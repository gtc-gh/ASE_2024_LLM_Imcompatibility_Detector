Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,"<android.bluetooth.BluetoothHeadset: boolean sendVendorSpecificResultCode(BluetoothDevice,String,String)>",30,31,"<android.bluetooth.BluetoothHeadset: boolean sendVendorSpecificResultCode(BluetoothDevice,String,String)>","<android.bluetooth.BluetoothHeadset: boolean sendVendorSpecificResultCode(BluetoothDevice,String,String)>",0,"{
    if (DBG) {
        log(""sendVendorSpecificResultCode()"");
    }
    if (command == null) {
        throw new IllegalArgumentException(""command is null"");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorSpecificResultCode(device, command, arg);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return false;
}","{
    if (DBG) {
        log(""sendVendorSpecificResultCode()"");
    }
    if (command == null) {
        throw new IllegalArgumentException(""command is null"");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorSpecificResultCode(device, command, arg, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return false;
}",1,"/**
 * Sends a vendor-specific unsolicited result code to the headset.
 *
 * <p>The actual string to be sent is <code>command + "": "" + arg</code>. For example, if {@code
 * command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg} is {@code ""0""}, the
 * string <code>""+ANDROID: 0""</code> will be sent.
 *
 * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset.
 * @param command A vendor-specific command.
 * @param arg The argument that will be attached to the command.
 * @return {@code false} if there is no headset connected, or if the command is not an allowed
 * vendor-specific unsolicited result code, or on error. {@code true} otherwise.
 * @throws IllegalArgumentException if {@code command} is {@code null}.
 */
","/**
 * Sends a vendor-specific unsolicited result code to the headset.
 *
 * <p>The actual string to be sent is <code>command + "": "" + arg</code>. For example, if {@code
 * command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg} is {@code ""0""}, the
 * string <code>""+ANDROID: 0""</code> will be sent.
 *
 * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.
 *
 * @param device Bluetooth headset.
 * @param command A vendor-specific command.
 * @param arg The argument that will be attached to the command.
 * @return {@code false} if there is no headset connected, or if the command is not an allowed
 * vendor-specific unsolicited result code, or on error. {@code true} otherwise.
 * @throws IllegalArgumentException if {@code command} is {@code null}.
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is the addition of `mAttributionSource` as a parameter to the method call `service.sendVendorSpecificResultCode`. This represents a change in the invocation of a dependent method (Dependent API changed). Aside from that, there are added annotations that specify permission requirements, but these annotations do not affect the method's behavior directly. So, the overall code change is classified as Other statement changed and Dependent API changed.","The change in the method signature itself does not lead to a compatibility issue, as the calling convention has not altered the expected behavior of the `sendVendorSpecificResultCode` methodâ€”assuming that `mAttributionSource` is correctly handled within the `service.sendVendorSpecificResultCode` method. No return value or exception handling behavior has changed within the `sendVendorSpecificResultCode` method itself. Therefore, there is no Compatibility Issue."
1,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>",30,31,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void hideSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingHideSoftInput) {
        Log.e(TAG, ""IME shouldn't call hideSoftInput on itself."" + "" Use requestHideSelf(int) itself"");
        return;
    }
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    applyVisibilityInInsetsConsumerIfNecessary(false);
    if (mIsPreRendered) {
        if (DEBUG) {
            Log.v(TAG, ""Making IME window invisible"");
        }
        setImeWindowStatus(IME_ACTIVE | IME_INVISIBLE, mBackDisposition);
        onPreRenderedWindowVisibilityChanged(false);
    } else {
        mShowInputFlags = 0;
        mShowInputRequested = false;
        doHideWindow();
    }
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""hideSoftInput()"");
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingHideSoftInput) {
        Log.e(TAG, ""IME shouldn't call hideSoftInput on itself."" + "" Use requestHideSelf(int) itself"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#hideSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.hideSoftInput"");
    applyVisibilityInInsetsConsumerIfNecessary(false);
    mShowInputFlags = 0;
    mShowInputRequested = false;
    doHideWindow();
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_HIDDEN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation removes the conditional logic related to `mIsPreRendered` and the related operations inside the if/else blocks, adds a new method call `ImeTracing.getInstance().triggerServiceDump(...)`, and uses `Trace.traceBegin(...)` and `Trace.traceEnd(...)` which were not present in the early version. The return statement has not been changed, but the logic for determining the visibility (`wasVisible` and `isVisible`) has changed because it no longer considers `mIsPreRendered`, `mDecorViewVisible`, and `mWindowVisible` for its state. This is a control dependency change since some conditions and branching logic have been removed, and other statements that perform operations related to tracing and logging have been added.","Even though the explicit `return` statement itself hasn't changed, there has been a removal of control dependency that could potentially affect the outcome of whether the input method window is hidden and what value the `resultReceiver.send(...)` method call sends back. Since the conditions under which the visibility state is checked have changed and methods related to the input window visibility (`doHideWindow()`) are invoked differently, this could potentially lead to the method returning a different result through the `ResultReceiver`, resulting in CI type 1."
2,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",30,31,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
3,<android.service.autofill.Dataset.Builder: Dataset build()>,30,31,<android.service.autofill.Dataset.Builder: Dataset build()>,<android.service.autofill.Dataset.Builder: Dataset build()>,0,"{
    throwIfDestroyed();
    mDestroyed = true;
    if (mFieldIds == null) {
        throw new IllegalStateException(""at least one value must be set"");
    }
    return new Dataset(this);
}","{
    throwIfDestroyed();
    mDestroyed = true;
    if (mFieldIds == null) {
        throw new IllegalStateException(""at least one value must be set"");
    }
    if (mFieldContent != null) {
        if (mFieldIds.size() > 1) {
            throw new IllegalStateException(""when filling content, only one field can be filled"");
        }
        if (mFieldValues.get(0) != null) {
            throw new IllegalStateException(""cannot fill both content and values"");
        }
    }
    return new Dataset(this);
}",1,"/**
 * Creates a new {@link Dataset} instance.
 *
 * <p>You should not interact with this builder once this method is called.
 *
 * @throws IllegalStateException if no field was set (through
 * {@link #setValue(AutofillId, AutofillValue)} or
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} or
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews, InlinePresentation)}),
 * or if {@link #build()} was already called.
 *
 * @return The built dataset.
 */
","/**
 * Creates a new {@link Dataset} instance.
 *
 * <p>You should not interact with this builder once this method is called.
 *
 * @throws IllegalStateException if no field was set (through
 * {@link #setValue(AutofillId, AutofillValue)} or
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews)} or
 * {@link #setValue(AutofillId, AutofillValue, RemoteViews, InlinePresentation)}),
 * or if {@link #build()} was already called.
 *
 * @return The built dataset.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"2,3","1,2","A new conditional block has been added, which throws an IllegalStateException if certain conditions are met. This will change the exception handling behavior of the API. The code change types are 2 for the new exceptions being thrown and 3 for the control dependency change because new conditions have been introduced.","The newly introduced conditional check can cause a new type of IllegalStateException to be thrown under certain conditions, which were not present in the early version. This is a change in the exception handling statement and can lead to a different exceptions being thrown, so the CI type is 2. Additionally, because of the new conditions checked before returning a Dataset, there is a potential for the method to not return a Dataset in cases where it previously would, which leads to a potential different return value, thus the CI type 1."
5,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,30,31,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingEnabled(boolean)>,0,"{
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Used to enable/disable periodic advertising. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingEnable()}.
 *
 * @param enable whether the periodic advertising should be enabled (true), or disabled
 * (false).
 */
","/**
 * Used to enable/disable periodic advertising. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingEnable()}.
 *
 * @param enable whether the periodic advertising should be enabled (true), or disabled
 * (false).
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method mGatt.setPeriodicAdvertisingEnable() has an additional parameter in the late version (mAttributionSource), which means that the dependent API has been changed, so the change type is 4,5.","There is no Compatibility Issue detected because the exception handling logic and the method's return type remain consistent between the two versions. The method implementation changes, but it does not affect the API's behavior from the caller's perspectiveâ€”it still handles the RemoteException in the same way by logging it. As a result, there is no CI caused by different return values or types, nor by different exception handlings."
6,<android.view.textclassifier.TextClassificationSession: boolean isDestroyed()>,30,31,<android.view.textclassifier.TextClassificationSession: boolean isDestroyed()>,<android.view.textclassifier.TextClassificationSession: boolean isDestroyed()>,0,"{
    return mDestroyed;
}","{
    synchronized (mLock) {
        return mDestroyed;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the inclusion of a synchronized block around the return statement, synchronized (mLock) {...}, which is an other statement change. The control flow and behavior of the method itself is unchanged as it always returns the value of mDestroyed.","Since the return value remains the same before and after the change, regardless of whether mDestroyed is accessed within a synchronized block or not, there is no Compatibility Issue. The synchronization is about thread safety, but does not affect the value being returned by the method. There is no change in what is returned or how exceptions are handled. Hence, the change does not lead to CI."
8,<android.widget.TextView: Typeface getTypeface()>,30,31,<android.widget.TextView: Typeface getTypeface()>,<android.widget.TextView: Typeface getTypeface()>,0,"{
    return mTextPaint.getTypeface();
}","{
    return mOriginalTypeface;
}",1,"/**
 * Gets the current {@link Typeface} that is used to style the text.
 * @return The current Typeface.
 *
 * @see #setTypeface(Typeface)
 *
 * @attr ref android.R.styleable#TextView_fontFamily
 * @attr ref android.R.styleable#TextView_typeface
 * @attr ref android.R.styleable#TextView_textStyle
 */
","/**
 * Gets the current {@link Typeface} that is used to style the text.
 * @return The current Typeface.
 *
 * @see #setTypeface(Typeface)
 *
 * @attr ref android.R.styleable#TextView_fontFamily
 * @attr ref android.R.styleable#TextView_typeface
 * @attr ref android.R.styleable#TextView_textStyle
 */
",-1,[@InspectableProperty],[@InspectableProperty],-1,-1,-1,-1,-1,-1,1,1,"The early version of the method returned the typeface from mTextPaint, whereas the late version returns mOriginalTypeface directly. This is a change in the return statement, so the code change type is 1.","As the method is now returning a potentially different Typeface object, this could lead to a different behavior when the API is called. There could be a different Typeface returned if mOriginalTypeface and mTextPaint.getTypeface() do not refer to the same object, hence the CI type is 1."
9,<android.view.autofill.AutofillManager: void notifyViewExitedLocked(View)>,30,31,<android.view.autofill.AutofillManager: void notifyViewExitedLocked(View)>,<android.view.autofill.AutofillManager: void notifyViewExitedLocked(View)>,0,"{
    ensureServiceClientAddedIfNeededLocked();
    if ((mEnabled || mEnabledForAugmentedAutofillOnly) && isActiveLocked()) {
        // dont notify exited when Activity is already in background
        if (!isClientDisablingEnterExitEvent()) {
            final AutofillId id = view.getAutofillId();
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}","{
    final boolean clientAdded = tryAddServiceClientIfNeededLocked();
    if (clientAdded && (mEnabled || mEnabledForAugmentedAutofillOnly) && isActiveLocked()) {
        // dont notify exited when Activity is already in background
        if (!isClientDisablingEnterExitEvent()) {
            final AutofillId id = view.getAutofillId();
            // Update focus on existing session.
            updateSessionLocked(id, null, null, ACTION_VIEW_EXITED, 0);
        }
    }
}",1,,,-1,"[@GuardedBy(""mLock"")]","[@GuardedBy(""mLock"")]",-1,-1,-1,-1,-1,-1,"3,4",0,"The call to `ensureServiceClientAddedIfNeededLocked()` is replaced with `tryAddServiceClientIfNeededLocked()` and the call's result stored in `clientAdded` variable which then determines the subsequent flow. This change includes a new variable declaration and a change in the control dependency since the subsequent block now depends also on the result of this new method call. Therefore, the change types are 3 and 4 (as it involves altering variables and control flow but not necessarily in a way that would affect outcomes directly).","Despite the introduction of a new method call and a variable that checks its result, as long as `tryAddServiceClientIfNeededLocked()` serves a similar purpose to `ensureServiceClientAddedIfNeededLocked()`, such as trying to add a service client and returning a boolean indicating success, and since the late version remains within the same condition `(mEnabled || mEnabledForAugmentedAutofillOnly) && isActiveLocked()`, it's not a compatibility issue as it does not inherently change the behavior of the method with respect to the return values or the exceptions thrown. Thus, there should be no compatibility issue, as the caller of the method will not observe any different behavior provided the intent and outcome of `tryAddServiceClientIfNeededLocked()` are functionally equivalent to `ensureServiceClientAddedIfNeededLocked()`."
10,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,30,31,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,<android.app.Activity: void startLocalVoiceInteraction(Bundle)>,0,"{
    try {
        ActivityTaskManager.getService().startLocalVoiceInteraction(mToken, privateOptions);
    } catch (RemoteException re) {
    }
}","{
    ActivityClient.getInstance().startLocalVoiceInteraction(mToken, privateOptions);
}",1,"/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
","/**
 * Starts a local voice interaction session. When ready,
 * {@link #onLocalVoiceInteractionStarted()} is called. You can pass a bundle of private options
 * to the registered voice interaction service.
 * @param privateOptions a Bundle of private arguments to the current voice interaction service
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to initiate the voice interaction has changed from ActivityTaskManager.getService().startLocalVoiceInteraction(...) to ActivityClient.getInstance().startLocalVoiceInteraction(...), which indicates a change in the dependent API. The change type is 5.","The implementation of starting a voice interaction has been modified to use a different class, but as the catch block for RemoteException is empty, and exception handling has not changed, and there is no actual behavior change described, so there is no compatibility issue detected as it stands, resulting in CI type 0."
11,<android.view.Display: DisplayCutout getCutout()>,30,31,<android.view.Display: DisplayCutout getCutout()>,<android.view.Display: DisplayCutout getCutout()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getDisplayCutout(mDisplayInfo.displayCutout) : mDisplayInfo.displayCutout;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getDisplayCutout(mDisplayInfo.displayCutout) : mDisplayInfo.displayCutout;
    }
}",1,"/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
","/**
 * Returns the {@link DisplayCutout}, or {@code null} if there is none.
 *
 * @see DisplayCutout
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The only code change is the switch from using `this` to using `mLock` as the object to synchronize on. Since the internal logic has not changed, the method still returns the same value based on the same conditions; therefore, the code change type is 4 (Other statement changed).",There is no Compatibility Issue as the return value is still determined by the same conditions and the execution flow of the method has not been altered.
12,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,30,31,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean writeCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""writeCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The late version of the code adds an additional parameter `mAttributionSource` to the method `mService.writeCharacteristic()`. There are also new annotations that specify permissions required for the API. However, since the core functionality of the method does not seem to change and these permissions checks are likely enforced at a higher level, the presence of permissions annotations is categorized under 'Other statement changed'. The main code change is categorized as a 'Dependent API changed' due to the change in parameters for the called method.","The addition of the `mAttributionSource` parameter in the call to `mService.writeCharacteristic` does not affect the return value or the exceptions thrown by the `writeCharacteristic` method itself. The method still returns `true` if the operation is successful, `false` otherwise, and potential exceptions are handled in the same way, with RemoteException being caught and logged. Therefore, there is no Compatibility Issue in terms of observable behavior from the API's perspective."
13,<android.net.LocalSocketImpl.SocketInputStream: int available()>,30,31,<android.net.LocalSocketImpl.SocketInputStream: int available()>,<android.net.LocalSocketImpl.SocketInputStream: int available()>,0,"{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    Int32Ref avail = new Int32Ref(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}","{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException(""socket closed"");
    try {
        return Os.ioctlInt(myFd, OsConstants.FIONREAD);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The code change includes removing the instantiation of the Int32Ref object and the direct return of the ioctlInt method's result instead of getting the value from the reference. Additionally, the signature of the method Os.ioctlInt has changed; the late version does not include the Int32Ref parameter. Hence, the code changes belong to types 1 (because of return value change), 4 (instantiation of Int32Ref removed), and 5 (signature of Os.ioctlInt changed).","There is a CI caused by potentially different return values due to the return statement's change from returning avail.value to directly returning the result of the ioctlInt method. This implies the late version of the API may return a different result than the early version, so the CI type is 1."
14,<android.view.Display.Mode: boolean equals(Object)>,30,31,<android.view.Display.Mode: boolean equals(Object)>,<android.view.Display.Mode: boolean equals(Object)>,0,"{
    if (this == other) {
        return true;
    }
    if (!(other instanceof Mode)) {
        return false;
    }
    Mode that = (Mode) other;
    return mModeId == that.mModeId && matches(that.mWidth, that.mHeight, that.mRefreshRate);
}","{
    if (this == other) {
        return true;
    }
    if (!(other instanceof Mode)) {
        return false;
    }
    Mode that = (Mode) other;
    return mModeId == that.mModeId && matches(that.mWidth, that.mHeight, that.mRefreshRate) && Arrays.equals(mAlternativeRefreshRates, that.mAlternativeRefreshRates);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional condition to check equality on the array `mAlternativeRefreshRates` has been added in the return statement, so the code change type is 4.","The added condition in the return statement could potentially lead the method to return false where previously it would have returned true. If the two Mode objects have the same `mModeId`, and match on `mWidth`, `mHeight`, and `mRefreshRate` but not on `mAlternativeRefreshRates`, in earlier versions the method would have returned true, but in the current version, it will return false. This is why the CI type is 1."
16,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,30,31,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,4,0,"The change is only related to reordering parameters and adding an additional inline comment (/*excludedPermissions=*/) without altering the behavior of the method, so the code change type is 4.","The change does not affect the method's behavior from an external point of view (i.e., the signature, the returned value, and the exceptions thrown remain the same). Therefore, there is no Compatibility Issue, and the CI type is 0."
18,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",30,31,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeTypeFilter, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeTypeFilter, ""mimeTypeFilter"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mAttributionSource, uri, mimeTypeFilter, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,,,-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The method `openTypedAssetFile` in the late version uses `mAttributionSource` instead of `mPackageName, mAttributionTag` as its parameters. Thus, there were changes to the dependent API invoked within the method which is a change type 5.","There is no compatibility issue arising from the change because the behaviour of the method `openTypedAssetFile` from an external point of view should remain consistent as long as `mAttributionSource` correctly encapsulates `mPackageName` and `mAttributionTag`. The change in parameters is internal to the implementation of the API and should not affect how the API behaves externally when called by existing client code. Hence, there is no compatibility issue, which is a CI type 0."
19,<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean hasActiveConnection(View)>,30,31,<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean hasActiveConnection(View)>,<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean hasActiveConnection(View)>,0,"{
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return false;
        }
        return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.isActive() && mServedInputConnectionWrapper.mServedView.get() == view;
    }
}","{
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentInputMethodSession == null) {
            return false;
        }
        return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.isActive() && mServedInputConnectionWrapper.getServedView() == view;
    }
}",1,"/**
 * Checks whether the active input connection (if any) is for the given view.
 *
 * TODO(b/160968797): Remove this method and move mServedInputConnectionWrapper to
 * ImeFocusController.
 *
 * Note that this method is only intended for restarting input after focus gain
 * (e.g. b/160391516), DO NOT leverage this method to do another check.
 */
","/**
 * Checks whether the active input connection (if any) is for the given view.
 *
 * TODO(b/182259171): Clean-up hasActiveConnection to simplify the logic.
 *
 * Note that this method is only intended for restarting input after focus gain
 * (e.g. b/160391516), DO NOT leverage this method to do another check.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed, as there's an additional check (mCurrentInputMethodSession == null) in the if statement. The method call within the return statement has been modified from a direct field access (mServedInputConnectionWrapper.mServedView.get()) to a method call (mServedInputConnectionWrapper.getServedView()). The control dependency change is classified as 3 and the method call change as 4.","Although there are changes within the control dependency and a method call, they do not lead to a Compatibility Issue. The new check for mCurrentInputMethodSession being null will prevent the method from returning true when it should not, which maintains the contract of hasActiveConnection(view). The change from direct field access to a method call does not by itself change the logic of the method; assuming getServedView() and mServedView.get() have the same logic, the return value of the method will remain the same. Thus, there is No Compatibility Issue, classified as 0."
20,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",30,31,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,int,BroadcastReceiver,Handler,int,String,Bundle,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        appOp, options, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the method's implementation is the replacement of `appOp` with `null` in the parameter list of the `broadcastIntentWithFeature` method call. Hence, the code change type is 4.","The change in the parameter value from `appOp` to null does not indicate that there will be different return values or types nor a different exception handling, as ""appOp"" seems to be a parameter related to app operations. Assuming `appOp` is meant to be an application operation code and replacing it with `null` implies a change in behavior, it does not affect the returning value or exception thrown by the method `sendOrderedBroadcast` itself. Therefore, there is no Compatibility Issue in this context."
21,"<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>",30,31,"<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>",0,"{
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        int a = start;
        int b = end;
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        // Clip the end points to be within the content bounds.
        final int length = content.length();
        if (a < 0)
            a = 0;
        if (b < 0)
            b = 0;
        if (a > length)
            a = length;
        if (b > length)
            b = length;
        ensureDefaultComposingSpans();
        if (mDefaultComposingSpans != null) {
            for (int i = 0; i < mDefaultComposingSpans.length; ++i) {
                content.setSpan(mDefaultComposingSpans[i], a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
            }
        }
        content.setSpan(COMPOSING, a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
        // Note: sendCurrentText does nothing unless mDummyMode is set
        sendCurrentText();
        endBatchEdit();
    }
    return true;
}","{
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        int a = start;
        int b = end;
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        // Clip the end points to be within the content bounds.
        final int length = content.length();
        if (a < 0)
            a = 0;
        if (b < 0)
            b = 0;
        if (a > length)
            a = length;
        if (b > length)
            b = length;
        ensureDefaultComposingSpans();
        if (mDefaultComposingSpans != null) {
            for (int i = 0; i < mDefaultComposingSpans.length; ++i) {
                content.setSpan(mDefaultComposingSpans[i], a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
            }
        }
        content.setSpan(COMPOSING, a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
        // Note: sendCurrentText does nothing unless mFallbackMode is set
        sendCurrentText();
        endBatchEdit();
        endComposingRegionEditInternal();
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new method call endComposingRegionEditInternal() has been added in the last part of the code before returning true. This is identified as an ""Other statement changed"" type of code change.","The addition of endComposingRegionEditInternal() in the late version does not affect the returned value nor does it introduce a new exception throwing condition. The implementation consistently returns true in both versions, and there is no indication based on the given implementation that new exceptions could be thrown. Therefore, there is no Compatibility Issue for this API based on the changes."
22,"<android.speech.tts.TextToSpeech: int addEarcon(String,File)>",30,31,"<android.speech.tts.TextToSpeech: int addEarcon(String,File)>","<android.speech.tts.TextToSpeech: int addEarcon(String,File)>",0,"{
    synchronized (mStartLock) {
        mEarcons.put(earcon, Uri.fromFile(file));
        return SUCCESS;
    }
}","{
    return addEarcon(earcon, Uri.fromFile(file));
}",1,"/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param file
 * File object pointing to the sound file.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param file
 * File object pointing to the sound file.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The late version replaces the entire code block within synchronized(mStartLock) with a call to another method 'addEarcon(earcon, Uri.fromFile(file))'. This constitutes a change in implementation while using a dependent API, hence the change types are 4 (Other statement changed) and 5 (Dependent API changed).","There is no Compatibility Issue here because the high-level behavior of the method, which is to add an earcon, remains unchanged. The method still returns the same SUCCESS constant assuming the called method 'addEarcon' with the URI parameter performs the same action internally as the earlier implementation."
23,<android.animation.AnimatorSet: AnimatorSet clone()>,30,31,<android.animation.AnimatorSet: AnimatorSet clone()>,<android.animation.AnimatorSet: AnimatorSet clone()>,0,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mStarted = false;
    anim.mLastFrameTime = -1;
    anim.mFirstFrame = -1;
    anim.mLastEventId = -1;
    anim.mPaused = false;
    anim.mPauseTime = -1;
    anim.mSeekState = new SeekState();
    anim.mSelfPulse = true;
    anim.mPlayingSet = new ArrayList<Node>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mEvents = new ArrayList<AnimationEvent>();
    anim.mDummyListener = new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            if (anim.mNodeMap.get(animation) == null) {
                throw new AndroidRuntimeException(""Error: animation ended is not in the node"" + "" map"");
            }
            anim.mNodeMap.get(animation).mEnded = true;
        }
    };
    anim.mReversing = false;
    anim.mDependencyDirty = true;
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    HashMap<Node, Node> clonesMap = new HashMap<>(nodeCount);
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        // Remove the old internal listener from the cloned child
        nodeClone.mAnimation.removeListener(mDummyListener);
        clonesMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.mAnimation, nodeClone);
    }
    anim.mRootNode = clonesMap.get(mRootNode);
    anim.mDelayAnim = (ValueAnimator) anim.mRootNode.mAnimation;
    // dependencies, mapping the old dependencies to the new nodes
    for (int i = 0; i < nodeCount; i++) {
        Node node = mNodes.get(i);
        // Update dependencies for node's clone
        Node nodeClone = clonesMap.get(node);
        nodeClone.mLatestParent = node.mLatestParent == null ? null : clonesMap.get(node.mLatestParent);
        int size = node.mChildNodes == null ? 0 : node.mChildNodes.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mChildNodes.set(j, clonesMap.get(node.mChildNodes.get(j)));
        }
        size = node.mSiblings == null ? 0 : node.mSiblings.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mSiblings.set(j, clonesMap.get(node.mSiblings.get(j)));
        }
        size = node.mParents == null ? 0 : node.mParents.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mParents.set(j, clonesMap.get(node.mParents.get(j)));
        }
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    final int nodeCount = mNodes.size();
    anim.mStarted = false;
    anim.mLastFrameTime = -1;
    anim.mFirstFrame = -1;
    anim.mLastEventId = -1;
    anim.mPaused = false;
    anim.mPauseTime = -1;
    anim.mSeekState = new SeekState();
    anim.mSelfPulse = true;
    anim.mPlayingSet = new ArrayList<Node>();
    anim.mNodeMap = new ArrayMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>(nodeCount);
    anim.mEvents = new ArrayList<AnimationEvent>();
    anim.mAnimationEndListener = new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            if (anim.mNodeMap.get(animation) == null) {
                throw new AndroidRuntimeException(""Error: animation ended is not in the node"" + "" map"");
            }
            anim.mNodeMap.get(animation).mEnded = true;
        }
    };
    anim.mReversing = false;
    anim.mDependencyDirty = true;
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    HashMap<Node, Node> clonesMap = new HashMap<>(nodeCount);
    for (int n = 0; n < nodeCount; n++) {
        final Node node = mNodes.get(n);
        Node nodeClone = node.clone();
        // Remove the old internal listener from the cloned child
        nodeClone.mAnimation.removeListener(mAnimationEndListener);
        clonesMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.mAnimation, nodeClone);
    }
    anim.mRootNode = clonesMap.get(mRootNode);
    anim.mDelayAnim = (ValueAnimator) anim.mRootNode.mAnimation;
    // dependencies, mapping the old dependencies to the new nodes
    for (int i = 0; i < nodeCount; i++) {
        Node node = mNodes.get(i);
        // Update dependencies for node's clone
        Node nodeClone = clonesMap.get(node);
        nodeClone.mLatestParent = node.mLatestParent == null ? null : clonesMap.get(node.mLatestParent);
        int size = node.mChildNodes == null ? 0 : node.mChildNodes.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mChildNodes.set(j, clonesMap.get(node.mChildNodes.get(j)));
        }
        size = node.mSiblings == null ? 0 : node.mSiblings.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mSiblings.set(j, clonesMap.get(node.mSiblings.get(j)));
        }
        size = node.mParents == null ? 0 : node.mParents.size();
        for (int j = 0; j < size; j++) {
            nodeClone.mParents.set(j, clonesMap.get(node.mParents.get(j)));
        }
    }
    return anim;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
24,<android.content.Intent: Intent putExtras(Intent)>,30,31,<android.content.Intent: Intent putExtras(Intent)>,<android.content.Intent: Intent putExtras(Intent)>,0,"{
    if (src.mExtras != null) {
        if (mExtras == null) {
            mExtras = new Bundle(src.mExtras);
        } else {
            mExtras.putAll(src.mExtras);
        }
    }
    return this;
}","{
    if (src.mExtras != null) {
        if (mExtras == null) {
            mExtras = new Bundle(src.mExtras);
        } else {
            mExtras.putAll(src.mExtras);
        }
    }
    // process.
    if ((src.mLocalFlags & LOCAL_FLAG_FROM_PARCEL) != 0 && (src.mLocalFlags & LOCAL_FLAG_FROM_PROTECTED_COMPONENT) == 0) {
        mLocalFlags |= LOCAL_FLAG_UNFILTERED_EXTRAS;
    }
    return this;
}",1,"/**
 * Copy all extras in 'src' in to this intent.
 *
 * @param src Contains the extras to copy.
 *
 * @see #putExtra
 */
","/**
 * Copy all extras in 'src' in to this intent.
 *
 * @param src Contains the extras to copy.
 *
 * @see #putExtra
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"An additional control statement and other statements are added that modify the 'mLocalFlags'; therefore, the changes involve both control dependency and other statements. Hence, the code change types are 3,4.","No Compatibility Issue is detected because the new code only alters the flags that will be used internally (mLocalFlags). It does not affect the return value or exception handling of the 'putExtras' API. The API signature remains the same, and the returned 'Intent' is the same instance as 'this', thus there is no change in the return type or the value of the return statement that would affect the API compatibility."
26,"<android.app.AppOpsManager: void startWatchingActive(String[],Executor,OnOpActiveChangedListener)>",30,31,"<android.app.AppOpsManager: void startWatchingActive(String[],Executor,OnOpActiveChangedListener)>","<android.app.AppOpsManager: void startWatchingActive(String[],Executor,OnOpActiveChangedListener)>",0,"{
    Objects.requireNonNull(ops);
    Objects.requireNonNull(executor);
    Objects.requireNonNull(callback);
    IAppOpsActiveCallback cb;
    synchronized (mActiveWatchers) {
        cb = mActiveWatchers.get(callback);
        if (cb != null) {
            return;
        }
        cb = new IAppOpsActiveCallback.Stub() {

            @Override
            public void opActiveChanged(int op, int uid, String packageName, boolean active) {
                executor.execute(() -> {
                    if (callback instanceof OnOpActiveChangedInternalListener) {
                        ((OnOpActiveChangedInternalListener) callback).onOpActiveChanged(op, uid, packageName, active);
                    }
                    if (sOpToString[op] != null) {
                        callback.onOpActiveChanged(sOpToString[op], uid, packageName, active);
                    }
                });
            }
        };
        mActiveWatchers.put(callback, cb);
    }
    final int[] rawOps = new int[ops.length];
    for (int i = 0; i < ops.length; i++) {
        rawOps[i] = strOpToOp(ops[i]);
    }
    try {
        mService.startWatchingActive(rawOps, cb);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Objects.requireNonNull(ops);
    Objects.requireNonNull(executor);
    Objects.requireNonNull(callback);
    IAppOpsActiveCallback cb;
    synchronized (mActiveWatchers) {
        cb = mActiveWatchers.get(callback);
        if (cb != null) {
            return;
        }
        cb = new IAppOpsActiveCallback.Stub() {

            @Override
            public void opActiveChanged(int op, int uid, String packageName, String attributionTag, boolean active, @AttributionFlags int attributionFlags, int attributionChainId) {
                executor.execute(() -> {
                    if (callback instanceof OnOpActiveChangedInternalListener) {
                        ((OnOpActiveChangedInternalListener) callback).onOpActiveChanged(op, uid, packageName, active);
                    }
                    if (sOpToString[op] != null) {
                        callback.onOpActiveChanged(sOpToString[op], uid, packageName, attributionTag, active, attributionFlags, attributionChainId);
                    }
                });
            }
        };
        mActiveWatchers.put(callback, cb);
    }
    final int[] rawOps = new int[ops.length];
    for (int i = 0; i < ops.length; i++) {
        rawOps[i] = strOpToOp(ops[i]);
    }
    try {
        mService.startWatchingActive(rawOps, cb);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"// @RequiresPermission(value=Manifest.permission.WATCH_APPOPS, conditional=true)
","// @RequiresPermission(value=Manifest.permission.WATCH_APPOPS, conditional=true)
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The signature of the method inside the anonymous class `IAppOpsActiveCallback.Stub()` has been changed. The method `opActiveChanged` has additional parameters in the late version, which is a change to a dependent API, thus the change type includes 5. This change to the method signature also constitutes ""other statement changed"" because it's not a control dependency, return statement, or an exception handling statement change, hence the change type is 4.","Even though the method `opActiveChanged` is changed, the actual external behavior of the `startWatchingActive` method is unchanged because it is an internal callback implementation that may handle the arguments differently, but does not affect the public contract of the `startWatchingActive` method. However, the late version's `opActiveChanged` method now calls the callback with additional arguments if `sOpToString[op] != null`, which could lead to a different behavior that the client of the API might observe. As such, there is the potential for a compatibility issue due to different return values or types, making the CI type 1."
28,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",30,31,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>","<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",0,"{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, null, null, null, null, 0, null, null);
    context.setResources(createResources(null, packageInfo, null, displayId, null, packageInfo.getCompatibilityInfo(), null));
    context.updateDisplay(displayId);
    context.mIsSystemOrSystemUiContext = true;
    return context;
}","{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, null);
    context.setResources(createResources(null, packageInfo, null, displayId, null, packageInfo.getCompatibilityInfo(), null));
    context.updateDisplay(displayId);
    context.mContextType = CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI;
    return context;
}",1,"/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
","/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The instantiation of `ContextImpl` and the setting of `mIsSystemOrSystemUiContext` have been changed. The constructor for `ContextImpl` used in the late version has an additional parameter `ContextParams.EMPTY`. Furthermore, instead of using `mIsSystemOrSystemUiContext`, the late version uses `mContextType = CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI`. These constitute an `Other statement changed` category since they neither affect the return value directly nor change exception handling. Additionally, `Dependent API changed` because the constructor parameters and used methods have been modified.","Even though there are statement changes, they don't seem to affect the return value or exception handling. It's assumed that the changes to how context flags are set (`mIsSystemOrSystemUiContext` vs. `mContextType`) are functionally equivalent but simply reflect an internal refactoring. Therefore, it does not result in a compatibility issue unless the external behavior of `createSystemUiContext()` is impacted by these internal changes, which cannot be determined without additional context. Hence, we will assume no compatibility issue until proven otherwise."
29,"<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>",30,31,"<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>","<android.content.res.Resources.Theme: boolean resolveAttribute(int,TypedValue,boolean)>",0,"{
    return mThemeImpl.resolveAttribute(resid, outValue, resolveRefs);
}","{
    synchronized (mLock) {
        return mThemeImpl.resolveAttribute(resid, outValue, resolveRefs);
    }
}",1,"/**
 * Retrieve the value of an attribute in the Theme.  The contents of
 * <var>outValue</var> are ultimately filled in by
 * {@link Resources#getValue}.
 *
 * @param resid The resource identifier of the desired theme
 * attribute.
 * @param outValue Filled in with the ultimate resource value supplied
 * by the attribute.
 * @param resolveRefs If true, resource references will be walked; if
 * false, <var>outValue</var> may be a
 * TYPE_REFERENCE.  In either case, it will never
 * be a TYPE_ATTRIBUTE.
 *
 * @return boolean Returns true if the attribute was found and
 * <var>outValue</var> is valid, else false.
 */
","/**
 * Retrieve the value of an attribute in the Theme.  The contents of
 * <var>outValue</var> are ultimately filled in by
 * {@link Resources#getValue}.
 *
 * @param resid The resource identifier of the desired theme
 * attribute.
 * @param outValue Filled in with the ultimate resource value supplied
 * by the attribute.
 * @param resolveRefs If true, resource references will be walked; if
 * false, <var>outValue</var> may be a
 * TYPE_REFERENCE.  In either case, it will never
 * be a TYPE_ATTRIBUTE.
 *
 * @return boolean Returns true if the attribute was found and
 * <var>outValue</var> is valid, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The implementation now wraps the return statement with a synchronized block, but the logic within the block remains the same. The only change is in adding thread-safety, so the code change type is 3 (Control dependency change).","The change does not affect the behavior of the API in terms of what it returns or the exceptions it might throw; it only affects the thread-safety of the operation. Therefore, there is no Compatibility Issue, and the CI type is 0."
30,<android.view.WindowInsets.Type: String toString(int)>,30,31,<android.view.WindowInsets.Type: String toString(int)>,<android.view.WindowInsets.Type: String toString(int)>,0,"{
    StringBuilder result = new StringBuilder();
    if ((types & STATUS_BARS) != 0) {
        result.append(""statusBars |"");
    }
    if ((types & NAVIGATION_BARS) != 0) {
        result.append(""navigationBars |"");
    }
    if ((types & IME) != 0) {
        result.append(""ime |"");
    }
    if ((types & SYSTEM_GESTURES) != 0) {
        result.append(""systemGestures |"");
    }
    if ((types & MANDATORY_SYSTEM_GESTURES) != 0) {
        result.append(""mandatorySystemGestures |"");
    }
    if ((types & TAPPABLE_ELEMENT) != 0) {
        result.append(""tappableElement |"");
    }
    if ((types & DISPLAY_CUTOUT) != 0) {
        result.append(""displayCutout |"");
    }
    if ((types & WINDOW_DECOR) != 0) {
        result.append(""windowDecor |"");
    }
    if (result.length() > 0) {
        result.delete(result.length() - 2, result.length());
    }
    return result.toString();
}","{
    StringBuilder result = new StringBuilder();
    if ((types & STATUS_BARS) != 0) {
        result.append(""statusBars |"");
    }
    if ((types & NAVIGATION_BARS) != 0) {
        result.append(""navigationBars |"");
    }
    if ((types & CAPTION_BAR) != 0) {
        result.append(""captionBar |"");
    }
    if ((types & IME) != 0) {
        result.append(""ime |"");
    }
    if ((types & SYSTEM_GESTURES) != 0) {
        result.append(""systemGestures |"");
    }
    if ((types & MANDATORY_SYSTEM_GESTURES) != 0) {
        result.append(""mandatorySystemGestures |"");
    }
    if ((types & TAPPABLE_ELEMENT) != 0) {
        result.append(""tappableElement |"");
    }
    if ((types & DISPLAY_CUTOUT) != 0) {
        result.append(""displayCutout |"");
    }
    if ((types & WINDOW_DECOR) != 0) {
        result.append(""windowDecor |"");
    }
    if (result.length() > 0) {
        result.delete(result.length() - 2, result.length());
    }
    return result.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is an added condition `if ((types & CAPTION_BAR) != 0)` in the late implementation that appends ""captionBar |"" to the result. Additionally, there's no corresponding condition in the early implementation. This results in a change in control dependency and a potential difference in the return value. Hence, the code change type is 1,3.","The addition of a new condition that appends ""captionBar |"" to the result string can lead to the API returning a different value if the `types` variable includes `CAPTION_BAR`. This is a compatibility issue of type 1, caused by a potential different return value."
31,<android.widget.TextView: boolean onTextContextMenuItem(int)>,30,31,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            final boolean hadSelection = hasSelection();
            selectAllText();
            if (mEditor != null && hadSelection) {
                mEditor.invalidateActionModeAsync();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            final ClipData cutData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(cutData)) {
                deleteText_internal(min, max);
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_COPY:
            // For link action mode in a non-selectable/non-focusable TextView,
            // make sure that we set the appropriate min/max.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            min = Math.max(0, Math.min(selStart, selEnd));
            max = Math.max(0, Math.max(selStart, selEnd));
            final ClipData copyData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(copyData)) {
                stopTextActionMode();
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
        case ID_AUTOFILL:
            requestAutofill();
            stopTextActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            final boolean hadSelection = hasSelection();
            selectAllText();
            if (mEditor != null && hadSelection) {
                mEditor.invalidateActionModeAsync();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(false);
            return true;
        case ID_CUT:
            final ClipData cutData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(cutData)) {
                deleteText_internal(min, max);
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_COPY:
            // For link action mode in a non-selectable/non-focusable TextView,
            // make sure that we set the appropriate min/max.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            min = Math.max(0, Math.min(selStart, selEnd));
            max = Math.max(0, Math.max(selStart, selEnd));
            final ClipData copyData = ClipData.newPlainText(null, getTransformedText(min, max));
            if (setPrimaryClip(copyData)) {
                stopTextActionMode();
            } else {
                Toast.makeText(getContext(), com.android.internal.R.string.failed_to_copy_to_clipboard, Toast.LENGTH_SHORT).show();
            }
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
        case ID_AUTOFILL:
            requestAutofill();
            stopTextActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
33,"<android.view.textservice.SpellCheckerSession: void getSuggestions(TextInfo[],int,boolean)>",30,31,"<android.view.textservice.SpellCheckerSession: void getSuggestions(TextInfo[],int,boolean)>","<android.view.textservice.SpellCheckerSession: void getSuggestions(TextInfo[],int,boolean)>",0,"{
    if (DBG) {
        Log.w(TAG, ""getSuggestions from "" + mSpellCheckerInfo.getId());
    }
    mSpellCheckerSessionListenerImpl.getSuggestionsMultiple(textInfos, suggestionsLimit, sequentialWords);
}","{
    if (DBG) {
        Log.w(TAG, ""getSuggestions from "" + mSpellCheckerInfo.getId());
    }
    final InputMethodManager imm = mTextServicesManager.getInputMethodManager();
    if (imm != null && imm.isInputMethodSuppressingSpellChecker()) {
        handleOnGetSuggestionsMultiple(new SuggestionsInfo[0]);
        return;
    }
    mSpellCheckerSessionListenerImpl.getSuggestionsMultiple(textInfos, suggestionsLimit, sequentialWords);
}",1,"/**
 * A batch process of getSuggestions
 * @param textInfos an array of text metadata for a spell checker
 * @param suggestionsLimit the maximum number of suggestions that will be returned
 * @param sequentialWords true if textInfos can be treated as sequential words.
 * @deprecated use {@link SpellCheckerSession#getSentenceSuggestions(TextInfo[], int)} instead
 */
","/**
 * A batch process of getSuggestions
 * @param textInfos an array of text metadata for a spell checker
 * @param suggestionsLimit the maximum number of suggestions that will be returned
 * @param sequentialWords true if textInfos can be treated as sequential words.
 * @deprecated use {@link SpellCheckerSession#getSentenceSuggestions(TextInfo[], int)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5",1,"There is a new block of code that adds a check for whether the input method is suppressing the spell checker, which is a control dependency change, type 3. Furthermore, this introduces a new possible behavior with an early return statement (return;), which is a return statement change, type 1. This change in behavior is also due to the invocation of a new dependent API mTextServicesManager.getInputMethodManager() and imm.isInputMethodSuppressingSpellChecker(), which is classified as a dependent API change, type 5.","This new early exit with handleOnGetSuggestionsMultiple(new SuggestionsInfo[0]) will change the behavior of the method by potentially returning different results when the condition imm.isInputMethodSuppressingSpellChecker() is true, resulting in no suggestions being provided when the spell checker is suppressed. This indicates a compatibility issue since the method now may return an empty array of SuggestionsInfo instead of the actual suggestions, which is a type 1 CI caused by potential different return values."
34,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,30,31,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,<android.hardware.camera2.params.StreamConfigurationMap: boolean isOutputSupportedFor(Surface)>,0,"{
    Objects.requireNonNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace == HAL_DATASPACE_DEPTH ? mDepthConfigurations : surfaceDataspace == HAL_DATASPACE_DYNAMIC_DEPTH ? mDynamicDepthConfigurations : surfaceDataspace == HAL_DATASPACE_HEIF ? mHeicConfigurations : mConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}","{
    Objects.requireNonNull(surface, ""surface must not be null"");
    Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);
    int surfaceFormat = SurfaceUtils.getSurfaceFormat(surface);
    int surfaceDataspace = SurfaceUtils.getSurfaceDataspace(surface);
    // See if consumer is flexible.
    boolean isFlexible = SurfaceUtils.isFlexibleConsumer(surface);
    StreamConfiguration[] configs = surfaceDataspace == HAL_DATASPACE_DEPTH ? mDepthConfigurations : surfaceDataspace == HAL_DATASPACE_DYNAMIC_DEPTH ? mDynamicDepthConfigurations : surfaceDataspace == HAL_DATASPACE_HEIF ? mHeicConfigurations : mConfigurations;
    for (StreamConfiguration config : configs) {
        if (config.getFormat() == surfaceFormat && config.isOutput()) {
            // and a size no bigger than MAX_DIMEN_FOR_ROUNDING
            if (config.getSize().equals(surfaceSize)) {
                return true;
            } else if (isFlexible && (config.getSize().getWidth() <= MAX_DIMEN_FOR_ROUNDING)) {
                return true;
            }
        }
    }
    return false;
}",1,"/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
","/**
 * Determine whether or not the {@code surface} in its current state is suitable to be included
 * in a {@link CameraDevice#createCaptureSession capture session} as an output.
 *
 * <p>Not all surfaces are usable with the {@link CameraDevice}, and not all configurations
 * of that {@code surface} are compatible. Some classes that provide the {@code surface} are
 * compatible with the {@link CameraDevice} in general
 * (see {@link #isOutputSupportedFor(Class)}, but it is the caller's responsibility to put the
 * {@code surface} into a state that will be compatible with the {@link CameraDevice}.</p>
 *
 * <p>Reasons for a {@code surface} being specifically incompatible might be:
 * <ul>
 * <li>Using a format that's not listed by {@link #getOutputFormats}
 * <li>Using a format/size combination that's not listed by {@link #getOutputSizes}
 * <li>The {@code surface} itself is not in a state where it can service a new producer.</p>
 * </li>
 * </ul>
 *
 * <p>Surfaces from flexible sources will return true even if the exact size of the Surface does
 * not match a camera-supported size, as long as the format (or class) is supported and the
 * camera device supports a size that is equal to or less than 1080p in that format. If such as
 * Surface is used to create a capture session, it will have its size rounded to the nearest
 * supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture,
 * and ImageReader.</p>
 *
 * <p>This is not an exhaustive list; see the particular class's documentation for further
 * possible reasons of incompatibility.</p>
 *
 * @param surface a non-{@code null} {@link Surface} object reference
 * @return {@code true} if this is supported, {@code false} otherwise
 *
 * @throws NullPointerException if {@code surface} was {@code null}
 * @throws IllegalArgumentException if the Surface endpoint is no longer valid
 *
 * @see CameraDevice#createCaptureSession
 * @see #isOutputSupportedFor(Class)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constant `LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING` is replaced by `MAX_DIMEN_FOR_ROUNDING` in the condition of the if statement inside the loop, which is an other statement change (4). Since the qualifier of the constant is removed, it indicates that there could be a change in the constant's definition (such as moving it to a different class or making it accessible without requiring the class name). Thus, it also suggests a change in a dependent API (5).","There is no Compatibility Issue because the replacement of `LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING` with `MAX_DIMEN_FOR_ROUNDING` will not change the behavior as long as the value of `MAX_DIMEN_FOR_ROUNDING` is the same as the value of `LegacyCameraDevice.MAX_DIMEN_FOR_ROUNDING`. Since the constant's value is unlikely to have been changed with this alteration, the output of the function will remain the same given the same input conditions."
37,<android.accessibilityservice.AccessibilityService: void disableSelf()>,30,31,<android.accessibilityservice.AccessibilityService: void disableSelf()>,<android.accessibilityservice.AccessibilityService: void disableSelf()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.disableSelf();
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.disableSelf();
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}",1,"/**
 * Disables the service. After calling this method, the service will be disabled and settings
 * will show that it is turned off.
 */
","/**
 * Disables the service. After calling this method, the service will be disabled and settings
 * will show that it is turned off.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only code change is in the usage of 'getInstance()' method where the later version passes 'this' as an argument (getInstance(this)) whereas the early version does not pass any argument. This implies a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue detected because the exception handling, control flow, and the return statements remain the same. The change inside of 'getInstance()' does not directly affect the return value or the exceptions thrown by 'disableSelf()' method in the scope of this API. Therefore, no CI is detected."
38,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,30,31,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method `service.getDevicesMatchingConnectionStates(states)` in the return statement is now wrapped by `Attributable.setAttributionSource(...)` which introduces a dependent API change, but the change itself doesn't imply that the return type or the returned value from the method has been altered. Therefore, the change type is 4,5 (Other statement changed, Dependent API changed).","There are no changes to the return statement structure, exception handling, or control flow that would lead to a difference in the returned value or thrown exceptions under the same conditions. So, there should be no Compatibility Issue (CI type 0). The annotations added in the late version (`@RequiresBluetoothConnectPermission, @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)`) enforce compile-time checks but do not affect runtime behavior."
39,<android.security.ConfirmationPrompt: void cancelPrompt()>,30,31,<android.security.ConfirmationPrompt: void cancelPrompt()>,<android.security.ConfirmationPrompt: void cancelPrompt()>,0,"{
    int responseCode = mKeyStore.cancelConfirmationPrompt(mCallbackBinder);
    if (responseCode == KeyStore.CONFIRMATIONUI_OK) {
        return;
    } else if (responseCode == KeyStore.CONFIRMATIONUI_OPERATION_PENDING) {
        throw new IllegalStateException();
    } else {
        // Unexpected error code.
        Log.w(TAG, ""Unexpected responseCode="" + responseCode + "" from cancelConfirmationPrompt() call."");
        throw new IllegalStateException();
    }
}","{
    int responseCode = getService().cancelConfirmationPrompt(mConfirmationCallback);
    if (responseCode == AndroidProtectedConfirmation.ERROR_OK) {
        return;
    } else if (responseCode == AndroidProtectedConfirmation.ERROR_OPERATION_PENDING) {
        throw new IllegalStateException();
    } else {
        // Unexpected error code.
        Log.w(TAG, ""Unexpected responseCode="" + responseCode + "" from cancelConfirmationPrompt() call."");
        throw new IllegalStateException();
    }
}",1,"/**
 * Cancels a prompt currently being displayed.
 *
 * On success, the
 * {@link ConfirmationCallback#onCanceled onCanceled()} method on
 * the supplied callback object will be called asynchronously.
 *
 * @throws IllegalStateException if no prompt is currently being presented.
 */
","/**
 * Cancels a prompt currently being displayed.
 *
 * On success, the
 * {@link ConfirmationCallback#onCanceled onCanceled()} method on
 * the supplied callback object will be called asynchronously.
 *
 * @throws IllegalStateException if no prompt is currently being presented.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used in the invocation has changed from `mKeyStore.cancelConfirmationPrompt(mCallbackBinder)` to `getService().cancelConfirmationPrompt(mConfirmationCallback)`, and the constants used for comparison have also been changed, so the code change type is 5.","Despite these changes, the behavior of the method and the purposes of the constants appear to remain consistent. It still returns void, and the conditions and the structure of the exception handling remain unchanged. As long as the new `getService().cancelConfirmationPrompt` method is expected to behave similarly to `mKeyStore.cancelConfirmationPrompt` with respect to the response codes, there is no compatibility issue in terms of behavior difference or different exceptions thrown. Therefore, the CI type is 0."
40,"<android.widget.Editor.SuggestionHelper: int getSuggestionInfo(SuggestionInfo[],SuggestionSpanInfo)>",30,31,"<android.widget.Editor.SuggestionHelper: int getSuggestionInfo(SuggestionInfo[],SuggestionSpanInfo)>","<android.widget.Editor.SuggestionHelper: int getSuggestionInfo(SuggestionInfo[],SuggestionSpanInfo)>",0,"{
    final Spannable spannable = (Spannable) mTextView.getText();
    final SuggestionSpan[] suggestionSpans = getSortedSuggestionSpans();
    final int nbSpans = suggestionSpans.length;
    if (nbSpans == 0)
        return 0;
    int numberOfSuggestions = 0;
    for (final SuggestionSpan suggestionSpan : suggestionSpans) {
        final int spanStart = spannable.getSpanStart(suggestionSpan);
        final int spanEnd = spannable.getSpanEnd(suggestionSpan);
        if (misspelledSpanInfo != null && (suggestionSpan.getFlags() & SuggestionSpan.FLAG_MISSPELLED) != 0) {
            misspelledSpanInfo.mSuggestionSpan = suggestionSpan;
            misspelledSpanInfo.mSpanStart = spanStart;
            misspelledSpanInfo.mSpanEnd = spanEnd;
        }
        final String[] suggestions = suggestionSpan.getSuggestions();
        final int nbSuggestions = suggestions.length;
        suggestionLoop: for (int suggestionIndex = 0; suggestionIndex < nbSuggestions; suggestionIndex++) {
            final String suggestion = suggestions[suggestionIndex];
            for (int i = 0; i < numberOfSuggestions; i++) {
                final SuggestionInfo otherSuggestionInfo = suggestionInfos[i];
                if (otherSuggestionInfo.mText.toString().equals(suggestion)) {
                    final int otherSpanStart = otherSuggestionInfo.mSuggestionSpanInfo.mSpanStart;
                    final int otherSpanEnd = otherSuggestionInfo.mSuggestionSpanInfo.mSpanEnd;
                    if (spanStart == otherSpanStart && spanEnd == otherSpanEnd) {
                        continue suggestionLoop;
                    }
                }
            }
            SuggestionInfo suggestionInfo = suggestionInfos[numberOfSuggestions];
            suggestionInfo.setSpanInfo(suggestionSpan, spanStart, spanEnd);
            suggestionInfo.mSuggestionIndex = suggestionIndex;
            suggestionInfo.mSuggestionStart = 0;
            suggestionInfo.mSuggestionEnd = suggestion.length();
            suggestionInfo.mText.replace(0, suggestionInfo.mText.length(), suggestion);
            numberOfSuggestions++;
            if (numberOfSuggestions >= suggestionInfos.length) {
                return numberOfSuggestions;
            }
        }
    }
    return numberOfSuggestions;
}","{
    final Spannable spannable = (Spannable) mTextView.getText();
    final SuggestionSpan[] suggestionSpans = getSortedSuggestionSpans();
    final int nbSpans = suggestionSpans.length;
    if (nbSpans == 0)
        return 0;
    int numberOfSuggestions = 0;
    for (final SuggestionSpan suggestionSpan : suggestionSpans) {
        final int spanStart = spannable.getSpanStart(suggestionSpan);
        final int spanEnd = spannable.getSpanEnd(suggestionSpan);
        if (misspelledSpanInfo != null && (suggestionSpan.getFlags() & FLAG_MISSPELLED_OR_GRAMMAR_ERROR) != 0) {
            misspelledSpanInfo.mSuggestionSpan = suggestionSpan;
            misspelledSpanInfo.mSpanStart = spanStart;
            misspelledSpanInfo.mSpanEnd = spanEnd;
        }
        final String[] suggestions = suggestionSpan.getSuggestions();
        final int nbSuggestions = suggestions.length;
        suggestionLoop: for (int suggestionIndex = 0; suggestionIndex < nbSuggestions; suggestionIndex++) {
            final String suggestion = suggestions[suggestionIndex];
            for (int i = 0; i < numberOfSuggestions; i++) {
                final SuggestionInfo otherSuggestionInfo = suggestionInfos[i];
                if (otherSuggestionInfo.mText.toString().equals(suggestion)) {
                    final int otherSpanStart = otherSuggestionInfo.mSuggestionSpanInfo.mSpanStart;
                    final int otherSpanEnd = otherSuggestionInfo.mSuggestionSpanInfo.mSpanEnd;
                    if (spanStart == otherSpanStart && spanEnd == otherSpanEnd) {
                        continue suggestionLoop;
                    }
                }
            }
            SuggestionInfo suggestionInfo = suggestionInfos[numberOfSuggestions];
            suggestionInfo.setSpanInfo(suggestionSpan, spanStart, spanEnd);
            suggestionInfo.mSuggestionIndex = suggestionIndex;
            suggestionInfo.mSuggestionStart = 0;
            suggestionInfo.mSuggestionEnd = suggestion.length();
            suggestionInfo.mText.replace(0, suggestionInfo.mText.length(), suggestion);
            numberOfSuggestions++;
            if (numberOfSuggestions >= suggestionInfos.length) {
                return numberOfSuggestions;
            }
        }
    }
    return numberOfSuggestions;
}",1,"/**
 * Gets the SuggestionInfo list that contains suggestion information at the current cursor
 * position.
 *
 * @param suggestionInfos SuggestionInfo array the results will be set.
 * @param misspelledSpanInfo a struct the misspelled SuggestionSpan info will be set.
 * @return the number of suggestions actually fetched.
 */
","/**
 * Gets the SuggestionInfo list that contains suggestion information at the current cursor
 * position.
 *
 * @param suggestionInfos SuggestionInfo array the results will be set.
 * @param misspelledSpanInfo a struct the misspelled SuggestionSpan info will be set.
 * @return the number of suggestions actually fetched.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The flag comparison in the if statement has changed from SuggestionSpan.FLAG_MISSPELLED to FLAG_MISSPELLED_OR_GRAMMAR_ERROR, indicating a change in the logic that updates misspelledSpanInfo when a certain condition is met. This could indicate a dependent API change if the FLAG_MISSPELLED_OR_GRAMMAR_ERROR is not present in the previous API version or its behavior is different. Also, this is an other statement changed because it's neither a return statement, control dependency, nor exception handling statement. So, the code change type is 4,5.","However, even though the conditional logic has changed, this does not lead to a Compatibility Issue because the method's return value or exception throwing behavior does not change; it still returns the number of suggestions found without altering the method's core functionality. Thus, no Compatibility Issue is detected."
41,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,30,31,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,<android.bluetooth.BluetoothGattServer: boolean removeService(BluetoothGattService)>,0,"{
    if (DBG)
        Log.d(TAG, ""removeService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getInstanceId());
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""removeService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService intService = getService(service.getUuid(), service.getInstanceId(), service.getType());
    if (intService == null)
        return false;
    try {
        mService.removeService(mServerIf, service.getInstanceId(), mAttributionSource);
        mServices.remove(intService);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Removes a service from the list of services to be provided.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be removed.
 * @return true, if the service has been removed
 */
","/**
 * Removes a service from the list of services to be provided.
 *
 * @param service Service to be removed.
 * @return true, if the service has been removed
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"3,5",0,"The implementation of the removeService method has changed to include an additional parameter, mAttributionSource, in the call to `mService.removeService`. This change is considered a dependent API change (class 5) as the signature of the dependent method call within the implementation is altered. Additionally, there is a change in the control dependency because the way the method is called has been updated to include a new parameter, which is a change in the method execution flow. However, there is no change in the control structures of the method itself; hence, some may argue against a control dependency change. Still, we consider here that the control flow is altered due to the dependent method modification, thus classifying it under 3. There are also new annotations in the late version, but annotations do not affect the actual bytecode executed and therefore do not fall under our change categories.","Despite the change in the dependent API being called within removeService, there is no Compatibility Issue detected because the method always returns the same boolean type and potential exceptions are handled in the same way. The logic flow does not change with respect to how it was handled in the early version, even though a new parameter is passed to a call. The method's external behavior, in terms of returning a bool or throwing exceptions, remains consistent."
42,<android.app.ActivityThread.ApplicationThread: void updateHttpProxy()>,30,31,<android.app.ActivityThread.ApplicationThread: void updateHttpProxy()>,<android.app.ActivityThread.ApplicationThread: void updateHttpProxy()>,0,"{
    ActivityThread.updateHttpProxy(getApplication() != null ? getApplication() : getSystemContext());
}","{
    final Application app;
    synchronized (ActivityThread.this) {
        app = getApplication();
        if (null == app) {
            // The app is not bound yet. Make a note to update the HTTP proxy when the
            // app is bound.
            mUpdateHttpProxyOnBind = true;
            return;
        }
    }
    // App is present, update the proxy inline.
    ActivityThread.updateHttpProxy(app);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces a synchronized block, an if-statement, and a variable assignment, which are not present in the early version, so the code change types are 3 (control dependency changed) and 4 (other statement changed).","Even though there are additions to the implementation, these changes do not lead to a Compatibility Issue. The behavior remains the same as the proxy will be updated with the Application context if available or will be updated later once the application is bound. The if-statement with the return statement only delays the proxy update until the app is bound but doesn't alter the eventual outcome of the update process. Therefore, there is no Compatibility Issue."
43,"<android.service.autofill.BatchUpdates.Builder: Builder transformChild(int,Transformation)>",30,31,"<android.service.autofill.BatchUpdates.Builder: Builder transformChild(int,Transformation)>","<android.service.autofill.BatchUpdates.Builder: Builder transformChild(int,Transformation)>",0,"{
    throwIfDestroyed();
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: "" + transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: %s"", transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}",1,"/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they are applied
 * in the same order as added.
 *
 * <p><b>Note:</b> The transformations are applied after the
 * {@link #updateTemplate(RemoteViews) updates} are applied to the presentation template.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 * @return this builder.
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 */
","/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they are applied
 * in the same order as added.
 *
 * <p><b>Note:</b> The transformations are applied after the
 * {@link #updateTemplate(RemoteViews) updates} are applied to the presentation template.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 * @return this builder.
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation has not been altered in terms of logic or behavior; the only change is the addition of string formatting in the second argument of the Preconditions.checkArgument() method. This change strictly affects the message that is output in case of a failure in the checkArgument() condition, and it does not affect the execution behavior of the method. Therefore, the code change type is 4.","There is no Compatibility Issue, as the change in the string formatting of the precondition check message does not affect the API's behavior, return values, or exception throwing capability. Hence, CI type is 0."
44,"<android.widget.Editor.SuggestionHelper.SuggestionSpanComparator: int compare(SuggestionSpan,SuggestionSpan)>",30,31,"<android.widget.Editor.SuggestionHelper.SuggestionSpanComparator: int compare(SuggestionSpan,SuggestionSpan)>","<android.widget.Editor.SuggestionHelper.SuggestionSpanComparator: int compare(SuggestionSpan,SuggestionSpan)>",0,"{
    final int flag1 = span1.getFlags();
    final int flag2 = span2.getFlags();
    if (flag1 != flag2) {
        // The order here should match what is used in updateDrawState
        final boolean easy1 = (flag1 & SuggestionSpan.FLAG_EASY_CORRECT) != 0;
        final boolean easy2 = (flag2 & SuggestionSpan.FLAG_EASY_CORRECT) != 0;
        final boolean misspelled1 = (flag1 & SuggestionSpan.FLAG_MISSPELLED) != 0;
        final boolean misspelled2 = (flag2 & SuggestionSpan.FLAG_MISSPELLED) != 0;
        if (easy1 && !misspelled1)
            return -1;
        if (easy2 && !misspelled2)
            return 1;
        if (misspelled1)
            return -1;
        if (misspelled2)
            return 1;
    }
    return mSpansLengths.get(span1).intValue() - mSpansLengths.get(span2).intValue();
}","{
    final int flag1 = span1.getFlags();
    final int flag2 = span2.getFlags();
    if (flag1 != flag2) {
        // Compare so that the order will be: easy -> misspelled -> grammarError
        int easy = compareFlag(SuggestionSpan.FLAG_EASY_CORRECT, flag1, flag2);
        if (easy != 0)
            return easy;
        int misspelled = compareFlag(SuggestionSpan.FLAG_MISSPELLED, flag1, flag2);
        if (misspelled != 0)
            return misspelled;
        int grammarError = compareFlag(SuggestionSpan.FLAG_GRAMMAR_ERROR, flag1, flag2);
        if (grammarError != 0)
            return grammarError;
    }
    return mSpansLengths.get(span1).intValue() - mSpansLengths.get(span2).intValue();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Control structure has been significantly changed by replacing a series of if-statements with calls to a separate method, compareFlag. Also, there is now a check for a new flag, FLAG_GRAMMAR_ERROR, which did not exist before. Furthermore, there is a change in how flags are compared as the conditions for -1 and 1 return values from the if-statements have been altered and replaced by the new method compareFlag. This results in both a control dependency change and other statement change.","The change in the control structure (conditions under which flags are compared and prioritized) may lead to different return values when the same SuggestionSpan objects are passed to the compare() method in two versions, causing the API to potentially return a different result than before, therefore the CI type is 1."
46,<android.app.ContextImpl: IBinder getActivityToken()>,30,31,<android.app.ContextImpl: IBinder getActivityToken()>,<android.app.ContextImpl: IBinder getActivityToken()>,0,"{
    return mToken;
}","{
    return mContextType == CONTEXT_TYPE_ACTIVITY ? mToken : null;
}",1,,,-1,"[@Override, @UnsupportedAppUsage]","[@Override, @UnsupportedAppUsage]",-1,-1,-1,-1,-1,-1,"1,3",1,"The late implementation introduces a conditional check `mContextType == CONTEXT_TYPE_ACTIVITY` that was not present in the early version, hence adding a control dependency which could alter the value being returned (either `mToken` or `null`), so the code change type is 1,3.","Given that the late version only returns `mToken` when `mContextType` is equal to `CONTEXT_TYPE_ACTIVITY`, there could be a change in the returned value (`null` instead of `mToken`) when the context type is not an activity. This represents a potential difference in return values, and thus the CI type is 1."
47,<android.app.Activity: boolean navigateUpTo(Intent)>,30,31,<android.app.Activity: boolean navigateUpTo(Intent)>,<android.app.Activity: boolean navigateUpTo(Intent)>,0,"{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityTaskManager.getService().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}","{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        upIntent.prepareToLeaveProcess(this);
        return ActivityClient.getInstance().navigateUpTo(mToken, upIntent, resultCode, resultData);
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}",1,"/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
","/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an ""in-app home"" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The try-catch block dealing with RemoteException is removed, and a call is made to a different method (from ActivityTaskManager.getService().navigateUpTo() to ActivityClient.getInstance().navigateUpTo()). This means there could be both an Other statement changed (4) due to the change in exception handling and a Dependent API changed (5) due to calling a different method.","Despite the changes, the possibility of a Compatibility Issue seems absent. The functional behavior on how the intent is processed and the activity navigated up to does not fundamentally change. The replacement of the RemoteException handler with a direct method call removes the potential for a RemoteException, but such an exception should not occur during normal operation (as RemoteException is a checked exception indicating an IPC error). The change in the method call should be internally consistent, considering both methods are infrastructure calls that should lead to the same result, following similar logic internally. Therefore, there is no Compatibility Issue (0)."
48,<android.view.textclassifier.TextClassificationSession: int getMaxGenerateLinksTextLength()>,30,31,<android.view.textclassifier.TextClassificationSession: int getMaxGenerateLinksTextLength()>,<android.view.textclassifier.TextClassificationSession: int getMaxGenerateLinksTextLength()>,0,"{
    checkDestroyed();
    return mDelegate.getMaxGenerateLinksTextLength();
}","{
    return checkDestroyedAndRun(mDelegate::getMaxGenerateLinksTextLength);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method has changed from a direct method call within a checkDestroyed() envelope to a method reference passed to checkDestroyedAndRun. This is a change in the way the delegate's method is called, which categorizes as type 4 (Other statement changed). Since the method maxGenerateLinksTextLength is called via a method reference in the late implementation instead of a direct call, it is also considered a change in the dependent API, thus categorizing as type 5 as well.","However, there is no Compatibility Issue here as the behavior (the return value) is intended to remain the same; it's merely a refactoring of the code to use a different mechanism for ensuring the object is not destroyed before calling the method. There's no indication that the return value or the type of exceptions it can throw would change, so there's no CI related to return values or types (type 1), nor any related to exception handling (type 2)."
49,"<android.speech.tts.TextToSpeech: int addSpeech(String,String)>",30,31,"<android.speech.tts.TextToSpeech: int addSpeech(String,String)>","<android.speech.tts.TextToSpeech: int addSpeech(String,String)>",0,"{
    synchronized (mStartLock) {
        mUtterances.put(text, Uri.parse(filename));
        return SUCCESS;
    }
}","{
    return addSpeech(text, Uri.parse(filename));
}",1,"/**
 * Adds a mapping between a string of text and a sound file. Using this, it is possible to
 * add custom pronounciations for a string of text. After a call to this method, subsequent
 * calls to {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound
 * resource if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/hello.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound file. Using this, it is possible to
 * add custom pronounciations for a string of text. After a call to this method, subsequent
 * calls to {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound
 * resource if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/hello.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has changed from directly manipulating the 'mUtterances' map and returning 'SUCCESS' inside of a synchronized block to calling another method addSpeech with the parsed URI, so the code change type is 1,5.","Since there is a change from inline code to a method call which might have different implementation details (especially given that we do not see the implementation of this new method), there is a potential for a different return value, representing a CI of type 1."
51,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,30,31,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHidDevice: List<BluetoothDevice> getConnectedDevices()>,0,"{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return new ArrayList<>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been modified to include a call to Attributable.setAttributionSource with mAttributionSource. Additionally, the API now requires new permissions as per the annotation changes, which are considered as a change in dependent API due to the API's contract with the caller being updated to enforce new permission requirements, and there is a modification in the dependent API itself (from `service.getConnectedDevices()` to `Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource)`). So, the change types are 1,4,5.","Due to the use of the new Attributable.setAttributionSource method, this leads to a change in the behavior of the method as it potentially returns additional or different set of data associated with the attribution source, which is a change related to the return value. Additionally, requiring new permissions (BLUETOOTH_CONNECT) could result in a SecurityException if the permission is not granted, which is also a change in behavior. Hence, there is a potential Compatibility Issue of type 1 due to the change in the return value introduced by the changes made to the method."
53,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,30,31,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,<android.hardware.fingerprint.FingerprintManager: boolean hasEnrolledFingerprints()>,0,"{
    if (mService != null)
        try {
            return mService.hasEnrolledFingerprints(mContext.getUserId(), mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return false;
}","{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_DEPRECATED_API_USED, AUTH_DEPRECATED_APIUSED__DEPRECATED_API__API_FINGERPRINT_MANAGER_HAS_ENROLLED_FINGERPRINTS, mContext.getApplicationInfo().uid, mContext.getApplicationInfo().targetSdkVersion);
    return hasEnrolledFingerprints(UserHandle.myUserId());
}",1,"/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_NO_FINGERPRINTS}
 */
","/**
 * Determine if there is at least one fingerprint enrolled.
 *
 * @return true if at least one fingerprint is enrolled, false otherwise
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_NO_FINGERPRINTS}
 */
",-1,"[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]","[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]",-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The method implementation has been significantly altered. The late version calls a logging function (FrameworkStatsLog.write(...)) and then delegates to a different API (hasEnrolledFingerprints(UserHandle.myUserId())). The early version directly calls the mService's method with specific parameters. This involves return statement changed (due to the delegation), other statements changed (due to the logging call), and dependent API changed (because the delegation now calls different implementation). So the code change type is 1,4,5.","The late version of the API adds a logging step that does not affect the return value, but it changes the function call to an overload with potentially different behavior (hasEnrolledFingerprints with a different set of arguments). This could potentially produce a different value upon invocation (if the behavior of the overloaded function is different), which is a compatibility issue under type 1. Moreover, the removal of the exception handling block from `mService` invocation can result in different exceptions now being propagated or handled differently; thus, there is also a potential compatibility issue under type 2."
54,<android.net.Uri.PathPart: PathPart makeAbsolute(PathPart)>,30,31,<android.net.Uri.PathPart: PathPart makeAbsolute(PathPart)>,<android.net.Uri.PathPart: PathPart makeAbsolute(PathPart)>,0,"{
    @SuppressWarnings(""StringEquality"") boolean encodedCached = oldPart.encoded != NOT_CACHED;
    // We don't care which version we use, and we don't want to force
    // unneccessary encoding/decoding.
    String oldPath = encodedCached ? oldPart.encoded : oldPart.decoded;
    if (oldPath == null || oldPath.length() == 0 || oldPath.startsWith(""/"")) {
        return oldPart;
    }
    // Prepend encoded string if present.
    String newEncoded = encodedCached ? ""/"" + oldPart.encoded : NOT_CACHED;
    // Prepend decoded string if present.
    @SuppressWarnings(""StringEquality"") boolean decodedCached = oldPart.decoded != NOT_CACHED;
    String newDecoded = decodedCached ? ""/"" + oldPart.decoded : NOT_CACHED;
    return new PathPart(newEncoded, newDecoded);
}","{
    @SuppressWarnings(""StringEquality"") boolean encodedCached = oldPart.encoded != NotCachedHolder.NOT_CACHED;
    // We don't care which version we use, and we don't want to force
    // unneccessary encoding/decoding.
    String oldPath = encodedCached ? oldPart.encoded : oldPart.decoded;
    if (oldPath == null || oldPath.length() == 0 || oldPath.startsWith(""/"")) {
        return oldPart;
    }
    // Prepend encoded string if present.
    String newEncoded = encodedCached ? ""/"" + oldPart.encoded : NotCachedHolder.NOT_CACHED;
    // Prepend decoded string if present.
    @SuppressWarnings(""StringEquality"") boolean decodedCached = oldPart.decoded != NotCachedHolder.NOT_CACHED;
    String newDecoded = decodedCached ? ""/"" + oldPart.decoded : NotCachedHolder.NOT_CACHED;
    return new PathPart(newEncoded, newDecoded);
}",1,"/**
 * Prepends path values with ""/"" if they're present, not empty, and
 * they don't already start with ""/"".
 */
","/**
 * Prepends path values with ""/"" if they're present, not empty, and
 * they don't already start with ""/"".
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The constant used for checking cache status has changed from NOT_CACHED to NotCachedHolder.NOT_CACHED, which indicates that a dependent API or a constant's definition has changed, so code changes include 4 (Other statement changed) and 5 (Dependent API changed).","This change does not affect the API's return values or the exceptions that it throws since it's merely referencing an updated reference to what is assumed to be a constant value. The logic and control flow of the method remain the same and thus should not introduce compatibility issues, so the CI type is 0 (No Compatibility Issue)."
56,<android.view.inputmethod.InlineSuggestion: int hashCode()>,30,31,<android.view.inputmethod.InlineSuggestion: int hashCode()>,<android.view.inputmethod.InlineSuggestion: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInfo);
    _hash = 31 * _hash + java.util.Objects.hashCode(mContentProvider);
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlineContentCallback);
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInfo);
    _hash = 31 * _hash + java.util.Objects.hashCode(mContentProvider);
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlineContentCallback);
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlineTooltipUi);
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,0,"An additional line of code (_hash = 31 * _hash + java.util.Objects.hashCode(mInlineTooltipUi);) is added to incorporate the hashCode computation of a new field (mInlineTooltipUi) in the 'hashCode' method. This is an other statement changed, hence the code change type is 4.","The addition of a new field to the hashCode computation does not introduce a compatibility issue for the method's intended operation, since hashCode is expected to change when the object's state changes. The new field is intended to represent part of the object state, and hence its inclusion is according to the contract of the hashCode method. There is no compatibility issue as the existing behavior of the method is consistent with the contract of hashCode in Java, which accounts for the object's state at the time it is called. Therefore, the CI type is 0."
57,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",30,31,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>","<android.app.Activity: boolean startActivityIfNeeded(Intent,int,Bundle)>",0,"{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData(this);
            intent.prepareToLeaveProcess(this);
            result = ActivityTaskManager.getService().startActivity(mMainThread.getApplicationThread(), getBasePackageName(), getAttributionTag(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            Uri referrer = onProvideReferrer();
            if (referrer != null) {
                intent.putExtra(Intent.EXTRA_REFERRER, referrer);
            }
            intent.migrateExtraStreamToClipData(this);
            intent.prepareToLeaveProcess(this);
            result = ActivityTaskManager.getService().startActivity(mMainThread.getApplicationThread(), getOpPackageName(), getAttributionTag(), intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken, mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED, null, options);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)}
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change consists of changing getBasePackageName() to getOpPackageName() which indicates a change in the dependent API used within the method. Therefore, the code change type is 5.","There is no Compatibility Issue here because the change is only in the underlying implementation detail (the package name provider method). The overall method signature, return type, exception handling, and behavior appear to be consistent between versions. The method's contract regarding when and what it returns or raises as an exception has not been changed."
59,<android.speech.tts.TextToSpeech: void shutdown()>,30,31,<android.speech.tts.TextToSpeech: void shutdown()>,<android.speech.tts.TextToSpeech: void shutdown()>,0,"{
    // Special case, we are asked to shutdown connection that did finalize its connection.
    synchronized (mStartLock) {
        if (mConnectingServiceConnection != null) {
            mContext.unbindService(mConnectingServiceConnection);
            mConnectingServiceConnection = null;
            return;
        }
    }
    // Post connection case
    runActionNoReconnect((ITextToSpeechService service) -> {
        service.setCallback(getCallerIdentity(), null);
        service.stop(getCallerIdentity());
        mServiceConnection.disconnect();
        // Context#unbindService does not result in a call to
        // ServiceConnection#onServiceDisconnected. As a result, the
        // service ends up being destroyed (if there are no other open
        // connections to it) but the process lives on and the
        // ServiceConnection continues to refer to the destroyed service.
        // 
        // This leads to tons of log spam about SynthThread being dead.
        mServiceConnection = null;
        mCurrentEngine = null;
        return null;
    }, null, ""shutdown"", false);
}","{
    // Special case, we are asked to shutdown connection that did finalize its connection.
    synchronized (mStartLock) {
        if (mConnectingServiceConnection != null) {
            mConnectingServiceConnection.disconnect();
            mConnectingServiceConnection = null;
            return;
        }
    }
    // Post connection case
    runActionNoReconnect((ITextToSpeechService service) -> {
        service.setCallback(getCallerIdentity(), null);
        service.stop(getCallerIdentity());
        mServiceConnection.disconnect();
        // Context#unbindService does not result in a call to
        // ServiceConnection#onServiceDisconnected. As a result, the
        // service ends up being destroyed (if there are no other open
        // connections to it) but the process lives on and the
        // ServiceConnection continues to refer to the destroyed service.
        // 
        // This leads to tons of log spam about SynthThread being dead.
        mServiceConnection = null;
        mCurrentEngine = null;
        return null;
    }, null, ""shutdown"", false);
}",1,"/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
","/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method mContext.unbindService(mConnectingServiceConnection) is replaced by mConnectingServiceConnection.disconnect(). This indicates an internal change of how the service connection is being handled during shutdown. However, the higher-level behavior of the shutdown method itself and its interaction with the client code doesn't seem to have changed. The modified statement is related to internal cleanup and should not affect the outward behavior of the `shutdown()` method. Thus, this change falls under the category of ""Other statement changed"".","No Compatibility Issue appears to exist because the modification does not affect the method's return type or value (since it is void) and does not introduce or remove any exception throwing. Therefore, dependent code would continue to execute as previously without any change in behaviour due to this internal cleanup change."
60,<android.view.inputmethod.InlineSuggestionsRequest.Builder: InlineSuggestionsRequest build()>,30,31,<android.view.inputmethod.InlineSuggestionsRequest.Builder: InlineSuggestionsRequest build()>,<android.view.inputmethod.InlineSuggestionsRequest.Builder: InlineSuggestionsRequest build()>,0,"{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x80;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mMaxSuggestionCount = defaultMaxSuggestionCount();
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mHostPackageName = defaultHostPackageName();
    }
    if ((mBuilderFieldsSet & 0x8) == 0) {
        mSupportedLocales = defaultSupportedLocales();
    }
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mExtras = defaultExtras();
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mHostInputToken = defaultHostInputToken();
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mHostDisplayId = defaultHostDisplayId();
    }
    InlineSuggestionsRequest o = new InlineSuggestionsRequest(mMaxSuggestionCount, mInlinePresentationSpecs, mHostPackageName, mSupportedLocales, mExtras, mHostInputToken, mHostDisplayId);
    return o;
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x100;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mMaxSuggestionCount = defaultMaxSuggestionCount();
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mHostPackageName = defaultHostPackageName();
    }
    if ((mBuilderFieldsSet & 0x8) == 0) {
        mSupportedLocales = defaultSupportedLocales();
    }
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mExtras = defaultExtras();
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mHostInputToken = defaultHostInputToken();
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mHostDisplayId = defaultHostDisplayId();
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mInlineTooltipPresentationSpec = defaultInlineTooltipPresentationSpec();
    }
    InlineSuggestionsRequest o = new InlineSuggestionsRequest(mMaxSuggestionCount, mInlinePresentationSpecs, mHostPackageName, mSupportedLocales, mExtras, mHostInputToken, mHostDisplayId, mInlineTooltipPresentationSpec);
    return o;
}",1,"/**
 * Builds the instance. This builder should not be touched after calling this!
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has a new block of conditional logic and a parameter added to the constructor of InlineSuggestionsRequest, which constitutes Other statement changed (4). Additionally, the return statement is now returning an object of InlineSuggestionsRequest with an additional parameter which wasn't there in the early version, so the return statement has changed as well (1).","The additional conditional logic and parameter in the constructor potentially lead to a different object being returned by this method, which means there's a Compatibility Issue caused by potential different return values or types (1)."
62,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,<android.hardware.biometrics.BiometricPrompt.Builder: BiometricPrompt build()>,0,"{
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    final boolean useDefaultTitle = mBundle.getBoolean(KEY_USE_DEFAULT_TITLE, false);
    final boolean deviceCredentialAllowed = mBundle.getBoolean(KEY_ALLOW_DEVICE_CREDENTIAL);
    @Authenticators.Types final int authenticators = mBundle.getInt(KEY_AUTHENTICATORS_ALLOWED, 0);
    final boolean willShowDeviceCredentialButton = deviceCredentialAllowed || (authenticators & Authenticators.DEVICE_CREDENTIAL) != 0;
    if (TextUtils.isEmpty(title) && !useDefaultTitle) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative) && !willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    } else if (!TextUtils.isEmpty(negative) && willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Can't have both negative button behavior"" + "" and device credential enabled"");
    }
    return new BiometricPrompt(mContext, mBundle, mPositiveButtonInfo, mNegativeButtonInfo);
}","{
    final CharSequence title = mPromptInfo.getTitle();
    final CharSequence negative = mPromptInfo.getNegativeButtonText();
    final boolean useDefaultTitle = mPromptInfo.isUseDefaultTitle();
    final boolean deviceCredentialAllowed = mPromptInfo.isDeviceCredentialAllowed();
    @Authenticators.Types final int authenticators = mPromptInfo.getAuthenticators();
    final boolean willShowDeviceCredentialButton = deviceCredentialAllowed || isCredentialAllowed(authenticators);
    if (TextUtils.isEmpty(title) && !useDefaultTitle) {
        throw new IllegalArgumentException(""Title must be set and non-empty"");
    } else if (TextUtils.isEmpty(negative) && !willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Negative text must be set and non-empty"");
    } else if (!TextUtils.isEmpty(negative) && willShowDeviceCredentialButton) {
        throw new IllegalArgumentException(""Can't have both negative button behavior"" + "" and device credential enabled"");
    }
    return new BiometricPrompt(mContext, mPromptInfo, mNegativeButtonInfo);
}",1,"/**
 * Creates a {@link BiometricPrompt}.
 *
 * @return An instance of {@link BiometricPrompt}.
 *
 * @throws IllegalArgumentException If any required fields are unset, or if given any
 * invalid combination of field values.
 */
","/**
 * Creates a {@link BiometricPrompt}.
 *
 * @return An instance of {@link BiometricPrompt}.
 *
 * @throws IllegalArgumentException If any required fields are unset, or if given any
 * invalid combination of field values.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The way values are retrieved from 'mBundle' is changed to calling methods on 'mPromptInfo', and the parameters passed to the 'BiometricPrompt' constructor have changed, therefore the changes are of types 1, 4, and 5. ","Since the logic of checking conditions and throwing exceptions remains the same, the potential CI is caused by the change in how the 'BiometricPrompt' object is constructed, which will potentially return a different 'BiometricPrompt' object due to changes in the parameters passed to its constructor; hence, the CI type is 1."
63,<android.net.Uri.PathPart: String getEncoded()>,30,31,<android.net.Uri.PathPart: String getEncoded()>,<android.net.Uri.PathPart: String getEncoded()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NOT_CACHED;
    // Don't encode '/'.
    return hasEncoded ? encoded : (encoded = encode(decoded, ""/""));
}","{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NotCachedHolder.NOT_CACHED;
    // Don't encode '/'.
    return hasEncoded ? encoded : (encoded = encode(decoded, ""/""));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The reference to NOT_CACHED has been changed to NotCachedHolder.NOT_CACHED. The value of NOT_CACHED is presumably static, and changing its reference does not imply a change in behavior as long as the value it represents remains the same. This change is an other statement change (4) and a change in a dependent API (5), as the current API implementation relies on the value of this variable.",There is no Compatibility Issue as the semantic meaning of the code has not changedâ€”the behavior of the API remains the same if the NOT_CACHED constant value is unchanged in the NotCachedHolder class.
64,<android.view.Display: long getPresentationDeadlineNanos()>,30,31,<android.view.Display: long getPresentationDeadlineNanos()>,<android.view.Display: long getPresentationDeadlineNanos()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.presentationDeadlineNanos;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.presentationDeadlineNanos;
    }
}",1,"/**
 * This is how far in advance a buffer must be queued for presentation at
 * a given time.  If you want a buffer to appear on the screen at
 * time N, you must submit the buffer before (N - presentationDeadline).
 * <p>
 * The desired presentation time for GLES rendering may be set with
 * {@link android.opengl.EGLExt#eglPresentationTimeANDROID}.  For video decoding, use
 * {@link android.media.MediaCodec#releaseOutputBuffer(int, long)}.  Times are
 * expressed in nanoseconds, using the system monotonic clock
 * ({@link System#nanoTime}).
 */
","/**
 * This is how far in advance a buffer must be queued for presentation at
 * a given time.  If you want a buffer to appear on the screen at
 * time N, you must submit the buffer before (N - presentationDeadline).
 * <p>
 * The desired presentation time for GLES rendering may be set with
 * {@link android.opengl.EGLExt#eglPresentationTimeANDROID}.  For video decoding, use
 * {@link android.media.MediaCodec#releaseOutputBuffer(int, long)}.  Times are
 * expressed in nanoseconds, using the system monotonic clock
 * ({@link System#nanoTime}).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is the object on which the synchronized block is locking, from `this` to `mLock`. This change does not affect the return statement nor does it introduce any new exceptions or alter the control flow, so the change type is 4.",There is no Compatibility Issue because the return value `mDisplayInfo.presentationDeadlineNanos` and the behavior of the method have not been modified by this change. The method's contract in terms of its input/output behavior remains the same across the two versions.
66,<android.content.res.XmlBlock.Parser: String getAttributeName(int)>,30,31,<android.content.res.XmlBlock.Parser: String getAttributeName(int)>,<android.content.res.XmlBlock.Parser: String getAttributeName(int)>,0,"{
    int id = nativeGetAttributeName(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeName of "" + index + "" = "" + id);
    if (id >= 0)
        return mStrings.get(id).toString();
    throw new IndexOutOfBoundsException(String.valueOf(index));
}","{
    int id = nativeGetAttributeName(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeName of "" + index + "" = "" + id);
    if (id >= 0)
        return getSequenceString(mStrings.getSequence(id));
    throw new IndexOutOfBoundsException(String.valueOf(index));
}",1,,,-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from mStrings.get(id).toString() to getSequenceString(mStrings.getSequence(id)), and a new function getSequenceString() is being used which means there is a change in a dependent API. Additionally, another 'Other statement changed' is the addition of the NonNull annotation, so the code change types are 1, 4, 5.","The change in the return statement could potentially lead to a different return value due to the implementation details of getSequenceString(), thus the CI type is 1."
67,<android.os.VibrationAttributes: int hashCode()>,30,31,<android.os.VibrationAttributes: int hashCode()>,<android.os.VibrationAttributes: int hashCode()>,0,"{
    return Objects.hash(mUsage, mFlags);
}","{
    return Objects.hash(mUsage, mOriginalAudioUsage, mFlags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The `hashCode()` method implementation has changed to include a new member variable `mOriginalAudioUsage` in the hash computation. This is a change in the statements that are not control or exception handling related. Given that it's an additional field being considered in the hash computation, this would categorize as type 1 (Return statement changed) and type 4 (Other statement changed).","The additional field `mOriginalAudioUsage` included in the hash computation changes the resultant hash value. Since `hashCode()` is expected to return a consistent hash code for the same object contents and a different value for distinct ones, the change definitely results in a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types). As the hashCode can be different for the same object state (excluding `mOriginalAudioUsage`), clients relying on the hash for comparing VibrationAttributes objects may experience unexpected results."
69,<android.app.ActivityManager.TaskDescription: String toString()>,30,31,<android.app.ActivityManager.TaskDescription: String toString()>,<android.app.ActivityManager.TaskDescription: String toString()>,0,"{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mStatusBarColor + (mEnsureStatusBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" navigationBarColor: "" + mNavigationBarColor + (mEnsureNavigationBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" resizeMode: "" + ActivityInfo.resizeModeToString(mResizeMode) + "" minWidth: "" + mMinWidth + "" minHeight: "" + mMinHeight;
}","{
    return ""TaskDescription Label: "" + mLabel + "" Icon: "" + mIcon + "" IconFilename: "" + mIconFilename + "" colorPrimary: "" + mColorPrimary + "" colorBackground: "" + mColorBackground + "" statusBarColor: "" + mStatusBarColor + (mEnsureStatusBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" navigationBarColor: "" + mNavigationBarColor + (mEnsureNavigationBarContrastWhenTransparent ? "" (contrast when transparent)"" : """") + "" resizeMode: "" + ActivityInfo.resizeModeToString(mResizeMode) + "" minWidth: "" + mMinWidth + "" minHeight: "" + mMinHeight + "" colorBackgrounFloating: "" + mColorBackgroundFloating;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the implementation is the addition of "" + mColorBackgroundFloating"" to the string that is being returned. This is considered an 'Other statement changed' since it does not affect the return type, exception handling, or control dependency.","There's no Compatibility Issue since the method simply returns a string representing the object's state, and the addition of one more field to this string does not affect how methods or clients interact with the object or method's return type. The change only adds additional information to the output string."
70,<android.app.Activity: int getMaxNumPictureInPictureActions()>,30,31,<android.app.Activity: int getMaxNumPictureInPictureActions()>,<android.app.Activity: int getMaxNumPictureInPictureActions()>,0,"{
    try {
        return ActivityTaskManager.getService().getMaxNumPictureInPictureActions(mToken);
    } catch (RemoteException e) {
        return 0;
    }
}","{
    return ActivityTaskManager.getMaxNumPictureInPictureActions(this);
}",1,"/**
 * Return the number of actions that will be displayed in the picture-in-picture UI when the
 * user interacts with the activity currently in picture-in-picture mode. This number may change
 * if the global configuration changes (ie. if the device is plugged into an external display),
 * but will always be larger than three.
 */
","/**
 * Return the number of actions that will be displayed in the picture-in-picture UI when the
 * user interacts with the activity currently in picture-in-picture mode. This number may change
 * if the global configuration changes (ie. if the device is plugged into an external display),
 * but will always be at least three.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed, from invoking `ActivityTaskManager.getService().getMaxNumPictureInPictureActions(mToken)` within a `try-catch` block to directly calling `ActivityTaskManager.getMaxNumPictureInPictureActions(this)`. This change is classified as a dependent API change.","No Compatibility Issue is detected, the returned value is expected to be functionally equivalent and there is no modification in the type or handling of exceptions. While the underlying method called has changed, the API contract appears to remain fulfilled, returning the maximum number of actions that can be shown in picture-in-picture mode for an activity."
72,<android.widget.TimePicker: String[] getAmPmStrings(Context)>,30,31,<android.widget.TimePicker: String[] getAmPmStrings(Context)>,<android.widget.TimePicker: String[] getAmPmStrings(Context)>,0,"{
    final Locale locale = context.getResources().getConfiguration().locale;
    final LocaleData d = LocaleData.get(locale);
    final String[] result = new String[2];
    result[0] = d.amPm[0].length() > 4 ? d.narrowAm : d.amPm[0];
    result[1] = d.amPm[1].length() > 4 ? d.narrowPm : d.amPm[1];
    return result;
}","{
    final Locale locale = context.getResources().getConfiguration().locale;
    DateFormatSymbols dfs = DateFormat.getIcuDateFormatSymbols(locale);
    String[] amPm = dfs.getAmPmStrings();
    String[] narrowAmPm = dfs.getAmpmNarrowStrings();
    final String[] result = new String[2];
    result[0] = amPm[0].length() > 4 ? narrowAmPm[0] : amPm[0];
    result[1] = amPm[1].length() > 4 ? narrowAmPm[1] : amPm[1];
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of how the AM/PM strings are retrieved has been changed significantly. The early version uses LocaleData.get(locale) whereas the late version uses DateFormat.getIcuDateFormatSymbols(locale). The method of obtaining narrow AM/PM strings has also changed, affecting the actual values being assigned to the 'result' array. There is also a new local variable declaration for DateFormatSymbols and the process of getting amPm and narrowAmPm strings has changed, thus other statements changed also apply. Due to these changes in implementation details and retrieval of data, the change types are categorized as 1, 4, and 5.","The return values can be different if the new implementation sources the amPm and narrowAmPm strings differently than the old implementation, resulting in possibly different strings in the 'result' array. This would lead to the API returning different values. Hence the CI type is 1."
74,"<android.bluetooth.le.BluetoothLeAdvertiser: IAdvertisingSetCallback wrap(AdvertisingSetCallback,Handler)>",30,31,"<android.bluetooth.le.BluetoothLeAdvertiser: IAdvertisingSetCallback wrap(AdvertisingSetCallback,Handler)>","<android.bluetooth.le.BluetoothLeAdvertiser: IAdvertisingSetCallback wrap(AdvertisingSetCallback,Handler)>",0,"{
    return new IAdvertisingSetCallback.Stub() {

        @Override
        public void onAdvertisingSetStarted(int advertiserId, int txPower, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    if (status != AdvertisingSetCallback.ADVERTISE_SUCCESS) {
                        callback.onAdvertisingSetStarted(null, 0, status);
                        mCallbackWrappers.remove(callback);
                        return;
                    }
                    AdvertisingSet advertisingSet = new AdvertisingSet(advertiserId, mBluetoothManager);
                    mAdvertisingSets.put(advertiserId, advertisingSet);
                    callback.onAdvertisingSetStarted(advertisingSet, txPower, status);
                }
            });
        }

        @Override
        public void onOwnAddressRead(int advertiserId, int addressType, String address) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onOwnAddressRead(advertisingSet, addressType, address);
                }
            });
        }

        @Override
        public void onAdvertisingSetStopped(int advertiserId) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingSetStopped(advertisingSet);
                    mAdvertisingSets.remove(advertiserId);
                    mCallbackWrappers.remove(callback);
                }
            });
        }

        @Override
        public void onAdvertisingEnabled(int advertiserId, boolean enabled, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingEnabled(advertisingSet, enabled, status);
                }
            });
        }

        @Override
        public void onAdvertisingDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onScanResponseDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onScanResponseDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onAdvertisingParametersUpdated(int advertiserId, int txPower, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingParametersUpdated(advertisingSet, txPower, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingParametersUpdated(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingParametersUpdated(advertisingSet, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingEnabled(int advertiserId, boolean enable, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingEnabled(advertisingSet, enable, status);
                }
            });
        }
    };
}","{
    return new IAdvertisingSetCallback.Stub() {

        @Override
        public void onAdvertisingSetStarted(int advertiserId, int txPower, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    if (status != AdvertisingSetCallback.ADVERTISE_SUCCESS) {
                        callback.onAdvertisingSetStarted(null, 0, status);
                        mCallbackWrappers.remove(callback);
                        return;
                    }
                    AdvertisingSet advertisingSet = new AdvertisingSet(advertiserId, mBluetoothManager, mAttributionSource);
                    mAdvertisingSets.put(advertiserId, advertisingSet);
                    callback.onAdvertisingSetStarted(advertisingSet, txPower, status);
                }
            });
        }

        @Override
        public void onOwnAddressRead(int advertiserId, int addressType, String address) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onOwnAddressRead(advertisingSet, addressType, address);
                }
            });
        }

        @Override
        public void onAdvertisingSetStopped(int advertiserId) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingSetStopped(advertisingSet);
                    mAdvertisingSets.remove(advertiserId);
                    mCallbackWrappers.remove(callback);
                }
            });
        }

        @Override
        public void onAdvertisingEnabled(int advertiserId, boolean enabled, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingEnabled(advertisingSet, enabled, status);
                }
            });
        }

        @Override
        public void onAdvertisingDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onScanResponseDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onScanResponseDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onAdvertisingParametersUpdated(int advertiserId, int txPower, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onAdvertisingParametersUpdated(advertisingSet, txPower, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingParametersUpdated(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingParametersUpdated(advertisingSet, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingDataSet(int advertiserId, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingDataSet(advertisingSet, status);
                }
            });
        }

        @Override
        public void onPeriodicAdvertisingEnabled(int advertiserId, boolean enable, int status) {
            handler.post(new Runnable() {

                @Override
                public void run() {
                    AdvertisingSet advertisingSet = mAdvertisingSets.get(advertiserId);
                    callback.onPeriodicAdvertisingEnabled(advertisingSet, enable, status);
                }
            });
        }
    };
}",1,,,-1,,"[@SuppressLint(""AndroidFrameworkBluetoothPermission"")]",-1,-1,-1,-1,-1,-1,,,,
76,<android.view.autofill.AutofillManager: boolean isEnabled()>,30,31,<android.view.autofill.AutofillManager: boolean isEnabled()>,<android.view.autofill.AutofillManager: boolean isEnabled()>,0,"{
    if (!hasAutofillFeature()) {
        return false;
    }
    synchronized (mLock) {
        if (isDisabledByServiceLocked()) {
            return false;
        }
        ensureServiceClientAddedIfNeededLocked();
        return mEnabled;
    }
}","{
    if (!hasAutofillFeature()) {
        return false;
    }
    synchronized (mLock) {
        if (isDisabledByServiceLocked()) {
            return false;
        }
        final boolean clientAdded = tryAddServiceClientIfNeededLocked();
        return clientAdded ? mEnabled : false;
    }
}",1,"/**
 * Checks whether autofill is enabled for the current user.
 *
 * <p>Typically used to determine whether the option to explicitly request autofill should
 * be offered - see {@link #requestAutofill(View)}.
 *
 * @return whether autofill is enabled for the current user.
 */
","/**
 * Checks whether autofill is enabled for the current user.
 *
 * <p>Typically used to determine whether the option to explicitly request autofill should
 * be offered - see {@link #requestAutofill(View)}.
 *
 * @return whether autofill is enabled for the current user.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The code change includes modifications within the synchronized block where ensureServiceClientAddedIfNeededLocked(); is replaced by final boolean clientAdded = tryAddServiceClientIfNeededLocked() and the return statement is altered from return mEnabled; to return clientAdded ? mEnabled : false;. This indicates changes in return statements (1), control dependencies (3), and other statements (4).","The late implementation introduces a condition that potentially changes the value returned depending on whether the client is successfully added or not (clientAdded ? mEnabled : false). In the early version, it simply returned mEnabled, without this conditional check. Thus, the API could_return_a_different_value based on the new condition in the late version which indicates a compatibility issue of type 1."
77,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",30,31,"<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getThemeValue(long,int,TypedValue,boolean)>",0,"{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeThemeGetAttributeValue(mObject, theme, resId, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = getPooledStringForCookie(cookie, outValue.data);
        }
        return true;
    }
}","{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeThemeGetAttributeValue(mObject, theme, resId, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            if ((outValue.string = getPooledStringForCookie(cookie, outValue.data)) == null) {
                return false;
            }
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated with a particular
 * resource identifier for the current configuration. Resolves theme
 * attributes against the specified theme.
 *
 * @param theme the native pointer of the theme
 * @param resId the resource identifier to load
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a conditional check introduced within an 'if' statement block which can impact the outcome of the method. This change involves a new control flow for checking if the string result from getPooledStringForCookie is null and returning false if so. Therefore, the change types include return statement change (1), control dependency change (3), and other statement change due to additional condition checks and assignments within the block (4).","A new condition check may result in the method returning false instead of true when the string is null, which was not a behavior in the early version. Hence, this constitutes a Compatibility Issue caused by potential different return values (1)."
78,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",30,31,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onScannerRegistered(int,int)>",0,"{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister scanner.
                    mBluetoothGatt.unregisterScanner(scannerId);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, mOpPackageName, mFeatureId);
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}","{
    Log.d(TAG, ""onScannerRegistered() - status="" + status + "" scannerId="" + scannerId + "" mScannerId="" + mScannerId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mScannerId == -1) {
                    // Registration succeeds after timeout, unregister scanner.
                    mBluetoothGatt.unregisterScanner(scannerId, mAttributionSource);
                } else {
                    mScannerId = scannerId;
                    mBluetoothGatt.startScan(mScannerId, mSettings, mFilters, mResultStorages, mAttributionSource);
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mScannerId = -1;
            }
        } else if (status == ScanCallback.SCAN_FAILED_SCANNING_TOO_FREQUENTLY) {
            // applicaiton was scanning too frequently
            mScannerId = -2;
        } else {
            // registration failed
            mScannerId = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method mBluetoothGatt.unregisterScanner(scannerId) has changed to mBluetoothGatt.unregisterScanner(scannerId, mAttributionSource) and mBluetoothGatt.startScan(...) has updated the parameters. Therefore, the code change type is 5 since the dependent APIs' signatures have changed.",There is no Compatibility Issue as the signature changes in the dependent API do not directly lead to different return values or exception handling in this method; it only modifies the parameters passed to the dependent methods. The behavior concerning return values and exception handling in 'onScannerRegistered' remains the same.
79,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,30,31,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,<android.os.StrictMode.VmPolicy.Builder: Builder detectAll()>,0,"{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    if (targetSdk >= Build.VERSION_CODES.Q) {
        detectCredentialProtectedWhileLocked();
    }
    if (targetSdk >= Build.VERSION_CODES.R) {
        detectIncorrectContextUse();
    }
    return this;
}","{
    detectLeakedSqlLiteObjects();
    final int targetSdk = VMRuntime.getRuntime().getTargetSdkVersion();
    if (targetSdk >= Build.VERSION_CODES.HONEYCOMB) {
        detectActivityLeaks();
        detectLeakedClosableObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN) {
        detectLeakedRegistrationObjects();
    }
    if (targetSdk >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
        detectFileUriExposure();
    }
    if (targetSdk >= Build.VERSION_CODES.M) {
        // facility for apps to mark sockets that should be ignored
        if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
            detectCleartextNetwork();
        }
    }
    if (targetSdk >= Build.VERSION_CODES.O) {
        detectContentUriWithoutPermission();
        detectUntaggedSockets();
    }
    if (targetSdk >= Build.VERSION_CODES.Q) {
        detectCredentialProtectedWhileLocked();
    }
    if (targetSdk >= Build.VERSION_CODES.R) {
        detectIncorrectContextUse();
    }
    if (targetSdk >= Build.VERSION_CODES.S) {
        detectUnsafeIntentLaunch();
    }
    return this;
}",1,"/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
","/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of SQLite cursors, Activities, and
 * other closable objects but will likely expand in future releases.
 */
",-1,[@NonNull],"[@SuppressWarnings(""AndroidFrameworkCompatChange""), @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"An additional conditional check if (targetSdk >= Build.VERSION_CODES.S) { detectUnsafeIntentLaunch(); } has been added, which results in other statements being executed without changing the control dependency, return statements, or exception handling within existing statements. This makes the code change type 4.","Since the change is adding a new condition which only gets executed if the targetSdk is S or higher, and doesn't alter the behavior for lower sdk versions nor change return values, control flows, or exception handlings for existing conditions, there is no Compatibility Issue in the given API between the two versions."
80,<android.content.ContentProvider: String getCallingPackageUnchecked()>,30,31,<android.content.ContentProvider: String getCallingPackageUnchecked()>,<android.content.ContentProvider: String getCallingPackageUnchecked()>,0,"{
    final Pair<String, String> pkg = mCallingPackage.get();
    if (pkg != null) {
        return pkg.first;
    }
    return null;
}","{
    final AttributionSource attributionSource = mCallingAttributionSource.get();
    if (attributionSource != null) {
        return attributionSource.getPackageName();
    }
    return null;
}",1,"/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have
 * <em>not</em> been verified to belong to the calling UID. Returns
 * {@code null} if not currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 */
","/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have
 * <em>not</em> been verified to belong to the calling UID. Returns
 * {@code null} if not currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changes the way the calling package name is obtained, from using a Pair object to using an AttributionSource object, and calls a different method getPackageName(). Since this reflects a change within the entire method body without altering the control flow or exception handling, the change type is 4. Additionally, it signifies a change in the dependent API (from 'Pair.first' to 'AttributionSource.getPackageName()'), thus the change type is also 5.","There's no Compatibility Issue detected as both the early and late versions return a String type and handle no exceptions, and the method contract is preserved through returning the calling package or null in both versions. Hence, the behavior of the API in terms of return value and exception handling should remain consistent across versions, despite the change in the underlying implementation details and dependent API."
82,"<android.widget.EdgeEffect: void onPull(float,float)>",30,31,"<android.widget.EdgeEffect: void onPull(float,float)>","<android.widget.EdgeEffect: void onPull(float,float)>",0,"{
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
        return;
    }
    if (mState != STATE_PULL) {
        mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    final float absdd = Math.abs(deltaDistance);
    mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
    } else {
        final float scale = (float) (Math.max(0, 1 - 1 / Math.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3d) / 0.7d);
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
}","{
    int edgeEffectBehavior = getCurrentEdgeEffectBehavior();
    if (edgeEffectBehavior == TYPE_NONE) {
        finish();
        return;
    }
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration && edgeEffectBehavior == TYPE_GLOW) {
        return;
    }
    if (mState != STATE_PULL) {
        if (edgeEffectBehavior == TYPE_STRETCH) {
            // Restore the mPullDistance to the fraction it is currently showing -- we want
            // to ""catch"" the current stretch value.
            mPullDistance = mDistance;
        } else {
            mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
        }
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    if (edgeEffectBehavior == TYPE_STRETCH) {
        // Don't allow stretch beyond 1
        mPullDistance = Math.min(1f, mPullDistance);
    }
    mDistance = Math.max(0f, mPullDistance);
    mVelocity = 0;
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
        mGlowAlpha = mGlowAlphaStart = 0;
    } else {
        final float absdd = Math.abs(deltaDistance);
        mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
        final float scale = (float) (Math.max(0, 1 - 1 / Math.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3d) / 0.7d);
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
    if (edgeEffectBehavior == TYPE_STRETCH && mDistance == 0) {
        mState = STATE_IDLE;
    }
}",1,"/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 * @param displacement The displacement from the starting side of the effect of the point
 * initiating the pull. In the case of touch this is the finger position.
 * Values may be from 0-1.
 */
","/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 * @param displacement The displacement from the starting side of the effect of the point
 * initiating the pull. In the case of touch this is the finger position.
 * Values may be from 0-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There are multiple changes here. Introduction of an edgeEffectBehavior variable and conditional logic based on it, change in the if conditionals, and additional assignments to variables like mDistance and mVelocity. Given these are not control flow changes, return statement changes, or exception handling changes, the code change type is 4.","The additional conditional logic and assignments based on edgeEffectBehavior will affect the state of the EdgeEffect object such as mDistance, mVelocity, mState and could lead to different behavior when calling onPull(), especially considering different types of behavior specified by the EDGE TYPE_NONE, TYPE_GLOW, and TYPE_STRETCH. Since the method's internal state changes differently, which is observable through the object's interaction, the CI type is 1."
83,"<android.app.backup.BackupAgent.BackupServiceBinder: void doQuotaExceeded(long,long,IBackupCallback)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doQuotaExceeded(long,long,IBackupCallback)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doQuotaExceeded(long,long,IBackupCallback)>",0,"{
    long ident = Binder.clearCallingIdentity();
    long result = RESULT_ERROR;
    try {
        BackupAgent.this.onQuotaExceeded(backupDataBytes, quotaBytes);
        result = RESULT_SUCCESS;
    } catch (Exception e) {
        Log.d(TAG, ""onQuotaExceeded("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.operationComplete(result);
        } catch (RemoteException e) {
        // We will time out anyway.
        }
    }
}","{
    long result = RESULT_ERROR;
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onQuotaExceeded(backupDataBytes, quotaBytes);
        result = RESULT_SUCCESS;
    } catch (Exception e) {
        Log.d(TAG, ""onQuotaExceeded("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.operationComplete(result);
        } catch (RemoteException e) {
        // We will time out anyway.
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the reordering of statements (the declaration of 'result' is moved before 'ident'). There's no change to the control flow, return values, exception handling, or any dependent API, so the code change type is 4 (Other statement changed).","The change does not affect the API's behavior, so there is no Compatibility Issue. The value returned and the exceptions that could be thrown remain the same."
84,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,30,31,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String flagToString(int)>,0,"{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return ""FLAG_SERVICE_HANDLES_DOUBLE_TAP"";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return ""FLAG_REQUEST_MULTI_FINGER_GESTURES"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}","{
    switch(flag) {
        case DEFAULT:
            return ""DEFAULT"";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return ""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return ""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return ""FLAG_SERVICE_HANDLES_DOUBLE_TAP"";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return ""FLAG_REQUEST_MULTI_FINGER_GESTURES"";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return ""FLAG_REQUEST_2_FINGER_PASSTHROUGH"";
        case FLAG_SEND_MOTION_EVENTS:
            return ""FLAG_SEND_MOTION_EVENTS"";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return ""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"";
        case FLAG_REPORT_VIEW_IDS:
            return ""FLAG_REPORT_VIEW_IDS"";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return ""FLAG_REQUEST_FILTER_KEY_EVENTS"";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return ""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return ""FLAG_ENABLE_ACCESSIBILITY_VOLUME"";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return ""FLAG_REQUEST_ACCESSIBILITY_BUTTON"";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return ""FLAG_REQUEST_FINGERPRINT_GESTURES"";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return ""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"Between the early version and the late version of the `flagToString` method, several cases in the switch statement have been changed. Specifically, two flags `FLAG_REQUEST_2_FINGER_PASSTHROUGH` and `FLAG_SEND_MOTION_EVENTS` have been introduced, and their corresponding return statements have been added to the switch control structure. This means that the method has been modified to include the handling of additional flag constant values, which translates to changes in return statements and a change in the dependent API because the method now recognizes additional flags that it did not in the earlier version.","The potential compatibility issue arises because the method will return different string values for new or modified flag inputs in the late version compared to the early version. For any code expecting the early version behavior when passing the new flags, this can result in unexpected behavior or incorrect handling since the corresponding strings for the new flags would not be available in the earlier version. Hence, the compatibility issue would be a difference in return values or types (type 1)."
85,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",30,31,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP) {
        BluetoothPbap pbap = new BluetoothPbap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, ""getProfileProxy(): BluetoothHealth is deprecated"");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener);
            return true;
        }
        return false;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null) {
        return false;
    }
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.HID_HOST) {
        BluetoothHidHost iDev = new BluetoothHidHost(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.PBAP) {
        BluetoothPbap pbap = new BluetoothPbap(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        Log.e(TAG, ""getProfileProxy(): BluetoothHealth is deprecated"");
        return false;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.MAP_CLIENT) {
        BluetoothMapClient mapClient = new BluetoothMapClient(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.HID_DEVICE) {
        BluetoothHidDevice hidDevice = new BluetoothHidDevice(context, listener, this);
        return true;
    } else if (profile == BluetoothProfile.HEARING_AID) {
        if (isHearingAidProfileSupported()) {
            BluetoothHearingAid hearingAid = new BluetoothHearingAid(context, listener, this);
            return true;
        }
        return false;
    } else if (profile == BluetoothProfile.LE_AUDIO) {
        BluetoothLeAudio leAudio = new BluetoothLeAudio(context, listener, this);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},
 * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link
 * BluetoothProfile#GATT_SERVER}. Clients must implement {@link
 * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the
 * proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link
 * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP},
 * {@link BluetoothProfile#GATT}, {@link BluetoothProfile#HEARING_AID}, or {@link
 * BluetoothProfile#GATT_SERVER}. Clients must implement {@link
 * BluetoothProfile.ServiceListener} to get notified of the connection status and to get the
 * proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, {@link
 * BluetoothProfile#HEARING_AID} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */
",-1,,"[@SuppressLint({ ""AndroidFrameworkRequiresPermission"", ""AndroidFrameworkBluetoothPermission"" })]",-1,-1,-1,-1,-1,-1,,,,
86,<android.view.Display: int getState()>,30,31,<android.view.Display: int getState()>,<android.view.Display: int getState()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mIsValid ? mDisplayInfo.state : STATE_UNKNOWN;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mIsValid ? mDisplayInfo.state : STATE_UNKNOWN;
    }
}",1,"/**
 * Gets the state of the display, such as whether it is on or off.
 *
 * @return The state of the display: one of {@link #STATE_OFF}, {@link #STATE_ON},
 * {@link #STATE_DOZE}, {@link #STATE_DOZE_SUSPEND}, {@link #STATE_ON_SUSPEND}, or
 * {@link #STATE_UNKNOWN}.
 */
","/**
 * Gets the state of the display, such as whether it is on or off.
 *
 * @return The state of the display: one of {@link #STATE_OFF}, {@link #STATE_ON},
 * {@link #STATE_DOZE}, {@link #STATE_DOZE_SUSPEND}, {@link #STATE_ON_SUSPEND}, or
 * {@link #STATE_UNKNOWN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the object that synchronizes block, from `this` to `mLock`, so the change is related to synchronization which doesnâ€™t affect the return value or exception handling of the method. Therefore, the code change type is 4.","Since the behavior within the synchronized block remains the same and the values returned by the method will be the same regardless of which object is used for synchronization, there is no compatibility issue. The CI type is 0."
87,<android.security.ConfirmationPrompt: boolean isSupported(Context)>,30,31,<android.security.ConfirmationPrompt: boolean isSupported(Context)>,<android.security.ConfirmationPrompt: boolean isSupported(Context)>,0,"{
    if (isAccessibilityServiceRunning(context)) {
        return false;
    }
    return KeyStore.getInstance().isConfirmationPromptSupported();
}","{
    if (isAccessibilityServiceRunning(context)) {
        return false;
    }
    return new AndroidProtectedConfirmation().isConfirmationPromptSupported();
}",1,"/**
 * Checks if the device supports confirmation prompts.
 *
 * @param context the application context.
 * @return true if confirmation prompts are supported by the device.
 */
","/**
 * Checks if the device supports confirmation prompts.
 *
 * @param context the application context.
 * @return true if confirmation prompts are supported by the device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method for checking if the ConfirmationPrompt is supported has changed from KeyStore.getInstance().isConfirmationPromptSupported() to new AndroidProtectedConfirmation().isConfirmationPromptSupported(). This change does not fall under return statement, exception handling, or control dependency changes, so it categorizes as Other statement changed (4). Additionally, since it also represents the use of a different API (a constructor of AndroidProtectedConfirmation class vs. a static method of KeyStore class), it falls under Dependent API changed (5).","This change to use a different API can potentially lead to a different return value (true or false) because the methods are part of separate classes and could have differing implementations for the isConfirmationPromptSupported method, causing a CI in case the two implementations behave differently under any circumstance. Hence, the CI type is 1, for potentially returning different values."
88,<android.bluetooth.le.AdvertiseData.Builder: Builder addServiceUuid(ParcelUuid)>,30,31,<android.bluetooth.le.AdvertiseData.Builder: Builder addServiceUuid(ParcelUuid)>,<android.bluetooth.le.AdvertiseData.Builder: Builder addServiceUuid(ParcelUuid)>,0,"{
    if (serviceUuid == null) {
        throw new IllegalArgumentException(""serivceUuids are null"");
    }
    mServiceUuids.add(serviceUuid);
    return this;
}","{
    if (serviceUuid == null) {
        throw new IllegalArgumentException(""serviceUuid is null"");
    }
    mServiceUuids.add(serviceUuid);
    return this;
}",1,"/**
 * Add a service UUID to advertise data.
 *
 * @param serviceUuid A service UUID to be advertised.
 * @throws IllegalArgumentException If the {@code serviceUuids} are null.
 */
","/**
 * Add a service UUID to advertise data.
 *
 * @param serviceUuid A service UUID to be advertised.
 * @throws IllegalArgumentException If the {@code serviceUuid} is null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There are no changes to the method's functionality or behavior. The only change is the correction of a spelling mistake in the exception message (""serivceUuids"" to ""serviceUuid"").",There are no Compatibility Issues since the change does not affect the behavior of the method; it only corrects a typo within an error message and does not alter the execution flow.
89,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",30,31,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String,CancellationSignal)>",0,"{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, mAttributionTag, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mAttributionSource, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mContentProvider.openAssetFile(mPackageName, mAttributionTag, url, mode, remoteSignal) to mContentProvider.openAssetFile(mAttributionSource, url, mode, remoteSignal). The parameters passed to the method openAssetFile have changed, indicating a dependent API changed. Therefore, the change type is 1,5.","The change in parameters suggests that the method could potentially return a different AssetFileDescriptor due to different input values passed to openAssetFile. This alteration could result in a different behavior when the method is called, hence the CI type is 1."
91,<android.view.Display: boolean isMinimalPostProcessingSupported()>,30,31,<android.view.Display: boolean isMinimalPostProcessingSupported()>,<android.view.Display: boolean isMinimalPostProcessingSupported()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.minimalPostProcessingSupported;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.minimalPostProcessingSupported;
    }
}",1,"/**
 * <p> Returns true if the connected display can be switched into a mode with minimal
 * post processing. </p>
 *
 * <p> If the Display sink is connected via HDMI, this method will return true if the
 * display supports either Auto Low Latency Mode or Game Content Type.
 *
 * <p> If the Display sink has an internal connection or uses some other protocol than
 * HDMI, this method will return true if the sink can be switched into an
 * implementation-defined low latency image processing mode. </p>
 *
 * <p> The ability to switch to a mode with minimal post processing may be disabled
 * by a user setting in the system settings menu. In that case, this method returns
 * false. </p>
 *
 * @see android.view.Window#setPreferMinimalPostProcessing
 */
","/**
 * <p> Returns true if the connected display can be switched into a mode with minimal
 * post processing. </p>
 *
 * <p> If the Display sink is connected via HDMI, this method will return true if the
 * display supports either Auto Low Latency Mode or Game Content Type.
 *
 * <p> If the Display sink has an internal connection or uses some other protocol than
 * HDMI, this method will return true if the sink can be switched into an
 * implementation-defined low latency image processing mode. </p>
 *
 * <p> The ability to switch to a mode with minimal post processing may be disabled
 * by a user setting in the system settings menu. In that case, this method returns
 * false. </p>
 *
 * @see android.view.Window#setPreferMinimalPostProcessing
 */
",-1,"[@SuppressLint(""VisiblySynchronized"")]","[@SuppressLint(""VisiblySynchronized"")]",-1,-1,-1,-1,-1,-1,4,0,"The object on which the synchronization is performed has changed from `this` to `mLock`. This is a change in the synchronization detail but it doesn't affect the API's behavior externally, so the code change type is 4.",There is no Compatibility Issue because the change in the lock object does not affect the return value or the exceptions thrown by this method. The synchronization is an internal change that doesn't lead to different behavior as seen by the caller of the method.
92,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,30,31,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled()) {
            return service.getDevicesMatchingConnectionStates(states);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@Override, @NonNull]","[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT), @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method return statement has been modified to include a call to Attributable.setAttributionSource, which is a new addition in the late version that wraps around the original return value to associate an attribution source. Additionally, the method now requires permission annotations, indicating a change in permission requirements. Thus, the code change types are 4 and 5.","Despite the change in how the return value is wrapped with an attribution source and the new permission requirements, these alterations do not introduce a compatibility issue that would cause the API to return different values or throw different exceptions. The underlying business logic and the return behavior of the API remain unchanged. Therefore, there is no compatibility issue."
95,"<android.speech.tts.TextToSpeech: int addSpeech(String,String,int)>",30,31,"<android.speech.tts.TextToSpeech: int addSpeech(String,String,int)>","<android.speech.tts.TextToSpeech: int addSpeech(String,String,int)>",0,"{
    synchronized (mStartLock) {
        mUtterances.put(text, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}","{
    return addSpeech(text, makeResourceUri(packagename, resourceId));
}",1,"/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. After a call to this method, subsequent calls to
 * {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. After a call to this method, subsequent calls to
 * {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The early implementation synchronized on mStartLock and updated the mUtterances map before returning SUCCESS, while the late implementation calls another method addSpeech(String, Uri) directly. There is also the change in the way that the Uri is being created and passed to another method. Hence, the change types are 4 for the removal of the synchronization block and 5 for calling a different overloaded method addSpeech().","The removal of the synchronized block and changing the internal implementation to call a different method with potentially different handling means that the method may behave differently under concurrent conditions or may return a different result based on the implementation of the newly called method. Therefore, the CI type is 1, potentially caused by a different return value."
96,"<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>",30,31,"<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>","<android.content.res.AssetManager: XmlResourceParser openXmlResourceParser(int,String)>",0,"{
    try (XmlBlock block = openXmlBlockAsset(cookie, fileName)) {
        XmlResourceParser parser = block.newParser();
        // be paranoid.
        if (parser == null) {
            throw new AssertionError(""block.newParser() returned a null parser"");
        }
        return parser;
    }
}","{
    try (XmlBlock block = openXmlBlockAsset(cookie, fileName)) {
        XmlResourceParser parser = block.newParser();
        // be careful.
        if (parser == null) {
            throw new AssertionError(""block.newParser() returned a null parser"");
        }
        return parser;
    }
}",1,"/**
 * Retrieve a parser for a compiled XML file.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName The name of the file to retrieve.
 */
","/**
 * Retrieve a parser for a compiled XML file.
 *
 * @param cookie Identifier of the package to be opened.
 * @param fileName The name of the file to retrieve.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the actual code logic; only a comment was updated, which doesn't affect the functionality or behavior of the method.","Because no functional code has been changed, there is no Compatibility Issue between the two versions."
100,"<android.bluetooth.BluetoothGattServer: void setPreferredPhy(BluetoothDevice,int,int,int)>",30,31,"<android.bluetooth.BluetoothGattServer: void setPreferredPhy(BluetoothDevice,int,int,int)>","<android.bluetooth.BluetoothGattServer: void setPreferredPhy(BluetoothDevice,int,int,int)>",0,"{
    try {
        mService.serverSetPreferredPhy(mServerIf, device.getAddress(), txPhy, rxPhy, phyOptions);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    try {
        mService.serverSetPreferredPhy(mServerIf, device.getAddress(), txPhy, rxPhy, phyOptions, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications peferences,
 * local and remote controller capabilities. Controller can override these settings. <p> {@link
 * BluetoothGattServerCallback#onPhyUpdate} will be triggered as a result of this call, even if
 * no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param device The remote device to send this response to
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */
","/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications peferences,
 * local and remote controller capabilities. Controller can override these settings. <p> {@link
 * BluetoothGattServerCallback#onPhyUpdate} will be triggered as a result of this call, even if
 * no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param device The remote device to send this response to
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method has changed as an additional parameter `mAttributionSource` is now being passed to the `mService.serverSetPreferredPhy` method. This indicates a change in the dependent API since there is an additional attribute being used (change type 5). There is no change in the return statement, exception handling statement, or control dependency, so the change type 4 is also applicable due to the alteration in the method invocation parameters.","There's no Compatibility Issue since the change does not affect the behavior of the API with respect to the return value or the exceptions that are thrown. The API's method signature remains the same, and the change does not introduce any new execution paths or modify existing ones that would change the outcome of the method invocation."
101,<android.os.VibrationAttributes.Builder: Builder setUsage(int)>,30,31,<android.os.VibrationAttributes.Builder: Builder setUsage(int)>,<android.os.VibrationAttributes.Builder: Builder setUsage(int)>,0,"{
    mUsage = usage;
    return this;
}","{
    mOriginalAudioUsage = AudioAttributes.USAGE_UNKNOWN;
    mUsage = usage;
    return this;
}",1,"/**
 * Sets the attribute describing the type of corresponding vibration.
 * @param usage one of {@link VibrationAttributes#USAGE_ALARM},
 * {@link VibrationAttributes#USAGE_RINGTONE},
 * {@link VibrationAttributes#USAGE_NOTIFICATION},
 * {@link VibrationAttributes#USAGE_COMMUNICATION_REQUEST},
 * {@link VibrationAttributes#USAGE_TOUCH},
 * {@link VibrationAttributes#USAGE_PHYSICAL_EMULATION},
 * {@link VibrationAttributes#USAGE_HARDWARE_FEEDBACK}.
 * @return the same Builder instance.
 */
","/**
 * Sets the attribute describing the type of corresponding vibration.
 * @param usage one of {@link VibrationAttributes#USAGE_ALARM},
 * {@link VibrationAttributes#USAGE_RINGTONE},
 * {@link VibrationAttributes#USAGE_NOTIFICATION},
 * {@link VibrationAttributes#USAGE_COMMUNICATION_REQUEST},
 * {@link VibrationAttributes#USAGE_TOUCH},
 * {@link VibrationAttributes#USAGE_PHYSICAL_EMULATION},
 * {@link VibrationAttributes#USAGE_HARDWARE_FEEDBACK}.
 * @return the same Builder instance.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"An additional assignment statement mOriginalAudioUsage = AudioAttributes.USAGE_UNKNOWN is added before the existing assignment and return statements, but the return type and the value returned (this) remain unchanged.","The additional assignment does not affect the returned value or the type returned by the method; it simply modifies an additional internal state within the builder. There is no change in how exceptions are handled, nor is there a control statement change that affects the execution flow leading to the return value. Therefore, there is no CI."
102,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,30,31,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,<android.content.pm.ShortcutManager: boolean setDynamicShortcuts(List<ShortcutInfo>)>,0,"{
    try {
        return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return ((boolean) getFutureOrThrow(mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId())));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed by wrapping the method call with a new method `getFutureOrThrow()`. This indicates a change in how the result is obtained and potentially in the type of the result being returned (from a direct boolean to an Object that is cast to a boolean), and the code change type is 1. The change implies there is now a dependency on 'getFutureOrThrow()' method which was not there before, indicating the code change type 5.","Since there is a change in the return statement due to a new method being introduced to retrieve the value, this could potentially cause a different value to be returned. Therefore, the CI type is 1."
103,<android.view.Display: String getName()>,30,31,<android.view.Display: String getName()>,<android.view.Display: String getName()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.name;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.name;
    }
}",1,"/**
 * Gets the name of the display.
 * <p>
 * Note that some displays may be renamed by the user.
 * </p>
 *
 * @return The display's name.
 */
","/**
 * Gets the name of the display.
 * <p>
 * Note that some displays may be renamed by the user.
 * </p>
 *
 * @return The display's name.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object being used for synchronization has changed from 'this' to 'mLock', which is considered Other statement changed (code change type 4).","The change in synchronization lock object will not cause the API to return a diffrent value or type, nor will it change the exception handling; thus, there is No Compatibility Issue (CI type 0)."
104,<android.content.pm.ShortcutManager: void removeDynamicShortcuts(List<String>)>,30,31,<android.content.pm.ShortcutManager: void removeDynamicShortcuts(List<String>)>,<android.content.pm.ShortcutManager: void removeDynamicShortcuts(List<String>)>,0,"{
    try {
        mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete dynamic shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete dynamic shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call to the `mService.removeDynamicShortcuts` method in the early version is replaced with `getFutureOrThrow(mService.removeDynamicShortcuts(...))` in the late version; this indicates that another method is now being called to handle the result of `removeDynamicShortcuts` which is a change type 4. Moreover, since the dependent API `mService.removeDynamicShortcuts` is still being used inside `getFutureOrThrow`, the actual API used hasn't changed, but the way its result is handled has, marking it as change type 5 as well.","There is no Compatibility Issue as the method still throws the same exception, and being a `void` method, it does not return any value, so the behavior that clients depend upon remains unchanged. The update in the way of handling the result of `mService.removeDynamicShortcuts` does not affect the method's observable behavior from the caller's perspective."
105,<android.net.Uri.PathPart: PathPart fromEncoded(String)>,30,31,<android.net.Uri.PathPart: PathPart fromEncoded(String)>,<android.net.Uri.PathPart: PathPart fromEncoded(String)>,0,"{
    return from(encoded, NOT_CACHED);
}","{
    return from(encoded, NotCachedHolder.NOT_CACHED);
}",1,"/**
 * Creates a path from the encoded string.
 *
 * @param encoded part string
 */
","/**
 * Creates a path from the encoded string.
 *
 * @param encoded part string
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change represents a reference update to a constant. The variable 'NOT_CACHED' is replaced with 'NotCachedHolder.NOT_CACHED', which is presumably the same constant value but perhaps now located in a different class or holder structure, indicating a dependent API change.","This change does not alter the external behavior of the method; it only changes the internal reference to a constant. There is no indication that the value has changed, hence no Compatibility Issue should arise due to this modification."
106,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,30,31,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return getTaskService().getTasks(maxNum);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return ActivityTaskManager.getInstance().getTasks(maxNum);
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the method which is being called to retrieve running tasks, from getTaskService().getTasks(maxNum) to ActivityTaskManager.getInstance().getTasks(maxNum). It represents a change in the dependent API that the current API relies on, so the code change type is 5.","Even though the underlying method for obtaining the running tasks has changed, the modification does not directly indicate a variation in the return type or exception handling behavior of the API itself. Thus, based on the information provided, there is no Compatibility Issue detected."
107,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: SurfaceParams build()>,30,31,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: SurfaceParams build()>,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: SurfaceParams build()>,0,"{
    return new SurfaceParams(surface, flags, alpha, matrix, windowCrop, layer, cornerRadius, backgroundBlurRadius, visible);
}","{
    return new SurfaceParams(surface, flags, alpha, matrix, windowCrop, layer, cornerRadius, backgroundBlurRadius, visible, mergeTransaction);
}",1,"/**
 * @return a new SurfaceParams instance
 */
","/**
 * @return a new SurfaceParams instance
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of the SurfaceParams object has an additional parameter in the late version ('mergeTransaction'), resulting in the creation of a SurfaceParams object with different information. This is a change type 1,5 as it is a change in the return statement and depends on the changed constructor (a dependent API).","Since the constructor of SurfaceParams now accepts a new parameter, it might initialize the SurfaceParams object differently. This presents a potential different return value if the additional parameter affects the state or behavior of the object being returned. Therefore, the CI type is 1."
109,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,30,31,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,<android.app.UiAutomation: ParcelFileDescriptor executeShellCommand(String)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    warnIfBetterCommand(command);
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink, null);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}","{
    warnIfBetterCommand(command);
    ParcelFileDescriptor source = null;
    ParcelFileDescriptor sink = null;
    try {
        ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
        source = pipe[0];
        sink = pipe[1];
        // Calling out without a lock held.
        mUiAutomationConnection.executeShellCommand(command, sink, null);
    } catch (IOException ioe) {
        Log.e(LOG_TAG, ""Error executing shell command!"", ioe);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing shell command!"", re);
    } finally {
        IoUtils.closeQuietly(sink);
    }
    return source;
}",1,"/**
 * Executes a shell command. This method returns a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the returned file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 *
 * @see #adoptShellPermissionIdentity()
 */
","/**
 * Executes a shell command. This method returns a file descriptor that points
 * to the standard output stream. The command execution is similar to running
 * ""adb shell <command>"" from a host connected to the device.
 * <p>
 * <strong>Note:</strong> It is your responsibility to close the returned file
 * descriptor once you are done reading.
 * </p>
 *
 * @param command The command to execute.
 * @return A file descriptor to the standard output stream.
 *
 * @see #adoptShellPermissionIdentity()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the removal of the synchronized block along with the call to throwIfNotConnectedLocked(). There is no change in the return statement, exception handling statement, or control dependency, so the change type is 4.","Removing the synchronized block and the connectivity check will not change the returned variable since the API's main functionality remains the same. The source variable, representing the output of the shell command, will not be affected by these changes, so there will be no compatibility issue from this change."
112,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,30,31,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    mNestedYOffset = 0;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                 * If being flinged and user touches the screen, initiate drag;
                 * otherwise don't. mScroller.isFinished should be false when
                 * being flinged. We need to call computeScrollOffset() first so that
                 * isFinished() is correct.
                */
                mScroller.computeScrollOffset();
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            stopNestedScroll();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and they is moving their finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from their original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop && (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    mNestedYOffset = 0;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                 * If being flinged and user touches the screen, initiate drag;
                 * otherwise don't. mScroller.isFinished should be false when
                 * being flinged. We need to call computeScrollOffset() first so that
                 * isFinished() is correct.
                */
                mScroller.computeScrollOffset();
                mIsBeingDragged = !mScroller.isFinished() || !mEdgeGlowBottom.isFinished() || !mEdgeGlowTop.isFinished();
                // Catch the edge effect if it is active.
                if (!mEdgeGlowTop.isFinished()) {
                    mEdgeGlowTop.onPullDistance(0f, ev.getX() / getWidth());
                }
                if (!mEdgeGlowBottom.isFinished()) {
                    mEdgeGlowBottom.onPullDistance(0f, 1f - ev.getX() / getWidth());
                }
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            stopNestedScroll();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
113,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,30,31,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,<android.app.WallpaperManager: int getDesiredMinimumHeight()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    StrictMode.assertUiContext(mContext, ""getDesiredMinimumHeight"");
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 *
 * @see #getDesiredMinimumWidth()
 */
","/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 *
 * @see #getDesiredMinimumWidth()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement `StrictMode.assertUiContext(mContext, ""getDesiredMinimumHeight"");` is introduced at the beginning, so the code change type is 4.","The newly introduced statement does not change the return value or exception handling of the method. It is a check to ensure that the method is being invoked in the context of a user interface, which does not impact the functionality of the existing code in terms of output or exception behavior. Therefore, there is no Compatibility Issue, and the CI type is 0."
114,<android.speech.SpeechRecognizer: void startListening(Intent)>,30,31,<android.speech.SpeechRecognizer: void startListening(Intent)>,<android.speech.SpeechRecognizer: void startListening(Intent)>,0,"{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException(""intent must not be null"");
    }
    checkIsCalledFromMainThread();
    if (mConnection == null) {
        // first time connection
        mConnection = new Connection();
        Intent serviceIntent = new Intent(RecognitionService.SERVICE_INTERFACE);
        if (mServiceComponent == null) {
            String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.VOICE_RECOGNITION_SERVICE);
            if (TextUtils.isEmpty(serviceComponent)) {
                Log.e(TAG, ""no selected voice recognition service"");
                mListener.onError(ERROR_CLIENT);
                return;
            }
            serviceIntent.setComponent(ComponentName.unflattenFromString(serviceComponent));
        } else {
            serviceIntent.setComponent(mServiceComponent);
        }
        if (!mContext.bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_INCLUDE_CAPABILITIES)) {
            Log.e(TAG, ""bind to recognition service failed"");
            mConnection = null;
            mService = null;
            mListener.onError(ERROR_CLIENT);
            return;
        }
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}","{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException(""intent must not be null"");
    }
    checkIsCalledFromMainThread();
    if (DBG) {
        Slog.i(TAG, ""#startListening called"");
        if (mService == null) {
            Slog.i(TAG, ""Connection is not established yet"");
        }
    }
    if (mService == null) {
        // First time connection: first establish a connection, then dispatch #startListening.
        connectToSystemService();
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}",1,"/**
 * Starts listening for speech. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called beforehand, otherwise
 * no notifications will be received.
 *
 * @param recognizerIntent contains parameters for the recognition to be performed. The intent
 * may also contain optional extras, see {@link RecognizerIntent}. If these values are
 * not set explicitly, default values will be used by the recognizer.
 */
","/**
 * Starts listening for speech. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called beforehand, otherwise
 * no notifications will be received.
 *
 * @param recognizerIntent contains parameters for the recognition to be performed. The intent
 * may also contain optional extras, see {@link RecognizerIntent}. If these values are
 * not set explicitly, default values will be used by the recognizer.
 */
",-1,,[@MainThread],-1,-1,-1,-1,-1,-1,"3,4",0,"There are multiple changes in the late implementation that including the logging mechanism and connection setup logic. The addition of a conditional debug logging statement with `if (DBG)` represents a change in the other statement (4), and replacing the direct connection setup code with a call to `connectToSystemService()` method represents a control dependency change (3) as well as it could also be categorized as a dependent API changed if `connectToSystemService()` is considered a different API.","There appears to be no Compatibility Issue because from the perspective of the API user, these internal changes do not affect the observable behavior. The method `startListening(Intent)` still throws the same `IllegalArgumentException` if the intent is `null`. The other changes are related to the connection process which is an internal implementation detail and does not directly impact what the method returns or the exceptions it throws, assuming `connectToSystemService()` has the same effect as the original code. The debug logging also does not impact external behavior."
116,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdListNoLazy()>,30,31,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdListNoLazy()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: String[] getCameraIdListNoLazy()>,0,"{
    if (sCameraServiceDisabled) {
        return new String[] {};
    }
    CameraStatus[] cameraStatuses;
    ICameraServiceListener.Stub testListener = new ICameraServiceListener.Stub() {

        @Override
        public void onStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onPhysicalCameraStatusChanged(int status, String id, String physicalId) throws RemoteException {
        }

        @Override
        public void onTorchStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onCameraAccessPrioritiesChanged() {
        }

        @Override
        public void onCameraOpened(String id, String clientPackageId) {
        }

        @Override
        public void onCameraClosed(String id) {
        }
    };
    String[] cameraIds = null;
    synchronized (mLock) {
        connectCameraServiceLocked();
        try {
            // The purpose of the addListener, removeListener pair here is to get a fresh
            // list of camera ids from cameraserver. We do this since for in test processes,
            // changes can happen w.r.t non-changeable permissions (eg: SYSTEM_CAMERA
            // permissions can be effectively changed by calling
            // adopt(drop)ShellPermissionIdentity()).
            // Camera devices, which have their discovery affected by these permission
            // changes, will not have clients get callbacks informing them about these
            // devices going offline (in real world scenarios, these permissions aren't
            // changeable). Future calls to getCameraIdList() will reflect the changes in
            // the camera id list after getCameraIdListNoLazy() is called.
            cameraStatuses = mCameraService.addListener(testListener);
            mCameraService.removeListener(testListener);
            for (CameraStatus c : cameraStatuses) {
                onStatusChangedLocked(c.status, c.cameraId);
            }
            Set<String> deviceCameraIds = mDeviceStatus.keySet();
            ArrayList<String> deviceIdsToRemove = new ArrayList<String>();
            for (String deviceCameraId : deviceCameraIds) {
                // adoptShellPermissionIdentity() and then dropShellPermissionIdentity().
                if (!cameraStatusesContains(cameraStatuses, deviceCameraId)) {
                    deviceIdsToRemove.add(deviceCameraId);
                }
            }
            for (String id : deviceIdsToRemove) {
                onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, id);
            }
        } catch (ServiceSpecificException e) {
            // Unexpected failure
            throw new IllegalStateException(""Failed to register a camera service listener"", e);
        } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        }
        cameraIds = extractCameraIdListLocked();
    }
    sortCameraIds(cameraIds);
    return cameraIds;
}","{
    if (sCameraServiceDisabled) {
        return new String[] {};
    }
    CameraStatus[] cameraStatuses;
    ICameraServiceListener.Stub testListener = new ICameraServiceListener.Stub() {

        @Override
        public void onStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onPhysicalCameraStatusChanged(int status, String id, String physicalId) throws RemoteException {
        }

        @Override
        public void onTorchStatusChanged(int status, String id) throws RemoteException {
        }

        @Override
        public void onCameraAccessPrioritiesChanged() {
        }

        @Override
        public void onCameraOpened(String id, String clientPackageId) {
        }

        @Override
        public void onCameraClosed(String id) {
        }
    };
    String[] cameraIds = null;
    synchronized (mLock) {
        connectCameraServiceLocked();
        try {
            // The purpose of the addListener, removeListener pair here is to get a fresh
            // list of camera ids from cameraserver. We do this since for in test processes,
            // changes can happen w.r.t non-changeable permissions (eg: SYSTEM_CAMERA
            // permissions can be effectively changed by calling
            // adopt(drop)ShellPermissionIdentity()).
            // Camera devices, which have their discovery affected by these permission
            // changes, will not have clients get callbacks informing them about these
            // devices going offline (in real world scenarios, these permissions aren't
            // changeable). Future calls to getCameraIdList() will reflect the changes in
            // the camera id list after getCameraIdListNoLazy() is called.
            // We need to remove the torch ids which may have been associated with the
            // devices removed as well. This is the same situation.
            cameraStatuses = mCameraService.addListener(testListener);
            mCameraService.removeListener(testListener);
            for (CameraStatus c : cameraStatuses) {
                onStatusChangedLocked(c.status, c.cameraId);
            }
            Set<String> deviceCameraIds = mDeviceStatus.keySet();
            ArrayList<String> deviceIdsToRemove = new ArrayList<String>();
            for (String deviceCameraId : deviceCameraIds) {
                // adoptShellPermissionIdentity() and then dropShellPermissionIdentity().
                if (!cameraStatusesContains(cameraStatuses, deviceCameraId)) {
                    deviceIdsToRemove.add(deviceCameraId);
                }
            }
            for (String id : deviceIdsToRemove) {
                onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, id);
                mTorchStatus.remove(id);
            }
        } catch (ServiceSpecificException e) {
            // Unexpected failure
            throw new IllegalStateException(""Failed to register a camera service listener"", e);
        } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        }
        cameraIds = extractCameraIdListLocked();
    }
    sortCameraIds(cameraIds);
    return cameraIds;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
121,"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",30,31,"<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ApplicationInfo: void writeToParcel(Parcel,int)>",0,"{
    if (dest.maybeWriteSquashed(this)) {
        return;
    }
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString8(taskAffinity);
    dest.writeString8(permission);
    dest.writeString8(processName);
    dest.writeString8(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString8(scanSourceDir);
    dest.writeString8(scanPublicSourceDir);
    dest.writeString8(sourceDir);
    dest.writeString8(publicSourceDir);
    dest.writeString8Array(splitNames);
    dest.writeString8Array(splitSourceDirs);
    dest.writeString8Array(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString8(nativeLibraryDir);
    dest.writeString8(secondaryNativeLibraryDir);
    dest.writeString8(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString8(primaryCpuAbi);
    dest.writeString8(secondaryCpuAbi);
    dest.writeString8Array(resourceDirs);
    dest.writeString8(seInfo);
    dest.writeString8(seInfoUser);
    dest.writeString8Array(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString8(dataDir);
    dest.writeString8(deviceProtectedDataDir);
    dest.writeString8(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString8(manageSpaceActivityName);
    dest.writeString8(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeBoolean(crossProfile);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString8(classLoaderName);
    dest.writeString8Array(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString8(compileSdkVersionCodename);
    dest.writeString8(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString8(zygotePreloadName);
    dest.writeInt(gwpAsanMode);
}","{
    if (dest.maybeWriteSquashed(this)) {
        return;
    }
    super.writeToParcel(dest, parcelableFlags);
    dest.writeString8(taskAffinity);
    dest.writeString8(permission);
    dest.writeString8(processName);
    dest.writeString8(className);
    dest.writeInt(theme);
    dest.writeInt(flags);
    dest.writeInt(privateFlags);
    dest.writeInt(privateFlagsExt);
    dest.writeInt(requiresSmallestWidthDp);
    dest.writeInt(compatibleWidthLimitDp);
    dest.writeInt(largestWidthLimitDp);
    if (storageUuid != null) {
        dest.writeInt(1);
        dest.writeLong(storageUuid.getMostSignificantBits());
        dest.writeLong(storageUuid.getLeastSignificantBits());
    } else {
        dest.writeInt(0);
    }
    dest.writeString8(scanSourceDir);
    dest.writeString8(scanPublicSourceDir);
    dest.writeString8(sourceDir);
    dest.writeString8(publicSourceDir);
    dest.writeString8Array(splitNames);
    dest.writeString8Array(splitSourceDirs);
    dest.writeString8Array(splitPublicSourceDirs);
    dest.writeSparseArray((SparseArray) splitDependencies);
    dest.writeString8(nativeLibraryDir);
    dest.writeString8(secondaryNativeLibraryDir);
    dest.writeString8(nativeLibraryRootDir);
    dest.writeInt(nativeLibraryRootRequiresIsa ? 1 : 0);
    dest.writeString8(primaryCpuAbi);
    dest.writeString8(secondaryCpuAbi);
    dest.writeString8Array(resourceDirs);
    dest.writeString8Array(overlayPaths);
    dest.writeString8(seInfo);
    dest.writeString8(seInfoUser);
    dest.writeString8Array(sharedLibraryFiles);
    dest.writeTypedList(sharedLibraryInfos);
    dest.writeString8(dataDir);
    dest.writeString8(deviceProtectedDataDir);
    dest.writeString8(credentialProtectedDataDir);
    dest.writeInt(uid);
    dest.writeInt(minSdkVersion);
    dest.writeInt(targetSdkVersion);
    dest.writeLong(longVersionCode);
    dest.writeInt(enabled ? 1 : 0);
    dest.writeInt(enabledSetting);
    dest.writeInt(installLocation);
    dest.writeString8(manageSpaceActivityName);
    dest.writeString8(backupAgentName);
    dest.writeInt(descriptionRes);
    dest.writeInt(uiOptions);
    dest.writeInt(fullBackupContent);
    dest.writeInt(dataExtractionRulesRes);
    dest.writeBoolean(crossProfile);
    dest.writeInt(networkSecurityConfigRes);
    dest.writeInt(category);
    dest.writeInt(targetSandboxVersion);
    dest.writeString8(classLoaderName);
    dest.writeString8Array(splitClassLoaderNames);
    dest.writeInt(compileSdkVersion);
    dest.writeString8(compileSdkVersionCodename);
    dest.writeString8(appComponentFactory);
    dest.writeInt(iconRes);
    dest.writeInt(roundIconRes);
    dest.writeInt(mHiddenApiPolicy);
    dest.writeInt(hiddenUntilInstalled ? 1 : 0);
    dest.writeString8(zygotePreloadName);
    dest.writeInt(gwpAsanMode);
    dest.writeInt(memtagMode);
    dest.writeInt(nativeHeapZeroInitialized);
    sForBoolean.parcel(requestRawExternalStorageAccess, dest, parcelableFlags);
}",1,,,-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
122,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,30,31,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,<android.content.pm.LauncherApps.CallbackMessageHandler: void handleMessage(Message)>,0,"{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_SUSPENDED:
            mCallback.onPackagesSuspended(info.packageNames, info.user, info.launcherExtras);
            break;
        case MSG_UNSUSPENDED:
            mCallback.onPackagesUnsuspended(info.packageNames, info.user);
            break;
        case MSG_SHORTCUT_CHANGED:
            mCallback.onShortcutsChanged(info.packageName, info.shortcuts, info.user);
            break;
    }
}","{
    if (mCallback == null || !(msg.obj instanceof CallbackInfo)) {
        return;
    }
    CallbackInfo info = (CallbackInfo) msg.obj;
    switch(msg.what) {
        case MSG_ADDED:
            mCallback.onPackageAdded(info.packageName, info.user);
            break;
        case MSG_REMOVED:
            mCallback.onPackageRemoved(info.packageName, info.user);
            break;
        case MSG_CHANGED:
            mCallback.onPackageChanged(info.packageName, info.user);
            break;
        case MSG_AVAILABLE:
            mCallback.onPackagesAvailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_UNAVAILABLE:
            mCallback.onPackagesUnavailable(info.packageNames, info.user, info.replacing);
            break;
        case MSG_SUSPENDED:
            mCallback.onPackagesSuspended(info.packageNames, info.user, info.launcherExtras);
            break;
        case MSG_UNSUSPENDED:
            mCallback.onPackagesUnsuspended(info.packageNames, info.user);
            break;
        case MSG_SHORTCUT_CHANGED:
            mCallback.onShortcutsChanged(info.packageName, info.shortcuts, info.user);
            break;
        case MSG_LOADING_PROGRESS_CHANGED:
            mCallback.onPackageLoadingProgressChanged(info.packageName, info.user, info.mLoadingProgress);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new 'case' statement has been added in the switch block (MSG_LOADING_PROGRESS_CHANGED), which is neither a return statement nor an exception handling statement, hence the change type is 3,4.",There is no CI as the additional case does not lead to a change in return value or introduce a new exception handling which would affect existing behavior. The new case only extends functionality and will handle new messages that were not previously handled. Existing messages and their handling remain unchanged.
123,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,30,31,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,<android.content.res.Resources.Theme: int getAppliedStyleResId()>,0,"{
    return mThemeImpl.getAppliedStyleResId();
}","{
    synchronized (mLock) {
        return mThemeImpl.getAppliedStyleResId();
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation now wraps the return statement with a synchronized block, which is a synchronization change, so the code change type is 4.","The addition of a synchronized block does not change the behavior of the method regarding the value it returns or the exceptions it may throw, thus there is no Compatibility Issue, and the CI type is 0."
124,<android.view.textclassifier.TextClassificationSession: void onTextClassifierEvent(TextClassifierEvent)>,30,31,<android.view.textclassifier.TextClassificationSession: void onTextClassifierEvent(TextClassifierEvent)>,<android.view.textclassifier.TextClassificationSession: void onTextClassifierEvent(TextClassifierEvent)>,0,"{
    try {
        event.mHiddenTempSessionId = mSessionId;
        mDelegate.onTextClassifierEvent(event);
    } catch (Exception e) {
        // Avoid crashing for event reporting.
        Log.e(LOG_TAG, ""Error reporting text classifier event"", e);
    }
}","{
    checkDestroyedAndRun(() -> {
        try {
            event.mHiddenTempSessionId = mSessionId;
            mDelegate.onTextClassifierEvent(event);
        } catch (Exception e) {
            // Avoid crashing for event reporting.
            Log.e(LOG_TAG, ""Error reporting text classifier event"", e);
        }
        return null;
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has introduced a new method checkDestroyedAndRun() that wraps the existing try-catch block, which qualifies as 'Other statement changed', so the code change type is 4.","There is no change to control flow or the way exceptions are handled within the method's logic. The added method checkDestroyedAndRun() is a wrapper and should not affect the outcome of the called method. Therefore, there is no Compatibility Issue; hence the CI type is 0."
125,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>",30,31,"<android.os.DropBoxManager: Entry getNextEntry(String,long)>","<android.os.DropBoxManager: Entry getNextEntry(String,long)>",0,"{
    try {
        return mService.getNextEntry(tag, msec, mContext.getOpPackageName());
    } catch (SecurityException e) {
        if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
            throw e;
        } else {
            Log.w(TAG, e.getMessage());
            return null;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mService.getNextEntryWithAttribution(tag, msec, mContext.getOpPackageName(), mContext.getAttributionTag());
    } catch (SecurityException e) {
        if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
            throw e;
        } else {
            Log.w(TAG, e.getMessage());
            return null;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * You must always call {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
","/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * You must always call {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */
",-1,"[@RequiresPermission(allOf = { READ_LOGS, PACKAGE_USAGE_STATS }), @Nullable]","[@RequiresPermission(allOf = { READ_LOGS, PACKAGE_USAGE_STATS }), @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method being called inside the try block has changed from mService.getNextEntry(tag, msec, mContext.getOpPackageName()) to mService.getNextEntryWithAttribution(tag, msec, mContext.getOpPackageName(), mContext.getAttributionTag()), which is a modification in the dependent API, so the change type is 1,5.","The dependent API has been changed to include an additional parameter mContext.getAttributionTag(), potentially affecting the return value of the getNextEntry method. Therefore, this could lead to a different behavior because the method signature has changed, which means there might be a Compatibility Issue with type 1."
126,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,30,31,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int[])>,0,"{
    return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, 0);
}","{
    synchronized (mLock) {
        return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, 0);
    }
}",1,"/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes. These attribute IDs must be sorted in ascending
 * order.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by
 * <var>Theme</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param attrs The desired attributes. These attribute IDs must be sorted in ascending
 * order.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int, int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"A synchronization block (`synchronized (mLock) { ... }`) has been introduced in the late version which contributes to a control dependency change, and also a new kind of statement (synchronization block) which is related to the thread safety of the method but does not influence the output or the exceptions thrown directly. Thus, the change type is 3,4.","The addition of synchronized block does not affect the return value or type and it does not change the exception handling, so it will not cause a Compatibility Issue. Therefore, the type is 0."
127,<android.view.InsetsController.InternalAnimationControlListener: Interpolator getAlphaInterpolator()>,30,31,<android.view.InsetsController.InternalAnimationControlListener: Interpolator getAlphaInterpolator()>,<android.view.InsetsController.InternalAnimationControlListener: Interpolator getAlphaInterpolator()>,0,"{
    if ((mRequestedTypes & ime()) != 0) {
        if (mHasAnimationCallbacks) {
            return input -> 1f;
        } else if (mShow) {
            // Alpha animation takes half the time with linear interpolation;
            return input -> Math.min(1f, 2 * input);
        } else {
            return FAST_OUT_LINEAR_IN_INTERPOLATOR;
        }
    } else {
        return input -> 1f;
    }
}","{
    if ((mRequestedTypes & ime()) != 0) {
        if (mHasAnimationCallbacks) {
            return input -> 1f;
        } else if (mShow) {
            // Alpha animation takes half the time with linear interpolation;
            return input -> Math.min(1f, 2 * input);
        } else {
            return FAST_OUT_LINEAR_IN_INTERPOLATOR;
        }
    } else {
        if (mBehavior == BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE) {
            return input -> 1f;
        } else {
            if (mShow) {
                return SYSTEM_BARS_ALPHA_INTERPOLATOR;
            } else {
                return SYSTEM_BARS_DIM_INTERPOLATOR;
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,There is an addition of an `if` control statement that looks at `mBehavior` and two new return statements that return different interpolators based on the condition. This is a change in the control dependency.,"There is no Compatibility Issue here because the behavior for the conditions that existed in the early version remains the same in the late version. The new conditions only apply to new cases and do not alter the behavior of the pre-existing conditions, so existing users of the API should not experience any difference in behavior."
128,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(String)>,30,31,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(String)>,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(String)>,0,"{
    return new BluetoothDevice(address);
}","{
    final BluetoothDevice res = new BluetoothDevice(address);
    res.setAttributionSource(mAttributionSource);
    return res;
}",1,"/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be upper case, in a format
 * such as ""00:11:22:33:AA:BB"". The helper {@link #checkBluetoothAddress} is
 * available to validate a Bluetooth address.
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address valid Bluetooth MAC address
 * @throws IllegalArgumentException if address is invalid
 */
","/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be upper case, in a format
 * such as ""00:11:22:33:AA:BB"". The helper {@link #checkBluetoothAddress} is
 * available to validate a Bluetooth address.
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address valid Bluetooth MAC address
 * @throws IllegalArgumentException if address is invalid
 */
",-1,,[@RequiresNoPermission],-1,-1,-1,-1,-1,-1,4,0,"The change from a direct return of 'new BluetoothDevice(address)' to creating a new BluetoothDevice instance, setting an attribution source, and then returning it is not a control dependency or a return type/value change. Hence, the change is an addition of other statements, which reflects an internal object state change before returning. The change type is 4.","The changes made set an attribution source on the BluetoothDevice object, but this does not affect the object's type or the fact that an instance of BluetoothDevice is returned. It also does not affect how exceptions are handled. As such, there is no compatibility issue concerning the return value/type or exception throwing. The CI type is 0."
129,<android.app.Activity: void setShowWhenLocked(boolean)>,30,31,<android.app.Activity: void setShowWhenLocked(boolean)>,<android.app.Activity: void setShowWhenLocked(boolean)>,0,"{
    try {
        ActivityTaskManager.getService().setShowWhenLocked(mToken, showWhenLocked);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    ActivityClient.getInstance().setShowWhenLocked(mToken, showWhenLocked);
}",1,"/**
 * Specifies whether an {@link Activity} should be shown on top of the lock screen whenever
 * the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
 * to the stopped state if it is started while the lockscreen is up, but with this flag set the
 * activity will remain in the resumed state visible on-top of the lock screen. This value can
 * be set as a manifest attribute using {@link android.R.attr#showWhenLocked}.
 *
 * @param showWhenLocked {@code true} to show the {@link Activity} on top of the lock screen;
 * {@code false} otherwise.
 * @see #setTurnScreenOn(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
","/**
 * Specifies whether an {@link Activity} should be shown on top of the lock screen whenever
 * the lockscreen is up and the activity is resumed. Normally an activity will be transitioned
 * to the stopped state if it is started while the lockscreen is up, but with this flag set the
 * activity will remain in the resumed state visible on-top of the lock screen. This value can
 * be set as a manifest attribute using {@link android.R.attr#showWhenLocked}.
 *
 * @param showWhenLocked {@code true} to show the {@link Activity} on top of the lock screen;
 * {@code false} otherwise.
 * @see #setTurnScreenOn(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to set the ""show when locked"" functionality has changed from ActivityTaskManager.getService().setShowWhenLocked() to ActivityClient.getInstance().setShowWhenLocked(), so the code change type is 5 (Dependent API changed).","There are no Compatibility Issues because there is no indication that the new implementation behaves differently in terms of output or exception handling from the perspective of the public API. The implementation detail has changed, but as long as ActivityClient.getInstance().setShowWhenLocked() is supposed to behave the same as the old method, the change is internal and should not affect the developers using this API."
130,<android.view.Display: Mode[] getSupportedModes()>,30,31,<android.view.Display: Mode[] getSupportedModes()>,<android.view.Display: Mode[] getSupportedModes()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        final Display.Mode[] modes = mDisplayInfo.supportedModes;
        return Arrays.copyOf(modes, modes.length);
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        final Display.Mode[] modes = mDisplayInfo.supportedModes;
        return Arrays.copyOf(modes, modes.length);
    }
}",1,"/**
 * Gets the supported modes of this display.
 */
","/**
 * Gets the supported modes of this display.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the object used for synchronization, from 'this' to 'mLock'. This is categorized as an Other statement change.","Changes in the synchronization object do not affect the external behavior of the method with regard to the return values or exceptions thrown, so there is no compatibility issue."
131,"<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>",30,31,"<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>","<android.os.FileObserver.ObserverThread: void onEvent(int,int,String)>",0,"{
    // look up our observer, fixing up the map if necessary...
    FileObserver observer = null;
    synchronized (m_observers) {
        WeakReference weak = m_observers.get(wfd);
        if (weak != null) {
            // can happen with lots of events from a dead wfd
            observer = (FileObserver) weak.get();
            if (observer == null) {
                m_observers.remove(wfd);
            }
        }
    }
    // ...then call out to the observer without the sync lock held
    if (observer != null) {
        try {
            observer.onEvent(mask, path);
        } catch (Throwable throwable) {
            Log.wtf(LOG_TAG, ""Unhandled exception in FileObserver "" + observer, throwable);
        }
    }
}","{
    // look up our observer, fixing up the map if necessary...
    FileObserver observer = null;
    synchronized (mRealObservers) {
        WeakReference weak = mRealObservers.get(wfd);
        if (weak != null) {
            // can happen with lots of events from a dead wfd
            observer = (FileObserver) weak.get();
            if (observer == null) {
                mRealObservers.remove(wfd);
            }
        }
    }
    // ...then call out to the observer without the sync lock held
    if (observer != null) {
        try {
            observer.onEvent(mask, path);
        } catch (Throwable throwable) {
            Log.wtf(LOG_TAG, ""Unhandled exception in FileObserver "" + observer, throwable);
        }
    }
}",1,,,-1,[@UnsupportedAppUsage],"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change from ""m_observers"" to ""mRealObservers"" is an internal variable change, and since the logic remains the same, it is considered as ""Other statement changed"" (4). Additionally, due to the change in the annotations with maxTargetSdk addition in the late version, it is also a ""Dependent API changed"" (5).","Based on the code provided and the change that occurred, there is no apparent change in the behavior of this method that would affect its outward functionality. The internal variable name change is not visible to clients of the API, and the method signature as well as its behavior remains consistent between versions. Thus, no Compatibility Issue arises from these changes (0)."
132,"<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>",30,31,"<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>","<android.app.NotificationManager: Map<String, AutomaticZenRule> getAutomaticZenRules()>",0,"{
    INotificationManager service = getService();
    try {
        List<ZenModeConfig.ZenRule> rules = service.getZenRules();
        Map<String, AutomaticZenRule> ruleMap = new HashMap<>();
        for (ZenModeConfig.ZenRule rule : rules) {
            ruleMap.put(rule.id, new AutomaticZenRule(rule.name, rule.component, rule.configurationActivity, rule.conditionId, rule.zenPolicy, zenModeToInterruptionFilter(rule.zenMode), rule.enabled, rule.creationTime));
        }
        return ruleMap;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        List<ZenModeConfig.ZenRule> rules = service.getZenRules();
        Map<String, AutomaticZenRule> ruleMap = new HashMap<>();
        for (ZenModeConfig.ZenRule rule : rules) {
            AutomaticZenRule azr = new AutomaticZenRule(rule.name, rule.component, rule.configurationActivity, rule.conditionId, rule.zenPolicy, zenModeToInterruptionFilter(rule.zenMode), rule.enabled, rule.creationTime);
            azr.setPackageName(rule.pkg);
            ruleMap.put(rule.id, azr);
        }
        return ruleMap;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns AutomaticZenRules owned by the caller.
 *
 * <p>
 * Throws a SecurityException if policy access is not granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
","/**
 * Returns AutomaticZenRules owned by the caller.
 *
 * <p>
 * Throws a SecurityException if policy access is not granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code inside the loop adds a method call to setPackageName on the 'AutomaticZenRule' object before putting it into 'ruleMap'. This represents a change of other statements, hence the code change type is 4.","The addition of setPackageName does not directly lead to a different return value of the Map itself, since it's modifying the content of the 'AutomaticZenRule' objects being put into the map. There is no indication that the behavior of the 'return ruleMap' statement could result in a different return value for the method due to this change; therefore, this change doesn't lead to a compatibility issue as per the given definitions. So, the CI type is 0."
134,<android.app.SyncNotedAppOp: boolean equals(Object)>,30,31,<android.app.SyncNotedAppOp: boolean equals(Object)>,<android.app.SyncNotedAppOp: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") SyncNotedAppOp that = (SyncNotedAppOp) o;
    // noinspection PointlessBooleanExpression
    return true && mOpCode == that.mOpCode && java.util.Objects.equals(mAttributionTag, that.mAttributionTag);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") SyncNotedAppOp that = (SyncNotedAppOp) o;
    // noinspection PointlessBooleanExpression
    return true && mOpMode == that.mOpMode && mOpCode == that.mOpCode && java.util.Objects.equals(mAttributionTag, that.mAttributionTag) && java.util.Objects.equals(mPackageName, that.mPackageName);
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"A comparison ""mOpMode == that.mOpMode"" was added to the return expression along with the comparison ""java.util.Objects.equals(mPackageName, that.mPackageName)"". This means there's an additional field involved in determining equality, so the code change type is 1 for added comparison and also 4 for other statement changed due to the addition of these new conditions.","The changes to the return statement mean that the method can return different values based on the new conditions added. As the conditions involving ""mOpMode"" and ""mPackageName"" are new, objects that were previously considered equal may not be considered equal in the new version if they differ in the new fields. Thus, the CI type is 1."
135,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean switchToInputMethod(String)>,30,31,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean switchToInputMethod(String)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean switchToInputMethod(String)>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.switchToInputMethod(imeId);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.switchToInputMethod(imeId);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
    return false;
}",1,"/**
 * Switches the current IME for the user for whom the service is enabled. The change will
 * persist until the current IME is explicitly changed again, and may persist beyond the
 * life cycle of the requesting service.
 *
 * @param imeId The ID of the input method to make current. This IME must be installed and
 * enabled.
 * @return {@code true} if the current input method was successfully switched to the input
 * method by {@code imeId},
 * {@code false} if the input method specified is not installed, not enabled, or
 * otherwise not available to become the current IME
 *
 * @see android.view.inputmethod.InputMethodInfo#getId()
 */
","/**
 * Switches the current IME for the user for whom the service is enabled. The change will
 * persist until the current IME is explicitly changed again, and may persist beyond the
 * life cycle of the requesting service.
 *
 * @param imeId The ID of the input method to make current. This IME must be installed and
 * enabled.
 * @return {@code true} if the current input method was successfully switched to the input
 * method by {@code imeId},
 * {@code false} if the input method specified is not installed, not enabled, or
 * otherwise not available to become the current IME
 *
 * @see android.view.inputmethod.InputMethodInfo#getId()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The call to `AccessibilityInteractionClient.getInstance()` has changed its parameter from `mService.mConnectionId` to `mService`. This indicates that the getInstance() method's signature or expected parameters may have changed, which is a dependent API change; hence the code change type is 5.","There is no change in the behavior of the method since the method still performs the same actions with the same control flow. It connects to the service, checks the connection, makes the call, and handles the exception in the same way if an exception is thrown. The return types and exceptions thrown remain consistent with the earlier version. Thus, there is no compatibility issue."
136,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,30,31,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            // exception in case cameraId is a hidden physical camera.
            if (!isHiddenPhysicalCamera(cameraId) && !supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info, id, displaySize);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                try {
                    info.setCameraId(Integer.parseInt(cameraId));
                } catch (NumberFormatException e) {
                    // For external camera, reaching here is expected.
                    Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
                }
                boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
                info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
                info.setDisplaySize(displaySize);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId, mContext.getApplicationInfo().targetSdkVersion);
            try {
                info.setCameraId(Integer.parseInt(cameraId));
            } catch (NumberFormatException e) {
                Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
            }
            boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
            info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
            info.setDisplaySize(displaySize);
            Map<String, StreamConfiguration[]> multiResolutionSizeMap = getPhysicalCameraMultiResolutionConfigs(cameraId, info, cameraService);
            if (multiResolutionSizeMap.size() > 0) {
                info.setMultiResolutionStreamConfigurationMap(multiResolutionSizeMap);
            }
            characteristics = new CameraCharacteristics(info);
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The early implementation has code paths to handle legacy camera characteristics, which include making calls to `getLegacyParameters` and `LegacyMetadataMapper.createCharacteristics`. The late implementation has removed this legacy support code, as well as changed the method signature for `getCameraCharacteristics` to include an additional parameter (the target SDK version). The `multiResolutionSizeMap` handling is also new to the late version. Code related to managing multi-resolution stream configuration maps has been introduced. These combined structural changes are classified as Other statement changed (4), Return statement changed (1), and Dependent API changed (5).","The removal of the legacy support code could result in different behavior if an older camera ID is passed, which previously would have been processed by the legacy code path but now might lead to exceptions or different return values since this code path was removed. This is a potential Compatibility Issue of returning a different value (1). The change in exception throwing behavior, now with additional context regarding different SDK versions and multi-resolution configurations, impacts the cases when a `CameraAccessException` or other exceptions might be thrown. This is a potential Compatibility Issue regarding exception handling (2)."
137,<android.content.pm.ShortcutManager: boolean updateShortcuts(List<ShortcutInfo>)>,30,31,<android.content.pm.ShortcutManager: boolean updateShortcuts(List<ShortcutInfo>)>,<android.content.pm.ShortcutManager: boolean updateShortcuts(List<ShortcutInfo>)>,0,"{
    try {
        return mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return (boolean) getFutureOrThrow(mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
 * dynamic, but they must not be immutable.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException If trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
 * dynamic, but they must not be immutable.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException If trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been changed from directly returning the result of mService.updateShortcuts() to returning the result cast to boolean after calling getFutureOrThrow(). This change indicates a potential alteration in the handling of the return value, hence falling into change types 1 and 4.","The change in how the return value of mService.updateShortcuts() is handledâ€”a new method getFutureOrThrow() is introduced which could potentially have a different behavior (e.g., may process exceptions differently, may handle the result differently, etc.), hence the API could potentially return a different value. Therefore, there is a potential for a Compatibility Issue of type 1."
138,"<android.appwidget.AppWidgetHostView: void onLayout(boolean,int,int,int,int)>",30,31,"<android.appwidget.AppWidgetHostView: void onLayout(boolean,int,int,int,int)>","<android.appwidget.AppWidgetHostView: void onLayout(boolean,int,int,int,int)>",0,"{
    try {
        super.onLayout(changed, left, top, right, bottom);
    } catch (final RuntimeException e) {
        Log.e(TAG, ""Remote provider threw runtime exception, using error view instead."", e);
        removeViewInLayout(mView);
        View child = getErrorView();
        prepareView(child);
        addViewInLayout(child, 0, child.getLayoutParams());
        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight, child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);
        mView = child;
        mViewMode = VIEW_MODE_ERROR;
    }
}","{
    try {
        SizeF oldSize = mCurrentSize;
        SizeF newSize = computeSizeFromLayout(left, top, right, bottom);
        mCurrentSize = newSize;
        if (mLastInflatedRemoteViews != null) {
            RemoteViews toApply = mLastInflatedRemoteViews.getRemoteViewsToApplyIfDifferent(oldSize, newSize);
            if (toApply != null) {
                applyRemoteViews(toApply, false);
                measureChildWithMargins(mView, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), 0, /* widthUsed */
                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY), 0);
            }
        }
        super.onLayout(changed, left, top, right, bottom);
    } catch (final RuntimeException e) {
        Log.e(TAG, ""Remote provider threw runtime exception, using error view instead."", e);
        removeViewInLayout(mView);
        View child = getErrorView();
        prepareView(child);
        addViewInLayout(child, 0, child.getLayoutParams());
        measureChild(child, MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
        child.layout(0, 0, child.getMeasuredWidth() + mPaddingLeft + mPaddingRight, child.getMeasuredHeight() + mPaddingTop + mPaddingBottom);
        mView = child;
        mViewMode = VIEW_MODE_ERROR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The new code assigns values to `oldSize` and `newSize`, computes the size, checks the last inflated RemoteViews and applies them if necessary, before calling `super.onLayout()`. There's also additional calls to `measureChildWithMargins()` and `applyRemoteViews()`. This change affects the control flow and other statements, so the code change type is 3,4.","There is no Compatibility Issue because the changes are related to additional layout calculations and applying remote views before the actual `onLayout()` code from the parent class is executed. The catch block for handling the RuntimeException is unchanged, and the essential `onLayout` contract is maintained without changing the exceptions thrown or any return values, as the method return type is `void`. Therefore, the method behavior from an API consumer's perspective remains the same in the context of how it's used."
139,<android.view.inputmethod.InlineSuggestion: String toString()>,30,31,<android.view.inputmethod.InlineSuggestion: String toString()>,<android.view.inputmethod.InlineSuggestion: String toString()>,0,"{
    return ""InlineSuggestion { "" + ""info = "" + mInfo + "", "" + ""contentProvider = "" + mContentProvider + "", "" + ""inlineContentCallback = "" + mInlineContentCallback + "" }"";
}","{
    return ""InlineSuggestion { "" + ""info = "" + mInfo + "", "" + ""contentProvider = "" + mContentProvider + "", "" + ""inlineContentCallback = "" + mInlineContentCallback + "", "" + ""inlineTooltipUi = "" + mInlineTooltipUi + "" }"";
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified to include an additional field (+ ""inlineTooltipUi = "" + mInlineTooltipUi) in the returned string, making this a Return statement changed (1).","As the returned string now includes additional data (""inlineTooltipUi = "" + mInlineTooltipUi), the API will return a different value, which means that a Compatibility Issue due to potentially different return values has been introduced (1)."
140,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,30,31,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,<android.app.backup.BackupAgent: void onFullBackup(FullBackupDataOutput)>,0,"{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this);
    if (!backupScheme.isFullBackupContentEnabled()) {
        return;
    }
    Map<String, Set<PathWithRequiredFlags>> manifestIncludeMap;
    ArraySet<PathWithRequiredFlags> manifestExcludeSet;
    try {
        manifestIncludeMap = backupScheme.maybeParseAndGetCanonicalIncludePaths();
        manifestExcludeSet = backupScheme.maybeParseAndGetCanonicalExcludePaths();
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    // System apps have control over where their default storage context
    // is pointed, so we're always explicit when building paths.
    final Context ceContext = createCredentialProtectedStorageContext();
    final String rootDir = ceContext.getDataDir().getCanonicalPath();
    final String filesDir = ceContext.getFilesDir().getCanonicalPath();
    final String noBackupDir = ceContext.getNoBackupFilesDir().getCanonicalPath();
    final String databaseDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String sharedPrefsDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String cacheDir = ceContext.getCacheDir().getCanonicalPath();
    final String codeCacheDir = ceContext.getCodeCacheDir().getCanonicalPath();
    final Context deContext = createDeviceProtectedStorageContext();
    final String deviceRootDir = deContext.getDataDir().getCanonicalPath();
    final String deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
    final String deviceNoBackupDir = deContext.getNoBackupFilesDir().getCanonicalPath();
    final String deviceDatabaseDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String deviceSharedPrefsDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String deviceCacheDir = deContext.getCacheDir().getCanonicalPath();
    final String deviceCodeCacheDir = deContext.getCodeCacheDir().getCanonicalPath();
    final String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.add(noBackupDir);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(cacheDir);
    traversalExcludeSet.add(codeCacheDir);
    traversalExcludeSet.add(deviceFilesDir);
    traversalExcludeSet.add(deviceNoBackupDir);
    traversalExcludeSet.add(deviceDatabaseDir);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    traversalExcludeSet.add(deviceCacheDir);
    traversalExcludeSet.add(deviceCodeCacheDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceRootDir);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.remove(deviceFilesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceFilesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.remove(deviceDatabaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceDatabaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.remove(deviceSharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}","{
    FullBackup.BackupScheme backupScheme = FullBackup.getBackupScheme(this, mOperationType);
    if (!backupScheme.isFullBackupEnabled(data.getTransportFlags())) {
        return;
    }
    IncludeExcludeRules includeExcludeRules;
    try {
        includeExcludeRules = getIncludeExcludeRules(backupScheme);
    } catch (IOException | XmlPullParserException e) {
        if (Log.isLoggable(FullBackup.TAG_XML_PARSER, Log.VERBOSE)) {
            Log.v(FullBackup.TAG_XML_PARSER, ""Exception trying to parse fullBackupContent xml file!"" + "" Aborting full backup."", e);
        }
        return;
    }
    Map<String, Set<PathWithRequiredFlags>> manifestIncludeMap = includeExcludeRules.getIncludeMap();
    Set<PathWithRequiredFlags> manifestExcludeSet = includeExcludeRules.getExcludeSet();
    final String packageName = getPackageName();
    final ApplicationInfo appInfo = getApplicationInfo();
    // System apps have control over where their default storage context
    // is pointed, so we're always explicit when building paths.
    final Context ceContext = createCredentialProtectedStorageContext();
    final String rootDir = ceContext.getDataDir().getCanonicalPath();
    final String filesDir = ceContext.getFilesDir().getCanonicalPath();
    final String databaseDir = ceContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String sharedPrefsDir = ceContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final Context deContext = createDeviceProtectedStorageContext();
    final String deviceRootDir = deContext.getDataDir().getCanonicalPath();
    final String deviceFilesDir = deContext.getFilesDir().getCanonicalPath();
    final String deviceDatabaseDir = deContext.getDatabasePath(""foo"").getParentFile().getCanonicalPath();
    final String deviceSharedPrefsDir = deContext.getSharedPreferencesPath(""foo"").getParentFile().getCanonicalPath();
    final String libDir = (appInfo.nativeLibraryDir != null) ? new File(appInfo.nativeLibraryDir).getCanonicalPath() : null;
    // Maintain a set of excluded directories so that as we traverse the tree we know we're not
    // going places we don't expect, and so the manifest includes can't take precedence over
    // what the framework decides is not to be included.
    final ArraySet<String> traversalExcludeSet = new ArraySet<String>();
    // Add the directories we always exclude.
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.add(deviceFilesDir);
    traversalExcludeSet.add(deviceDatabaseDir);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    if (libDir != null) {
        traversalExcludeSet.add(libDir);
    }
    Set<String> extraExcludedDirs = getExtraExcludeDirsIfAny(ceContext);
    Set<String> extraExcludedDeviceDirs = getExtraExcludeDirsIfAny(deContext);
    traversalExcludeSet.addAll(extraExcludedDirs);
    traversalExcludeSet.addAll(extraExcludedDeviceDirs);
    // Root dir first.
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(rootDir);
    // Exclude the extra directories anyway, since we've already covered them if it was needed.
    traversalExcludeSet.addAll(extraExcludedDirs);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_ROOT_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceRootDir);
    // Exclude the extra directories anyway, since we've already covered them if it was needed.
    traversalExcludeSet.addAll(extraExcludedDeviceDirs);
    // Data dir next.
    traversalExcludeSet.remove(filesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(filesDir);
    traversalExcludeSet.remove(deviceFilesDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_FILES_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceFilesDir);
    // Database directory.
    traversalExcludeSet.remove(databaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(databaseDir);
    traversalExcludeSet.remove(deviceDatabaseDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_DATABASE_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceDatabaseDir);
    // SharedPrefs.
    traversalExcludeSet.remove(sharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(sharedPrefsDir);
    traversalExcludeSet.remove(deviceSharedPrefsDir);
    applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
    traversalExcludeSet.add(deviceSharedPrefsDir);
    // the log.
    if (Process.myUid() != Process.SYSTEM_UID) {
        File efLocation = getExternalFilesDir(null);
        if (efLocation != null) {
            applyXmlFiltersAndDoFullBackupForDomain(packageName, FullBackup.MANAGED_EXTERNAL_TREE_TOKEN, manifestIncludeMap, manifestExcludeSet, traversalExcludeSet, data);
        }
    }
}",1,"/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
","/**
 * The application is having its entire file system contents backed up.  {@code data}
 * points to the backup destination, and the app has the opportunity to choose which
 * files are to be stored.  To commit a file as part of the backup, call the
 * {@link #fullBackupFile(File, FullBackupDataOutput)} helper method.  After all file
 * data is written to the output, the agent returns from this method and the backup
 * operation concludes.
 *
 * <p>Certain parts of the app's data are never backed up even if the app explicitly
 * sends them to the output:
 *
 * <ul>
 * <li>The contents of the {@link #getCacheDir()} directory</li>
 * <li>The contents of the {@link #getCodeCacheDir()} directory</li>
 * <li>The contents of the {@link #getNoBackupFilesDir()} directory</li>
 * <li>The contents of the app's shared library directory</li>
 * </ul>
 *
 * <p>The default implementation of this method backs up the entirety of the
 * application's ""owned"" file system trees to the output other than the few exceptions
 * listed above.  Apps only need to override this method if they need to impose special
 * limitations on which files are being stored beyond the control that
 * {@link #getNoBackupFilesDir()} offers.
 * Alternatively they can provide an xml resource to specify what data to include or exclude.
 *
 * @param data A structured wrapper pointing to the backup destination.
 * @throws IOException
 *
 * @see Context#getNoBackupFilesDir()
 * @see #fullBackupFile(File, FullBackupDataOutput)
 * @see #onRestoreFile(ParcelFileDescriptor, long, File, int, long, long)
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
141,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onInterruptData(BluetoothDevice,byte,byte[])>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onInterruptData(BluetoothDevice,byte,byte[])>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onInterruptData(BluetoothDevice,byte,byte[])>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onInterruptData(device, reportId, data));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onInterruptData(device, reportId, data));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The modification introduces a new line setting the attribution source for the device, and wraps the existing execute() method call within a try-finally block to restore the calling identity. Therefore, the change types are 3 for the addition of the try-finally block, and 4 for the new method call to setAttributionSource().","There is no new return statement or exception handling statement introduced, and the existing execution flow doesn't change as a result of these modifications. Therefore, these changes do not affect the return value or the exception handling of the method, resulting in no compatibility issue (CI type 0)."
142,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,30,31,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken, moreArgs.argi2 == 1);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,,,,
143,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",30,31,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>","<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",0,"{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int count;
    LocaleData localeData = LocaleData.get(Locale.getDefault());
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        count = 1;
        int c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case 'A':
            case 'a':
                replacement = localeData.amPm[inDate.get(Calendar.AM_PM) - Calendar.AM];
                break;
            case 'd':
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case 'c':
            case 'E':
                replacement = getDayOfWeekString(localeData, inDate.get(Calendar.DAY_OF_WEEK), count, c);
                break;
            // hour in am/pm (0-11)
            case 'K':
            case // hour in am/pm (1-12)
            'h':
                {
                    int hour = inDate.get(Calendar.HOUR);
                    if (c == 'h' && hour == 0) {
                        hour = 12;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            // hour in day (0-23)
            case 'H':
            case // hour in day (1-24) [but see note below]
            'k':
                {
                    int hour = inDate.get(Calendar.HOUR_OF_DAY);
                    // times are abusing 'k'. http://b/8359981.
                    if (false && c == 'k' && hour == 0) {
                        hour = 24;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            case 'L':
            case 'M':
                replacement = getMonthString(localeData, inDate.get(Calendar.MONTH), count, c);
                break;
            case 'm':
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case 's':
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case 'y':
                replacement = getYearString(inDate.get(Calendar.YEAR), count);
                break;
            case 'z':
                replacement = getTimeZoneString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned) {
        return new SpannedString(s);
    } else {
        return s.toString();
    }
}","{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int count;
    DateFormatSymbols dfs = getIcuDateFormatSymbols(Locale.getDefault());
    String[] amPm = dfs.getAmPmStrings();
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        count = 1;
        int c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case 'A':
            case 'a':
                replacement = amPm[inDate.get(Calendar.AM_PM) - Calendar.AM];
                break;
            case 'd':
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case 'c':
            case 'E':
                replacement = getDayOfWeekString(dfs, inDate.get(Calendar.DAY_OF_WEEK), count, c);
                break;
            // hour in am/pm (0-11)
            case 'K':
            case // hour in am/pm (1-12)
            'h':
                {
                    int hour = inDate.get(Calendar.HOUR);
                    if (c == 'h' && hour == 0) {
                        hour = 12;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            // hour in day (0-23)
            case 'H':
            case // hour in day (1-24) [but see note below]
            'k':
                {
                    int hour = inDate.get(Calendar.HOUR_OF_DAY);
                    // times are abusing 'k'. http://b/8359981.
                    if (false && c == 'k' && hour == 0) {
                        hour = 24;
                    }
                    replacement = zeroPad(hour, count);
                }
                break;
            case 'L':
            case 'M':
                replacement = getMonthString(dfs, inDate.get(Calendar.MONTH), count, c);
                break;
            case 'm':
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case 's':
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case 'y':
                replacement = getYearString(inDate.get(Calendar.YEAR), count);
                break;
            case 'z':
                replacement = getTimeZoneString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned) {
        return new SpannedString(s);
    } else {
        return s.toString();
    }
}",1,"/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
","/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
144,<android.view.textclassifier.TextClassificationSession: TextSelection suggestSelection(Request)>,30,31,<android.view.textclassifier.TextClassificationSession: TextSelection suggestSelection(Request)>,<android.view.textclassifier.TextClassificationSession: TextSelection suggestSelection(Request)>,0,"{
    checkDestroyed();
    return mDelegate.suggestSelection(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.suggestSelection(request));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method now uses a lambda expression to encapsulate the call within a method `checkDestroyedAndRun()`, which represents a change in the way the method operates. However, it is not evident from the information provided that `checkDestroyedAndRun()` behaves differently from the direct `checkDestroyed()` call, apart from its encapsulation of the `mDelegate.suggestSelection(request)` call within a lambda. There is also a possible change in dependent API due to the introduction of `checkDestroyedAndRun()`.","Assuming `checkDestroyedAndRun()` internally calls `checkDestroyed()` and then runs the lambda if not destroyed, there should be no difference in behavior between the two versions of the API regarding return values, exception handling, or control flow (given the same input `request`). There is no indication that the encapsulation alone would lead to a compatibility issue. Thus, no compatibility issue is detected."
145,<android.nfc.NfcAdapter: boolean isSecureNfcSupported()>,30,31,<android.nfc.NfcAdapter: boolean isSecureNfcSupported()>,<android.nfc.NfcAdapter: boolean isSecureNfcSupported()>,0,"{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.deviceSupportsNfcSecure();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.deviceSupportsNfcSecure();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, ""Failed to recover NFC Service."");
            return false;
        }
        try {
            return sService.deviceSupportsNfcSecure();
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover NFC Service."");
        }
        return false;
    }
}",1,"/**
 * Checks if the device supports Secure NFC functionality.
 *
 * @return True if device supports Secure NFC, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
","/**
 * Checks if the device supports Secure NFC functionality.
 *
 * @return True if device supports Secure NFC, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2",The exception handling statement has changed with an additional 'try' block and another return statement has been introduced in case of recovering from a `RemoteException`. There is also a control dependency change because of an additional null check on 'sService' and another method call attempt. The code change types are 2 and 3.,"The new exception handling could lead to a different exception being logged, and the second attempt to call `sService.deviceSupportsNfcSecure()` could either return a different value or throw an unknown exception due to the state of 'sService' after recovery. Therefore, there are potential changes in both return values (type 1) and exception handlings (type 2), so the CI type is 1,2."
146,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,30,31,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,<android.inputmethodservice.InputMethodService: void showWindow(boolean)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mViewsCreated="" + mViewsCreated + "" mDecorViewVisible="" + mDecorViewVisible + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    mDecorViewWasVisible = mDecorViewVisible;
    mInShowWindow = true;
    boolean isPreRenderedAndInvisible = mIsPreRendered && !mWindowVisible;
    final int previousImeWindowStatus = (mDecorViewVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? (isPreRenderedAndInvisible ? IME_INVISIBLE : IME_VISIBLE) : 0);
    startViews(prepareWindow(showInput));
    final int nextImeWindowStatus = mapToImeWindowStatus();
    if (previousImeWindowStatus != nextImeWindowStatus) {
        setImeWindowStatus(nextImeWindowStatus, mBackDisposition);
    }
    // compute visibility
    onWindowShown();
    mIsPreRendered = mCanPreRender;
    if (mIsPreRendered) {
        onPreRenderedWindowVisibilityChanged(true);
    } else {
        // Pre-rendering not supported.
        if (DEBUG)
            Log.d(TAG, ""No pre-rendering supported"");
        mWindowVisible = true;
    }
    // When IME is not pre-rendered, this will actually show the IME.
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
    }
    maybeNotifyPreRendered();
    mDecorViewWasVisible = true;
    mInShowWindow = false;
}","{
    if (DEBUG)
        Log.v(TAG, ""Showing window: showInput="" + showInput + "" mShowInputRequested="" + mShowInputRequested + "" mViewsCreated="" + mViewsCreated + "" mDecorViewVisible="" + mDecorViewVisible + "" mWindowVisible="" + mWindowVisible + "" mInputStarted="" + mInputStarted + "" mShowInputFlags="" + mShowInputFlags);
    if (mInShowWindow) {
        Log.w(TAG, ""Re-entrance in to showWindow"");
        return;
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService#showWindow"", this, null);
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showWindow"");
    mDecorViewWasVisible = mDecorViewVisible;
    mInShowWindow = true;
    final int previousImeWindowStatus = (mDecorViewVisible ? IME_ACTIVE : 0) | (isInputViewShown() ? (!mWindowVisible ? IME_INVISIBLE : IME_VISIBLE) : 0);
    startViews(prepareWindow(showInput));
    final int nextImeWindowStatus = mapToImeWindowStatus();
    if (previousImeWindowStatus != nextImeWindowStatus) {
        setImeWindowStatus(nextImeWindowStatus, mBackDisposition);
    }
    // compute visibility
    onWindowShown();
    mWindowVisible = true;
    // When IME is not pre-rendered, this will actually show the IME.
    if ((previousImeWindowStatus & IME_ACTIVE) == 0) {
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
    }
    mDecorViewWasVisible = true;
    mInShowWindow = false;
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There have been changes inside the control structure adding new method calls `ImeTracing.getInstance().triggerServiceDump(""InputMethodService#showWindow"", this, null);` and `Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showWindow"");` at the beginning, and `Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);` at the end of the method body. Additionally, the condition `isPreRenderedAndInvisible` has been removed and its logic (`!mWindowVisible`) has been directly placed into the `previousImeWindowStatus` variable initialization. This alteration modifies statements around control structures and introduces other statements, hence the code change type is classified as 3,4.","These changes do not introduce any different exception handlings, nor do they affect the method's return type or value, as the method's signature implies that it returns void, and the purpose of these changes is related to debugging and tracing rather than altering functional behavior. Hence, the function's operational behavior regarding the return and thrown exceptions remains the same across versions. Thus, there is no Compatibility Issue, and the classification is 0."
147,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,30,31,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,0,"{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_HPDS) {
        return handleHPDS(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The code has changed significantly from the early version to the late version. Multiple return statements and conditionals have been removed, resulting in far fewer execution branches in the late version. Types of change include the removal of return statements (type 1), control dependency changes (type 3), as all conditions have been stripped except for one, and other statement changes (type 4), because the exception message has been simplified from `ChunkHandler.name(type)` to `name(type)`. This simplification might be considered as another change that is not related to return, exception handling, and control dependency.","The CI could arise from both return values or types (type 1) and exception handling (type 2). Since there are fewer conditions leading to specific method calls, the late version will likely return a different set of values compared to the early version. Additionally, by changing the exception message detail, the information provided when an exception is thrown will be different, leading to a different exception handling behavior."
149,"<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",30,31,"<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>","<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(String,ArrayList<ContentProviderOperation>)>",0,"{
    Objects.requireNonNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, mAttributionTag, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(operations, ""operations"");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mAttributionSource, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The parameter in the applyBatch method call has changed from 'mPackageName, mAttributionTag' to 'mAttributionSource', which indicates that a dependent API has been modified. The rest of the method implementation remains unchanged, so the code change type is 5.","Although a dependent API changed, the signature of the method as well as its return type remains unchanged. The try-catch block for handling 'DeadObjectException' is identical in both versions, which suggests that the exception handling has not changed. Therefore, based on provided details, there is no indication of potential different return values, types, or exception handlings caused by the change. Thus, there should be no CI, and the CI type is 0."
150,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,30,31,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""%d: %s (%f,%f)"", event.getSequenceNumber(), MotionEvent.actionToString(event.getActionMasked()), event.getX(), event.getY());
    }
    if (!isFromPrimePointer(event, false)) {
        return true;
    }
    final int action = event.getActionMasked();
    if (mEditor != null) {
        mEditor.onTouchEvent(event);
        if (mEditor.mInsertionPointCursorController != null && mEditor.mInsertionPointCursorController.isCursorBeingModified()) {
            return true;
        }
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""superResult=%s"", superResult);
    }
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (DEBUG_CURSOR) {
            logCursor(""onTouchEvent"", ""release after long press detected"");
        }
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""%d: %s (%f,%f)"", event.getSequenceNumber(), MotionEvent.actionToString(event.getActionMasked()), event.getX(), event.getY());
    }
    final int action = event.getActionMasked();
    if (mEditor != null) {
        if (!isFromPrimePointer(event, false)) {
            return true;
        }
        mEditor.onTouchEvent(event);
        if (mEditor.mInsertionPointCursorController != null && mEditor.mInsertionPointCursorController.isCursorBeingModified()) {
            return true;
        }
        if (mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) {
            return true;
        }
    }
    final boolean superResult = super.onTouchEvent(event);
    if (DEBUG_CURSOR) {
        logCursor(""onTouchEvent"", ""superResult=%s"", superResult);
    }
    /*
         * Don't handle the release after a long press, because it will move the selection away from
         * whatever the menu action was trying to affect. If the long press should have triggered an
         * insertion action mode, we can now actually show it.
         */
    if (mEditor != null && mEditor.mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mEditor.mDiscardNextActionUp = false;
        if (DEBUG_CURSOR) {
            logCursor(""onTouchEvent"", ""release after long press detected"");
        }
        if (mEditor.mIsInsertionActionModeStartPending) {
            mEditor.startInsertionActionMode();
            mEditor.mIsInsertionActionModeStartPending = false;
        }
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && (mEditor == null || !mEditor.mIgnoreActionUpEvent) && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, mSpannable, event);
        }
        final boolean textIsSelectable = isTextSelectable();
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && textIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = mSpannable.getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length > 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || textIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = getInputMethodManager();
            viewClicked(imm);
            if (isTextEditable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                imm.showSoftInput(this, 0);
            }
            // The above condition ensures that the mEditor is not null
            mEditor.onTouchUpEvent(event);
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
151,"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextBeforeCursor(int,int)>",30,31,"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextBeforeCursor(int,int)>","<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextBeforeCursor(int,int)>",0,"{
    return mTarget.getTextBeforeCursor(n, flags);
}","{
    Preconditions.checkArgumentNonnegative(n);
    return mTarget.getTextBeforeCursor(n, flags);
}",1,"/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 */
","/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 * @throws IllegalArgumentException if {@code length} is negative.
 */
",-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,4,0,"There is an added check for the argument to be non-negative (Preconditions.checkArgumentNonnegative(n)) before the method call, so the code change type is 4.","The added Preconditions check does not modify the method's behavior in terms of the return value or the exception handling as it merely validates an input condition that should be met. If the condition is not met, the check would cause an IllegalArgumentException which is an unchecked exception; this behavior is implicit in the earlier version as well because passing a negative value would presumably be a misuse of the API. Therefore, there is no CI issue here."
153,"<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>",30,31,"<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>","<android.os.PowerManager: void addThermalStatusListener(Executor,OnThermalStatusChangedListener)>",0,"{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: "" + listener);
    IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

        @Override
        public void onStatusChange(int status) {
            final long token = Binder.clearCallingIdentity();
            try {
                executor.execute(() -> {
                    listener.onThermalStatusChanged(status);
                });
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    };
    try {
        if (mThermalService.registerThermalStatusListener(internalListener)) {
            mListenerMap.put(listener, internalListener);
        } else {
            throw new RuntimeException(""Listener failed to set"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkArgument(!mListenerMap.containsKey(listener), ""Listener already registered: %s"", listener);
    IThermalStatusListener internalListener = new IThermalStatusListener.Stub() {

        @Override
        public void onStatusChange(int status) {
            final long token = Binder.clearCallingIdentity();
            try {
                executor.execute(() -> {
                    listener.onThermalStatusChanged(status);
                });
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        }
    };
    try {
        if (mThermalService.registerThermalStatusListener(internalListener)) {
            mListenerMap.put(listener, internalListener);
        } else {
            throw new RuntimeException(""Listener failed to set"");
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
","/**
 * This function adds a listener for thermal status change.
 *
 * @param executor {@link Executor} to handle listener callback.
 * @param listener listener to be added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a minor change in the precondition check string literal from concatenation (""Listener already registered: "" + listener) to using a format specifier (""Listener already registered: %s"", listener). This is categorized under other statement change type 4.","The string modification does not affect the behavior of the API, it only changes the message of the exception that would be constructed. It is not a change that could lead to different values or exceptions being thrown, therefore, there is no Compatibility Issue, which is category 0."
154,"<android.content.res.ResourcesImpl.ThemeImpl: int[] getAttributeResolutionStack(int,int,int)>",30,31,"<android.content.res.ResourcesImpl.ThemeImpl: int[] getAttributeResolutionStack(int,int,int)>","<android.content.res.ResourcesImpl.ThemeImpl: int[] getAttributeResolutionStack(int,int,int)>",0,"{
    synchronized (mKey) {
        return mAssets.getAttributeResolutionStack(mTheme, defStyleAttr, defStyleRes, explicitStyleRes);
    }
}","{
    return mAssets.getAttributeResolutionStack(mTheme, defStyleAttr, defStyleRes, explicitStyleRes);
}",1,"/**
 * Returns the ordered list of resource ID that are considered when resolving attribute
 * values when making an equivalent call to
 * {@link #obtainStyledAttributes(Resources.Theme, AttributeSet, int[], int, int)}. The list
 * will include a set of explicit styles ({@code explicitStyleRes} and it will include the
 * default styles ({@code defStyleAttr} and {@code defStyleRes}).
 *
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 * @param explicitStyleRes A resource identifier of an explicit style resource.
 * @return ordered list of resource ID that are considered when resolving attribute values.
 */
","/**
 * Returns the ordered list of resource ID that are considered when resolving attribute
 * values when making an equivalent call to
 * {@link #obtainStyledAttributes(Resources.Theme, AttributeSet, int[], int, int)}. The list
 * will include a set of explicit styles ({@code explicitStyleRes} and it will include the
 * default styles ({@code defStyleAttr} and {@code defStyleRes}).
 *
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 * @param explicitStyleRes A resource identifier of an explicit style resource.
 * @return ordered list of resource ID that are considered when resolving attribute values.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"2,4",0,"The synchronized block has been removed, and this is an 'Other statement changed'. Also, the exception handling may be potentially different due to removing the synchronized block, even though no explicit exception handling code is present. This change may affect how the method deals with concurrent modifications or accesses that could have been previously synchronized. Given the synchronized block could have implications on the thread-safety of this method, we also consider it to fall under 'Exception handling statement changed'.","However, there is no indication that the behavior of the method in terms of returned values, return types, or exceptions that it throws has changed. The API signature and annotations are the same, and the removal of synchronized does not necessarily indicate that the behaviour of the underlying `getAttributeResolutionStack` call has changed. Thus, even though the exception handling might be handled differently without the synchronized block, the exception catching itself has not changed and such concurrent behavior is typically not a part of the API contract. Therefore, this change does not lead to a Compatibility Issue as per the given rules."
155,<android.content.IntentSender: String getCreatorPackage()>,30,31,<android.content.IntentSender: String getCreatorPackage()>,<android.content.IntentSender: String getCreatorPackage()>,0,"{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    return getCachedInfo().getCreatorPackage();
}",1,"/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole return statement has been changed from calling ActivityManager.getService().getPackageForIntentSender(mTarget) to calling a method getCachedInfo().getCreatorPackage() and there is no try-catch block handling RemoteException in the late version, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value since it now uses a different method to retrieve the creator package. Because there is no try-catch block for the RemoteException in the late version, it can introduce a different exception handling behaviour if such an exception would occur during the call to getCachedInfo().getCreatorPackage() and is unhandled elsewhere. Therefore, the CI type is 1."
156,<android.app.AutomaticZenRule: int hashCode()>,30,31,<android.app.AutomaticZenRule: int hashCode()>,<android.app.AutomaticZenRule: int hashCode()>,0,"{
    return Objects.hash(enabled, name, interruptionFilter, conditionId, owner, configurationActivity, mZenPolicy, mModified, creationTime);
}","{
    return Objects.hash(enabled, name, interruptionFilter, conditionId, owner, configurationActivity, mZenPolicy, mModified, creationTime, mPkg);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The hashCode() method in the late version includes one more field 'mPkg' in the Objects.hash() calculation. This is a change in the other statements since it's related to the object's state, so the code change type is 1,4.","The change in hashCode() method's implementation does not affect the API's behavior in terms of how it's used. The method still returns an integer, and the contract of the hashCode() method is such that it must produce the same output given the same input; the change in fields being considered does not violate this contract. The intent of the hashCode() method is to produce a hash, and the exact value of the hash is generally considered an implementation detail, not a part of the API contract. Thus, no Compatibility Issue is introduced by this change."
158,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,30,31,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,<android.bluetooth.BluetoothGatt: boolean requestMtu(int)>,0,"{
    if (DBG) {
        Log.d(TAG, ""configureMTU() - device: "" + mDevice.getAddress() + "" mtu: "" + mtu);
    }
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.configureMTU(mClientIf, mDevice.getAddress(), mtu);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""configureMTU() - device: "" + mDevice.getAddress() + "" mtu: "" + mtu);
    }
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.configureMTU(mClientIf, mDevice.getAddress(), mtu, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Request an MTU size used for a given connection.
 *
 * <p>When performing a write request operation (write without response),
 * the data sent is truncated to the MTU size. This function may be used
 * to request a larger MTU size to be able to send more data at once.
 *
 * <p>A {@link BluetoothGattCallback#onMtuChanged} callback will indicate
 * whether this operation was successful.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the new MTU value has been requested successfully
 */
","/**
 * Request an MTU size used for a given connection.
 *
 * <p>When performing a write request operation (write without response),
 * the data sent is truncated to the MTU size. This function may be used
 * to request a larger MTU size to be able to send more data at once.
 *
 * <p>A {@link BluetoothGattCallback#onMtuChanged} callback will indicate
 * whether this operation was successful.
 *
 * @return true, if the new MTU value has been requested successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls configureMTU with an additional parameter, mAttributionSource, which is a change in the dependent API being called. Thus, the code change type is 5.","Although there is a change in the dependent API call, this change does not alter the behavior of the method requestMtu in terms of the values it returns nor the exceptions it throws. The method still returns true on success, false on a precondition failure, and handles the RemoteException in the same way. Therefore, there is no Compatibility Issue; hence the CI type is 0."
159,<android.bluetooth.BluetoothGattServer: boolean registerCallback(BluetoothGattServerCallback)>,30,31,<android.bluetooth.BluetoothGattServer: boolean registerCallback(BluetoothGattServerCallback)>,<android.bluetooth.BluetoothGattServer: boolean registerCallback(BluetoothGattServerCallback)>,0,"{
    if (DBG)
        Log.d(TAG, ""registerCallback()"");
    if (mService == null) {
        Log.e(TAG, ""GATT service not available"");
        return false;
    }
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, ""registerCallback() - UUID="" + uuid);
    synchronized (mServerIfLock) {
        if (mCallback != null) {
            Log.e(TAG, ""App can register callback only once"");
            return false;
        }
        mCallback = callback;
        try {
            mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
            mCallback = null;
            return false;
        }
        try {
            mServerIfLock.wait(CALLBACK_REG_TIMEOUT);
        } catch (InterruptedException e) {
            Log.e(TAG, """" + e);
            mCallback = null;
        }
        if (mServerIf == 0) {
            mCallback = null;
            return false;
        } else {
            return true;
        }
    }
}","{
    return registerCallback(callback, false);
}",1,"/*package*/
","/**
 * Register an application callback to start using GattServer.
 *
 * <p>This is an asynchronous call. The callback is used to notify
 * success or failure if the function returns true.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @return true, the callback will be called to notify success or failure, false on immediate
 * error
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed to call `registerCallback(callback, false)` in the late version, which likely indicates a new method or an overload with different parameters is used. Since the whole implementation has been replaced by a call to another method, code change is 1 and 5.","Since the method now delegates to a different implementation (which might have a different behavior), the API could potentially return different values and a Compatibility Issue arises due to the possibility of different return values, thus CI type is 1."
161,<android.content.ClipData: String toString()>,30,31,<android.content.ClipData: String toString()>,<android.content.ClipData: String toString()>,0,"{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipData { "");
    toShortString(b);
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipData { "");
    toShortString(b, true);
    b.append("" }"");
    return b.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method toShortString is called with an additional parameter in the late implementation, but there is no return statement or exception handling statement change, so the change type is 4,5.","Despite the change in the method call, it does not necessarily indicate a Compatibility Issue since it's unknown whether the behavior of toShortString(b, true) differs in such a way from toShortString(b) that would affect the overall behavior of the toString() method. Without additional information about the implementation and behavior of toShortString, we cannot assume different return values or exception handlings, so the CI type is 0."
162,<android.text.format.Time.TimeCalculator: long toMillis(boolean)>,30,31,<android.text.format.Time.TimeCalculator: long toMillis(boolean)>,<android.text.format.Time.TimeCalculator: long toMillis(boolean)>,0,"{
    if (ignoreDst) {
        wallTime.setIsDst(-1);
    }
    int r = wallTime.mktime(zoneInfo);
    if (r == -1) {
        return -1;
    }
    return r * 1000L;
}","{
    if (ignoreDst) {
        wallTime.setIsDst(-1);
    }
    int r = wallTime.mktime(mZoneInfoData);
    if (r == -1) {
        return -1;
    }
    return r * 1000L;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call parameter changed from `zoneInfo` to `mZoneInfoData`, which indicates that the change type is 5.","Even though there's a change in the dependent API call parameter, as long as this parameter change does not affect the return value of the 'mktime' function and subsequent calculations, there will be no Compatibility Issue. There is no indication that the behavior of 'mktime' would change when receiving `mZoneInfoData` instead of `zoneInfo`, as the actual content and structure of these objects are not known. Assuming `mZoneInfoData` is an equivalent, correctly-initialized timezone information as `zoneInfo`, there would be no CI."
163,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",30,31,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the method body between the early and late versions of the code. The parameter list of the `broadcastIntentWithFeature` method appears to have been reformatted with the addition of comments for clarity, but the number, types, and order of the parameters passed to the method are unchanged.","Since there is no functional change to the method implementation or its behavior, there is no compatibility issue between the two versions."
164,<android.content.pm.ShortcutManager: void removeLongLivedShortcuts(List<String>)>,30,31,<android.content.pm.ShortcutManager: void removeLongLivedShortcuts(List<String>)>,<android.content.pm.ShortcutManager: void removeLongLivedShortcuts(List<String>)>,0,"{
    try {
        mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete long lived shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete long lived shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from calling mService.removeLongLivedShortcuts directly to wrapping the call in getFutureOrThrow, which indicates a change in how the service response is handled. This is a change to the statement not related to return statements, exception handling, or control dependencies, and it suggests a change in a dependent API, so the code change falls under 4 and 5.","The change in implementation does not affect the method's behavior regarding its return type or the exceptions it throws because the try-catch block for RemoteException and the throwing mechanism (throw e.rethrowFromSystemServer()) remain the same. Hence, there's no Compatibility Issue as the method signature and behavior in terms of returning a value or throwing an exception have not been altered. The change is internal to the method's execution and does not affect its interface or observable behavior. Therefore, the CI type is 0."
165,"<com.android.server.backup.AccountManagerBackupHelper: void applyRestoredPayload(String,byte[])>",30,31,"<com.android.server.backup.AccountManagerBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.AccountManagerBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    AccountManagerInternal am = LocalServices.getService(AccountManagerInternal.class);
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_ACCOUNT_ACCESS_GRANTS:
                {
                    am.restoreAccountAccessPermissions(payload, UserHandle.USER_SYSTEM);
                }
                break;
            default:
                {
                    Slog.w(TAG, ""Unexpected restore key "" + key);
                }
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}","{
    AccountManagerInternal am = LocalServices.getService(AccountManagerInternal.class);
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_ACCOUNT_ACCESS_GRANTS:
                {
                    am.restoreAccountAccessPermissions(payload, UserHandle.USER_SYSTEM);
                }
                break;
            default:
                {
                    Slog.w(TAG, ""Unexpected restore key "" + key);
                }
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to restore key "" + key, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only the log method changed from Slog.w to Slog.e within the catch block, so it's an Other statement changed situation. The statement that logs an exception has altered from a warning log without an exception trace to an error log with an exception trace. This is a logging level change and not a functional change.","There is no compatibility issue arising from this change since it only affects the log output level and includes the exception trace when logging. It does not affect the return type, value or exception thrown by the API."
166,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>",30,31,"<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>","<android.app.LoadedApk.ServiceDispatcher: void doConnected(ComponentName,IBinder,boolean)>",0,"{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    if (dead) {
        mConnection.onBindingDied(name);
    }
    // If there is a new viable service, it is now connected.
    if (service != null) {
        mConnection.onServiceConnected(name, service);
    } else {
        // The binding machinery worked, but the remote returned null from onBind().
        mConnection.onNullBinding(name);
    }
}","{
    ServiceDispatcher.ConnectionInfo old;
    ServiceDispatcher.ConnectionInfo info;
    synchronized (this) {
        if (mForgotten) {
            // any connection received.
            return;
        }
        old = mActiveConnections.get(name);
        if (old != null && old.binder == service) {
            // Huh, already have this one.  Oh well!
            return;
        }
        if (service != null) {
            // A new service is being connected... set it all up.
            info = new ConnectionInfo();
            info.binder = service;
            info.deathMonitor = new DeathMonitor(name, service);
            try {
                service.linkToDeath(info.deathMonitor, 0);
                mActiveConnections.put(name, info);
            } catch (RemoteException e) {
                // This service was dead before we got it...  just
                // don't do anything with it.
                mActiveConnections.remove(name);
                return;
            }
        } else {
            // The named service is being disconnected... clean up.
            mActiveConnections.remove(name);
        }
        if (old != null) {
            old.binder.unlinkToDeath(old.deathMonitor, 0);
        }
    }
    // If there was an old service, it is now disconnected.
    if (old != null) {
        mConnection.onServiceDisconnected(name);
    }
    if (dead) {
        mConnection.onBindingDied(name);
    } else {
        // If there is a new viable service, it is now connected.
        if (service != null) {
            mConnection.onServiceConnected(name, service);
        } else {
            // The binding machinery worked, but the remote returned null from onBind().
            mConnection.onNullBinding(name);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control statement in the outside 'else' clause has been moved into the 'else' part nested inside the final 'if' statement, thus restructuring the control dependency, so the code change type is 3.","Despite the restructured ""if-else"" control flow, there is no change in the behavior of the API method. Whether the 'dead' variable is true or false, and independent of the 'service' variable's state (null or not-null), the API method calls the relevant methods on 'mConnection' as it did previously. Therefore, there is no Compatibility Issue; the method will behave identically between the two versions in this aspect. The previous logic is merely restructured without altering the underlying logic."
167,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,30,31,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,<android.content.ContentProviderClient: Uri canonicalize(Uri)>,0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mAttributionSource, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#canonicalize}
 */
","/**
 * See {@link ContentProvider#canonicalize}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The parameter passed to the method mContentProvider.canonicalize() changed from (mPackageName, mAttributionTag, url) to (mAttributionSource, url), so the code change type is 5. The number of parameters and the types have been altered.","Despite this change, there is no indication of a direct Compatibility Issue as no return statement or exception handling statement has been directly affected. The structure of the flow remains intact, and exceptions are handled in the same way. Therefore, the CI type is 0."
168,<android.app.EnterTransitionCoordinator: void prepareEnter()>,30,31,<android.app.EnterTransitionCoordinator: void prepareEnter()>,<android.app.EnterTransitionCoordinator: void prepareEnter()>,0,"{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    if (!isCrossTask()) {
        mActivity.overridePendingTransition(0, 0);
    }
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background == null) {
            background = new ColorDrawable(Color.TRANSPARENT);
            mReplacedBackground = background;
        } else {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
        }
        getWindow().setBackgroundDrawable(background);
    } else {
        // all done with it now.
        mActivity = null;
    }
}","{
    ViewGroup decorView = getDecor();
    if (mActivity == null || decorView == null) {
        return;
    }
    mIsTaskRoot = mActivity.isTaskRoot();
    if (!isCrossTask()) {
        mActivity.overridePendingTransition(0, 0);
    }
    if (!mIsReturning) {
        mWasOpaque = mActivity.convertToTranslucent(null, null);
        Drawable background = decorView.getBackground();
        if (background == null) {
            background = new ColorDrawable(Color.TRANSPARENT);
            mReplacedBackground = background;
        } else {
            getWindow().setBackgroundDrawable(null);
            background = background.mutate();
            background.setAlpha(0);
        }
        getWindow().setBackgroundDrawable(background);
    } else {
        // all done with it now.
        mActivity = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is the addition of the assignment `mIsTaskRoot = mActivity.isTaskRoot();`. This is an assignment statement that affects a field not involved in return values or exception handling, so the change type is 4.","There are no changes to return statements or exception handling, nor control dependency changes. Therefore, there shouldn't be a Compatibility Issue, as the added assignment does not affect what is returned by the method or the exceptions that are thrown, and the behavior related to how results are produced does not change."
172,<android.app.Notification: Class<? extends Style> getNotificationStyleClass(String)>,30,31,<android.app.Notification: Class<? extends Style> getNotificationStyleClass(String)>,<android.app.Notification: Class<? extends Style> getNotificationStyleClass(String)>,0,"{
    Class<? extends Style>[] classes = new Class[] { BigTextStyle.class, BigPictureStyle.class, InboxStyle.class, MediaStyle.class, DecoratedCustomViewStyle.class, DecoratedMediaCustomViewStyle.class, MessagingStyle.class };
    for (Class<? extends Style> innerClass : classes) {
        if (templateClass.equals(innerClass.getName())) {
            return innerClass;
        }
    }
    return null;
}","{
    for (Class<? extends Style> innerClass : PLATFORM_STYLE_CLASSES) {
        if (templateClass.equals(innerClass.getName())) {
            return innerClass;
        }
    }
    return null;
}",1,"/**
 * @removed
 */
","/**
 * @removed
 */
",-1,[@SystemApi],[@SystemApi],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation now references a constant (PLATFORM_STYLE_CLASSES) instead of declaring an inline array, and there is no mention of an alteration to the referenced array itself. Since there is no change to the control structure, return statements, or exception handling logic, and assuming that the content of PLATFORM_STYLE_CLASSES is equivalent to the inline array's content, the change type is 4 for using a different source for classes and 5 for a change in the referenced dependency which is the constant in which classes is defined.","There is no Compatibility Issue if the content within PLATFORM_STYLE_CLASSES is identical to the previous inline array of classes. Assuming the referenced PLATFORM_STYLE_CLASSES constant contains the same class objects as before, which the changes do not indicate otherwise, no behavior would change from an external perspective, hence no CI."
173,<android.app.AppOpsManager: String toReceiverId(Object)>,30,31,<android.app.AppOpsManager: String toReceiverId(Object)>,<android.app.AppOpsManager: String toReceiverId(Object)>,0,"{
    if (obj instanceof PendingIntent) {
        return toReceiverId((PendingIntent) obj);
    } else {
        return obj.getClass().getName() + ""@"" + System.identityHashCode(obj);
    }
}","{
    if (obj == null) {
        return ""null"";
    } else if (obj instanceof PendingIntent) {
        return toReceiverId((PendingIntent) obj);
    } else {
        return obj.getClass().getName() + ""@"" + System.identityHashCode(obj);
    }
}",1,"// TODO: this should probably be @SystemApi as well
","// TODO: this should probably be @SystemApi as well
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,"An additional conditional branch checking for 'null' objects is introduced in the control dependency, before the instances of 'PendingIntent' are checked, so the code change type is 3.","There is no Compatibility Issue because the newly added condition only affects the case when 'obj' is null. Since the method is annotated with [@NonNull], it is not expected that null should be passed to it. If null is passed while the annotation is in place, it is a misuse of the API and the expected behavior in such cases is not guaranteed. Therefore, within the assumed proper use of the API, there would be no behavior change: null is already an improper input, and the handling of non-null inputs remains the same. The CI type is 0."
174,<android.bluetooth.BluetoothHearingAid: int getConnectionState(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHearingAid: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothHearingAid: int getConnectionState(BluetoothDevice)>,0,"{
    if (VDBG)
        log(""getState("" + device + "")"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    }
}","{
    if (VDBG)
        log(""getState("" + device + "")"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@Override, @BluetoothProfile.BtProfileState]","[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT), @BluetoothProfile.BtProfileState]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method service.getConnectionState(device) has been changed to service.getConnectionState(device, mAttributionSource) with an additional parameter. No other changes are detected. This indicates the dependent API has changed, so the code change type is 1,5.","The change to the dependent API call can lead to potentially different return values if the behavior of service.getConnectionState is affected by the new parameter mAttributionSource. Therefore, the CI type is 1."
175,<android.app.ActivityThread.ProviderKey: int hashCode()>,30,31,<android.app.ActivityThread.ProviderKey: int hashCode()>,<android.app.ActivityThread.ProviderKey: int hashCode()>,0,"{
    return ((authority != null) ? authority.hashCode() : 0) ^ userId;
}","{
    return hashCode(authority, userId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls a separate method hashCode(authority, userId) rather than doing the computation inline, so the code change type is 5.","There is no Compatibility Issue as long as the newly introduced hashCode(authority, userId) method behaves exactly the same as the inlined computation from the early version. Since there is no indication that the behavior of calculating the hash code has changed, we can assume it to be a refactoring with the intention of maintaining the same behavior. Therefore, the pred_CI is 0."
177,<android.animation.AnimatorSet.Builder: Builder after(long)>,30,31,<android.animation.AnimatorSet.Builder: Builder after(long)>,<android.animation.AnimatorSet.Builder: Builder after(long)>,0,"{
    // setup dummy ValueAnimator just to run the clock
    ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
    anim.setDuration(delay);
    after(anim);
    return this;
}","{
    // setup a ValueAnimator just to run the clock
    ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
    anim.setDuration(delay);
    after(anim);
    return this;
}",1,"/**
 * Sets up the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to play when the given amount of time elapses.
 *
 * @param delay The number of milliseconds that should elapse before the
 * animation starts.
 */
","/**
 * Sets up the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * to play when the given amount of time elapses.
 *
 * @param delay The number of milliseconds that should elapse before the
 * animation starts.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There has been no change in the code, except a comment update which does not affect the behavior or the output of the method.",There is no Compatibility Issue since there are no changes to the method's implementation or its signature.
178,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",30,31,"<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>","<android.view.inputmethod.InputMethodManager: void showStatusIcon(IBinder,String,int)>",0,"{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(packageName, iconId);
}","{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIconAsync(packageName, iconId);
}",1,"/**
 * @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
","/**
 * @deprecated Use {@link InputMethodService#showStatusIcon(int)} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in this
 * class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method name called on the object from InputMethodPrivilegedOperationsRegistry has been changed from updateStatusIcon to updateStatusIconAsync, indicating a dependent API change, so the code change type is 5.","There's no indication that changing from updateStatusIcon to updateStatusIconAsync would lead to a change in the behavior or output of the showStatusIcon method, assuming that updateStatusIconAsync is designed to have the same effect as updateStatusIcon, just in an asynchronous manner. There is no evidence of a change in return type, exception throwing, or control flow as a result of this renaming, so there is no compatibility issue expected. Therefore, the CI type is 0."
180,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,30,31,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to include a call to Attributable.setAttributionSource() in the late implementation, which wraps the original returned list with additional attribution information. A dependent API Attributable.setAttributionSource() is called within the try block of the late version. So, the changes are categorized as 1 and 5.","Since the return statement now includes an additional method call that may manipulate the return value, this can potentially result in a different value being returned. Thus, there is a compatibility issue of type 1."
181,<android.app.Activity: void finishActivity(int)>,30,31,<android.app.Activity: void finishActivity(int)>,<android.app.Activity: void finishActivity(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityTaskManager.getService().finishSubActivity(mToken, mEmbeddedID, requestCode);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}","{
    if (mParent == null) {
        ActivityClient.getInstance().finishSubActivity(mToken, mEmbeddedID, requestCode);
    } else {
        mParent.finishActivityFromChild(this, requestCode);
    }
}",1,"/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
","/**
 * Force finish another activity that you had previously started with
 * {@link #startActivityForResult}.
 *
 * @param requestCode The request code of the activity that you had
 * given to startActivityForResult().  If there are multiple
 * activities started with this request code, they
 * will all be finished.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to finish the sub-activity within the if(mParent == null) block has been changed from ActivityTaskManager.getService().finishSubActivity(...) to ActivityClient.getInstance().finishSubActivity(...). The logic remains the same, but the dependent API to accomplish the task has changed, hence change 4,5 was applied.","The API has changed the implementation of how to finish a sub-activity, but from a caller's perspective, this does not introduce a compatibility issue. The method still does not return any value nor throw a different exception based on the code provided (there is no 'throw' statement in the late version, as opposed to the early version where the 'catch' block is empty), hence there's no potential for a different return value or type, and no difference in exception handling. Therefore, no compatibility issue arises, which is classified as 0."
182,<android.os.Parcel: Parcel obtain()>,30,31,<android.os.Parcel: Parcel obtain()>,<android.os.Parcel: Parcel obtain()>,0,"{
    final Parcel[] pool = sOwnedPool;
    synchronized (pool) {
        Parcel p;
        for (int i = 0; i < POOL_SIZE; i++) {
            p = pool[i];
            if (p != null) {
                pool[i] = null;
                if (DEBUG_RECYCLE) {
                    p.mStack = new RuntimeException();
                }
                p.mReadWriteHelper = ReadWriteHelper.DEFAULT;
                return p;
            }
        }
    }
    return new Parcel(0);
}","{
    Parcel res = null;
    synchronized (sPoolSync) {
        if (sOwnedPool != null) {
            res = sOwnedPool;
            sOwnedPool = res.mPoolNext;
            res.mPoolNext = null;
            sOwnedPoolSize--;
        }
    }
    // cached object to be used
    if (res == null) {
        res = new Parcel(0);
    } else {
        if (DEBUG_RECYCLE) {
            res.mStack = new RuntimeException();
        }
        res.mReadWriteHelper = ReadWriteHelper.DEFAULT;
    }
    return res;
}",1,"/**
 * Retrieve a new Parcel object from the pool.
 */
","/**
 * Retrieve a new Parcel object from the pool.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,5",1,"There is a control dependency change as the method of obtaining a Parcel from the pool has been refactored. Additionally, the return statement changed because it now accommodates the new implementation of pooling logic. The relevant condition check and the loop have been removed. There's also a dependent API change since the implementation now uses different member variables (`sPoolSync`, `sOwnedPool`, `mPoolNext`, `sOwnedPoolSize`) that are not present in the early version. So, the code change types are 1,3,5.","The changes in how the Parcel object is obtained from the pool and returned could potentially lead to different Parcel objects being returned because the internal pooling mechanism changed. This constitutes a case where the API might return a different value, leading to a Compatibility Issue of type 1."
183,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,30,31,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,<android.content.pm.LauncherActivityInfo: Drawable getIcon(int)>,0,"{
    // TODO: Go through LauncherAppsService
    final int iconRes = mActivityInfo.getIconResource();
    Drawable icon = null;
    // Get the preferred density icon from the app's resources
    if (density != 0 && iconRes != 0) {
        try {
            final Resources resources = mPm.getResourcesForApplication(mActivityInfo.applicationInfo);
            icon = resources.getDrawableForDensity(iconRes, density);
        } catch (NameNotFoundException | Resources.NotFoundException exc) {
        }
    }
    // Get the default density icon
    if (icon == null) {
        icon = mActivityInfo.loadIcon(mPm);
    }
    return icon;
}","{
    // TODO: Go through LauncherAppsService
    final int iconRes = getActivityInfo().getIconResource();
    Drawable icon = null;
    // Get the preferred density icon from the app's resources
    if (density != 0 && iconRes != 0) {
        try {
            final Resources resources = mPm.getResourcesForApplication(getActivityInfo().applicationInfo);
            icon = resources.getDrawableForDensity(iconRes, density);
        } catch (NameNotFoundException | Resources.NotFoundException exc) {
        }
    }
    // Get the default density icon
    if (icon == null) {
        icon = getActivityInfo().loadIcon(mPm);
    }
    return icon;
}",1,"/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
","/**
 * Returns the icon for this activity, without any badging for the profile.
 * @param density The preferred density of the icon, zero for default density. Use
 * density DPI values from {@link DisplayMetrics}.
 * @see #getBadgedIcon(int)
 * @see DisplayMetrics
 * @return The drawable associated with the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change consists of replacing direct field accesses (`mActivityInfo`) with a method call (`getActivityInfo()`). Since both the field access and the method call should refer to the same object, no change in the behaviour of the API is expected. This is a change in how the object is accessed (from a direct field access to a method call), hence the change type is 4,5.","There is no Compatibility Issue arising from this change, because although the access to `mActivityInfo` has been changed to `getActivityInfo()`, the object and its properties that are being accessed remain unchanged. The return statements and exception handling have not been altered, so they should not cause any difference in the API's behaviour between the two versions."
189,"<android.app.LoadedApk.SplitDependencyLoaderImpl: void constructSplit(int,int[],int)>",30,31,"<android.app.LoadedApk.SplitDependencyLoaderImpl: void constructSplit(int,int[],int)>","<android.app.LoadedApk.SplitDependencyLoaderImpl: void constructSplit(int,int[],int)>",0,"{
    final ArrayList<String> splitPaths = new ArrayList<>();
    if (splitIdx == 0) {
        createOrUpdateClassLoaderLocked(null);
        mCachedClassLoaders[0] = mClassLoader;
        // Never add the base resources here, they always get added no matter what.
        for (int configSplitIdx : configSplitIndices) {
            splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
        }
        mCachedResourcePaths[0] = splitPaths.toArray(new String[splitPaths.size()]);
        return;
    }
    // Since we handled the special base case above, parentSplitIdx is always valid.
    final ClassLoader parent = mCachedClassLoaders[parentSplitIdx];
    mCachedClassLoaders[splitIdx] = ApplicationLoaders.getDefault().getClassLoader(mSplitAppDirs[splitIdx - 1], getTargetSdkVersion(), false, null, null, parent, mSplitClassLoaderNames[splitIdx - 1]);
    Collections.addAll(splitPaths, mCachedResourcePaths[parentSplitIdx]);
    splitPaths.add(mSplitResDirs[splitIdx - 1]);
    for (int configSplitIdx : configSplitIndices) {
        splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
    }
    mCachedResourcePaths[splitIdx] = splitPaths.toArray(new String[splitPaths.size()]);
}","{
    synchronized (mLock) {
        final ArrayList<String> splitPaths = new ArrayList<>();
        if (splitIdx == 0) {
            createOrUpdateClassLoaderLocked(null);
            mCachedClassLoaders[0] = mClassLoader;
            // Never add the base resources here, they always get added no matter what.
            for (int configSplitIdx : configSplitIndices) {
                splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
            }
            mCachedResourcePaths[0] = splitPaths.toArray(new String[splitPaths.size()]);
            return;
        }
        // Since we handled the special base case above, parentSplitIdx is always valid.
        final ClassLoader parent = mCachedClassLoaders[parentSplitIdx];
        mCachedClassLoaders[splitIdx] = ApplicationLoaders.getDefault().getClassLoader(mSplitAppDirs[splitIdx - 1], getTargetSdkVersion(), false, null, null, parent, mSplitClassLoaderNames[splitIdx - 1]);
        Collections.addAll(splitPaths, mCachedResourcePaths[parentSplitIdx]);
        splitPaths.add(mSplitResDirs[splitIdx - 1]);
        for (int configSplitIdx : configSplitIndices) {
            splitPaths.add(mSplitResDirs[configSplitIdx - 1]);
        }
        mCachedResourcePaths[splitIdx] = splitPaths.toArray(new String[splitPaths.size()]);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The addition of a synchronization block (synchronized (mLock)) constitutes a control dependency change, i.e., change type 3, as it alters the thread-safety of the method.","The introduction of the synchronized block changes the way the method behaves in a multi-threaded environment but does not affect the method's return type, value, or exceptions thrown. Therefore, it does not introduce a Compatibility Issue. The CI type is 0."
190,<android.content.SyncRequest.Builder: SyncRequest build()>,30,31,<android.content.SyncRequest.Builder: SyncRequest build()>,<android.content.SyncRequest.Builder: SyncRequest build()>,0,"{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with"" + "" setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}","{
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mScheduleAsExpeditedJob) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Validate the extras bundles
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    // If this is a periodic sync ensure than invalid extras were not set.
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // If this sync is scheduled as an EJ, ensure that invalid extras were not set.
    if (mCustomExtras.getBoolean(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB) || mScheduleAsExpeditedJob) {
        if (ContentResolver.hasInvalidScheduleAsEjExtras(mCustomExtras) || ContentResolver.hasInvalidScheduleAsEjExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException(""Illegal extras were set"");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException(""Must specify an adapter with"" + "" setSyncAdapter(Account, String"");
    }
    return new SyncRequest(this);
}",1,"/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
","/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version starts by validating the extras bundle and then setting mCustomExtras if null, while the late version starts by combining builder extra flags, sets mCustomExtras if null afterwards, and validates the extras bundle later. Additionally, the late version includes a check for the flag `mScheduleAsExpeditedJob` that is not present in the early version. The ordering of extra bundle validation and the addition of a new conditional block for `mScheduleAsExpeditedJob` represents an ""Other statement changed"" scenario.","Although the order and statements of the implementation have changed, none of the changes indicate a change in behavior that would lead to either a different return value or a different exception being thrown under the same conditions. The validations performed remain the same, and the conditions that lead to exceptions are not alteredâ€”the same exceptions are still thrown for the illegal extras and unspecified adapter scenarios. Therefore, no compatibility issue arises from these changes."
192,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,30,31,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,<android.content.ContentProviderClient: Uri uncanonicalize(Uri)>,0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mAttributionSource, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#uncanonicalize}
 */
","/**
 * See {@link ContentProvider#uncanonicalize}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The API signature remains the same. However, the implementation has changed from calling mContentProvider.uncanonicalize with three parameters (mPackageName, mAttributionTag, url) to just two parameters (mAttributionSource, url), which means that the method which is being called has changed, specifically how its parameters are being passed to it. Therefore, this change is classified as a Dependent API changed (5).","Despite the change in the parameter list for the dependent method call, this does not constitute a compatibility issue for the user of the `uncanonicalize` API, because the signature of `uncanonicalize` and the value it returns have not changed. The dependent API is handled internally, and as long as the method still correctly fulfills its contract by providing the same functionality with the new parameter, there isn't a compatibility issue based purely on this aspect of the change, so the CI type is 0."
193,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,30,31,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,<android.bluetooth.le.ScanSettings.Builder: Builder setScanMode(int)>,0,"{
    if (scanMode < SCAN_MODE_OPPORTUNISTIC || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException(""invalid scan mode "" + scanMode);
    }
    mScanMode = scanMode;
    return this;
}","{
    switch(scanMode) {
        case SCAN_MODE_OPPORTUNISTIC:
        case SCAN_MODE_LOW_POWER:
        case SCAN_MODE_BALANCED:
        case SCAN_MODE_LOW_LATENCY:
        case SCAN_MODE_AMBIENT_DISCOVERY:
            mScanMode = scanMode;
            break;
        default:
            throw new IllegalArgumentException(""invalid scan mode "" + scanMode);
    }
    return this;
}",1,"/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */
","/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The exception handling has not really changed, as the same exception is thrown for invalid scan modes in both implementations, but the control structure around how this is determined has changed from an if-statement to a switch-statement. Therefore, the code change type is 3.","No Compatibility Issue arises because the behaviour of the method is the same: it throws an IllegalArgumentException if the scan mode is invalid, regardless of the use of an if-statement or a switch-statement to validate the scan mode. The set of valid scan modes appears to remain unchanged, as there are no new cases or deleted cases in the switch statement related to scan modes. Thus, the API behaves the same when called with the same arguments, which means there is no CI."
194,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,30,31,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,<android.bluetooth.BluetoothAdapter: IBluetooth getBluetoothService(IBluetoothManagerCallback)>,0,"{
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, ""getBluetoothService() called with no BluetoothManagerCallback"");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}","{
    Objects.requireNonNull(cb);
    synchronized (sServiceLock) {
        sProxyServiceStateCallbacks.put(cb, null);
        registerOrUnregisterAdapterLocked();
        return sService;
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The way callbacks are managed has been changed with a switch from a conditional insertion 'if (!mProxyServiceStateCallbacks.contains(cb)) { mProxyServiceStateCallbacks.add(cb); }' to unconditional insertion using a Map 'sProxyServiceStateCallbacks.put(cb, null);'. Additionally, there is a change from 'Log.w' to 'Objects.requireNonNull(cb);', a change in Object being synchronized on from 'mProxyServiceStateCallbacks' to 'sServiceLock', and a change in the service variable from 'mService' to 'sService'. There is also a new method call 'registerOrUnregisterAdapterLocked();' before the return. Therefore, there are changes in control dependency, other statements changed, and the mechanism for obtaining the service has changed implying a change in the dependent API.","The change in the return statement from 'return mService;' to 'return sService;' implies that the method may now return different objects, hence there is a Compatibility Issue caused by different return values or types. The removal of the conditional check 'if (!mProxyServiceStateCallbacks.contains(cb))' and the new throw of 'NullPointerException' by 'Objects.requireNonNull(cb);' can potentially cause different exception handlings (in the case when cb is null) leading to a different behavior. Therefore, the CI type is 1."
195,<android.hardware.biometrics.BiometricPrompt: CharSequence getTitle()>,30,31,<android.hardware.biometrics.BiometricPrompt: CharSequence getTitle()>,<android.hardware.biometrics.BiometricPrompt: CharSequence getTitle()>,0,"{
    return mBundle.getCharSequence(KEY_TITLE, """");
}","{
    return mPromptInfo.getTitle();
}",1,"/**
 * Gets the title for the prompt, as set by {@link Builder#setTitle(CharSequence)}.
 * @return The title of the prompt, which is guaranteed to be non-null.
 */
","/**
 * Gets the title for the prompt, as set by {@link Builder#setTitle(CharSequence)}.
 * @return The title of the prompt, which is guaranteed to be non-null.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method used to obtain the title has changed from mBundle.getCharSequence(KEY_TITLE, """") to mPromptInfo.getTitle(). This means the implementation has changed the dependent API, making the change type 5.","Despite the change in the method used to obtain the title, both methods are expected to serve the same purposeâ€”returning the title for the BiometricPrompt. Since there is no change in the return type, and both methods are expected to return non-null CharSequence objects (as indicated by the @NonNull annotation in both versions), there's no indication that this change will lead to a different behavior from the API's point of view. Thus, there is no Compatibility Issue."
196,<android.bluetooth.BluetoothGatt: boolean requestConnectionPriority(int)>,30,31,<android.bluetooth.BluetoothGatt: boolean requestConnectionPriority(int)>,<android.bluetooth.BluetoothGatt: boolean requestConnectionPriority(int)>,0,"{
    if (connectionPriority < CONNECTION_PRIORITY_BALANCED || connectionPriority > CONNECTION_PRIORITY_LOW_POWER) {
        throw new IllegalArgumentException(""connectionPriority not within valid range"");
    }
    if (DBG)
        Log.d(TAG, ""requestConnectionPriority() - params: "" + connectionPriority);
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.connectionParameterUpdate(mClientIf, mDevice.getAddress(), connectionPriority);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (connectionPriority < CONNECTION_PRIORITY_BALANCED || connectionPriority > CONNECTION_PRIORITY_LOW_POWER) {
        throw new IllegalArgumentException(""connectionPriority not within valid range"");
    }
    if (DBG)
        Log.d(TAG, ""requestConnectionPriority() - params: "" + connectionPriority);
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.connectionParameterUpdate(mClientIf, mDevice.getAddress(), connectionPriority, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Request a connection parameter update.
 *
 * <p>This function will send a connection parameter update request to the
 * remote device.
 *
 * @param connectionPriority Request a specific connection priority. Must be one of {@link
 * BluetoothGatt#CONNECTION_PRIORITY_BALANCED}, {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH}
 * or {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.
 * @throws IllegalArgumentException If the parameters are outside of their specified range.
 */
","/**
 * Request a connection parameter update.
 *
 * <p>This function will send a connection parameter update request to the
 * remote device.
 *
 * @param connectionPriority Request a specific connection priority. Must be one of {@link
 * BluetoothGatt#CONNECTION_PRIORITY_BALANCED}, {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH}
 * or {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.
 * @throws IllegalArgumentException If the parameters are outside of their specified range.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method mService.connectionParameterUpdate() now includes an additional parameter 'mAttributionSource', so the code change type is 4. The change in the annotations indicates new permission requirements, thus there is also a Dependent API change of type 5.","Since these changes do not affect the execution flow or possible outputs of the method itself, they do not introduce a compatibility issue according to the Compatibility Issue definitions provided. Therefore, no compatibility issue is detected."
197,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetReport(BluetoothDevice,byte,byte,byte[])>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetReport(BluetoothDevice,byte,byte,byte[])>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetReport(BluetoothDevice,byte,byte,byte[])>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onSetReport(device, type, id, data));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onSetReport(device, type, id, data));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"The late version of the code introduces additional statements for setting an attribution source to the 'device' and altering the exception handling strategy by wrapping the executor's execution with a 'try-finally' block where the identity is restored after the execution. This results in a change type of 2,4 because there's a new call to 'setAttributionSource' and a change in exception handling pattern.","These changes do not result in a Compatibility Issue because they do not affect the return value or thrown exceptions of the public API method 'onSetReport'. The internal implementation changes with regards to attribution source handling and ensuring the calling identity is restored, but the overall behavior from the point of view of the caller remains the same."
200,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",30,31,"<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(uri, ""uri"");
    try {
        if (mWrapped != null) {
            return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
        }
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    try {
        if (mWrapped != null) {
            return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
        }
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mContext.getAttributionSource(), uri, projection, queryArgs, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mContext.getAttributionSource(), uri, projection, queryArgs, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, queryArgs);
        // Wrap the cursor object into CursorWrapperInner object.
        final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri);
        final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS
 * @see #QUERY_ARG_SORT_DIRECTION
 * @see #QUERY_ARG_SORT_COLLATION
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry. May return
 * <code>null</code> if the underlying content provider returns <code>null</code>,
 * or if it crashes.
 * @see Cursor
 */
","/**
 * Query the given URI, returning a {@link Cursor} over the result set
 * with support for cancellation.
 *
 * <p>For best performance, the caller should follow these guidelines:
 *
 * <li>Provide an explicit projection, to prevent reading data from storage
 * that aren't going to be used.
 *
 * Provider must identify which QUERY_ARG_SORT* arguments were honored during
 * the preparation of the result set by including the respective argument keys
 * in the {@link Cursor} extras {@link Bundle}. See {@link #EXTRA_HONORED_ARGS}
 * for details.
 *
 * @see #QUERY_ARG_SORT_COLUMNS
 * @see #QUERY_ARG_SORT_DIRECTION
 * @see #QUERY_ARG_SORT_COLLATION
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param queryArgs A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry. May return
 * <code>null</code> if the underlying content provider returns <code>null</code>,
 * or if it crashes.
 * @see Cursor
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,,,,
202,<android.view.View: void setSystemGestureExclusionRects(List<Rect>)>,30,31,<android.view.View: void setSystemGestureExclusionRects(List<Rect>)>,<android.view.View: void setSystemGestureExclusionRects(List<Rect>)>,0,"{
    if (rects.isEmpty() && mListenerInfo == null)
        return;
    final ListenerInfo info = getListenerInfo();
    if (rects.isEmpty()) {
        info.mSystemGestureExclusionRects = null;
        if (info.mPositionUpdateListener != null) {
            mRenderNode.removePositionUpdateListener(info.mPositionUpdateListener);
        }
    } else {
        info.mSystemGestureExclusionRects = rects;
        if (info.mPositionUpdateListener == null) {
            info.mPositionUpdateListener = new RenderNode.PositionUpdateListener() {

                @Override
                public void positionChanged(long n, int l, int t, int r, int b) {
                    postUpdateSystemGestureExclusionRects();
                }

                @Override
                public void positionLost(long frameNumber) {
                    postUpdateSystemGestureExclusionRects();
                }
            };
            mRenderNode.addPositionUpdateListener(info.mPositionUpdateListener);
        }
    }
    postUpdateSystemGestureExclusionRects();
}","{
    if (rects.isEmpty() && mListenerInfo == null)
        return;
    final ListenerInfo info = getListenerInfo();
    if (info.mSystemGestureExclusionRects != null) {
        info.mSystemGestureExclusionRects.clear();
        info.mSystemGestureExclusionRects.addAll(rects);
    } else {
        info.mSystemGestureExclusionRects = new ArrayList<>(rects);
    }
    if (rects.isEmpty()) {
        if (info.mPositionUpdateListener != null) {
            mRenderNode.removePositionUpdateListener(info.mPositionUpdateListener);
        }
    } else {
        if (info.mPositionUpdateListener == null) {
            info.mPositionUpdateListener = new RenderNode.PositionUpdateListener() {

                @Override
                public void positionChanged(long n, int l, int t, int r, int b) {
                    postUpdateSystemGestureExclusionRects();
                }

                @Override
                public void positionLost(long frameNumber) {
                    postUpdateSystemGestureExclusionRects();
                }
            };
            mRenderNode.addPositionUpdateListener(info.mPositionUpdateListener);
        }
    }
    postUpdateSystemGestureExclusionRects();
}",1,"/**
 * Sets a list of areas within this view's post-layout coordinate space where the system
 * should not intercept touch or other pointing device gestures. <em>This method should
 * be called by {@link #onLayout(boolean, int, int, int, int)} or {@link #onDraw(Canvas)}.</em>
 *
 * <p>Use this to tell the system which specific sub-areas of a view need to receive gesture
 * input in order to function correctly in the presence of global system gestures that may
 * conflict. For example, if the system wishes to capture swipe-in-from-screen-edge gestures
 * to provide system-level navigation functionality, a view such as a navigation drawer
 * container can mark the left (or starting) edge of itself as requiring gesture capture
 * priority using this API. The system may then choose to relax its own gesture recognition
 * to allow the app to consume the user's gesture. It is not necessary for an app to register
 * exclusion rects for broadly spanning regions such as the entirety of a
 * <code>ScrollView</code> or for simple press and release click targets such as
 * <code>Button</code>. Mark an exclusion rect when interacting with a view requires
 * a precision touch gesture in a small area in either the X or Y dimension, such as
 * an edge swipe or dragging a <code>SeekBar</code> thumb.</p>
 *
 * <p>Do not modify the provided list after this method is called.</p>
 *
 * <p>Note: the system will put a limit of <code>200dp</code> on the vertical extent of the
 * exclusions it takes into account. The limit does not apply while the navigation
 * bar is {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY stickily} hidden, nor to the
 * {@link android.inputmethodservice.InputMethodService input method} and
 * {@link Intent#CATEGORY_HOME home activity}.
 * </p>
 *
 * @param rects A list of precision gesture regions that this view needs to function correctly
 */
","/**
 * Sets a list of areas within this view's post-layout coordinate space where the system
 * should not intercept touch or other pointing device gestures. <em>This method should
 * be called by {@link #onLayout(boolean, int, int, int, int)} or {@link #onDraw(Canvas)}.</em>
 *
 * <p>Use this to tell the system which specific sub-areas of a view need to receive gesture
 * input in order to function correctly in the presence of global system gestures that may
 * conflict. For example, if the system wishes to capture swipe-in-from-screen-edge gestures
 * to provide system-level navigation functionality, a view such as a navigation drawer
 * container can mark the left (or starting) edge of itself as requiring gesture capture
 * priority using this API. The system may then choose to relax its own gesture recognition
 * to allow the app to consume the user's gesture. It is not necessary for an app to register
 * exclusion rects for broadly spanning regions such as the entirety of a
 * <code>ScrollView</code> or for simple press and release click targets such as
 * <code>Button</code>. Mark an exclusion rect when interacting with a view requires
 * a precision touch gesture in a small area in either the X or Y dimension, such as
 * an edge swipe or dragging a <code>SeekBar</code> thumb.</p>
 *
 * <p>Note: the system will put a limit of <code>200dp</code> on the vertical extent of the
 * exclusions it takes into account. The limit does not apply while the navigation
 * bar is {@link #SYSTEM_UI_FLAG_IMMERSIVE_STICKY stickily} hidden, nor to the
 * {@link android.inputmethodservice.InputMethodService input method} and
 * {@link Intent#CATEGORY_HOME home activity}.
 * </p>
 *
 * @param rects A list of precision gesture regions that this view needs to function correctly
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The main changes are in how `mSystemGestureExclusionRects` is being updated:,
203,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setTitle(CharSequence)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setTitle(CharSequence)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setTitle(CharSequence)>,0,"{
    mBundle.putCharSequence(KEY_TITLE, title);
    return this;
}","{
    mPromptInfo.setTitle(title);
    return this;
}",1,"/**
 * Required: Sets the title that will be shown on the prompt.
 * @param title The title to display.
 * @return This builder.
 */
","/**
 * Required: Sets the title that will be shown on the prompt.
 * @param title The title to display.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",1,"The method used to set the title has changed from mBundle.putCharSequence(KEY_TITLE, title) to mPromptInfo.setTitle(title), indicating a change in internal implementation and the dependency on a method of a different object (mPromptInfo) has changed. Therefore, the change types are 4 for an 'Other statement changed' and 5 for 'Dependent API changed'.","The change in the method used to set the title suggests that a different mechanism is now being used to apply the title to the builder. Although the final effect for the user should theoretically remain the same (setting the title), due to the dependency on a different API (mPromptInfo.setTitle(title) instead of mBundle.putCharSequence(KEY_TITLE, title)), there's a possibility that the behavior could be different, for example, if mPromptInfo object behaves differently or if it handles the title attribute in a different way. Hence, the CI type is 1 for a potential 'Compatibility Issue caused by potential different return values or types'."
204,<android.accessibilityservice.AccessibilityService: SparseArray<List<AccessibilityWindowInfo>> getWindowsOnAllDisplays()>,30,31,<android.accessibilityservice.AccessibilityService: SparseArray<List<AccessibilityWindowInfo>> getWindowsOnAllDisplays()>,<android.accessibilityservice.AccessibilityService: SparseArray<List<AccessibilityWindowInfo>> getWindowsOnAllDisplays()>,0,"{
    return AccessibilityInteractionClient.getInstance().getWindowsOnAllDisplays(mConnectionId);
}","{
    return AccessibilityInteractionClient.getInstance(this).getWindowsOnAllDisplays(mConnectionId);
}",1,"/**
 * Gets the windows on the screen of all displays. This method returns only the windows
 * that a sighted user can interact with, as opposed to all windows.
 * For example, if there is a modal dialog shown and the user cannot touch
 * anything behind it, then only the modal window will be reported
 * (assuming it is the top one). For convenience the returned windows
 * are ordered in a descending layer order, which is the windows that
 * are on top are reported first. Since the user can always
 * interact with the window that has input focus by typing, the focused
 * window is always returned (even if covered by a modal window).
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag.
 * </p>
 *
 * @return The windows of all displays if there are windows and the service is can retrieve
 * them, otherwise an empty list. The key of SparseArray is display ID.
 */
","/**
 * Gets the windows on the screen of all displays. This method returns only the windows
 * that a sighted user can interact with, as opposed to all windows.
 * For example, if there is a modal dialog shown and the user cannot touch
 * anything behind it, then only the modal window will be reported
 * (assuming it is the top one). For convenience the returned windows
 * are ordered in a descending layer order, which is the windows that
 * are on top are reported first. Since the user can always
 * interact with the window that has input focus by typing, the focused
 * window is always returned (even if covered by a modal window).
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag.
 * </p>
 *
 * @return The windows of all displays if there are windows and the service is can retrieve
 * them, otherwise an empty list. The key of SparseArray is display ID.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The change is the addition of `this` as an argument for the `getInstance` method of `AccessibilityInteractionClient`. This indicates a change in the dependent API (how `getInstance` is called), so the code change type is 5.","Even though there is a change in the dependent API, since the same method `getWindowsOnAllDisplays` is being called with the same argument `mConnectionId`, there is no Compatibility Issue caused by different return values or exception handlings. The method's behavior from the perspective of a caller should remain unchanged because it still returns the same type, and the method is annotated as `@NonNull` in both versions."
205,<android.app.ActivityThread.H: void handleMessage(Message)>,30,31,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            mConfigurationController.handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case DUMP_GFXINFO:
            handleDumpGfxInfo((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throwRemoteServiceException((String) msg.obj, msg.arg1);
            break;
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
        case UPDATE_UI_TRANSLATION_STATE:
            final SomeArgs args = (SomeArgs) msg.obj;
            updateUiTranslationState((IBinder) args.arg1, (int) args.arg2, (TranslationSpec) args.arg3, (TranslationSpec) args.arg4, (List<AutofillId>) args.arg5, (UiTranslationSpec) args.arg6);
            break;
        case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
            handleSetContentCaptureOptionsCallback((String) msg.obj);
            break;
        case INSTRUMENT_WITHOUT_RESTART:
            handleInstrumentWithoutRestart((AppBindData) msg.obj);
            break;
        case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
            handleFinishInstrumentationWithoutRestart();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
206,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,30,31,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            outAttrs.setInitialSurroundingText(mText);
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor() && isEnabled()) {
        mEditor.createInputMethodStateIfNeeded();
        outAttrs.inputType = getInputType();
        if (mEditor.mInputContentType != null) {
            outAttrs.imeOptions = mEditor.mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel;
            outAttrs.actionId = mEditor.mInputContentType.imeActionId;
            outAttrs.extras = mEditor.mInputContentType.extras;
            outAttrs.hintLocales = mEditor.mInputContentType.imeHintLocales;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
            outAttrs.hintLocales = null;
        }
        if (focusSearch(FOCUS_DOWN) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
        }
        if (focusSearch(FOCUS_UP) != null) {
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if ((outAttrs.imeOptions & EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if (getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT) {
            outAttrs.internalImeOptions |= EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT;
        }
        if (isMultilineInputType(outAttrs.inputType)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        outAttrs.targetInputMethodUser = mTextOperationUser;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType());
            outAttrs.setInitialSurroundingText(mText);
            outAttrs.contentMimeTypes = getReceiveContentMimeTypes();
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
208,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,30,31,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,<android.content.pm.PackageInstaller: int createSession(SessionParams)>,0,"{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return mInstaller.createSession(params, mInstallerPackageName, mAttributionTag, mUserId);
    } catch (RuntimeException e) {
        ExceptionUtils.maybeUnwrapIOException(e);
        throw e;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
","/**
 * Create a new session using the given parameters, returning a unique ID
 * that represents the session. Once created, the session can be opened
 * multiple times across multiple device boots.
 * <p>
 * The system may automatically destroy sessions that have not been
 * finalized (either committed or abandoned) within a reasonable period of
 * time, typically on the order of a day.
 *
 * @throws IOException if parameters were unsatisfiable, such as lack of
 * disk space or unavailable media.
 * @throws SecurityException when installation services are unavailable,
 * such as when called from a restricted user.
 * @throws IllegalArgumentException when {@link SessionParams} is invalid.
 * @return positive, non-zero unique ID that represents the created session.
 * This ID remains consistent across device reboots until the
 * session is finalized. IDs are not reused during a given boot.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature of mInstaller.createSession has an additional parameter mAttributionTag in the late version. This is a change in the dependent API the current method relies on, so the code change types are 4 for the additional parameter and 5 for the dependent API change.","No Compatibility Issue arises from this change as the additional parameter does not affect how exceptions are handled, or the return type or value of the method. The method still returns the session ID as an int, and the try-catch blocks are unchanged, so there is no alteration in the exception handling. Therefore, the CI type is 0."
209,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,30,31,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,<android.app.UiAutomation: AccessibilityNodeInfo findFocus(int)>,0,"{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows you have to opt-in
 * to retrieve the interactive windows by setting the
 * {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS} flag.
 * Otherwise, the search will be performed only in the active window.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"There is a new block of code introduced with a control dependency change, which is the synchronized block that now prefaces the existing return statement. Additionally, an exception handling statement has been added within the synchronized block (`throwIfNotConnectedLocked()`), so the change type is 2,3.","The addition of `throwIfNotConnectedLocked()` within the `synchronized` block introduces a new potential exception throwing behavior when the connection is not established or valid. This means that the new version may throw an exception where the previous version would not, thus the CI type is 2."
211,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,30,31,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void onThreadPolicyViolation(ViolationInfo)>,0,"{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; penalty="" + info.mPenaltyMask);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    long now = SystemClock.uptimeMillis();
    if (sLogger == LOGCAT_LOGGER) {
        // Don't throttle it if there is a non-default logger
        if (mLastViolationTime != null) {
            Long vtime = mLastViolationTime.get(crashFingerprint);
            if (vtime != null) {
                lastViolationTime = vtime;
            }
            clampViolationTimeMap(mLastViolationTime, Math.max(MIN_LOG_INTERVAL_MS, Math.max(MIN_DIALOG_INTERVAL_MS, MIN_DROPBOX_INTERVAL_MS)));
        } else {
            mLastViolationTime = new ArrayMap<>(1);
        }
        mLastViolationTime.put(crashFingerprint, now);
    }
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // Penalties that ActivityManager should execute on our behalf.
    int penaltyMask = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        penaltyMask |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && timeSinceLastViolationMillis > MIN_DROPBOX_INTERVAL_MS) {
        penaltyMask |= PENALTY_DROPBOX;
    }
    if (penaltyMask != 0) {
        final boolean justDropBox = (info.mPenaltyMask == PENALTY_DROPBOX);
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(penaltyMask, info);
        } else {
            handleApplicationStrictModeViolation(penaltyMask, info);
        }
    }
    if (info.penaltyEnabled(PENALTY_DEATH)) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = StrictMode.allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}","{
    if (LOG_V)
        Log.d(TAG, ""onThreadPolicyViolation; penalty="" + info.mPenaltyMask);
    if (info.penaltyEnabled(PENALTY_GATHER)) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<>(1);
            gatheredViolations.set(violations);
        }
        for (ViolationInfo previous : violations) {
            if (info.getStackTrace().equals(previous.getStackTrace())) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    long now = SystemClock.uptimeMillis();
    if (sLogger == LOGCAT_LOGGER) {
        // Don't throttle it if there is a non-default logger
        if (mRealLastViolationTime != null) {
            Long vtime = mRealLastViolationTime.get(crashFingerprint);
            if (vtime != null) {
                lastViolationTime = vtime;
            }
            clampViolationTimeMap(mRealLastViolationTime, Math.max(MIN_LOG_INTERVAL_MS, Math.max(MIN_DIALOG_INTERVAL_MS, MIN_DROPBOX_INTERVAL_MS)));
        } else {
            mRealLastViolationTime = new SparseLongArray(1);
        }
        mRealLastViolationTime.put(crashFingerprint, now);
    }
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if (info.penaltyEnabled(PENALTY_LOG) && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        sLogger.log(info);
    }
    final Violation violation = info.mViolation;
    // Penalties that ActivityManager should execute on our behalf.
    int penaltyMask = 0;
    if (info.penaltyEnabled(PENALTY_DIALOG) && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        penaltyMask |= PENALTY_DIALOG;
    }
    if (info.penaltyEnabled(PENALTY_DROPBOX) && timeSinceLastViolationMillis > MIN_DROPBOX_INTERVAL_MS) {
        penaltyMask |= PENALTY_DROPBOX;
    }
    if (penaltyMask != 0) {
        final boolean justDropBox = (info.mPenaltyMask == PENALTY_DROPBOX);
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(penaltyMask, info);
        } else {
            handleApplicationStrictModeViolation(penaltyMask, info);
        }
    }
    if (info.penaltyEnabled(PENALTY_DEATH)) {
        throw new RuntimeException(""StrictMode ThreadPolicy violation"", violation);
    }
    // penaltyDeath will cause penaltyCallback to no-op since we cannot guarantee the
    // executor finishes before crashing.
    final OnThreadViolationListener listener = sThreadViolationListener.get();
    final Executor executor = sThreadViolationExecutor.get();
    if (listener != null && executor != null) {
        try {
            executor.execute(() -> {
                // Lift violated policy to prevent infinite recursion.
                ThreadPolicy oldPolicy = StrictMode.allowThreadViolations();
                try {
                    listener.onThreadViolation(violation);
                } finally {
                    StrictMode.setThreadPolicy(oldPolicy);
                }
            });
        } catch (RejectedExecutionException e) {
            Log.e(TAG, ""ThreadPolicy penaltyCallback failed"", e);
        }
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,,,,
212,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,30,31,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,0,"{
    if (mAttachInfo != null) {
        try {
            mAttachInfo.mSession.getDisplayFrame(mAttachInfo.mWindow, outRect);
        } catch (RemoteException e) {
            return;
        }
        // XXX This is really broken, and probably all needs to be done
        // in the window manager, and we need to know more about whether
        // we want the area behind or in front of the IME.
        final Rect insets = mAttachInfo.mVisibleInsets;
        outRect.left += insets.left;
        outRect.top += insets.top;
        outRect.right -= insets.right;
        outRect.bottom -= insets.bottom;
        return;
    }
    // The view is not attached to a display so we don't have a context.
    // Make a best guess about the display size.
    Display d = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    d.getRectSize(outRect);
}","{
    if (mAttachInfo != null) {
        mAttachInfo.mViewRootImpl.getWindowVisibleDisplayFrame(outRect);
        return;
    }
    // The view is not attached to a display so we don't have a context.
    // Make a best guess about the display size.
    Display d = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    d.getRectSize(outRect);
}",1,"/**
 * Retrieve the overall visible display size in which the window this view is
 * attached to has been positioned in.  This takes into account screen
 * decorations above the window, for both cases where the window itself
 * is being position inside of them or the window is being placed under
 * then and covered insets are used for the window to position its content
 * inside.  In effect, this tells you the available area where content can
 * be placed and remain visible to users.
 *
 * <p>This function requires an IPC back to the window manager to retrieve
 * the requested information, so should not be used in performance critical
 * code like drawing.
 *
 * @param outRect Filled in with the visible display frame.  If the view
 * is not attached to a window, this is simply the raw display size.
 */
","/**
 * Retrieve the overall visible display size in which the window this view is
 * attached to has been positioned in.  This takes into account screen
 * decorations above the window, for both cases where the window itself
 * is being position inside of them or the window is being placed under
 * then and covered insets are used for the window to position its content
 * inside.  In effect, this tells you the available area where content can
 * be placed and remain visible to users.
 *
 * @param outRect Filled in with the visible display frame.  If the view
 * is not attached to a window, this is simply the raw display size.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only statement that has been changed is mAttachInfo.mSession.getDisplayFrame(mAttachInfo.mWindow, outRect); replaced with mAttachInfo.mViewRootImpl.getWindowVisibleDisplayFrame(outRect); which is the change in a dependent API call, so the code change type is 5.","Despite the change in the dependent API call, the method's functionality appears to stay consistent, i.e., updating the passed Rect to represent the display frame. There's no change in the method signature or return type, and no new control paths or exceptions introduced that suggest different behavior from an external perspective. As long as the new internal call to getWindowVisibleDisplayFrame(outRect) is expected to set the outRect the same way as the previous implementation, there shouldn't be a compatibility issue, so the CI type is 0."
213,<android.view.DragAndDropPermissions: void release()>,30,31,<android.view.DragAndDropPermissions: void release()>,<android.view.DragAndDropPermissions: void release()>,0,"{
    try {
        mDragAndDropPermissions.release();
        mTransientToken = null;
    } catch (RemoteException e) {
    }
}","{
    try {
        mDragAndDropPermissions.release();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Revoke permissions explicitly.
 */
","/**
 * Revoke permissions explicitly.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The exception handling statement changed since a new `throw` statement has been introduced (throw e.rethrowFromSystemServer()), and there is a deletion of the statement `mTransientToken = null;`, leading to the change type being 2,4.","The introduction of a new exception handling mechanism can change the contract of an API, as it can potentially lead to a different exception being thrown by the API, which is a change of exception handling behavior. Thus, the CI type is 2."
214,<android.bluetooth.BluetoothAdapter: void finalize()>,30,31,<android.bluetooth.BluetoothAdapter: void finalize()>,<android.bluetooth.BluetoothAdapter: void finalize()>,0,"{
    try {
        mManagerService.unregisterAdapter(mManagerCallback);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        super.finalize();
    }
}","{
    try {
        removeServiceStateCallback(mManagerCallback);
    } finally {
        super.finalize();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called within the try block has changed from mManagerService.unregisterAdapter(mManagerCallback) to removeServiceStateCallback(mManagerCallback). Additionally, the associated catch block for RemoteException has been removed. This results in a change type 4 (Other statement changed) and 5 (Dependent API changed), since the method invocation has been modified to a different method.","Despite the method invoked within the try block changing, there is no indication of a difference in return variable type or value (since the method is 'void' and doesn't return any value) and no difference in exception handling (because the removal of the catch block for RemoteException wouldn't cause a change in behavior since it's the finalization method and exceptions from finalize are ignored by the garbage collector). Therefore, there is no Compatibility Issue as per the provided definitions, which results in type 0 (No Compatibility Issue)."
216,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,30,31,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,<android.app.UiAutomation: void setRunAsMonkey(boolean)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        ActivityManager.getService().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}","{
    try {
        ActivityManager.getService().setUserIsMonkey(enable);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while setting run as monkey!"", re);
    }
}",1,"/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
","/**
 * Sets whether this UiAutomation to run in a ""monkey"" mode. Applications can query whether
 * they are executed in a ""monkey"" mode, i.e. run by a test framework, and avoid doing
 * potentially undesirable actions such as calling 911 or posting on public forums etc.
 *
 * @param enable whether to run in a ""monkey"" mode or not. Default is not.
 * @see ActivityManager#isUserAMonkey()
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control statement (synchronized block) has been removed, so the code change type is 3.","Although the synchronized block has been removed, the behavior of the API method itself (in terms of returned value or exception it throws) is not altered. The removal of the synchronized block might affect thread-safety, but that does not constitute a compatibility issue based on the given definition. Therefore, there is no compatibility issue, and CI type is 0."
217,<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(BluetoothDevice)>,<android.bluetooth.BluetoothHeadset: boolean startVoiceRecognition(BluetoothDevice)>,0,"{
    if (DBG)
        log(""startVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (DBG)
        log(""startVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Start Bluetooth voice recognition. This methods sends the voice
 * recognition AT command to the headset and establishes the
 * audio connection.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected, or the connected headset doesn't support
 * voice recognition, or voice recognition is already started, or audio channel is occupied,
 * or on error, true otherwise
 */
","/**
 * Start Bluetooth voice recognition. This methods sends the voice
 * recognition AT command to the headset and establishes the
 * audio connection.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected, or the connected headset doesn't support
 * voice recognition, or voice recognition is already started, or audio channel is occupied,
 * or on error, true otherwise
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(allOf = { android.Manifest.permission.BLUETOOTH_CONNECT, android.Manifest.permission.MODIFY_PHONE_STATE })]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation change is the addition of the `mAttributionSource` argument to the `service.startVoiceRecognition(device)` method call. This is an other statement change as it changes how the method is called, and it is a dependent API change since it modifies the parameters of the method being called. Therefore, the code change types are 4,5.","There's no Compatibility Issue detected as the behavior of `startVoiceRecognition` should not be altered just by the addition of an AttributionSource object to the service call - it is intended to provide additional context for the call, not change its behavior. The value returned by the call remains dependent on the external service and the boolean conditions of the if-statement guard have not been modified. Thus, the change does not directly affect what the API returns or the exceptions it might throw."
218,<android.view.VerifiedMotionEvent: boolean equals(Object)>,30,31,<android.view.VerifiedMotionEvent: boolean equals(Object)>,<android.view.VerifiedMotionEvent: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") VerifiedMotionEvent that = (VerifiedMotionEvent) o;
    // noinspection PointlessBooleanExpression
    return true && getDeviceId() == that.getDeviceId() && getEventTimeNanos() == that.getEventTimeNanos() && getSource() == that.getSource() && getDisplayId() == that.getDisplayId() && mRawX == that.mRawX && mRawY == that.mRawY && mActionMasked == that.mActionMasked && mDownTimeNanos == that.mDownTimeNanos && mFlags == that.mFlags && mMetaState == that.mMetaState && mButtonState == that.mButtonState;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") VerifiedMotionEvent that = (VerifiedMotionEvent) o;
    // noinspection PointlessBooleanExpression
    return true && super.equals(that) && mRawX == that.mRawX && mRawY == that.mRawY && mActionMasked == that.mActionMasked && mDownTimeNanos == that.mDownTimeNanos && mFlags == that.mFlags && mMetaState == that.mMetaState && mButtonState == that.mButtonState;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, specifically removing direct checks on the device ID, event time, source, and display ID, and replacing it with a call to super.equals(that). There is also a dependent API change as the method now depends on the implementation of equals in the superclass, so the code change types are 1,5.","The modification in the return statement can potentially lead to different outcomes of the equals method between versions because of relying on the superclass implementation. Hence, the behaviour of the API could lead to different equality checks on the given object, and the CI type is 1."
219,"<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>",30,31,"<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>","<android.bluetooth.BluetoothHidDevice: boolean sendReport(BluetoothDevice,int,byte[])>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.sendReport(device, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.sendReport(device, id, data, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends report to remote host using interrupt channel.
 *
 * @param id Report Id, as defined in descriptor. Can be 0 in case Report Id are not defined in
 * descriptor.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends report to remote host using interrupt channel.
 *
 * @param id Report Id, as defined in descriptor. Can be 0 in case Report Id are not defined in
 * descriptor.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The code has changed in the sense that an additional parameter `mAttributionSource` is being passed to the method `service.sendReport`. This change falls under the category of 'Other statement changed' since the logic and flow of the method have not been altered, and no new control structures were introduced. Moreover, the 'Dependent API changed', as the dependent method `sendReport` from `IBluetoothHidDevice` now expects an additional parameter.","There is no Compatibility Issue because the changes do not affect the behavior of the `sendReport` method from the perspective of the client code using this API. The additional parameter `mAttributionSource` is handled internally and does not impose any new requirements or behavior changes on the existing method contract; it does not alter the return type, value, or exceptions that might be thrown. Thus, the API maintains backward compatibility."
220,"<android.view.inputmethod.BaseInputConnection: boolean commitContent(InputContentInfo,int,Bundle)>",30,31,"<android.view.inputmethod.BaseInputConnection: boolean commitContent(InputContentInfo,int,Bundle)>","<android.view.inputmethod.BaseInputConnection: boolean commitContent(InputContentInfo,int,Bundle)>",0,"{
    return false;
}","{
    ClipDescription description = inputContentInfo.getDescription();
    if (mTargetView.getReceiveContentMimeTypes() == null) {
        if (DEBUG) {
            Log.d(TAG, ""Can't insert content from IME: content="" + description);
        }
        return false;
    }
    if ((flags & InputConnection.INPUT_CONTENT_GRANT_READ_URI_PERMISSION) != 0) {
        try {
            inputContentInfo.requestPermission();
        } catch (Exception e) {
            Log.w(TAG, ""Can't insert content from IME; requestPermission() failed"", e);
            return false;
        }
    }
    final ClipData clip = new ClipData(inputContentInfo.getDescription(), new ClipData.Item(inputContentInfo.getContentUri()));
    final ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_INPUT_METHOD).setLinkUri(inputContentInfo.getLinkUri()).setExtras(opts).setInputContentInfo(inputContentInfo).build();
    return mTargetView.performReceiveContent(payload) == null;
}",1,"/**
 * The default implementation does nothing.
 */
","/**
 * Default implementation which invokes {@link View#performReceiveContent} on the target
 * view if the view {@link View#getReceiveContentMimeTypes allows} content insertion;
 * otherwise returns false without any side effects.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The late version adds several new statements including checks, log messages, permission requests, and a complex return statement. These changes include return statement changed, exception handling statement changed, control dependency changed, and other statement changed, so the code change type is 1,2,3,4.","The early version always returns false, while the late version includes conditional logic that could return either true or false and also handles exceptions differently. This leads to a CI due to potentially different return values or types (CI type 1) and different exception handlings (CI type 2)."
221,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegistration()>,30,31,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegistration()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void startRegistration()>,0,"{
    synchronized (this) {
        // Scan stopped.
        if (mScannerId == -1 || mScannerId == -2)
            return;
        try {
            mBluetoothGatt.registerScanner(this, mWorkSource);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mScannerId > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            // subsequent operations can proceed.
            if (mScannerId == 0)
                mScannerId = -1;
            // If scanning too frequently, don't report anything to the app.
            if (mScannerId == -2)
                return;
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}","{
    synchronized (this) {
        // Scan stopped.
        if (mScannerId == -1 || mScannerId == -2)
            return;
        try {
            mBluetoothGatt.registerScanner(this, mWorkSource, mAttributionSource);
            wait(REGISTRATION_CALLBACK_TIMEOUT_MILLIS);
        } catch (InterruptedException | RemoteException e) {
            Log.e(TAG, ""application registeration exception"", e);
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_INTERNAL_ERROR);
        }
        if (mScannerId > 0) {
            mLeScanClients.put(mScanCallback, this);
        } else {
            // subsequent operations can proceed.
            if (mScannerId == 0)
                mScannerId = -1;
            // If scanning too frequently, don't report anything to the app.
            if (mScannerId == -2)
                return;
            postCallbackError(mScanCallback, ScanCallback.SCAN_FAILED_APPLICATION_REGISTRATION_FAILED);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API mBluetoothGatt.registerScanner() is called with an additional parameter in the late version (mAttributionSource), therefore the change type is 5.","There is no apparent compatibility issue caused by this change, assuming that the new parameter does not alter the behavior of the method in an incompatible way. The method still handles exceptions and conditions in the same way and registers the scanner with the same logic, except for the addition of handling the mAttributionSource. Thus, the CI type is 0."
222,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",30,31,"<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentResolver: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, extras, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.refresh(url, extras, cancellationSignal);
    } catch (RemoteException e) {
        return false;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return false;
    }
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = provider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return provider.refresh(mContext.getAttributionSource(), url, extras, remoteCancellationSignal);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return false;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
","/**
 * This allows clients to request an explicit refresh of content identified
 * by {@code uri}.
 * <p>
 * Client code should only invoke this method when there is a strong
 * indication (such as a user initiated pull to refresh gesture) that the
 * content is stale.
 * <p>
 *
 * @param url The Uri identifying the data to refresh.
 * @param extras Additional options from the client. The definitions of
 * these are specific to the content provider being called.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or {@code null} if none. For example, if you called refresh on
 * a particular uri, you should call
 * {@link CancellationSignal#throwIfCanceled()} to check whether
 * the client has canceled the refresh request.
 * @return true if the provider actually tried refreshing.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change is within the provider.refresh method call, where mPackageName, mAttributionTag is replaced with mContext.getAttributionSource(), therefore, the code change type is 5 due to the change in the dependent API.","There should be no Compatibility Issue because of the change as both mContext.getAttributionSource() and the removed mPackageName, mAttributionTag would provide the necessary attribution information for the refresh operation without changing the return value or the exception handling of the method. Thus, there's no change causing potential different return values or different exception handling."
223,"<android.speech.tts.TextToSpeech: int addEarcon(String,String)>",30,31,"<android.speech.tts.TextToSpeech: int addEarcon(String,String)>","<android.speech.tts.TextToSpeech: int addEarcon(String,String)>",0,"{
    synchronized (mStartLock) {
        mEarcons.put(earcon, Uri.parse(filename));
        return SUCCESS;
    }
}","{
    return addEarcon(earcon, Uri.parse(filename));
}",1,"/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/tick.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 *
 * @deprecated As of API level 21, replaced by
 * {@link #addEarcon(String, File)}.
 */
","/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/tick.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 *
 * @deprecated As of API level 21, replaced by
 * {@link #addEarcon(String, File)}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The late implementation calls another overload of the method addEarcon, so this is a dependent API change. However, there is no change in the control flow or exception handling, the synchronization block has been removed but since it's not specified that the dependent method is synchronized or not, we assume it's a direct method call replacement, thus it looks like an ""Other statement changed"".","There are no apparent changes that could lead to a different return value or throw a new exception. The dependent method is assumed to preserve the original method's contract, thus ensuring compatibility; hence, no compatibility issue is expected (0)."
225,"<android.content.ContentProviderClient: int delete(Uri,Bundle)>",30,31,"<android.content.ContentProviderClient: int delete(Uri,Bundle)>","<android.content.ContentProviderClient: int delete(Uri,Bundle)>",0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, mAttributionTag, url, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.delete(mAttributionSource, url, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter passed to the `mContentProvider.delete` method has been changed from `(mPackageName, mAttributionTag, url, extras)` to `(mAttributionSource, url, extras)`. Since this is a change in the method call parameter's list, the code change type is 4 for the changed statement, and 5 because it affects a dependent API.","Although the parameters for the delete method call have changed, this is an internal implementation detail, and as long as the `delete` method on `mContentProvider` is expected to behave the same way with respect to the new `mAttributionSource` parameter (which is a bundle of information including what was previously passed as separate `mPackageName` and `mAttributionTag`), there is no change in the return statement or exception handling on the surface level. We do not have evidence that changing the parameter will lead to different returns or exceptions based on what is provided. Therefore, there is no compatibility issue detected in terms of return value or exception handling, and the pred_CI is 0."
226,<android.content.pm.ShortcutManager: void enableShortcuts(List<String>)>,30,31,<android.content.pm.ShortcutManager: void enableShortcuts(List<String>)>,<android.content.pm.ShortcutManager: void enableShortcuts(List<String>)>,0,"{
    try {
        mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
 * are already enabled, this method does nothing.
 *
 * @throws IllegalArgumentException If trying to enable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
 * are already enabled, this method does nothing.
 *
 * @throws IllegalArgumentException If trying to enable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change consists of wrapping the call to mService.enableShortcuts with a getFutureOrThrow() method, instead of directly invoking mService.enableShortcuts() within the try block. The dependent API mService.enableShortcuts() does not change its arguments but the method it's used with has changed; thus, the change type is 4,5 (Other statement changed, Dependent API changed).","The wrapping of the API call with the getFutureOrThrow() method does not change the method's signature nor the expected behavior in terms of return value or exceptions; RemoteException is still thrown the same way it was. Therefore, there's no compatibility issue; hence the CI type is 0."
227,"<android.provider.Settings.NameValueCache: ArrayMap<String, String> getStringsForPrefix(ContentResolver,String,List<String>)>",30,31,"<android.provider.Settings.NameValueCache: ArrayMap<String, String> getStringsForPrefix(ContentResolver,String,List<String>)>","<android.provider.Settings.NameValueCache: ArrayMap<String, String> getStringsForPrefix(ContentResolver,String,List<String>)>",0,"{
    String namespace = prefix.substring(0, prefix.length() - 1);
    DeviceConfig.enforceReadPermission(ActivityThread.currentApplication(), namespace);
    ArrayMap<String, String> keyValues = new ArrayMap<>();
    int currentGeneration = -1;
    synchronized (NameValueCache.this) {
        if (mGenerationTracker != null) {
            if (mGenerationTracker.isGenerationChanged()) {
                if (DEBUG) {
                    Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName());
                }
                mValues.clear();
            } else {
                boolean prefixCached = mValues.containsKey(prefix);
                if (prefixCached) {
                    if (!names.isEmpty()) {
                        for (String name : names) {
                            if (mValues.containsKey(name)) {
                                keyValues.put(name, mValues.get(name));
                            }
                        }
                    } else {
                        for (int i = 0; i < mValues.size(); ++i) {
                            String key = mValues.keyAt(i);
                            // signal that the prefix has been cached.
                            if (key.startsWith(prefix) && !key.equals(prefix)) {
                                keyValues.put(key, mValues.get(key));
                            }
                        }
                    }
                    return keyValues;
                }
            }
            if (mGenerationTracker != null) {
                currentGeneration = mGenerationTracker.getCurrentGeneration();
            }
        }
    }
    if (mCallListCommand == null) {
        // No list command specified, return empty map
        return keyValues;
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    try {
        Bundle args = new Bundle();
        args.putString(Settings.CALL_METHOD_PREFIX_KEY, prefix);
        boolean needsGenerationTracker = false;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker == null) {
                needsGenerationTracker = true;
                args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                if (DEBUG) {
                    Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName());
                }
            }
        }
        // Fetch all flags for the namespace at once for caching purposes
        Bundle b = cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallListCommand, null, args);
        if (b == null) {
            // Invalid response, return an empty map
            return keyValues;
        }
        // All flags for the namespace
        Map<String, String> flagsToValues = (HashMap) b.getSerializable(Settings.NameValueTable.VALUE);
        // Only the flags requested by the caller
        if (!names.isEmpty()) {
            for (Map.Entry<String, String> flag : flagsToValues.entrySet()) {
                if (names.contains(flag.getKey())) {
                    keyValues.put(flag.getKey(), flag.getValue());
                }
            }
        } else {
            keyValues.putAll(flagsToValues);
        }
        synchronized (NameValueCache.this) {
            if (needsGenerationTracker) {
                MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                if (array != null && index >= 0) {
                    final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                    if (DEBUG) {
                        Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" with index:"" + index);
                    }
                    if (mGenerationTracker != null) {
                        mGenerationTracker.destroy();
                    }
                    mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                        synchronized (NameValueCache.this) {
                            Log.e(TAG, ""Error accessing generation tracker"" + "" - removing"");
                            if (mGenerationTracker != null) {
                                GenerationTracker generationTracker = mGenerationTracker;
                                mGenerationTracker = null;
                                generationTracker.destroy();
                                mValues.clear();
                            }
                        }
                    });
                    currentGeneration = generation;
                }
            }
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                // cache the complete list of flags for the namespace
                mValues.putAll(flagsToValues);
                // Adding the prefix as a signal that the prefix is cached.
                mValues.put(prefix, null);
            }
        }
        return keyValues;
    } catch (RemoteException e) {
        // Not supported by the remote side, return an empty map
        return keyValues;
    }
}","{
    String namespace = prefix.substring(0, prefix.length() - 1);
    DeviceConfig.enforceReadPermission(ActivityThread.currentApplication(), namespace);
    ArrayMap<String, String> keyValues = new ArrayMap<>();
    int currentGeneration = -1;
    synchronized (NameValueCache.this) {
        if (mGenerationTracker != null) {
            if (mGenerationTracker.isGenerationChanged()) {
                if (DEBUG) {
                    Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName());
                }
                mValues.clear();
            } else {
                boolean prefixCached = mValues.containsKey(prefix);
                if (prefixCached) {
                    if (!names.isEmpty()) {
                        for (String name : names) {
                            if (mValues.containsKey(name)) {
                                keyValues.put(name, mValues.get(name));
                            }
                        }
                    } else {
                        for (int i = 0; i < mValues.size(); ++i) {
                            String key = mValues.keyAt(i);
                            // signal that the prefix has been cached.
                            if (key.startsWith(prefix) && !key.equals(prefix)) {
                                keyValues.put(key, mValues.get(key));
                            }
                        }
                    }
                    return keyValues;
                }
            }
            if (mGenerationTracker != null) {
                currentGeneration = mGenerationTracker.getCurrentGeneration();
            }
        }
    }
    if (mCallListCommand == null) {
        // No list command specified, return empty map
        return keyValues;
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    try {
        Bundle args = new Bundle();
        args.putString(Settings.CALL_METHOD_PREFIX_KEY, prefix);
        boolean needsGenerationTracker = false;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker == null) {
                needsGenerationTracker = true;
                args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                if (DEBUG) {
                    Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName());
                }
            }
        }
        // Fetch all flags for the namespace at once for caching purposes
        Bundle b = cp.call(cr.getAttributionSource(), mProviderHolder.mUri.getAuthority(), mCallListCommand, null, args);
        if (b == null) {
            // Invalid response, return an empty map
            return keyValues;
        }
        // All flags for the namespace
        Map<String, String> flagsToValues = (HashMap) b.getSerializable(Settings.NameValueTable.VALUE);
        // Only the flags requested by the caller
        if (!names.isEmpty()) {
            for (Map.Entry<String, String> flag : flagsToValues.entrySet()) {
                if (names.contains(flag.getKey())) {
                    keyValues.put(flag.getKey(), flag.getValue());
                }
            }
        } else {
            keyValues.putAll(flagsToValues);
        }
        synchronized (NameValueCache.this) {
            if (needsGenerationTracker) {
                MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                if (array != null && index >= 0) {
                    final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                    if (DEBUG) {
                        Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" with index:"" + index);
                    }
                    if (mGenerationTracker != null) {
                        mGenerationTracker.destroy();
                    }
                    mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                        synchronized (NameValueCache.this) {
                            Log.e(TAG, ""Error accessing generation tracker"" + "" - removing"");
                            if (mGenerationTracker != null) {
                                GenerationTracker generationTracker = mGenerationTracker;
                                mGenerationTracker = null;
                                generationTracker.destroy();
                                mValues.clear();
                            }
                        }
                    });
                    currentGeneration = generation;
                }
            }
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                // cache the complete list of flags for the namespace
                mValues.putAll(flagsToValues);
                // Adding the prefix as a signal that the prefix is cached.
                mValues.put(prefix, null);
            }
        }
        return keyValues;
    } catch (RemoteException e) {
        // Not supported by the remote side, return an empty map
        return keyValues;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
228,<android.content.ContentProvider: String getCallingAttributionTag()>,30,31,<android.content.ContentProvider: String getCallingAttributionTag()>,<android.content.ContentProvider: String getCallingAttributionTag()>,0,"{
    final Pair<String, String> pkg = mCallingPackage.get();
    if (pkg != null) {
        return pkg.second;
    }
    return null;
}","{
    final AttributionSource attributionSource = mCallingAttributionSource.get();
    if (attributionSource != null) {
        return attributionSource.getAttributionTag();
    }
    return null;
}",1,"/**
 * Return the attribution tag of the caller that initiated the request being
 * processed on the current thread. Returns {@code null} if not currently processing
 * a request of the request is for the default attribution.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see #getCallingPackage
 */
","/**
 * Return the attribution tag of the caller that initiated the request being
 * processed on the current thread. Returns {@code null} if not currently processing
 * a request of the request is for the default attribution.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see #getCallingPackage
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The code changed its internal variable from a Pair object (mCallingPackage) to an AttributionSource object (mCallingAttributionSource), and the corresponding method from accessing the second element of the Pair to getting the attribution tag via getAttributionTag(). Hence, the change type is 5.","There is no compatibility issue as the method's signature, return type, and the returned variable have remained consistent, even though the underlying implementation has been modified to adapt to a new way of managing the calling attribution. Both versions return a String object or null. The annotations regarding nullability (@Nullable) also remained unchanged."
229,<android.view.inputmethod.InlineSuggestionsRequest: boolean equals(Object)>,30,31,<android.view.inputmethod.InlineSuggestionsRequest: boolean equals(Object)>,<android.view.inputmethod.InlineSuggestionsRequest: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestionsRequest that = (InlineSuggestionsRequest) o;
    // noinspection PointlessBooleanExpression
    return true && mMaxSuggestionCount == that.mMaxSuggestionCount && java.util.Objects.equals(mInlinePresentationSpecs, that.mInlinePresentationSpecs) && java.util.Objects.equals(mHostPackageName, that.mHostPackageName) && java.util.Objects.equals(mSupportedLocales, that.mSupportedLocales) && extrasEquals(that.mExtras) && java.util.Objects.equals(mHostInputToken, that.mHostInputToken) && mHostDisplayId == that.mHostDisplayId;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestionsRequest that = (InlineSuggestionsRequest) o;
    // noinspection PointlessBooleanExpression
    return true && mMaxSuggestionCount == that.mMaxSuggestionCount && java.util.Objects.equals(mInlinePresentationSpecs, that.mInlinePresentationSpecs) && java.util.Objects.equals(mHostPackageName, that.mHostPackageName) && java.util.Objects.equals(mSupportedLocales, that.mSupportedLocales) && extrasEquals(that.mExtras) && java.util.Objects.equals(mHostInputToken, that.mHostInputToken) && mHostDisplayId == that.mHostDisplayId && java.util.Objects.equals(mInlineTooltipPresentationSpec, that.mInlineTooltipPresentationSpec);
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"An additional condition (java.util.Objects.equals(mInlineTooltipPresentationSpec, that.mInlineTooltipPresentationSpec)) is added to the return statement, which is a logical statement change, so the change type is 1,4.","By adding a new comparison for 'mInlineTooltipPresentationSpec' in the return statement, this changes the behavior of the equals method to include an additional property in its equality check. Therefore, previous instances of the class that were considered equal might no longer be equal if their 'mInlineTooltipPresentationSpec' properties differ, leading to a different return value and potentially a Compatibility Issue of type 1."
232,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,30,31,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,0,"{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors, mDisplay.getDisplayId());
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}","{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors, mDisplay.getDisplayId());
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
        resetWindowPages();
        processLocalColors(mPendingXOffset, mPendingXOffsetStep);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}",1,"/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
","/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The introduction of two new method calls, resetWindowPages() and processLocalColors(mPendingXOffset, mPendingXOffsetStep), represents ""Other statement changed"", so the code change type is 4.","The new methods calls do not seem to affect the return value or exception handling of the notifyColorsChanged() method directly as they are not involved in modifying what gets returned or the exceptions being caught or thrown. Without any evidence that they change the behavior with respect to the output or exception handling, there is no Compatibility Issue detected, so the CI type is 0."
233,"<android.app.ResourcesManager.UpdateHandler: void onLoadersChanged(Resources,List<ResourcesLoader>)>",30,31,"<android.app.ResourcesManager.UpdateHandler: void onLoadersChanged(Resources,List<ResourcesLoader>)>","<android.app.ResourcesManager.UpdateHandler: void onLoadersChanged(Resources,List<ResourcesLoader>)>",0,"{
    synchronized (ResourcesManager.this) {
        final ResourcesKey oldKey = findKeyForResourceImplLocked(resources.getImpl());
        if (oldKey == null) {
            throw new IllegalArgumentException(""Cannot modify resource loaders of"" + "" ResourcesImpl not registered with ResourcesManager"");
        }
        final ResourcesKey newKey = new ResourcesKey(oldKey.mResDir, oldKey.mSplitResDirs, oldKey.mOverlayDirs, oldKey.mLibDirs, oldKey.mDisplayId, oldKey.mOverrideConfiguration, oldKey.mCompatInfo, newLoader.toArray(new ResourcesLoader[0]));
        final ResourcesImpl impl = findOrCreateResourcesImplForKeyLocked(newKey);
        resources.setImpl(impl);
    }
}","{
    synchronized (mLock) {
        final ResourcesKey oldKey = findKeyForResourceImplLocked(resources.getImpl());
        if (oldKey == null) {
            throw new IllegalArgumentException(""Cannot modify resource loaders of"" + "" ResourcesImpl not registered with ResourcesManager"");
        }
        final ResourcesKey newKey = new ResourcesKey(oldKey.mResDir, oldKey.mSplitResDirs, oldKey.mOverlayPaths, oldKey.mLibDirs, oldKey.mDisplayId, oldKey.mOverrideConfiguration, oldKey.mCompatInfo, newLoader.toArray(new ResourcesLoader[0]));
        final ResourcesImpl impl = findOrCreateResourcesImplForKeyLocked(newKey);
        resources.setImpl(impl);
    }
}",1,"/**
 * Updates the list of {@link ResourcesLoader ResourcesLoader(s)} that the {@code resources}
 * instance uses.
 */
","/**
 * Updates the list of {@link ResourcesLoader ResourcesLoader(s)} that the {@code resources}
 * instance uses.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a change in one of the constructor parameters: `oldKey.mOverlayDirs` has been changed to `oldKey.mOverlayPaths`. Since this is a change in a variable name, but not a new introduction or deletion of a method, or a modification to the method signature, the change type is 4.","The change in the variable name does not impact the method's behavior from the perspective of an API consumer. Internal renaming of variables should not cause compatibility issues provided that the underlying type and semantics haven't changed, which isn't indicated based on the information provided. Thus, the CI type is 0."
234,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,30,31,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,<android.app.ActivityTransitionState: boolean startExitBackTransition(Activity)>,0,"{
    ArrayList<String> pendingExitNames = getPendingExitNames();
    if (pendingExitNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(activity, activity.getWindow(), activity.mEnterTransitionListener, pendingExitNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                OneShotPreDrawListener.add(decor, () -> {
                    if (mReturnExitCoordinator != null) {
                        mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity.mResultCode, activity.mResultData);
            }
        }
        return true;
    }
}","{
    ArrayList<String> pendingExitNames = getPendingExitNames();
    if (pendingExitNames == null || mCalledExitCoordinator != null) {
        return false;
    } else {
        if (!mHasExited) {
            mHasExited = true;
            Transition enterViewsTransition = null;
            ViewGroup decor = null;
            boolean delayExitBack = false;
            if (mEnterTransitionCoordinator != null) {
                enterViewsTransition = mEnterTransitionCoordinator.getEnterViewsTransition();
                decor = mEnterTransitionCoordinator.getDecor();
                delayExitBack = mEnterTransitionCoordinator.cancelEnter();
                mEnterTransitionCoordinator = null;
                if (enterViewsTransition != null && decor != null) {
                    enterViewsTransition.pause(decor);
                }
            }
            mReturnExitCoordinator = new ExitTransitionCoordinator(new ExitTransitionCoordinator.ActivityExitTransitionCallbacks(activity), activity.getWindow(), activity.mEnterTransitionListener, pendingExitNames, null, null, true);
            if (enterViewsTransition != null && decor != null) {
                enterViewsTransition.resume(decor);
            }
            if (delayExitBack && decor != null) {
                final ViewGroup finalDecor = decor;
                OneShotPreDrawListener.add(decor, () -> {
                    if (mReturnExitCoordinator != null) {
                        mReturnExitCoordinator.startExit(activity);
                    }
                });
            } else {
                mReturnExitCoordinator.startExit(activity);
            }
        }
        return true;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The changes in the code involve the creation of a new `ExitTransitionCoordinator` object with a different constructor parameter and the arguments of the `startExit` method in the if-else branch at the bottom of the block. This is considered an 'Other statement changed' since it's neither a return statement, an exception handling statement, nor a control dependency change. It is also a 'Dependent API changed' because the `ExitTransitionCoordinator` constructor and `startExit` method signatures have changed.","The modification of the `ExitTransitionCoordinator` constructor parameters and the changes to the method signature of `startExit` indicate that the method relies on a different set of data, which could alter its behavior and hence lead to compatibility issues in terms of potential different return values or types."
236,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void updateScores(List<ScoredNetwork>)>,30,31,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void updateScores(List<ScoredNetwork>)>,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void updateScores(List<ScoredNetwork>)>,0,"{
    Binder.clearCallingIdentity();
    mExecutor.execute(() -> {
        mCallback.onScoresUpdated(networks);
    });
}","{
    final long token = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onScoresUpdated(networks);
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",2,"The late version added a try-finally block for managing the Binder's calling identity which means there was an addition of token variable usage for restoring the calling identity. So, changes include an exception handling statement for restoring identity and the usage of a new variable (token); the change types are 2 and 4.","The added try-finally block does not change the outward behavior of the API in terms of returned values. However, the behavior in the event of an exception has changed â€“ previously the calling identity may not have been properly restored upon an exception, but with the late version, it always will be. This means the late version of the API will potentially handle exceptions differently, so the CI type is 2."
237,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,30,31,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,<android.view.textclassifier.TextClassificationSession: TextLanguage detectLanguage(Request)>,0,"{
    checkDestroyed();
    return mDelegate.detectLanguage(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.detectLanguage(request));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation wraps the call mDelegate.detectLanguage(request) with checkDestroyedAndRun rather than calling checkDestroyed separately. This means that the method call itself relies on a different, possibly new, implementation of checkDestroyedAndRun which can handle the destroyed state differently. However, the actual logic of detectLanguage remains unchanged because it still eventually delegates to mDelegate.detectLanguage(request). So, the code change type is 5 (Dependent API changed).","There is no Compatibility Issue here since the modify having no impact on the return values or exceptions. The wrapping function is presumably an internal utility to check the destroyed state and then execute the given lambda if it's not destroyed. This does not change the value returned by detectLanguage nor the exceptions it may throw, assuming that checkDestroyedAndRun exhibits the same behavior externally as the combination of checkDestroyed and the call to detectLanguage. Thus, the change does not introduce a difference in behavior that would affect API consumers."
238,<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onVirtualCableUnplug(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onVirtualCableUnplug(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onVirtualCableUnplug(BluetoothDevice)>,0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onVirtualCableUnplug(device));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onVirtualCableUnplug(device));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The changes include the introduction of a new method call 'setAttributionSource' on the device and wrapping the existing executor code within a try-finally block to include 'clearCallingIdentity' and 'restoreCallingIdentity' to manage security context correctly. So the change type is 3 for the introduction of the new try-finally block control structure, and 4 for the call added to 'setAttributionSource'.","Despite the changes in the implementation details with respect to security context, the overall functionality of the method with respect to what the method returns (which is void) and the exceptions it might throw remains the same. It does not cause any change in the behavior observable by the caller related to return values or exceptions, hence there's no Compatibility Issue, indicated by 0."
239,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,30,31,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_SCALE:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    mConnection.onWallpaperColorsChanged(mEngine.onComputeColors(), mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                Engine engine = onCreateEngine();
                mEngine = engine;
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    engine.detach();
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_ZOOM:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_SCALE_PREVIEW:
            mEngine.scalePreview((Rect) message.obj);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    WallpaperColors colors = mEngine.onComputeColors();
                    mEngine.setPrimaryWallpaperColors(colors);
                    mConnection.onWallpaperColorsChanged(colors, mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
241,<android.app.AutomaticZenRule: String toString()>,30,31,<android.app.AutomaticZenRule: String toString()>,<android.app.AutomaticZenRule: String toString()>,0,"{
    return new StringBuilder(AutomaticZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",name="").append(name).append("",interruptionFilter="").append(interruptionFilter).append("",conditionId="").append(conditionId).append("",owner="").append(owner).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",mZenPolicy="").append(mZenPolicy).append(']').toString();
}","{
    return new StringBuilder(AutomaticZenRule.class.getSimpleName()).append('[').append(""enabled="").append(enabled).append("",name="").append(name).append("",interruptionFilter="").append(interruptionFilter).append("",pkg="").append(mPkg).append("",conditionId="").append(conditionId).append("",owner="").append(owner).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",mZenPolicy="").append(mZenPolicy).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString() method has changed in the structure of the StringBuilder construction. It now includes ""pkg="" concatenated with mPkg instead of ""owner="" concatenated with owner. There's also an addition or change in variable name; ""configActivity"" to ""configurationActivity"". These changes fall under the category ""Other statement changed"" and since the method's return is based on a StringBuilder that now has different content, it's also considered under the category ""Return statement changed"".","The changes that have been made to the toString method will result in it returning a different string, representing different information. Any caller expecting a specific format or content could face issues. This is a potential compatibility issue caused by potentially different return values (CI type 1)."
244,<android.app.Activity: void setImmersive(boolean)>,30,31,<android.app.Activity: void setImmersive(boolean)>,<android.app.Activity: void setImmersive(boolean)>,0,"{
    try {
        ActivityTaskManager.getService().setImmersive(mToken, i);
    } catch (RemoteException e) {
    // pass
    }
}","{
    ActivityClient.getInstance().setImmersive(mToken, i);
}",1,"/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Adjust the current immersive mode setting.
 *
 * Note that changing this value will have no effect on the activity's
 * {@link android.content.pm.ActivityInfo} structure; that is, if
 * <code>android:immersive</code> is set to <code>true</code>
 * in the application's manifest entry for this activity, the {@link
 * android.content.pm.ActivityInfo#flags ActivityInfo.flags} member will
 * always have its {@link android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 * FLAG_IMMERSIVE} bit set.
 *
 * @see #isImmersive()
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the early version uses ActivityTaskManager.getService().setImmersive(), while the late version implementation uses ActivityClient.getInstance().setImmersive(). This means that the underlying dependent API being called has changed, so the code change type is 5.","There is no Compatibility Issue in this case because there is no change in the return value or the exception handling behavior from the perspective of this method's contract with its caller. The method remains void; it does not return anything, and neither version throws checked exceptions. The changes are internal to the method and are related to the mechanism of how the immersive state is set rather than the method's exposed behavior. Therefore, the CI type is 0."
245,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,30,31,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,<android.accessibilityservice.AccessibilityService: boolean performGlobalAction(int)>,0,"{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.performGlobalAction(action);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling performGlobalAction"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.performGlobalAction(action);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling performGlobalAction"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Performs a global action. Such an action can be performed
 * at any moment regardless of the current application or user
 * location in that application. For example going back, going
 * home, opening recents, etc.
 *
 * @param action The action to perform.
 * @return Whether the action was successfully performed.
 *
 * @see #GLOBAL_ACTION_BACK
 * @see #GLOBAL_ACTION_HOME
 * @see #GLOBAL_ACTION_NOTIFICATIONS
 * @see #GLOBAL_ACTION_RECENTS
 */
","/**
 * Performs a global action. Such an action can be performed
 * at any moment regardless of the current application or user
 * location in that application. For example going back, going
 * home, opening recents, etc.
 *
 * <p>
 * Note: The global action ids themselves give no information about the current availability
 * of their corresponding actions. To determine if a global action is available, use
 * {@link #getSystemActions()}
 *
 * @param action The action to perform.
 * @return Whether the action was successfully performed.
 *
 * @see #GLOBAL_ACTION_BACK
 * @see #GLOBAL_ACTION_HOME
 * @see #GLOBAL_ACTION_NOTIFICATIONS
 * @see #GLOBAL_ACTION_RECENTS
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The `AccessibilityInteractionClient.getInstance()` method has been changed to `AccessibilityInteractionClient.getInstance(this)`, indicating that the dependent API has undergone a change, which is a change in the type or number of parameters, so the code change type is 5.","Although there is a change in the dependent API, this code change in itself would not lead to a Compatibility Issue, because the surrounding logic and the method's behavior remain the same. Hence, the CI type is 0."
246,"<android.view.inputmethod.EditorInfo: void setInitialSurroundingSubText(CharSequence,int)>",30,31,"<android.view.inputmethod.EditorInfo: void setInitialSurroundingSubText(CharSequence,int)>","<android.view.inputmethod.EditorInfo: void setInitialSurroundingSubText(CharSequence,int)>",0,"{
    CharSequence newSubText = Editable.Factory.getInstance().newEditable(subText);
    Objects.requireNonNull(newSubText);
    // Swap selection start and end if necessary.
    final int subTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd - subTextStart : initialSelStart - subTextStart;
    final int subTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart - subTextStart : initialSelEnd - subTextStart;
    final int subTextLength = newSubText.length();
    // Unknown or invalid selection.
    if (subTextStart < 0 || subTextSelStart < 0 || subTextSelEnd > subTextLength) {
        mInitialSurroundingText = new InitialSurroundingText();
        return;
    }
    // For privacy protection reason, we don't carry password inputs to IMEs.
    if (isPasswordInputType(inputType)) {
        mInitialSurroundingText = new InitialSurroundingText();
        return;
    }
    if (subTextLength <= MEMORY_EFFICIENT_TEXT_LENGTH) {
        mInitialSurroundingText = new InitialSurroundingText(newSubText, subTextSelStart, subTextSelEnd);
        return;
    }
    trimLongSurroundingText(newSubText, subTextSelStart, subTextSelEnd);
}","{
    Objects.requireNonNull(subText);
    // For privacy protection reason, we don't carry password inputs to IMEs.
    if (isPasswordInputType(inputType)) {
        mInitialSurroundingText = null;
        return;
    }
    // Swap selection start and end if necessary.
    final int subTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd - subTextStart : initialSelStart - subTextStart;
    final int subTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart - subTextStart : initialSelEnd - subTextStart;
    final int subTextLength = subText.length();
    // Unknown or invalid selection.
    if (subTextStart < 0 || subTextSelStart < 0 || subTextSelEnd > subTextLength) {
        mInitialSurroundingText = null;
        return;
    }
    if (subTextLength <= MEMORY_EFFICIENT_TEXT_LENGTH) {
        mInitialSurroundingText = new SurroundingText(subText, subTextSelStart, subTextSelEnd, subTextStart);
        return;
    }
    trimLongSurroundingText(subText, subTextSelStart, subTextSelEnd, subTextStart);
}",1,"/**
 * Editors may use this method to provide initial input text to IMEs. As the surrounding text
 * could be used to provide various input assistance, we recommend editors to provide the
 * complete initial input text in its {@link View#onCreateInputConnection(EditorInfo)} callback.
 * When trimming the input text is needed, call this method instead of
 * {@code setInitialSurroundingText(CharSequence)} and provide the trimmed position info. Always
 * try to include the selected text within {@code subText} to give the system best flexibility
 * to choose where and how to trim {@code subText} when necessary.
 *
 * @param subText The input text. When it was trimmed, {@code subTextStart} must be provided
 * correctly.
 * @param subTextStart  The position that the input text got trimmed. For example, when the
 * editor wants to trim out the first 10 chars, subTextStart should be 10.
 */
","/**
 * Editors may use this method to provide initial input text to IMEs. As the surrounding text
 * could be used to provide various input assistance, we recommend editors to provide the
 * complete initial input text in its {@link View#onCreateInputConnection(EditorInfo)} callback.
 * When trimming the input text is needed, call this method instead of
 * {@code setInitialSurroundingText(CharSequence)} and provide the trimmed position info. Always
 * try to include the selected text within {@code subText} to give the system best flexibility
 * to choose where and how to trim {@code subText} when necessary.
 *
 * Starting from {@link VERSION_CODES#S}, spans that do not implement {@link Parcelable} will
 * be automatically dropped.
 *
 * @param subText The input text. When it was trimmed, {@code subTextStart} must be provided
 * correctly.
 * @param subTextStart  The position that the input text got trimmed. For example, when the
 * editor wants to trim out the first 10 chars, subTextStart should be 10.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,The following code changes are observed:,- A return statement is changed from setting mInitialSurroundingText to a new InitialSurroundingText() instance to setting it to null.
247,<android.app.ContextImpl: Object getSystemService(String)>,30,31,<android.app.ContextImpl: Object getSystemService(String)>,<android.app.ContextImpl: Object getSystemService(String)>,0,"{
    if (vmIncorrectContextUseEnabled()) {
        // We may override this API from outer context.
        final boolean isUiContext = isUiContext() || isOuterUiContext();
        // Check incorrect Context usage.
        if (isUiComponent(name) && !isUiContext) {
            final String errorMessage = ""Tried to access visual service "" + SystemServiceRegistry.getSystemServiceClassName(name) + "" from a non-visual Context:"" + getOuterContext();
            final String message = ""Visual services, such as WindowManager, WallpaperService "" + ""or LayoutInflater should be accessed from Activity or other visual "" + ""Context. Use an Activity or a Context created with "" + ""Context#createWindowContext(int, Bundle), which are adjusted to "" + ""the configuration and visual bounds of an area on screen."";
            final Exception exception = new IllegalAccessException(errorMessage);
            StrictMode.onIncorrectContextUsed(message, exception);
            Log.e(TAG, errorMessage + "" "" + message, exception);
        }
    }
    return SystemServiceRegistry.getSystemService(this, name);
}","{
    if (vmIncorrectContextUseEnabled()) {
        // Check incorrect Context usage.
        if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
            final String errorMessage = ""Tried to access visual service "" + SystemServiceRegistry.getSystemServiceClassName(name) + "" from a non-visual Context:"" + getOuterContext();
            final String message = ""WindowManager should be accessed from Activity or other "" + ""visual Context. Use an Activity or a Context created with "" + ""Context#createWindowContext(int, Bundle), which are adjusted to "" + ""the configuration and visual bounds of an area on screen."";
            final Exception exception = new IllegalAccessException(errorMessage);
            StrictMode.onIncorrectContextUsed(message, exception);
            Log.e(TAG, errorMessage + "" "" + message, exception);
        }
    }
    return SystemServiceRegistry.getSystemService(this, name);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The condition in the if statement is changed from checking `isUiComponent(name)` with additional checks to only checking `WINDOW_SERVICE.equals(name)`, and the string messages inside the if statement have been updated. So, the code change includes control dependency and other statement changes, which are types 3 and 4.","The modifications in the if statement and string messages do not affect the return value or the exceptions that might be thrown by the method, as these changes only affect the logging and the error handling for internal checks. The actual value returned by the method will still be the same regardless of the visual context, as it is fetched with the same method call `SystemServiceRegistry.getSystemService(this, name)`. Therefore, there is no compatibility issue regarding different return values or exception handlings."
248,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetProtocol(BluetoothDevice,byte)>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetProtocol(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onSetProtocol(BluetoothDevice,byte)>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onSetProtocol(device, protocol));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onSetProtocol(device, protocol));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The early and late versions differ by the addition of two lines: the method call to Attributable.setAttributionSource() and the exception handling mechanism that wraps the existing code in a try-finally block to ensure restoreCallingIdentity(token) is called. The change type is 4, other statement changed since the code changes do not directly affect return statements, exception handling or control flow (no new control statements were introduced).","There is no compatibility issue as the behavior of the method has not changed in a way that would affect the API contract. The `onSetProtocol` method does not have a return type and the callback execution remains the same. The added lines manipulate the calling identity for security/accounting purposes and do not alter the functional result of this method. Hence, there should be no compatibility issue here."
250,"<android.app.admin.DeviceAdminReceiver: CharSequence onDisableRequested(Context,Intent)>",30,31,"<android.app.admin.DeviceAdminReceiver: CharSequence onDisableRequested(Context,Intent)>","<android.app.admin.DeviceAdminReceiver: CharSequence onDisableRequested(Context,Intent)>",0,"{
    return null;
}","{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + "".onDisableRequested() on user "" + context.getUserId());
    }
    return null;
}",1,"/**
 * Called when the user has asked to disable the administrator, as a result of
 * receiving {@link #ACTION_DEVICE_ADMIN_DISABLE_REQUESTED}, giving you
 * a chance to present a warning message to them.  The message is returned
 * as the result; if null is returned (the default implementation), no
 * message will be displayed.
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @return Return the warning message to display to the user before
 * being disabled; if null is returned, no message is displayed.
 */
","/**
 * Called when the user has asked to disable the administrator, as a result of
 * receiving {@link #ACTION_DEVICE_ADMIN_DISABLE_REQUESTED}, giving you
 * a chance to present a warning message to them.  The message is returned
 * as the result; if null is returned (the default implementation), no
 * message will be displayed.
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @return Return the warning message to display to the user before
 * being disabled; if null is returned, no message is displayed.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"A logging statement has been added for verbose logging. This change does not affect the method's return value or exception handling, so the code change type is 4.","The change in the code is related only to logging and does not affect the API behavior that impacts the return value or the exceptions thrown. Therefore, there is no Compatibility Issue, and the CI type is 0."
251,<android.content.res.XmlBlock.Parser: String getName()>,30,31,<android.content.res.XmlBlock.Parser: String getName()>,<android.content.res.XmlBlock.Parser: String getName()>,0,"{
    int id = nativeGetName(mParseState);
    return id >= 0 ? mStrings.get(id).toString() : null;
}","{
    int id = nativeGetName(mParseState);
    return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : null;
}",1,,,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The early version uses mStrings.get(id).toString(), while the late version uses getSequenceString(mStrings.getSequence(id)). This is a change in how the string result is obtained from the native code, which might not only include a different method call (getSequence instead of get), but also a different final processing (getSequenceString instead of toString()). This qualifies as a return statement changed (1) and a dependent API changed (5), as the way of obtaining the string from the id has changed.","Given that the method of processing the string has been altered, it is possible for the API to return different values. The change from directly calling `toString()` on the result from `mStrings.get(id)` to using a method `getSequenceString(mStrings.getSequence(id))` might result in different strings being returned if `getSequenceString` and `get(id).toString()` do not behave identically for every possible `id` value. This introduces a potential Compatibility Issue due to different return values (1)."
256,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,30,31,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,<android.accessibilityservice.AccessibilityService: AccessibilityServiceInfo getServiceInfo()>,0,"{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getServiceInfo();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while getting AccessibilityServiceInfo"", re);
            re.rethrowFromSystemServer();
        }
    }
    return null;
}","{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getServiceInfo();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while getting AccessibilityServiceInfo"", re);
            re.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Gets the an {@link AccessibilityServiceInfo} describing this
 * {@link AccessibilityService}. This method is useful if one wants
 * to change some of the dynamically configurable properties at
 * runtime.
 *
 * @return The accessibility service info.
 *
 * @see AccessibilityServiceInfo
 */
","/**
 * Gets the an {@link AccessibilityServiceInfo} describing this
 * {@link AccessibilityService}. This method is useful if one wants
 * to change some of the dynamically configurable properties at
 * runtime.
 *
 * @return The accessibility service info.
 *
 * @see AccessibilityServiceInfo
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API AccessibilityInteractionClient.getInstance() has been changed to AccessibilityInteractionClient.getInstance(this), indicating a change in the type or number of parameters passed to the method, which corresponds to change type 5 (Dependent API changed).","Even though the method used to get the instance of `AccessibilityInteractionClient` has changed, it does not affect the behavior of the `getServiceInfo()` method when it comes to returning values or throwing exceptions. The logic remains the same and it still attempts to get and return the service information in the same way or throw the same exception. Thus, thereâ€™s no compatibility issue based on the changes, which is why the CI type is 0."
257,<android.view.Display: Mode getMode()>,30,31,<android.view.Display: Mode getMode()>,<android.view.Display: Mode getMode()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getMode();
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getMode();
    }
}",1,"/**
 * Returns the active mode of the display.
 */
","/**
 * Returns the active mode of the display.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object that's being used for synchronization has changed from 'this' to 'mLock'. This is a change in the synchronization strategy but doesn't affect the functionality of the method. Hence, the code change type is 4.",There's no Compatibility Issue introduced by this change because the behavior of the API (what it returns or the exceptions it might throw) has not been altered as a result of this synchronization object change. The method still ultimately returns the same value from mDisplayInfo.getMode().
258,"<android.view.inputmethod.InputMethodManager: void toggleSoftInput(int,int)>",30,31,"<android.view.inputmethod.InputMethodManager: void toggleSoftInput(int,int)>","<android.view.inputmethod.InputMethodManager: void toggleSoftInput(int,int)>",0,"{
    if (mCurMethod != null) {
        try {
            mCurMethod.toggleSoftInput(showFlags, hideFlags);
        } catch (RemoteException e) {
        }
    }
}","{
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager#toggleSoftInput"", InputMethodManager.this, null);
    synchronized (mH) {
        final View view = getServedViewLocked();
        if (mImeInsetsConsumer != null && view != null) {
            if (mImeInsetsConsumer.isRequestedVisible()) {
                hideSoftInputFromWindow(view.getWindowToken(), hideFlags, null, SoftInputShowHideReason.HIDE_TOGGLE_SOFT_INPUT);
            } else {
                showSoftInput(view, showFlags, null, SoftInputShowHideReason.SHOW_TOGGLE_SOFT_INPUT);
            }
        }
    }
}",1,"/**
 * This method toggles the input method window display.
 *
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
","/**
 * This method toggles the input method window display.
 *
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 *
 * @deprecated Use {@link #showSoftInput(View, int)} or
 * {@link #hideSoftInputFromWindow(IBinder, int)} explicitly instead.
 * In particular during focus changes, the current visibility of the IME is not
 * well defined. Starting in {@link Build.VERSION_CODES#S Android S}, this only
 * has an effect if the calling app is the current IME focus.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","There has been a complete overhaul of the method body, with new logic implemented for toggling soft input, including changes in exception handling and control flow. The method calls within the method body have also changed, and there is the introduction of additional logic with if-else conditions and a synchronized block. Therefore, the changes include return statement changes, exception handling statement changes, control dependency changes, other statement changes, and dependent API changes, and hence the change types are 1,2,3,4,5.","Due to these changes in the method body, there is a high chance of a compatibility issue arising, as these changes could affect the behavior of the API and result in different outcomes. The method now contains logic that may not invoke the same methods or handle exceptions in the same way as before, which could lead to both different return values or types and different exception handlings. Thus, the CI types are 1,2."
259,"<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float,int)>",30,31,"<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float,int)>","<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float,int)>",0,"{
    mEffects.add(new PrimitiveEffect(checkPrimitive(primitiveId), scale, delay));
    return this;
}","{
    PrimitiveSegment primitive = new PrimitiveSegment(primitiveId, scale, delay);
    primitive.validate();
    return addSegment(primitive);
}",1,"/**
 * Add a haptic primitive to the end of the current composition.
 *
 * @param primitiveId The primitive to add
 * @param scale The scale to apply to the intensity of the primitive.
 * @param delay The amount of time, in milliseconds, to wait between playing the prior
 * primitive and this one
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
","/**
 * Add a haptic primitive to the end of the current composition.
 *
 * @param primitiveId The primitive to add
 * @param scale The scale to apply to the intensity of the primitive.
 * @param delay The amount of time in milliseconds to wait before playing this primitive,
 * starting at the time the previous element in this composition is finished.
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",0,"The return statement hasn't changed as both versions return 'this', which refers to the same object. However, new local variable declaration and method calls have been introduced (creating a PrimitiveSegment and calling validate() on it), but they don't affect the returned variable itself. There is also a change in the internal implementation detail and dependent API, with 'mEffects.add(...)' changed to an addSegment(...) method call. The code change types are therefore 1 for maintaining the same return statement, 4 for other statement changes inside the method, and 5 for the change in how the primitive effect is added to the internal list.",There is no Compatibility Issue as the method's behavior from an external perspective (returning 'this' for method chaining) remains unchanged. Different internal implementation details do not affect the API contract.
260,<android.view.VerifiedMotionEvent: Boolean getFlag(int)>,30,31,<android.view.VerifiedMotionEvent: Boolean getFlag(int)>,<android.view.VerifiedMotionEvent: Boolean getFlag(int)>,0,"{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_WINDOW_IS_OBSCURED:
        case FLAG_WINDOW_IS_PARTIALLY_OBSCURED:
            return (mFlags & flag) != 0;
    }
    return null;
}","{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_IS_ACCESSIBILITY_EVENT:
        case FLAG_WINDOW_IS_OBSCURED:
        case FLAG_WINDOW_IS_PARTIALLY_OBSCURED:
            return (mFlags & flag) != 0;
    }
    return null;
}",1,"/**
 * Get a specific flag of this motion event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the motion event has the requested flag
 * Boolean(false) if the motion event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see MotionEvent#FLAG_WINDOW_IS_OBSCURED
 * @see MotionEvent#FLAG_WINDOW_IS_PARTIALLY_OBSCURED
 */
","/**
 * Get a specific flag of this motion event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the motion event has the requested flag
 * Boolean(false) if the motion event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see MotionEvent#FLAG_WINDOW_IS_OBSCURED
 * @see MotionEvent#FLAG_WINDOW_IS_PARTIALLY_OBSCURED
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"The change is within the switch statement with a new case (FLAG_IS_ACCESSIBILITY_EVENT) being added. This constitutes a control dependency change, which is code change type 3.","There is no compatibility issue as the new case in the switch statement handles an additional flag; it does not alter the existing functionality or introduces a new return type or change in exception handling. The existing cases and the return statement have not been altered, hence there is no change in the API's behaviour for the older flags; it only extends the functionality to support a new flag without affecting old ones. Thus, the CI type is 0."
261,<android.app.Notification.Builder: RemoteViews createBigContentView()>,30,31,<android.app.Notification.Builder: RemoteViews createBigContentView()>,<android.app.Notification.Builder: RemoteViews createBigContentView()>,0,"{
    RemoteViews result = null;
    if (mN.bigContentView != null && useExistingRemoteView()) {
        return mN.bigContentView;
    } else if (mStyle != null) {
        result = mStyle.makeBigContentView();
        hideLine1Text(result);
    } else if (mActions.size() != 0) {
        result = applyStandardTemplateWithActions(getBigBaseLayoutResource(), null);
    }
    makeHeaderExpanded(result);
    return result;
}","{
    RemoteViews result = null;
    if (useExistingRemoteView(mN.bigContentView)) {
        return fullyCustomViewRequiresDecoration(false) ? minimallyDecoratedBigContentView(mN.bigContentView) : mN.bigContentView;
    }
    if (mStyle != null) {
        result = mStyle.makeBigContentView();
        if (fullyCustomViewRequiresDecoration(true)) {
            result = minimallyDecoratedBigContentView(result);
        }
    }
    if (result == null) {
        if (bigContentViewRequired()) {
            StandardTemplateParams p = mParams.reset().viewType(StandardTemplateParams.VIEW_TYPE_BIG).allowTextWithProgress(true).fillTextsFrom(this);
            result = applyStandardTemplateWithActions(getBigBaseLayoutResource(), p, null);
        }
    }
    makeHeaderExpanded(result);
    return result;
}",1,"/**
 * Construct a RemoteViews for the final big notification layout.
 */
","/**
 * Construct a RemoteViews for the final big notification layout.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method has several alterations: the condition check for using existing RemoteView has been changed with the `useExistingRemoteView(mN.bigContentView)` method and may now return different RemoteView instances with additional decoration logic. The control structure was modified by introducing an additional condition and refactoring the previous else-if into separate if statements. Furthermore, a new dependent API `fullyCustomViewRequiresDecoration`, `minimallyDecoratedBigContentView`, and the `bigContentViewRequired` method were added which affects the logic and execution path of the method. The API `applyStandardTemplateWithActions` also has a change in the parameters it accepts. Therefore, the change types are 1, 3, 4, 5.","The potential Behavior of the API is affected due to the changes in the return statement, which could return a differently decorated `RemoteViews` object or a different object entirely based on the new conditions and methods introduced. Therefore, there is a Compatibility Issue caused by potential different return values or types, corresponding to CI type 1."
263,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,30,31,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,<android.bluetooth.BluetoothHidDevice: boolean unregisterApp()>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.unregisterApp();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.unregisterApp(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Unregisters application. Active connection will be disconnected and no new connections will
 * be allowed until registered again using {@link #registerApp
 * (BluetoothHidDeviceAppQosSettings, BluetoothHidDeviceAppQosSettings,
 * BluetoothHidDeviceAppQosSettings, Executor, Callback)}. The registration status should be
 * tracked by the application by handling callback from Callback#onAppStatusChanged. The app
 * registration status is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Unregisters application. Active connection will be disconnected and no new connections will
 * be allowed until registered again using {@link #registerApp
 * (BluetoothHidDeviceAppQosSettings, BluetoothHidDeviceAppQosSettings,
 * BluetoothHidDeviceAppQosSettings, Executor, Callback)}. The registration status should be
 * tracked by the application by handling callback from Callback#onAppStatusChanged. The app
 * registration status is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method call service.unregisterApp() has been changed to include a new parameter (service.unregisterApp(mAttributionSource)), hence the code change type is 4 for other statement changed and 5 for dependent API changed.","Despite the change in the call to service.unregisterApp(), the behavior of the unregisterApp() API itself remains consistent because the return type and exception handling have not been altered. The addition of a new parameter (mAttriburationSource) is an internal change to the call and does not affect external behavior, unless the behavior of the method unregisterApp(mAttributionSource) itself differs from unregisterApp(). However, based on the information provided, it is assumed the addition of the attribution source does not fundamentally change the success/failure outcome of the method call. Therefore, there is no compatibility issue detected."
264,<android.app.ContextImpl: int checkSelfPermission(String)>,30,31,<android.app.ContextImpl: int checkSelfPermission(String)>,<android.app.ContextImpl: int checkSelfPermission(String)>,0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    return checkPermission(permission, Process.myPid(), Process.myUid());
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    if (mParams.isRenouncedPermission(permission)) {
        Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied"");
        return PERMISSION_DENIED;
    }
    return checkPermission(permission, Process.myPid(), Process.myUid());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version has introduced new control-flow logic with an additional 'if' statement and return statement, as well as a log message, so the code change type is 1,4.","The addition of a new 'if' statement which returns a constant (PERMISSION_DENIED) introduces a potential compatibility issue because this condition could cause the method to now return a different value than before. Previously, the value came only from checkPermission(), but now it can also be PERMISSION_DENIED if the permission is renounced. Therefore, the CI type is 1."
266,"<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>",30,31,"<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>","<android.service.autofill.CustomDescription.Builder: Builder addChild(int,Transformation)>",0,"{
    throwIfDestroyed();
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: "" + transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((transformation instanceof InternalTransformation), ""not provided by Android System: %s"", transformation);
    if (mTransformations == null) {
        mTransformations = new ArrayList<>();
    }
    mTransformations.add(new Pair<>(id, (InternalTransformation) transformation));
    return this;
}",1,"/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they will be applied
 * in the same order as added.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 *
 * @return this builder.
 *
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
","/**
 * Adds a transformation to replace the value of a child view with the fields in the
 * screen.
 *
 * <p>When multiple transformations are added for the same child view, they will be applied
 * in the same order as added.
 *
 * @param id view id of the children view.
 * @param transformation an implementation provided by the Android System.
 *
 * @return this builder.
 *
 * @throws IllegalArgumentException if {@code transformation} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change is in the message string provided to Preconditions.checkArgument method, which is modified to use formatting (%s) instead of string concatenation (+). This change is neither affecting the return value nor the exception handling; therefore, the change type is 4.","There are no Compatibility Issues because the modification does not alter the behavior of how this method works. It still throws the same exception under the same circumstances, and the return value remains unchanged. Hence, the CI type is 0."
267,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,30,31,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,<android.view.inputmethod.InputMethodManager: void hideStatusIcon(IBinder)>,0,"{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIcon(null, 0);
}","{
    InputMethodPrivilegedOperationsRegistry.get(imeToken).updateStatusIconAsync(null, 0);
}",1,"/**
 * @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
","/**
 * @deprecated Use {@link InputMethodService#hideStatusIcon()} instead. This method was
 * intended for IME developers who should be accessing APIs through the service. APIs in
 * this class are intended for app developers interacting with the IME.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The method that is being called changed from updateStatusIcon to updateStatusIconAsync, so the code change type is 5 (Dependent API changed).","There is no potential Compatibility Issue detected due to the change, because the external behavior of the method, in terms of what it returns or the exceptions it throws, remains the same. Both methods are void and don't throw checked exceptions. The change seems to be an internal asynchronous handling which wouldn't affect the API's behavior from a caller's perspective. Hence, the CI type is 0 (No Compatibility Issue)."
268,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult classifyText()>,30,31,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult classifyText()>,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult classifyText()>,0,"{
    mHot = true;
    return performClassification(null);
}","{
    mInitialized = true;
    return performClassification(null);
}",1,,,-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,4,0,"The state change is from setting `mHot` to `true` to setting `mInitialized` to `true`, which is a change in the states being modified but does not affect the method signature, the return type, exception handling or control structures. Therefore, the only change is an ""Other statement changed"" which is classified as 4.","Since there is no change in return statements, exception handling statements, or control dependency changes that affect the output or behavior of the method, there is no Compatibility Issue, so the CI type is 0."
269,<android.bluetooth.BluetoothAdapter: String getName()>,30,31,<android.bluetooth.BluetoothAdapter: String getName()>,<android.bluetooth.BluetoothAdapter: String getName()>,0,"{
    try {
        return mManagerService.getName();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    try {
        return mManagerService.getName(mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
","/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 *
 * @return the Bluetooth name, or null on error
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The method mManagerService.getName() now requires an additional parameter `mAttributionSource` in the late version. Annotations have been added in the late version that enforce permission checks. Therefore, the code change is regarding the addition of a parameter in a method call, which means the change type is 5.","There is no difference in return values or types and no changes in exception handling between the two versions since both return null upon a RemoteException and otherwise return the result of mManagerService.getName(), although with different parameters. However, the new permissions enforced through annotations do not affect the execution flow or the potential return value or exception thrown by the method itself. Therefore, it is classified as no compatibility issue (0)."
270,<android.widget.TextView: void setSingleLine(boolean)>,30,31,<android.widget.TextView: void setSingleLine(boolean)>,<android.widget.TextView: void setSingleLine(boolean)>,0,"{
    // Could be used, but may break backward compatibility.
    // if (mSingleLine == singleLine) return;
    setInputTypeSingleLine(singleLine);
    applySingleLine(singleLine, true, true);
}","{
    // Could be used, but may break backward compatibility.
    // if (mSingleLine == singleLine) return;
    setInputTypeSingleLine(singleLine);
    applySingleLine(singleLine, true, true, true);
}",1,"/**
 * If true, sets the properties of this field (number of lines, horizontally scrolling,
 * transformation method) to be for a single-line input; if false, restores these to the default
 * conditions.
 *
 * Note that the default conditions are not necessarily those that were in effect prior this
 * method, and you may want to reset these properties to your custom values.
 *
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * If true, sets the properties of this field (number of lines, horizontally scrolling,
 * transformation method) to be for a single-line input; if false, restores these to the default
 * conditions.
 *
 * Note that the default conditions are not necessarily those that were in effect prior this
 * method, and you may want to reset these properties to your custom values.
 *
 * Note that due to performance reasons, by setting single line for the EditText, the maximum
 * text length is set to 5000 if no other character limitation are applied.
 *
 * @attr ref android.R.styleable#TextView_singleLine
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"4,5",0,"The 'applySingleLine' method call now includes an additional boolean parameter but no change has been made to any return or exception statement, and the structure of control statements has not been altered, so the code change type is 4,5.","Despite a change to a dependent method call, there is no change to the public API's return type, thrown exceptions, control flow, or other behavior that a caller of setSingleLine(boolean) would experience, so there is no Compatibility Issue."
271,"<android.content.ContentProviderClient: int update(Uri,ContentValues,Bundle)>",30,31,"<android.content.ContentProviderClient: int update(Uri,ContentValues,Bundle)>","<android.content.ContentProviderClient: int update(Uri,ContentValues,Bundle)>",0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, mAttributionTag, url, values, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.update(mAttributionSource, url, values, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API from 'mContentProvider.update(mPackageName, mAttributionTag, url, values, extras)' changed to 'mContentProvider.update(mAttributionSource, url, values, extras)' where the type of the first argument has been altered, so the code change type is 5.","There is no compatibility issue because the replaced argument 'mPackageName, mAttributionTag' with 'mAttributionSource' is built internally within the method and does not affect the return type or the exceptions thrown by the method. The overall behavior and the contract of the method remain the same for the caller as it is an internal change that is not exposed to the calling code. Therefore, CI type is 0."
272,<android.accessibilityservice.AccessibilityService: List<AccessibilityAction> getSystemActions()>,30,31,<android.accessibilityservice.AccessibilityService: List<AccessibilityAction> getSystemActions()>,<android.accessibilityservice.AccessibilityService: List<AccessibilityAction> getSystemActions()>,0,"{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getSystemActions();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling getSystemActions"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Collections.emptyList();
}","{
    IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            return connection.getSystemActions();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Error while calling getSystemActions"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Collections.emptyList();
}",1,"/**
 * Returns a list of system actions available in the system right now.
 * <p>
 * System actions that correspond to the global action constants will have matching action IDs.
 * For example, an with id {@link #GLOBAL_ACTION_BACK} will perform the back action.
 * </p>
 * <p>
 * These actions should be called by {@link #performGlobalAction}.
 * </p>
 *
 * @return A list of available system actions.
 */
","/**
 * Returns a list of system actions available in the system right now.
 * <p>
 * System actions that correspond to the global action constants will have matching action IDs.
 * For example, an with id {@link #GLOBAL_ACTION_BACK} will perform the back action.
 * </p>
 * <p>
 * These actions should be called by {@link #performGlobalAction}.
 * </p>
 *
 * @return A list of available system actions.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method getInstance() is now called with 'this' as an argument, indicating a change in a dependent API invocation. This is reflected in the change type 5.","Given that only the argument with which getInstance() is invoked has changed and no other change is observed in the overall implementation or control flow, it is presumed that the behavior of the API remains consistent with its earlier version. There should be no compatibility issue from this specific change since the dependent API should still provide the correct IAccessibilityServiceConnection object that is required for the rest of the method to function correctly. The annotations remain the same and enforce non-null behavior as expected. Therefore, the CI type is 0."
273,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>",30,31,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,Bundle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change occurs in the argument list of the `broadcastIntentWithFeature` method from `AppOpsManager.OP_NONE` to `null, /*excludedPermissions=*/ AppOpsManager.OP_NONE`. However, this doesn't affect the behaviour of the `sendBroadcastAsUser` method as it is only changing a parameter (from an operation flag to a null value for the excluded permissions and then the operation flag), not the overall logic or the control flow. The dependent API `broadcastIntentWithFeature` is called differently, but the change doesn't imply a difference in the behaviour of the `sendBroadcastAsUser` method itself, thus it's a Dependent API changed, code change type 5.","There's no Compatibility Issue, as the changes do not affect the behaviour of this API method from the perspective of the caller. The method signature remains the same, it doesn't throw any new exceptions, and the method returns no value (void), so no return value can be affected. The API still functionally does the same from the caller's standpoint, despite the parameter change in the inner method call. Thus, there is No Compatibility Issue."
274,<android.app.Activity: int getRequestedOrientation()>,30,31,<android.app.Activity: int getRequestedOrientation()>,<android.app.Activity: int getRequestedOrientation()>,0,"{
    if (mParent == null) {
        try {
            return ActivityTaskManager.getService().getRequestedOrientation(mToken);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        return mParent.getRequestedOrientation();
    }
    return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
}","{
    if (mParent == null) {
        return ActivityClient.getInstance().getRequestedOrientation(mToken);
    } else {
        return mParent.getRequestedOrientation();
    }
}",1,"/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Return the current requested orientation of the activity.  This will
 * either be the orientation requested in its component's manifest, or
 * the last requested orientation given to
 * {@link #setRequestedOrientation(int)}.
 *
 * @return Returns an orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,[@ActivityInfo.ScreenOrientation],[@ActivityInfo.ScreenOrientation],-1,-1,-1,-1,-1,-1,"1,2,5","1,2","The try-catch block has been removed, and a new method (ActivityClient.getInstance().getRequestedOrientation) is now called instead of the previous (ActivityTaskManager.getService().getRequestedOrientation). This represents changes of type 1 (return statement changed), 2 (exception handling changed), and 5 (dependent API changed), as the method call and exception handling structure have been altered.","The removal of the try-catch block leads to a CI of type 2, as it changes how exceptions are handled. Previously, a RemoteException would be caught and swallowed, now it would propagate up, changing the behavior of the method in the case of an exception. The change in the API used to get the requested orientation could mean that the return value may be different, leading to a CI of type 1. The behavior of the `getRequestedOrientation` method could change if `ActivityTaskManager.getService().getRequestedOrientation` and `ActivityClient.getInstance().getRequestedOrientation` behave differently, even if they are intended to serve the same purpose."
275,"<android.accessibilityservice.AccessibilityService: void takeScreenshot(int,Executor,TakeScreenshotCallback)>",30,31,"<android.accessibilityservice.AccessibilityService: void takeScreenshot(int,Executor,TakeScreenshotCallback)>","<android.accessibilityservice.AccessibilityService: void takeScreenshot(int,Executor,TakeScreenshotCallback)>",0,"{
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkNotNull(callback, ""callback cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        sendScreenshotFailure(ERROR_TAKE_SCREENSHOT_INTERNAL_ERROR, executor, callback);
        return;
    }
    try {
        connection.takeScreenshot(displayId, new RemoteCallback((result) -> {
            final int status = result.getInt(KEY_ACCESSIBILITY_SCREENSHOT_STATUS);
            if (status != TAKE_SCREENSHOT_SUCCESS) {
                sendScreenshotFailure(status, executor, callback);
                return;
            }
            final HardwareBuffer hardwareBuffer = result.getParcelable(KEY_ACCESSIBILITY_SCREENSHOT_HARDWAREBUFFER);
            final ParcelableColorSpace colorSpace = result.getParcelable(KEY_ACCESSIBILITY_SCREENSHOT_COLORSPACE);
            final ScreenshotResult screenshot = new ScreenshotResult(hardwareBuffer, colorSpace.getColorSpace(), result.getLong(KEY_ACCESSIBILITY_SCREENSHOT_TIMESTAMP));
            sendScreenshotSuccess(screenshot, executor, callback);
        }));
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
}","{
    Preconditions.checkNotNull(executor, ""executor cannot be null"");
    Preconditions.checkNotNull(callback, ""callback cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection == null) {
        sendScreenshotFailure(ERROR_TAKE_SCREENSHOT_INTERNAL_ERROR, executor, callback);
        return;
    }
    try {
        connection.takeScreenshot(displayId, new RemoteCallback((result) -> {
            final int status = result.getInt(KEY_ACCESSIBILITY_SCREENSHOT_STATUS);
            if (status != TAKE_SCREENSHOT_SUCCESS) {
                sendScreenshotFailure(status, executor, callback);
                return;
            }
            final HardwareBuffer hardwareBuffer = result.getParcelable(KEY_ACCESSIBILITY_SCREENSHOT_HARDWAREBUFFER);
            final ParcelableColorSpace colorSpace = result.getParcelable(KEY_ACCESSIBILITY_SCREENSHOT_COLORSPACE);
            final ScreenshotResult screenshot = new ScreenshotResult(hardwareBuffer, colorSpace.getColorSpace(), result.getLong(KEY_ACCESSIBILITY_SCREENSHOT_TIMESTAMP));
            sendScreenshotSuccess(screenshot, executor, callback);
        }));
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
}",1,"/**
 * Takes a screenshot of the specified display and returns it via an
 * {@link AccessibilityService.ScreenshotResult}. You can use {@link Bitmap#wrapHardwareBuffer}
 * to construct the bitmap from the ScreenshotResult's payload.
 * <p>
 * <strong>Note:</strong> In order to take screenshot your service has
 * to declare the capability to take screenshot by setting the
 * {@link android.R.styleable#AccessibilityService_canTakeScreenshot}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param displayId The logic display id, must be {@link Display#DEFAULT_DISPLAY} for
 * default display.
 * @param executor Executor on which to run the callback.
 * @param callback The callback invoked when taking screenshot has succeeded or failed.
 * See {@link TakeScreenshotCallback} for details.
 */
","/**
 * Takes a screenshot of the specified display and returns it via an
 * {@link AccessibilityService.ScreenshotResult}. You can use {@link Bitmap#wrapHardwareBuffer}
 * to construct the bitmap from the ScreenshotResult's payload.
 * <p>
 * <strong>Note:</strong> In order to take screenshot your service has
 * to declare the capability to take screenshot by setting the
 * {@link android.R.styleable#AccessibilityService_canTakeScreenshot}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param displayId The logic display id, must be {@link Display#DEFAULT_DISPLAY} for
 * default display.
 * @param executor Executor on which to run the callback.
 * @param callback The callback invoked when taking screenshot has succeeded or failed.
 * See {@link TakeScreenshotCallback} for details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the dependent API AccessibilityInteractionClient.getInstance() has changed. It now requires a 'this' parameter in the late version (AccessibilityInteractionClient.getInstance(this)). This indicates a change in the method signature of the getInstance() method of the AccessibilityInteractionClient class, which may potentially affect how the connection object is obtained. Hence, the code change type is 5.","There is no compatibility issue introduced by this specific change since getInstance(this) will still return an instance of the AccessibilityInteractionClient that should behave consistently with its prior version in terms of getConnection(mConnectionId) functionality. Thus, there's no change that could result in different return values/types or exception handlings of the takeScreenshot API itself."
276,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDeviceCredentialAllowed(boolean)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDeviceCredentialAllowed(boolean)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDeviceCredentialAllowed(boolean)>,0,"{
    mBundle.putBoolean(KEY_ALLOW_DEVICE_CREDENTIAL, allowed);
    return this;
}","{
    mPromptInfo.setDeviceCredentialAllowed(allowed);
    return this;
}",1,"/**
 * Optional: If enabled, the user will be given the option to authenticate with their device
 * PIN, pattern, or password. Developers should first check {@link
 * BiometricManager#canAuthenticate(int)} for {@link Authenticators#DEVICE_CREDENTIAL}
 * before enabling. If the device is not secured with a credential,
 * {@link AuthenticationCallback#onAuthenticationError(int, CharSequence)} will be invoked
 * with {@link BiometricPrompt#BIOMETRIC_ERROR_NO_DEVICE_CREDENTIAL}. Defaults to false.
 *
 * <p>Note that enabling this option replaces the negative button on the prompt with one
 * that allows the user to authenticate with their device credential, making it an error to
 * call {@link #setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 *
 * @param allowed true if the prompt should fall back to asking for the user's device
 * credential (PIN/pattern/password), or false otherwise.
 * @return This builder.
 *
 * @deprecated Replaced by {@link #setAllowedAuthenticators(int)}.
 */
","/**
 * Optional: If enabled, the user will be given the option to authenticate with their device
 * PIN, pattern, or password. Developers should first check {@link
 * BiometricManager#canAuthenticate(int)} for {@link Authenticators#DEVICE_CREDENTIAL}
 * before enabling. If the device is not secured with a credential,
 * {@link AuthenticationCallback#onAuthenticationError(int, CharSequence)} will be invoked
 * with {@link BiometricPrompt#BIOMETRIC_ERROR_NO_DEVICE_CREDENTIAL}. Defaults to false.
 *
 * <p>Note that enabling this option replaces the negative button on the prompt with one
 * that allows the user to authenticate with their device credential, making it an error to
 * call {@link #setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 *
 * @param allowed true if the prompt should fall back to asking for the user's device
 * credential (PIN/pattern/password), or false otherwise.
 * @return This builder.
 *
 * @deprecated Replaced by {@link #setAllowedAuthenticators(int)}.
 */
",-1,"[@Deprecated, @NonNull]","[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to set the device credential allowed flag has changed from putting a boolean into a Bundle with a specific key to calling a method on mPromptInfo. Given that both versions are using different mechanisms to set the value and the change is within an assignment operation, the change type is 4. Also, a method from a dependent API is being used instead of directly manipulating a bundle, which indicates a change type 5.","Despite the implementation change, this method ultimately configures a setting and then returns 'this', the current Builder object, without altering the builder's return type or the exception handling. Therefore, there's no Compatibility Issue regarding the return value or the exception handling."
277,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertisingSet(AdvertisingSetCallback)>,30,31,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertisingSet(AdvertisingSetCallback)>,<android.bluetooth.le.BluetoothLeAdvertiser: void stopAdvertisingSet(AdvertisingSetCallback)>,0,"{
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    IAdvertisingSetCallback wrapped = mCallbackWrappers.remove(callback);
    if (wrapped == null) {
        return;
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopAdvertisingSet(wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to stop advertising - "", e);
    }
}","{
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    IAdvertisingSetCallback wrapped = mCallbackWrappers.remove(callback);
    if (wrapped == null) {
        return;
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopAdvertisingSet(wrapped, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to stop advertising - "", e);
    }
}",1,"/**
 * Used to dispose of a {@link AdvertisingSet} object, obtained with {@link
 * BluetoothLeAdvertiser#startAdvertisingSet}.
 */
","/**
 * Used to dispose of a {@link AdvertisingSet} object, obtained with {@link
 * BluetoothLeAdvertiser#startAdvertisingSet}.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method call gatt.stopAdvertisingSet(wrapped) in the early implementation has an additional parameter mAttributionSource in the late implementation, making it gatt.stopAdvertisingSet(wrapped, mAttributionSource). It indicates a change in a dependent API call, thus the change type is 4,5.","This change to the method parameters of a dependent API call does not in itself lead to a different return value or a different exception being thrown by the method; the method signature remains the same and there are no changes to the exception handling or return statement in the method implementation, so there is no compatibility issue, and the CI type is 0."
278,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",30,31,"<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>","<android.view.textservice.TextServicesManager: SpellCheckerSession newSpellCheckerSession(Bundle,Locale,SpellCheckerSessionListener,boolean)>",0,"{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException(""Locale should not be null if you don't refer"" + "" settings."");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(mUserId, null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, this, listener);
    try {
        mService.getSpellCheckerService(mUserId, sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}","{
    // Attributes existed before {@link #newSpellCheckerSession(Locale, boolean, int, Bundle,
    // Executor, SpellCheckerSessionListener)} was introduced.
    int supportedAttributes = SuggestionsInfo.RESULT_ATTR_IN_THE_DICTIONARY | SuggestionsInfo.RESULT_ATTR_LOOKS_LIKE_TYPO | SuggestionsInfo.RESULT_ATTR_HAS_RECOMMENDED_SUGGESTIONS;
    SpellCheckerSessionParams.Builder paramsBuilder = new SpellCheckerSessionParams.Builder().setLocale(locale).setShouldReferToSpellCheckerLanguageSettings(referToSpellCheckerLanguageSettings).setSupportedAttributes(supportedAttributes);
    if (bundle != null) {
        paramsBuilder.setExtras(bundle);
    }
    // Using the implicit looper to preserve the old behavior.
    Executor executor = new HandlerExecutor(new Handler());
    return newSpellCheckerSession(paramsBuilder.build(), executor, listener);
}",1,"/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */
","/**
 * Get a spell checker session from the spell checker.
 *
 * <p>{@link SuggestionsInfo#RESULT_ATTR_IN_THE_DICTIONARY},
 * {@link SuggestionsInfo#RESULT_ATTR_LOOKS_LIKE_TYPO}, and
 * {@link SuggestionsInfo#RESULT_ATTR_HAS_RECOMMENDED_SUGGESTIONS} will be passed to the spell
 * checker as supported attributes.
 *
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. ""en""), the specified locale in Settings (e.g. ""en_US"") will be
 * selected.
 * @param listener a spell checker session lister for getting results from the spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return a spell checker session of the spell checker
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late version method implementation changes completely, calling newSpellCheckerSession with different parameters which include objects of new types such as SpellCheckerSessionParams and HandlerExecutor, and including logic for creating these new objects. Additionally, the method's return statement now calls a different overloaded version of the same method with a different signature. Thus, the change types are 1, 4, and 5.","This change can cause a Compatibility Issue due to the potential different return values or types as the entire logic of the method's implementation is restructured to call a different method and the exceptions handling logic has been removed, leading to type 1 CI."
279,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",30,31,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateSelection(view, selStart, selEnd, candidatesStart, candidatesEnd);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            if (DEBUG) {
                Log.v(TAG, ""SELECTION CHANGE: "" + mCurrentInputMethodSession);
            }
            final int oldSelStart = mCursorSelStart;
            final int oldSelEnd = mCursorSelEnd;
            // Update internal values before sending updateSelection to the IME, because
            // if it changes the text within its onUpdateSelection handler in a way that
            // does not move the cursor we don't want to call it again with the same values.
            mCursorSelStart = selStart;
            mCursorSelEnd = selEnd;
            mCursorCandStart = candidatesStart;
            mCursorCandEnd = candidatesEnd;
            mCurrentInputMethodSession.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
        }
    }
}",1,"/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
","/**
 * Report the current selection range.
 *
 * <p><strong>Editor authors</strong>, you need to call this method whenever
 * the cursor moves in your editor. Remember that in addition to doing this, your
 * editor needs to always supply current cursor values in
 * {@link EditorInfo#initialSelStart} and {@link EditorInfo#initialSelEnd} every
 * time {@link android.view.View#onCreateInputConnection(EditorInfo)} is
 * called, which happens whenever the keyboard shows up or the focus changes
 * to a text field, among other cases.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency changed because the condition in the 'if' statement has been altered from checking `mCurMethod` to checking `mCurrentInputMethodSession`. Additionally, the method call within the try block changed from `mCurMethod.updateSelection` to `mCurrentInputMethodSession.updateSelection`, indicating a change in the dependent API, so the code change is 3,5.","Despite the change in the dependent API, there is no inherent change indicating a different return value or type, nor is there a change in exception handling. The method's behavior in terms of return value and exception handling remains consistent. Although a different object is called, this does not in itself cause a different value or type to be returned, or an exception to be thrown, thus there is no Compatibility Issue, and the CI type is 0."
280,"<android.content.ContentResolver: int delete(Uri,Bundle)>",30,31,"<android.content.ContentResolver: int delete(Uri,Bundle)>","<android.content.ContentResolver: int delete(Uri,Bundle)>",0,"{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.delete(url, extras);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, mAttributionTag, url, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", null);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.delete(url, extras);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mContext.getAttributionSource(), url, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""delete"", null);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return The number of rows deleted.
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
","/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return The number of rows deleted.
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The parameter `provider.delete(mPackageName, mAttributionTag, url, extras)` is changed to `provider.delete(mContext.getAttributionSource(), url, extras)` where the object used as a parameter has changed which indicates a dependent API has changed. There are no other changes in control structures or exception handling. So the code change type is 5.","The modification is to the parameters being passed into another API (dependent API). There has been no change in the control flow or the logic that could lead to a different exception being thrown or change the return value (assuming that the `delete` method's behavior remains consistent across the attribution changes). Therefore, there is no Compatibility Issue; the type is 0."
282,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,30,31,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,0,"{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}","{
    return getDateFormatOrder(getDateFormatString(context));
}",1,"/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
","/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change consists of updating the method used to obtain the date format order from ICU.getDateFormatOrder to getDateFormatOrder directly without the ICU qualifier, indicating that the implementation of getDateFormatOrder may have been moved or changed. This is a dependent API change, so the code change type is 5.","There is no direct indication that the behavior of the method has changed regarding what it returns or the exceptions it might throw. Assuming the new getDateFormatOrder method without the ICU class qualifier has the same behavior as the old ICU.getDateFormatOrder, there are no potential Compatibility Issues, so the CI type is 0."
283,<android.os.VibrationAttributes.Builder: VibrationAttributes build()>,30,31,<android.os.VibrationAttributes.Builder: VibrationAttributes build()>,<android.os.VibrationAttributes.Builder: VibrationAttributes build()>,0,"{
    VibrationAttributes ans = new VibrationAttributes(mUsage, mFlags, mAudioAttributes);
    return ans;
}","{
    VibrationAttributes ans = new VibrationAttributes(mUsage, mOriginalAudioUsage, mFlags);
    return ans;
}",1,"/**
 * Combines all of the attributes that have been set and returns a new
 * {@link VibrationAttributes} object.
 * @return a new {@link VibrationAttributes} object
 */
","/**
 * Combines all of the attributes that have been set and returns a new
 * {@link VibrationAttributes} object.
 * @return a new {@link VibrationAttributes} object
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The constructor parameters for `VibrationAttributes` creation are changed, which involves changing from `mAudioAttributes` to `mOriginalAudioUsage`. This indicates that there is a change in how the object is constructed, classified as change type 4 (Other statement changed). Additionally, since the change directly involves the parameters used in the API of another class (`VibrationAttributes`), this is also a change type 5 (Dependent API changed).","There's no direct indication of a Compatibility Issue from the change in constructor parameters, assuming both `mAudioAttributes` and `mOriginalAudioUsage` serve to initialize the `VibrationAttributes` correctly for their intended purpose. The return type remains the same, and it is not clear from the context provided that this would lead to a different behavior, as the constructor should be designed to handle different sets of parameters without causing a failure. Thus, we can consider there are no compatibility issues in terms of different return values, types, or exception handlings based on the information given, so the CI type is 0."
284,<android.view.Display: int getHeight()>,30,31,<android.view.Display: int getHeight()>,<android.view.Display: int getHeight()>,0,"{
    synchronized (this) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppHeightCompat;
    }
}","{
    synchronized (mLock) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppHeightCompat;
    }
}",1,"/**
 * @deprecated Use {@link WindowMetrics#getBounds()#height()} instead.
 */
","/**
 * @deprecated Use {@link WindowMetrics#getBounds()#height()} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The object used for synchronization has changed from 'this' to 'mLock', which is classified as an ""Other statement changed"".","There is no Compatibility Issue detected as the logic inside the synchronized block remains unchanged. The change in the object used for locking would not affect the behavior from the client's perspective, assuming 'mLock' is properly guarding the same state as 'this' did. Both blocks perform the same operations and return the same value. Thus, the method's contract remains consistent across both versions."
285,<android.content.res.Resources.Theme: long getNativeTheme()>,30,31,<android.content.res.Resources.Theme: long getNativeTheme()>,<android.content.res.Resources.Theme: long getNativeTheme()>,0,"{
    return mThemeImpl.getNativeTheme();
}","{
    synchronized (mLock) {
        return mThemeImpl.getNativeTheme();
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A synchronization block has been added to the late version which is a control dependency change and the 'return' statement is now inside this synchronized block. This is considered an ""other statement changed"" as well because it doesn't modify exception handling or the return value, just the threading behavior. Therefore, the code change type is 3,4.","The change to wrap the return statement with a synchronized block on mLock does not affect what the method returns nor the exceptions it might throw, it only affects the threading behavior. Thus, it is considered a change that does not introduce a Compatibility Issue, marked by 0."
286,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",30,31,"<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>","<android.view.ViewGroup: int getChildMeasureSpec(int,int,int)>",0,"{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    // noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}","{
    int specMode = MeasureSpec.getMode(spec);
    int specSize = MeasureSpec.getSize(spec);
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;
    switch(specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;
        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let them have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
    }
    // noinspection ResourceType
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}",1,"/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
","/**
 * Does the hard part of measureChildren: figuring out the MeasureSpec to
 * pass to a particular child. This method figures out the right MeasureSpec
 * for one dimension (height or width) of one child view.
 *
 * The goal is to combine information from our MeasureSpec with the
 * LayoutParams of the child to get the best possible results. For example,
 * if the this view knows its size (because its MeasureSpec has a mode of
 * EXACTLY), and the child has indicated in its LayoutParams that it wants
 * to be the same size as the parent, the parent should ask the child to
 * layout given an exact size.
 *
 * @param spec The requirements for this view
 * @param padding The padding of this view for the current dimension and
 * margins, if applicable
 * @param childDimension How big the child wants to be in the current
 * dimension
 * @return a MeasureSpec integer for the child
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
287,<android.content.pm.ShortcutInfo.Builder: Builder setLongLived(boolean)>,30,31,<android.content.pm.ShortcutInfo.Builder: Builder setLongLived(boolean)>,<android.content.pm.ShortcutInfo.Builder: Builder setLongLived(boolean)>,0,"{
    mIsLongLived = londLived;
    return this;
}","{
    mIsLongLived = longLived;
    return this;
}",1,"/**
 * Sets if a shortcut would be valid even if it has been unpublished/invisible by the app
 * (as a dynamic or pinned shortcut). If it is long lived, it can be cached by various
 * system services even after it has been unpublished as a dynamic shortcut.
 */
","/**
 * Sets if a shortcut would be valid even if it has been unpublished/invisible by the app
 * (as a dynamic or pinned shortcut). If it is long lived, it can be cached by various
 * system services even after it has been unpublished as a dynamic shortcut.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the method implementation; only a typo in the parameter name has been corrected from ""londLived"" to ""longLived"", which does not affect the method's behavior. The annotations have not changed.","Since there is no change in the behavior of the method between the two versions, no Compatibility Issue arises."
288,<android.view.autofill.AutofillValue: boolean getToggleValue()>,30,31,<android.view.autofill.AutofillValue: boolean getToggleValue()>,<android.view.autofill.AutofillValue: boolean getToggleValue()>,0,"{
    Preconditions.checkState(isToggle(), ""value must be a toggle value, not type="" + mType);
    return (Boolean) mValue;
}","{
    Preconditions.checkState(isToggle(), ""value must be a toggle value, not type=%d"", mType);
    return (Boolean) mValue;
}",1,"/**
 * Gets the value to autofill a toggable field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TOGGLE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a toggle value
 */
","/**
 * Gets the value to autofill a toggable field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TOGGLE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a toggle value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the error message inside the checkState() method has changed. The String concatenation with ""+"" has been replaced by a formatted string using ""%d"". This change does not affect the behavior or the control flow of the method, so the code change type is 4.",There is no Compatibility Issue because the change does not affect the returned value or thrown exception types/patterns of the method. The functionality remains unchanged.
289,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,30,31,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,<android.bluetooth.BluetoothGatt: void abortReliableWrite()>,0,"{
    if (VDBG)
        Log.d(TAG, ""abortReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), false);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    if (VDBG)
        Log.d(TAG, ""abortReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), false, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Cancels a reliable write transaction for a given device.
 *
 * <p>Calling this function will discard all queued characteristic write
 * operations for a given remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
","/**
 * Cancels a reliable write transaction for a given device.
 *
 * <p>Calling this function will discard all queued characteristic write
 * operations for a given remote device.
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method call within the try block has changed by adding an additional parameter `mAttributionSource`. Additionally, new annotations have been added, so the code change types are 4,5.","There's no change in the control flow of the code or in exception handling. Therefore, no compatibility issue is expected regarding different return values or exception handling, and the CI type is 0."
291,"<android.content.pm.ShortcutManager: void disableShortcuts(List<String>,CharSequence)>",30,31,"<android.content.pm.ShortcutManager: void disableShortcuts(List<String>,CharSequence)>","<android.content.pm.ShortcutManager: void disableShortcuts(List<String>,CharSequence)>",0,"{
    try {
        mService.disableShortcuts(mContext.getPackageName(), shortcutIds, disabledMessage, /* disabledMessageResId =*/
        0, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.disableShortcuts(mContext.getPackageName(), shortcutIds, disabledMessage, /* disabledMessageResId =*/
        0, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Disable pinned shortcuts, showing the user a custom error message when they try to select
 * the disabled shortcuts.
 * For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Disable pinned shortcuts, showing the user a custom error message when they try to select
 * the disabled shortcuts.
 * For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method called inside the `try` block changed from `mService.disableShortcuts` directly to using `getFutureOrThrow` with `mService.disableShortcuts` as its argument, without changing the control flow or exception handling. Also, the `getFutureOrThrow` method suggests that the underlying implementation might be related to asynchronous processing or future results, which means the dependent API has changed. Hence, the code changes are 4 for the method call change, and 5 for the dependent API change.","Because the exception handling has not changed and the return type of the method is void, there should be no compatibility issues with respect to the return value or different exception handlingsâ€”assuming the new `getFutureOrThrow` method does not introduce any new exceptions, and the semantics of how the disableShortcuts is processed does not change the method's behavior as observed by the caller. Therefore, there's no compatibility issue: 0."
292,"<android.app.WallpaperColors: void writeToParcel(Parcel,int)>",30,31,"<android.app.WallpaperColors: void writeToParcel(Parcel,int)>","<android.app.WallpaperColors: void writeToParcel(Parcel,int)>",0,"{
    List<Color> mainColors = getMainColors();
    int count = mainColors.size();
    dest.writeInt(count);
    for (int i = 0; i < count; i++) {
        Color color = mainColors.get(i);
        dest.writeInt(color.toArgb());
    }
    dest.writeInt(mColorHints);
}","{
    List<Color> mainColors = getMainColors();
    int count = mainColors.size();
    dest.writeInt(count);
    for (int i = 0; i < count; i++) {
        Color color = mainColors.get(i);
        dest.writeInt(color.toArgb());
    }
    count = mAllColors.size();
    dest.writeInt(count);
    for (Map.Entry<Integer, Integer> colorEntry : mAllColors.entrySet()) {
        if (colorEntry.getKey() != null) {
            dest.writeInt(colorEntry.getKey());
            Integer population = colorEntry.getValue();
            int populationInt = (population != null) ? population : 0;
            dest.writeInt(populationInt);
        }
    }
    dest.writeInt(mColorHints);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"New code was added which writes additional data to the Parcel object. The iteration over the 'mAllColors' map and the writing of its keys and values are new steps in the method. There are no changes to existing statements, making the code change type 4.","Since these changes are additional write operations to the Parcel, which is essentially a data structure designed to store a flattened representation of the objects being written, these do not change the behavior of the method itself in terms of its interaction with the rest of the system or the calling code. The added instructions do not affect the functionality from a caller's perspective, besides ensuring that more data is written to the Parcel. There are no different return values or exception handling changes; therefore, there is no Compatibility Issue."
293,"<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>",30,31,"<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(uri, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(uri, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mAttributionSource, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method parameter has been changed from 'mPackageName, mAttributionTag' to 'mAttributionSource' in the call to mContentProvider.query(). This indicates a change in the dependent API, but all other parts of the method remain unchanged, so change type is 4,5.","Since the method signature remains the same and only the internal call arguments to another API have changed without affecting the type or value of the returned Cursor, there is no compatibility issue regarding return values or exceptions. Therefore, the CI type is 0."
294,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,30,31,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.PackageItemInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}","{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        // system is overwhelmed by an enormous string returned by the application.
        return TextUtils.trimToSize(loadUnsafeLabel(pm), MAX_SAFE_LABEL_LENGTH);
    }
}",1,"/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The only change in the implementation is an additional method call TextUtils.trimToSize() to the return value of loadUnsafeLabel(pm) in the else block, which is an 'Other statement changed'. However, this changes the value returned by the method in cases where the unsafe label is longer than MAX_SAFE_LABEL_LENGTH, which means the return statement is also altered in its behavior. Thus, the change types are 1,4.","The addition of TextUtils.trimToSize() affects the value being returned by the API when the condition is false (i.e., sForceSafeLabels is not true or the package name being checked is the current package name). Since the length of the label can be trimmed, the API now potentially returns a different value. The CI type is therefore 1."
296,<android.widget.Editor.SuggestionsPopupWindow: void show()>,30,31,<android.widget.Editor.SuggestionsPopupWindow: void show()>,<android.widget.Editor.SuggestionsPopupWindow: void show()>,0,"{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (extractedTextModeWillBeStarted()) {
        return;
    }
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mCursorVisible;
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
    mSuggestionListView.setVisibility(mNumberOfSuggestions == 0 ? View.GONE : View.VISIBLE);
}","{
    if (!(mTextView.getText() instanceof Editable))
        return;
    if (extractedTextModeWillBeStarted()) {
        return;
    }
    if (updateSuggestions()) {
        mCursorWasVisibleBeforeSuggestions = mTextView.isCursorVisibleFromAttr();
        mTextView.setCursorVisible(false);
        mIsShowingUp = true;
        super.show();
    }
    mSuggestionListView.setVisibility(mNumberOfSuggestions == 0 ? View.GONE : View.VISIBLE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation replaces `mCursorVisible` with a call to `mTextView.isCursorVisibleFromAttr()`, so the code change type is 4.","The change in the implementation is a replacement of a direct member variable access with a method call that is expected to provide the same boolean value. It does not change the control flow or the type and value returned by the method itself, so there is no Compatibility Issue."
298,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,long,IBackupCallback,int)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,long,IBackupCallback,int)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doBackup(ParcelFileDescriptor,ParcelFileDescriptor,ParcelFileDescriptor,long,IBackupCallback,int)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor(), quotaBytes, transportFlags);
    long result = RESULT_ERROR;
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
        result = RESULT_SUCCESS;
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any SharedPreferences writes have landed after the backup,
        // in case the app code has side effects (since apps cannot provide this
        // guarantee themselves).
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.operationComplete(result);
        } catch (RemoteException e) {
        // We will time out anyway.
        }
        // Don't close the fd out from under the system service if this was local
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(oldState);
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""doBackup() invoked"");
    BackupDataOutput output = new BackupDataOutput(data.getFileDescriptor(), quotaBytes, transportFlags);
    long result = RESULT_ERROR;
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onBackup(oldState, output, newState);
        result = RESULT_SUCCESS;
    } catch (IOException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // Ensure that any SharedPreferences writes have landed after the backup,
        // in case the app code has side effects (since apps cannot provide this
        // guarantee themselves).
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.operationComplete(result);
        } catch (RemoteException e) {
        // We will time out anyway.
        }
        // Don't close the fd out from under the system service if this was local
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(oldState);
            IoUtils.closeQuietly(data);
            IoUtils.closeQuietly(newState);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There has been a reordering of statements (moving the DEBUG logging statement and the declaration of BackupDataOutput above the Binder.clearCallingIdentity call), but this does not alter the actual behavior of the method. All the functional operations remain in the same order and with the same control flow. All significant statements and exception handling remain unchanged.","Since there is no change in the actual behavior of the method and the alterations do not affect how the method returns or throws exceptions, there is no Compatibility Issue present."
299,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",30,31,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.migrateExtraStreamToClipData(context);
        intent.prepareToLeaveProcess(context);
        IIntentSender target = ActivityManager.getService().getIntentSenderWithFeature(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, context.getAttributionTag(), null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null
    final UserHandle user = context.getUser();
    return getActivityAsUser(context, requestCode, intent, flags, options, user != null ? user : UserHandle.of(context.getUserId()));
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,"[@SuppressWarnings(""AndroidFrameworkPendingIntentMutability"")]",-1,-1,-1,-1,-1,-1,"1,3,4,5",1,The entire body of the method has changed significantly:,"3. The control flow of the method has been updated to use a helper method ""getActivityAsUser""."
300,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",30,31,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The call to the method broadcastIntentWithFeature() has a change in the arguments: specifically, there's a null value provided as an argument in the later version. This indicates a change in the method signature of the called API (dependent API). Therefore, the change type involves an 'Other statement changed' as well as a 'Dependent API changed', which are indicated as types 4 and 5.","Despite the changes in the method arguments, there's no direct indication that the behavior of the API sendOrderedBroadcast itself has been altered in a way that would cause it to return a different value or throw a different exception under the same conditions. The called API's internal implementation handles the null value as an additional argument, and there is no change in the control flow or exception handling of the sendOrderedBroadcast method itself that could lead to a compatibility issue. Thus, the Compatibility Issue type is 0."
301,<android.view.inputmethod.InlineSuggestionsRequest: int hashCode()>,30,31,<android.view.inputmethod.InlineSuggestionsRequest: int hashCode()>,<android.view.inputmethod.InlineSuggestionsRequest: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + mMaxSuggestionCount;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlinePresentationSpecs);
    _hash = 31 * _hash + java.util.Objects.hashCode(mHostPackageName);
    _hash = 31 * _hash + java.util.Objects.hashCode(mSupportedLocales);
    _hash = 31 * _hash + java.util.Objects.hashCode(mExtras);
    _hash = 31 * _hash + java.util.Objects.hashCode(mHostInputToken);
    _hash = 31 * _hash + mHostDisplayId;
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + mMaxSuggestionCount;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlinePresentationSpecs);
    _hash = 31 * _hash + java.util.Objects.hashCode(mHostPackageName);
    _hash = 31 * _hash + java.util.Objects.hashCode(mSupportedLocales);
    _hash = 31 * _hash + java.util.Objects.hashCode(mExtras);
    _hash = 31 * _hash + java.util.Objects.hashCode(mHostInputToken);
    _hash = 31 * _hash + mHostDisplayId;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlineTooltipPresentationSpec);
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,1,"The hashCode calculation has been changed by adding an additional field (mInlineTooltipPresentationSpec) in the late version, which results in a different hash value computation. This is categorized as other statement changed.","This change will result in a different return value for hashCode() because the calculation now includes an additional field, which affects the output of the method. Therefore, it is a Compatibility Issue caused by the potential for different return values."
305,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,30,31,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,<android.app.admin.SecurityLog.SecurityEvent: int getLogLevel()>,0,"{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}","{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}",1,"/**
 * Returns severity level for the event.
 */
","/**
 * Returns severity level for the event.
 */
",-1,[@SecurityLogLevel],[@SecurityLogLevel],-1,-1,-1,-1,-1,-1,3,0,The control dependency has changed with the addition of `case TAG_PASSWORD_COMPLEXITY_REQUIRED:` in the switch-case statement. This is classified as a type 3 change.,"No Compatibility Issue arises from the addition of the case `TAG_PASSWORD_COMPLEXITY_REQUIRED`, since it is associated with the same return value (`LEVEL_INFO`) as most other cases in the switch statement. Thus, existing behavior for known tags is unchanged, and new behavior for a previously unhandled tag has been consistently integrated with the existing pattern."
306,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,30,31,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,<android.app.WallpaperManager: int getDesiredMinimumWidth()>,0,"{
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    StrictMode.assertUiContext(mContext, ""getDesiredMinimumWidth"");
    if (sGlobals.mService == null) {
        Log.w(TAG, ""WallpaperService not running"");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint(mContext.getDisplayId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 *
 * @see #getDesiredMinimumHeight()
 */
","/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 *
 * @see #getDesiredMinimumHeight()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the API implementation is the introduction of a new method call StrictMode.assertUiContext(mContext, ""getDesiredMinimumWidth""); this change is not affecting the return value or exception handling, creating a change type of 4.","The addition of the StrictMode.assertUiContext call does not cause a Compatibility Issue because it is not changing the return value or the exception handling mechanism of the API method. Therefore, the CI type is 0."
307,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,30,31,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,0,"{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return service.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return service.getRemoteUuids(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device, or null on error
 */
","/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device, or null on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method service.getRemoteUuids(this) in the early version has an additional parameter added in the late version: service.getRemoteUuids(this, mAttributionSource). This is a change in the parameters of the dependent API invocation, so the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the method invocation, the method's signature has not been altered, and the control flow remains the same in both versions, including the same return points and exception handling. Therefore, there is no Compatibility Issue because the behavior of the API has not changed in a way that would result in different return values or exceptions being thrown. Hence, the Compatibility Issue is 0 (No Compatibility Issue)."
308,<android.view.FrameMetrics: long getMetric(int)>,30,31,<android.view.FrameMetrics: long getMetric(int)>,<android.view.FrameMetrics: long getMetric(int)>,0,"{
    if (id < UNKNOWN_DELAY_DURATION || id > VSYNC_TIMESTAMP) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}","{
    if (id < UNKNOWN_DELAY_DURATION || id > DEADLINE) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FLAG_WINDOW_VISIBILITY_CHANGED) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}",1,"/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */
","/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement has changed in the condition `(id < UNKNOWN_DELAY_DURATION || id > VSYNC_TIMESTAMP)` to `(id < UNKNOWN_DELAY_DURATION || id > DEADLINE)`. Additionally, `FRAME_INFO_FLAG_FIRST_DRAW` in the if condition changed to `FLAG_WINDOW_VISIBILITY_CHANGED`. The constants `VSYNC_TIMESTAMP` and `DEADLINE` differ as well, indicating a change in the acceptable range for `id`, and the comparison logic for `FIRST_DRAW_FRAME` has been modified, all of which fall under return statement changed (1) and control dependency changed (3). The change from `FRAME_INFO_FLAG_FIRST_DRAW` to `FLAG_WINDOW_VISIBILITY_CHANGED` suggests that there is a potential dependent API changed (5) because these are most likely enum values or constants that are defined elsewhere.","Since the condition for checking the range of `id` has changed and logic within the if statement has been modified, the API could potentially return different results, which differs in behavior from the previous version. This constitutes a compatibility issue of type 1. The change in the constants used within the comparison can also lead to different return values. Furthermore, because a different flag is being checked (`FRAME_INFO_FLAG_FIRST_DRAW` vs `FLAG_WINDOW_VISIBILITY_CHANGED`), the return value for `FIRST_DRAW_FRAME` could also be different, reinforcing the classification of the compatibility issue as type 1."
309,<android.net.Uri.AbstractPart: String getDecoded()>,30,31,<android.net.Uri.AbstractPart: String getDecoded()>,<android.net.Uri.AbstractPart: String getDecoded()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean hasDecoded = decoded != NOT_CACHED;
    return hasDecoded ? decoded : (decoded = decode(encoded));
}","{
    @SuppressWarnings(""StringEquality"") boolean hasDecoded = decoded != NotCachedHolder.NOT_CACHED;
    return hasDecoded ? decoded : (decoded = decode(encoded));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The field access NOT_CACHED has been refactored to NotCachedHolder.NOT_CACHED. This is an internal change that affects how the NOT_CACHED value is referenced but does not alter the logic of the method itself, so the code change type is 4,5.","Since the actual value of NOT_CACHED does not seem to have changed, but rather only the way it is accessed, there should be no change in the behavior or the return value of the method. Hence, there is no Compatibility Issue."
310,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",30,31,"<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcastAsUser(Intent,UserHandle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,4,0,"The change is the removal of a constant (AppOpsManager.OP_NONE) as an argument in a method call and its replacement with a comment. This is an internal change and does not affect the API signature or its behavior from the caller's perspective, so the code change type is 4.",This internal change will not cause any Compatibility Issue since it does not affect the methodâ€™s return value or exception handling behavior. It is more like code clarification rather than a functional modification.
311,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,30,31,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,<android.widget.RemoteViews.AsyncApplyTask: void onPostExecute(ViewTree)>,0,"{
    mCancelSignal.setOnCancelListener(null);
    if (mError == null) {
        if (mListener != null) {
            mListener.onViewInflated(viewTree.mRoot);
        }
        try {
            if (mActions != null) {
                OnClickHandler handler = mHandler == null ? DEFAULT_ON_CLICK_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler);
                }
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}","{
    mCancelSignal.setOnCancelListener(null);
    if (mError == null) {
        if (mListener != null) {
            mListener.onViewInflated(viewTree.mRoot);
        }
        try {
            if (mActions != null) {
                InteractionHandler handler = mHandler == null ? DEFAULT_INTERACTION_HANDLER : mHandler;
                for (Action a : mActions) {
                    a.apply(viewTree.mRoot, mParent, handler, mColorResources);
                }
            }
            // If the parent of the view is has is a root, resolve the recycling.
            if (mTopLevel && mResult instanceof ViewGroup) {
                finalizeViewRecycling((ViewGroup) mResult);
            }
        } catch (Exception e) {
            mError = e;
        }
    }
    if (mListener != null) {
        if (mError != null) {
            mListener.onError(mError);
        } else {
            mListener.onViewApplied(viewTree.mRoot);
        }
    } else if (mError != null) {
        if (mError instanceof ActionException) {
            throw (ActionException) mError;
        } else {
            throw new ActionException(mError);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change includes an assignment to the variable 'handler' with a different variable type (from OnClickHandler to InteractionHandler) and the 'apply' method now also takes an additional parameter 'mColorResources'. Besides that, there is a new statement block checking 'mTopLevel' and finalizing the view recycling if conditions are met. This is new code logic and reflects a control dependency change as well as other statement changes, which classifies as types 3 and 4.","Although the implementation of the onPostExecute method has changed, these changes do not constitute a compatibility issue since the method's return type is void and does not throw a checked exception â€“ it only throws an unchecked exception (ActionException), which doesn't need to be declared or caught and the handling of this exception is unchanged between versions. The changes internal to the method do not affect the method's expected behavior regarding its return type or exceptions thrown. Therefore, no compatibility issue arises, which is indicated by 0."
313,"<android.os.VibrationEffect: VibrationEffect createOneShot(long,int)>",30,31,"<android.os.VibrationEffect: VibrationEffect createOneShot(long,int)>","<android.os.VibrationEffect: VibrationEffect createOneShot(long,int)>",0,"{
    VibrationEffect effect = new OneShot(milliseconds, amplitude);
    effect.validate();
    return effect;
}","{
    if (amplitude == 0) {
        throw new IllegalArgumentException(""amplitude must either be DEFAULT_AMPLITUDE, "" + ""or between 1 and 255 inclusive (amplitude="" + amplitude + "")"");
    }
    return createWaveform(new long[] { milliseconds }, new int[] { amplitude }, -1);
}",1,"/**
 * Create a one shot vibration.
 *
 * One shot vibrations will vibrate constantly for the specified period of time at the
 * specified amplitude, and then stop.
 *
 * @param milliseconds The number of milliseconds to vibrate. This must be a positive number.
 * @param amplitude The strength of the vibration. This must be a value between 1 and 255, or
 * {@link #DEFAULT_AMPLITUDE}.
 *
 * @return The desired effect.
 */
","/**
 * Create a one shot vibration.
 *
 * One shot vibrations will vibrate constantly for the specified period of time at the
 * specified amplitude, and then stop.
 *
 * @param milliseconds The number of milliseconds to vibrate. This must be a positive number.
 * @param amplitude The strength of the vibration. This must be a value between 1 and 255, or
 * {@link #DEFAULT_AMPLITUDE}.
 *
 * @return The desired effect.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5","1,2","In the late implementation, a new control structure (if-statement) has been introduced to check for an invalid amplitude value, and it throws an exception if the condition is met. Additionally, the return statement has been changed to call a different method, createWaveform(...), instead of creating a new OneShot instance, and there is no validation step. Hence, there is a change in control dependency, return statement, and the dependent API, so the code change is 1,3,5.","Compatibility issues arise from both the new potential to throw an exception due to the amplitude check, which can lead to different exception handling (CI type 2), and the change in the method used to generate the VibrationEffect, which can result in a different return value (CI type 1)."
314,"<android.view.inputmethod.InputMethodManager: void doDump(FileDescriptor,PrintWriter,String[])>",30,31,"<android.view.inputmethod.InputMethodManager: void doDump(FileDescriptor,PrintWriter,String[])>","<android.view.inputmethod.InputMethodManager: void doDump(FileDescriptor,PrintWriter,String[])>",0,"{
    final Printer p = new PrintWriterPrinter(fout);
    p.println(""Input method client state for "" + this + "":"");
    p.println(""  mService="" + mService);
    p.println(""  mMainLooper="" + mMainLooper);
    p.println(""  mIInputContext="" + mIInputContext);
    p.println(""  mActive="" + mActive + "" mRestartOnNextWindowFocus="" + mRestartOnNextWindowFocus + "" mBindSequence="" + mBindSequence + "" mCurId="" + mCurId);
    p.println(""  mFullscreenMode="" + mFullscreenMode);
    p.println(""  mCurMethod="" + mCurMethod);
    p.println(""  mCurRootView="" + mCurRootView);
    p.println(""  mServedView="" + getServedViewLocked());
    p.println(""  mNextServedView="" + getNextServedViewLocked());
    p.println(""  mServedConnecting="" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println(""  mCurrentTextBoxAttribute:"");
        mCurrentTextBoxAttribute.dump(p, ""    "");
    } else {
        p.println(""  mCurrentTextBoxAttribute: null"");
    }
    p.println(""  mServedInputConnectionWrapper="" + mServedInputConnectionWrapper);
    p.println(""  mCompletions="" + Arrays.toString(mCompletions));
    p.println(""  mCursorRect="" + mCursorRect);
    p.println(""  mCursorSelStart="" + mCursorSelStart + "" mCursorSelEnd="" + mCursorSelEnd + "" mCursorCandStart="" + mCursorCandStart + "" mCursorCandEnd="" + mCursorCandEnd);
}","{
    if (processDump(fd, args)) {
        return;
    }
    final Printer p = new PrintWriterPrinter(fout);
    p.println(""Input method client state for "" + this + "":"");
    p.println(""  mService="" + mService);
    p.println(""  mMainLooper="" + mMainLooper);
    p.println(""  mIInputContext="" + mIInputContext);
    p.println(""  mActive="" + mActive + "" mRestartOnNextWindowFocus="" + mRestartOnNextWindowFocus + "" mBindSequence="" + mBindSequence + "" mCurId="" + mCurId);
    p.println(""  mFullscreenMode="" + mFullscreenMode);
    if (mCurrentInputMethodSession != null) {
        p.println(""  mCurMethod="" + mCurrentInputMethodSession);
    } else {
        p.println(""  mCurMethod= null"");
    }
    p.println(""  mCurRootView="" + mCurRootView);
    p.println(""  mServedView="" + getServedViewLocked());
    p.println(""  mNextServedView="" + getNextServedViewLocked());
    p.println(""  mServedConnecting="" + mServedConnecting);
    if (mCurrentTextBoxAttribute != null) {
        p.println(""  mCurrentTextBoxAttribute:"");
        mCurrentTextBoxAttribute.dump(p, ""    "");
    } else {
        p.println(""  mCurrentTextBoxAttribute: null"");
    }
    p.println(""  mServedInputConnectionWrapper="" + mServedInputConnectionWrapper);
    p.println(""  mCompletions="" + Arrays.toString(mCompletions));
    p.println(""  mCursorRect="" + mCursorRect);
    p.println(""  mCursorSelStart="" + mCursorSelStart + "" mCursorSelEnd="" + mCursorSelEnd + "" mCursorCandStart="" + mCursorCandStart + "" mCursorCandEnd="" + mCursorCandEnd);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The late version includes a new method call processDump(fd, args) at the beginning of the method along with a check that might result in an early return, which was not present in the early version. This is a control dependency change (type 3). Additionally, the dumping of mCurMethod has been changed to use mCurrentInputMethodSession instead of mCurMethod. There's also an introduction of an 'if' statement around this logging, which represents another control dependency change, and since it is dependent on the state of mCurrentInputMethodSession, it leads to the type 5 change (dependent API changed). Lastly, a statement to log mCurMethod has been altered to conditional logging (changing the parameter of println from mCurMethod to mCurrentInputMethodSession) which is an other statement changed (type 4).","Despite the changes, there are no differences in the output provided by the method that would indicate a compatibility issue. The method has no return value (void) and does not throw exceptions that are handled differently. Therefore, there's no compatibility issue according to the given instructions (type 0)."
315,<android.hardware.camera2.params.OutputConfiguration: void enableSurfaceSharing()>,30,31,<android.hardware.camera2.params.OutputConfiguration: void enableSurfaceSharing()>,<android.hardware.camera2.params.OutputConfiguration: void enableSurfaceSharing()>,0,"{
    mIsShared = true;
}","{
    if (mIsMultiResolution) {
        throw new IllegalStateException(""Cannot enable surface sharing on "" + ""multi-resolution output configurations"");
    }
    mIsShared = true;
}",1,"/**
 * Enable multiple surfaces sharing the same OutputConfiguration
 *
 * <p>For advanced use cases, a camera application may require more streams than the combination
 * guaranteed by {@link CameraDevice#createCaptureSession}. In this case, more than one
 * compatible surface can be attached to an OutputConfiguration so that they map to one
 * camera stream, and the outputs share memory buffers when possible. Due to buffer sharing
 * clients should be careful when adding surface outputs that modify their input data. If such
 * case exists, camera clients should have an additional mechanism to synchronize read and write
 * access between individual consumers.</p>
 *
 * <p>Two surfaces are compatible in the below cases:</p>
 *
 * <li> Surfaces with the same size, format, dataSpace, and Surface source class. In this case,
 * {@link CameraDevice#createCaptureSessionByOutputConfigurations} is guaranteed to succeed.
 *
 * <li> Surfaces with the same size, format, and dataSpace, but different Surface source classes
 * that are generally not compatible. However, on some devices, the underlying camera device is
 * able to use the same buffer layout for both surfaces. The only way to discover if this is the
 * case is to create a capture session with that output configuration. For example, if the
 * camera device uses the same private buffer format between a SurfaceView/SurfaceTexture and a
 * MediaRecorder/MediaCodec, {@link CameraDevice#createCaptureSessionByOutputConfigurations}
 * will succeed. Otherwise, it fails with {@link
 * CameraCaptureSession.StateCallback#onConfigureFailed}.
 * </ol>
 *
 * <p>To enable surface sharing, this function must be called before {@link
 * CameraDevice#createCaptureSessionByOutputConfigurations} or {@link
 * CameraDevice#createReprocessableCaptureSessionByConfigurations}. Calling this function after
 * {@link CameraDevice#createCaptureSessionByOutputConfigurations} has no effect.</p>
 *
 * <p>Up to {@link #getMaxSharedSurfaceCount} surfaces can be shared for an OutputConfiguration.
 * The supported surfaces for sharing must be of type SurfaceTexture, SurfaceView,
 * MediaRecorder, MediaCodec, or implementation defined ImageReader.</p>
 */
","/**
 * Enable multiple surfaces sharing the same OutputConfiguration
 *
 * <p>For advanced use cases, a camera application may require more streams than the combination
 * guaranteed by {@link CameraDevice#createCaptureSession}. In this case, more than one
 * compatible surface can be attached to an OutputConfiguration so that they map to one
 * camera stream, and the outputs share memory buffers when possible. Due to buffer sharing
 * clients should be careful when adding surface outputs that modify their input data. If such
 * case exists, camera clients should have an additional mechanism to synchronize read and write
 * access between individual consumers.</p>
 *
 * <p>Two surfaces are compatible in the below cases:</p>
 *
 * <li> Surfaces with the same size, format, dataSpace, and Surface source class. In this case,
 * {@link CameraDevice#createCaptureSessionByOutputConfigurations} is guaranteed to succeed.
 *
 * <li> Surfaces with the same size, format, and dataSpace, but different Surface source classes
 * that are generally not compatible. However, on some devices, the underlying camera device is
 * able to use the same buffer layout for both surfaces. The only way to discover if this is the
 * case is to create a capture session with that output configuration. For example, if the
 * camera device uses the same private buffer format between a SurfaceView/SurfaceTexture and a
 * MediaRecorder/MediaCodec, {@link CameraDevice#createCaptureSessionByOutputConfigurations}
 * will succeed. Otherwise, it fails with {@link
 * CameraCaptureSession.StateCallback#onConfigureFailed}.
 * </ol>
 *
 * <p>To enable surface sharing, this function must be called before {@link
 * CameraDevice#createCaptureSessionByOutputConfigurations} or {@link
 * CameraDevice#createReprocessableCaptureSessionByConfigurations}. Calling this function after
 * {@link CameraDevice#createCaptureSessionByOutputConfigurations} has no effect.</p>
 *
 * <p>Up to {@link #getMaxSharedSurfaceCount} surfaces can be shared for an OutputConfiguration.
 * The supported surfaces for sharing must be of type SurfaceTexture, SurfaceView,
 * MediaRecorder, MediaCodec, or implementation defined ImageReader.</p>
 *
 * <p>This function must not be called from OuptutConfigurations created by {@link
 * #createInstancesForMultiResolutionOutput}.</p>
 *
 * @throws IllegalStateException If this OutputConfiguration is created via {@link
 * #createInstancesForMultiResolutionOutput} to back a MultiResolutionImageReader.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The late version has introduced a new control statement ('if') with an exception being thrown under a certain condition, so the change types are 2,3.","The introduction of a new conditional check that throws an exception under a certain condition (mIsMultiResolution being true) could lead to different exception handlings, thus causing a Compatibility Issue of type 2."
316,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,30,31,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,<android.view.inputmethod.InputMethodManager: void closeCurrentInput()>,0,"{
    synchronized (mH) {
        if (mCurRootView == null || mCurRootView.getView() == null) {
            Log.w(TAG, ""No current root view, ignoring closeCurrentInput()"");
            return;
        }
        try {
            mService.hideSoftInput(mClient, mCurRootView.getView().getWindowToken(), HIDE_NOT_ALWAYS, null);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    synchronized (mH) {
        if (mCurRootView == null || mCurRootView.getView() == null) {
            Log.w(TAG, ""No current root view, ignoring closeCurrentInput()"");
            return;
        }
        try {
            mService.hideSoftInput(mClient, mCurRootView.getView().getWindowToken(), HIDE_NOT_ALWAYS, null, SoftInputShowHideReason.HIDE_SOFT_INPUT);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,5,0,"The only change is an additional parameter (SoftInputShowHideReason.HIDE_SOFT_INPUT) being passed to the method mService.hideSoftInput(), which does not affect the return type or exception handling; therefore, the code change type is 5.","There is no Compatibility Issue as the method signature remains the same, there is no change in the return type or the exceptions being thrown, and the additional parameter does not alter the behavior of the method that would lead to a CI."
317,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,30,31,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,0,"{
    if (DEBUG)
        Log.v(TAG, ""finishComposingText"");
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        // Note: sendCurrentText does nothing unless mDummyMode is set
        sendCurrentText();
        endBatchEdit();
    }
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""finishComposingText"");
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        // Note: sendCurrentText does nothing unless mFallbackMode is set
        sendCurrentText();
        endBatchEdit();
        endComposingRegionEditInternal();
    }
    return true;
}",1,"/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if fallback mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There is an additional method call `endComposingRegionEditInternal()` inside the if block, and there is no change in return or exception handling statements. The comment within the code has also been modified, but since comments do not affect program execution, it's not a functional change. Therefore, the change types are 3 and 4 for the addition of a new method call and the change in comments.","Since the newly added method call `endComposingRegionEditInternal()` doesn't affect the return value (which is always true) and there is no change in exception handling, this change does not introduce a compatibility issue based on the information given. The Compatibility Issue type is 0."
318,<android.widget.SelectionActionModeHelper.TextClassificationHelper: int getTimeoutDuration()>,30,31,<android.widget.SelectionActionModeHelper.TextClassificationHelper: int getTimeoutDuration()>,<android.widget.SelectionActionModeHelper.TextClassificationHelper: int getTimeoutDuration()>,0,"{
    if (mHot) {
        return 200;
    } else {
        // selection handles or toolbar until after this timeout.
        return 500;
    }
}","{
    if (mInitialized) {
        return mViewConfiguration.getSmartSelectionInitializedTimeout();
    } else {
        // selection handles or toolbar until after this timeout.
        return mViewConfiguration.getSmartSelectionInitializingTimeout();
    }
}",1,"// TODO: Consider making this a ViewConfiguration.
","/**
 * Maximum time (in milliseconds) to wait for a textclassifier result before timing out.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statements have been changed to return different values or types, as the timeout duration is now obtained from mViewConfiguration with different methods for initialized states. Additionally, there is a change in a dependent API because the values now depend on mViewConfiguration's methods getSmartSelectionInitializedTimeout() and getSmartSelectionInitializingTimeout(). The if condition also changed from checking mHot to mInitialized, which is an expression change within the control dependency. Thus, the changes are 1,4,5.","Since the return statements have changed and the conditions for returning timeout values have been modified, the API will potentially return different values based on the state of the ViewConfiguration. Therefore, the CI type is 1."
319,"<android.app.PendingIntent: PendingIntent getForegroundService(Context,int,Intent,int)>",30,31,"<android.app.PendingIntent: PendingIntent getForegroundService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getForegroundService(Context,int,Intent,int)>",0,"{
    return buildServicePendingIntent(context, requestCode, intent, flags, ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE);
}","{
    return buildServicePendingIntent(context, requestCode, intent, flags, INTENT_SENDER_FOREGROUND_SERVICE);
}",1,"/**
 * Retrieve a PendingIntent that will start a foreground service, like calling
 * {@link Context#startForegroundService Context.startForegroundService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a foreground service, like calling
 * {@link Context#startForegroundService Context.startForegroundService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The change from ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE to INTENT_SENDER_FOREGROUND_SERVICE seems to be a change to the reference of the constant. There are no other changes visible in the provided code snippets.,This change does not cause a Compatibility Issue because it is merely a change in the reference to the constant value and not a change in the logic or output of the method itself. The value of the constant is assumed to be the same based on the information given.
320,<android.view.inputmethod.InputMethodManager: void setInputChannelLocked(InputChannel)>,30,31,<android.view.inputmethod.InputMethodManager: void setInputChannelLocked(InputChannel)>,<android.view.inputmethod.InputMethodManager: void setInputChannelLocked(InputChannel)>,0,"{
    if (mCurChannel != channel) {
        if (mCurSender != null) {
            flushPendingEventsLocked();
            mCurSender.dispose();
            mCurSender = null;
        }
        if (mCurChannel != null) {
            mCurChannel.dispose();
        }
        mCurChannel = channel;
    }
}","{
    if (mCurChannel == channel) {
        return;
    }
    if (mCurChannel != null && channel != null && mCurChannel.getToken() == channel.getToken()) {
        // avoid confusing the InputEventReceiver.
        return;
    }
    if (mCurSender != null) {
        flushPendingEventsLocked();
        mCurSender.dispose();
        mCurSender = null;
    }
    if (mCurChannel != null) {
        mCurChannel.dispose();
    }
    mCurChannel = channel;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",0,"There was a refactoring in the control dependency since new returning conditions have been introduced to exit the method early. Therefore, the change type would be 3 due to control dependency change. Additionally, the change type is 1 because new return statements have been added.","Despite the control changes and the return statements added, the method's behavior stays consistent regarding its outcome. The new conditions added simply provide early exits under circumstances that would have led to the same result in the earlier version of the method; hence, no Compatibility Issue arises, which is predicated as 0."
321,<android.os.BugreportManager.DumpstateListener: void onProgress(int)>,30,31,<android.os.BugreportManager.DumpstateListener: void onProgress(int)>,<android.os.BugreportManager.DumpstateListener: void onProgress(int)>,0,"{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onProgress(progress);
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}","{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onProgress(progress));
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The implementation between the two versions only has a stylistic change (removal of the braces around the lambda expression), which does not affect the behavior of the method.","There is no behavior change between the two versions of the method, thus no Compatibility Issue arises."
322,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",30,31,"<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>","<android.app.Activity: void setVrModeEnabled(boolean,ComponentName)>",0,"{
    try {
        if (ActivityTaskManager.getService().setVrMode(mToken, enabled, requestedComponent) != 0) {
            throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
        }
    } catch (RemoteException e) {
    // pass
    }
}","{
    if (ActivityClient.getInstance().setVrMode(mToken, enabled, requestedComponent) != 0) {
        throw new PackageManager.NameNotFoundException(requestedComponent.flattenToString());
    }
}",1,"/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
","/**
 * Enable or disable virtual reality (VR) mode for this Activity.
 *
 * <p>VR mode is a hint to Android system to switch to a mode optimized for VR applications
 * while this Activity has user focus.</p>
 *
 * <p>It is recommended that applications additionally declare
 * {@link android.R.attr#enableVrMode} in their manifest to allow for smooth activity
 * transitions when switching between VR activities.</p>
 *
 * <p>If the requested {@link android.service.vr.VrListenerService} component is not available,
 * VR mode will not be started.  Developers can handle this case as follows:</p>
 *
 * <pre>
 * String servicePackage = ""com.whatever.app"";
 * String serviceClass = ""com.whatever.app.MyVrListenerService"";
 *
 * // Name of the component of the VrListenerService to start.
 * ComponentName serviceComponent = new ComponentName(servicePackage, serviceClass);
 *
 * try {
 * setVrModeEnabled(true, myComponentName);
 * } catch (PackageManager.NameNotFoundException e) {
 * List&lt;ApplicationInfo> installed = getPackageManager().getInstalledApplications(0);
 * boolean isInstalled = false;
 * for (ApplicationInfo app : installed) {
 * if (app.packageName.equals(servicePackage)) {
 * isInstalled = true;
 * break;
 * }
 * }
 * if (isInstalled) {
 * // Package is installed, but not enabled in Settings.  Let user enable it.
 * startActivity(new Intent(Settings.ACTION_VR_LISTENER_SETTINGS));
 * } else {
 * // Package is not installed.  Send an intent to download this.
 * sentIntentToLaunchAppStore(servicePackage);
 * }
 * }
 * </pre>
 *
 * @param enabled {@code true} to enable this mode.
 * @param requestedComponent the name of the component to use as a
 * {@link android.service.vr.VrListenerService} while VR mode is enabled.
 *
 * @throws android.content.pm.PackageManager.NameNotFoundException if the given component
 * to run as a {@link android.service.vr.VrListenerService} is not installed, or has
 * not been enabled in user settings.
 *
 * @see android.content.pm.PackageManager#FEATURE_VR_MODE_HIGH_PERFORMANCE
 * @see android.service.vr.VrListenerService
 * @see android.provider.Settings#ACTION_VR_LISTENER_SETTINGS
 * @see android.R.attr#enableVrMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5",2,"The try-catch block has been removed, changing exception handling behavior. The call to ActivityTaskManager.getService().setVrMode() has been replaced by ActivityClient.getInstance().setVrMode(), altering the dependent API and the control dependency, because the try block has been removed entirely, so the change type is 2,3,5.","The late version allows potential exceptions to propagate rather than catching RemoteException. The exception handling behavior is different between the two versions, potentially leading to a Compatibility Issue due to different exception handlings, thus CI type is 2."
323,"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextAfterCursor(int,int)>",30,31,"<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextAfterCursor(int,int)>","<android.view.inputmethod.InputConnectionWrapper: CharSequence getTextAfterCursor(int,int)>",0,"{
    return mTarget.getTextAfterCursor(n, flags);
}","{
    Preconditions.checkArgumentNonnegative(n);
    return mTarget.getTextAfterCursor(n, flags);
}",1,"/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 */
","/**
 * {@inheritDoc}
 * @throws NullPointerException if the target is {@code null}.
 * @throws IllegalArgumentException if {@code length} is negative.
 */
",-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,4,0,"A new statement `Preconditions.checkArgumentNonnegative(n);` has been added before the return statement, so the code change type is 4.","The added statement only checks the input argument `n` for non-negativity, but does not change the behavior of the API regarding the return type, return value, or exceptions thrown. Hence, it does not introduce a Compatibility Issue, and the CI type is 0."
324,<android.widget.EdgeEffect: void onRelease()>,30,31,<android.widget.EdgeEffect: void onRelease()>,<android.widget.EdgeEffect: void onRelease()>,0,"{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}","{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mVelocity = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}",1,"/**
 * Call when the object is released after being pulled.
 * This will begin the ""decay"" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */
","/**
 * Call when the object is released after being pulled.
 * This will begin the ""decay"" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late version of the code includes a new assignment statement: mVelocity = 0.f;. This is an additional operation that wasn't present in the early version. Hence, the change type is 4 (Other statement changed).","The addition of the assignment statement doesn't affect the method's return type or throw new exceptions, and it's not related to any control dependency. Therefore, it should not cause a Compatibility Issue as it won't affect how the API behaves from the caller's perspective. The method does not return a value, and the assignment does not cause it to throw an exception or return a different type of result. Thus, there is no Compatibility Issue; the pred_CI is 0."
325,<android.text.format.Time.TimeCalculator: String format(String)>,30,31,<android.text.format.Time.TimeCalculator: String format(String)>,<android.text.format.Time.TimeCalculator: String format(String)>,0,"{
    if (format == null) {
        format = ""%c"";
    }
    TimeFormatter formatter = new TimeFormatter();
    return formatter.format(format, wallTime, zoneInfo);
}","{
    if (format == null) {
        format = ""%c"";
    }
    TimeFormatter formatter = new TimeFormatter();
    return formatter.format(format, wallTime, mZoneInfoData);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,There's a change in a variable name from zoneInfo to mZoneInfoData. This change is classified as 4 (Other statement changed) because it involves a direct variable replacement without altering control flow or method signature.,"The change from zoneInfo to mZoneInfoData does not constitute a compatibility issue as long as mZoneInfoData represents the same data previously held by zoneInfo. Since this is an internal variable change and does not affect the method's input parameters or overall behavior, it does not lead to a CI."
326,"<android.view.SurfaceControl.Transaction: Transaction setFrameRate(SurfaceControl,float,int)>",30,31,"<android.view.SurfaceControl.Transaction: Transaction setFrameRate(SurfaceControl,float,int)>","<android.view.SurfaceControl.Transaction: Transaction setFrameRate(SurfaceControl,float,int)>",0,"{
    checkPreconditions(sc);
    nativeSetFrameRate(mNativeObject, sc.mNativeObject, frameRate, compatibility);
    return this;
}","{
    return setFrameRate(sc, frameRate, compatibility, Surface.CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS);
}",1,"/**
 * Sets the intended frame rate for the surface {@link SurfaceControl}.
 * <p>
 * On devices that are capable of running the display at different refresh rates, the system
 * may choose a display refresh rate to better match this surface's frame rate. Usage of
 * this API won't directly affect the application's frame production pipeline. However,
 * because the system may change the display refresh rate, calls to this function may result
 * in changes to Choreographer callback timings, and changes to the time interval at which
 * the system releases buffers back to the application.
 *
 * @param sc The SurfaceControl to specify the frame rate of.
 * @param frameRate The intended frame rate for this surface, in frames per second. 0 is a
 * special value that indicates the app will accept the system's choice for
 * the display frame rate, which is the default behavior if this function
 * isn't called. The frameRate param does <em>not</em> need to be a valid
 * refresh rate for this device's display - e.g., it's fine to pass 30fps
 * to a device that can only run the display at 60fps.
 * @param compatibility The frame rate compatibility of this surface. The compatibility
 * value may influence the system's choice of display frame rate. See
 * the Surface.FRAME_RATE_COMPATIBILITY_* values for more info.
 * @return This transaction object.
 */
","/**
 * Sets the intended frame rate for this surface. Any switching of refresh rates is
 * most probably going to be seamless.
 *
 * @see #setFrameRate(SurfaceControl, float, int, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to call another overload of setFrameRate with an additional parameter instead of calling nativeSetFrameRate directly, so the change type is 5.","There is no compatibility issue to indicate because the method ultimately calls an overload of itself, likely to incorporate a default behavior extension with an additional argument. This change doesn't alter the return type or the exceptions thrown and keeps the signature compatible."
327,<android.content.res.XmlBlock.Parser: CharSequence getPooledString(int)>,30,31,<android.content.res.XmlBlock.Parser: CharSequence getPooledString(int)>,<android.content.res.XmlBlock.Parser: CharSequence getPooledString(int)>,0,"{
    return mStrings.get(id);
}","{
    return mStrings.getSequence(id);
}",1,"/*package*/
",,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The method invoked has changed from mStrings.get(id) to mStrings.getSequence(id), indicating a change in the dependent API; therefore, the code change type is 1,5.","Since there's a change in the method used to fetch the string (from get to getSequence), the returned CharSequence could potentially be different, leading to a CI type of 1."
328,"<android.view.ViewGroup: void addView(View,int)>",30,31,"<android.view.ViewGroup: void addView(View,int)>","<android.view.ViewGroup: void addView(View,int)>",0,"{
    if (child == null) {
        throw new IllegalArgumentException(""Cannot add a null child view to a ViewGroup"");
    }
    LayoutParams params = child.getLayoutParams();
    if (params == null) {
        params = generateDefaultLayoutParams();
        if (params == null) {
            throw new IllegalArgumentException(""generateDefaultLayoutParams() cannot return null"");
        }
    }
    addView(child, index, params);
}","{
    if (child == null) {
        throw new IllegalArgumentException(""Cannot add a null child view to a ViewGroup"");
    }
    LayoutParams params = child.getLayoutParams();
    if (params == null) {
        params = generateDefaultLayoutParams();
        if (params == null) {
            throw new IllegalArgumentException(""generateDefaultLayoutParams() cannot return null  "");
        }
    }
    addView(child, index, params);
}",1,"/**
 * Adds a child view. If no layout parameters are already set on the child, the
 * default parameters for this ViewGroup are set on the child.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 *
 * @see #generateDefaultLayoutParams()
 */
","/**
 * Adds a child view. If no layout parameters are already set on the child, the
 * default parameters for this ViewGroup are set on the child.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 *
 * @param child the child view to add
 * @param index the position at which to add the child
 *
 * @see #generateDefaultLayoutParams()
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between the two versions; the change is only in the string literal of the exception message where additional spaces have been added at the end of the string. Since this does not affect the code's logic or behavior, it's considered no change.","No Compatibility Issue arises because there are no changes in return values, thrown exceptions, control flow, or any other behavior of the API."
330,<android.app.NotificationChannel: int hashCode()>,30,31,<android.app.NotificationChannel: int hashCode()>,<android.app.NotificationChannel: int hashCode()>,0,"{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getGroup(), getAudioAttributes(), isBlockable(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp, mOriginalImportance, mParentId, mConversationId, mDemoted, mImportantConvo);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}","{
    int result = Objects.hash(getId(), getName(), mDesc, getImportance(), mBypassDnd, getLockscreenVisibility(), getSound(), mLights, getLightColor(), getUserLockedFields(), isFgServiceShown(), mVibrationEnabled, mShowBadge, isDeleted(), getDeletedTimeMs(), getGroup(), getAudioAttributes(), isBlockable(), mAllowBubbles, mImportanceLockedByOEM, mImportanceLockedDefaultApp, mOriginalImportance, mParentId, mConversationId, mDemoted, mImportantConvo);
    result = 31 * result + Arrays.hashCode(mVibration);
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode computation has changed by including an additional field, getDeletedTimeMs(), which alters the result of the hashCode method. Therefore, the change type is 1 and 4.","Due to the addition of getDeletedTimeMs() in the hash calculation, the returned hash value is potentially different, which constitutes a compatibility issue by potentially returning a different value, setting the CI type to 1."
331,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,30,31,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,<android.app.PendingIntent: UserHandle getCreatorUserHandle()>,0,"{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    int uid = getCachedInfo().getCreatorUid();
    return UserHandle.getUserHandleForUid(uid);
}",1,"/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The user handle of the PendingIntent
 */
",-1,[@Nullable],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from using 'ActivityManager.getService().getUidForIntentSender' and returning with a conditional operator to directly getting the UID from 'getCachedInfo().getCreatorUid()' and using 'UserHandle.getUserHandleForUid'. The whole structure of try-catch has been removed, and the code now directly fetches and processes the UID without any exception handling. Additionally, the annotation has changed from [@Nullable] to [@NonNull], which implies a different expectation of the return value regarding nullability. Hence, the change types are 1 and 5.","The method potentially returns different values because the previous implementation could return null under certain circumstances (uid <= 0), whereas the new version does not consider this case and always returns a UserHandle object. Moreover, the change in annotation from Nullable to NonNull indicates an altered contract regarding the return type, and clients relying on the method returning null in some cases would now face a compatibility issue, so the CI type is 1."
332,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>",30,31,"<android.view.ViewGroup: boolean requestFocus(int,Rect)>","<android.view.ViewGroup: boolean requestFocus(int,Rect)>",0,"{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be one of FOCUS_BEFORE_DESCENDANTS,"" + "" FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}","{
    if (DBG) {
        System.out.println(this + "" ViewGroup.requestFocus direction="" + direction);
    }
    int descendantFocusability = getDescendantFocusability();
    boolean result;
    switch(descendantFocusability) {
        case FOCUS_BLOCK_DESCENDANTS:
            result = super.requestFocus(direction, previouslyFocusedRect);
            break;
        case FOCUS_BEFORE_DESCENDANTS:
            {
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                result = took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
                break;
            }
        case FOCUS_AFTER_DESCENDANTS:
            {
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                result = took ? took : super.requestFocus(direction, previouslyFocusedRect);
                break;
            }
        default:
            throw new IllegalStateException(""descendant focusability must be "" + ""one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "" + ""but is "" + descendantFocusability);
    }
    if (result && !isLayoutValid() && ((mPrivateFlags & PFLAG_WANTS_FOCUS) == 0)) {
        mPrivateFlags |= PFLAG_WANTS_FOCUS;
    }
    return result;
}",1,"/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
","/**
 * {@inheritDoc}
 *
 * Looks for a view to give focus to respecting the setting specified by
 * {@link #getDescendantFocusability()}.
 *
 * Uses {@link #onRequestFocusInDescendants(int, android.graphics.Rect)} to
 * find focus within the children of this group when appropriate.
 *
 * @see #FOCUS_BEFORE_DESCENDANTS
 * @see #FOCUS_AFTER_DESCENDANTS
 * @see #FOCUS_BLOCK_DESCENDANTS
 * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There are no code changes that affect the behavior of the program; only the error message within an exception throw statement has been modified to add spaces for clarity. This does not change how the API functions.,"Because there are no changes to the execution or behavior of the method, there is no compatibility issue between the two versions."
333,<android.widget.Gallery: void trackMotionScroll(int)>,30,31,<android.widget.Gallery: void trackMotionScroll(int)>,<android.widget.Gallery: void trackMotionScroll(int)>,0,"{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    final View selChild = mSelectedChild;
    if (selChild != null) {
        final int childLeft = selChild.getLeft();
        final int childCenter = selChild.getWidth() / 2;
        final int galleryCenter = getWidth() / 2;
        mSelectedCenterOffset = childLeft + childCenter - galleryCenter;
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
    invalidate();
}","{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    final View selChild = mSelectedChild;
    if (selChild != null) {
        final int childLeft = selChild.getLeft();
        final int childCenter = selChild.getWidth() / 2;
        final int galleryCenter = getWidth() / 2;
        mSelectedCenterOffset = childLeft + childCenter - galleryCenter;
    }
    // placeholder values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
    invalidate();
}",1,"/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
","/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the replacement of the comment ""dummy values"" with ""placeholder values"". This does not affect the actual behavior or output of the code, so the change type is 4.","There is no Compatibility Issue, since the code's operational behavior has not been altered. The change is purely in the comments, which does not affect code execution."
334,<android.view.SurfaceView: void onDetachedFromWindow()>,30,31,<android.view.SurfaceView: void onDetachedFromWindow()>,<android.view.SurfaceView: void onDetachedFromWindow()>,0,"{
    ViewRootImpl viewRoot = getViewRootImpl();
    // the SurfaceHolder forward, most live wallpapers do it.
    if (viewRoot != null) {
        viewRoot.removeSurfaceChangedCallback(this);
    }
    mAttachedToWindow = false;
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    while (mPendingReportDraws > 0) {
        notifyDrawFinished();
    }
    mRequestedVisible = false;
    updateSurface();
    releaseSurfaces();
    // detached.
    if (mSurfacePackage != null) {
        mSurfacePackage.release();
        mSurfacePackage = null;
    }
    mHaveFrame = false;
    super.onDetachedFromWindow();
}","{
    ViewRootImpl viewRoot = getViewRootImpl();
    // the SurfaceHolder forward, most live wallpapers do it.
    if (viewRoot != null) {
        viewRoot.removeSurfaceChangedCallback(this);
    }
    mAttachedToWindow = false;
    if (mGlobalListenersAdded) {
        ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnScrollChangedListener(mScrollChangedListener);
        observer.removeOnPreDrawListener(mDrawListener);
        mGlobalListenersAdded = false;
    }
    while (mPendingReportDraws > 0) {
        notifyDrawFinished();
    }
    mRequestedVisible = false;
    updateSurface();
    tryReleaseSurfaces();
    // detached.
    if (mSurfacePackage != null) {
        final SurfaceControl sc = mSurfacePackage.getSurfaceControl();
        if (sc != null && sc.isValid()) {
            mTmpTransaction.reparent(sc, null).apply();
        }
        mSurfacePackage.release();
        mSurfacePackage = null;
    }
    mHaveFrame = false;
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The method call releaseSurfaces() has been changed to tryReleaseSurfaces(), and there is an added code block involving SurfaceControl and a transaction to reparent the surface. Therefore, the change types are 3 (control dependency change, added block of code) and 4 (other statement change due to the method name change).","The added code block is conditionally executed depending on whether mSurfacePackage is not null and the SurfaceControl object retrieved from it is valid. This block performs a reparenting operation but does not affect the API's outward behavior, nor does it introduce new return values or exceptions from the API itself. The tryReleaseSurfaces() method is also an internal change and should not impact the expected behavior of onDetachedFromWindow() from the perspective of an API consumer. Hence, there's no Compatibility Issue in terms of different return values or exception handlings."
336,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,30,31,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(getOpPackageName(), getAttributionTag());
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.startDiscovery(mAttributionSource);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth, wait for {@link #ACTION_STATE_CHANGED}
 * with {@link #STATE_ON} to get the updated value.
 * <p>If a device is currently bonding, this request will be queued and executed once that
 * device has finished bonding. If a request is already queued, this request will be ignored.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothScanPermission, @RequiresBluetoothLocationPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method signature hasn't changed, but the implementation calls a method with a different parameter (mService.startDiscovery(mAttributionSource) instead of mService.startDiscovery(getOpPackageName(), getAttributionTag())), indicating a Dependent API changed (code change type 5). Additionally, return statements are involved as the result of the dependent API call may be different, so code change type 1 is also applicable.","Since the dependent API method call has altered to pass a different argument type, this could lead to a different return value. Thus, a Compatibility Issue caused by a potential different return value would be code type 1. There is no indication of changes in exception handling, so no CI code 2 is detected."
337,"<android.view.inputmethod.EditorInfo: CharSequence getInitialTextAfterCursor(int,int)>",30,31,"<android.view.inputmethod.EditorInfo: CharSequence getInitialTextAfterCursor(int,int)>","<android.view.inputmethod.EditorInfo: CharSequence getInitialTextAfterCursor(int,int)>",0,"{
    return mInitialSurroundingText.getInitialTextAfterCursor(length, flags);
}","{
    if (mInitialSurroundingText == null) {
        return null;
    }
    int surroundingTextLength = mInitialSurroundingText.getText().length();
    int selEnd = Math.max(mInitialSurroundingText.getSelectionStart(), mInitialSurroundingText.getSelectionEnd());
    int n = Math.min(length, surroundingTextLength - selEnd);
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selEnd, selEnd + n) : TextUtils.substring(mInitialSurroundingText.getText(), selEnd, selEnd + n);
}",1,"/**
 * Get <var>length</var> characters of text after the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text after the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text after the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */
","/**
 * Get <var>length</var> characters of text after the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text after the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text after the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version of the code introduces a null check for mInitialSurroundingText, and the logic for getting the text after the cursor is now checking for flags and calculating the length. It's not just a direct call to mInitialSurroundingText.getInitialTextAfterCursor as it was in the early version. Therefore, the changes include new variable initializations, a new if condition, and changes to the return statement to account for flagsâ€”this qualifies as changes in return statement, control dependency, and other statement, corresponding to change types 1, 3, and 4.","The introduction of a null check for mInitialSurroundingText can now potentially lead to a different return value (null instead of proceeding with the rest of the code), and the changed logic for calculating the text to return can lead to different results based on the same inputs. Therefore, the changes can lead to the API returning different results, corresponding to CI type 1."
338,<android.bluetooth.BluetoothSocket: void connect()>,30,31,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.getSocketManager().connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0) {
            throw new IOException(""bt socket connect failed"");
        }
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                throw new IOException(""bt socket closed"");
            }
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService();
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.getSocketManager().connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0) {
            throw new IOException(""bt socket connect failed"");
        }
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                throw new IOException(""bt socket closed"");
            }
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException(""unable to send RPC: "" + e.getMessage());
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 *
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 *
 * @throws IOException on error, for example connection failure
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API call BluetoothAdapter.getDefaultAdapter().getBluetoothService(null) has been replaced with BluetoothAdapter.getDefaultAdapter().getBluetoothService(), where the parameter has been removed. Thus, the change is a Dependent API changed, which is indicated by code change type 5.","As the change only impacts how the Bluetooth service is retrieved from the BluetoothAdapter and does not directly impact the behavior of the connect method, and no changes are made to function return type, values, or exception handling that would affect client code, there is no Compatibility Issue. The method's functionality remains the same assuming that getDefaultAdapter().getBluetoothService() works as before without needing a null parameter."
339,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,30,31,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,<android.bluetooth.BluetoothGatt: boolean beginReliableWrite()>,0,"{
    if (VDBG)
        Log.d(TAG, ""beginReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""beginReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without committing any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */
","/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without committing any values on the
 * remote device.
 *
 * @return true, if the reliable write transaction has been initiated
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API `mService.beginReliableWrite(mClientIf, mDevice.getAddress())` in the early version has changed to `mService.beginReliableWrite(mClientIf, mDevice.getAddress(), mAttributionSource)` with an additional parameter in the late version, which is an Other statement and a Dependent API change, so the change type is 4,5.","The additional parameter `mAttributionSource` in the method call does not affect the returned value, as the method always returns `true` after the call. The error handling for `RemoteException` hasnâ€™t changed, so the behavior remains the same for that exception. There is no change in the semantics that could cause a Compatibility Issue, which means no CI is detected. The method's return value is not impacted by this internal API call change since the returned value is determined by the exception presence rather than the API call's result. Hence, the CI type is 0."
340,"<android.app.Activity: void performResume(boolean,String)>",30,31,"<android.app.Activity: void performResume(boolean,String)>","<android.app.Activity: void performResume(boolean,String)>",0,"{
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
}","{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_WINDOW_MANAGER)) {
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, ""performResume:"" + mComponent.getClassName());
    }
    dispatchActivityPreResumed();
    performRestart(true, /* start */
    reason);
    mFragments.execPendingActions();
    mLastNonConfigurationInstances = null;
    if (mAutoFillResetNeeded) {
        // When Activity is destroyed in paused state, and relaunch activity, there will be
        // extra onResume and onPause event,  ignore the first onResume and onPause.
        // see ActivityThread.handleRelaunchActivity()
        mAutoFillIgnoreFirstResumePause = followedByPause;
        if (mAutoFillIgnoreFirstResumePause && DEBUG_LIFECYCLE) {
            Slog.v(TAG, ""autofill will ignore first pause when relaunching "" + this);
        }
    }
    mCalled = false;
    // mResumed is set by the instrumentation
    mInstrumentation.callActivityOnResume(this);
    EventLogTags.writeWmOnResumeCalled(mIdent, getComponentName().getClassName(), reason);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onResume()"");
    }
    // invisible activities must be finished before onResume() completes
    if (!mVisibleFromClient && !mFinished) {
        Log.w(TAG, ""An activity without a UI must call finish() before onResume() completes"");
        if (getApplicationInfo().targetSdkVersion > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
            throw new IllegalStateException(""Activity "" + mComponent.toShortString() + "" did not call finish() prior to onResume() completing"");
        }
    }
    // Now really resume, and install the current status bar and menu.
    mCalled = false;
    mFragments.dispatchResume();
    mFragments.execPendingActions();
    onPostResume();
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPostResume()"");
    }
    dispatchActivityPostResumed();
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new Trace statements added at the beginning after the Trace.isTagEnabled() check and at the end before the method concludes, but no change in the flow of execution or behavior of the method, hence the code change type is 4.","The added Trace statements do not impact the API's behavior; they are only for logging purposes. Thus, there would be no Compatibility Issue, hence the CI type is 0."
341,<android.net.Uri.HierarchicalUri: String toString()>,30,31,<android.net.Uri.HierarchicalUri: String toString()>,<android.net.Uri.HierarchicalUri: String toString()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean cached = (uriString != NOT_CACHED);
    return cached ? uriString : (uriString = makeUriString());
}","{
    @SuppressWarnings(""StringEquality"") boolean cached = (uriString != NotCachedHolder.NOT_CACHED);
    return cached ? uriString : (uriString = makeUriString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"There has been a change where `NOT_CACHED` has been replaced with `NotCachedHolder.NOT_CACHED` due to the introduction of a new holder class for the constant. Thus, the dependent API class definition has changed, so the change type is 5.","Even though the source for the constant `NOT_CACHED` has changed, the actual behavior of the `toString()` method when it comes to constructing the URI string has not been affected. Therefore, there is no compatibility issue here; the comparison is still functionally identical assuming `NotCachedHolder.NOT_CACHED` equals `NOT_CACHED`. Hence, the CI type is 0."
342,"<android.hardware.camera2.params.MandatoryStreamCombination.Builder.SizeComparator: int compare(Size,Size)>",30,31,"<android.hardware.camera2.params.MandatoryStreamCombination.Builder.SizeComparator: int compare(Size,Size)>","<android.hardware.camera2.params.MandatoryStreamCombination.Builder.SizeComparator: int compare(Size,Size)>",0,"{
    return compareSizes(lhs.getWidth(), lhs.getHeight(), rhs.getWidth(), rhs.getHeight());
}","{
    return StreamConfigurationMap.compareSizes(lhs.getWidth(), lhs.getHeight(), rhs.getWidth(), rhs.getHeight());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the compare method now calls a static method from the StreamConfigurationMap class rather than a local compareSizes method. However, assuming the StreamConfigurationMap.compareSizes method behaves identically to the local compareSizes method that it replaced, the change should not affect the outcome of comparisons, hence the code change type is 5 (Dependent API changed).","There is no indication that the behaviour of the comparison has changed. If the static method from StreamConfigurationMap behaves the same way as the previous local compareSizes method, there should be no change in how the objects are compared and no compatibility issue should arise. Hence, the pred_CI code is 0 (No Compatibility Issue)."
344,"<android.content.ContentProvider: boolean checkUser(int,int,Context)>",30,31,"<android.content.ContentProvider: boolean checkUser(int,int,Context)>","<android.content.ContentProvider: boolean checkUser(int,int,Context)>",0,"{
    if (UserHandle.getUserId(uid) == context.getUserId() || mSingleUser) {
        return true;
    }
    return context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PERMISSION_GRANTED || context.checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PERMISSION_GRANTED;
}","{
    if (UserHandle.getUserId(uid) == context.getUserId() || mSingleUser) {
        return true;
    }
    return context.checkPermission(INTERACT_ACROSS_USERS, pid, uid) == PackageManager.PERMISSION_GRANTED || context.checkPermission(INTERACT_ACROSS_USERS_FULL, pid, uid) == PackageManager.PERMISSION_GRANTED;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is only in how PERMISSION_GRANTED is being accessed; it's changed from directly accessing the PERMISSION_GRANTED constant to accessing it through the PackageManager class. So, the code change type is 5.","Since PERMISSION_GRANTED is a constant, and its value has not changed between versions, just the way it is accessed has changed, this would not cause a different behavior in the API. Therefore, no compatibility issue arises from this change."
345,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,30,31,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,<android.content.pm.LauncherActivityInfo: CharSequence getLabel()>,0,"{
    // TODO: Go through LauncherAppsService
    return mActivityInfo.loadLabel(mPm);
}","{
    // TODO: Go through LauncherAppsService
    return getActivityInfo().loadLabel(mPm);
}",1,"/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
","/**
 * Retrieves the label for the activity.
 *
 * @return The label for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed to call `getActivityInfo()` instead of directly using `mActivityInfo` to load the label. Therefore, the code change type is 5, because there is a change regarding a dependent API.","Assuming `getActivityInfo()` reliably returns `mActivityInfo`, i.e., the result of the call provides the same object, there is no change in behavior in terms of the outcome of `loadLabel(mPm)`. As such, there would be no compatibility issue as yield the same return value."
346,<android.view.Display: void getRealSize(Point)>,30,31,<android.view.Display: void getRealSize(Point)>,<android.view.Display: void getRealSize(Point)>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        outSize.x = mDisplayInfo.logicalWidth;
        outSize.y = mDisplayInfo.logicalHeight;
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustSize(outSize, mDisplayInfo.rotation);
        }
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            final Rect bounds = mResources.getConfiguration().windowConfiguration.getMaxBounds();
            outSize.x = bounds.width();
            outSize.y = bounds.height();
            if (DEBUG) {
                Log.d(TAG, ""getRealSize determined from max bounds: "" + outSize);
            }
            // should already reflect the expected rotation.
            return;
        }
        outSize.x = mDisplayInfo.logicalWidth;
        outSize.y = mDisplayInfo.logicalHeight;
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustSize(outSize, mDisplayInfo.rotation);
        }
    }
}",1,"/**
 * Gets the real size of the display without subtracting any window decor or
 * applying any compatibility scale factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * </p><p>
 * The real size may be smaller than the physical size of the screen when the
 * window manager is emulating a smaller display (using adb shell wm size).
 * </p>
 *
 * @param outSize Set to the real size of the display.
 */
","/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealSize} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outSize Set to the real size of the display.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method now synchronizes on a different lock object (synchronized (mLock)), the logic within the synchronized block has changed (by introducing an 'if' statement), and additional assignment to outSize.x and outSize.y using getMaxBounds() has been added. The return statement is also newly introduced under certain conditions. Therefore, the code changes types are 1,3,4.","Since there's a new control flow that potentially affects which value is assigned to outSize and an early return in some situations, it could lead to different return values. Hence, the CI type is 1."
348,"<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doMeasureFullBackup(long,int,IBackupManager,int)>",0,"{
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    FullBackupDataOutput measureOutput = new FullBackupDataOutput(quotaBytes, transportFlags);
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(measureOutput);
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, measureOutput.getSize());
        } catch (RemoteException e) {
        // timeout, so we're safe
        }
    }
}","{
    FullBackupDataOutput measureOutput = new FullBackupDataOutput(quotaBytes, transportFlags);
    waitForSharedPrefs();
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onFullBackup(measureOutput);
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup[M] ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, measureOutput.getSize());
        } catch (RemoteException e) {
        // timeout, so we're safe
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The order of statements has changed, moving the 'final long ident = Binder.clearCallingIdentity();' line down after 'waitForSharedPrefs();'. No other changes are observed, so the change type is 4.","The internal reordering of code statements does not affect the outward behavior of the method. The method's signature and return type remain unchanged, and the control flow of the method is the same. Hence, there is no compatibility issue."
349,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",30,31,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,4,0,"The invocation of the `broadcastIntentWithFeature` method has been altered to include `null` for a new parameter, but this is an addition of a comment (`/*excludedPermissions=*/`) which does not impact the functionality; it just adds clarity to the code, so the code change type is 4.","There is no compatibility issue as the behavior of the method has not changed. It still takes the same arguments and performs the same operations. The introduction of a comment does not affect the execution or the outcome of the method. The `null` placeholder appears to indicate that an additional parameter has been allowed in the `broadcastIntentWithFeature` call without changing the actual parameter being passed (which remains `AppOpsManager.OP_NONE`), thus there's no compatibility issue."
350,<android.bluetooth.BluetoothGatt: boolean discoverServices()>,30,31,<android.bluetooth.BluetoothGatt: boolean discoverServices()>,<android.bluetooth.BluetoothGatt: boolean discoverServices()>,0,"{
    if (DBG)
        Log.d(TAG, ""discoverServices() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    mServices.clear();
    try {
        mService.discoverServices(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""discoverServices() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    mServices.clear();
    try {
        mService.discoverServices(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Discovers services offered by a remote device as well as their
 * characteristics and descriptors.
 *
 * <p>This is an asynchronous operation. Once service discovery is completed,
 * the {@link BluetoothGattCallback#onServicesDiscovered} callback is
 * triggered. If the discovery was successful, the remote services can be
 * retrieved using the {@link #getServices} function.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the remote service discovery has been started
 */
","/**
 * Discovers services offered by a remote device as well as their
 * characteristics and descriptors.
 *
 * <p>This is an asynchronous operation. Once service discovery is completed,
 * the {@link BluetoothGattCallback#onServicesDiscovered} callback is
 * triggered. If the discovery was successful, the remote services can be
 * retrieved using the {@link #getServices} function.
 *
 * @return true, if the remote service discovery has been started
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the arguments of the method call mService.discoverServices(), where a new parameter mAttributionSource is added. This is classified as a change in the dependent API, which is code change type 5. Additionally, annotations have been added, but these do not change the behavior of the code, so they are not considered a CI. The annotations impose permissions requirements, but since they do not alter the executed code, they have no impact on the return value or the exceptions thrown, thus they are classified under change 4.","The introduction of a new parameter in the method call does not inherently cause a compatibility issue because it does not change the return type or value or change exception handling. The method still returns either true or false dependent on the same conditions as before. Therefore, there is no compatibility issue (type 0)."
351,<android.app.Activity: void startLockTask()>,30,31,<android.app.Activity: void startLockTask()>,<android.app.Activity: void startLockTask()>,0,"{
    try {
        ActivityTaskManager.getService().startLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}","{
    ActivityClient.getInstance().startLockTaskModeByToken(mToken);
}",1,"/**
 * Request to put this activity in a mode where the user is locked to a restricted set of
 * applications.
 *
 * <p>If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns {@code true}
 * for this component, the current task will be launched directly into LockTask mode. Only apps
 * whitelisted by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])} can
 * be launched while LockTask mode is active. The user will not be able to leave this mode
 * until this activity calls {@link #stopLockTask()}. Calling this method while the device is
 * already in LockTask mode has no effect.
 *
 * <p>Otherwise, the current task will be launched into screen pinning mode. In this case, the
 * system will prompt the user with a dialog requesting permission to use this mode.
 * The user can exit at any time through instructions shown on the request dialog. Calling
 * {@link #stopLockTask()} will also terminate this mode.
 *
 * <p><strong>Note:</strong> this method can only be called when the activity is foreground.
 * That is, between {@link #onResume()} and {@link #onPause()}.
 *
 * @see #stopLockTask()
 * @see android.R.attr#lockTaskMode
 */
","/**
 * Request to put this activity in a mode where the user is locked to a restricted set of
 * applications.
 *
 * <p>If {@link DevicePolicyManager#isLockTaskPermitted(String)} returns {@code true}
 * for this component, the current task will be launched directly into LockTask mode. Only apps
 * allowlisted by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])} can
 * be launched while LockTask mode is active. The user will not be able to leave this mode
 * until this activity calls {@link #stopLockTask()}. Calling this method while the device is
 * already in LockTask mode has no effect.
 *
 * <p>Otherwise, the current task will be launched into screen pinning mode. In this case, the
 * system will prompt the user with a dialog requesting permission to use this mode.
 * The user can exit at any time through instructions shown on the request dialog. Calling
 * {@link #stopLockTask()} will also terminate this mode.
 *
 * <p><strong>Note:</strong> this method can only be called when the activity is foreground.
 * That is, between {@link #onResume()} and {@link #onPause()}.
 *
 * @see #stopLockTask()
 * @see android.R.attr#lockTaskMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has switched from using ActivityTaskManager.getService().startLockTaskModeByToken(mToken) directly to a singleton method call ActivityClient.getInstance().startLockTaskModeByToken(mToken), which can be an internal refactoring. The structure of the code and exception handling has not changed; there's no try-catch block in the late version, suggesting that RemoteException is not expected to be thrown from ActivityClient.getInstance(). The Singleton pattern could encapsulate the RemoteException, or it handles it differently. So the change type is 4,5 due to the changed method call and the removal of the try-catch block.","There is no Compatibility Issue because the method's contract seems to remain the same, and even if the RemoteException was thrown in the early version, it was swallowed, so it would not affect the caller. There is no change in behavior from the perspective of the caller between the two versions, since either way, no exception is thrown to the caller, and there is no return value that could change."
353,<android.bluetooth.BluetoothDevice: String getAlias()>,30,31,<android.bluetooth.BluetoothDevice: String getAlias()>,<android.bluetooth.BluetoothDevice: String getAlias()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device Alias"");
        return null;
    }
    try {
        String alias = service.getRemoteAlias(this);
        if (alias == null) {
            return getName();
        }
        return alias;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device Alias"");
        return null;
    }
    try {
        String alias = service.getRemoteAliasWithAttribution(this, mAttributionSource);
        if (alias == null) {
            return getName();
        }
        return alias;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the Bluetooth alias of the remote device.
 * <p>Alias is the locally modified name of a remote device.
 *
 * @return the Bluetooth alias, the friendly device name if no alias, or
 * null if there was a problem
 */
","/**
 * Get the locally modifiable name (alias) of the remote Bluetooth device.
 *
 * @return the Bluetooth alias, the friendly device name if no alias, or
 * null if there was a problem
 */
",-1,"[@Nullable, @RequiresPermission(Manifest.permission.BLUETOOTH)]","[@Nullable, @RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method getRemoteAlias() has been changed to getRemoteAliasWithAttribution() with an additional parameter mAttributionSource. This is a dependent API change, so the code change is of types 1,5.","Since the dependent API getRemoteAliasWithAttribution() is called with an additional parameter which was not present in the earlier version, it could potentially lead to different return values. Hence, this is a Compatibility Issue of type 1."
354,"<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>",30,31,"<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>","<android.app.admin.DevicePolicyManager: boolean setPermittedInputMethods(ComponentName,List<String>)>",0,"{
    throwIfParentInstance(""setPermittedInputMethods"");
    if (mService != null) {
        try {
            return mService.setPermittedInputMethods(admin, packageNames);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.setPermittedInputMethods(admin, packageNames, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Called by a profile or device owner to set the permitted input methods services for this
 * user. By default, the user can use any input method.
 * <p>
 * When zero or more packages have been added, input method that are not in the list and not
 * part of the system can not be enabled by the user. This method will fail if it is called for
 * a admin that is not for the foreground user or a profile of the foreground user. Any
 * non-system input method service that's currently enabled must be included in the list.
 * <p>
 * Calling with a null value for the list disables the restriction so that all input methods can
 * be used, calling with an empty list disables all but the system's own input methods.
 * <p>
 * System input methods are always available to the user - this method can't modify this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of input method package names.
 * @return {@code true} if the operation succeeded, or {@code false} if the list didn't
 * contain every enabled non-system input method service.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Called by a profile or device owner to set the permitted input methods services for this
 * user. By default, the user can use any input method.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance,
 * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be
 * a profile owner of an organization-owned device.
 * <p>
 * If called on the parent instance:
 * <ul>
 * <li>The permitted input methods will be applied on the personal profile</li>
 * <li>Can only permit all input methods (calling this method with a {@code null} package
 * list) or only permit system input methods (calling this method with an empty package
 * list). This is to prevent the caller from learning which packages are installed on
 * the personal side</li>
 * </ul>
 * <p>
 * When zero or more packages have been added, input method that are not in the list and not
 * part of the system can not be enabled by the user. This method will fail if it is called for
 * a admin that is not for the foreground user or a profile of the foreground user. Any
 * non-system input method service that's currently enabled must be included in the list.
 * <p>
 * Calling with a null value for the list disables the restriction so that all input methods can
 * be used, calling with an empty list disables all but the system's own input methods.
 * <p>
 * System input methods are always available to the user - this method can't modify this.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param packageNames List of input method package names.
 * @return {@code true} if the operation succeeded, or {@code false} if the list didn't
 * contain every enabled non-system input method service.
 * @throws SecurityException if {@code admin} is not a device, profile owner or if called on
 * the parent profile and the {@code admin} is not a profile owner
 * of an organization-owned managed profile.
 * @throws IllegalArgumentException if called on the parent profile, the {@code admin} is a
 * profile owner of an organization-owned managed profile and the
 * list of permitted input method package names is not null or empty.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The control dependency and the method signature of the dependent API call mService.setPermittedInputMethods have changed. Specifically, the deletion of the throwIfParentInstance(""setPermittedInputMethods"") control statement and the addition of a new parameter mParentInstance to the call to setPermittedInputMethods(admin, packageNames) make it a 3,5 change.","The deletion of throwIfParentInstance(""setPermittedInputMethods"") might have previously thrown an exception under certain conditions which will no longer be the case. Additionally, adding a new parameter to the API call could alter the return value depending on the new parameter's influence on the method's behavior. Hence, there is a potential for a different value to be returned (change type 1)."
355,<android.bluetooth.BluetoothDevice: String getName()>,30,31,<android.bluetooth.BluetoothDevice: String getName()>,<android.bluetooth.BluetoothDevice: String getName()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        String name = service.getRemoteName(this);
        if (name != null) {
            return name.replaceAll(""[\\t\\n\\r]+"", "" "");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        String name = service.getRemoteName(this, mAttributionSource);
        if (name != null) {
            // remove whitespace characters from the name
            return name.replace('\t', ' ').replace('\n', ' ').replace('\r', ' ');
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
","/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of `boolean replaceAll(String regex, String replacement)` is changed to individual character replacements `char replace(char oldChar, char newChar)`. Also, a new parameter `mAttributionSource` was added to the method `service.getRemoteName(this, mAttributionSource)`. These indicate Other statements have been changed (4) and a Dependent API has been changed (5).","In terms of behavior, these changes should not cause compatibility issues. The logic stays the same: it cleans up whitespace characters from the Bluetooth device name. Adding `mAttributionSource` as a parameter to `service.getRemoteName()` method doesn't affect the method's behavior from the perspective of an app developer using `BluetoothDevice.getName()`. The output remains the sameâ€”a processed device name string, cleaned of any white space, or `null` if the service is not available or an error occurs. The annotation changes don't cause any change in behavior but define more specific permission requirements which are enforced at compile time and do not directly affect the runtime behavior of the method. Therefore, it can be concluded that there is no compatibility issue (0)."
356,<android.view.Display: int getWidth()>,30,31,<android.view.Display: int getWidth()>,<android.view.Display: int getWidth()>,0,"{
    synchronized (this) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppWidthCompat;
    }
}","{
    synchronized (mLock) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppWidthCompat;
    }
}",1,"/**
 * @deprecated Use {@link WindowMetrics#getBounds#width()} instead.
 */
","/**
 * @deprecated Use {@link WindowMetrics#getBounds#width()} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The change is in the object used for synchronization (from `this` to `mLock`). This is an internal change in the synchronization mechanism and does not affect the method's signature or its behavior from the caller's perspective. Therefore, the code change type is 4.","Since the method's behavior (return value, exceptions thrown) remains the same and only the object used for the synchronization block has been changed, there's no compatibility issue. The returned value `mCachedAppWidthCompat` and method signature remain unchanged, so the method behaves the same way externally in both versions. Hence, there's no CI."
357,<android.view.inputmethod.BaseInputConnection: int getCursorCapsMode(int)>,30,31,<android.view.inputmethod.BaseInputConnection: int getCursorCapsMode(int)>,<android.view.inputmethod.BaseInputConnection: int getCursorCapsMode(int)>,0,"{
    if (mDummyMode)
        return 0;
    final Editable content = getEditable();
    if (content == null)
        return 0;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    return TextUtils.getCapsMode(content, a, reqModes);
}","{
    if (mFallbackMode)
        return 0;
    final Editable content = getEditable();
    if (content == null)
        return 0;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    return TextUtils.getCapsMode(content, a, reqModes);
}",1,"/**
 * The default implementation uses TextUtils.getCapsMode to get the
 * cursor caps mode for the current selection position in the editable
 * text, unless in dummy mode in which case 0 is always returned.
 */
","/**
 * The default implementation uses TextUtils.getCapsMode to get the
 * cursor caps mode for the current selection position in the editable
 * text, unless in fallback mode in which case 0 is always returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a change in a variable name within a conditional check from `mDummyMode` to `mFallbackMode`, which counts as an ""Other statement changed."" This change does not affect any return statements, exception handling, control dependencies, or dependent APIs.","There is no Compatibility Issue because the change from `mDummyMode` to `mFallbackMode` does not inherently imply a change in behavior unless the semantics of `mFallbackMode` are different from `mDummyMode`. The code structure and logic remain the same, and it still returns 0 under the updated condition. Without additional context about the behavior of `mFallbackMode`, we cannot assume a different behavior, thus no CI."
359,<android.content.pm.ShortcutManager: boolean addDynamicShortcuts(List<ShortcutInfo>)>,30,31,<android.content.pm.ShortcutManager: boolean addDynamicShortcuts(List<ShortcutInfo>)>,<android.content.pm.ShortcutManager: boolean addDynamicShortcuts(List<ShortcutInfo>)>,0,"{
    try {
        return mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return (boolean) getFutureOrThrow(mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
 * the same IDs, each mutable shortcut is updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
 * the same IDs, each mutable shortcut is updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,"1,4",1,"The casting of the return value has been added as '(boolean)', and a method call to getFutureOrThrow() has been wrapped around the original return statement in the late version. This is considered an Other statement changed (4). In addition, the casting and added method introduce a Return statement changed (1), since the API could now potentially return a different value or behave differently due to the processing within getFutureOrThrow().","Since `getFutureOrThrow` could potentially alter the value returned by the `mService.addDynamicShortcuts` call (for example, by resolving a future value), the return value of the API could differ between versions. The addition of casting to `(boolean)` does not in itself cause a compatibility issue, but it is part of the overall change in how the return value is processed. Therefore, there could be a Compatibility Issue due to potential different return values or types (1)."
360,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",30,31,"<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>","<android.view.inputmethod.InputMethodManager: void sendAppPrivateCommand(View,String,Bundle)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.sendAppPrivateCommand(view, action, data);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
            mCurMethod.appPrivateCommand(action, data);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.sendAppPrivateCommand(view, action, data);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""APP PRIVATE COMMAND "" + action + "": "" + data);
        mCurrentInputMethodSession.appPrivateCommand(action, data);
    }
}",1,"/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
","/**
 * Call {@link InputMethodSession#appPrivateCommand(String, Bundle)
 * InputMethodSession.appPrivateCommand()} on the current Input Method.
 * @param view Optional View that is sending the command, or null if
 * you want to send the command regardless of the view that is attached
 * to the input method.
 * @param action Name of the command to be performed.  This <em>must</em>
 * be a scoped name, i.e. prefixed with a package name you own, so that
 * different developers will not create conflicting commands.
 * @param data Any data to include with the command.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the member variable from mCurMethod to mCurrentInputMethodSession in a non-conditional statement which doesn't affect control flow, which is change type 4. Also, this member variable change implies there might be a change in the dependent API, which is type 5.","Even though the member variable used to call appPrivateCommand has changed, there is no indication that the behavior of the API has changed. The API will either successfully send the 'appPrivateCommand' or not, and will not throw an exception or return a different value as part of the API's post-conditions. Therefore, there is no Compatibility Issue, CI type 0."
364,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",30,31,"<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>","<android.app.ActivityManager: void moveTaskToFront(int,int,Bundle)>",0,"{
    try {
        ActivityThread thread = ActivityThread.currentActivityThread();
        IApplicationThread appThread = thread.getApplicationThread();
        String packageName = mContext.getPackageName();
        getTaskService().moveTaskToFront(appThread, packageName, taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        ActivityThread thread = ActivityThread.currentActivityThread();
        IApplicationThread appThread = thread.getApplicationThread();
        String packageName = mContext.getOpPackageName();
        getTaskService().moveTaskToFront(appThread, packageName, taskId, flags, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
","/**
 * Ask that the task associated with a given task ID be moved to the
 * front of the stack, so it is now visible to the user.
 *
 * @param taskId The identifier of the task to be moved, as found in
 * {@link RunningTaskInfo} or {@link RecentTaskInfo}.
 * @param flags Additional operational flags.
 * @param options Additional options for the operation, either null or
 * as per {@link Context#startActivity(Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)}.
 */
",-1,[@RequiresPermission(android.Manifest.permission.REORDER_TASKS)],[@RequiresPermission(android.Manifest.permission.REORDER_TASKS)],-1,-1,-1,-1,-1,-1,4,0,"The code change is in the line `String packageName = mContext.getPackageName();` which has been changed to `String packageName = mContext.getOpPackageName();`. This is an 'Other statement' type of change, so the code change type is 4.","Despite the change in how the package name is obtained, this should not lead to a compatibility issue as long as the method `getOpPackageName` is guaranteed to return the same package name for the context of the calling application, which is the presumed behavior. Hence, there is no CI as the behavior of the API would remain the same from a caller's perspective; therefore, the CI type is 0."
365,<android.ddm.DdmHandleNativeHeap: Chunk handleChunk(Chunk)>,30,31,<android.ddm.DdmHandleNativeHeap: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleNativeHeap: Chunk handleChunk(Chunk)>,0,"{
    Log.i(""ddm-nativeheap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_NHGT) {
        return handleNHGT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    Log.i(""ddm-nativeheap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_NHGT) {
        return handleNHGT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The string concatenation inside the RuntimeException changed from ChunkHandler.name(type) to name(type), but this does not affect the execution flow of the method, so the code change type is 4 (other statement change).","No Compatibility Issue could arise, as the altered string message does not affect the method's behavior, variable values, or exception handling logic; the exception type and when it is thrown remain unchanged. Therefore, the CI is 0 (no compatibility issue)."
366,<android.view.textclassifier.TextClassificationSession: TextClassification classifyText(Request)>,30,31,<android.view.textclassifier.TextClassificationSession: TextClassification classifyText(Request)>,<android.view.textclassifier.TextClassificationSession: TextClassification classifyText(Request)>,0,"{
    checkDestroyed();
    return mDelegate.classifyText(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.classifyText(request));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method `checkDestroyed()` is wrapped inside a lambda provided as an argument to a different method `checkDestroyedAndRun()`. This suggests an alteration in how `checkDestroyed()` is executed within the context of the API, which classifies the change as a dependent API changed (5).","Despite the change in the method execution process, there is no indication that the behaviour of the API will lead to different return values or exceptions, provided that `checkDestroyedAndRun()` is designed to behave in a manner equivalent to the earlier implementation when delegating to `mDelegate.classifyText(request)`. Hence, there seems to be no compatibility issue (0)."
367,<android.view.textclassifier.TextClassificationSession: ConversationActions suggestConversationActions(Request)>,30,31,<android.view.textclassifier.TextClassificationSession: ConversationActions suggestConversationActions(Request)>,<android.view.textclassifier.TextClassificationSession: ConversationActions suggestConversationActions(Request)>,0,"{
    checkDestroyed();
    return mDelegate.suggestConversationActions(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.suggestConversationActions(request));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,The implementation has changed from directly calling checkDestroyed() and then mDelegate.suggestConversationActions(request) to wrapping the previous logic inside a lambda expression passed to checkDestroyedAndRun(). This change affects how the method's internal operations are structured but does not impact the method's external behavior or signature since the return type and exception handling remain the same. The code change type is 4 and 5 due to the use of the lambda expression and the assumption that checkDestroyedAndRun() may be a dependent API.,"There is no Compatibility Issue. Although the internal implementation has changed, the behavior observed by the API consumers (the return type and exception handling) would remain the same. The method still returns a ConversationActions object and does not introduce new exceptions nor changes to the control flow that would lead to a change in the returned value or thrown exceptions. Hence, the API change should not cause any Compatibility Issues."
369,<android.app.ApplicationExitInfo: InputStream getTraceInputStream()>,30,31,<android.app.ApplicationExitInfo: InputStream getTraceInputStream()>,<android.app.ApplicationExitInfo: InputStream getTraceInputStream()>,0,"{
    if (mAppTraceRetriever == null) {
        return null;
    }
    try {
        final ParcelFileDescriptor fd = mAppTraceRetriever.getTraceFileDescriptor(mPackageName, mPackageUid, mPid);
        if (fd == null) {
            return null;
        }
        return new GZIPInputStream(new ParcelFileDescriptor.AutoCloseInputStream(fd));
    } catch (RemoteException e) {
        return null;
    }
}","{
    if (mAppTraceRetriever == null && mNativeTombstoneRetriever == null) {
        return null;
    }
    try {
        if (mNativeTombstoneRetriever != null) {
            final ParcelFileDescriptor pfd = mNativeTombstoneRetriever.getPfd();
            if (pfd == null) {
                return null;
            }
            return new ParcelFileDescriptor.AutoCloseInputStream(pfd);
        } else {
            final ParcelFileDescriptor fd = mAppTraceRetriever.getTraceFileDescriptor(mPackageName, mPackageUid, mPid);
            if (fd == null) {
                return null;
            }
            return new GZIPInputStream(new ParcelFileDescriptor.AutoCloseInputStream(fd));
        }
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the InputStream to the traces that was taken by the system
 * prior to the death of the process; typically it'll be available when
 * the reason is {@link #REASON_ANR}, though if the process gets an ANR
 * but recovers, and dies for another reason later, this trace will be included
 * in the record of {@link ApplicationExitInfo} still.
 *
 * @return The input stream to the traces that was taken by the system
 * prior to the death of the process.
 */
","/**
 * Return the InputStream to the traces that was taken by the system
 * prior to the death of the process; typically it'll be available when
 * the reason is {@link #REASON_ANR}, though if the process gets an ANR
 * but recovers, and dies for another reason later, this trace will be included
 * in the record of {@link ApplicationExitInfo} still. Beginning with API 31,
 * tombstone traces will be returned for
 * {@link #REASON_CRASH_NATIVE}, with an InputStream containing a protobuf with
 * <a href=""https://android.googlesource.com/platform/system/core/+/refs/heads/master/debuggerd/proto/tombstone.proto"">this schema</a>.
 * Note that because these traces are kept in a separate global circular buffer, crashes may be
 * overwritten by newer crashes (including from other applications), so this may still return
 * null.
 *
 * @return The input stream to the traces that was taken by the system
 * prior to the death of the process.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The condition in the if statement has been changed, adding a condition for mNativeTombstoneRetriever, and a new block for handling mNativeTombstoneRetriever is added. Additionally, the return type for the mNativeTombstoneRetriever case is a different InputStream type than the other case, which is a GZIPInputStream. These changes correspond to code change types 1 and 3.","The condition in the if statement change can lead to a different code execution path, which in turn can result in different return types or values (between ParcelFileDescriptor.AutoCloseInputStream and GZIPInputStream). This represents a compatibility issue since the API can potentially return a different variable type or value, hence the CI type is 1."
370,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",30,31,"<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>","<android.app.assist.AssistStructure.ParcelTransferWriter: void writeView(ViewNode,Parcel,PooledStringWriter,int)>",0,"{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}","{
    if (DEBUG_PARCEL)
        Log.d(TAG, ""write view: at "" + out.dataPosition() + "", windows="" + mNumWrittenWindows + "", views="" + mNumWrittenViews + "", level="" + (mCurViewStackPos + levelAdj));
    out.writeInt(VALIDATE_VIEW_TOKEN);
    int flags = child.writeSelfToParcel(out, pwriter, mSanitizeOnWrite, mTmpMatrix, /*willWriteChildren=*/
    true);
    mNumWrittenViews++;
    // If the child has children, push it on the stack to write them next.
    if ((flags & ViewNode.FLAGS_HAS_CHILDREN) != 0) {
        if (DEBUG_PARCEL_TREE || DEBUG_PARCEL_CHILDREN)
            Log.d(TAG, ""Preparing to write "" + child.mChildren.length + "" children: @ #"" + mNumWrittenViews + "", level "" + (mCurViewStackPos + levelAdj));
        out.writeInt(child.mChildren.length);
        int pos = ++mCurViewStackPos;
        pushViewStackEntry(child, pos);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The call to ""child.writeSelfToParcel"" has an additional boolean parameter in the late version but there are no changes to control statements or exception handling, so the change type is 4,5 for the modified dependent API call.","There is no Compatibility Issue related to the potential different return values or exception handlings since the method's functionality (writing the view to a parcel) and its return type (void) remain the same. The added parameter does not alter the method's signature or return type, nor does it introduce a new code path that could lead to a different exception being thrown."
371,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",30,31,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>","<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",0,"{
    String allowedProviders = Settings.Secure.getStringForUser(cr, LOCATION_PROVIDERS_ALLOWED, cr.getUserId());
    return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
}","{
    IBinder binder = ServiceManager.getService(Context.LOCATION_SERVICE);
    ILocationManager lm = Objects.requireNonNull(ILocationManager.Stub.asInterface(binder));
    try {
        return lm.isProviderEnabledForUser(provider, cr.getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link LocationManager#isProviderEnabled(String)}
 */
","/**
 * Helper method for determining if a location provider is enabled.
 *
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 *
 * @deprecated use {@link LocationManager#isProviderEnabled(String)}
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire implementation of the method has changed. It uses a different set of APIs to achieve the functionality, moving from using Settings.Secure.getStringForUser(...) and TextUtils.delimitedStringContains(...) to ILocationManager.Stub.asInterface(...) and lm.isProviderEnabledForUser(...). This constitutes changes in the implementation logic, other statements, and dependent APIs which are of change types 1, 4,5.","Given that the implementation moved away from using previously concatenated string checks towards a more direct service call, the return value of the API method could potentially differ. Hence, there could be a Compatibility Issue due to different return values, which is type 1."
372,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,30,31,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
        case DO_REMOVE_IME_SURFACE:
            {
                mInputMethodSession.removeImeSurface();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null) {
        // for cases below.
        switch(msg.what) {
            case DO_UPDATE_SELECTION:
            case DO_APP_PRIVATE_COMMAND:
                {
                    SomeArgs args = (SomeArgs) msg.obj;
                    args.recycle();
                }
        }
        return;
    }
    switch(msg.what) {
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_UPDATE_CURSOR_ANCHOR_INFO:
            {
                mInputMethodSession.updateCursorAnchorInfo((CursorAnchorInfo) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_FINISH_SESSION:
            {
                doFinishSession();
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
        case DO_NOTIFY_IME_HIDDEN:
            {
                mInputMethodSession.notifyImeHidden();
                return;
            }
        case DO_REMOVE_IME_SURFACE:
            {
                mInputMethodSession.removeImeSurface();
                return;
            }
        case DO_FINISH_INPUT:
            {
                mInputMethodSession.finishInput();
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,A new case (DO_FINISH_INPUT) has been added in the late version switch statement. This addition is both a control dependency change and an other statement change since it is a part of the control flow (3) and also a modification of the switch statement content (4).,"There is no Compatibility Issue as the new case only adds functionality for a new message type. This change does not affect the existing behavior for any of the previously handled message types. Therefore, there's no change in the API's behavior for the earlier message types, and it will not cause an existing use of the API to behave differently or break."
373,"<android.speech.tts.TextToSpeech: int addEarcon(String,String,int)>",30,31,"<android.speech.tts.TextToSpeech: int addEarcon(String,String,int)>","<android.speech.tts.TextToSpeech: int addEarcon(String,String,int)>",0,"{
    synchronized (mStartLock) {
        mEarcons.put(earcon, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}","{
    return addEarcon(earcon, makeResourceUri(packagename, resourceId));
}",1,"/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>""[tick]""</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>""[tick]""</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The early version uses a synchronized block and directly updates a map and returns SUCCESS, while the late version delegates to another version of addEarcon(). This is a change in the structure of the code, but not in the behavior related to return values or exceptions; hence, change type is 4. Moreover, since it now relies on a different overload of the addEarcon() method, which is a dependent API change, change type 5 is also present.","No Compatibility Issue is detected as the delegation to another overload of addEarcon() should maintain the same behavior regarding return values and exception handling. The method internals have changed, but as long as the other overload of addEarcon() maintains the same contract, the changes should not affect compatibility; thus, the CI type is 0."
374,"<android.service.autofill.CustomDescription.Builder: Builder batchUpdate(Validator,BatchUpdates)>",30,31,"<android.service.autofill.CustomDescription.Builder: Builder batchUpdate(Validator,BatchUpdates)>","<android.service.autofill.CustomDescription.Builder: Builder batchUpdate(Validator,BatchUpdates)>",0,"{
    throwIfDestroyed();
    Preconditions.checkArgument((condition instanceof InternalValidator), ""not provided by Android System: "" + condition);
    Preconditions.checkNotNull(updates);
    if (mUpdates == null) {
        mUpdates = new ArrayList<>();
    }
    mUpdates.add(new Pair<>((InternalValidator) condition, updates));
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((condition instanceof InternalValidator), ""not provided by Android System: %s"", condition);
    Preconditions.checkNotNull(updates);
    if (mUpdates == null) {
        mUpdates = new ArrayList<>();
    }
    mUpdates.add(new Pair<>((InternalValidator) condition, updates));
    return this;
}",1,"/**
 * Updates the {@link RemoteViews presentation template} when a condition is satisfied by
 * applying a series of remote view operations. This allows dynamic customization of the
 * portion of the save UI that is controlled by the autofill service. Such dynamic
 * customization is based on the content of target views.
 *
 * <p>The updates are applied in the sequence they are added, after the
 * {@link #addChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>For example, to make children views visible when fields are not empty:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_full_template);
 *
 * Pattern notEmptyPattern = Pattern.compile("".+"");
 * Validator hasAddress = new RegexValidator(addressAutofillId, notEmptyPattern);
 * Validator hasCcNumber = new RegexValidator(ccNumberAutofillId, notEmptyPattern);
 *
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * addressUpdates.setViewVisibility(R.id.address, View.VISIBLE);
 *
 * // Make address visible
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * ccUpdates.setViewVisibility(R.id.cc_number, View.VISIBLE);
 *
 * // Mask credit card number (as .....LAST_4_DIGITS) and make it visible
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * <p>Another approach is to add a child first, then apply the transformations. Example:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_base_template);
 *
 * RemoteViews addressPresentation = new RemoteViews(pgkName, R.layout.address)
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * addressUpdates.addView(R.id.parentId, addressPresentation);
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccPresentation = new RemoteViews(pgkName, R.layout.cc)
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * ccUpdates.addView(R.id.parentId, ccPresentation);
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * @param condition condition used to trigger the updates.
 * @param updates actions to be applied to the
 * {@link #Builder(RemoteViews) template presentation} when the condition
 * is satisfied.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
","/**
 * Updates the {@link RemoteViews presentation template} when a condition is satisfied by
 * applying a series of remote view operations. This allows dynamic customization of the
 * portion of the save UI that is controlled by the autofill service. Such dynamic
 * customization is based on the content of target views.
 *
 * <p>The updates are applied in the sequence they are added, after the
 * {@link #addChild(int, Transformation) transformations} are applied to the children
 * views.
 *
 * <p>For example, to make children views visible when fields are not empty:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_full_template);
 *
 * Pattern notEmptyPattern = Pattern.compile("".+"");
 * Validator hasAddress = new RegexValidator(addressAutofillId, notEmptyPattern);
 * Validator hasCcNumber = new RegexValidator(ccNumberAutofillId, notEmptyPattern);
 *
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * addressUpdates.setViewVisibility(R.id.address, View.VISIBLE);
 *
 * // Make address visible
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_full_template)
 * ccUpdates.setViewVisibility(R.id.cc_number, View.VISIBLE);
 *
 * // Mask credit card number (as .....LAST_4_DIGITS) and make it visible
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * <p>Another approach is to add a child first, then apply the transformations. Example:
 *
 * <pre class=""prettyprint"">
 * RemoteViews template = new RemoteViews(pgkName, R.layout.my_base_template);
 *
 * RemoteViews addressPresentation = new RemoteViews(pgkName, R.layout.address)
 * RemoteViews addressUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * addressUpdates.addView(R.id.parentId, addressPresentation);
 * BatchUpdates addressBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(addressUpdates)
 * .build();
 *
 * RemoteViews ccPresentation = new RemoteViews(pgkName, R.layout.cc)
 * RemoteViews ccUpdates = new RemoteViews(pgkName, R.layout.my_template)
 * ccUpdates.addView(R.id.parentId, ccPresentation);
 * BatchUpdates ccBatchUpdates = new BatchUpdates.Builder()
 * .updateTemplate(ccUpdates)
 * .transformChild(R.id.templateCcNumber, new CharSequenceTransformation
 * .Builder(ccNumberId, Pattern.compile(""^.*(\\d\\d\\d\\d)$""), ""...$1"")
 * .build())
 * .build();
 *
 * CustomDescription customDescription = new CustomDescription.Builder(template)
 * .batchUpdate(hasAddress, addressBatchUpdates)
 * .batchUpdate(hasCcNumber, ccBatchUpdates)
 * .build();
 * </pre>
 *
 * @param condition condition used to trigger the updates.
 * @param updates actions to be applied to the
 * {@link #Builder(RemoteViews) template presentation} when the condition
 * is satisfied.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code condition} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is in a string within the Preconditions.checkArgument call, where the concatenation has been changed to string formatting. This is considered as an ""Other statement changed"" since the functionality and method's behavior remains the same, and thus the code change type is 4.","There is no Compatibility Issue since the modification to the error message string does not affect the execution flow or the values returned by the method, so the CI type is 0."
375,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,0,"{
    if (VDBG)
        log(""isAudioConnected()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (VDBG)
        log(""isAudioConnected()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isAudioConnected(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected, false otherwise or on error
 */
","/**
 * Check if Bluetooth SCO audio is connected.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected, false otherwise or on error
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The call to the method service.isAudioConnected has added a new parameter mAttributionSource. This change can be considered as a dependent API change (method call with altered parameters), so the code change type is 4,5.","No Compatibility Issue should arise from this change because the added parameter (mAttributionSource) does not affect the return type or the variable returned. It may affect the internal implementation regarding permissions, but unless there's a behavior change related to exceptions or return values, no compatibility issue regarding return values or exceptions is expected. Thus, the CI type is 0."
376,"<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>",30,31,"<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>","<android.text.method.NumberKeyListener: boolean addAmPmChars(Collection<Character>,Locale)>",0,"{
    if (locale == null) {
        return false;
    }
    final String[] amPm = LocaleData.get(locale).amPm;
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}","{
    if (locale == null) {
        return false;
    }
    final String[] amPm = DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings();
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API called within the method has changed from LocaleData.get(locale).amPm to DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings(), so the change type is 5.","Although there's a change in the dependent API, there's no indication that this change will affect the behavior of the addAmPmChars method. The method's logic remains the same, and assuming the new API call DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings() provides the same outcome as the old LocaleData.get(locale).amPm, there should be no compatibility issues. Therefore, the CI type is 0."
378,"<android.widget.Magnifier: void show(float,float,float,float)>",30,31,"<android.widget.Magnifier: void show(float,float,float,float)>","<android.widget.Magnifier: void show(float,float,float,float)>",0,"{
    obtainSurfaces();
    obtainContentCoordinates(sourceCenterX, sourceCenterY);
    int startX = mClampedCenterZoomCoords.x - mSourceWidth / 2;
    final int startY = mClampedCenterZoomCoords.y - mSourceHeight / 2;
    if (mIsFishEyeStyle) {
        // The magnifier center is the same as source center in new style.
        magnifierCenterX = mClampedCenterZoomCoords.x - mViewCoordinatesInSurface[0];
        magnifierCenterY = mClampedCenterZoomCoords.y - mViewCoordinatesInSurface[1];
        // mLeftBound & mRightBound (typically the text line left/right) is for magnified
        // content. However the PixelCopy requires the pre-magnified bounds.
        // The below logic calculates the leftBound & rightBound for the pre-magnified bounds.
        final float rampPre = (mSourceWidth - (mSourceWidth - 2 * mRamp) / mZoom) / 2;
        // Calculates the pre-zoomed left edge.
        // The leftEdge moves from the left of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x0 = sourceCenterX - mSourceWidth / 2;
        final float rampX0 = x0 + mRamp;
        float leftEdge = 0;
        if (leftEdge > rampX0) {
            // leftEdge is in the zoom range, the distance from leftEdge to sourceCenterX
            // should reduce per mZoom.
            leftEdge = sourceCenterX - (sourceCenterX - leftEdge) / mZoom;
        } else if (leftEdge > x0) {
            // leftEdge is in the ramp range, the distance from leftEdge to rampX0 should
            // increase per ramp zoom (ramp / rampPre).
            leftEdge = x0 + rampPre - (rampX0 - leftEdge) * rampPre / mRamp;
        }
        int leftBound = Math.min(Math.max((int) leftEdge, mLeftBound), mRightBound);
        // Calculates the pre-zoomed right edge.
        // The rightEdge moves from the right of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x1 = sourceCenterX + mSourceWidth / 2;
        final float rampX1 = x1 - mRamp;
        float rightEdge = mView.getWidth();
        if (rightEdge < rampX1) {
            // rightEdge is in the zoom range, the distance from rightEdge to sourceCenterX
            // should reduce per mZoom.
            rightEdge = sourceCenterX + (rightEdge - sourceCenterX) / mZoom;
        } else if (rightEdge < x1) {
            // rightEdge is in the ramp range, the distance from rightEdge to rampX1 should
            // increase per ramp zoom (ramp / rampPre).
            rightEdge = x1 - rampPre + (rightEdge - rampX1) * rampPre / mRamp;
        }
        int rightBound = Math.max(leftBound, Math.min((int) rightEdge, mRightBound));
        // Gets the startX for new style, which should be bounded by the horizontal bounds.
        // Also calculates the left/right cut width for pixel copy.
        leftBound = Math.max(leftBound + mViewCoordinatesInSurface[0], 0);
        rightBound = Math.min(rightBound + mViewCoordinatesInSurface[0], mContentCopySurface.mWidth);
        mLeftCutWidth = Math.max(0, leftBound - startX);
        mRightCutWidth = Math.max(0, startX + mSourceWidth - rightBound);
        startX = Math.max(startX, leftBound);
    }
    obtainWindowCoordinates(magnifierCenterX, magnifierCenterY);
    if (sourceCenterX != mPrevShowSourceCoords.x || sourceCenterY != mPrevShowSourceCoords.y || mDirtyState) {
        if (mWindow == null) {
            synchronized (mLock) {
                mWindow = new InternalPopupWindow(mView.getContext(), mView.getDisplay(), mParentSurface.mSurfaceControl, mWindowWidth, mWindowHeight, mZoom, mRamp, mWindowElevation, mWindowCornerRadius, mOverlay != null ? mOverlay : new ColorDrawable(Color.TRANSPARENT), Handler.getMain(), /* draw the magnifier on the UI thread */
                mLock, mCallback, mIsFishEyeStyle);
            }
        }
        performPixelCopy(startX, startY, true);
    } else if (magnifierCenterX != mPrevShowWindowCoords.x || magnifierCenterY != mPrevShowWindowCoords.y) {
        final Point windowCoords = getCurrentClampedWindowCoordinates();
        final InternalPopupWindow currentWindowInstance = mWindow;
        sPixelCopyHandlerThread.getThreadHandler().post(() -> {
            synchronized (mLock) {
                if (mWindow != currentWindowInstance) {
                    // The magnifier was dismissed (and maybe shown again) in the meantime.
                    return;
                }
                mWindow.setContentPositionForNextDraw(windowCoords.x, windowCoords.y);
            }
        });
    }
    mPrevShowSourceCoords.x = sourceCenterX;
    mPrevShowSourceCoords.y = sourceCenterY;
    mPrevShowWindowCoords.x = magnifierCenterX;
    mPrevShowWindowCoords.y = magnifierCenterY;
}","{
    obtainSurfaces();
    obtainContentCoordinates(sourceCenterX, sourceCenterY);
    int startX = mClampedCenterZoomCoords.x - mSourceWidth / 2;
    final int startY = mClampedCenterZoomCoords.y - mSourceHeight / 2;
    if (mIsFishEyeStyle) {
        // The magnifier center is the same as source center in new style.
        magnifierCenterX = mClampedCenterZoomCoords.x - mViewCoordinatesInSurface[0];
        magnifierCenterY = mClampedCenterZoomCoords.y - mViewCoordinatesInSurface[1];
        // PixelCopy requires the pre-magnified bounds.
        // The below logic calculates the leftBound & rightBound for the pre-magnified bounds.
        final float rampPre = (mSourceWidth - (mSourceWidth - 2 * mRamp) / mZoom) / 2;
        // Calculates the pre-zoomed left edge.
        // The leftEdge moves from the left of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x0 = sourceCenterX - mSourceWidth / 2f;
        final float rampX0 = x0 + mRamp;
        float leftEdge = 0;
        if (leftEdge > rampX0) {
            // leftEdge is in the zoom range, the distance from leftEdge to sourceCenterX
            // should reduce per mZoom.
            leftEdge = sourceCenterX - (sourceCenterX - leftEdge) / mZoom;
        } else if (leftEdge > x0) {
            // leftEdge is in the ramp range, the distance from leftEdge to rampX0 should
            // increase per ramp zoom (ramp / rampPre).
            leftEdge = x0 + rampPre - (rampX0 - leftEdge) * rampPre / mRamp;
        }
        int leftBound = Math.min((int) leftEdge, mView.getWidth());
        // Calculates the pre-zoomed right edge.
        // The rightEdge moves from the right of view towards to sourceCenterX, considering the
        // fisheye-like zooming.
        final float x1 = sourceCenterX + mSourceWidth / 2f;
        final float rampX1 = x1 - mRamp;
        float rightEdge = mView.getWidth();
        if (rightEdge < rampX1) {
            // rightEdge is in the zoom range, the distance from rightEdge to sourceCenterX
            // should reduce per mZoom.
            rightEdge = sourceCenterX + (rightEdge - sourceCenterX) / mZoom;
        } else if (rightEdge < x1) {
            // rightEdge is in the ramp range, the distance from rightEdge to rampX1 should
            // increase per ramp zoom (ramp / rampPre).
            rightEdge = x1 - rampPre + (rightEdge - rampX1) * rampPre / mRamp;
        }
        int rightBound = Math.max(leftBound, (int) rightEdge);
        // Gets the startX for new style, which should be bounded by the horizontal bounds.
        // Also calculates the left/right cut width for pixel copy.
        leftBound = Math.max(leftBound + mViewCoordinatesInSurface[0], 0);
        rightBound = Math.min(rightBound + mViewCoordinatesInSurface[0], mContentCopySurface.mWidth);
        mLeftCutWidth = Math.max(0, leftBound - startX);
        mRightCutWidth = Math.max(0, startX + mSourceWidth - rightBound);
        startX = Math.max(startX, leftBound);
    }
    obtainWindowCoordinates(magnifierCenterX, magnifierCenterY);
    if (sourceCenterX != mPrevShowSourceCoords.x || sourceCenterY != mPrevShowSourceCoords.y || mDirtyState) {
        if (mWindow == null) {
            synchronized (mLock) {
                mWindow = new InternalPopupWindow(mView.getContext(), mView.getDisplay(), mParentSurface.mSurfaceControl, mWindowWidth, mWindowHeight, mZoom, mRamp, mWindowElevation, mWindowCornerRadius, mOverlay != null ? mOverlay : new ColorDrawable(Color.TRANSPARENT), Handler.getMain(), /* draw the magnifier on the UI thread */
                mLock, mCallback, mIsFishEyeStyle);
            }
        }
        performPixelCopy(startX, startY, true);
    } else if (magnifierCenterX != mPrevShowWindowCoords.x || magnifierCenterY != mPrevShowWindowCoords.y) {
        final Point windowCoords = getCurrentClampedWindowCoordinates();
        final InternalPopupWindow currentWindowInstance = mWindow;
        sPixelCopyHandlerThread.getThreadHandler().post(() -> {
            synchronized (mLock) {
                if (mWindow != currentWindowInstance) {
                    // The magnifier was dismissed (and maybe shown again) in the meantime.
                    return;
                }
                mWindow.setContentPositionForNextDraw(windowCoords.x, windowCoords.y);
            }
        });
    }
    mPrevShowSourceCoords.x = sourceCenterX;
    mPrevShowSourceCoords.y = sourceCenterY;
    mPrevShowWindowCoords.x = magnifierCenterX;
    mPrevShowWindowCoords.y = magnifierCenterY;
}",1,"/**
 * Shows the magnifier on the screen at a position that is independent from its content
 * position. The first two arguments represent the coordinates of the center of the
 * content source going to be magnified and copied to the magnifier. The last two arguments
 * represent the coordinates of the center of the magnifier itself. All four coordinates
 * are relative to the top left corner of the magnified view. If you consider using this
 * method such that the offset between the source center and the magnifier center coordinates
 * remains constant, you should consider using method {@link #show(float, float)} instead.
 *
 * @param sourceCenterX horizontal coordinate of the source center relative to the view
 * @param sourceCenterY vertical coordinate of the source center, relative to the view
 * @param magnifierCenterX horizontal coordinate of the magnifier center, relative to the view
 * @param magnifierCenterY vertical coordinate of the magnifier center, relative to the view
 */
","/**
 * Shows the magnifier on the screen at a position that is independent from its content
 * position. The first two arguments represent the coordinates of the center of the
 * content source going to be magnified and copied to the magnifier. The last two arguments
 * represent the coordinates of the center of the magnifier itself. All four coordinates
 * are relative to the top left corner of the magnified view. If you consider using this
 * method such that the offset between the source center and the magnifier center coordinates
 * remains constant, you should consider using method {@link #show(float, float)} instead.
 *
 * @param sourceCenterX horizontal coordinate of the source center relative to the view
 * @param sourceCenterY vertical coordinate of the source center, relative to the view
 * @param magnifierCenterX horizontal coordinate of the magnifier center, relative to the view
 * @param magnifierCenterY vertical coordinate of the magnifier center, relative to the view
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
379,<android.net.Uri.StringUri: String getScheme()>,30,31,<android.net.Uri.StringUri: String getScheme()>,<android.net.Uri.StringUri: String getScheme()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean cached = (scheme != NOT_CACHED);
    return cached ? scheme : (scheme = parseScheme());
}","{
    @SuppressWarnings(""StringEquality"") boolean cached = (scheme != NotCachedHolder.NOT_CACHED);
    return cached ? scheme : (scheme = parseScheme());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The access of the constant NOT_CACHED has changed to NotCachedHolder.NOT_CACHED. This is a change in how the constant is accessed but it's not a functional change to the method's behavior because the value of NOT_CACHED should be the same as NotCachedHolder.NOT_CACHED if the change was done correctly. So, the code change type is 4. Since the dependent API is changed, type 5 is also applicable.","There's no compatibility issue caused by potentially different return values or exception handlings if the semantic of the NOT_CACHED constant remains the same, and there's no indication that its meaning has changed. Therefore, no compatibility issue arises here, CI type is 0."
380,"<android.bluetooth.BluetoothGatt: void setPreferredPhy(int,int,int)>",30,31,"<android.bluetooth.BluetoothGatt: void setPreferredPhy(int,int,int)>","<android.bluetooth.BluetoothGatt: void setPreferredPhy(int,int,int)>",0,"{
    try {
        mService.clientSetPreferredPhy(mClientIf, mDevice.getAddress(), txPhy, rxPhy, phyOptions);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    try {
        mService.clientSetPreferredPhy(mClientIf, mDevice.getAddress(), txPhy, rxPhy, phyOptions, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications preferences,
 * local and remote controller capabilities. Controller can override these settings.
 * <p>
 * {@link BluetoothGattCallback#onPhyUpdate} will be triggered as a result of this call, even
 * if no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */
","/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications preferences,
 * local and remote controller capabilities. Controller can override these settings.
 * <p>
 * {@link BluetoothGattCallback#onPhyUpdate} will be triggered as a result of this call, even
 * if no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The method mService.clientSetPreferredPhy has an additional parameter in the late version, which indicates that a dependent API has changed. This is a change in the dependent API, so the code change type is 5.","The change in the dependent API does not inherently indicate a difference in return values or the potential for an exception to be thrown differently when using the current API, as it isn't altering the flow of the current method's logic. Therefore, there is no compatibility issue based on the provided definitions, so the CI type is 0."
382,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,30,31,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,<android.service.notification.ZenModeConfig.ZenRule: String toString()>,0,"{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""id="").append(id).append("",enabled="").append(String.valueOf(enabled).toUpperCase()).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",condition="").append(condition).append("",pkg="").append(pkg).append("",component="").append(component).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",enabler="").append(enabler).append("",zenPolicy="").append(zenPolicy).append("",modified="").append(modified).append(']').toString();
}","{
    return new StringBuilder(ZenRule.class.getSimpleName()).append('[').append(""id="").append(id).append("",state="").append(condition == null ? ""STATE_FALSE"" : Condition.stateToString(condition.state)).append("",enabled="").append(String.valueOf(enabled).toUpperCase()).append("",snoozing="").append(snoozing).append("",name="").append(name).append("",zenMode="").append(Global.zenModeToString(zenMode)).append("",conditionId="").append(conditionId).append("",pkg="").append(pkg).append("",component="").append(component).append("",configActivity="").append(configurationActivity).append("",creationTime="").append(creationTime).append("",enabler="").append(enabler).append("",zenPolicy="").append(zenPolicy).append("",modified="").append(modified).append("",condition="").append(condition).append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation has been altered with the addition of a new string ("",state="") along with a conditional expression to determine the string value. This constitutes as both a return statement change (since the method returns a string built differently) and an other statement change (change in the string content being appended), so the code change type is 1,4.",The toString() method will return a different string as the content has been modified. The CI type is 1 because it potentially returns a different value.
383,"<android.os.DropBoxManager: void addFile(String,File,int)>",30,31,"<android.os.DropBoxManager: void addFile(String,File,int)>","<android.os.DropBoxManager: void addFile(String,File,int)>",0,"{
    if (file == null)
        throw new NullPointerException(""file == null"");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } finally {
        entry.close();
    }
}","{
    if (file == null)
        throw new NullPointerException(""file == null"");
    try (ParcelFileDescriptor pfd = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)) {
        mService.addFile(tag, pfd, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
","/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependency, particularly the try-with-resources block, has been introduced, and the implementation now uses ParcelFileDescriptor, which changes the way the file is processed and passed to the service. The Entry object creation and subsequent management logic have been removed. The dependent method call has changed from `mService.add(entry)` to `mService.addFile(tag, pfd, flags)`. Therefore, the code change type is 3,5.","Although the implementation details and how the file is passed to the service have changed, there is no change that affects the exception handling or the return type/value because the method return type is void and the exception thrown remains the same. Hence, there is no Compatibility Issue; the CI type is 0."
384,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,30,31,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getConnectedDevices();
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getConnectedDevicesWithAttribution(mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method service.getConnectedDevices() has changed to service.getConnectedDevicesWithAttribution(mAttributionSource) and wrapped with Attributable.setAttributionSource(), which modifies the returned list. Additionally, the late implementation adds new annotations, including permission requirement annotations. Therefore, the changes are related to the return statement, other statement, and dependent API, so the code change types are 1,4,5.","The change in the method used to get the connected devices and the addition of the setAttributionSource() method could lead to a different return value, as the attribution source information is now associated with the returned device list. Furthermore, new permissions requirements introduced in the late version annotation could also impact the behavior of the method when called without the necessary permissions. Therefore, the CI type is 1."
385,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceDataspace(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceDataspace(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceDataspace(Surface)>,0,"{
    try {
        return LegacyCameraDevice.detectSurfaceDataspace(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException(""Surface was abandoned"", e);
    }
}","{
    checkNotNull(surface);
    int dataSpace = nativeDetectSurfaceDataspace(surface);
    if (dataSpace == BAD_VALUE)
        throw new IllegalArgumentException(""Surface was abandoned"");
    return dataSpace;
}",1,"/**
 * Get the Surface dataspace.
 *
 * @param surface The surface to be queried for dataspace.
 * @return dataspace of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
","/**
 * Get the Surface dataspace.
 *
 * @param surface The surface to be queried for dataspace.
 * @return dataspace of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The code change includes removing the try-catch block, adding a call to `checkNotNull(surface)`, replacing `LegacyCameraDevice.detectSurfaceDataspace` with `nativeDetectSurfaceDataspace`, and introducing a new check that throws an exception if `dataSpace` equals `BAD_VALUE`, so the code change types are 2,3,4, and 5.","This change could lead to different return values and exception handlings. Instead of catching `BufferQueueAbandonedException`, throwing an IllegalArgumentException directly with a different message, and the new condition check can also lead to IllegalArgumentException with a different message when `dataSpace` is `BAD_VALUE`. Therefore, this causes different exceptions to be thrown. The return value is also potentially affected by the introduction of the new native method `nativeDetectSurfaceDataspace` instead of `LegacyCameraDevice.detectSurfaceDataspace`, and the CI type is 1 for return values and 2 for exception handlings."
386,"<android.os.DropBoxManager: void addText(String,String)>",30,31,"<android.os.DropBoxManager: void addText(String,String)>","<android.os.DropBoxManager: void addText(String,String)>",0,"{
    try {
        mService.add(new Entry(tag, 0, data));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data, so it was ignored"", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}","{
    addData(tag, data.getBytes(StandardCharsets.UTF_8), IS_TEXT);
}",1,"/**
 * Stores human-readable text.  The data may be discarded eventually (or even
 * immediately) if space is limited, or ignored entirely if the tag has been
 * blocked (see {@link #isTagEnabled}).
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 */
","/**
 * Stores human-readable text.  The data may be discarded eventually (or even
 * immediately) if space is limited, or ignored entirely if the tag has been
 * blocked (see {@link #isTagEnabled}).
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method implementation has changed from directly interacting with the service to delegating the addition of text data to another method addData. This change involves changes in the method logic and invocation of a new, different method (addData), so the change type is 4,5.","The early version of the method directly interacts with mService and contains logic for handling a specific exception scenario related to 'TransactionTooLargeException'. The late version delegates to addData method, and there is no inline exception handling or RemoteException catching in this version of the method, which indicates changes in the method's internal behavior and potential error handling. The change in the method's implementation could lead to different return behavior in case of exceptions, and hence the CI type is 1."
387,<android.bluetooth.BluetoothAdapter: boolean disable()>,30,31,<android.bluetooth.BluetoothAdapter: boolean disable()>,<android.bluetooth.BluetoothAdapter: boolean disable()>,0,"{
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        return mManagerService.disable(mAttributionSource, true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 *
 * @return true to indicate adapter shutdown has begun, or false on immediate error
 */
","/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 *
 * @return true to indicate adapter shutdown has begun, or false on immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method parameter passed to mManagerService.disable has changed from ActivityThread.currentPackageName() to mAttributionSource without altering the control flow or the behavior of return and exception handling statements, so the code change type is 4. Moreover, the dependent API being called has changed its expected parameters, which leads to code change type 5.","Although there is a change in the call to the dependent API (the parameter passed to disable), it does not affect the behavior of the BluetoothAdapter.disable() method in terms of the return value or exception handling; therefore, it is not a Compatibility Issue according to the defined criteria. The return false statement is still reached the same way in case of RemoteException and the true/false return behavior of the method remains unchanged. Thus, there is no Compatibility Issue, 0."
388,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",30,31,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    authenticateInternal(null, /* crypto */
    cancel, executor, callback, mContext.getUserId());
}","{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_PROMPT_AUTHENTICATE_INVOKED, false, /* isCrypto */
    mPromptInfo.isConfirmationRequested(), mPromptInfo.isDeviceCredentialAllowed(), mPromptInfo.getAuthenticators() != Authenticators.EMPTY_SET, mPromptInfo.getAuthenticators());
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    authenticateInternal(null, /* crypto */
    cancel, executor, callback, mContext.getUserId());
}",1,"/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * @throws IllegalArgumentException If any of the arguments are null.
 *
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)} is called, or when
 * the user dismisses the system-provided dialog.  This operation can be canceled by using the
 * provided cancel object. The application will receive authentication errors through {@link
 * AuthenticationCallback}, and button events through the corresponding callback set in {@link
 * Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.  It is
 * safe to reuse the {@link BiometricPrompt} object, and calling {@link
 * BiometricPrompt#authenticate(CancellationSignal, Executor, AuthenticationCallback)} while
 * an existing authentication attempt is occurring will stop the previous client and start a new
 * authentication. The interrupted client will receive a cancelled notification through {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * @throws IllegalArgumentException If any of the arguments are null.
 *
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,4,0,"There has been an addition of a method call to FrameworkStatsLog.write() at the beginning of the implementation, but the workflow and the control flow of the method did not change. They both check for null arguments and call authenticateInternal with the same parameters. Other than the new logging statement, there are no changes in return statements, exception handling, or other code logic, hence the code change type is 4 (Other statement changed).","The added logging statement has no impact on the return values, types, or exceptions thrown by this method. It does not change how the method executes in any way that would be observable to the caller (except for the side effects of logging itself, assuming FrameworkStatsLog.write() does not throw an exception that would change the method's behavior). Thus, there is no Compatibility Issue, resulting in CI type 0 (No Compatibility Issue)."
389,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,30,31,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,<android.content.pm.LauncherActivityInfo: long getFirstInstallTime()>,0,"{
    try {
        // TODO: Go through LauncherAppsService
        return mPm.getPackageInfo(mActivityInfo.packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES).firstInstallTime;
    } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        return 0;
    }
}","{
    try {
        // TODO: Go through LauncherAppsService
        return mPm.getPackageInfo(getActivityInfo().packageName, PackageManager.MATCH_UNINSTALLED_PACKAGES).firstInstallTime;
    } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        return 0;
    }
}",1,"/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
","/**
 * Returns the time at which the package was first installed.
 *
 * @return The time of installation of the package, in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call from mActivityInfo.packageName to getActivityInfo().packageName has changed, so the code change type is 5.","The replacement of mActivityInfo with getActivityInfo() does not result in a compatibility issue since the method getActivityInfo() most likely exists to encapsulate access to mActivityInfo fields such as packageName. There's no indication that the behavior of how the package name is retrieved has changed, indicating that the returned value remains consistent with the early version. Therefore, no compatibility issue is present."
390,<android.app.ActivityManager: AppTask> getAppTasks()>,30,31,<android.app.ActivityManager: AppTask> getAppTasks()>,<android.app.ActivityManager: AppTask> getAppTasks()>,0,"{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IBinder> appTasks;
    try {
        appTasks = getTaskService().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));
    }
    return tasks;
}","{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IBinder> appTasks;
    try {
        appTasks = getTaskService().getAppTasks(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(IAppTask.Stub.asInterface(appTasks.get(i))));
    }
    return tasks;
}",1,"/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
","/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used inside the method implementation changed from mContext.getPackageName() to mContext.getOpPackageName(). Thus, the code change type is 5.","There is no Compatibility Issue detected here, since the change from mContext.getPackageName() to mContext.getOpPackageName() is internal and would not affect the return value or the exception handling of the method for the caller. Therefore, the CI type is 0."
391,<android.app.ActivityOptions: Bundle toBundle()>,30,31,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the GraphicBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.createGraphicBufferHandle());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mSplitScreenCreateMode != SPLIT_SCREEN_CREATE_MODE_TOP_OR_LEFT) {
        b.putInt(KEY_SPLIT_SCREEN_CREATE_MODE, mSplitScreenCreateMode);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putBinder(KEY_REMOTE_TRANSITION, mRemoteTransition.asBinder());
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
392,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,30,31,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,0,"{
    final Parcelable parcelable = container.get(generateId());
    SparseArray<Parcelable> jail = null;
    if (parcelable instanceof Bundle) {
        jail = ((Bundle) parcelable).getSparseParcelableArray(KEY_JAILED_ARRAY);
    }
    if (jail == null)
        jail = new SparseArray<>();
    try {
        super.dispatchRestoreInstanceState(jail);
    } catch (Exception e) {
        Log.e(TAG, ""failed to restoreInstanceState for widget id: "" + mAppWidgetId + "", "" + (mInfo == null ? ""null"" : mInfo.provider), e);
    }
}","{
    final Parcelable parcelable = container.get(generateId());
    SparseArray<Parcelable> jail = null;
    long inflationId = -1;
    if (parcelable instanceof Bundle) {
        Bundle bundle = (Bundle) parcelable;
        jail = bundle.getSparseParcelableArray(KEY_JAILED_ARRAY);
        inflationId = bundle.getLong(KEY_INFLATION_ID, -1);
    }
    if (jail == null)
        jail = new SparseArray<>();
    mDelayedRestoredState = jail;
    mDelayedRestoredInflationId = inflationId;
    restoreInstanceState();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version of the method introduces new variables 'inflationId' and 'bundle', changes control-flow by removing 'super.dispatchRestoreInstanceState(jail)' and replaces it with new logic 'restoreInstanceState()', and also introduces new assignments to 'mDelayedRestoredState' and 'mDelayedRestoredInflationId', respectively. The changes involve adding new local variables, altering control flow and other statements. Therefore, the code change types are 1,3,4.","The new implementation removes the direct call to 'super.dispatchRestoreInstanceState(jail)' and instead sets up some state to be used later by another method 'restoreInstanceState()'. This change alters how and when the state is restored, potentially leading to different behavior. As a result, the CI type is 1."
393,<android.content.pm.ShortcutManager: void reportShortcutUsed(String)>,30,31,<android.content.pm.ShortcutManager: void reportShortcutUsed(String)>,<android.content.pm.ShortcutManager: void reportShortcutUsed(String)>,0,"{
    try {
        mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Apps that publish shortcuts should call this method whenever the user
 * selects the shortcut containing the given ID or when the user completes
 * an action in the app that is equivalent to selecting the shortcut.
 * For more details, read about
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#track-usage"">
 * tracking shortcut usage</a>.
 *
 * <p>The information is accessible via {@link UsageStatsManager#queryEvents}
 * Typically, launcher apps use this information to build a prediction model
 * so that they can promote the shortcuts that are likely to be used at the moment.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Apps that publish shortcuts should call this method whenever the user
 * selects the shortcut containing the given ID or when the user completes
 * an action in the app that is equivalent to selecting the shortcut.
 * For more details, read about
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#track-usage"">
 * tracking shortcut usage</a>.
 *
 * <p>The information is accessible via {@link UsageStatsManager#queryEvents}
 * Typically, launcher apps use this information to build a prediction model
 * so that they can promote the shortcuts that are likely to be used at the moment.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the method called within the try block; it has changed from directly calling `mService.reportShortcutUsed(...)` to calling `getFutureOrThrow(mService.reportShortcutUsed(...))`. This indicates that there was a change in the dependent API, which is now possibly invoked via an additional layer that handles the result as a future object. However, since there are no details about the implementation of `getFutureOrThrow()`, we conclude it to be 4,5 due to the change in the API being called.","The change seems to be adapting a new way to handle the service call without altering the external behavior of the method `reportShortcutUsed`. Assuming that the `getFutureOrThrow` method properly captures and handles the result or exception from the `mService.reportShortcutUsed` method, there should not be a compatibility issue since the way in which exceptions are handled remains the same and the method's signature and return type have not changed. The exception is still rethrown in the catch clause. Thus, no Compatibility Issue should arise from this change."
394,<android.view.VerifiedKeyEvent: Boolean getFlag(int)>,30,31,<android.view.VerifiedKeyEvent: Boolean getFlag(int)>,<android.view.VerifiedKeyEvent: Boolean getFlag(int)>,0,"{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_CANCELED:
            return (mFlags & flag) != 0;
    }
    return null;
}","{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_CANCELED:
        case FLAG_IS_ACCESSIBILITY_EVENT:
            return (mFlags & flag) != 0;
    }
    return null;
}",1,"/**
 * Get a specific flag of this key event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the key event has the requested flag
 * Boolean(false) if the key event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see KeyEvent#getFlags()
 * @see KeyEvent#FLAG_CANCELED
 */
","/**
 * Get a specific flag of this key event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the key event has the requested flag
 * Boolean(false) if the key event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see KeyEvent#getFlags()
 * @see KeyEvent#FLAG_CANCELED
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"An additional case `FLAG_IS_ACCESSIBILITY_EVENT` has been added to the switch statement which affects the control dependency, hence the change is categorized as 3.","Since the method returns `null` as the default case in both versions and the new case added to the switch block follows the same pattern of returning a boolean result `(mFlags & flag) != 0`, there's no change in the types or values of the returned data. Therefore, there is no Compatibility Issue, marked as 0."
396,<android.view.View: boolean onTouchEvent(MotionEvent)>,30,31,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    if (!pointInView(x, y, touchSlop)) {
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout() * mAmbiguousGestureMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= mAmbiguousGestureMultiplier;
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(0, /* send immediately */
                    x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();
    final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
    if ((viewFlags & ENABLED_MASK) == DISABLED && (mPrivateFlags4 & PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) {
        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
        // events, it just doesn't respond to them.
        return clickable;
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
        switch(action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags & TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }
                    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClickInternal();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;
            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;
                if (!clickable) {
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    break;
                }
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                break;
            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }
                final int motionClassification = event.getClassification();
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                int touchSlop = mTouchSlop;
                if (ambiguousGesture && hasPendingLongPressCallback()) {
                    if (!pointInView(x, y, touchSlop)) {
                        // The default action here is to cancel long press. But instead, we
                        // just extend the timeout here, in case the classification
                        // stays ambiguous.
                        removeLongPressCallback();
                        long delay = (long) (ViewConfiguration.getLongPressTimeout() * mAmbiguousGestureMultiplier);
                        // Subtract the time already spent
                        delay -= event.getEventTime() - event.getDownTime();
                        checkForLongClick(delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);
                    }
                    touchSlop *= mAmbiguousGestureMultiplier;
                }
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, touchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                }
                final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
                if (deepPress && hasPendingLongPressCallback()) {
                    // process the long click action immediately
                    removeLongPressCallback();
                    checkForLongClick(0, /* send immediately */
                    x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 * <p>
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * <ul>
 * <li>obeying click sound preferences
 * <li>dispatching OnClickListener calls
 * <li>handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * </ul>
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
397,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,30,31,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,<android.nfc.cardemulation.CardEmulation: int getSelectionModeForCategory(String)>,0,"{
    if (CATEGORY_PAYMENT.equals(category)) {
        String defaultComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_DEFAULT_COMPONENT);
        if (defaultComponent != null) {
            return SELECTION_MODE_PREFER_DEFAULT;
        } else {
            return SELECTION_MODE_ALWAYS_ASK;
        }
    } else {
        return SELECTION_MODE_ASK_IF_CONFLICT;
    }
}","{
    if (CATEGORY_PAYMENT.equals(category)) {
        boolean paymentRegistered = false;
        try {
            paymentRegistered = sService.isDefaultPaymentRegistered();
        } catch (RemoteException e) {
            recoverService();
            if (sService == null) {
                Log.e(TAG, ""Failed to recover CardEmulationService."");
                return SELECTION_MODE_ALWAYS_ASK;
            }
            try {
                paymentRegistered = sService.isDefaultPaymentRegistered();
            } catch (RemoteException ee) {
                Log.e(TAG, ""Failed to reach CardEmulationService."");
                return SELECTION_MODE_ALWAYS_ASK;
            }
        }
        if (paymentRegistered) {
            return SELECTION_MODE_PREFER_DEFAULT;
        } else {
            return SELECTION_MODE_ALWAYS_ASK;
        }
    } else {
        return SELECTION_MODE_ASK_IF_CONFLICT;
    }
}",1,"/**
 * Returns the service selection mode for the passed in category.
 * Valid return values are:
 * <p>{@link #SELECTION_MODE_PREFER_DEFAULT} the user has requested a default
 * service for this category, which will be preferred.
 * <p>{@link #SELECTION_MODE_ALWAYS_ASK} the user has requested to be asked
 * every time what service he would like to use in this category.
 * <p>{@link #SELECTION_MODE_ASK_IF_CONFLICT} the user will only be asked
 * to pick a service if there is a conflict.
 * @param category The category, for example {@link #CATEGORY_PAYMENT}
 * @return the selection mode for the passed in category
 */
","/**
 * Returns the service selection mode for the passed in category.
 * Valid return values are:
 * <p>{@link #SELECTION_MODE_PREFER_DEFAULT} the user has requested a default
 * service for this category, which will be preferred.
 * <p>{@link #SELECTION_MODE_ALWAYS_ASK} the user has requested to be asked
 * every time what service they would like to use in this category.
 * <p>{@link #SELECTION_MODE_ASK_IF_CONFLICT} the user will only be asked
 * to pick a service if there is a conflict.
 * @param category The category, for example {@link #CATEGORY_PAYMENT}
 * @return the selection mode for the passed in category
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","The early version API uses `Settings.Secure.getString` to determine the return value, while the late version API calls `sService.isDefaultPaymentRegistered()`. The late version includes additional exception handling for `RemoteException`, a recovery attempt by calling `recoverService()` , and additional exception handling for a subsequent call to `sService.isDefaultPaymentRegistered()`. Thus, there are changes in exception handling statements, control dependency, and a dependent API, so the code change type is 2,3,5.","These changes can lead to differences in behavior: due to the new way of determining `paymentRegistered` and the additional exception handling, a user may now encounter different return values. Especially, in the case of a `RemoteException`, the early version does not include logic to recover from the service failure, while the late version attempts to do so. Depending on the success of the recovery, the final return value can differ. As such, there is a compatibility issue caused by potentially different return values and exception handlings, and the CI type is 1,2."
398,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,30,31,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,<android.app.Activity: void setPictureInPictureParams(PictureInPictureParams)>,0,"{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        ActivityTaskManager.getService().setPictureInPictureParams(mToken, params);
    } catch (RemoteException e) {
    }
}","{
    if (!deviceSupportsPictureInPictureMode()) {
        return;
    }
    if (params == null) {
        throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
    }
    ActivityClient.getInstance().setPictureInPictureParams(mToken, params);
}",1,"/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
","/**
 * Updates the properties of the picture-in-picture activity, or sets it to be used later when
 * {@link #enterPictureInPictureMode()} is called.
 *
 * @param params the new parameters for the picture-in-picture.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change involves a dependent API call: from ActivityTaskManager.getService().setPictureInPictureParams(...) to ActivityClient.getInstance().setPictureInPictureParams(...). Thus, this is a change in type 4 (Other statement changed), and type 5 (Dependent API changed) since the method being called on a different object might refer to a different implementation.","There is no compatibility issue in this change because the external behavior of the API, in terms of return values or exception handling, has not been altered. The try-catch block was removed, but since the catch block was empty, its removal doesn't affect how exceptions are handled by the method; thus, the API's contract in terms of observable behavior remains the same."
399,<android.content.pm.PackageParserCacheHelper.ReadHelper: void startAndInstall()>,30,31,<android.content.pm.PackageParserCacheHelper.ReadHelper: void startAndInstall()>,<android.content.pm.PackageParserCacheHelper.ReadHelper: void startAndInstall()>,0,"{
    mStrings.clear();
    final int poolPosition = mParcel.readInt();
    final int startPosition = mParcel.dataPosition();
    // The pool is at the end of the parcel.
    mParcel.setDataPosition(poolPosition);
    mParcel.readStringList(mStrings);
    // Then move back.
    mParcel.setDataPosition(startPosition);
    if (DEBUG) {
        Log.i(TAG, ""Read "" + mStrings.size() + "" strings"");
        for (int i = 0; i < mStrings.size(); i++) {
            Log.i(TAG, ""  "" + i + "": \"""" + mStrings.get(i) + ""\"""");
        }
    }
    mParcel.setReadWriteHelper(this);
}","{
    mStrings.clear();
    final int poolPosition = mParcel.readInt();
    if (poolPosition < 0) {
        throw new IllegalStateException(""Invalid string pool position: "" + poolPosition);
    }
    final int startPosition = mParcel.dataPosition();
    // The pool is at the end of the parcel.
    mParcel.setDataPosition(poolPosition);
    mParcel.readStringList(mStrings);
    // Then move back.
    mParcel.setDataPosition(startPosition);
    if (DEBUG) {
        Log.i(TAG, ""Read "" + mStrings.size() + "" strings"");
        for (int i = 0; i < mStrings.size(); i++) {
            Log.i(TAG, ""  "" + i + "": \"""" + mStrings.get(i) + ""\"""");
        }
    }
    mParcel.setReadWriteHelper(this);
}",1,"/**
 * Prepare to read from a parcel, and install itself as a read-write helper.
 *
 * (We don't do it in the constructor to avoid calling methods before the constructor
 * finishes.)
 */
","/**
 * Prepare to read from a parcel, and install itself as a read-write helper.
 *
 * (We don't do it in the constructor to avoid calling methods before the constructor
 * finishes.)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"An `if` control statement has been inserted that checks the `poolPosition`, and it throws a new `IllegalStateException` if a certain condition is met. The code change type includes 2 for the exception handling statement change and 3 for the control dependency change.","The new `if` control dependency could lead to a new IllegalStateException being thrown that was not present before, potentially leading to a CI due to different exception handlings. Therefore, CI type is 2."
400,<android.app.Activity: void setInheritShowWhenLocked(boolean)>,30,31,<android.app.Activity: void setInheritShowWhenLocked(boolean)>,<android.app.Activity: void setInheritShowWhenLocked(boolean)>,0,"{
    try {
        ActivityTaskManager.getService().setInheritShowWhenLocked(mToken, inheritShowWhenLocked);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    ActivityClient.getInstance().setInheritShowWhenLocked(mToken, inheritShowWhenLocked);
}",1,"/**
 * Specifies whether this {@link Activity} should be shown on top of the lock screen whenever
 * the lockscreen is up and this activity has another activity behind it with the showWhenLock
 * attribute set. That is, this activity is only visible on the lock screen if there is another
 * activity with the showWhenLock attribute visible at the same time on the lock screen. A use
 * case for this is permission dialogs, that should only be visible on the lock screen if their
 * requesting activity is also visible. This value can be set as a manifest attribute using
 * android.R.attr#inheritShowWhenLocked.
 *
 * @param inheritShowWhenLocked {@code true} to show the {@link Activity} on top of the lock
 * screen when this activity has another activity behind it with
 * the showWhenLock attribute set; {@code false} otherwise.
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#inheritShowWhenLocked
 */
","/**
 * Specifies whether this {@link Activity} should be shown on top of the lock screen whenever
 * the lockscreen is up and this activity has another activity behind it with the showWhenLock
 * attribute set. That is, this activity is only visible on the lock screen if there is another
 * activity with the showWhenLock attribute visible at the same time on the lock screen. A use
 * case for this is permission dialogs, that should only be visible on the lock screen if their
 * requesting activity is also visible. This value can be set as a manifest attribute using
 * android.R.attr#inheritShowWhenLocked.
 *
 * @param inheritShowWhenLocked {@code true} to show the {@link Activity} on top of the lock
 * screen when this activity has another activity behind it with
 * the showWhenLock attribute set; {@code false} otherwise.
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#inheritShowWhenLocked
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the method changed from calling ActivityTaskManager.getService().setInheritShowWhenLocked to calling ActivityClient.getInstance().setInheritShowWhenLocked. This does not change the control flow or exception handling of the method, but the underlying implementation now calls a different API, leading to a dependent API changed. Therefore, the code change types are 4 for changing the method call and 5 for changing the dependent API.","Despite the change in the implementation, this does not appear to affect the behavior of the method from the perspective of an API consumer because the method's signature, return type, and exception handling remain the same. The method does not return any value (it is void), and there is no information on whether the new implementation could throw different exceptions. Assuming that the new implementation of setInheritShowWhenLocked via ActivityClient.getInstance() successfully abstracts the underlying processes in the same way as the earlier version did with ActivityTaskManager.getService(), there should be no compatibility issue, thus the CI type is 0."
401,"<android.database.DatabaseUtils: void dumpCurrentRow(Cursor,StringBuilder)>",30,31,"<android.database.DatabaseUtils: void dumpCurrentRow(Cursor,StringBuilder)>","<android.database.DatabaseUtils: void dumpCurrentRow(Cursor,StringBuilder)>",0,"{
    String[] cols = cursor.getColumnNames();
    sb.append("""" + cursor.getPosition() + "" {\n"");
    int length = cols.length;
    for (int i = 0; i < length; i++) {
        String value;
        try {
            value = cursor.getString(i);
        } catch (SQLiteException e) {
            // assume that if the getString threw this exception then the column is not
            // representable by a string, e.g. it is a BLOB.
            value = ""<unprintable>"";
        }
        sb.append(""   "" + cols[i] + '=' + value + ""\n"");
    }
    sb.append(""}\n"");
}","{
    String[] cols = cursor.getColumnNames();
    sb.append(cursor.getPosition()).append("" {\n"");
    int length = cols.length;
    for (int i = 0; i < length; i++) {
        String value;
        try {
            value = cursor.getString(i);
        } catch (SQLiteException e) {
            // assume that if the getString threw this exception then the column is not
            // representable by a string, e.g. it is a BLOB.
            value = ""<unprintable>"";
        }
        sb.append(""   "").append(cols[i]).append('=').append(value).append('\n');
    }
    sb.append(""}\n"");
}",1,"/**
 * Prints the contents of a Cursor's current row to a StringBuilder.
 *
 * @param cursor the cursor to print
 * @param sb the StringBuilder to print to
 */
","/**
 * Prints the contents of a Cursor's current row to a StringBuilder.
 *
 * @param cursor the cursor to print
 * @param sb the StringBuilder to print to
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is related to how strings are appended to `StringBuilder` (`sb`). Early implementation uses concatenation with the `+` operator, while late implementation uses `StringBuilder`'s `append` method. This kind of change doesn't affect the control flow or logic of the method, so the change type is 4.","This change only modifies how strings are constructed and appended to the `StringBuilder`. It does not affect the API's behavior regarding return values, exception handling, or control flow; therefore, there is no Compatibility Issue, and the CI type is 0."
402,<android.os.SystemClock: Clock currentGnssTimeClock()>,30,31,<android.os.SystemClock: Clock currentGnssTimeClock()>,<android.os.SystemClock: Clock currentGnssTimeClock()>,0,"{
    return new SimpleClock(ZoneOffset.UTC) {

        private final ILocationManager mMgr = ILocationManager.Stub.asInterface(ServiceManager.getService(Context.LOCATION_SERVICE));

        @Override
        public long millis() {
            LocationTime time;
            try {
                time = mMgr.getGnssTimeMillis();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
                return 0;
            }
            if (time == null) {
                throw new DateTimeException(""Gnss based time is not available."");
            }
            long currentNanos = elapsedRealtimeNanos();
            long deltaMs = (currentNanos - time.getElapsedRealtimeNanos()) / 1000000L;
            return time.getTime() + deltaMs;
        }
    };
}","{
    return new SimpleClock(ZoneOffset.UTC) {

        private final ILocationManager mMgr = ILocationManager.Stub.asInterface(ServiceManager.getService(Context.LOCATION_SERVICE));

        @Override
        public long millis() {
            LocationTime time;
            try {
                time = mMgr.getGnssTimeMillis();
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            if (time == null) {
                throw new DateTimeException(""Gnss based time is not available."");
            }
            long currentNanos = elapsedRealtimeNanos();
            long deltaMs = (currentNanos - time.getElapsedRealtimeNanos()) / 1000000L;
            return time.getTime() + deltaMs;
        }
    };
}",1,"/**
 * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,
 * synchronized using the device's location provider.
 *
 * @throws DateTimeException when the location provider has not had a location fix since boot.
 */
","/**
 * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,
 * synchronized using the device's location provider.
 *
 * @throws DateTimeException when the location provider has not had a location fix since boot.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,2,2,"The change between the two versions is in the exception handling within the millis() method. In the early version, there is an attempt to rethrow the RemoteException, followed by returning 0, whereas the late version simply throws the exception without returning a value.","There is a Compatibility Issue related to exception handling because the early version of the API catches a RemoteException and returns 0, while the late version rethrows the exception. This could cause code that previously caught an exception without impacting flow to now terminate due to an unhandled exception. Therefore, the CI type is 2."
403,<android.app.Activity: boolean isVoiceInteractionRoot()>,30,31,<android.app.Activity: boolean isVoiceInteractionRoot()>,<android.app.Activity: boolean isVoiceInteractionRoot()>,0,"{
    try {
        return mVoiceInteractor != null && ActivityTaskManager.getService().isRootVoiceInteraction(mToken);
    } catch (RemoteException e) {
    }
    return false;
}","{
    return mVoiceInteractor != null && ActivityClient.getInstance().isRootVoiceInteraction(mToken);
}",1,"/**
 * Like {@link #isVoiceInteraction}, but only returns {@code true} if this is also the root
 * of a voice interaction.  That is, returns {@code true} if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns {@code false}.
 * If the activity {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode} is
 * {@code singleTask}, it forces the activity to launch in a new task, separate from the one
 * that started it. Therefore, there is no longer a relationship between them, and
 * {@link #isVoiceInteractionRoot()} return {@code false} in this case.
 */
","/**
 * Like {@link #isVoiceInteraction}, but only returns {@code true} if this is also the root
 * of a voice interaction.  That is, returns {@code true} if this activity was directly
 * started by the voice interaction service as the initiation of a voice interaction.
 * Otherwise, for example if it was started by another activity while under voice
 * interaction, returns {@code false}.
 * If the activity {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode} is
 * {@code singleTask}, it forces the activity to launch in a new task, separate from the one
 * that started it. Therefore, there is no longer a relationship between them, and
 * {@link #isVoiceInteractionRoot()} return {@code false} in this case.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The exception handling statement has been removed, and the dependent API used within the return statement has changed from ActivityTaskManager.getService().isRootVoiceInteraction(mToken) to ActivityClient.getInstance().isRootVoiceInteraction(mToken), so the code change types are 2,5.","The removal of the try-catch block means that RemoteException will no longer be caught and will potentially be propagated as a new exception for callers to handle. Coupled with the change in the dependent API which could throw a different set of checked exceptions or have different runtime exception behavior, there is a potential Compatibility Issue due to different exception handling, which is type 2."
404,<android.os.FileBridge.FileBridgeOutputStream: void close()>,30,31,<android.os.FileBridge.FileBridgeOutputStream: void close()>,<android.os.FileBridge.FileBridgeOutputStream: void close()>,0,"{
    try {
        writeCommandAndBlock(CMD_CLOSE, ""close()"");
    } finally {
        IoBridge.closeAndSignalBlockedThreads(mClient);
        IoUtils.closeQuietly(mClientPfd);
    }
}","{
    try {
        writeCommandAndBlock(CMD_CLOSE, ""close()"");
    } finally {
        IoUtils.closeQuietly(mClientPfd);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement IoBridge.closeAndSignalBlockedThreads(mClient) has been removed in the late implementation, but there is no change to control flow or return value, so the code change type is 4.","There is no compatibility issue because the removal of IoBridge.closeAndSignalBlockedThreads(mClient) does not affect the return value or the exceptions thrown by the method; it is an internal implementation detail related to resource cleanup, the behavior facing the caller remains consistent. Therefore, the CI type is 0."
406,"<android.view.SurfaceControl.Transaction: void writeToParcel(Parcel,int)>",30,31,"<android.view.SurfaceControl.Transaction: void writeToParcel(Parcel,int)>","<android.view.SurfaceControl.Transaction: void writeToParcel(Parcel,int)>",0,"{
    if (mNativeObject == 0) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
    }
    nativeWriteTransactionToParcel(mNativeObject, dest);
}","{
    if (mNativeObject == 0) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    nativeWriteTransactionToParcel(mNativeObject, dest);
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        nativeClearTransaction(mNativeObject);
    }
}",1,"/**
 * Writes the transaction to parcel, clearing the transaction as if it had been applied so
 * it can be used to store future transactions. It's the responsibility of the parcel
 * reader to apply the original transaction.
 *
 * @param dest parcel to write the transaction to
 * @param flags
 */
","/**
 * Writes the transaction to parcel, clearing the transaction as if it had been applied so
 * it can be used to store future transactions. It's the responsibility of the parcel
 * reader to apply the original transaction.
 *
 * @param dest parcel to write the transaction to
 * @param flags
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, there is a 'return' statement added, which could lead to a premature termination of the method. Additionally, a new if block has been added that checks for a flag and then potentially invokes a new method, 'nativeClearTransaction'. Therefore, there have been changes to the return statements, control dependency, and other statements, leading to change types 1, 3, and 4.","The addition of the 'return' statement after writing an integer to the Parcel means that in cases where mNativeObject is 0, the method will exit early and no further actions will be performed which is different than the early version. Furthermore, the behavior when the Parcelable.PARCELABLE_WRITE_RETURN_VALUE flag is set is new and will potentially clear the transaction through 'nativeClearTransaction', possibly affecting the state of 'mNativeObject' after the method call. Therefore, the CI type is 1."
409,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",30,31,"<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A comment inline was added to the method call of broadcastIntentWithFeature(). The parameters of the method remain the same, and the addition of a comment does not change the logic or execution path of the code. This is classified as 'Other statement changed.'","Since the comment has no impact on the execution of the method or on its return value or exceptions thrown, no compatibility issue arises."
410,<android.view.Display.Mode: int hashCode()>,30,31,<android.view.Display.Mode: int hashCode()>,<android.view.Display.Mode: int hashCode()>,0,"{
    int hash = 1;
    hash = hash * 17 + mModeId;
    hash = hash * 17 + mWidth;
    hash = hash * 17 + mHeight;
    hash = hash * 17 + Float.floatToIntBits(mRefreshRate);
    return hash;
}","{
    int hash = 1;
    hash = hash * 17 + mModeId;
    hash = hash * 17 + mWidth;
    hash = hash * 17 + mHeight;
    hash = hash * 17 + Float.floatToIntBits(mRefreshRate);
    hash = hash * 17 + Arrays.hashCode(mAlternativeRefreshRates);
    return hash;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late implementation has an additional statement that incorporates mAlternativeRefreshRates into the hash computation, which is a modification to the hashCode algorithm, and that is why the code change type is 1,4.","The change to the hash code computation will cause the method to potentially return a different hash value for the same object if mAlternativeRefreshRates are different than before. As hashCode is supposed to return consistent values for the same object state within a single execution of an application, this change could induce a Compatibility Issue if the hash value is used in collections or any data structure relying on the consistent behavior of hashCode. Therefore, the CI type is 1."
412,<android.content.pm.Signature: boolean equals(Object)>,30,31,<android.content.pm.Signature: boolean equals(Object)>,<android.content.pm.Signature: boolean equals(Object)>,0,"{
    try {
        if (obj != null) {
            Signature other = (Signature) obj;
            return this == other || Arrays.equals(mSignature, other.mSignature);
        }
    } catch (ClassCastException e) {
    }
    return false;
}","{
    try {
        if (obj != null) {
            Signature other = (Signature) obj;
            // only comparing the mSignature arrays without the flags.
            return this == other || Arrays.equals(mSignature, other.mSignature);
        }
    } catch (ClassCastException e) {
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"While there is a comment added in the late implementation, no actual code logic has changed. The implementations are identical with regard to their executable statements.",There is no Compatibility Issue because no executable statements or behaviors have changed between the early and late versions.
414,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,30,31,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,<android.service.notification.ZenModeConfig.ZenRule: boolean isAutomaticActive()>,0,"{
    return enabled && !snoozing && pkg != null && isTrueOrUnknown();
}","{
    return enabled && !snoozing && getPkg() != null && isTrueOrUnknown();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The member `pkg` was accessed directly in the early version, whereas a method call `getPkg()` is being made in the late version, representing a change in the attribute to a method invocation. Hence, the changes fall under code change types 4 and 5.","The change from directly accessing a member variable to using an accessor method could lead to a potential different return value. If the implementation of `getPkg()` differs from the direct access to `pkg` (such as performing additional checks), the returned boolean value of `isAutomaticActive()` could be different. Therefore, the CI type is 1."
415,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",30,31,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    if ((flags & (PackageManager.MATCH_DIRECT_BOOT_UNAWARE | PackageManager.MATCH_DIRECT_BOOT_AWARE)) == 0) {
        // Caller expressed no opinion about what encryption
        // aware/unaware components they want to see, so match both
        flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
    }
    boolean collectCertificates = (flags & PackageManager.GET_SIGNATURES) != 0 || (flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0;
    ParseInput input = ParseTypeImpl.forParsingWithoutPlatformCompat().reset();
    ParseResult<ParsingPackage> result = ParsingPackageUtils.parseDefault(input, new File(archiveFilePath), 0, collectCertificates);
    if (result.isError()) {
        return null;
    }
    return PackageInfoWithoutStateUtils.generate(result.getResult(), null, flags, 0, 0, null, new PackageUserState(), UserHandle.getCallingUserId());
}","{
    throw new UnsupportedOperationException(""getPackageArchiveInfo() not implemented in subclass"");
}",1,"/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
","/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,4",1,"The method in the late version always throws an UnsupportedOperationException and lacks the original implementation entirely, so there is a return statement change (deletion of the original return statements) and other statements change (the late implementation is completely different from the early one), thus the changes are of type 1,4.","In the late version, regardless of the input parameters, the method will throw an exception compared to the early version that had a proper implementation. This leads to a completely different behavior, which is a compatibility issue due to a potentially different return value (type 1)."
416,"<android.widget.SmartSelectSprite: void startAnimation(PointF,List<RectangleWithTextSelectionLayout>,Runnable)>",30,31,"<android.widget.SmartSelectSprite: void startAnimation(PointF,List<RectangleWithTextSelectionLayout>,Runnable)>","<android.widget.SmartSelectSprite: void startAnimation(PointF,List<RectangleWithTextSelectionLayout>,Runnable)>",0,"{
    cancelAnimation();
    final ValueAnimator.AnimatorUpdateListener updateListener = valueAnimator -> mInvalidator.run();
    final int rectangleCount = destinationRectangles.size();
    final List<RoundedRectangleShape> shapes = new ArrayList<>(rectangleCount);
    final List<Animator> cornerAnimators = new ArrayList<>(rectangleCount);
    RectangleWithTextSelectionLayout centerRectangle = null;
    int startingOffset = 0;
    for (RectangleWithTextSelectionLayout rectangleWithTextSelectionLayout : destinationRectangles) {
        final RectF rectangle = rectangleWithTextSelectionLayout.getRectangle();
        if (contains(rectangle, start)) {
            centerRectangle = rectangleWithTextSelectionLayout;
            break;
        }
        startingOffset += rectangle.width();
    }
    if (centerRectangle == null) {
        throw new IllegalArgumentException(""Center point is not inside any of the rectangles!"");
    }
    startingOffset += start.x - centerRectangle.getRectangle().left;
    @RoundedRectangleShape.ExpansionDirection final int[] expansionDirections = generateDirections(centerRectangle, destinationRectangles);
    for (int index = 0; index < rectangleCount; ++index) {
        final RectangleWithTextSelectionLayout rectangleWithTextSelectionLayout = destinationRectangles.get(index);
        final RectF rectangle = rectangleWithTextSelectionLayout.getRectangle();
        final RoundedRectangleShape shape = new RoundedRectangleShape(rectangle, expansionDirections[index], rectangleWithTextSelectionLayout.getTextSelectionLayout() == Layout.TEXT_SELECTION_LAYOUT_RIGHT_TO_LEFT);
        cornerAnimators.add(createCornerAnimator(shape, updateListener));
        shapes.add(shape);
    }
    final RectangleList rectangleList = new RectangleList(shapes);
    final ShapeDrawable shapeDrawable = new ShapeDrawable(rectangleList);
    final Paint paint = shapeDrawable.getPaint();
    paint.setColor(mFillColor);
    paint.setStyle(Paint.Style.FILL);
    mExistingRectangleList = rectangleList;
    mExistingDrawable = shapeDrawable;
    mActiveAnimator = createAnimator(rectangleList, startingOffset, startingOffset, cornerAnimators, updateListener, onAnimationEnd);
    mActiveAnimator.start();
}","{
    cancelAnimation();
    final ValueAnimator.AnimatorUpdateListener updateListener = valueAnimator -> mInvalidator.run();
    final int rectangleCount = destinationRectangles.size();
    final List<RoundedRectangleShape> shapes = new ArrayList<>(rectangleCount);
    RectangleWithTextSelectionLayout centerRectangle = null;
    int startingOffset = 0;
    for (RectangleWithTextSelectionLayout rectangleWithTextSelectionLayout : destinationRectangles) {
        final RectF rectangle = rectangleWithTextSelectionLayout.getRectangle();
        if (contains(rectangle, start)) {
            centerRectangle = rectangleWithTextSelectionLayout;
            break;
        }
        startingOffset += rectangle.width();
    }
    if (centerRectangle == null) {
        throw new IllegalArgumentException(""Center point is not inside any of the rectangles!"");
    }
    startingOffset += start.x - centerRectangle.getRectangle().left;
    @RoundedRectangleShape.ExpansionDirection final int[] expansionDirections = generateDirections(centerRectangle, destinationRectangles);
    for (int index = 0; index < rectangleCount; ++index) {
        final RectangleWithTextSelectionLayout rectangleWithTextSelectionLayout = destinationRectangles.get(index);
        final RectF rectangle = rectangleWithTextSelectionLayout.getRectangle();
        final RoundedRectangleShape shape = new RoundedRectangleShape(rectangle, expansionDirections[index], rectangleWithTextSelectionLayout.getTextSelectionLayout() == Layout.TEXT_SELECTION_LAYOUT_RIGHT_TO_LEFT);
        shapes.add(shape);
    }
    final RectangleList rectangleList = new RectangleList(shapes);
    final ShapeDrawable shapeDrawable = new ShapeDrawable(rectangleList);
    final Paint paint = shapeDrawable.getPaint();
    paint.setColor(mFillColor);
    paint.setStyle(Paint.Style.FILL);
    mExistingRectangleList = rectangleList;
    mExistingDrawable = shapeDrawable;
    mActiveAnimator = createAnimator(rectangleList, startingOffset, startingOffset, updateListener, onAnimationEnd);
    mActiveAnimator.start();
}",1,"// TODO nullability checks on parameters
","// TODO nullability checks on parameters
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the removal of the cornerAnimators list and its related usage in the createAnimator() method. This modifies a variable declaration and its related operations (creation of corner animators), which is an 'Other statement changed' since it does not involve return statements, exception handling statements, or control dependency changes.","There is no compatibility issue detected since the removed code related to cornerAnimators does not affect the return type of the method (which remains `void` in both versions), and there are no changes in the exceptions thrown. The potential behavior of the method is assumed to be unaffected from an API compatibility standpoint."
417,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,30,31,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,<android.app.ContextImpl: Context createCredentialProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, flags, mClassLoader, null);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_DEVICE_PROTECTED_STORAGE) | Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method for creating a new ContextImpl has changed in the late version with added mParams and modifications concerning attribution handling (mAttributionTag to mAttributionSource.getAttributionTag(), and mAttributionSource.getNext()). This indicates changes in the dependent APIs being used within this method, so code change type is 5.","Even with changes in the dependent APIs being called, the return type of the method remains the same (Context). There is no indication of a different behavior that might lead to different return values or exceptions being thrown due to these internal changes. Hence, there is no Compatibility Issue in this case."
418,<android.content.res.XmlBlock.Parser: String getClassAttribute()>,30,31,<android.content.res.XmlBlock.Parser: String getClassAttribute()>,<android.content.res.XmlBlock.Parser: String getClassAttribute()>,0,"{
    int id = nativeGetClassAttribute(mParseState);
    return id >= 0 ? mStrings.get(id).toString() : null;
}","{
    int id = nativeGetClassAttribute(mParseState);
    return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : null;
}",1,,,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement includes a call to a different method for getting the class attribute string (getSequenceString(mStrings.getSequence(id)) instead of mStrings.get(id).toString()), and a dependent API is changed (mStrings.get() to mStrings.getSequence()), which means the change types include 1, 4, and 5.","There is a potential compatibility issue because the alteration in the return statement could lead to a different returned value due to the change in how the string is retrieved and constructed. Therefore, the CI type is 1."
419,<android.view.DisplayAddress.Physical: String toString()>,30,31,<android.view.DisplayAddress.Physical: String toString()>,<android.view.DisplayAddress.Physical: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder(""{"").append(""port="").append(Byte.toUnsignedInt(getPort()));
    final Long model = getModel();
    if (model != null) {
        builder.append("", model=0x"").append(Long.toHexString(model));
    }
    return builder.append(""}"").toString();
}","{
    final StringBuilder builder = new StringBuilder(""{"").append(""port="").append(getPort());
    final Long model = getModel();
    if (model != null) {
        builder.append("", model=0x"").append(Long.toHexString(model));
    }
    return builder.append(""}"").toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is replacing Byte.toUnsignedInt(getPort()) with getPort() for appending to the StringBuilder. Since this is just a change in the method call without any alteration to control flow or exception handling, it falls under the category of 4 (Other statement changed).","There is no Compatibility Issue because the toString() method in question is expected to return the state of the object in string format, and the alteration does not affect the value returned by the method in a way that would break compatibility. The getPort() method's output is still being appended to the string; it's just the representation that has slightly changed, which does not affect the method's contract or behavior from an API perspective."
420,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",30,31,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    if (sService == null) {
        return null;
    }
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    if (sService == null) {
        return null;
    }
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setInteractionHandler(mInteractionHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call 'view.setOnClickHandler(mOnClickHandler)' has been replaced with 'view.setInteractionHandler(mInteractionHandler)'. This constitutes a change of an ""Other statement"".","Though the interaction handler has been changed, we have no information that indicates the replacement 'setInteractionHandler(mInteractionHandler)' behaves differently compared to 'setOnClickHandler(mOnClickHandler)'. Therefore, based on the provided information, we cannot confirm any Compatibility Issue."
421,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",30,31,"<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>","<android.app.ContextImpl: ContextImpl createActivityContext(ActivityThread,LoadedApk,ActivityInfo,IBinder,int,Configuration)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, activityInfo.splitName, activityToken, null, 0, classLoader, null);
    context.mIsUiContext = true;
    context.mIsAssociatedWithDisplay = true;
    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseTokenResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader, packageInfo.getApplication() == null ? null : packageInfo.getApplication().getResources().getLoaders()));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    String[] splitDirs = packageInfo.getSplitResDirs();
    ClassLoader classLoader = packageInfo.getClassLoader();
    if (packageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, ""SplitDependencies"");
        try {
            classLoader = packageInfo.getSplitClassLoader(activityInfo.splitName);
            splitDirs = packageInfo.getSplitPaths(activityInfo.splitName);
        } catch (NameNotFoundException e) {
            // Nothing above us can handle a NameNotFoundException, better crash.
            throw new RuntimeException(e);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        }
    }
    final String attributionTag;
    if (activityInfo.attributionTags != null && activityInfo.attributionTags.length > 0) {
        attributionTag = activityInfo.attributionTags[0];
    } else {
        attributionTag = null;
    }
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, ContextParams.EMPTY, attributionTag, null, activityInfo.splitName, activityToken, null, 0, classLoader, null);
    context.mContextType = CONTEXT_TYPE_ACTIVITY;
    context.mIsConfigurationBasedContext = true;
    // Clamp display ID to DEFAULT_DISPLAY if it is INVALID_DISPLAY.
    displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;
    final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY) ? packageInfo.getCompatibilityInfo() : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    final ResourcesManager resourcesManager = ResourcesManager.getInstance();
    // Create the base resources for which all configuration contexts for this Activity
    // will be rebased upon.
    context.setResources(resourcesManager.createBaseTokenResources(activityToken, packageInfo.getResDir(), splitDirs, packageInfo.getOverlayDirs(), packageInfo.getOverlayPaths(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo, classLoader, packageInfo.getApplication() == null ? null : packageInfo.getApplication().getResources().getLoaders()));
    context.mDisplay = resourcesManager.getAdjustedDisplay(displayId, context.getResources());
    return context;
}",1,,,-1,[@UnsupportedAppUsage],"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)]",-1,-1,-1,-1,-1,-1,4,0,"The code change includes the introduction of a new variable (`attributionTag`) and setting two new properties (`mContextType` and `mIsConfigurationBasedContext`) on the `context` object, which are not directly related to return statements or exception handling statements. Additionally, the `ContextImpl` constructor call includes a different number of parameters in the late version (`ContextParams.EMPTY`, and `attributionTag` are added). However, since the return type remains the same and these changes do not directly affect the returned `context` object's behavior from an API consumer standpoint, the change type is 4.","There is no compatibility issue since the changes do not affect the returned object in a way that would lead to different behavior for API consumers. The return type is unchanged, and the additional settings within the method logic are internal implementation details that should not influence the outcome of calling `createActivityContext`."
422,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",30,31,"<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>","<android.view.inputmethod.InputMethodManager: void updateExtractedText(View,int,ExtractedText)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateExtractedText(view, token, text);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.updateExtractedText(token, text);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateExtractedText(view, token, text);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        if (mCurrentInputMethodSession != null) {
            mCurrentInputMethodSession.updateExtractedText(token, text);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,The implementation has several changes:,3. The RemoteException catch block has been removed.
423,<android.hardware.camera2.params.InputConfiguration: boolean equals(Object)>,30,31,<android.hardware.camera2.params.InputConfiguration: boolean equals(Object)>,<android.hardware.camera2.params.InputConfiguration: boolean equals(Object)>,0,"{
    if (!(obj instanceof InputConfiguration)) {
        return false;
    }
    InputConfiguration otherInputConfig = (InputConfiguration) obj;
    if (otherInputConfig.getWidth() == mWidth && otherInputConfig.getHeight() == mHeight && otherInputConfig.getFormat() == mFormat) {
        return true;
    }
    return false;
}","{
    if (!(obj instanceof InputConfiguration)) {
        return false;
    }
    InputConfiguration otherInputConfig = (InputConfiguration) obj;
    if (otherInputConfig.getWidth() == mWidth && otherInputConfig.getHeight() == mHeight && otherInputConfig.getFormat() == mFormat && otherInputConfig.isMultiResolution() == mIsMultiResolution) {
        return true;
    }
    return false;
}",1,"/**
 * Check if this InputConfiguration is equal to another InputConfiguration.
 *
 * <p>Two input configurations are equal if and only if they have the same widths, heights, and
 * formats.</p>
 *
 * @param obj the object to compare this instance with.
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise.
 */
","/**
 * Check if this InputConfiguration is equal to another InputConfiguration.
 *
 * <p>Two input configurations are equal if and only if they have the same widths, heights, and
 * formats.</p>
 *
 * @param obj the object to compare this instance with.
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new condition has been added to the 'if' statement in the method implementation to check 'otherInputConfig.isMultiResolution() == mIsMultiResolution'. This is a control dependency change, so the code change type is 3.","Because of the additional condition in the equality check, the result of the 'equals' method could change, and thus potentially return a different value. Therefore, the CI type is 1."
424,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,30,31,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToInternal(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        case ImageFormat.RAW_DEPTH:
            return HAL_PIXEL_FORMAT_RAW16;
        default:
            return format;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            return HAL_PIXEL_FORMAT_BLOB;
        case ImageFormat.DEPTH16:
            return HAL_PIXEL_FORMAT_Y16;
        case ImageFormat.RAW_DEPTH:
            return HAL_PIXEL_FORMAT_RAW16;
        case ImageFormat.RAW_DEPTH10:
            return HAL_PIXEL_FORMAT_RAW10;
        default:
            return format;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.HEIC => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal format
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH_JPEG => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.HEIC => HAL_PIXEL_FORMAT_BLOB
 * <li>ImageFormat.DEPTH16 => HAL_PIXEL_FORMAT_Y16
 * </ul>
 * </p>
 *
 * <p>Passing in an internal format which has a different public format equivalent will fail.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new case `ImageFormat.RAW_DEPTH10: return HAL_PIXEL_FORMAT_RAW10;` has been added to the `switch` statement without changing the existing cases, so the code change type is 3 for the control dependency change and 4 for the other statement changed.","The addition of a new case in the switch statement leads to a new mapping for the `ImageFormat.RAW_DEPTH10` format, which previously would have hit the `default` case and returned its own value. Now it returns `HAL_PIXEL_FORMAT_RAW10` instead, which means the method would now potentially return a different value for this format. Therefore, the CI type is 1."
425,<android.view.inputmethod.InlineSuggestionsRequest: String toString()>,30,31,<android.view.inputmethod.InlineSuggestionsRequest: String toString()>,<android.view.inputmethod.InlineSuggestionsRequest: String toString()>,0,"{
    return ""InlineSuggestionsRequest { "" + ""maxSuggestionCount = "" + mMaxSuggestionCount + "", "" + ""inlinePresentationSpecs = "" + mInlinePresentationSpecs + "", "" + ""hostPackageName = "" + mHostPackageName + "", "" + ""supportedLocales = "" + mSupportedLocales + "", "" + ""extras = "" + mExtras + "", "" + ""hostInputToken = "" + mHostInputToken + "", "" + ""hostDisplayId = "" + mHostDisplayId + "" }"";
}","{
    return ""InlineSuggestionsRequest { "" + ""maxSuggestionCount = "" + mMaxSuggestionCount + "", "" + ""inlinePresentationSpecs = "" + mInlinePresentationSpecs + "", "" + ""hostPackageName = "" + mHostPackageName + "", "" + ""supportedLocales = "" + mSupportedLocales + "", "" + ""extras = "" + mExtras + "", "" + ""hostInputToken = "" + mHostInputToken + "", "" + ""hostDisplayId = "" + mHostDisplayId + "", "" + ""inlineTooltipPresentationSpec = "" + mInlineTooltipPresentationSpec + "" }"";
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been changed to include an additional concatenated string for ""inlineTooltipPresentationSpec"". Besides that, no other code or annotation changes have been detected. Thus, the code change classification is 1 for the return statement change and 4 for other statement change, which in this case is the addition of new string content in the return statement.","This change in the return statement means that the method will now return a different string value compared to the previous version. Since this additional information changes the output of the method, it can be classified as a Compatibility Issue of type 1, caused by a potential difference in return values."
426,<android.app.LoadedApk.SplitDependencyLoaderImpl: boolean isSplitCached(int)>,30,31,<android.app.LoadedApk.SplitDependencyLoaderImpl: boolean isSplitCached(int)>,<android.app.LoadedApk.SplitDependencyLoaderImpl: boolean isSplitCached(int)>,0,"{
    return mCachedClassLoaders[splitIdx] != null;
}","{
    synchronized (mLock) {
        return mCachedClassLoaders[splitIdx] != null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change made is the addition of a synchronized block around the existing return statement, which is an other statement change, so the code change type is 4.","The additional synchronized block doesn't affect the return value of the method and does not introduce any different exception handling. Therefore, there is no Compatibility Issue, so the CI type is 0."
427,<android.permission.PermissionManager.PackageNamePermissionQuery: String toString()>,30,31,<android.permission.PermissionManager.PackageNamePermissionQuery: String toString()>,<android.permission.PermissionManager.PackageNamePermissionQuery: String toString()>,0,"{
    return String.format(""PackageNamePermissionQuery(pkgName=\""%s\"", permName=\""%s, uid=%s\"")"", pkgName, permName, uid);
}","{
    return String.format(""PackageNamePermissionQuery(pkgName=\""%s\"", permName=\""%s, userId=%s\"")"", pkgName, permName, userId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method's return statement's content has been changed; specifically, the variable name within the string from ""uid"" to ""userId"". This does not change the method's behavior or the type of the returned value, it just changes the content of the string. Hence, the code change type is 4.","There would not be a Compatibility Issue due to this change because the method still returns a string in both versions, and the change in the string content does not affect the way the method behaves or is called by the clients."
428,<android.speech.RecognitionService.Callback: int getCallingUid()>,30,31,<android.speech.RecognitionService.Callback: int getCallingUid()>,<android.speech.RecognitionService.Callback: int getCallingUid()>,0,"{
    return mCallingUid;
}","{
    return mCallingAttributionSource.getUid();
}",1,"/**
 * Return the Linux uid assigned to the process that sent you the current transaction that
 * is being processed. This is obtained from {@link Binder#getCallingUid()}.
 */
","/**
 * Return the Linux uid assigned to the process that sent you the current transaction that
 * is being processed. This is obtained from {@link Binder#getCallingUid()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation has changed from returning `mCallingUid` directly to returning the UID from `mCallingAttributionSource.getUid()`. This indicates a change in how the UID is retrieved, so the code change type is 4 (an alteration in the returned expression) and 5 (it relies on a different field/method for the result).","The retrieval of the UID in the late version APIs uses a different method (`mCallingAttributionSource.getUid` instead of directly accessing `mCallingUid`), which constitutes a CI type 1 since the API may return a different value depending on the implementation of `getUid()`."
429,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,30,31,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and they are moving their finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    if (super.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from their original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished() || !mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished();
                // Catch the edge effect if it is active.
                if (!mEdgeGlowLeft.isFinished()) {
                    mEdgeGlowLeft.onPullDistance(0f, 1f - ev.getY() / getHeight());
                }
                if (!mEdgeGlowRight.isFinished()) {
                    mEdgeGlowRight.onPullDistance(0f, ev.getY() / getHeight());
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
430,<android.view.ViewDebug.StreamingPictureCallbackHandler: void onPictureCaptured(Picture)>,30,31,<android.view.ViewDebug.StreamingPictureCallbackHandler: void onPictureCaptured(Picture)>,<android.view.ViewDebug.StreamingPictureCallbackHandler: void onPictureCaptured(Picture)>,0,"{
    mLock.lock();
    if (mStopListening) {
        mLock.unlock();
        mRenderer.setPictureCaptureCallback(null);
        return;
    }
    if (mRenderThread == null) {
        mRenderThread = Thread.currentThread();
    }
    boolean needsInvoke = true;
    if (mQueue.size() == 3) {
        mQueue.removeLast();
        needsInvoke = false;
    }
    picture.writeToStream(mByteStream);
    mQueue.add(mByteStream.toByteArray());
    mByteStream.reset();
    mLock.unlock();
    if (needsInvoke) {
        mExecutor.execute(this);
    }
}","{
    mLock.lock();
    if (mStopListening) {
        mLock.unlock();
        mRenderer.setPictureCaptureCallback(null);
        return;
    }
    if (mRenderThread == null) {
        mRenderThread = Thread.currentThread();
    }
    boolean needsInvoke = true;
    if (mQueue.size() == 3) {
        mQueue.removeLast();
        needsInvoke = false;
    }
    mQueue.add(picture);
    mLock.unlock();
    if (needsInvoke) {
        mExecutor.execute(this);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's a change in the method of adding an object to the queue; instead of writing the `Picture` to a stream and then adding the byte array to the queue, the late version directly adds the `Picture` object to the queue. Thus, the method used to add the object has changed and the change type is 4.","There is no compatibility issue detected because both the early and late version of the method logically perform the same functionâ€”they enqueue a representation of the `Picture` for processing by the renderer. Even though the type of object enqueued has changed from a byte array to the `Picture` itself, this change does not inherently lead to different behavior from the perspective of the API's contract as it is an internal detail of how the `Picture` is queued. The API's input and output behavior remains consistent; thus, no different return values or exception handlings are expected."
432,<android.content.ContentProvider: CallingIdentity clearCallingIdentity()>,30,31,<android.content.ContentProvider: CallingIdentity clearCallingIdentity()>,<android.content.ContentProvider: CallingIdentity clearCallingIdentity()>,0,"{
    return new CallingIdentity(Binder.clearCallingIdentity(), setCallingPackage(null));
}","{
    return new CallingIdentity(Binder.clearCallingIdentity(), setCallingAttributionSource(null));
}",1,"/**
 * Reset the identity of the incoming IPC on the current thread.
 * <p>
 * Internally this calls {@link Binder#clearCallingIdentity()} and also
 * clears any value stored in {@link #getCallingPackage()}.
 *
 * @return Returns an opaque token that can be used to restore the original
 * calling identity by passing it to
 * {@link #restoreCallingIdentity}.
 */
","/**
 * Reset the identity of the incoming IPC on the current thread.
 * <p>
 * Internally this calls {@link Binder#clearCallingIdentity()} and also
 * clears any value stored in {@link #getCallingPackage()}.
 *
 * @return Returns an opaque token that can be used to restore the original
 * calling identity by passing it to
 * {@link #restoreCallingIdentity}.
 */
",-1,[@NonNull],"[@SuppressWarnings(""AndroidFrameworkBinderIdentity""), @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The constructor of CallingIdentity is called with a different method as the second parameter: from setCallingPackage(null) to setCallingAttributionSource(null). This indicates that a dependent API has changed, hence code change type 5.","The change in the dependent API does not inherently cause a compatibility issue regarding return values or exception handling because the constructor of CallingIdentity is expected to handle any CallingPackage or CallingAttributionSource equivalently. As long as the CallingIdentity object is created correctly with the new attribution source instead of the package, the API contract remains fulfilled. Therefore, there is no compatibility issue, CI type 0."
433,<android.app.PendingIntent: void cancel()>,30,31,<android.app.PendingIntent: void cancel()>,<android.app.PendingIntent: void cancel()>,0,"{
    try {
        ActivityManager.getService().cancelIntentSender(mTarget);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManager.getService().cancelIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Cancel a currently active PendingIntent.  Only the original application
 * owning a PendingIntent can cancel it.
 */
","/**
 * Cancel a currently active PendingIntent.  Only the original application
 * owning a PendingIntent can cancel it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception handling statement has changed from catching the RemoteException and doing nothing to throwing the excepetion again using e.rethrowFromSystemServer(), hence the code change type is 2.","The change in exception handling will lead to a different behavior when an RemoteException occurs. In the early version, the exception is swallowed, while in the late version, it is thrown again, potentially affecting the caller. Therefore, the Compatibility Issue type is 2."
434,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,30,31,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterY()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterY(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center Y"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterY(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center Y"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}",1,"/**
 * Returns the unscaled screen-relative Y coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative Y coordinate of the center of
 * the magnified region
 */
","/**
 * Returns the unscaled screen-relative Y coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative Y coordinate of the center of
 * the magnified region
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The parameter passed to getInstance() changed from `mService.mConnectionId` to `mService`. Since the API used to get the `connection` object has a different parameter, the dependent API has changed. Thus, the code change type is 5.","Since the method implementation uses the same logic and catch blocks for exceptions, and the return paths remain the same as well, there is no change resulting in a different value being returned or exception being thrown. There is also no modification in exception handling statements. Therefore, no Compatibility Issue is detected, and the CI type is 0."
435,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",30,31,"<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>","<android.widget.RemoteViewsAdapter.RemoteViewsFrameLayoutRefSet: void notifyOnRemoteViewsLoaded(int,RemoteViews)>",0,"{
    if (view == null)
        return;
    // Remove this set from the original mapping
    final LinkedList<RemoteViewsFrameLayout> refs = removeReturnOld(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsOnClickHandler, true);
        }
    }
}","{
    if (view == null)
        return;
    // Remove this set from the original mapping
    final LinkedList<RemoteViewsFrameLayout> refs = removeReturnOld(position);
    if (refs != null) {
        // Notify all the references for that position of the newly loaded RemoteViews
        for (final RemoteViewsFrameLayout ref : refs) {
            ref.onRemoteViewsLoaded(view, mRemoteViewsInteractionHandler, true);
        }
    }
}",1,"/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
","/**
 * Notifies each of the RemoteViewsFrameLayouts associated with a particular position that
 * the associated RemoteViews has loaded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only change is in the parameter passed to the method onRemoteViewsLoaded from mRemoteViewsOnClickHandler to mRemoteViewsInteractionHandler, suggesting that the dependent API has changed. There are no other statement or control dependency changes, so the code change type is 4,5.","There is no Compatibility Issue because the change is within the method's internal implementation details, and there are no changes in the types or values returned or exceptions thrown, so the CI type is 0."
436,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",30,31,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>","<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",0,"{
    try {
        return ContentResolver.loadThumbnail(content, documentUri, Point.convert(size), signal, ImageDecoder.ALLOCATOR_SOFTWARE);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        rethrowIfNecessary(e);
        return null;
    }
}","{
    try {
        return ContentResolver.loadThumbnail(content, documentUri, new Size(size.x, size.y), signal, ImageDecoder.ALLOCATOR_SOFTWARE);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        rethrowIfNecessary(e);
        return null;
    }
}",1,"/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
","/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter passed to the `ContentResolver.loadThumbnail` method has changed from `Point.convert(size)` to `new Size(size.x, size.y)`. Since this is an alteration in the parameters of a called method (dependent API), the change type is 4,5.","Despite the change of the parameter passed to the method, the early and late versions of the API both handle the exception in the same way and return null in case of an exception. Therefore, the behavior of the API in terms of return values and exception handling is preserved. There is no Compatibility Issue, so the CI type is 0."
438,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,30,31,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    final IAccessibilityManager service;
    final int userId;
    final AccessibilityEvent dispatchedEvent;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        event.setEventTime(SystemClock.uptimeMillis());
        if (mAccessibilityPolicy != null) {
            dispatchedEvent = mAccessibilityPolicy.onAccessibilityEvent(event, mIsEnabled, mRelevantEventTypes);
            if (dispatchedEvent == null) {
                return;
            }
        } else {
            dispatchedEvent = event;
        }
        if (!isEnabled()) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        if ((dispatchedEvent.getEventType() & mRelevantEventTypes) == 0) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Not dispatching irrelevant event: "" + dispatchedEvent + "" that is not among "" + AccessibilityEvent.eventTypeToString(mRelevantEventTypes));
            }
            return;
        }
        userId = mUserId;
    }
    try {
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        try {
            service.sendAccessibilityEvent(dispatchedEvent, userId);
        } finally {
            Binder.restoreCallingIdentity(identityToken);
        }
        if (DEBUG) {
            Log.i(LOG_TAG, dispatchedEvent + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + dispatchedEvent + "" "", re);
    } finally {
        if (event != dispatchedEvent) {
            event.recycle();
        }
        dispatchedEvent.recycle();
    }
}","{
    final IAccessibilityManager service;
    final int userId;
    final AccessibilityEvent dispatchedEvent;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        event.setEventTime(SystemClock.uptimeMillis());
        if (event.getAction() == 0) {
            event.setAction(mPerformingAction);
        }
        if (mAccessibilityPolicy != null) {
            dispatchedEvent = mAccessibilityPolicy.onAccessibilityEvent(event, mIsEnabled, mRelevantEventTypes);
            if (dispatchedEvent == null) {
                return;
            }
        } else {
            dispatchedEvent = event;
        }
        if (!isEnabled()) {
            Looper myLooper = Looper.myLooper();
            if (myLooper == Looper.getMainLooper()) {
                throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
            } else {
                // If we're not running on the thread with the main looper, it's possible for
                // the state of accessibility to change between checking isEnabled and
                // calling this method. So just log the error rather than throwing the
                // exception.
                Log.e(LOG_TAG, ""AccessibilityEvent sent with accessibility disabled"");
                return;
            }
        }
        if ((dispatchedEvent.getEventType() & mRelevantEventTypes) == 0) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Not dispatching irrelevant event: "" + dispatchedEvent + "" that is not among "" + AccessibilityEvent.eventTypeToString(mRelevantEventTypes));
            }
            return;
        }
        userId = mUserId;
    }
    try {
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        final long identityToken = Binder.clearCallingIdentity();
        try {
            service.sendAccessibilityEvent(dispatchedEvent, userId);
        } finally {
            Binder.restoreCallingIdentity(identityToken);
        }
        if (DEBUG) {
            Log.i(LOG_TAG, dispatchedEvent + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + dispatchedEvent + "" "", re);
    } finally {
        if (event != dispatchedEvent) {
            event.recycle();
        }
        dispatchedEvent.recycle();
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The only change in the code is the addition of two lines:,    event.setAction(mPerformingAction);
439,"<android.view.accessibility.AccessibilityNodeInfo: boolean refreshWithExtraData(String,Bundle)>",30,31,"<android.view.accessibility.AccessibilityNodeInfo: boolean refreshWithExtraData(String,Bundle)>","<android.view.accessibility.AccessibilityNodeInfo: boolean refreshWithExtraData(String,Bundle)>",0,"{
    args.putString(EXTRA_DATA_REQUESTED_KEY, extraDataKey);
    return refresh(args, true);
}","{
    // the binder transaction failure and OOM crash.
    if (args.getInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH, -1) > EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_MAX_LENGTH) {
        args.putInt(EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_LENGTH, EXTRA_DATA_TEXT_CHARACTER_LOCATION_ARG_MAX_LENGTH);
    }
    args.putString(EXTRA_DATA_REQUESTED_KEY, extraDataKey);
    return refresh(args, true);
}",1,"/**
 * Refreshes this info with the latest state of the view it represents, and request new
 * data be added by the View.
 *
 * @param extraDataKey The extra data requested. Data that must be requested
 * with this mechanism is generally expensive to retrieve, so should only be
 * requested when needed. See
 * {@link #EXTRA_DATA_RENDERING_INFO_KEY},
 * {@link #EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY},
 * {@link #getAvailableExtraData()} and {@link #getExtraRenderingInfo()}.
 * @param args A bundle of arguments for the request. These depend on the particular request.
 *
 * @return {@code true} if the refresh succeeded. {@code false} if the {@link View} represented
 * by this node is no longer in the view tree (and thus this node is obsolete and should be
 * recycled).
 */
","/**
 * Refreshes this info with the latest state of the view it represents, and request new
 * data be added by the View.
 *
 * @param extraDataKey The extra data requested. Data that must be requested
 * with this mechanism is generally expensive to retrieve, so should only be
 * requested when needed. See
 * {@link #EXTRA_DATA_RENDERING_INFO_KEY},
 * {@link #EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY},
 * {@link #getAvailableExtraData()} and {@link #getExtraRenderingInfo()}.
 * @param args A bundle of arguments for the request. These depend on the particular request.
 *
 * @return {@code true} if the refresh succeeded. {@code false} if the {@link View} represented
 * by this node is no longer in the view tree (and thus this node is obsolete and should be
 * recycled).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version API does not include the extra condition that limits the argument length, while the late version introduces a check for the length of data in the 'args' Bundle and potentially modifies it. This adds both a new conditional statement (type 3) and other statements to check and update the 'args' data (type 4).","There is no Compatibility Issue because the new code does not impact the final result returned by the method. It only modifies one of the input parameters before passing it to the 'refresh' method, which does not affect the behavior observed by the method callers in case of valid 'args'. The contract of the API remains intact for all the valid inputs, which is why the API behavior does not change for them. Compatibility Issues would only arise if the change would affect the outputs or exceptions observable by the API users, which is not the case here."
440,"<android.app.ContextImpl: boolean bindService(Intent,int,Executor,ServiceConnection)>",30,31,"<android.app.ContextImpl: boolean bindService(Intent,int,Executor,ServiceConnection)>","<android.app.ContextImpl: boolean bindService(Intent,int,Executor,ServiceConnection)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, null, null, executor, getUser());
}","{
    return bindServiceCommon(service, conn, flags, null, null, executor, getUser());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method call to warnIfCallingFromSystemProcess() is removed in the late implementation. This is considered an Other statement change (code change type 4), as it does not fit the categories of return statement, exception handling, control dependency, or dependent API changes.","Since the removed method is a warning log and does not affect the behavior of the API in terms of its return type, return value, or exception handling, it does not pose a Compatibility Issue (CI is 0)."
441,<android.app.SyncNotedAppOp: int hashCode()>,30,31,<android.app.SyncNotedAppOp: int hashCode()>,<android.app.SyncNotedAppOp: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + mOpCode;
    _hash = 31 * _hash + java.util.Objects.hashCode(mAttributionTag);
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + mOpMode;
    _hash = 31 * _hash + mOpCode;
    _hash = 31 * _hash + java.util.Objects.hashCode(mAttributionTag);
    _hash = 31 * _hash + java.util.Objects.hashCode(mPackageName);
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode calculation has been changed by adding new fields into the computation (`mOpMode` and `mPackageName`), which are not present in the early version, thus the change types are 1 and 4.","The addition of new fields in the hashCode method computation (`mOpMode` and `mPackageName`) will result in a different hash value being returned, which is a Compatibility Issue of type 1 caused by potential different return values."
442,<android.content.pm.PackageInstaller.Session: void transfer(String)>,30,31,<android.content.pm.PackageInstaller.Session: void transfer(String)>,<android.content.pm.PackageInstaller.Session: void transfer(String)>,0,"{
    Objects.requireNonNull(packageName);
    try {
        mSession.transfer(packageName);
    } catch (ParcelableException e) {
        e.maybeRethrow(PackageManager.NameNotFoundException.class);
        throw new RuntimeException(e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    Preconditions.checkArgument(!TextUtils.isEmpty(packageName));
    try {
        mSession.transfer(packageName);
    } catch (ParcelableException e) {
        e.maybeRethrow(PackageManager.NameNotFoundException.class);
        throw new RuntimeException(e);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Transfer the session to a new owner.
 * <p>
 * Only sessions that update the installing app can be transferred.
 * <p>
 * After the transfer to a package with a different uid all method calls on the session
 * will cause {@link SecurityException}s.
 * <p>
 * Once this method is called, the session is sealed and no additional mutations beside
 * committing it may be performed on the session.
 *
 * @param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
 * permission.
 *
 * @throws PackageManager.NameNotFoundException if the new owner could not be found.
 * @throws SecurityException if called after the session has been committed or abandoned.
 * @throws SecurityException if the session does not update the original installer
 * @throws SecurityException if streams opened through
 * {@link #openWrite(String, long, long) are still open.
 */
","/**
 * Transfer the session to a new owner.
 * <p>
 * Only sessions that update the installing app can be transferred.
 * <p>
 * After the transfer to a package with a different uid all method calls on the session
 * will cause {@link SecurityException}s.
 * <p>
 * Once this method is called, the session is sealed and no additional mutations beside
 * committing it may be performed on the session.
 *
 * @param packageName The package of the new owner. Needs to hold the INSTALL_PACKAGES
 * permission.
 *
 * @throws PackageManager.NameNotFoundException if the new owner could not be found.
 * @throws SecurityException if called after the session has been committed or abandoned.
 * @throws IllegalStateException if streams opened through
 * {@link #openWrite(String, long, long) are still open.
 * @throws IllegalArgumentException if {@code packageName} is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The check at the beginning of the method has changed from Objects.requireNonNull(packageName) to Preconditions.checkArgument(!TextUtils.isEmpty(packageName)), which is a check for both null and empty values. Thus, the change type is an 'Other statement changed'.","Although the initial input validation has been strengthened to reject empty strings in addition to null, it should not result in a Compatibility Issue for valid inputs (non-null and non-empty strings). If a null or empty string was passed to the early version, it would have thrown a NullPointerException; if the same input is passed to the late version, it will throw an IllegalArgumentException. However, neither of these changes affect the API's behavior for valid inputs, so there are 'No Compatibility Issues' caused by this change."
444,<android.view.WindowInsets: String toString()>,30,31,<android.view.WindowInsets: String toString()>,<android.view.WindowInsets: String toString()>,0,"{
    StringBuilder result = new StringBuilder(""WindowInsets{\n    "");
    for (int i = 0; i < SIZE; i++) {
        Insets insets = mTypeInsetsMap[i];
        Insets maxInsets = mTypeMaxInsetsMap[i];
        boolean visible = mTypeVisibilityMap[i];
        if (!Insets.NONE.equals(insets) || !Insets.NONE.equals(maxInsets) || visible) {
            result.append(Type.toString(1 << i)).append(""="").append(insets).append("" max="").append(maxInsets).append("" vis="").append(visible).append(""\n    "");
        }
    }
    result.append(mDisplayCutout != null ? ""cutout="" + mDisplayCutout : """");
    result.append(""\n    "");
    result.append(isRound() ? ""round"" : """");
    result.append(""}"");
    return result.toString();
}","{
    StringBuilder result = new StringBuilder(""WindowInsets{\n    "");
    for (int i = 0; i < SIZE; i++) {
        Insets insets = mTypeInsetsMap[i];
        Insets maxInsets = mTypeMaxInsetsMap[i];
        boolean visible = mTypeVisibilityMap[i];
        if (!Insets.NONE.equals(insets) || !Insets.NONE.equals(maxInsets) || visible) {
            result.append(Type.toString(1 << i)).append(""="").append(insets).append("" max="").append(maxInsets).append("" vis="").append(visible).append(""\n    "");
        }
    }
    result.append(mDisplayCutout != null ? ""cutout="" + mDisplayCutout : """");
    result.append(""\n    "");
    result.append(mRoundedCorners != null ? ""roundedCorners="" + mRoundedCorners : """");
    result.append(""\n    "");
    result.append(mPrivacyIndicatorBounds != null ? ""privacyIndicatorBounds="" + mPrivacyIndicatorBounds : """");
    result.append(""\n    "");
    result.append(isRound() ? ""round"" : """");
    result.append(""}"");
    return result.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The addition of string building for `mRoundedCorners` and `mPrivacyIndicatorBounds` in the `toString()` method results in the addition of new strings to the StringBuilder. These new parts being appended represent additional information in the string returned from the method, and this constitutes an ""Other statement changed"" type since it is not a return type change, exception change, or control dependency change.","There is no Compatibility Issue detected as the `toString()` method is solely for creating a representative string of the object's state, and adding new information to this string doesn't affect how existing applications would operate. This is typically used for debugging or logging, so returning additional information won't break backward compatibility."
445,<android.os.PersistableBundle: void writeToStream(OutputStream)>,30,31,<android.os.PersistableBundle: void writeToStream(OutputStream)>,<android.os.PersistableBundle: void writeToStream(OutputStream)>,0,"{
    FastXmlSerializer serializer = new FastXmlSerializer();
    serializer.setOutput(outputStream, UTF_8.name());
    serializer.startTag(null, ""bundle"");
    try {
        saveToXml(serializer);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
    serializer.endTag(null, ""bundle"");
    serializer.flush();
}","{
    TypedXmlSerializer serializer = Xml.newFastSerializer();
    serializer.setOutput(outputStream, UTF_8.name());
    serializer.startTag(null, ""bundle"");
    try {
        saveToXml(serializer);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
    serializer.endTag(null, ""bundle"");
    serializer.flush();
}",1,"/**
 * Writes the content of the {@link PersistableBundle} to a {@link OutputStream}.
 *
 * <p>The content can be read by a {@link #readFromStream}.
 *
 * @see #readFromStream
 */
","/**
 * Writes the content of the {@link PersistableBundle} to a {@link OutputStream}.
 *
 * <p>The content can be read by a {@link #readFromStream}.
 *
 * @see #readFromStream
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation change involves using a different class TypedXmlSerializer instead of FastXmlSerializer, and the method call Xml.newFastSerializer() instead of new FastXmlSerializer(). This indicates a dependent API change, so the code change type is 4,5.","There is no change to the control flow or the structure of exceptions and return statements that would affect the external behavior of the method. Thus, while there is a change within the implementation details (constructor and method call for the serializer), this does not directly cause a compatibility issue in terms of the method's signature, return type, thrown exceptions, or the actual serialized data. Therefore, the CI type is 0."
446,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,30,31,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,<android.widget.Editor.HandleView: void updateMagnifier(MotionEvent)>,0,"{
    if (getMagnifierAnimator() == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = checkForTransforms() && /*check not rotated and compute scale*/
    !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        if (mNewMagnifierEnabled) {
            // Calculates the line bounds as the content source bounds to the magnifier.
            Layout layout = mTextView.getLayout();
            int line = layout.getLineForOffset(getCurrentCursorOffset());
            int lineLeft = (int) layout.getLineLeft(line);
            lineLeft += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            int lineRight = (int) layout.getLineRight(line);
            lineRight += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            mMagnifierAnimator.mMagnifier.setSourceHorizontalBounds(lineLeft, lineRight);
            final int lineHeight = layout.getLineBottomWithoutSpacing(line) - layout.getLineTop(line);
            float zoom = mInitialZoom;
            if (lineHeight < mMinLineHeightForMagnifier) {
                zoom = zoom * mMinLineHeightForMagnifier / lineHeight;
            }
            mMagnifierAnimator.mMagnifier.updateSourceFactors(lineHeight, zoom);
            mMagnifierAnimator.mMagnifier.show(showPosInView.x, showPosInView.y);
        } else {
            mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
        }
        updateHandlesVisibility();
    } else {
        dismissMagnifier();
    }
}","{
    if (getMagnifierAnimator() == null) {
        return;
    }
    final PointF showPosInView = new PointF();
    final boolean shouldShow = checkForTransforms() && /*check not rotated and compute scale*/
    !tooLargeTextForMagnifier() && obtainMagnifierShowCoordinates(event, showPosInView);
    if (shouldShow) {
        // Make the cursor visible and stop blinking.
        mRenderCursorRegardlessTiming = true;
        mTextView.invalidateCursorPath();
        suspendBlink();
        if (mNewMagnifierEnabled) {
            // Calculates the line bounds as the content source bounds to the magnifier.
            Layout layout = mTextView.getLayout();
            int line = layout.getLineForOffset(getCurrentCursorOffset());
            int lineLeft = (int) layout.getLineLeft(line);
            lineLeft += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            int lineRight = (int) layout.getLineRight(line);
            lineRight += mTextView.getTotalPaddingLeft() - mTextView.getScrollX();
            mDrawCursorOnMagnifier = showPosInView.x < lineLeft - CURSOR_START_FLOAT_DISTANCE_PX || showPosInView.x > lineRight + CURSOR_START_FLOAT_DISTANCE_PX;
            mMagnifierAnimator.mMagnifier.setDrawCursor(mDrawCursorOnMagnifier, mDrawableForCursor);
            boolean cursorVisible = mCursorVisible;
            // Updates cursor visibility, so that the real cursor and the float cursor on
            // magnifier surface won't appear at the same time.
            mCursorVisible = !mDrawCursorOnMagnifier;
            if (mCursorVisible && !cursorVisible) {
                // When the real cursor is a drawable, hiding/showing it would change its
                // bounds. So, call updateCursorPosition() to correct its position.
                updateCursorPosition();
            }
            final int lineHeight = layout.getLineBottomWithoutSpacing(line) - layout.getLineTop(line);
            float zoom = mInitialZoom;
            if (lineHeight < mMinLineHeightForMagnifier) {
                zoom = zoom * mMinLineHeightForMagnifier / lineHeight;
            }
            mMagnifierAnimator.mMagnifier.updateSourceFactors(lineHeight, zoom);
            mMagnifierAnimator.mMagnifier.show(showPosInView.x, showPosInView.y);
        } else {
            mMagnifierAnimator.show(showPosInView.x, showPosInView.y);
        }
        updateHandlesVisibility();
    } else {
        dismissMagnifier();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes within the control structure ""if (shouldShow)"" where additional logic has been added (like setting mDrawCursorOnMagnifier, mMagnifierAnimator.mMagnifier.setDrawCursor, and the block handling cursor visibility). This is a control dependency change because new variables and logic are introduced inside a control structure (3). Additionally, new variable assignments and method calls like setDrawCursor and updateCursorPosition indicate other statement changes (4).","Although new functionality has been added and there is a complexity increase within the control structure, there's no indication that these changes would lead to different return values or throw different exceptions since the overall flow and the return behavior of the method have not been altered. The method does not have a return type that could be influenced by these changes, nor does it throw exceptions that would be influenced. Thus, no Compatibility Issue detected."
447,<android.content.res.ResourcesImpl.ThemeImpl: String[] getTheme()>,30,31,<android.content.res.ResourcesImpl.ThemeImpl: String[] getTheme()>,<android.content.res.ResourcesImpl.ThemeImpl: String[] getTheme()>,0,"{
    synchronized (mKey) {
        final int N = mKey.mCount;
        final String[] themes = new String[N * 2];
        for (int i = 0, j = N - 1; i < themes.length; i += 2, --j) {
            final int resId = mKey.mResId[j];
            final boolean forced = mKey.mForce[j];
            try {
                themes[i] = getResourceName(resId);
            } catch (NotFoundException e) {
                themes[i] = Integer.toHexString(i);
            }
            themes[i + 1] = forced ? ""forced"" : ""not forced"";
        }
        return themes;
    }
}","{
    final int n = mKey.mCount;
    final String[] themes = new String[n * 2];
    for (int i = 0, j = n - 1; i < themes.length; i += 2, --j) {
        final int resId = mKey.mResId[j];
        final boolean forced = mKey.mForce[j];
        try {
            themes[i] = getResourceName(resId);
        } catch (NotFoundException e) {
            themes[i] = Integer.toHexString(i);
        }
        themes[i + 1] = forced ? ""forced"" : ""not forced"";
    }
    return themes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the early and late version except for renaming a local variable from `N` to `n`, which does not affect the behavior of the method.",No Compatibility Issue detected because the method's behavior remains the same. The renaming of a local variable does not introduce any changes in the method's functionality or output.
448,"<android.app.Activity: void performStop(boolean,String)>",30,31,"<android.app.Activity: void performStop(boolean,String)>","<android.app.Activity: void performStop(boolean,String)>",0,"{
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        dispatchActivityPreStopped();
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
        dispatchActivityPostStopped();
    }
    mResumed = false;
}","{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_WINDOW_MANAGER)) {
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, ""performStop:"" + mComponent.getClassName());
    }
    mDoReportFullyDrawn = false;
    mFragments.doLoaderStop(mChangingConfigurations);
    // Disallow entering picture-in-picture after the activity has been stopped
    mCanEnterPictureInPicture = false;
    if (!mStopped) {
        dispatchActivityPreStopped();
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        // destroys hardware resources and causes flicker.
        if (!preserveWindow && mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
        dispatchActivityPostStopped();
    }
    mResumed = false;
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The tracing statements using Trace.traceBegin and Trace.traceEnd have been added, which are not affecting the logic of the method. Therefore, the change type is 4.","The added tracing statements will not change the behavior of the method concerning its return or the exceptions that it might throw. Hence, there is no Compatibility Issue."
449,<android.bluetooth.BluetoothSocket: int bindListen()>,30,31,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        if (DBG)
            Log.d(TAG, ""bindListen(): mPort="" + mPort + "", mType="" + mType);
        mPfd = bluetoothProxy.getSocketManager().createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG) {
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            }
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, ""bindListen(), null file descriptor"");
                return -1;
            }
            if (DBG)
                Log.d(TAG, ""bindListen(), Create LocalSocket"");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream()"");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT) {
                mSocketState = SocketState.LISTENING;
            }
        }
        if (DBG)
            Log.d(TAG, ""bindListen(): channel="" + channel + "", mPort="" + mPort);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService();
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        if (DBG)
            Log.d(TAG, ""bindListen(): mPort="" + mPort + "", mType="" + mType);
        mPfd = bluetoothProxy.getSocketManager().createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG) {
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            }
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, ""bindListen(), null file descriptor"");
                return -1;
            }
            if (DBG)
                Log.d(TAG, ""bindListen(), Create LocalSocket"");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream()"");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT) {
                mSocketState = SocketState.LISTENING;
            }
        }
        if (DBG)
            Log.d(TAG, ""bindListen(): channel="" + channel + "", mPort="" + mPort);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, ""bindListen, close mPfd: "" + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/**
 * Currently returns unix errno instead of throwing IOException,
 * so that BluetoothAdapter can check the error code for EADDRINUSE
 */
",-1,,[@RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)],-1,-1,-1,-1,-1,-1,,,,
450,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,30,31,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,<android.content.IntentSender: UserHandle getCreatorUserHandle()>,0,"{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    int uid = getCachedInfo().getCreatorUid();
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
}",1,"/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5",0,"The implementation has removed the try-catch block handling a RemoteException and replaced ActivityManager.getService().getUidForIntentSender(mTarget) with getCachedInfo().getCreatorUid(), which no longer throws a checked exception. These changes lead to a difference in exception handling, as well as a change in a method call not present in the try block. Thus, the code changes are of type 2 (exception handling statement changed), 4 (other statement changed), and 5 (dependent API changed).","However, since the old try-catch block was catching a RemoteException and returning null (which is a reasonable default behavior when dealing with remote services in Android), and the replaced method call does not declare that it throws any checked exceptions, the code's behavior regarding exceptions remains consistent with its original design. Furthermore, the returned value depends on whether the uid is greater than 0, a condition that has not changed. Therefore, it is unlikely to cause a different behavior in terms of the returned UserHandle object. There is no Compatibility Issue."
451,<android.app.ContextImpl: Context createDisplayContext(Display)>,30,31,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), mResources.getLoaders()));
    context.mDisplay = display;
    context.mIsAssociatedWithDisplay = true;
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    // Ensure the resources display metrics are adjusted to match the provided display.
    Configuration overrideConfig = new Configuration();
    overrideConfig.setTo(display.getDisplayAdjustments().getConfiguration(), ActivityInfo.CONFIG_WINDOW_CONFIGURATION, 1);
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, overrideConfig, display.getDisplayAdjustments().getCompatibilityInfo(), mResources.getLoaders()));
    context.mDisplay = display;
    context.mContextType = CONTEXT_TYPE_DISPLAY_CONTEXT;
    // Display contexts and any context derived from a display context should always override
    // the display that would otherwise be inherited from mToken (or the global configuration if
    // mToken is null).
    context.mForceDisplayOverrideInResources = true;
    // The configuration is overridden by display adjustments' configuration and won't receive
    // configuration changes. This context won't be regarded as having the proper configuration
    // anymore.
    context.mIsConfigurationBasedContext = false;
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The control dependency change exists in the way `Configuration overrideConfig` is being instantiated and used. Other statement changed include the instantiation of `ContextImpl` with different arguments (`mParams` and `mAttributionSource` related changes), setting `mContextType`, `mForceDisplayOverrideInResources`, and `mIsConfigurationBasedContext` which are new in the late version. The dependent API `createResources` now receives a `Configuration` parameter which was not present in the early version. Hence, the changes are 3, 4, 5.","Despite these extensive changes, the return type remains `ContextImpl`, and the method still throws the same `IllegalArgumentException` if `display` is null. The changes affect internal state and configuration of the `ContextImpl` object, but they don't alter the API's outward behavior regarding returned value types or thrown exceptions. That is, from the perspective of an API user calling `createDisplayContext()`, these changes do not manifest as different return types or exceptions, thus there's no compatibility issue in those aspects, and the pred_CI is 0."
452,<android.content.res.Configuration: int compareTo(Configuration)>,30,31,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    if (n != 0)
        return n;
    n = windowConfiguration.compareTo(that.windowConfiguration);
    if (n != 0)
        return n;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    fixUpLocaleList();
    that.fixUpLocaleList();
    // than any non-empty locale list.
    if (this.mLocaleList.isEmpty()) {
        if (!that.mLocaleList.isEmpty())
            return 1;
    } else if (that.mLocaleList.isEmpty()) {
        return -1;
    } else {
        final int minSize = Math.min(this.mLocaleList.size(), that.mLocaleList.size());
        for (int i = 0; i < minSize; ++i) {
            final Locale thisLocale = this.mLocaleList.get(i);
            final Locale thatLocale = that.mLocaleList.get(i);
            n = thisLocale.getLanguage().compareTo(thatLocale.getLanguage());
            if (n != 0)
                return n;
            n = thisLocale.getCountry().compareTo(thatLocale.getCountry());
            if (n != 0)
                return n;
            n = thisLocale.getVariant().compareTo(thatLocale.getVariant());
            if (n != 0)
                return n;
            n = thisLocale.toLanguageTag().compareTo(thatLocale.toLanguageTag());
            if (n != 0)
                return n;
        }
        n = this.mLocaleList.size() - that.mLocaleList.size();
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.colorMode - that.colorMode;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    if (n != 0)
        return n;
    n = this.assetsSeq - that.assetsSeq;
    if (n != 0)
        return n;
    n = windowConfiguration.compareTo(that.windowConfiguration);
    if (n != 0)
        return n;
    n = this.fontWeightAdjustment - that.fontWeightAdjustment;
    if (n != 0)
        return n;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
453,<android.os.Debug: void stopNativeTracing()>,30,31,<android.os.Debug: void stopNativeTracing()>,<android.os.Debug: void stopNativeTracing()>,0,"{
    VMDebug.stopEmulatorTracing();
    // Open the sysfs file for writing and write ""0"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""0"");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}","{
    // Open the sysfs file for writing and write ""0"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""0"");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}",1,"/**
 * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.
 *
 * <p>Tracing can be started and stopped as many times as desired.  When
 * the qemu emulator itself is stopped then the buffered trace records
 * are flushed and written to the trace file.  In fact, it is not necessary
 * to call this method at all; simply killing qemu is sufficient.  But
 * starting and stopping a trace is useful for examining a specific
 * region of code.</p>
 */
","/**
 * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.
 *
 * <p>Tracing can be started and stopped as many times as desired.  When
 * the qemu emulator itself is stopped then the buffered trace records
 * are flushed and written to the trace file.  In fact, it is not necessary
 * to call this method at all; simply killing qemu is sufficient.  But
 * starting and stopping a trace is useful for examining a specific
 * region of code.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method VMDebug.stopEmulatorTracing(); was removed from the implementation, which is an other statement change, therefore the change type is 4.","However, the removed method does not affect the returned value nor does it affect the exceptions that are thrown by the API, as there is no return value and exceptions are caught and swallowed. Consequently, there is no Compatibility Issue, so the CI type is 0."
454,"<android.hardware.camera2.params.SessionConfiguration: void writeToParcel(Parcel,int)>",30,31,"<android.hardware.camera2.params.SessionConfiguration: void writeToParcel(Parcel,int)>","<android.hardware.camera2.params.SessionConfiguration: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mSessionType);
    if (mInputConfig != null) {
        dest.writeInt(mInputConfig.getWidth());
        dest.writeInt(mInputConfig.getHeight());
        dest.writeInt(mInputConfig.getFormat());
    } else {
        dest.writeInt(/*inputWidth*/
        0);
        dest.writeInt(/*inputHeight*/
        0);
        dest.writeInt(/*inputFormat*/
        -1);
    }
    dest.writeTypedList(mOutputConfigurations);
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mSessionType);
    if (mInputConfig != null) {
        dest.writeInt(mInputConfig.getWidth());
        dest.writeInt(mInputConfig.getHeight());
        dest.writeInt(mInputConfig.getFormat());
        dest.writeBoolean(mInputConfig.isMultiResolution());
    } else {
        dest.writeInt(/*inputWidth*/
        0);
        dest.writeInt(/*inputHeight*/
        0);
        dest.writeInt(/*inputFormat*/
        -1);
        dest.writeBoolean(/*isMultiResolution*/
        false);
    }
    dest.writeTypedList(mOutputConfigurations);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The late version contains one additional method call to `dest.writeBoolean(mInputConfig.isMultiResolution());` also with the corresponding else block to write a default boolean value, indicating an additional data written to the `Parcel`. This change type is 4.",There is no Compatibility Issue because the method `writeToParcel` does not return any value or throw any new exceptions; it merely serializes the `SessionConfiguration` instance's state into the `Parcel`. The new parcel data does not change the method's control flow or exception handling behaviorâ€”it only extends the data to be serialized without altering existing behavior.
455,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onConnectionStateChanged(BluetoothDevice,int)>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onConnectionStateChanged(BluetoothDevice,int)>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onConnectionStateChanged(BluetoothDevice,int)>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onConnectionStateChanged(device, state));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onConnectionStateChanged(device, state));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The addition of Attributable.setAttributionSource(device, mAttributionSource) and wrapping the executor's execute method call with a try-finally block to restore the calling identity refers to Other statement changed (4), but none of these changes seem to affect the return value or exception handling in this API's behavior; they affect the surrounding context and security of the API call.",There is no Compatibility Issue here because the changes do not affect how the method behaves in terms of the return values or exceptions that it might throw. The changes are related to the calling identity and attribution source management which should be transparent to the users of this method.
456,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,30,31,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,<android.app.Activity: boolean enterPictureInPictureMode(PictureInPictureParams)>,0,"{
    try {
        if (!deviceSupportsPictureInPictureMode()) {
            return false;
        }
        if (params == null) {
            throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
        }
        if (!mCanEnterPictureInPicture) {
            throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
        }
        // Set mIsInPictureInPictureMode earlier and don't wait for
        // onPictureInPictureModeChanged callback here. This is to ensure that
        // isInPictureInPictureMode returns true in the following onPause callback.
        // See https://developer.android.com/guide/topics/ui/picture-in-picture for guidance.
        mIsInPictureInPictureMode = ActivityTaskManager.getService().enterPictureInPictureMode(mToken, params);
        return mIsInPictureInPictureMode;
    } catch (RemoteException e) {
        return false;
    }
}","{
    if (!deviceSupportsPictureInPictureMode()) {
        return false;
    }
    if (params == null) {
        throw new IllegalArgumentException(""Expected non-null picture-in-picture params"");
    }
    if (!mCanEnterPictureInPicture) {
        throw new IllegalStateException(""Activity must be resumed to enter"" + "" picture-in-picture"");
    }
    // Set mIsInPictureInPictureMode earlier and don't wait for
    // onPictureInPictureModeChanged callback here. This is to ensure that
    // isInPictureInPictureMode returns true in the following onPause callback.
    // See https://developer.android.com/guide/topics/ui/picture-in-picture for guidance.
    mIsInPictureInPictureMode = ActivityClient.getInstance().enterPictureInPictureMode(mToken, params);
    return mIsInPictureInPictureMode;
}",1,"/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * <p>By default, system calculates the dimension of picture-in-picture window based on the
 * given {@param params}.
 * See <a href=""{@docRoot}guide/topics/ui/picture-in-picture"">Picture-in-picture Support</a>
 * on how to override this behavior.</p>
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 * does not support picture-in-picture, return false.
 */
","/**
 * Puts the activity in picture-in-picture mode if possible in the current system state. The
 * set parameters in {@param params} will be combined with the parameters from prior calls to
 * {@link #setPictureInPictureParams(PictureInPictureParams)}.
 *
 * The system may disallow entering picture-in-picture in various cases, including when the
 * activity is not visible, if the screen is locked or if the user has an activity pinned.
 *
 * <p>By default, system calculates the dimension of picture-in-picture window based on the
 * given {@param params}.
 * See <a href=""{@docRoot}guide/topics/ui/picture-in-picture"">Picture-in-picture Support</a>
 * on how to override this behavior.</p>
 *
 * @see android.R.attr#supportsPictureInPicture
 * @see PictureInPictureParams
 *
 * @param params non-null parameters to be combined with previously set parameters when entering
 * picture-in-picture.
 *
 * @return true if the system successfully put this activity into picture-in-picture mode or was
 * already in picture-in-picture mode (see {@link #isInPictureInPictureMode()}). If the device
 * does not support picture-in-picture, return false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method invoked to enter picture-in-picture mode has changed from ActivityTaskManager.getService().enterPictureInPictureMode() to ActivityClient.getInstance().enterPictureInPictureMode(); this indicates a change in dependent API, so the code change type is 5.","There is a change in the dependent API which could potentially return a different value (the boolean mIsInPictureInPictureMode) based on the new implementation. This would lead to a Compatibility Issue of type 1, as it potentially causes the API to return a different value."
457,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: boolean connect(BluetoothDevice)>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Initiates connection to host which is currently paired with this device. If the application
 * is not registered, #connect(BluetoothDevice) will fail. The connection state should be
 * tracked by the application by handling callback from Callback#onConnectionStateChanged. The
 * connection state is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Initiates connection to host which is currently paired with this device. If the application
 * is not registered, #connect(BluetoothDevice) will fail. The connection state should be
 * tracked by the application by handling callback from Callback#onConnectionStateChanged. The
 * connection state is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"A new parameter, mAttriburationSource, is passed to the method service.connect(), which indicates that the dependent API has changed. The code change type is 5.","There is no Compatibility Issue due to this code change, because the public API signature has not changed and the new parameter addition does not affect the return type or exception handling of the public API itself. The method is still returning a boolean result and handling the RemoteException the same way as before. Hence, it does not lead to different return values or types, nor to different exception handlings from the perspective of clients using this API."
458,<android.view.inputmethod.EditorInfo: CharSequence getInitialSelectedText(int)>,30,31,<android.view.inputmethod.EditorInfo: CharSequence getInitialSelectedText(int)>,<android.view.inputmethod.EditorInfo: CharSequence getInitialSelectedText(int)>,0,"{
    // Swap selection start and end if necessary.
    final int correctedTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd : initialSelStart;
    final int correctedTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart : initialSelEnd;
    final int sourceSelLength = correctedTextSelEnd - correctedTextSelStart;
    if (initialSelStart < 0 || initialSelEnd < 0 || mInitialSurroundingText.getSelectionLength() != sourceSelLength) {
        return null;
    }
    return mInitialSurroundingText.getInitialSelectedText(flags);
}","{
    if (mInitialSurroundingText == null) {
        return null;
    }
    // Swap selection start and end if necessary.
    final int correctedTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd : initialSelStart;
    final int correctedTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart : initialSelEnd;
    final int sourceSelLength = correctedTextSelEnd - correctedTextSelStart;
    int selStart = mInitialSurroundingText.getSelectionStart();
    int selEnd = mInitialSurroundingText.getSelectionEnd();
    if (selStart > selEnd) {
        int tmp = selStart;
        selStart = selEnd;
        selEnd = tmp;
    }
    final int selLength = selEnd - selStart;
    if (initialSelStart < 0 || initialSelEnd < 0 || selLength != sourceSelLength) {
        return null;
    }
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selStart, selEnd) : TextUtils.substring(mInitialSurroundingText.getText(), selStart, selEnd);
}",1,"/**
 * Gets the selected text, if any. May be {@code null} when the protocol is not supported or the
 * selected text is way too long.
 *
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text that is currently selected, if any. It could be an empty string when there
 * is no text selected. When {@code null} is returned, the selected text might be too long or
 * this protocol is not supported.
 */
","/**
 * Gets the selected text, if any. May be {@code null} when the protocol is not supported or the
 * selected text is way too long.
 *
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text that is currently selected, if any. It could be an empty string when there
 * is no text selected. When {@code null} is returned, the selected text might be too long or
 * this protocol is not supported.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early implementation directly accesses mInitialSurroundingText, which can potentially lead to a NullPointerException if it is null. In the late implementation, there's a new null check for mInitialSurroundingText, a refactoring of how selection starts and ends are determined and also a change in the return statement based on `flags`. This introduces changes in control dependency, other statements, and the return statement.","There is a new null check for mInitialSurroundingText which means this function in the late implementation can return null in a scenario where it would have previously caused a NullPointerException. This introduces a compatibility issue of type 1 as the behaviour has changed when mInitialSurroundingText is null. Additionally, the way how the returned value is calculated has also changed with the introduction of the conditional return based on `flags`. This can result in returning different values or types than the previous implementation, contributing further to a CI of type 1."
459,<android.provider.Settings: boolean canDrawOverlays(Context)>,30,31,<android.provider.Settings: boolean canDrawOverlays(Context)>,<android.provider.Settings: boolean canDrawOverlays(Context)>,0,"{
    return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false);
}","{
    return Settings.isCallingPackageAllowedToDrawOverlays(context, Process.myUid(), context.getOpPackageName(), false) || context.checkSelfPermission(Manifest.permission.SYSTEM_APPLICATION_OVERLAY) == PackageManager.PERMISSION_GRANTED;
}",1,"/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */
","/**
 * Checks if the specified context can draw on top of other apps. As of API
 * level 23, an app cannot draw on top of other apps unless it declares the
 * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its
 * manifest, <em>and</em> the user specifically grants the app this
 * capability. To prompt the user to grant this approval, the app must send an
 * intent with the action
 * {@link android.provider.Settings#ACTION_MANAGE_OVERLAY_PERMISSION}, which
 * causes the system to display a permission management screen.
 *
 * @param context App context.
 * @return true if the specified context can draw on top of other apps, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been extended with an additional logical OR condition that checks whether a specific permission is granted, resulting in a control dependency change (the execution of the return statement now additionally depends on the outcome of the permission check) and a potential change in the return value. The code change type is therefore 1,3.","The added permission check introduces a new pathway that can alter the return value from what would have been returned in the early version. In cases where the first method returns `false`, the late version may still return `true` if the permission is granted. This means that the API has a Compatibility Issue of type 1 due to potential different return values."
460,<android.accessibilityservice.AccessibilityService: List<AccessibilityWindowInfo> getWindows()>,30,31,<android.accessibilityservice.AccessibilityService: List<AccessibilityWindowInfo> getWindows()>,<android.accessibilityservice.AccessibilityService: List<AccessibilityWindowInfo> getWindows()>,0,"{
    return AccessibilityInteractionClient.getInstance().getWindows(mConnectionId);
}","{
    return AccessibilityInteractionClient.getInstance(this).getWindows(mConnectionId);
}",1,"/**
 * Gets the windows on the screen of the default display. This method returns only the windows
 * that a sighted user can interact with, as opposed to all windows.
 * For example, if there is a modal dialog shown and the user cannot touch
 * anything behind it, then only the modal window will be reported
 * (assuming it is the top one). For convenience the returned windows
 * are ordered in a descending layer order, which is the windows that
 * are on top are reported first. Since the user can always
 * interact with the window that has input focus by typing, the focused
 * window is always returned (even if covered by a modal window).
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag.
 * </p>
 *
 * @return The windows if there are windows and the service is can retrieve
 * them, otherwise an empty list.
 */
","/**
 * Gets the windows on the screen of the default display. This method returns only the windows
 * that a sighted user can interact with, as opposed to all windows.
 * For example, if there is a modal dialog shown and the user cannot touch
 * anything behind it, then only the modal window will be reported
 * (assuming it is the top one). For convenience the returned windows
 * are ordered in a descending layer order, which is the windows that
 * are on top are reported first. Since the user can always
 * interact with the window that has input focus by typing, the focused
 * window is always returned (even if covered by a modal window).
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag.
 * </p>
 *
 * @return The windows if there are windows and the service is can retrieve
 * them, otherwise an empty list.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the parameter to the getInstance method of AccessibilityInteractionClient; from a version without parameters, it was modified to pass `this` as the argument. In this case, the change type is 5, a dependent API change.","This change shouldn't introduce a Compatibility Issue, as the method's behavior presumably remains the same â€“ it still returns the result of calling getWindows() on an instance of AccessibilityInteractionClient. The getInstance() method likely returns the appropriate instance for the calling AccessibilityService, so it's an internal detail that does not affect the API contract. Thus, there does not seem to be a Compatibility Issue, and the CI type is 0."
461,<android.view.inputmethod.InlineSuggestionInfo: int hashCode()>,30,31,<android.view.inputmethod.InlineSuggestionInfo: int hashCode()>,<android.view.inputmethod.InlineSuggestionInfo: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlinePresentationSpec);
    _hash = 31 * _hash + java.util.Objects.hashCode(mSource);
    _hash = 31 * _hash + java.util.Arrays.hashCode(mAutofillHints);
    _hash = 31 * _hash + java.util.Objects.hashCode(mType);
    _hash = 31 * _hash + Boolean.hashCode(mPinned);
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + java.util.Objects.hashCode(mInlinePresentationSpec);
    _hash = 31 * _hash + java.util.Objects.hashCode(mSource);
    _hash = 31 * _hash + java.util.Arrays.hashCode(mAutofillHints);
    _hash = 31 * _hash + java.util.Objects.hashCode(mType);
    _hash = 31 * _hash + Boolean.hashCode(mPinned);
    _hash = 31 * _hash + java.util.Objects.hashCode(mTooltip);
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,0,"A new statement that calculates the hashcode of mTooltip has been added (_hash = 31 * _hash + java.util.Objects.hashCode(mTooltip);), so the code change type is 4.","The change is related to the internal calculation of the hash code. This should not be considered a Compatibility Issue since it does not affect the API's external behavior such as return value or exception throwing. The change should be invisible to the API's callers as long as they use hash codes as typically intended (for example, in hash-based collections). Thus, the CI type is 0."
464,<android.app.ContextImpl: void sendBroadcast(Intent)>,30,31,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change has been made in the argument of the method call 'broadcastIntentWithFeature', where 'null' is passed explicitly before 'AppOpsManager.OP_NONE'. There are no other changes in control flow or logic.","Since the added 'null' argument in the method call does not affect the behavior of 'sendBroadcast', as it effectively represents an unchanged parameter list (assuming the called method signature accommodates the additional null as an overloaded version or optional parameter), there is no compatibility issue. The method will still perform the same actions and throw the same exceptions as before."
465,<android.content.SyncResult: String toDebugString()>,30,31,<android.content.SyncResult: String toDebugString()>,<android.content.SyncResult: String toDebugString()>,0,"{
    StringBuffer sb = new StringBuffer();
    if (fullSyncRequested) {
        sb.append(""f1"");
    }
    if (partialSyncUnavailable) {
        sb.append(""r1"");
    }
    if (hasHardError()) {
        sb.append(""X1"");
    }
    if (stats.numParseExceptions > 0) {
        sb.append(""e"").append(stats.numParseExceptions);
    }
    if (stats.numConflictDetectedExceptions > 0) {
        sb.append(""c"").append(stats.numConflictDetectedExceptions);
    }
    if (stats.numAuthExceptions > 0) {
        sb.append(""a"").append(stats.numAuthExceptions);
    }
    if (tooManyDeletions) {
        sb.append(""D1"");
    }
    if (tooManyRetries) {
        sb.append(""R1"");
    }
    if (databaseError) {
        sb.append(""b1"");
    }
    if (hasSoftError()) {
        sb.append(""x1"");
    }
    if (syncAlreadyInProgress) {
        sb.append(""l1"");
    }
    if (stats.numIoExceptions > 0) {
        sb.append(""I"").append(stats.numIoExceptions);
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    if (fullSyncRequested) {
        sb.append(""f1"");
    }
    if (partialSyncUnavailable) {
        sb.append(""r1"");
    }
    if (hasHardError()) {
        sb.append(""X1"");
    }
    if (stats.numParseExceptions > 0) {
        sb.append(""e"").append(stats.numParseExceptions);
    }
    if (stats.numConflictDetectedExceptions > 0) {
        sb.append(""c"").append(stats.numConflictDetectedExceptions);
    }
    if (stats.numAuthExceptions > 0) {
        sb.append(""a"").append(stats.numAuthExceptions);
    }
    if (tooManyDeletions) {
        sb.append(""D1"");
    }
    if (tooManyRetries) {
        sb.append(""R1"");
    }
    if (databaseError) {
        sb.append(""b1"");
    }
    if (hasSoftError()) {
        sb.append(""x1"");
    }
    if (syncAlreadyInProgress) {
        sb.append(""l1"");
    }
    if (stats.numIoExceptions > 0) {
        sb.append(""I"").append(stats.numIoExceptions);
    }
    return sb.toString();
}",1,"/**
 * Generates a debugging string indicating the status.
 * The string consist of a sequence of code letter followed by the count.
 * Code letters are f - fullSyncRequested, r - partialSyncUnavailable,
 * X - hardError, e - numParseExceptions, c - numConflictDetectedExceptions,
 * a - numAuthExceptions, D - tooManyDeletions, R - tooManyRetries,
 * b - databaseError, x - softError, l - syncAlreadyInProgress,
 * I - numIoExceptions
 * @return debugging string.
 */
","/**
 * Generates a debugging string indicating the status.
 * The string consist of a sequence of code letter followed by the count.
 * Code letters are f - fullSyncRequested, r - partialSyncUnavailable,
 * X - hardError, e - numParseExceptions, c - numConflictDetectedExceptions,
 * a - numAuthExceptions, D - tooManyDeletions, R - tooManyRetries,
 * b - databaseError, x - softError, l - syncAlreadyInProgress,
 * I - numIoExceptions
 * @return debugging string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the code between the two versions is the use of StringBuilder instead of StringBuffer, which are different classes in Java for constructing and manipulating sequences of characters, however, they both provide the same method behavior. StringBuilder is non-synchronized (not thread-safe), while StringBuffer is synchronized (thread-safe). The method's functionality and the return value remain unchanged, because the method toDebugString() does not concern about the thread safety, but rather just appends the characters to a sequence.",There should be no Compatibility Issue because the return value will still be a String representing the debug information and the switch from StringBuffer to StringBuilder does not alter the business logic of the method or its output. The change does not affect the behavior of the API as perceived by the code using it.
466,<android.widget.TextView: void autofill(AutofillValue)>,30,31,<android.widget.TextView: void autofill(AutofillValue)>,<android.widget.TextView: void autofill(AutofillValue)>,0,"{
    if (!value.isText() || !isTextEditable()) {
        Log.w(LOG_TAG, value + "" could not be autofilled into "" + this);
        return;
    }
    final CharSequence autofilledValue = value.getTextValue();
    // First autofill it...
    setText(autofilledValue, mBufferType, true, 0);
    // ...then move cursor to the end.
    final CharSequence text = getText();
    if ((text instanceof Spannable)) {
        Selection.setSelection((Spannable) text, text.length());
    }
}","{
    if (!isTextEditable()) {
        Log.w(LOG_TAG, ""cannot autofill non-editable TextView: "" + this);
        return;
    }
    if (!value.isText()) {
        Log.w(LOG_TAG, ""value of type "" + value.describeContents() + "" cannot be autofilled into "" + this);
        return;
    }
    final ClipData clip = ClipData.newPlainText("""", value.getTextValue());
    final ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_AUTOFILL).build();
    performReceiveContent(payload);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation has significantly changed with alteration in the control flow, deletion of some statements and addition of new statements like 'final ClipData clip = ...' and 'performReceiveContent(payload);'. The log messages have also been adapted to be more descriptive of which check failed, and the way the `autofilledValue` is used to set the text has been modified. The method setText(...) along with the subsequent selection setting has been replaced with performReceiveContent(...), thus changing dependent API as setText(...) was an internally used API. So, the code change types include 1,3,4,5.","Since the `setText(...)` method and cursor positioning logic have been replaced with `performReceiveContent(...)`, the value set in the TextView could potentially be handled differently, thus a Compatibility Issue arises due to potentially different return values or behaviours, making the CI type 1."
467,"<android.app.Activity: void requestPermissions(String[],int)>",30,31,"<android.app.Activity: void requestPermissions(String[],int)>","<android.app.Activity: void requestPermissions(String[],int)>",0,"{
    if (requestCode < 0) {
        throw new IllegalArgumentException(""requestCode should be >= 0"");
    }
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can request only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}","{
    if (requestCode < 0) {
        throw new IllegalArgumentException(""requestCode should be >= 0"");
    }
    if (mHasCurrentPermissionsRequest) {
        Log.w(TAG, ""Can request only one set of permissions at a time"");
        // Dispatch the callback with empty arrays which means a cancellation.
        onRequestPermissionsResult(requestCode, new String[0], new int[0]);
        return;
    }
    if (!getAttributionSource().getRenouncedPermissions().isEmpty()) {
        final int permissionCount = permissions.length;
        for (int i = 0; i < permissionCount; i++) {
            if (getAttributionSource().getRenouncedPermissions().contains(permissions[i])) {
                throw new IllegalArgumentException(""Cannot request renounced permission: "" + permissions[i]);
            }
        }
    }
    final Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
    mHasCurrentPermissionsRequest = true;
}",1,"/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link
 * android.content.pm.PermissionInfo#PROTECTION_DANGEROUS dangerous}, regardless
 * whether they are declared by the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * Call {@link #shouldShowRequestPermissionRationale(String)} before calling this API to
 * check if the system recommends to show a rationale UI before asking for a permission.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * Calling this API for permissions already granted to your app would show UI
 * to the user to decide whether the app can still hold these permissions. This
 * can be useful if the way your app uses data guarded by the permissions
 * changes significantly.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""https://github.com/googlesamples/android-RuntimePermissions"">
 * RuntimePermissions</a> sample app demonstrates how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @throws IllegalArgumentException if requestCode is negative.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
","/**
 * Requests permissions to be granted to this application. These permissions
 * must be requested in your manifest, they should not be granted to your app,
 * and they should have protection level {@link
 * android.content.pm.PermissionInfo#PROTECTION_DANGEROUS dangerous}, regardless
 * whether they are declared by the platform or a third-party app.
 * <p>
 * Normal permissions {@link android.content.pm.PermissionInfo#PROTECTION_NORMAL}
 * are granted at install time if requested in the manifest. Signature permissions
 * {@link android.content.pm.PermissionInfo#PROTECTION_SIGNATURE} are granted at
 * install time if requested in the manifest and the signature of your app matches
 * the signature of the app declaring the permissions.
 * </p>
 * <p>
 * Call {@link #shouldShowRequestPermissionRationale(String)} before calling this API to
 * check if the system recommends to show a rationale UI before asking for a permission.
 * </p>
 * <p>
 * If your app does not have the requested permissions the user will be presented
 * with UI for accepting them. After the user has accepted or rejected the
 * requested permissions you will receive a callback on {@link
 * #onRequestPermissionsResult(int, String[], int[])} reporting whether the
 * permissions were granted or not.
 * </p>
 * <p>
 * Note that requesting a permission does not guarantee it will be granted and
 * your app should be able to run without having this permission.
 * </p>
 * <p>
 * This method may start an activity allowing the user to choose which permissions
 * to grant and which to reject. Hence, you should be prepared that your activity
 * may be paused and resumed. Further, granting some permissions may require
 * a restart of you application. In such a case, the system will recreate the
 * activity stack before delivering the result to {@link
 * #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * When checking whether you have a permission you should use {@link
 * #checkSelfPermission(String)}.
 * </p>
 * <p>
 * You cannot request a permission if your activity sets {@link
 * android.R.styleable#AndroidManifestActivity_noHistory noHistory} to
 * <code>true</code> because in this case the activity would not receive
 * result callbacks including {@link #onRequestPermissionsResult(int, String[], int[])}.
 * </p>
 * <p>
 * The <a href=""https://github.com/android/permissions-samples"">
 * RuntimePermissions</a> sample apps demonstrate how to use this method to
 * request permissions at run time.
 * </p>
 *
 * @param permissions The requested permissions. Must me non-null and not empty.
 * @param requestCode Application specific request code to match with a result
 * reported to {@link #onRequestPermissionsResult(int, String[], int[])}.
 * Should be >= 0.
 *
 * @throws IllegalArgumentException if requestCode is negative.
 *
 * @see #onRequestPermissionsResult(int, String[], int[])
 * @see #checkSelfPermission(String)
 * @see #shouldShowRequestPermissionRationale(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"An additional conditional check is introduced in the Late Implementation to verify whether any of the received permissions have been renounced. There's also a 'for' loop to iterate over the permissions. Both are a change in a control dependency and other statements, so the code change type is 3,4.","There should be no compatibility issue caused by this change. The additional block only throws an exception for a new condition: if the permission has been renounced, which would not affect existing, well-behaving clients that do not request renounced permissions. Hence, no CI is expected (type 0)."
468,<android.app.Activity: void onBackPressed()>,30,31,<android.app.Activity: void onBackPressed()>,<android.app.Activity: void onBackPressed()>,0,"{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    try {
        // Inform activity task manager that the activity received a back press
        // while at the root of the task. This call allows ActivityTaskManager
        // to intercept or defer finishing.
        ActivityTaskManager.getService().onBackPressedOnTaskRoot(mToken, new RequestFinishCallback(new WeakReference<>(this)));
    } catch (RemoteException e) {
        finishAfterTransition();
    }
}","{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    FragmentManager fragmentManager = mFragments.getFragmentManager();
    if (!fragmentManager.isStateSaved() && fragmentManager.popBackStackImmediate()) {
        return;
    }
    if (!isTaskRoot()) {
        // If the activity is not the root of the task, allow finish to proceed normally.
        finishAfterTransition();
        return;
    }
    // Inform activity task manager that the activity received a back press while at the
    // root of the task. This call allows ActivityTaskManager to intercept or move the task
    // to the back.
    ActivityClient.getInstance().onBackPressedOnTaskRoot(mToken, new RequestFinishCallback(new WeakReference<>(this)));
    // be restored now.
    if (mIntent != null && mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) {
        restoreAutofillSaveUi();
    }
}",1,"/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */
","/**
 * Called when the activity has detected the user's press of the back key. The default
 * implementation depends on the platform version:
 *
 * <ul>
 * <li>On platform versions prior to {@link android.os.Build.VERSION_CODES#S}, it
 * finishes the current activity, but you can override this to do whatever you want.
 *
 * <li><p>Starting with platform version {@link android.os.Build.VERSION_CODES#S}, for
 * activities that are the root activity of the task and also declare an
 * {@link android.content.IntentFilter} with {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER} in the manifest, the current activity and its
 * task will be moved to the back of the activity stack instead of being finished.
 * Other activities will simply be finished.
 *
 * <p>If you target version {@link android.os.Build.VERSION_CODES#S} or later and
 * override this method, it is strongly recommended to call through to the superclass
 * implementation after you finish handling navigation within the app.
 * </ul>
 *
 * @see #moveTaskToBack(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control dependency and subsequent action have been added (`if` statement checking mIntent and calling restoreAutofillSaveUi()). Additionally, the method `ActivityTaskManager.getService()` has been replaced with `ActivityClient.getInstance()`, which represents a code change as well. So the change types are 3 and 4.","Since there's a new if condition that involves restoring the autofill save UI, which can potentially alter the method's behavior, and the ActivityTaskManager call has changed, there could be a different outcome in terms of the UI state or the flow. Therefore, the compatibility issue type is 1."
470,"<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>",30,31,"<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>","<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    AbstractInputMethodService target = mTarget.get();
    if (target == null) {
        return;
    }
    if (target.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.executeOrSendMessage(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}","{
    AbstractInputMethodService target = mTarget.get();
    if (target == null) {
        return;
    }
    if (target.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.getHandler().sendMessageAtFrontOfQueue(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}",1,,,-1,"[@BinderThread, @Override]","[@BinderThread, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to send a message to mCaller has changed from executeOrSendMessage to getHandler().sendMessageAtFrontOfQueue. This is not a return statement, exception handling, or control dependency change, but a change in the method used for sending the message, hence the change type is 4. Additionally, the semantics of how the message is queued might differ, which could impact a dependent API, leading to a type 5 change.","Since the change does not affect the API's return value or the exceptions it might throw, it should not cause any compatibility issue based on the given information. The queueing semantics might have changed, but since the latch is still used to wait for the dump operation to complete and it does not impact the success or failure observable by the API's clients, it does not introduce a compatibility issue. Therefore, the CI type is 0."
471,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,30,31,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.isDiscovering(mAttributionSource);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true if discovering
 */
","/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true if discovering
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothScanPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The code change is in the call to `mService.isDiscovering()` where the late version introduces a new parameter `mAttributionSource`, indicating a change in the dependent API. There's also a change in the annotations, but annotations changes are not considered in the determination of code changes. So the change type is 4,5.","The added parameter `mAttributionSource` in the method call to `mService.isDiscovering()` does not impact the return type or value of `isDiscovering()` from the perspective of the caller since it's related to internal implementation details. It also does not impact exception handling or any other behaviors that could be observable by the code using this API. Therefore, there is no compatibility issue, hence the CI type is 0."
472,<android.view.VerifiedKeyEvent: int hashCode()>,30,31,<android.view.VerifiedKeyEvent: int hashCode()>,<android.view.VerifiedKeyEvent: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + getDeviceId();
    _hash = 31 * _hash + Long.hashCode(getEventTimeNanos());
    _hash = 31 * _hash + getSource();
    _hash = 31 * _hash + getDisplayId();
    _hash = 31 * _hash + mAction;
    _hash = 31 * _hash + Long.hashCode(mDownTimeNanos);
    _hash = 31 * _hash + mFlags;
    _hash = 31 * _hash + mKeyCode;
    _hash = 31 * _hash + mScanCode;
    _hash = 31 * _hash + mMetaState;
    _hash = 31 * _hash + mRepeatCount;
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + super.hashCode();
    _hash = 31 * _hash + mAction;
    _hash = 31 * _hash + Long.hashCode(mDownTimeNanos);
    _hash = 31 * _hash + mFlags;
    _hash = 31 * _hash + mKeyCode;
    _hash = 31 * _hash + mScanCode;
    _hash = 31 * _hash + mMetaState;
    _hash = 31 * _hash + mRepeatCount;
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The hash code calculation now includes a call to super.hashCode() which replaces several individual field hash code calculations (getDeviceId(), getEventTimeNanos(), getSource(), getDisplayId()), indicating a change in logic for generating the hash code. This is a change in the other statements within the method body, so the code change types are 1,4.","Since the hash code generation logic has changed and the value returned by the hashCode() method can be different in the late version due to the introduction of super.hashCode(), the CI type is 1."
473,<android.service.autofill.Validators: Validator not(Validator)>,30,31,<android.service.autofill.Validators: Validator not(Validator)>,<android.service.autofill.Validators: Validator not(Validator)>,0,"{
    Preconditions.checkArgument(validator instanceof InternalValidator, ""validator not provided by Android System: "" + validator);
    return new NegationValidator((InternalValidator) validator);
}","{
    Preconditions.checkArgument(validator instanceof InternalValidator, ""validator not provided by Android System: %s"", validator);
    return new NegationValidator((InternalValidator) validator);
}",1,"/**
 * Creates a validator that is valid when {@code validator} is not, and vice versa.
 *
 * <p>Used to represent a {@code NOT} boolean operation in a chain of validators.
 *
 * @throws IllegalArgumentException if {@code validator} is an instance of a class that is not
 * provided by the Android System.
 */
","/**
 * Creates a validator that is valid when {@code validator} is not, and vice versa.
 *
 * <p>Used to represent a {@code NOT} boolean operation in a chain of validators.
 *
 * @throws IllegalArgumentException if {@code validator} is an instance of a class that is not
 * provided by the Android System.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is related to the formatting of the error message in the Preconditions.checkArgument method. The actual logic of the method call and the object being returned does not change, so the code change type is 4.","The modification in the error message format will not cause the method to exhibit different behavior in terms of its execution path or output, as long as the argument condition is met. If the condition is not met, both versions will throw IllegalArgumentException but with different messages. Since the format of the error message does not affect the behavior of the API from the caller's perspective (as the messages are only different in formatting, not in substance), there is no Compatibility Issue."
474,<android.app.UiAutomation: WindowAnimationFrameStats getWindowAnimationFrameStats()>,30,31,<android.app.UiAutomation: WindowAnimationFrameStats getWindowAnimationFrameStats()>,<android.app.UiAutomation: WindowAnimationFrameStats getWindowAnimationFrameStats()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Getting window animation frame stats"");
        }
        // Calling out without a lock held.
        return mUiAutomationConnection.getWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting window animation frame stats!"", re);
    }
    return null;
}","{
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Getting window animation frame stats"");
        }
        // Calling out without a lock held.
        return mUiAutomationConnection.getWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting window animation frame stats!"", re);
    }
    return null;
}",1,"/**
 * Gets the window animation frame statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * <p>
 * A typical usage requires clearing the window animation frame statistics via
 * {@link #clearWindowAnimationFrameStats()} followed by an interaction that causes
 * a window transition which uses a window animation and finally getting the window
 * animation frame statistics by calling this method.
 * </p>
 * <pre>
 * // Start with a clean slate.
 * uiAutimation.clearWindowAnimationFrameStats();
 *
 * // Do stuff to trigger a window transition.
 *
 * // Get the frame statistics.
 * WindowAnimationFrameStats stats = uiAutomation.getWindowAnimationFrameStats();
 * </pre>
 *
 * @return The window animation frame statistics.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #clearWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
","/**
 * Gets the window animation frame statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * <p>
 * A typical usage requires clearing the window animation frame statistics via
 * {@link #clearWindowAnimationFrameStats()} followed by an interaction that causes
 * a window transition which uses a window animation and finally getting the window
 * animation frame statistics by calling this method.
 * </p>
 * <pre>
 * // Start with a clean slate.
 * uiAutimation.clearWindowAnimationFrameStats();
 *
 * // Do stuff to trigger a window transition.
 *
 * // Get the frame statistics.
 * WindowAnimationFrameStats stats = uiAutomation.getWindowAnimationFrameStats();
 * </pre>
 *
 * @return The window animation frame statistics.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #clearWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version includes a block of code that uses a synchronized block with a 'throwIfNotConnectedLocked()' method call which is not present in the late version, and the change in debug logging is not a functional change. This indicates that there has been a control structure change and other statements change, therefore code change types 3 and 4 are applicable.","The removal of the synchronized block and the 'throwIfNotConnectedLocked()' method call does not introduce a change in the method's return type or value, nor does it introduce any new exceptions or changes in exception handling. As such, the changes do not affect the API's behavior from the caller's perspective, resulting in no compatibility issues."
475,"<android.security.ConfirmationPrompt: void presentPrompt(Executor,ConfirmationCallback)>",30,31,"<android.security.ConfirmationPrompt: void presentPrompt(Executor,ConfirmationCallback)>","<android.security.ConfirmationPrompt: void presentPrompt(Executor,ConfirmationCallback)>",0,"{
    if (mCallback != null) {
        throw new ConfirmationAlreadyPresentingException();
    }
    if (isAccessibilityServiceRunning(mContext)) {
        throw new ConfirmationNotAvailableException();
    }
    mCallback = callback;
    mExecutor = executor;
    int uiOptionsAsFlags = getUiOptionsAsFlags();
    String locale = Locale.getDefault().toLanguageTag();
    int responseCode = mKeyStore.presentConfirmationPrompt(mCallbackBinder, mPromptText.toString(), mExtraData, locale, uiOptionsAsFlags);
    switch(responseCode) {
        case KeyStore.CONFIRMATIONUI_OK:
            return;
        case KeyStore.CONFIRMATIONUI_OPERATION_PENDING:
            throw new ConfirmationAlreadyPresentingException();
        case KeyStore.CONFIRMATIONUI_UNIMPLEMENTED:
            throw new ConfirmationNotAvailableException();
        case KeyStore.CONFIRMATIONUI_UIERROR:
            throw new IllegalArgumentException();
        default:
            // Unexpected error code.
            Log.w(TAG, ""Unexpected responseCode="" + responseCode + "" from presentConfirmationPrompt() call."");
            throw new IllegalArgumentException();
    }
}","{
    if (mCallback != null) {
        throw new ConfirmationAlreadyPresentingException();
    }
    if (isAccessibilityServiceRunning(mContext)) {
        throw new ConfirmationNotAvailableException();
    }
    mCallback = callback;
    mExecutor = executor;
    String locale = Locale.getDefault().toLanguageTag();
    int uiOptionsAsFlags = getUiOptionsAsFlags();
    int responseCode = getService().presentConfirmationPrompt(mConfirmationCallback, mPromptText.toString(), mExtraData, locale, uiOptionsAsFlags);
    switch(responseCode) {
        case AndroidProtectedConfirmation.ERROR_OK:
            return;
        case AndroidProtectedConfirmation.ERROR_OPERATION_PENDING:
            throw new ConfirmationAlreadyPresentingException();
        case AndroidProtectedConfirmation.ERROR_UNIMPLEMENTED:
            throw new ConfirmationNotAvailableException();
        default:
            // Unexpected error code.
            Log.w(TAG, ""Unexpected responseCode="" + responseCode + "" from presentConfirmationPrompt() call."");
            throw new IllegalArgumentException();
    }
}",1,"/**
 * Requests a confirmation prompt to be presented to the user.
 *
 * When the prompt is no longer being presented, one of the methods in
 * {@link ConfirmationCallback} is called on the supplied callback object.
 *
 * Confirmation prompts may not be available when accessibility services are running so this
 * may fail with a {@link ConfirmationNotAvailableException} exception even if
 * {@link #isSupported} returns {@code true}.
 *
 * @param executor the executor identifying the thread that will receive the callback.
 * @param callback the callback to use when the prompt is done showing.
 * @throws IllegalArgumentException if the prompt text is too long or malfomed.
 * @throws ConfirmationAlreadyPresentingException if another prompt is being presented.
 * @throws ConfirmationNotAvailableException if confirmation prompts are not supported.
 */
","/**
 * Requests a confirmation prompt to be presented to the user.
 *
 * When the prompt is no longer being presented, one of the methods in
 * {@link ConfirmationCallback} is called on the supplied callback object.
 *
 * Confirmation prompts may not be available when accessibility services are running so this
 * may fail with a {@link ConfirmationNotAvailableException} exception even if
 * {@link #isSupported} returns {@code true}.
 *
 * @param executor the executor identifying the thread that will receive the callback.
 * @param callback the callback to use when the prompt is done showing.
 * @throws IllegalArgumentException if the prompt text is too long or malfomed.
 * @throws ConfirmationAlreadyPresentingException if another prompt is being presented.
 * @throws ConfirmationNotAvailableException if confirmation prompts are not supported.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","There is a control dependency change where the class name used for constants in the switch case is changed from `KeyStore` to `AndroidProtectedConfirmation`. There's also a dependent API changed from `mKeyStore.presentConfirmationPrompt` to `getService().presentConfirmationPrompt`. Additionally, there is an exception handling change: `KeyStore.CONFIRMATIONUI_UIERROR` case has been removed, in effect changing the exception that may be thrown in the default case.","The change in the control dependency (the switch cases) along with the removal of the `KeyStore.CONFIRMATIONUI_UIERROR` case may result in different exceptions being thrown, causing a CI type of 2. Meanwhile, the change in dependent API (from `mKeyStore.presentConfirmationPrompt` to `getService().presentConfirmationPrompt`) alters the method being called, resulting in potential different return behavior, causing a CI type of 1."
476,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,30,31,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void stopLeScan()>,0,"{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.stopScan(mScannerId);
            mBluetoothGatt.unregisterScanner(mScannerId);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to stop scan and unregister"", e);
        }
        mScannerId = -1;
    }
}","{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.stopScan(mScannerId, mAttributionSource);
            mBluetoothGatt.unregisterScanner(mScannerId, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to stop scan and unregister"", e);
        }
        mScannerId = -1;
    }
}",1,,,-1,,[@RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)],-1,-1,-1,-1,-1,-1,5,0,"The dependent API changed as `mBluetoothGatt.stopScan()` and `mBluetoothGatt.unregisterScanner()` now take an additional parameter `mAttributionSource`, so the code change type is 5.","The changes in the parameters of the dependent APIs do not inherently cause a different return value or handling of exceptions, so there is no compatibility issue according to the provided definitions. The behavior in terms of API contract remains consistent assuming the additional `mAttributionSource` is correctly handled internally within the `mBluetoothGatt` implementation."
477,"<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,String,int)>",30,31,"<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,String,int)>","<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,String,int)>",0,"{
    synchronized (mStartLock) {
        mUtterances.put(text, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}","{
    return addSpeech(text, makeResourceUri(packagename, resourceId));
}",1,"/**
 * Adds a mapping between a CharSequence (may be spanned with TtsSpans) of text
 * and a sound resource in a package. After a call to this method, subsequent calls to
 * {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a CharSequence (may be spanned with TtsSpans) of text
 * and a sound resource in a package. After a call to this method, subsequent calls to
 * {@link #speak(CharSequence, int, Bundle, String)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The implementation of the addSpeech() method has changed to call another addSpeech() method with the newly created resource URI instead of adding to mUtterances directly, which indicates a change in a dependent API, so the code change type is 5.","Since we don't have visibility into the implementation of the overloaded addSpeech() method that is called in the late version, and because it is used in a different way than in the early version (which directly modifies the mUtterances map), this constitutes a change in behavior. In the early version, the success is assumed after putting an item in the map, while in the late version, it relies on the result of the newly called addSpeech() method. Therefore, there's a potential for different return values, and the CI type is 1."
478,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",30,31,"<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>","<android.app.Instrumentation: Activity newActivity(Class<?>,Context,IBinder,Application,Intent,ActivityInfo,CharSequence,Activity,String,Object)>",0,"{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null, /* activityConfigCallback */
    null);
    return activity;
}","{
    Activity activity = (Activity) clazz.newInstance();
    ActivityThread aThread = null;
    // Activity.attach expects a non-null Application Object.
    if (application == null) {
        application = new Application();
    }
    activity.attach(context, aThread, this, token, 0, /* ident */
    application, intent, info, title, parent, id, (Activity.NonConfigurationInstances) lastNonConfigurationInstance, new Configuration(), null, /* referrer */
    null, /* voiceInteractor */
    null, /* window */
    null, /* activityConfigCallback */
    null, /*assistToken*/
    null);
    return activity;
}",1,"/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
","/**
 * Perform instantiation of an {@link Activity} object.  This method is intended for use with
 * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable
 * locally but will be missing some of the linkages necessary for use within the system.
 *
 * @param clazz The Class of the desired Activity
 * @param context The base context for the activity to use
 * @param token The token for this activity to communicate with
 * @param application The application object (if any)
 * @param intent The intent that started this Activity
 * @param info ActivityInfo from the manifest
 * @param title The title, typically retrieved from the ActivityInfo record
 * @param parent The parent Activity (if any)
 * @param id The embedded Id (if any)
 * @param lastNonConfigurationInstance Arbitrary object that will be
 * available via {@link Activity#getLastNonConfigurationInstance()
 * Activity.getLastNonConfigurationInstance()}.
 * @return Returns the instantiated activity
 * @throws InstantiationException
 * @throws IllegalAccessException
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"Despite the comment in the code referencing the addition of the `assistToken`, the actual call to `activity.attach` within both the early and late versions of the implementation passes `null` for the last parameter, which does not affect how many parameters are passed nor their types. As such, there are no functional changes between the early and late versions. Comments do not affect the execution of the code.","There is no compatibility issue because the way the method works has not changed between versions, as the implementation of the method itself remains unaltered in terms of logic and behavior."
479,"<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<PathWithRequiredFlags>,Map<String, Set<PathWithRequiredFlags>>)>",30,31,"<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<PathWithRequiredFlags>,Map<String, Set<PathWithRequiredFlags>>)>","<android.app.backup.FullBackup.BackupScheme: void parseBackupSchemeFromXmlLocked(XmlPullParser,Set<PathWithRequiredFlags>,Map<String, Set<PathWithRequiredFlags>>)>",0,"{
    // START_DOCUMENT
    int event = parser.getEventType();
    while (event != XmlPullParser.START_TAG) {
        event = parser.next();
    }
    if (!""full-backup-content"".equals(parser.getName())) {
        throw new XmlPullParserException(""Xml file didn't start with correct tag"" + "" (<full-backup-content>). Found \"""" + parser.getName() + ""\"""");
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""Found valid fullBackupContent; parsing xml resource."");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, """");
    }
    while ((event = parser.next()) != XmlPullParser.END_DOCUMENT) {
        switch(event) {
            case XmlPullParser.START_TAG:
                validateInnerTagContents(parser);
                final String domainFromXml = parser.getAttributeValue(null, ""domain"");
                final File domainDirectory = getDirectoryForCriteriaDomain(domainFromXml);
                if (domainDirectory == null) {
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...parsing \"""" + parser.getName() + ""\"": "" + ""domain=\"""" + domainFromXml + ""\"" invalid; skipping"");
                    }
                    break;
                }
                final File canonicalFile = extractCanonicalFile(domainDirectory, parser.getAttributeValue(null, ""path""));
                if (canonicalFile == null) {
                    break;
                }
                // no transport flags are required by default
                int requiredFlags = 0;
                if (TAG_INCLUDE.equals(parser.getName())) {
                    // requiredFlags are only supported for <include /> tag, for <exclude />
                    // we should always leave them as the default = 0
                    requiredFlags = getRequiredFlagsFromString(parser.getAttributeValue(null, ""requireFlags""));
                }
                // retrieve the include/exclude set we'll be adding this rule to
                Set<PathWithRequiredFlags> activeSet = parseCurrentTagForDomain(parser, excludes, includes, domainFromXml);
                activeSet.add(new PathWithRequiredFlags(canonicalFile.getCanonicalPath(), requiredFlags));
                if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                    Log.v(TAG_XML_PARSER, ""...parsed "" + canonicalFile.getCanonicalPath() + "" for domain \"""" + domainFromXml + ""\"", requiredFlags + \"""" + requiredFlags + ""\"""");
                }
                // dir, so we add the -journal anyway to be safe.
                if (""database"".equals(domainFromXml) && !canonicalFile.isDirectory()) {
                    final String canonicalJournalPath = canonicalFile.getCanonicalPath() + ""-journal"";
                    activeSet.add(new PathWithRequiredFlags(canonicalJournalPath, requiredFlags));
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalJournalPath + "". Ignore if nonexistent."");
                    }
                    final String canonicalWalPath = canonicalFile.getCanonicalPath() + ""-wal"";
                    activeSet.add(new PathWithRequiredFlags(canonicalWalPath, requiredFlags));
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalWalPath + "". Ignore if nonexistent."");
                    }
                }
                // Special case for sharedpref files (not dirs) also add "".xml"" suffix file.
                if (""sharedpref"".equals(domainFromXml) && !canonicalFile.isDirectory() && !canonicalFile.getCanonicalPath().endsWith("".xml"")) {
                    final String canonicalXmlPath = canonicalFile.getCanonicalPath() + "".xml"";
                    activeSet.add(new PathWithRequiredFlags(canonicalXmlPath, requiredFlags));
                    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
                        Log.v(TAG_XML_PARSER, ""...automatically generated "" + canonicalXmlPath + "". Ignore if nonexistent."");
                    }
                }
        }
    }
    if (Log.isLoggable(TAG_XML_PARSER, Log.VERBOSE)) {
        Log.v(TAG_XML_PARSER, ""\n"");
        Log.v(TAG_XML_PARSER, ""Xml resource parsing complete."");
        Log.v(TAG_XML_PARSER, ""Final tally."");
        Log.v(TAG_XML_PARSER, ""Includes:"");
        if (includes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing specified (This means the entirety of app"" + "" data minus excludes)"");
        } else {
            for (Map.Entry<String, Set<PathWithRequiredFlags>> entry : includes.entrySet()) {
                Log.v(TAG_XML_PARSER, ""  domain="" + entry.getKey());
                for (PathWithRequiredFlags includeData : entry.getValue()) {
                    Log.v(TAG_XML_PARSER, "" path: "" + includeData.getPath() + "" requiredFlags: "" + includeData.getRequiredFlags());
                }
            }
        }
        Log.v(TAG_XML_PARSER, ""Excludes:"");
        if (excludes.isEmpty()) {
            Log.v(TAG_XML_PARSER, ""  ...nothing to exclude."");
        } else {
            for (PathWithRequiredFlags excludeData : excludes) {
                Log.v(TAG_XML_PARSER, "" path: "" + excludeData.getPath() + "" requiredFlags: "" + excludeData.getRequiredFlags());
            }
        }
        Log.v(TAG_XML_PARSER, ""  "");
        Log.v(TAG_XML_PARSER, ""===================================================="");
        Log.v(TAG_XML_PARSER, ""\n"");
    }
}","{
    verifyTopLevelTag(parser, ""full-backup-content"");
    parseRules(parser, excludes, includes, Optional.empty(), ""full-backup-content"");
    logParsingResults(excludes, includes);
}",1,,,-1,[@VisibleForTesting],[@VisibleForTesting],-1,-1,-1,-1,-1,-1,,,,
480,<android.content.IntentSender: int getCreatorUid()>,30,31,<android.content.IntentSender: int getCreatorUid()>,<android.content.IntentSender: int getCreatorUid()>,0,"{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}","{
    return getCachedInfo().getCreatorUid();
}",1,"/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
","/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has completely changed from invoking a method on ActivityManager to calling getCachedInfo(). There is also a removed try-catch block and the dependent API has changed, resulting in code changes of type 1,5.","Because the implementation changes from calling the ActivityManager service to using a locally cached value and because the exception handling was removed (previously returning -1 in an error case), the return value can differ for the same conditions. This could lead to a Compatibility Issue of type 1, where return values potentially differ."
481,<android.view.DisplayCutout: int hashCode()>,30,31,<android.view.DisplayCutout: int hashCode()>,<android.view.DisplayCutout: int hashCode()>,0,"{
    return (mSafeInsets.hashCode() * 48271 + mBounds.hashCode()) * 48271 + mWaterfallInsets.hashCode();
}","{
    int result = 0;
    result = 48271 * result + mSafeInsets.hashCode();
    result = 48271 * result + mBounds.hashCode();
    result = 48271 * result + mWaterfallInsets.hashCode();
    result = 48271 * result + mCutoutPathParserInfo.hashCode();
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The logic for calculating the hashCode has been slightly refactored although the mathematical operations essentially yield the same result, but with the addition of mCutoutPathParserInfo.hashCode() in the late version, which makes a functional change to the code. Therefore, the code change types are 1 and 4.","Since mCutoutPathParserInfo.hashCode() is added in the late version, the resulting hash code value may be different compared to the early version. Therefore, the difference in return value indicates a potential Compatibility Issue, type 1."
482,<android.os.Environment: boolean isExternalStorageLegacy(File)>,30,31,<android.os.Environment: boolean isExternalStorageLegacy(File)>,<android.os.Environment: boolean isExternalStorageLegacy(File)>,0,"{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    // Isolated processes and Instant apps are never allowed to be in scoped storage
    if (Process.isIsolated(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    boolean defaultScopedStorage = Compatibility.isChangeEnabled(DEFAULT_SCOPED_STORAGE);
    boolean forceEnableScopedStorage = Compatibility.isChangeEnabled(FORCE_ENABLE_SCOPED_STORAGE);
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageEnforced(defaultScopedStorage, forceEnableScopedStorage)) {
        return false;
    }
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageDisabled(defaultScopedStorage, forceEnableScopedStorage)) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    return appOps.checkOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, context.getOpPackageName()) == AppOpsManager.MODE_ALLOWED;
}","{
    final Context context = AppGlobals.getInitialApplication();
    final int uid = context.getApplicationInfo().uid;
    // Isolated processes and Instant apps are never allowed to be in scoped storage
    if (Process.isIsolated(uid)) {
        return false;
    }
    final PackageManager packageManager = context.getPackageManager();
    if (packageManager.isInstantApp()) {
        return false;
    }
    boolean defaultScopedStorage = Compatibility.isChangeEnabled(DEFAULT_SCOPED_STORAGE);
    boolean forceEnableScopedStorage = Compatibility.isChangeEnabled(FORCE_ENABLE_SCOPED_STORAGE);
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageEnforced(defaultScopedStorage, forceEnableScopedStorage)) {
        return false;
    }
    // Note: does not require packagename/uid as this is directly called from an app process
    if (isScopedStorageDisabled(defaultScopedStorage, forceEnableScopedStorage)) {
        return true;
    }
    final AppOpsManager appOps = context.getSystemService(AppOpsManager.class);
    final String opPackageName = context.getOpPackageName();
    if (appOps.noteOpNoThrow(AppOpsManager.OP_LEGACY_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED) {
        return true;
    }
    // ""--no-isolated-storage"" flag.
    return appOps.noteOpNoThrow(AppOpsManager.OP_NO_ISOLATED_STORAGE, uid, opPackageName) == AppOpsManager.MODE_ALLOWED;
}",1,"/**
 * Returns whether the shared/external storage media is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed, target sdk and other
 * factors.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
","/**
 * Returns whether the shared/external storage media is a
 * legacy view that includes files not owned by the app.
 * <p>
 * This value may be different from the value requested by
 * {@code requestLegacyExternalStorage} in the app's manifest, since an app
 * may inherit its legacy state based on when it was first installed, target sdk and other
 * factors.
 * <p>
 * Non-legacy apps can continue to discover and read media belonging to
 * other apps via {@link android.provider.MediaStore}.
 *
 * @throws IllegalArgumentException if the path is not a valid storage
 * device.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version method introduces a new check and return statement that uses 'appOps.noteOpNoThrow' with a new operation 'AppOpsManager.OP_NO_ISOLATED_STORAGE'. Besides, the call to `appOps.checkOpNoThrow` has been replaced with `appOps.noteOpNoThrow` and the usage has been modified to store the package name in a separate variable. Thus, this is a control dependency change (for the addition of a new 'if' condition) and other statement changed (for the change of the method call and introduction of a new variable). ","The addition of the new 'if' condition at the end of the late version, and the change in the method from `checkOpNoThrow` to `noteOpNoThrow` introduces potential new behaviors. Also, the added return statement may produce a different return value for cases when 'OP_NO_ISOLATED_STORAGE' is allowed, hence, leading to a compatibility issue of type 1 (different return values) due to the new condition and behavior."
483,"<android.content.pm.ApplicationInfo: CharSequence getCategoryTitle(Context,int)>",30,31,"<android.content.pm.ApplicationInfo: CharSequence getCategoryTitle(Context,int)>","<android.content.pm.ApplicationInfo: CharSequence getCategoryTitle(Context,int)>",0,"{
    switch(category) {
        case ApplicationInfo.CATEGORY_GAME:
            return context.getText(com.android.internal.R.string.app_category_game);
        case ApplicationInfo.CATEGORY_AUDIO:
            return context.getText(com.android.internal.R.string.app_category_audio);
        case ApplicationInfo.CATEGORY_VIDEO:
            return context.getText(com.android.internal.R.string.app_category_video);
        case ApplicationInfo.CATEGORY_IMAGE:
            return context.getText(com.android.internal.R.string.app_category_image);
        case ApplicationInfo.CATEGORY_SOCIAL:
            return context.getText(com.android.internal.R.string.app_category_social);
        case ApplicationInfo.CATEGORY_NEWS:
            return context.getText(com.android.internal.R.string.app_category_news);
        case ApplicationInfo.CATEGORY_MAPS:
            return context.getText(com.android.internal.R.string.app_category_maps);
        case ApplicationInfo.CATEGORY_PRODUCTIVITY:
            return context.getText(com.android.internal.R.string.app_category_productivity);
        default:
            return null;
    }
}","{
    switch(category) {
        case ApplicationInfo.CATEGORY_GAME:
            return context.getText(com.android.internal.R.string.app_category_game);
        case ApplicationInfo.CATEGORY_AUDIO:
            return context.getText(com.android.internal.R.string.app_category_audio);
        case ApplicationInfo.CATEGORY_VIDEO:
            return context.getText(com.android.internal.R.string.app_category_video);
        case ApplicationInfo.CATEGORY_IMAGE:
            return context.getText(com.android.internal.R.string.app_category_image);
        case ApplicationInfo.CATEGORY_SOCIAL:
            return context.getText(com.android.internal.R.string.app_category_social);
        case ApplicationInfo.CATEGORY_NEWS:
            return context.getText(com.android.internal.R.string.app_category_news);
        case ApplicationInfo.CATEGORY_MAPS:
            return context.getText(com.android.internal.R.string.app_category_maps);
        case ApplicationInfo.CATEGORY_PRODUCTIVITY:
            return context.getText(com.android.internal.R.string.app_category_productivity);
        case ApplicationInfo.CATEGORY_ACCESSIBILITY:
            return context.getText(com.android.internal.R.string.app_category_accessibility);
        default:
            return null;
    }
}",1,"/**
 * Return a concise, localized title for the given
 * {@link ApplicationInfo#category} value, or {@code null} for unknown
 * values such as {@link #CATEGORY_UNDEFINED}.
 *
 * @see #category
 */
","/**
 * Return a concise, localized title for the given
 * {@link ApplicationInfo#category} value, or {@code null} for unknown
 * values such as {@link #CATEGORY_UNDEFINED}.
 *
 * @see #category
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"A new `case` condition has been added to the `switch` statement for `ApplicationInfo.CATEGORY_ACCESSIBILITY`, so the change type is 3.","The introduction of a new `case` condition to handle `ApplicationInfo.CATEGORY_ACCESSIBILITY` does not affect any of the existing case conditions or the default behavior. It simply adds support for a new category, so it does not introduce a compatibility issue for the existing categories. Hence, there is no Compatibility Issue."
485,<android.app.Notification.Style: RemoteViews getStandardView(int)>,30,31,<android.app.Notification.Style: RemoteViews getStandardView(int)>,<android.app.Notification.Style: RemoteViews getStandardView(int)>,0,"{
    StandardTemplateParams p = mBuilder.mParams.reset().fillTextsFrom(mBuilder);
    return getStandardView(layoutId, p, null);
}","{
    // TODO(jeffdq): set the view type based on the layout resource?
    StandardTemplateParams p = mBuilder.mParams.reset().viewType(StandardTemplateParams.VIEW_TYPE_UNSPECIFIED).fillTextsFrom(mBuilder);
    return getStandardView(layoutId, p, null);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The late version of the method includes a new method call `.viewType(StandardTemplateParams.VIEW_TYPE_UNSPECIFIED)` on the object `p` before calling `.fillTextsFrom(mBuilder)`, which is an example of another statement being changed, and it also suggests there's a change in the behavior of dependent API `StandardTemplateParams.reset()`. So the change is of type 4,5.","Since a new method call that sets the view type has been added in the invocation chain, this change could potentially affect the behavior of `getStandardView(int)`. Specifically, the view type influences what is returned, which is why a CI is detected due to potentially different return values. The CI type is 1."
486,<android.view.DragEvent: DragEvent obtain()>,30,31,<android.view.DragEvent: DragEvent obtain()>,<android.view.DragEvent: DragEvent obtain()>,0,"{
    return DragEvent.obtain(0, 0f, 0f, null, null, null, null, false);
}","{
    return DragEvent.obtain(0, 0f, 0f, 0f, 0f, null, null, null, null, null, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement calls a different version of the obtain method with additional parameters (two more floating-point values), so the code change type is 1 for the return statement changed, and 5 for the dependent API changed.","Since the return statement now invokes a method with more parameters, it could potentially return a different value (specifically, a DragEvent with the additional float fields initialized), hence the CI type is 1."
487,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setAllowedAuthenticators(int)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setAllowedAuthenticators(int)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setAllowedAuthenticators(int)>,0,"{
    mBundle.putInt(KEY_AUTHENTICATORS_ALLOWED, authenticators);
    return this;
}","{
    mPromptInfo.setAuthenticators(authenticators);
    return this;
}",1,"/**
 * Optional: Specifies the type(s) of authenticators that may be invoked by
 * {@link BiometricPrompt} to authenticate the user. Available authenticator types are
 * defined in {@link Authenticators} and can be combined via bitwise OR. Defaults to:
 * <ul>
 * <li>{@link Authenticators#BIOMETRIC_WEAK} for non-crypto authentication, or</li>
 * <li>{@link Authenticators#BIOMETRIC_STRONG} for crypto-based authentication.</li>
 * </ul>
 *
 * <p>If this method is used and no authenticator of any of the specified types is available
 * at the time <code>BiometricPrompt#authenticate(...)</code> is called, authentication will
 * be canceled and {@link AuthenticationCallback#onAuthenticationError(int, CharSequence)}
 * will be invoked with an appropriate error code.
 *
 * <p>This method should be preferred over {@link #setDeviceCredentialAllowed(boolean)} and
 * overrides the latter if both are used. Using this method to enable device credential
 * authentication (with {@link Authenticators#DEVICE_CREDENTIAL}) will replace the negative
 * button on the prompt, making it an error to also call
 * {@link #setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 *
 * <p>If unlocking cryptographic operation(s), it is the application's responsibility to
 * request authentication with the proper set of authenticators (e.g. match the
 * authenticators specified during key generation).
 *
 * @see KeyGenParameterSpec.Builder#setUserAuthenticationParameters(int, int)
 * @see KeyProperties#AUTH_BIOMETRIC_STRONG
 * @see KeyProperties#AUTH_DEVICE_CREDENTIAL
 *
 * @param authenticators A bit field representing all valid authenticator types that may be
 * invoked by the prompt.
 * @return This builder.
 */
","/**
 * Optional: Specifies the type(s) of authenticators that may be invoked by
 * {@link BiometricPrompt} to authenticate the user. Available authenticator types are
 * defined in {@link Authenticators} and can be combined via bitwise OR. Defaults to:
 * <ul>
 * <li>{@link Authenticators#BIOMETRIC_WEAK} for non-crypto authentication, or</li>
 * <li>{@link Authenticators#BIOMETRIC_STRONG} for crypto-based authentication.</li>
 * </ul>
 *
 * <p>If this method is used and no authenticator of any of the specified types is available
 * at the time <code>BiometricPrompt#authenticate(...)</code> is called, authentication will
 * be canceled and {@link AuthenticationCallback#onAuthenticationError(int, CharSequence)}
 * will be invoked with an appropriate error code.
 *
 * <p>This method should be preferred over {@link #setDeviceCredentialAllowed(boolean)} and
 * overrides the latter if both are used. Using this method to enable device credential
 * authentication (with {@link Authenticators#DEVICE_CREDENTIAL}) will replace the negative
 * button on the prompt, making it an error to also call
 * {@link #setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 *
 * <p>If unlocking cryptographic operation(s), it is the application's responsibility to
 * request authentication with the proper set of authenticators (e.g. match the
 * authenticators specified during key generation).
 *
 * @see android.security.keystore.KeyGenParameterSpec.Builder
 * @see KeyProperties#AUTH_BIOMETRIC_STRONG
 * @see KeyProperties#AUTH_DEVICE_CREDENTIAL
 *
 * @param authenticators A bit field representing all valid authenticator types that may be
 * invoked by the prompt.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to set the authenticators has changed from mBundle.putInt(KEY_AUTHENTICATORS_ALLOWED, authenticators) to mPromptInfo.setAuthenticators(authenticators), which is a type 4 change (Other statement changed). Additionally, since mPromptInfo is presumably an object whose method is being called instead of adding to a Bundle, this also reflects a type 5 change (Dependent API changed).","There is no CI issue, as the method still fulfills the same contract of setting the allowed authenticators and returns the same object with 'return this', ensuring that the purpose of the API remains consistent from the caller's perspective. The return type and exceptions thrown (none in both cases) remain the same, so the likelihood of a different behavior in terms of API usage is minimal. The internal implementation details have changed, which doesn't affect the API contract."
488,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,30,31,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = getDisplayId();
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo(), mResources.getLoaders()));
    context.mIsUiContext = isUiContext() || isOuterUiContext();
    return context;
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    if (mForceDisplayOverrideInResources) {
        // Ensure the resources display metrics are adjusted to match the display this context
        // is based on.
        Configuration displayAdjustedConfig = new Configuration();
        displayAdjustedConfig.setTo(mDisplay.getDisplayAdjustments().getConfiguration(), ActivityInfo.CONFIG_WINDOW_CONFIGURATION, 1);
        displayAdjustedConfig.updateFrom(overrideConfiguration);
        overrideConfiguration = displayAdjustedConfig;
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    context.mIsConfigurationBasedContext = true;
    final int displayId = getDisplayId();
    final Integer overrideDisplayId = mForceDisplayOverrideInResources ? displayId : null;
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, overrideDisplayId, overrideConfiguration, getDisplayAdjustments(displayId).getCompatibilityInfo(), mResources.getLoaders()));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The new block of code introduces a control structure (if statement) that alters the value of 'overrideConfiguration', other assignments and calls statements have changed, and a new variable 'overrideDisplayId' is introduced, which changes the parameter used in 'createResources' method. So, the code change type is 3 (due to control structure change), 4 (due to new assignments and method calls), and 5 (due to changes in the method parameters).","These changes could lead to a different return value, as 'overrideConfiguration' can be altered, and 'createResources' method is no longer called with the same parameters, potentially affecting the resources configuration of the resulting context. Thus, the CI type is 1."
489,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceFormat(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceFormat(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: int getSurfaceFormat(Surface)>,0,"{
    try {
        return LegacyCameraDevice.detectSurfaceType(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException(""Surface was abandoned"", e);
    }
}","{
    checkNotNull(surface);
    int surfaceType = nativeDetectSurfaceType(surface);
    if (surfaceType == BAD_VALUE)
        throw new IllegalArgumentException(""Surface was abandoned"");
    // ImageFormat.PRIVATE. b/9487482
    if ((surfaceType >= PixelFormat.RGBA_8888 && surfaceType <= BGRA_8888)) {
        surfaceType = ImageFormat.PRIVATE;
    }
    return surfaceType;
}",1,"/**
 * Get the Surface format.
 *
 * @param surface The surface to be queried for format.
 * @return format of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
","/**
 * Get the Surface format.
 *
 * @param surface The surface to be queried for format.
 * @return format of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The return statement has changed from calling LegacyCameraDevice.detectSurfaceType() to the usage of a new local variable 'surfaceType' with additional control logic. An exception handling statement has been removed (catching BufferQueueAbandonedException), and new exception handling logic has been added for the check when 'surfaceType' equals BAD_VALUE. Additionally, a new check has been introduced at the start (checkNotNull) and some other statements that affect the final surfaceType value. Because an internal method has changed to the native method nativeDetectSurfaceType(surface), that is also classified as a dependent API changed. Therefore, the change types are 1,2,4,5.","The removal of the BufferQueueAbandonedException catch block with the addition of a new IllegalArgumentException throw statement for a different condition changes how exceptions are handled. Furthermore, the new logic transforms the return value from the direct result of a single method call to a potentially altered value after additional checks and conversions. This will lead to different return values or types and different exception handlings, indicating a Compatibility Issue of both types 1 and 2."
490,<android.app.Activity: boolean releaseInstance()>,30,31,<android.app.Activity: boolean releaseInstance()>,<android.app.Activity: boolean releaseInstance()>,0,"{
    try {
        return ActivityTaskManager.getService().releaseActivityInstance(mToken);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    return ActivityClient.getInstance().releaseActivityInstance(mToken);
}",1,"/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
","/**
 * Ask that the local app instance of this activity be released to free up its memory.
 * This is asking for the activity to be destroyed, but does <b>not</b> finish the activity --
 * a new instance of the activity will later be re-created if needed due to the user
 * navigating back to it.
 *
 * @return Returns true if the activity was in a state that it has started the process
 * of destroying its current instance; returns false if for any reason this could not
 * be done: it is currently visible to the user, it is already being destroyed, it is
 * being finished, it hasn't yet saved its state, etc.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ActivityTaskManager.getService().releaseActivityInstance(mToken) to ActivityClient.getInstance().releaseActivityInstance(mToken) and it no longer includes the try-catch block for RemoteException; hence, the change types are 1 for the return statement and 5 for the method it depends on.","The new implementation could potentially return a different value due to the change in which object's method is called for releasing the activity instance. The removal of the catch block for RemoteException also changes the exception handling behavior of the method. Therefore, the CI type is 1."
492,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,30,31,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mIWallpaperEngine.mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mIWallpaperEngine.mDisplay;
    mDisplayContext = createDisplayContext(mDisplay);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession();
    mWindow.setSession(mSession);
    mLayout.packageName = getPackageName();
    mIWallpaperEngine.mDisplayManager.registerDisplayListener(mDisplayListener, mCaller.getHandler());
    mDisplay = mIWallpaperEngine.mDisplay;
    // Use window context of TYPE_WALLPAPER so client can access UI resources correctly.
    mDisplayContext = createDisplayContext(mDisplay).createWindowContext(TYPE_WALLPAPER, null);
    mWallpaperDimAmount = mDisplayContext.getResources().getFloat(com.android.internal.R.dimen.config_wallpaperDimAmount);
    mDisplayState = mDisplay.getState();
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are two new lines added which set `mWallpaperDimAmount` and modify how `mDisplayContext` is created, but these are not return statements or exception handling, so the code change type is 4.","The modifications do not affect how exceptions are thrown or what values are returned by methods; they merely set a new field and change the context in which some operations are performed. Without additional information suggesting that these changes would lead to different return values or exceptions being thrown, it appears there is no compatibility issue, and therefore the CI type is 0."
493,<android.inputmethodservice.InlineSuggestionSession: void invalidate()>,30,31,<android.inputmethodservice.InlineSuggestionSession: void invalidate()>,<android.inputmethodservice.InlineSuggestionSession: void invalidate()>,0,"{
    try {
        mCallback.onInlineSuggestionsSessionInvalidated();
    } catch (RemoteException e) {
        Log.w(TAG, ""onInlineSuggestionsSessionInvalidated() remote exception:"" + e);
    }
    if (mResponseCallback != null) {
        consumeInlineSuggestionsResponse(EMPTY_RESPONSE);
        mResponseCallback.invalidate();
        mResponseCallback = null;
    }
}","{
    try {
        mCallback.onInlineSuggestionsSessionInvalidated();
    } catch (RemoteException e) {
        Log.w(TAG, ""onInlineSuggestionsSessionInvalidated() remote exception"", e);
    }
    if (mResponseCallback != null) {
        consumeInlineSuggestionsResponse(EMPTY_RESPONSE);
        mResponseCallback.invalidate();
        mResponseCallback = null;
    }
}",1,"/**
 * Invalidates the current session so it doesn't process any further {@link
 * InlineSuggestionsResponse} from Autofill.
 *
 * <p> This method should be called when the session is de-referenced from the {@link
 * InlineSuggestionSessionController}.
 */
","/**
 * Invalidates the current session so it doesn't process any further {@link
 * InlineSuggestionsResponse} from Autofill.
 *
 * <p> This method should be called when the session is de-referenced from the {@link
 * InlineSuggestionSessionController}.
 */
",-1,[@MainThread],[@MainThread],-1,-1,-1,-1,-1,-1,4,0,"The change is in a Log message string where ""+"" operator and string concatenation has been removed. This is categorized as ""Other statement changed"" which is type 4.","There is no Compatibility Issue here as the change in a log message has no effect on the method's functionality, output (return value or type), or exception throwing behavior. The API's behavior remains consistent across versions despite the change."
494,<android.app.Activity: int getTaskId()>,30,31,<android.app.Activity: int getTaskId()>,<android.app.Activity: int getTaskId()>,0,"{
    try {
        return ActivityTaskManager.getService().getTaskForActivity(mToken, false);
    } catch (RemoteException e) {
        return -1;
    }
}","{
    return ActivityClient.getInstance().getTaskForActivity(mToken, false);
}",1,"/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
","/**
 * Return the identifier of the task this activity is in.  This identifier
 * will remain the same for the lifetime of the activity.
 *
 * @return Task identifier, an opaque integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version is calling `ActivityTaskManager.getService().getTaskForActivity(mToken, false)`, which is handled within a try-catch block for `RemoteException`. In contrast, the late version calls `ActivityClient.getInstance().getTaskForActivity(mToken, false)` without any exception handling. The change to the return statement and removal of the exception handling indicate that the calling API or method has been changed. Thus, the code change type is both 1 (Return statement changed) and 5 (Dependent API changed).","The Compatibility Issue arises because the API in the late version potentially returns a different value. The original version might have returned -1 in case of a RemoteException, which the new version doesn't handle explicitly, it also potentially raises an unhandled exception if `getTaskForActivity` was to throw an `RemoteException` that was caught previously. Thus, we have a CI caused by potential different return values or types (type 1) and potential different exception handlings (type 2)."
495,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withWindowCrop(Rect)>,30,31,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withWindowCrop(Rect)>,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withWindowCrop(Rect)>,0,"{
    this.windowCrop = windowCrop;
    flags |= FLAG_WINDOW_CROP;
    return this;
}","{
    this.windowCrop = new Rect(windowCrop);
    flags |= FLAG_WINDOW_CROP;
    return this;
}",1,"/**
 * @param windowCrop The window crop to apply to the surface.
 * @return this Builder
 */
","/**
 * @param windowCrop The window crop to apply to the surface.
 * @return this Builder
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement to `this.windowCrop` has changed. It now creates a new `Rect` object instead of directly assigning the input `windowCrop`, resulting in a defensive copy.","The behavior of the API has not changed from a caller's perspective because the method still accepts a `Rect` object and sets it successfully to `this.windowCrop`. It does not affect the return value or the function's control flow, thus causing no Compatibility Issue."
496,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",30,31,"<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean showSoftInput(View,int,ResultReceiver)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        return fallbackImm.showSoftInput(view, flags, resultReceiver);
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return false;
        }
        try {
            return mService.showSoftInput(mClient, view.getWindowToken(), flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return showSoftInput(view, flags, resultReceiver, SoftInputShowHideReason.SHOW_SOFT_INPUT);
}",1,"/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Explicitly request that the current input method's soft input area be
 * shown to the user, if needed.  Call this if the user interacts with
 * your view in such a way that they have expressed they would like to
 * start performing input into it.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param view The currently focused view, which would like to receive
 * soft keyboard input.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #SHOW_IMPLICIT} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has changed. The early version includes control flow, exception handling, and calls multiple methods internally, whereas the late version simply calls another method with an added argument, SoftInputShowHideReason.SHOW_SOFT_INPUT. The code change is regarding both return statements and a dependent API, so the change types are 1 and 5.","The change in the method's body alters the behavior significantly. The late version of the method no longer conducts the same checks and may bypass any control flows that were present in the early version. As a result, the method could return different values than before, causing a Compatibility Issue of type 1."
498,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",30,31,"<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>","<android.app.assist.AssistStructure: void dump(String,ViewNode,boolean)>",0,"{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
        Log.i(TAG, prefix + ""  Resource id: "" + node.getHintIdEntry());
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""  Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", important="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}","{
    Log.i(TAG, prefix + ""View ["" + node.getLeft() + "","" + node.getTop() + "" "" + node.getWidth() + ""x"" + node.getHeight() + ""]"" + "" "" + node.getClassName());
    int id = node.getId();
    if (id != 0) {
        StringBuilder sb = new StringBuilder();
        sb.append(prefix);
        sb.append(""  ID: #"");
        sb.append(Integer.toHexString(id));
        String entry = node.getIdEntry();
        if (entry != null) {
            String type = node.getIdType();
            String pkg = node.getIdPackage();
            sb.append("" "");
            sb.append(pkg);
            sb.append("":"");
            sb.append(type);
            sb.append(""/"");
            sb.append(entry);
        }
        Log.i(TAG, sb.toString());
    }
    int scrollX = node.getScrollX();
    int scrollY = node.getScrollY();
    if (scrollX != 0 || scrollY != 0) {
        Log.i(TAG, prefix + ""  Scroll: "" + scrollX + "","" + scrollY);
    }
    Matrix matrix = node.getTransformation();
    if (matrix != null) {
        Log.i(TAG, prefix + ""  Transformation: "" + matrix);
    }
    float elevation = node.getElevation();
    if (elevation != 0) {
        Log.i(TAG, prefix + ""  Elevation: "" + elevation);
    }
    float alpha = node.getAlpha();
    if (alpha != 0) {
        Log.i(TAG, prefix + ""  Alpha: "" + elevation);
    }
    CharSequence contentDescription = node.getContentDescription();
    if (contentDescription != null) {
        Log.i(TAG, prefix + ""  Content description: "" + contentDescription);
    }
    CharSequence text = node.getText();
    if (text != null) {
        final String safeText = node.isSanitized() || showSensitive ? text.toString() : ""REDACTED["" + text.length() + "" chars]"";
        Log.i(TAG, prefix + ""  Text (sel "" + node.getTextSelectionStart() + ""-"" + node.getTextSelectionEnd() + ""): "" + safeText);
        Log.i(TAG, prefix + ""  Text size: "" + node.getTextSize() + "" , style: #"" + node.getTextStyle());
        Log.i(TAG, prefix + ""  Text color fg: #"" + Integer.toHexString(node.getTextColor()) + "", bg: #"" + Integer.toHexString(node.getTextBackgroundColor()));
        Log.i(TAG, prefix + ""  Input type: "" + node.getInputType());
        Log.i(TAG, prefix + ""  Resource id: "" + node.getTextIdEntry());
    }
    String webDomain = node.getWebDomain();
    if (webDomain != null) {
        Log.i(TAG, prefix + ""  Web domain: "" + webDomain);
    }
    HtmlInfo htmlInfo = node.getHtmlInfo();
    if (htmlInfo != null) {
        Log.i(TAG, prefix + ""  HtmlInfo: tag="" + htmlInfo.getTag() + "", attr="" + htmlInfo.getAttributes());
    }
    LocaleList localeList = node.getLocaleList();
    if (localeList != null) {
        Log.i(TAG, prefix + ""  LocaleList: "" + localeList);
    }
    String[] mimeTypes = node.getReceiveContentMimeTypes();
    if (mimeTypes != null) {
        Log.i(TAG, prefix + ""  MIME types: "" + Arrays.toString(mimeTypes));
    }
    String hint = node.getHint();
    if (hint != null) {
        Log.i(TAG, prefix + ""  Hint: "" + hint);
        Log.i(TAG, prefix + ""  Resource id: "" + node.getHintIdEntry());
    }
    Bundle extras = node.getExtras();
    if (extras != null) {
        Log.i(TAG, prefix + ""  Extras: "" + extras);
    }
    if (node.isAssistBlocked()) {
        Log.i(TAG, prefix + ""  BLOCKED"");
    }
    AutofillId autofillId = node.getAutofillId();
    if (autofillId == null) {
        Log.i(TAG, prefix + "" NO autofill ID"");
    } else {
        Log.i(TAG, prefix + ""  Autofill info: id= "" + autofillId + "", type="" + node.getAutofillType() + "", options="" + Arrays.toString(node.getAutofillOptions()) + "", hints="" + Arrays.toString(node.getAutofillHints()) + "", value="" + node.getAutofillValue() + "", sanitized="" + node.isSanitized() + "", important="" + node.getImportantForAutofill());
    }
    final int NCHILDREN = node.getChildCount();
    if (NCHILDREN > 0) {
        Log.i(TAG, prefix + ""  Children:"");
        String cprefix = prefix + ""    "";
        for (int i = 0; i < NCHILDREN; i++) {
            ViewNode cnode = node.getChildAt(i);
            dump(cprefix, cnode, showSensitive);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
499,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,30,31,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,<android.app.UiAutomation: void clearWindowAnimationFrameStats()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Clearing window animation frame stats"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.clearWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re);
    }
}","{
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Clearing window animation frame stats"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.clearWindowAnimationFrameStats();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error clearing window animation frame stats!"", re);
    }
}",1,"/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
","/**
 * Clears the window animation rendering statistics. These statistics contain
 * information about the most recently rendered window animation frames, i.e.
 * for window transition animations.
 *
 * @see android.view.WindowAnimationFrameStats
 * @see #getWindowAnimationFrameStats()
 * @see android.R.styleable#WindowAnimation
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The synchronized block with the method call throwIfNotConnectedLocked() has been removed, which constitutes a control dependency change.","The removal of the synchronized block with the method throwIfNotConnectedLocked() does not affect the return type or exception thrown by the clearWindowAnimationFrameStats() method, as the method does not have a return type (void) and the RemoteException handling remains the same. Thus, there is no Compatibility Issue."
500,<android.os.BugreportManager.DumpstateListener: void onError(int)>,30,31,<android.os.BugreportManager.DumpstateListener: void onError(int)>,<android.os.BugreportManager.DumpstateListener: void onError(int)>,0,"{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onError(errorCode);
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}","{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onError(errorCode));
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no actual change in the behavior of the implementation, only a syntactic change (removal of braces around the lambda's body), which does not affect the outcome.","Since there is no change in the logic or the control flow, there is no Compatibility Issue between the two versions."
501,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",30,31,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeType, ""mimeType"");
    try {
        if (mWrapped != null)
            return mWrapped.openTypedAssetFile(uri, mimeType, opts, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, mAttributionTag, uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength(), fd.getExtras());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mimeType, ""mimeType"");
    try {
        if (mWrapped != null)
            return mWrapped.openTypedAssetFile(uri, mimeType, opts, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            fd = unstableProvider.openTypedAssetFile(mContext.getAttributionSource(), uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mContext.getAttributionSource(), uri, mimeType, opts, remoteCancellationSignal);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        unstableProvider = null;
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength(), fd.getExtras());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider or {@code null} if the provider recently crashed.
 * Note that this may be a pipe, meaning you can't seek in it.  The only seek you
 * should do is if the AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *&#47;*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @param cancellationSignal A signal to cancel the operation in progress,
 * or null if none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider or {@code null} if the provider recently crashed.
 * Note that this may be a pipe, meaning you can't seek in it.  The only seek you
 * should do is if the AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
502,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",30,31,"<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>","<android.os.image.DynamicSystemClient.DynSystemServiceConnection: void onServiceConnected(ComponentName,IBinder)>",0,"{
    Slog.v(TAG, ""DynSystemService connected"");
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        if (mExecutor != null) {
            mExecutor.execute(() -> {
                mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
            });
        } else {
            mListener.onStatusChanged(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
        }
    }
}","{
    Slog.v(TAG, ""onServiceConnected: "" + className);
    mService = new Messenger(service);
    try {
        Message msg = Message.obtain(null, MSG_REGISTER_LISTENER);
        msg.replyTo = mMessenger;
        mService.send(msg);
    } catch (RemoteException e) {
        Slog.e(TAG, ""Unable to get status from installation service"");
        notifyOnStatusChangedListener(STATUS_UNKNOWN, CAUSE_ERROR_IPC, 0, e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The difference between Early_Implementation and Late_Implementation is the log message and the extraction of the catch block content into the notifyOnStatusChangedListener method. Since the behavior of the catch block remains the same (it still calls the same method on the mListener with the same parameters), only other statements are changed. Therefore, the code change type is 4.","There are no Compatibility Issues caused by these changes because the extracted method (notifyOnStatusChangedListener) still performs the same operations that were formerly directly in the catch block. The behavior observed by the user of this API remains consistent. Thus, CI type is 0."
503,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",30,31,"<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>","<android.hardware.biometrics.BiometricPrompt: void authenticate(CryptoObject,CancellationSignal,Executor,AuthenticationCallback)>",0,"{
    if (crypto == null) {
        throw new IllegalArgumentException(""Must supply a crypto object"");
    }
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    // Disallow explicitly setting any non-Strong biometric authenticator types.
    @Authenticators.Types final int authenticators = mBundle.getInt(KEY_AUTHENTICATORS_ALLOWED, Authenticators.BIOMETRIC_STRONG);
    final int biometricStrength = authenticators & Authenticators.BIOMETRIC_WEAK;
    if ((biometricStrength & ~Authenticators.BIOMETRIC_STRONG) != 0) {
        throw new IllegalArgumentException(""Only Strong biometrics supported with crypto"");
    }
    authenticateInternal(crypto, cancel, executor, callback, mContext.getUserId());
}","{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_PROMPT_AUTHENTICATE_INVOKED, true, /* isCrypto */
    mPromptInfo.isConfirmationRequested(), mPromptInfo.isDeviceCredentialAllowed(), mPromptInfo.getAuthenticators() != Authenticators.EMPTY_SET, mPromptInfo.getAuthenticators());
    if (crypto == null) {
        throw new IllegalArgumentException(""Must supply a crypto object"");
    }
    if (cancel == null) {
        throw new IllegalArgumentException(""Must supply a cancellation signal"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Must supply an executor"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""Must supply a callback"");
    }
    // Disallow explicitly setting any non-Strong biometric authenticator types.
    @Authenticators.Types int authenticators = mPromptInfo.getAuthenticators();
    if (authenticators == Authenticators.EMPTY_SET) {
        authenticators = Authenticators.BIOMETRIC_STRONG;
    }
    final int biometricStrength = authenticators & Authenticators.BIOMETRIC_WEAK;
    if ((biometricStrength & ~Authenticators.BIOMETRIC_STRONG) != 0) {
        throw new IllegalArgumentException(""Only Strong biometrics supported with crypto"");
    }
    authenticateInternal(crypto, cancel, executor, callback, mContext.getUserId());
}",1,"/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate(CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * <p>Per the Android CDD, only biometric authenticators that meet or exceed the requirements
 * for <strong>Strong</strong> are permitted to integrate with Keystore to perform related
 * cryptographic operations. Therefore, it is an error to call this method after explicitly
 * calling {@link Builder#setAllowedAuthenticators(int)} with any biometric strength other than
 * {@link Authenticators#BIOMETRIC_STRONG}.
 *
 * @throws IllegalArgumentException If any argument is null, or if the allowed biometric
 * authenticator strength is explicitly set to {@link Authenticators#BIOMETRIC_WEAK}. Prior to
 * {@link android.os.Build.VERSION_CODES#R}, this exception is also thrown if
 * {@link Builder#setDeviceCredentialAllowed(boolean)} was explicitly set to true.
 *
 * @param crypto A cryptographic operation to be unlocked after successful authentication.
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
","/**
 * This call warms up the biometric hardware, displays a system-provided dialog, and starts
 * scanning for a biometric. It terminates when {@link
 * AuthenticationCallback#onAuthenticationError(int, CharSequence)} is called, when {@link
 * AuthenticationCallback#onAuthenticationSucceeded( AuthenticationResult)}, or when the user
 * dismisses the system-provided dialog, at which point the crypto object becomes invalid. This
 * operation can be canceled by using the provided cancel object. The application will receive
 * authentication errors through {@link AuthenticationCallback}, and button events through the
 * corresponding callback set in {@link Builder#setNegativeButton(CharSequence, Executor,
 * DialogInterface.OnClickListener)}. It is safe to reuse the {@link BiometricPrompt} object,
 * and calling {@link BiometricPrompt#authenticate(CancellationSignal, Executor,
 * AuthenticationCallback)} while an existing authentication attempt is occurring will stop the
 * previous client and start a new authentication. The interrupted client will receive a
 * cancelled notification through {@link AuthenticationCallback#onAuthenticationError(int,
 * CharSequence)}.
 *
 * <p>Note: Applications generally should not cancel and start authentication in quick
 * succession. For example, to properly handle authentication across configuration changes, it's
 * recommended to use BiometricPrompt in a fragment with setRetainInstance(true). By doing so,
 * the application will not need to cancel/restart authentication during the configuration
 * change.
 *
 * <p>Per the Android CDD, only biometric authenticators that meet or exceed the requirements
 * for <strong>Strong</strong> are permitted to integrate with Keystore to perform related
 * cryptographic operations. Therefore, it is an error to call this method after explicitly
 * calling {@link Builder#setAllowedAuthenticators(int)} with any biometric strength other than
 * {@link Authenticators#BIOMETRIC_STRONG}.
 *
 * @throws IllegalArgumentException If any argument is null, or if the allowed biometric
 * authenticator strength is explicitly set to {@link Authenticators#BIOMETRIC_WEAK}. Prior to
 * {@link android.os.Build.VERSION_CODES#R}, this exception is also thrown if
 * {@link Builder#setDeviceCredentialAllowed(boolean)} was explicitly set to true.
 *
 * @param crypto A cryptographic operation to be unlocked after successful authentication.
 * @param cancel An object that can be used to cancel authentication.
 * @param executor An executor to handle callback events.
 * @param callback An object to receive authentication events.
 */
",-1,[@RequiresPermission(USE_BIOMETRIC)],[@RequiresPermission(USE_BIOMETRIC)],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a new statement introduced to record logging information which does not affect the method's behavior, so the change type is 4. Besides, the logic to determine the 'authenticators' variable has been adjusted where `mBundle.getInt` is replaced with `mPromptInfo.getAuthenticators()`. Additionally, the variable `authenticators` is no longer annotated with `@Authenticators.Types` in the later version, which is considered a dependent API changed, hence change type 5 is also applicable.","These changes will not lead to compatibility issues as they do not affect the external behavior of the method. The logging statement does not change execution flow or outcomes, and the updated logic for determining the `authenticators` variable aligns with the prior version's intent. The permission annotation has not changed, and is not part of the implementation logic. Therefore, no compatibility issue arises from these changes."
504,<android.view.WindowInsets: int hashCode()>,30,31,<android.view.WindowInsets: int hashCode()>,<android.view.WindowInsets: int hashCode()>,0,"{
    return Objects.hash(Arrays.hashCode(mTypeInsetsMap), Arrays.hashCode(mTypeMaxInsetsMap), Arrays.hashCode(mTypeVisibilityMap), mIsRound, mDisplayCutout, mAlwaysConsumeSystemBars, mSystemWindowInsetsConsumed, mStableInsetsConsumed, mDisplayCutoutConsumed);
}","{
    return Objects.hash(Arrays.hashCode(mTypeInsetsMap), Arrays.hashCode(mTypeMaxInsetsMap), Arrays.hashCode(mTypeVisibilityMap), mIsRound, mDisplayCutout, mRoundedCorners, mAlwaysConsumeSystemBars, mSystemWindowInsetsConsumed, mStableInsetsConsumed, mDisplayCutoutConsumed, mPrivacyIndicatorBounds);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode method in Late_Implementation adds two new fields into the hash calculation: `mRoundedCorners` and `mPrivacyIndicatorBounds`. This is a change in the computation of the return value, thus the change type is 1. Since the hash calculation has been altered, this could also be seen as an other statement change because of the addition of the new fields, so it's denoted as 4 as well.","Considering that the hashCode method now includes additional fields in its computation, the potential returned hash value can differ even for the same object state with respect to the fields considered in the Early_Version. As the contract of the hashCode method implies it should consistently return the same value if the object doesnâ€™t change, and the equality relationship between objects is typically related to the fields participating in hashCode, this is a potential Compatibility Issue of type 1 due to the potential for different return values."
505,<android.view.autofill.AutofillValue: long getDateValue()>,30,31,<android.view.autofill.AutofillValue: long getDateValue()>,<android.view.autofill.AutofillValue: long getDateValue()>,0,"{
    Preconditions.checkState(isDate(), ""value must be a date value, not type="" + mType);
    return (Long) mValue;
}","{
    Preconditions.checkState(isDate(), ""value must be a date value, not type=%d"", mType);
    return (Long) mValue;
}",1,"/**
 * Gets the value to autofill a date field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_DATE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a date value
 */
","/**
 * Gets the value to autofill a date field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_DATE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a date value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is in the error message string displayed by the exception. The actual functional behavior of the method, including the checked condition and the return value, remains the same. Therefore, the code change type is 4.","There is no compatibility issue as the change does not affect the behavior of the API; it only modifies the error message format. The values returned by the method or the exceptions that it throws remain consistent between versions. Hence, the CI type is 0."
506,<android.bluetooth.BluetoothHeadset: void close()>,30,31,<android.bluetooth.BluetoothHeadset: void close()>,<android.bluetooth.BluetoothHeadset: void close()>,0,"{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, """", re);
        }
    }
    mServiceListener = null;
    doUnbind();
}","{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, """", re);
        }
    }
    mServiceListener = null;
    doUnbind();
    mCloseGuard.close();
}",1,"/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothHeadset will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */
","/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothHeadset will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,4,0,"A new method call (mCloseGuard.close()) is added at the end of the method body. This represents an ""Other statement changed"" (4) situation.","Though a new method call has been added (mCloseGuard.close()), this change does not alter the return type or throw a new exception, nor does it depend on a changed method signature of a dependent API. As a result, adding a method call only affects the internal state or behavior without altering the method's contract or interaction with callers. Therefore, this change does not cause a Compatibility Issue (0)."
507,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,30,31,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,<android.app.Notification.StandardTemplateParams: StandardTemplateParams reset()>,0,"{
    hasProgress = true;
    title = null;
    text = null;
    summaryText = null;
    headerTextSecondary = null;
    maxRemoteInputHistory = Style.MAX_REMOTE_INPUT_HISTORY_LINES;
    allowColorization = true;
    forceDefaultColor = false;
    return this;
}","{
    mViewType = VIEW_TYPE_UNSPECIFIED;
    mHeaderless = false;
    mHideAppName = false;
    mHideTitle = false;
    mHideSubText = false;
    mHideTime = false;
    mHideActions = false;
    mHideProgress = false;
    mHideSnoozeButton = false;
    mHideLeftIcon = false;
    mHideRightIcon = false;
    mPromotedPicture = null;
    mCallStyleActions = false;
    mAllowTextWithProgress = false;
    mTitleViewId = R.id.title;
    mTextViewId = R.id.text;
    title = null;
    text = null;
    summaryText = null;
    headerTextSecondary = null;
    maxRemoteInputHistory = Style.MAX_REMOTE_INPUT_HISTORY_LINES;
    allowColorization = true;
    mHighlightExpander = false;
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The late implementation includes the initialization of a significant number of additional member variables that were not present in the early version. Additionally, it introduces new fields related to view types and visibility options which are specific to the notification's appearance and behavior. However, since all the fields are reset and the method returns 'this' in both versions, the change is related to the addition of new fields; therefore, the code change type is 4.","Despite the added fields in the late implementation, the method's purpose is to reset the state of the object and it still returns the same object reference 'this'. No return value or exception handling behavior has been altered that would change how the code behaves when it's called by existing clients. Therefore, there should be no Compatibility Issue; the CI type is 0."
508,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,30,31,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,<android.hardware.camera2.marshal.impl.MarshalQueryableArray.MarshalerArray: T unmarshal(ByteBuffer)>,0,"{
    Object array;
    int elementSize = mComponentMarshaler.getNativeSize();
    if (elementSize != Marshaler.NATIVE_SIZE_DYNAMIC) {
        int remaining = buffer.remaining();
        int arraySize = remaining / elementSize;
        if (remaining % elementSize != 0) {
            throw new UnsupportedOperationException(""Arrays for "" + mTypeReference + "" must be packed tighly into a multiple of "" + elementSize + ""; but there are "" + (remaining % elementSize) + "" left over bytes"");
        }
        if (DEBUG) {
            Log.v(TAG, String.format(""Attempting to unpack array (count = %d, element size = %d, bytes "" + ""remaining = %d) for type %s"", arraySize, elementSize, remaining, mClass));
        }
        array = Array.newInstance(mComponentClass, arraySize);
        for (int i = 0; i < arraySize; ++i) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            Array.set(array, i, elem);
        }
    } else {
        // Dynamic size, use an array list.
        ArrayList<Object> arrayList = new ArrayList<Object>();
        // Assumes array is packed tightly; no unused bytes allowed
        while (buffer.hasRemaining()) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            arrayList.add(elem);
        }
        int arraySize = arrayList.size();
        array = copyListToArray(arrayList, Array.newInstance(mComponentClass, arraySize));
    }
    if (buffer.remaining() != 0) {
        Log.e(TAG, ""Trailing bytes ("" + buffer.remaining() + "") left over after unpacking "" + mClass);
    }
    return mClass.cast(array);
}","{
    Object array;
    int elementSize = mComponentMarshaler.getNativeSize();
    if (elementSize != Marshaler.NATIVE_SIZE_DYNAMIC) {
        int remaining = buffer.remaining();
        int arraySize = remaining / elementSize;
        if (remaining % elementSize != 0) {
            throw new UnsupportedOperationException(""Arrays for "" + mTypeReference + "" must be packed tighly into a multiple of "" + elementSize + ""; but there are "" + (remaining % elementSize) + "" left over bytes"");
        }
        if (DEBUG) {
            Log.v(TAG, String.format(""Attempting to unpack array (count = %d, element size = %d, bytes "" + ""remaining = %d) for type %s"", arraySize, elementSize, remaining, mClass));
        }
        array = Array.newInstance(mComponentClass, arraySize);
        if (isUnwrappedPrimitiveClass(mComponentClass) && mComponentClass == getPrimitiveTypeClass(mNativeType)) {
            unmarshalPrimitiveArray(array, arraySize, buffer, PrimitiveArrayFiller.getPrimitiveArrayFiller(mComponentClass));
        } else {
            for (int i = 0; i < arraySize; ++i) {
                Object elem = mComponentMarshaler.unmarshal(buffer);
                Array.set(array, i, elem);
            }
        }
    } else {
        // Dynamic size, use an array list.
        ArrayList<Object> arrayList = new ArrayList<Object>();
        // Assumes array is packed tightly; no unused bytes allowed
        while (buffer.hasRemaining()) {
            Object elem = mComponentMarshaler.unmarshal(buffer);
            arrayList.add(elem);
        }
        int arraySize = arrayList.size();
        array = copyListToArray(arrayList, Array.newInstance(mComponentClass, arraySize));
    }
    if (buffer.remaining() != 0) {
        Log.e(TAG, ""Trailing bytes ("" + buffer.remaining() + "") left over after unpacking "" + mClass);
    }
    return mClass.cast(array);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The conditional block that checks if the component class is an unwrapped primitive type and uses a primitive array filler has been added, resulting in a control dependency change type 3. There are also other changes outside this control dependency, like the addition of method calls to isUnwrappedPrimitiveClass, getPrimitiveTypeClass, and PrimitiveArrayFiller.getPrimitiveArrayFiller that do not fall under the other specified change types, thus we include the other statement changed type 4 as well.","These changes do not influence the return value of the method nor change exception handling. The additional code improves performance but does not alter the external behavior of the API; it only affects the internal implementation detail. Therefore, there is no Compatibility Issue."
509,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onGetReport(BluetoothDevice,byte,byte,int)>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onGetReport(BluetoothDevice,byte,byte,int)>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onGetReport(BluetoothDevice,byte,byte,int)>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onGetReport(device, type, id, bufferSize));
}","{
    Attributable.setAttributionSource(device, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onGetReport(device, type, id, bufferSize));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"In the late version implementation, a statement for setting the attribution source for the device and wrapping the execution within a try-finally block to restore the calling identity using `restoreCallingIdentity(token)` is added. Therefore, the code change type is 2,4 due to the changes in the exception handling statements (adding try-finally block) and the introduction of setAttributionSource(device, mAttributionSource), which is not categorized under return, control dependency, or dependent API changes.","There is no Compatibility Issue detected despite the additional wrapping within a try-finally block and the setting of the attribution source, since these changes do not affect the behavior of the API in terms of what value it returns or what exceptions it may throw when used as intended. The actual call to mCallback.onGetReport(device, type, id, bufferSize) within the runnable has not been modified, and will behave as it did previously. Thus, it would not lead to different return values/types or exception handlings seen by the client code - the callbacks themselves are responsible for handling any necessary state or exceptions."
511,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",30,31,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method signature remains the same, but there is a slight difference in one of the arguments passed to `ActivityManager.getService().broadcastIntentWithFeature...`. The only change is an additional comment (`/*excludedPermissions=*/`) added to clarify a `null` parameter in the `broadcastIntentWithFeature` method call, which does not affect the functionality of the code. This constitutes a change in the other statement without any modification to the actual implementation's behavior, hence the code change type is 4.","Since the method signature is unchanged, no exceptions have been added or modified, no return types or values have been changed, and the logic of the implementation remains the same, there is no compatibility issue. The added comment has no impact on runtime behavior. Therefore, no compatibility issue could arise from this change, so the CI type is 0."
513,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,30,31,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,<android.accessibilityservice.AccessibilityService.MagnificationController: boolean reset(boolean)>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.resetMagnification(mDisplayId, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to reset"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.resetMagnification(mDisplayId, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to reset"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Resets magnification scale and center to their default (e.g. no
 * magnification) values.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param animate {@code true} to animate from the current scale and
 * center or {@code false} to reset the scale and center
 * immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Resets magnification scale and center to their default (e.g. no
 * magnification) values.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param animate {@code true} to animate from the current scale and
 * center or {@code false} to reset the scale and center
 * immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change in the code is that the parameter passed to getInstance() method of AccessibilityInteractionClient has changed from being no parameters to passing mService. This indicates a change in a dependent API, as AccessibilityInteractionClient.getInstance() now requires a parameter and may behave differently based on it. The change type is 5.","Despite the change in how the instance of AccessibilityInteractionClient is obtained, the logic and return values of the `reset` method itself remain unchanged. No new return statements or exception handling statements have been introduced, and no existing ones have been removed or modified. This means there is no compatibility issue introduced by the code change. The API's behavior, in terms of returned values or exceptions thrown, should remain consistent, hence no CI."
515,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,30,31,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,<android.view.contentcapture.ContentCaptureManager: Set<ContentCaptureCondition> getContentCaptureConditions()>,0,"{
    // the service to fine tune how long-lived apps (like browsers) are whitelisted.
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = syncRun((r) -> mService.getContentCaptureConditions(mContext.getPackageName(), r));
    try {
        final ArrayList<ContentCaptureCondition> result = resultReceiver.getParcelableListResult();
        return toSet(result);
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get content capture conditions."");
    }
}","{
    // the service to fine tune how long-lived apps (like browsers) are allowlisted.
    if (!isContentCaptureEnabled() && !mOptions.lite)
        return null;
    final SyncResultReceiver resultReceiver = syncRun((r) -> mService.getContentCaptureConditions(mContext.getPackageName(), r));
    try {
        final ArrayList<ContentCaptureCondition> result = resultReceiver.getParcelableListResult();
        return toSet(result);
    } catch (SyncResultReceiver.TimeoutException e) {
        throw new RuntimeException(""Fail to get content capture conditions."");
    }
}",1,"/**
 * Gets the list of conditions for when content capture should be allowed.
 *
 * <p>This method is typically used by web browsers so they don't generate unnecessary content
 * capture events for websites the content capture service is not interested on.
 *
 * @return list of conditions, or {@code null} if the service didn't set any restriction
 * (in which case content capture events should always be generated). If the list is empty,
 * then it should not generate any event at all.
 */
","/**
 * Gets the list of conditions for when content capture should be allowed.
 *
 * <p>This method is typically used by web browsers so they don't generate unnecessary content
 * capture events for websites the content capture service is not interested on.
 *
 * @return list of conditions, or {@code null} if the service didn't set any restriction
 * (in which case content capture events should always be generated). If the list is empty,
 * then it should not generate any event at all.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the method's implementation between the two versions; only a comment has been modified (from 'whitelisted' to 'allowlisted'), which doesn't affect the code behavior or API contract.","As there are no changes affecting the actual execution of the code, there are no Compatibility Issues between these versions."
516,"<android.os.PatternMatcher: boolean matchPattern(String,String,int[],int)>",30,31,"<android.os.PatternMatcher: boolean matchPattern(String,String,int[],int)>","<android.os.PatternMatcher: boolean matchPattern(String,String,int[],int)>",0,"{
    if (match == null)
        return false;
    if (type == PATTERN_LITERAL) {
        return pattern.equals(match);
    }
    if (type == PATTERN_PREFIX) {
        return match.startsWith(pattern);
    } else if (type == PATTERN_SIMPLE_GLOB) {
        return matchGlobPattern(pattern, match);
    } else if (type == PATTERN_ADVANCED_GLOB) {
        return matchAdvancedPattern(parsedPattern, match);
    }
    return false;
}","{
    if (match == null)
        return false;
    if (type == PATTERN_LITERAL) {
        return pattern.equals(match);
    }
    if (type == PATTERN_PREFIX) {
        return match.startsWith(pattern);
    } else if (type == PATTERN_SIMPLE_GLOB) {
        return matchGlobPattern(pattern, match);
    } else if (type == PATTERN_ADVANCED_GLOB) {
        return matchAdvancedPattern(parsedPattern, match);
    } else if (type == PATTERN_SUFFIX) {
        return match.endsWith(pattern);
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"The change includes the addition of a new control flow case ""else if (type == PATTERN_SUFFIX)"" and this adds a new return statement ""return match.endsWith(pattern);"", which makes the change type 3, 4.","The addition of a new control flow case for `PATTERN_SUFFIX` means that for cases where `type == PATTERN_SUFFIX`, the method now returns `match.endsWith(pattern)` instead of `false`, resulting in a potentially different return value, and the CI type is 1."
517,<com.android.server.backup.SliceBackupHelper: byte[] getBackupPayload(String)>,30,31,<com.android.server.backup.SliceBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.SliceBackupHelper: byte[] getBackupPayload(String)>,0,"{
    byte[] newPayload = null;
    if (KEY_SLICES.equals(key)) {
        try {
            ISliceManager sm = ISliceManager.Stub.asInterface(ServiceManager.getService(Context.SLICE_SERVICE));
            // TODO: http://b/22388012
            newPayload = sm.getBackupPayload(UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with slice manager"");
            newPayload = null;
        }
    }
    return newPayload;
}","{
    byte[] newPayload = null;
    if (KEY_SLICES.equals(key)) {
        try {
            ISliceManager sm = ISliceManager.Stub.asInterface(ServiceManager.getService(Context.SLICE_SERVICE));
            // TODO: http://b/22388012
            newPayload = sm.getBackupPayload(UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with slice manager"", e);
            newPayload = null;
        }
    }
    return newPayload;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is in the log message where an exception 'e' is now being passed to the 'Slog.e()' method in the late version. This is a minor change and does not affect the control flow, variables returned, or exceptions thrown, so the code change type is 4.","Since only the logging statement has been enhanced to include exception details and no other behavior of the method has changed, this alteration does not lead to a compatibility issue. Hence, the CI type is 0."
518,<com.android.server.backup.AccountManagerBackupHelper: byte[] getBackupPayload(String)>,30,31,<com.android.server.backup.AccountManagerBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.AccountManagerBackupHelper: byte[] getBackupPayload(String)>,0,"{
    AccountManagerInternal am = LocalServices.getService(AccountManagerInternal.class);
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_ACCOUNT_ACCESS_GRANTS:
                {
                    return am.backupAccountAccessPermissions(UserHandle.USER_SYSTEM);
                }
            default:
                {
                    Slog.w(TAG, ""Unexpected backup key "" + key);
                }
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return new byte[0];
}","{
    AccountManagerInternal am = LocalServices.getService(AccountManagerInternal.class);
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_ACCOUNT_ACCESS_GRANTS:
                {
                    return am.backupAccountAccessPermissions(UserHandle.USER_SYSTEM);
                }
            default:
                {
                    Slog.w(TAG, ""Unexpected backup key "" + key);
                }
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key, e);
    }
    return new byte[0];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The exception handling statement in the `catch` block is changed, with adding the exception `e` as an argument to the `Slog.e()` method. This change does not affect the control flow or the values being returned, so the code change type is 4.","The change to the logging statement in the `catch` block does not alter the behavior of the method in terms of the output it produces or the exceptions it throws. Since it is just a change in the logging detail and does not affect the method's external behavior, there is no compatibility issue, hence CI type is 0."
519,<android.content.pm.LauncherActivityInfo: ComponentName getComponentName()>,30,31,<android.content.pm.LauncherActivityInfo: ComponentName getComponentName()>,<android.content.pm.LauncherActivityInfo: ComponentName getComponentName()>,0,"{
    return mComponentName;
}","{
    return mInternal.getComponentName();
}",1,"/**
 * Returns the component name of this activity.
 *
 * @return ComponentName of the activity
 */
","/**
 * Returns the component name of this activity.
 *
 * @return ComponentName of the activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls getComponentName() on the member variable mInternal instead of directly returning mComponentName, so the code change type is 5.","This change should not cause compatibility issues. The method still returns the ComponentName and, assuming mInternal.getComponentName() is intended to return mComponentName, the behavior of the method and its output remain the same. So, no CI is introduced, and the CI type is 0."
520,<android.view.VelocityTracker: VelocityTracker obtain()>,30,31,<android.view.VelocityTracker: VelocityTracker obtain()>,<android.view.VelocityTracker: VelocityTracker obtain()>,0,"{
    VelocityTracker instance = sPool.acquire();
    return (instance != null) ? instance : new VelocityTracker(null);
}","{
    VelocityTracker instance = sPool.acquire();
    return (instance != null) ? instance : new VelocityTracker(VELOCITY_TRACKER_STRATEGY_DEFAULT);
}",1,"/**
 * Retrieve a new VelocityTracker object to watch the velocity of a
 * motion.  Be sure to call {@link #recycle} when done.  You should
 * generally only maintain an active object while tracking a movement,
 * so that the VelocityTracker can be re-used elsewhere.
 *
 * @return Returns a new VelocityTracker.
 */
","/**
 * Retrieve a new VelocityTracker object to watch the velocity of a
 * motion.  Be sure to call {@link #recycle} when done.  You should
 * generally only maintain an active object while tracking a movement,
 * so that the VelocityTracker can be re-used elsewhere.
 *
 * @return Returns a new VelocityTracker.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed, specifically, the argument passed to the constructor of a new `VelocityTracker` instance has changed from `null` to `VELOCITY_TRACKER_STRATEGY_DEFAULT`. This could potentially change the behavior of the obtained `VelocityTracker` object because a different configuration is used in the late version.","Since the constructor argument has changed from `null` to `VELOCITY_TRACKER_STRATEGY_DEFAULT`, the behavior of the newly created `VelocityTracker` instances may differ between the two versions, causing a compatibility issue with type 1."
521,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,30,31,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,<android.hardware.camera2.impl.CameraConstrainedHighSpeedCaptureSessionImpl: List<CaptureRequest> createHighSpeedRequestList(CaptureRequest)>,0,"{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
    null);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
        null);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}","{
    if (request == null) {
        throw new IllegalArgumentException(""Input capture request must not be null"");
    }
    CameraCharacteristics.Key<StreamConfigurationMap> ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP;
    Integer sensorPixelMode = request.get(CaptureRequest.SENSOR_PIXEL_MODE);
    if (sensorPixelMode != null && sensorPixelMode == CameraMetadata.SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION) {
        ck = CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION;
    }
    Collection<Surface> outputSurfaces = request.getTargets();
    Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
    StreamConfigurationMap config = mCharacteristics.get(ck);
    SurfaceUtils.checkConstrainedHighSpeedSurfaces(outputSurfaces, fpsRange, config);
    // Request list size: to limit the preview to 30fps, need use maxFps/30; to maximize
    // the preview frame rate, should use maxBatch size for that high speed stream
    // configuration. We choose the former for now.
    int requestListSize = fpsRange.getUpper() / 30;
    List<CaptureRequest> requestList = new ArrayList<CaptureRequest>();
    // Prepare the Request builders: need carry over the request controls.
    // First, create a request builder that will only include preview or recording target.
    CameraMetadataNative requestMetadata = new CameraMetadataNative(request.getNativeCopy());
    // Note that after this step, the requestMetadata is mutated (swapped) and can not be used
    // for next request builder creation.
    CaptureRequest.Builder singleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
    false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
    null);
    // Carry over userTag, as native metadata doesn't have this field.
    singleTargetRequestBuilder.setTag(request.getTag());
    // Overwrite the capture intent to make sure a good value is set.
    Iterator<Surface> iterator = outputSurfaces.iterator();
    Surface firstSurface = iterator.next();
    Surface secondSurface = null;
    if (outputSurfaces.size() == 1 && SurfaceUtils.isSurfaceForHwVideoEncoder(firstSurface)) {
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_PREVIEW);
    } else {
        // Video only, or preview + video
        singleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
    }
    singleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
    true);
    // Second, Create a request builder that will include both preview and recording targets.
    CaptureRequest.Builder doubleTargetRequestBuilder = null;
    if (outputSurfaces.size() == 2) {
        // Have to create a new copy, the original one was mutated after a new
        // CaptureRequest.Builder creation.
        requestMetadata = new CameraMetadataNative(request.getNativeCopy());
        doubleTargetRequestBuilder = new CaptureRequest.Builder(requestMetadata, /*reprocess*/
        false, CameraCaptureSession.SESSION_ID_NONE, request.getLogicalCameraId(), /*physicalCameraIdSet*/
        null);
        doubleTargetRequestBuilder.setTag(request.getTag());
        doubleTargetRequestBuilder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_VIDEO_RECORD);
        doubleTargetRequestBuilder.addTarget(firstSurface);
        secondSurface = iterator.next();
        doubleTargetRequestBuilder.addTarget(secondSurface);
        doubleTargetRequestBuilder.setPartOfCHSRequestList(/*partOfCHSList*/
        true);
        // Make sure singleTargetRequestBuilder contains only recording surface for
        // preview + recording case.
        Surface recordingSurface = firstSurface;
        if (!SurfaceUtils.isSurfaceForHwVideoEncoder(recordingSurface)) {
            recordingSurface = secondSurface;
        }
        singleTargetRequestBuilder.addTarget(recordingSurface);
    } else {
        // Single output case: either recording or preview.
        singleTargetRequestBuilder.addTarget(firstSurface);
    }
    // Generate the final request list.
    for (int i = 0; i < requestListSize; i++) {
        if (i == 0 && doubleTargetRequestBuilder != null) {
            // First request should be recording + preview request
            requestList.add(doubleTargetRequestBuilder.build());
        } else {
            requestList.add(singleTargetRequestBuilder.build());
        }
    }
    return Collections.unmodifiableList(requestList);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
522,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,30,31,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,0,"{
    Configuration config = getResources().getConfiguration();
    if (config.orientation != Configuration.ORIENTATION_LANDSCAPE) {
        return false;
    }
    if (mInputEditorInfo != null && (mInputEditorInfo.imeOptions & EditorInfo.IME_FLAG_NO_FULLSCREEN) != 0) {
        return false;
    }
    return true;
}","{
    Configuration config = getResources().getConfiguration();
    if (config.orientation != Configuration.ORIENTATION_LANDSCAPE) {
        return false;
    }
    if ((mInputEditorInfo != null && (mInputEditorInfo.imeOptions & EditorInfo.IME_FLAG_NO_FULLSCREEN) != 0) || // is, IME shouldn't use fullscreen-mode.
    (mInputEditorInfo.internalImeOptions & EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT) != 0) {
        return false;
    }
    return true;
}",1,"/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
","/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"An additional condition has been added to an 'if' statement to check for the IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT flag, which implies a change in control dependency, so the code change type is 3.","The new condition could prevent the method from returning true when the IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT flag is set in mInputEditorInfo.internalImeOptions, which the earlier version did not check for. This constitutes a change in the return value under certain conditions, hence a CI type of 1."
523,<android.view.Display: boolean isWideColorGamut()>,30,31,<android.view.Display: boolean isWideColorGamut()>,<android.view.Display: boolean isWideColorGamut()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.isWideColorGamut();
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.isWideColorGamut();
    }
}",1,"/**
 * Returns whether this display can be used to display wide color gamut content.
 * This does not necessarily mean the device itself can render wide color gamut
 * content. To ensure wide color gamut content can be produced, refer to
 * {@link Configuration#isScreenWideColorGamut()}.
 */
","/**
 * Returns whether this display can be used to display wide color gamut content.
 * This does not necessarily mean the device itself can render wide color gamut
 * content. To ensure wide color gamut content can be produced, refer to
 * {@link Configuration#isScreenWideColorGamut()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the object on which the method is synchronized (from `this` to `mLock`), so the change type is 4 (Other statement changed).","This change alters the synchronization mechanism, but does not affect the logic that computes the return value (it still returns `mDisplayInfo.isWideColorGamut()`), so there should be no Compatibility Issue due to return value or exception handling. Hence, the CI type is 0 (No Compatibility Issue)."
524,<android.view.Display: boolean isHdr()>,30,31,<android.view.Display: boolean isHdr()>,<android.view.Display: boolean isHdr()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.isHdr();
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        HdrCapabilities hdrCapabilities = getHdrCapabilities();
        if (hdrCapabilities == null) {
            return false;
        }
        return !(hdrCapabilities.getSupportedHdrTypes().length == 0);
    }
}",1,"/**
 * Returns whether this display supports any HDR type.
 *
 * @see #getHdrCapabilities()
 * @see HdrCapabilities#getSupportedHdrTypes()
 */
","/**
 * Returns whether this display supports any HDR type.
 *
 * @see #getHdrCapabilities()
 * @see HdrCapabilities#getSupportedHdrTypes()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method's implementation has been changed to use `mLock` instead of `this` for the synchronized block, add a check for `hdrCapabilities` being `null`, and change the logic to determine if HDR is supported by checking the length of `hdrCapabilities.getSupportedHdrTypes()`. The return type remains a boolean, but the returned value changes based on the new logic introduced. Additionally, there is a change in the dependent API (`getHdrCapabilities()`). This accounts for the change types 1, 3, and 5.","The method is now using a different approach to determine whether HDR is supported, which may result in a different return value (either `true` or `false`). Therefore, the changes can lead to different behavior when the late version API is invoked, which means there is a Compatibility Issue of type 1."
525,<android.content.res.XmlBlock.Parser: String getAttributeNamespace(int)>,30,31,<android.content.res.XmlBlock.Parser: String getAttributeNamespace(int)>,<android.content.res.XmlBlock.Parser: String getAttributeNamespace(int)>,0,"{
    int id = nativeGetAttributeNamespace(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeNamespace of "" + index + "" = "" + id);
    if (id >= 0)
        return mStrings.get(id).toString();
    else if (id == -1)
        return """";
    throw new IndexOutOfBoundsException(String.valueOf(index));
}","{
    int id = nativeGetAttributeNamespace(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeNamespace of "" + index + "" = "" + id);
    if (id >= 0)
        return getSequenceString(mStrings.getSequence(id));
    else if (id == -1)
        return """";
    throw new IndexOutOfBoundsException(String.valueOf(index));
}",1,,,-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",1,"The method for retrieving the attribute namespace string has changed from `mStrings.get(id).toString()` to `getSequenceString(mStrings.getSequence(id))`. This is considered an ""Other statement changed"" as the way the string is returned has been altered. Additionally, because the actual string returned could be different, it's also considered a ""Return statement changed"".","Because the string value returned by the method has changed (due to the change from `toString()` to `getSequenceString()`), this may lead to different results for the same input. Therefore, a potential Compatibility Issue can arise due to the possibility of different return values, so the CI type is 1."
526,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,30,31,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,<android.view.textclassifier.SystemTextClassifier.ResponseReceiver: T get()>,0,"{
    // NOTE that TextClassifier calls should preferably always be called on a worker thread.
    if (Looper.myLooper() != Looper.getMainLooper()) {
        try {
            boolean success = mLatch.await(2, TimeUnit.SECONDS);
            if (!success) {
                Log.w(LOG_TAG, ""Timeout in ResponseReceiver.get(): "" + mName);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            Log.e(LOG_TAG, ""Interrupted during ResponseReceiver.get(): "" + mName, e);
        }
    }
    return mResponse;
}","{
    // NOTE that TextClassifier calls should preferably always be called on a worker thread.
    if (Looper.myLooper() != Looper.getMainLooper()) {
        try {
            boolean success = mLatch.await(mSettings.getSystemTextClassifierApiTimeoutInSecond(), TimeUnit.SECONDS);
            if (!success) {
                Log.w(LOG_TAG, ""Timeout in ResponseReceiver.get(): "" + mName);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            Log.e(LOG_TAG, ""Interrupted during ResponseReceiver.get(): "" + mName, e);
        }
    }
    return mResponse;
}",1,,,-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,5",0,"The 'await' method in the control structure 'try' now adopts a dynamic timeout value (mSettings.getSystemTextClassifierApiTimeoutInSecond()) instead of a hardcoded one (2), which implies a change in a control dependency and also a change in a dependent API by introducing a new method call to get the timeout value from mSettings. Thus, the code change type is 3,5.","Despite the change in timeout value, since the logic and the control flow remain unaffected irrespective of the timeout duration, and it does not affect the return type or the exception handling, no compatibility issue arises due to this change. Therefore, CI type is 0."
527,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",30,31,"<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>","<android.view.inputmethod.InputMethodManager: void updateCursorAnchorInfo(View,CursorAnchorInfo)>",0,"{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        try {
            if (mActivityViewToScreenMatrix != null) {
                mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(cursorAnchorInfo, mActivityViewToScreenMatrix));
            } else {
                mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);
            }
            mCursorAnchorInfo = cursorAnchorInfo;
            // Clear immediate bit (if any).
            mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    if (view == null || cursorAnchorInfo == null) {
        return;
    }
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursorAnchorInfo(view, cursorAnchorInfo);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has
        // not been changed from the previous call.
        final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;
        if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {
            // calls of this method from android.widget.Editor.
            if (DEBUG) {
                Log.w(TAG, ""Ignoring redundant updateCursorAnchorInfo: info="" + cursorAnchorInfo);
            }
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""updateCursorAnchorInfo: "" + cursorAnchorInfo);
        mCurrentInputMethodSession.updateCursorAnchorInfo(cursorAnchorInfo);
        mCursorAnchorInfo = cursorAnchorInfo;
        // Clear immediate bit (if any).
        mRequestUpdateCursorAnchorInfoMonitorMode &= ~InputConnection.CURSOR_UPDATE_IMMEDIATE;
    }
}",1,"/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
","/**
 * Report positional change of the text insertion point and/or characters in the composition
 * string.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The code change involves an update to the variable used from `mCurMethod` to `mCurrentInputMethodSession` for invoking `updateCursorAnchorInfo`, and there is no change to the control structures or exception handling, which categorizes as Other statement changed (4). Since the method called (`updateCursorAnchorInfo`) remains the same but with a different object instance used to call it, this is also a Dependent API changed (5).","Despite the object instance used for the call `updateCursorAnchorInfo` changing, there is no indication that the behavior of the `updateCursorAnchorInfo` method itself has changedâ€”no different return values or exceptions occur due to this change by itself. Without evidence of a difference in the implementations of `mCurMethod.updateCursorAnchorInfo` versus `mCurrentInputMethodSession.updateCursorAnchorInfo`, we cannot assert that there is a compatibility issue. Therefore, there is No Compatibility Issue (0)."
530,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>",30,31,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>","<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setCenter(float,float,boolean)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, Float.NaN, centerX, centerY, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, Float.NaN, centerX, centerY, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set center"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the center of the magnified viewport.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param centerX the unscaled screen-relative X coordinate on which to
 * center the viewport
 * @param centerY the unscaled screen-relative Y coordinate on which to
 * center the viewport
 * @param animate {@code true} to animate from the current viewport
 * center or {@code false} to set the center immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change from getConnection(mService.mConnectionId) to getConnection(mService) indicates a change in the dependent API, specifically the parameters expected by getConnection. Since there is no change in the set of return statements, exception handling statements or control dependency, the only change type is 5.","Although there is a change in the dependent API, this alone does not inherently create a compatibility issue since it doesn't alter the behavior of the setCenter method itself. The return values and exceptions thrown by the setCenter method would remain consistent with the behavior of the previous version, assuming the underlying change to getConnection still correctly facilitates the service connection in the context of the setCenter method. Therefore, no compatibility issue is detected."
531,<android.os.DropBoxManager.Entry: int getFlags()>,30,31,<android.os.DropBoxManager.Entry: int getFlags()>,<android.os.DropBoxManager.Entry: int getFlags()>,0,"{
    return mFlags & ~IS_GZIPPED;
}","{
    // getInputStream() decompresses.
    return mFlags & ~IS_GZIPPED;
}",1,"// getInputStream() decompresses.
","/**
 * @return flags describing the content returned by {@link #getInputStream()}.
 */
",-1,,[@Flags],-1,-1,-1,-1,-1,-1,4,0,"The change is a comment added in the late version implementation, so the code change type is 4.","Since the implementation regarding the return statement has not changed, adding a comment does not affect the functionality, behavior, or returned result of the method. Therefore, there is no Compatibility Issue, and the CI type is 0."
532,<android.permission.PermissionManager.PackageNamePermissionQuery: boolean equals(Object)>,30,31,<android.permission.PermissionManager.PackageNamePermissionQuery: boolean equals(Object)>,<android.permission.PermissionManager.PackageNamePermissionQuery: boolean equals(Object)>,0,"{
    if (rval == null) {
        return false;
    }
    PackageNamePermissionQuery other;
    try {
        other = (PackageNamePermissionQuery) rval;
    } catch (ClassCastException ex) {
        return false;
    }
    return Objects.equals(permName, other.permName) && Objects.equals(pkgName, other.pkgName) && uid == other.uid;
}","{
    if (rval == null) {
        return false;
    }
    PackageNamePermissionQuery other;
    try {
        other = (PackageNamePermissionQuery) rval;
    } catch (ClassCastException ex) {
        return false;
    }
    return Objects.equals(permName, other.permName) && Objects.equals(pkgName, other.pkgName) && userId == other.userId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The comparison at the return statement changed from ""uid == other.uid"" to ""userId == other.userId"", which indicates that either a variable has been renamed or the value it represents has changed. This is an ""Other statement changed"" kind of modification. However, this might not necessarily lead to a compatibility issue if ""uid"" was simply renamed to ""userId"" without changing the semantic, which seems likely given the context of the method (comparing objects of the same type). Therefore, we classify the change as both 1 and 4.","As long as ""uid"" was simply renamed to ""userId"" and represents the same entity semantically, it would not lead to a compatibility issue; hence the prediction is 0. If the semantic meaning or the type of the identifier was changed, for instance, if ""userId"" represents a different concept than ""uid"", it might be a compatibility issue. However, from the context provided, it seems more likely to be a simple rename refactoring."
534,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,30,31,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,<android.content.res.ResourcesImpl.ThemeImpl: int getChangingConfigurations()>,0,"{
    synchronized (mKey) {
        @NativeConfig final int nativeChangingConfig = AssetManager.nativeThemeGetChangingConfigurations(mTheme);
        return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
    }
}","{
    @NativeConfig final int nativeChangingConfig = AssetManager.nativeThemeGetChangingConfigurations(mTheme);
    return ActivityInfo.activityInfoConfigNativeToJava(nativeChangingConfig);
}",1,,,-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,4,0,"The change is the removal of the synchronized block around the code. The method's logic remains the same; only the thread-safety mechanism is modified, so the code change type is 4.","The API's behavior, in terms of the return value, has not been altered. The change does not affect what value is returned nor does it introduce any new exceptions or change existing exception handling. Hence, there is no Compatibility Issue, so CI type is 0."
535,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",30,31,"<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>","<android.view.inputmethod.InputMethodManager: boolean hideSoftInputFromWindow(IBinder,int,ResultReceiver)>",0,"{
    checkFocus();
    synchronized (mH) {
        final View servedView = getServedViewLocked();
        if (servedView == null || servedView.getWindowToken() != windowToken) {
            return false;
        }
        try {
            return mService.hideSoftInput(mClient, windowToken, flags, resultReceiver);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    return hideSoftInputFromWindow(windowToken, flags, resultReceiver, SoftInputShowHideReason.HIDE_SOFT_INPUT);
}",1,"/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
","/**
 * Request to hide the soft input window from the context of the window
 * that is currently accepting input.  This should be called as a result
 * of the user doing some actually than fairly explicitly requests to
 * have the input window hidden.
 *
 * <p><strong>Caveat:</strong> {@link ResultReceiver} instance passed to
 * this method can be a long-lived object, because it may not be
 * garbage-collected until all the corresponding {@link ResultReceiver}
 * objects transferred to different processes get garbage-collected.
 * Follow the general patterns to avoid memory leaks in Android.
 * Consider to use {@link java.lang.ref.WeakReference} so that application
 * logic objects such as {@link android.app.Activity} and {@link Context}
 * can be garbage collected regardless of the lifetime of
 * {@link ResultReceiver}.
 *
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param flags Provides additional operating flags.  Currently may be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY} bit set.
 * @param resultReceiver If non-null, this will be called by the IME when
 * it has processed your request to tell you what it has done.  The result
 * code you receive may be either {@link #RESULT_UNCHANGED_SHOWN},
 * {@link #RESULT_UNCHANGED_HIDDEN}, {@link #RESULT_SHOWN}, or
 * {@link #RESULT_HIDDEN}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The early implementation includes a focus check, a synchronized block, checks on the view state, and exception handling, whereas the late implementation directly invokes another method. This introduction of a new method call and the removal of several checks and exception handling indicate a change in exception handling statements, control dependency, and a dependent API change, which amounts to code change types 1, 3, and 5.","Due to the simplified late version implementation which calls another method, a Compatibility Issue could arise because the exception handling and specific checks have been removed. Thus, the API in its late version could behave differently from the early version in both the return value and the exceptions it throws or does not throw, which can be classified as a Compatibility Issue type 1."
537,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,30,31,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,<android.hardware.camera2.impl.CameraDeviceImpl: void close()>,0,"{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mOfflineSwitchService != null) {
            mOfflineSwitchService.shutdownNow();
            mOfflineSwitchService = null;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceExecutor.execute(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}","{
    synchronized (mInterfaceLock) {
        if (mClosing.getAndSet(true)) {
            return;
        }
        if (mOfflineSwitchService != null) {
            mOfflineSwitchService.shutdownNow();
            mOfflineSwitchService = null;
        }
        if (mRemoteDevice != null) {
            mRemoteDevice.disconnect();
            mRemoteDevice.unlinkToDeath(this, /*flags*/
            0);
        }
        if (mCurrentExtensionSession != null) {
            mCurrentExtensionSession.release(true);
            mCurrentExtensionSession = null;
        }
        if (mCurrentAdvancedExtensionSession != null) {
            mCurrentAdvancedExtensionSession.release(true);
            mCurrentAdvancedExtensionSession = null;
        }
        // or a close after a startup error (no remote device but in error state)
        if (mRemoteDevice != null || mInError) {
            mDeviceExecutor.execute(mCallOnClosed);
        }
        mRemoteDevice = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change includes the addition of new blocks that handle the 'mCurrentExtensionSession' and 'mCurrentAdvancedExtensionSession' variables. Since this is neither a return statement, exception handling, control dependency, nor a change in a dependent API, it falls under the ""Other statement changed"" category.","There is no Compatibility Issue indicated by this change since the contract of the method 'close()' does not seem to be affected. The method's behavior remains synchronous and exception-free as per its original contract. The newly introduced statements deal with internal cleanup that is not part of the method's external contract with its callers. Therefore, there is no change in the behavior that would be outwardly visible or impactful to existing client code."
538,<android.content.pm.ShortcutManager: List<ShortcutInfo> getShortcuts(int)>,30,31,<android.content.pm.ShortcutManager: List<ShortcutInfo> getShortcuts(int)>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getShortcuts(int)>,0,"{
    try {
        return mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns {@link ShortcutInfo}s that match {@code matchFlags}.
 *
 * @param matchFlags result includes shortcuts matching this flags. Any combination of:
 * <ul>
 * <li>{@link #FLAG_MATCH_MANIFEST}
 * <li>{@link #FLAG_MATCH_DYNAMIC}
 * <li>{@link #FLAG_MATCH_PINNED}
 * <li>{@link #FLAG_MATCH_CACHED}
 * </ul>
 *
 * @return list of {@link ShortcutInfo}s that match the flag.
 *
 * <p>At least one of the {@code MATCH} flags should be set. Otherwise no shortcuts will be
 * returned.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Returns {@link ShortcutInfo}s that match {@code matchFlags}.
 *
 * @param matchFlags result includes shortcuts matching this flags. Any combination of:
 * <ul>
 * <li>{@link #FLAG_MATCH_MANIFEST}
 * <li>{@link #FLAG_MATCH_DYNAMIC}
 * <li>{@link #FLAG_MATCH_PINNED}
 * <li>{@link #FLAG_MATCH_CACHED}
 * </ul>
 *
 * @return list of {@link ShortcutInfo}s that match the flag.
 *
 * <p>At least one of the {@code MATCH} flags should be set. Otherwise no shortcuts will be
 * returned.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],"[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API called within return statement changed from direct service call mService.getShortcuts() to getFutureOrThrow(mService.getShortcuts()), without altering the structure of the try-catch block. This indicates the change type is 5.",There is no Compatibility Issue detected because the return type and exception handling have not been altered in a way that would lead to different behavior from the perspective of an API consumer. The code changes internally handle the result before returning but do not affect the output type or potential exceptions that are thrown.
540,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",30,31,"<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>","<android.content.pm.ShortcutInfo: void writeToParcel(Parcel,int)>",0,"{
    dest.writeInt(mUserId);
    dest.writeString8(mId);
    dest.writeString8(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString8(mBitmapPath);
    dest.writeString8(mIconResName);
    dest.writeString8(mTitleResName);
    dest.writeString8(mTextResName);
    dest.writeString8(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString8(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
    dest.writeString8(mIconUri);
}","{
    dest.writeInt(mUserId);
    dest.writeString8(mId);
    dest.writeString8(mPackageName);
    dest.writeParcelable(mActivity, flags);
    dest.writeInt(mFlags);
    dest.writeInt(mIconResId);
    dest.writeLong(mLastChangedTimestamp);
    dest.writeInt(mDisabledReason);
    if (hasKeyFieldsOnly()) {
        dest.writeInt(0);
        return;
    }
    dest.writeInt(1);
    dest.writeParcelable(mIcon, flags);
    dest.writeCharSequence(mTitle);
    dest.writeInt(mTitleResId);
    dest.writeCharSequence(mText);
    dest.writeInt(mTextResId);
    dest.writeCharSequence(mDisabledMessage);
    dest.writeInt(mDisabledMessageResId);
    dest.writeParcelableArray(mIntents, flags);
    dest.writeParcelableArray(mIntentPersistableExtrases, flags);
    dest.writeInt(mRank);
    dest.writeParcelable(mExtras, flags);
    dest.writeString8(mBitmapPath);
    dest.writeString8(mIconResName);
    dest.writeString8(mTitleResName);
    dest.writeString8(mTextResName);
    dest.writeString8(mDisabledMessageResName);
    if (mCategories != null) {
        final int N = mCategories.size();
        dest.writeInt(N);
        for (int i = 0; i < N; i++) {
            dest.writeString8(mCategories.valueAt(i));
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeParcelableArray(mPersons, flags);
    dest.writeParcelable(mLocusId, flags);
    dest.writeString8(mIconUri);
    dest.writeString8(mStartingThemeResName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's only an additional line at the end of the Late Implementation that writes a new string to the parcel, so the code change type is 4.","This is adding an additional piece of information to the serialization process and does not affect the compatibility as it does not change how existing information is written or alter the control flow. Existing code which reads from the Parcel does not expect or depend on the new piece of information. Therefore, there is no compatibility issue, hence the CI type is 0."
543,"<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>",30,31,"<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>","<android.content.ContentProviderClient: boolean refresh(Uri,Bundle,CancellationSignal)>",0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mAttributionSource, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#refresh}
 */
","/**
 * See {@link ContentProvider#refresh}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The call to `mContentProvider.refresh` changed its arguments list from `refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal)` to `refresh(mAttributionSource, url, extras, remoteCancellationSignal)`, removing `mPackageName` and `mAttributionTag` and adding `mAttributionSource` instead, so there's a change in the Dependent API (5); also, since this change involves method parameters being passed differently, it's classified as ""Other statement changed"" as well (4).","Since the parameters passed to `mContentProvider.refresh` have changed, it may cause the API to return a different result based on this new parameter, thus leading to a potential Compatibility Issue of type 1."
544,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,30,31,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,<android.bluetooth.BluetoothGatt: boolean executeReliableWrite()>,0,"{
    if (VDBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""executeReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */
","/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * @return true, if the request to execute the transaction has been sent
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the implementation is the addition of one more argument `mAttributionSource` to the method `endReliableWrite()`. Since this is a change in the signature of a method being called and not in the control flow, return statements, or exception handling, the changes are of type 4 (Other statement changed) and 5 (Dependent API changed).","The change to the `endReliableWrite()` method does not directly result in a different return variable or an exception being thrown, as the calling method's interface (`executeReliableWrite()`) and logic remain the same. The method still returns `false` if the service is null, if `mClientIf` is 0, if `mDeviceBusy` is true, otherwise it will attempt to call `endReliableWrite()` and return `true` if no exception occurs. Therefore, no compatibility issue should arise due to the changes made. There is no change that would cause the API to return a different variable or throw a different exception."
545,<android.app.ActivityManager.TaskDescription: boolean equals(Object)>,30,31,<android.app.ActivityManager.TaskDescription: boolean equals(Object)>,<android.app.ActivityManager.TaskDescription: boolean equals(Object)>,0,"{
    if (!(obj instanceof TaskDescription)) {
        return false;
    }
    TaskDescription other = (TaskDescription) obj;
    return TextUtils.equals(mLabel, other.mLabel) && TextUtils.equals(mIconFilename, other.mIconFilename) && mIcon == other.mIcon && mColorPrimary == other.mColorPrimary && mColorBackground == other.mColorBackground && mStatusBarColor == other.mStatusBarColor && mNavigationBarColor == other.mNavigationBarColor && mEnsureStatusBarContrastWhenTransparent == other.mEnsureStatusBarContrastWhenTransparent && mEnsureNavigationBarContrastWhenTransparent == other.mEnsureNavigationBarContrastWhenTransparent && mResizeMode == other.mResizeMode && mMinWidth == other.mMinWidth && mMinHeight == other.mMinHeight;
}","{
    if (!(obj instanceof TaskDescription)) {
        return false;
    }
    TaskDescription other = (TaskDescription) obj;
    return TextUtils.equals(mLabel, other.mLabel) && TextUtils.equals(mIconFilename, other.mIconFilename) && mIcon == other.mIcon && mColorPrimary == other.mColorPrimary && mColorBackground == other.mColorBackground && mStatusBarColor == other.mStatusBarColor && mNavigationBarColor == other.mNavigationBarColor && mEnsureStatusBarContrastWhenTransparent == other.mEnsureStatusBarContrastWhenTransparent && mEnsureNavigationBarContrastWhenTransparent == other.mEnsureNavigationBarContrastWhenTransparent && mResizeMode == other.mResizeMode && mMinWidth == other.mMinWidth && mMinHeight == other.mMinHeight && mColorBackgroundFloating == other.mColorBackgroundFloating;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There's an addition of new condition `mColorBackgroundFloating == other.mColorBackgroundFloating` in the return statement, hence the change type is 1.","This additional condition in the return statement could potentially result in a different return value when comparing two `TaskDescription` objects that differ on the `mColorBackgroundFloating` attribute even though they are the same on all the other attributes. This indicates a change in the behavior of the method, which means there is a potential Compatibility Issue of type 1."
546,<android.app.UiAutomation: void adoptShellPermissionIdentity()>,30,31,<android.app.UiAutomation: void adoptShellPermissionIdentity()>,<android.app.UiAutomation: void adoptShellPermissionIdentity()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.adoptShellPermissionIdentity(Process.myUid(), null);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing adopting shell permission identity!"", re);
    }
}","{
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.adoptShellPermissionIdentity(Process.myUid(), null);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing adopting shell permission identity!"", re);
    }
}",1,"/**
 * Adopt the permission identity of the shell UID for all permissions. This allows
 * you to call APIs protected permissions which normal apps cannot hold but are
 * granted to the shell UID. If you already adopted all shell permissions by calling
 * this method or {@link #adoptShellPermissionIdentity(String...)} a subsequent call
 * would be a no-op. Note that your permission state becomes that of the shell UID
 * and it is not a combination of your and the shell UID permissions.
 * <p>
 * <strong>Note:<strong/> Calling this method adopts all shell permissions and overrides
 * any subset of adopted permissions via {@link #adoptShellPermissionIdentity(String...)}.
 *
 * @see #adoptShellPermissionIdentity(String...)
 * @see #dropShellPermissionIdentity()
 */
","/**
 * Adopt the permission identity of the shell UID for all permissions. This allows
 * you to call APIs protected permissions which normal apps cannot hold but are
 * granted to the shell UID. If you already adopted all shell permissions by calling
 * this method or {@link #adoptShellPermissionIdentity(String...)} a subsequent call will
 * replace any previous adoption. Note that your permission state becomes that of the shell UID
 * and it is not a combination of your and the shell UID permissions.
 * <p>
 * <strong>Note:<strong/> Calling this method adopts all shell permissions and overrides
 * any subset of adopted permissions via {@link #adoptShellPermissionIdentity(String...)}.
 *
 * @see #adoptShellPermissionIdentity(String...)
 * @see #dropShellPermissionIdentity()
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The synchronized block along with the throwIfNotConnectedLocked() method call inside it has been removed, so the code change type is 3.","The removal of the synchronized block and the throwIfNotConnectedLocked() method call is related to the program's internal synchronization and error handling prior to making the actual API call. Since the RemoteException is still caught and logged as an error, and the RemoteException handling has not changed, there is no change that affects how the API potentially throws different exceptions. The RemoteException that could have been potentially thrown by throwIfNotConnectedLocked() inside the synchronized block is not part of the API's contract (it's an internal check). Hence, there is no CI, since the behavior observed by the caller remains consistent before and after the change."
547,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,30,31,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,<android.view.inputmethod.CursorAnchorInfo.Builder: CursorAnchorInfo build()>,0,"{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return CursorAnchorInfo.create(this);
}","{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException(""Coordinate transformation matrix is "" + ""required when positional parameters are specified."");
        }
    }
    return new CursorAnchorInfo(this);
}",1,"/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
","/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed from invoking a static method `CursorAnchorInfo.create(this)` in the early version to invoking a constructor `new CursorAnchorInfo(this)` in the late version, thus the change type is 4.","The change from a static factory method to a constructor does not inherently lead to a different behavior unless the implementation of `create()` and the constructor `CursorAnchorInfo()` differs. Since there is no information given that suggests a different implementation, and since constructors typically don't contain logic that would alter the initialization from what a static factory method would do in a stable API, we cannot assume a compatibility issue without further information. Therefore, based on the given data, there is no compatibility issue."
548,<android.companion.AssociationRequest: boolean equals(Object)>,30,31,<android.companion.AssociationRequest: boolean equals(Object)>,<android.companion.AssociationRequest: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    AssociationRequest that = (AssociationRequest) o;
    return mSingleDevice == that.mSingleDevice && Objects.equals(mDeviceFilters, that.mDeviceFilters);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") AssociationRequest that = (AssociationRequest) o;
    // noinspection PointlessBooleanExpression
    return true && mSingleDevice == that.mSingleDevice && Objects.equals(mDeviceFilters, that.mDeviceFilters) && Objects.equals(mDeviceProfile, that.mDeviceProfile) && Objects.equals(mCallingPackage, that.mCallingPackage) && Objects.equals(mDeviceProfilePrivilegesDescription, that.mDeviceProfilePrivilegesDescription) && mCreationTime == that.mCreationTime && mSkipPrompt == that.mSkipPrompt;
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"Additional fields are compared in the equals method (`mDeviceProfile`, `mCallingPackage`, `mDeviceProfilePrivilegesDescription`, `mCreationTime`, and `mSkipPrompt`). There are also changes in comments and the addition of an annotation and use of suppress warnings. This constitutes changes in control structures due to additional logical conditions, and because of the dependent API `Objects.equals()` being used multiple times with new fields. Therefore, the code change types are 1, 3, 4, and 5.","The addition of new comparisons in the late version's `equals()` method will produce different results when comparing `AssociationRequest` objects with the new fields, thus leading to different return values. Therefore, the CI type is 1."
549,<android.permission.PermissionManager.PackageNamePermissionQuery: int hashCode()>,30,31,<android.permission.PermissionManager.PackageNamePermissionQuery: int hashCode()>,<android.permission.PermissionManager.PackageNamePermissionQuery: int hashCode()>,0,"{
    return Objects.hash(permName, pkgName, uid);
}","{
    return Objects.hash(permName, pkgName, userId);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in the use of a different variable name inside the hash method (from 'uid' to 'userId'), which indicates an ""Other statement changed"" (4). However, if 'uid' and 'userId' hold the same value, the computation of the hash would be the same.","There is no Compatibility Issue since the method's behavior of returning a hash value does not change as long as 'uid' and 'userId' represent the same data. The internal variable names are not part of the API contract with the callers; what matters is that they correctly represent the identifiers for a user. Assuming 'userId' is just a renaming of 'uid' and does not represent a different concept, the functionality of the method remains consistent with the previous version."
550,<android.widget.EdgeEffect: boolean draw(Canvas)>,30,31,<android.widget.EdgeEffect: boolean draw(Canvas)>,<android.widget.EdgeEffect: boolean draw(Canvas)>,0,"{
    update();
    final int count = canvas.save();
    final float centerX = mBounds.centerX();
    final float centerY = mBounds.height() - mRadius;
    canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
    final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
    float translateX = mBounds.width() * displacement / 2;
    canvas.clipRect(mBounds);
    canvas.translate(translateX, 0);
    mPaint.setAlpha((int) (0xff * mGlowAlpha));
    canvas.drawCircle(centerX, centerY, mRadius, mPaint);
    canvas.restoreToCount(count);
    boolean oneLastFrame = false;
    if (mState == STATE_RECEDE && mGlowScaleY == 0) {
        mState = STATE_IDLE;
        oneLastFrame = true;
    }
    return mState != STATE_IDLE || oneLastFrame;
}","{
    int edgeEffectBehavior = getCurrentEdgeEffectBehavior();
    if (edgeEffectBehavior == TYPE_GLOW) {
        update();
        final int count = canvas.save();
        final float centerX = mBounds.centerX();
        final float centerY = mBounds.height() - mRadius;
        canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
        final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
        float translateX = mBounds.width() * displacement / 2;
        canvas.clipRect(mBounds);
        canvas.translate(translateX, 0);
        mPaint.setAlpha((int) (0xff * mGlowAlpha));
        canvas.drawCircle(centerX, centerY, mRadius, mPaint);
        canvas.restoreToCount(count);
    } else if (edgeEffectBehavior == TYPE_STRETCH && canvas instanceof RecordingCanvas) {
        if (mState == STATE_RECEDE) {
            updateSpring();
        }
        if (mDistance != 0f) {
            RecordingCanvas recordingCanvas = (RecordingCanvas) canvas;
            if (mTmpMatrix == null) {
                mTmpMatrix = new Matrix();
                mTmpPoints = new float[12];
            }
            // noinspection deprecation
            recordingCanvas.getMatrix(mTmpMatrix);
            mTmpPoints[0] = 0;
            // top-left
            mTmpPoints[1] = 0;
            mTmpPoints[2] = mWidth;
            // top-right
            mTmpPoints[3] = 0;
            mTmpPoints[4] = mWidth;
            // bottom-right
            mTmpPoints[5] = mHeight;
            mTmpPoints[6] = 0;
            // bottom-left
            mTmpPoints[7] = mHeight;
            mTmpPoints[8] = mWidth * mDisplacement;
            // drag start point
            mTmpPoints[9] = 0;
            mTmpPoints[10] = mWidth * mDisplacement;
            // drag point
            mTmpPoints[11] = mHeight * mDistance;
            mTmpMatrix.mapPoints(mTmpPoints);
            RenderNode renderNode = recordingCanvas.mNode;
            float left = renderNode.getLeft() + min(mTmpPoints[0], mTmpPoints[2], mTmpPoints[4], mTmpPoints[6]);
            float top = renderNode.getTop() + min(mTmpPoints[1], mTmpPoints[3], mTmpPoints[5], mTmpPoints[7]);
            float right = renderNode.getLeft() + max(mTmpPoints[0], mTmpPoints[2], mTmpPoints[4], mTmpPoints[6]);
            float bottom = renderNode.getTop() + max(mTmpPoints[1], mTmpPoints[3], mTmpPoints[5], mTmpPoints[7]);
            // assume rotations of increments of 90 degrees
            float x = mTmpPoints[10] - mTmpPoints[8];
            float width = right - left;
            float vecX = dampStretchVector(Math.max(-1f, Math.min(1f, x / width)));
            float y = mTmpPoints[11] - mTmpPoints[9];
            float height = bottom - top;
            float vecY = dampStretchVector(Math.max(-1f, Math.min(1f, y / height)));
            boolean hasValidVectors = Float.isFinite(vecX) && Float.isFinite(vecY);
            if (right > left && bottom > top && mWidth > 0 && mHeight > 0 && hasValidVectors) {
                renderNode.stretch(// horizontal stretch intensity
                vecX, // vertical stretch intensity
                vecY, // max horizontal stretch in pixels
                mWidth, // max vertical stretch in pixels
                mHeight);
            }
        }
    } else {
        // Animations have been disabled or this is TYPE_STRETCH and drawing into a Canvas
        // that isn't a Recording Canvas, so no effect can be shown. Just end the effect.
        mState = STATE_IDLE;
        mDistance = 0;
        mVelocity = 0;
    }
    boolean oneLastFrame = false;
    if (mState == STATE_RECEDE && mDistance == 0 && mVelocity == 0) {
        mState = STATE_IDLE;
        oneLastFrame = true;
    }
    return mState != STATE_IDLE || oneLastFrame;
}",1,"/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
","/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height. The effect will only be visible on a
 * hardware canvas, e.g. {@link RenderNode#beginRecording()}.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
551,<android.hardware.camera2.params.InputConfiguration: int hashCode()>,30,31,<android.hardware.camera2.params.InputConfiguration: int hashCode()>,<android.hardware.camera2.params.InputConfiguration: int hashCode()>,0,"{
    return HashCodeHelpers.hashCode(mWidth, mHeight, mFormat);
}","{
    return HashCodeHelpers.hashCode(mWidth, mHeight, mFormat, mIsMultiResolution ? 1 : 0);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the implementation adds an additional parameter to the hashCode() call (mIsMultiResolution ? 1 : 0), which is a code change of type 4 (Other statement changed), and since this additional information changes how the hashCode is generated, it is also a change of type 1 (Return statement changed).","The added parameter to the hashCode call changes the return value of the hashCode method when `mIsMultiResolution` is true, which means that objects of the same class may have different hash codes between these two versions under certain conditions. Therefore, there is a Compatibility Issue of type 1 caused by potential different return values."
552,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,30,31,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,<android.app.WallpaperManager: void setDisplayPadding(Rect)>,0,"{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    StrictMode.assertUiContext(mContext, ""setDisplayPadding"");
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 */
","/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 */
",-1,[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER_HINTS)],[@RequiresPermission(android.Manifest.permission.SET_WALLPAPER_HINTS)],-1,-1,-1,-1,-1,-1,4,0,"An additional statement 'StrictMode.assertUiContext(mContext, ""setDisplayPadding"");' is introduced in the late version, and no other changes are found. So, the code change type is 4.","The new statement, 'StrictMode.assertUiContext(mContext, ""setDisplayPadding"");', does not affect the return value or type, nor the exceptions that are thrown by the method. It is an extra check that will throw a RuntimeException only if the context passed is not a UI context. Since this is an added assertion which will throw an unchecked exception that is not related to the behavior of the rest of the method, it does not directly affect backward compatibility for calls that already comply with this assertion requirement. Thus, there's no Compatibility Issue, so CI type is 0."
553,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,30,31,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,<android.hardware.camera2.params.OutputConfiguration: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId))
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}","{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}",1,"/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late version includes an additional field comparison (mIsMultiResolution != other.mIsMultiResolution) and a new loop comparing elements of mSensorPixelModesUsed. This introduces changes to the if condition (returns statement), and the introduction of a new loop, which is a control dependency change. Therefore, the change types are 1,3, and 4.","Given that there is an additional check introduced (mIsMultiResolution != other.mIsMultiResolution) and a new comparison loop for the mSensorPixelModesUsed list, the equality check behavior of the method has changed. The method may now return false in cases where the previous version would have returned true, due to these additional comparisons. Hence, there is a potential Compatibility Issue of type 1."
554,<android.os.VibrationAttributes: boolean equals(Object)>,30,31,<android.os.VibrationAttributes: boolean equals(Object)>,<android.os.VibrationAttributes: boolean equals(Object)>,0,"{
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    VibrationAttributes rhs = (VibrationAttributes) o;
    return mUsage == rhs.mUsage && mFlags == rhs.mFlags;
}","{
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    VibrationAttributes rhs = (VibrationAttributes) o;
    return mUsage == rhs.mUsage && mOriginalAudioUsage == rhs.mOriginalAudioUsage && mFlags == rhs.mFlags;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"Added an additional condition to the return statement (`mOriginalAudioUsage == rhs.mOriginalAudioUsage`), so the code change type is 1.","The added condition in the return statement will make the API potentially return a different value (true or false), depending on the result of the comparison `mOriginalAudioUsage == rhs.mOriginalAudioUsage`, hence a different behavior of `equals` method. Therefore, the CI type is 1."
555,<android.database.sqlite.SQLiteCursor: void finalize()>,30,31,<android.database.sqlite.SQLiteCursor: void finalize()>,<android.database.sqlite.SQLiteCursor: void finalize()>,0,"{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (mStackTrace != null) {
                String sql = mQuery.getSql();
                int len = sql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.getDatabase().getLabel() + "", table = "" + mEditTable + "", query = "" + sql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            // Report original sql statement
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                String sql = mQuery.getSql();
                int len = sql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.getDatabase().getLabel() + "", table = "" + mEditTable + "", query = "" + sql.substring(0, (len > 1000) ? 1000 : len), null);
            }
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",2,"The condition checking for StrictMode using a stack trace has been replaced by a method call to `StrictMode.vmSqliteObjectLeaksEnabled()`, and the logic for reporting leaks no longer includes the `mStackTrace`. Additionally, the `close()` method call that was in the early version inside the `if` block has been removed. These changes are encompassed under exception handling statement changed (2), control dependency change (3), and other statement changed (4).","The removal of the `close()` method call as part of the finalization process could potentially lead to different behavior, i.e., the cursor may not be closed properly in scenarios where it should be, and this could potentially lead to resource leaks or unexpected behavior. Furthermore, handling the exception differently might have an impact on the application's behavior regarding how it reports leaked cursor objects. This can be classified as a Compatibility Issue related to exception handling (2)."
556,<android.app.admin.FreezePeriod: String toString()>,30,31,<android.app.admin.FreezePeriod: String toString()>,<android.app.admin.FreezePeriod: String toString()>,0,"{
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""MMM dd"");
    return LocalDate.ofYearDay(DUMMY_YEAR, mStartDay).format(formatter) + "" - "" + LocalDate.ofYearDay(DUMMY_YEAR, mEndDay).format(formatter);
}","{
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""MMM dd"");
    return LocalDate.ofYearDay(SENTINEL_YEAR, mStartDay).format(formatter) + "" - "" + LocalDate.ofYearDay(SENTINEL_YEAR, mEndDay).format(formatter);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the use of `SENTINEL_YEAR` instead of `DUMMY_YEAR`, so the change type is 4 (Other statement changed).","Since `DUMMY_YEAR` and `SENTINEL_YEAR` are used to format a date and as long as they represent valid year values, the behavior and output of the `toString()` method should be consistent and the actual year shouldn't affect the resulting formatted string which just includes month and day. Therefore, there is no Compatibility Issue."
557,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",30,31,"<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>","<android.app.ContextImpl: void sendBroadcast(Intent,String,int)>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        appOp, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The only change between the two versions of the code is the reordering of parameters being passed to ActivityManager.getService().broadcastIntentWithFeature() method. There is no change in the values of existing parameters, so there is no different value returned or exception handling changed. Thus, the code change type is 5.","The reordering of the parameters does not change the behavior of the method as it's still compatible with the method signature (assuming that broadcastIntentWithFeature method was adjusted accordingly in the SDK to support this new order). Therefore, there is no compatibility issue and the CI type is 0."
559,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",30,31,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>","<android.content.res.ResourcesImpl.ThemeImpl: TypedArray obtainStyledAttributes(Theme,AttributeSet,int[],int,int)>",0,"{
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        mAssets.applyStyle(mTheme, defStyleAttr, defStyleRes, parser, attrs, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        return array;
    }
}","{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    final XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.applyStyle(mTheme, defStyleAttr, defStyleRes, parser, attrs, array.mDataAddress, array.mIndicesAddress);
    array.mTheme = wrapper;
    array.mXml = parser;
    return array;
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The early version contains a synchronized block on the object `mKey` which has been removed in the late version, so this is a control dependency change (3). Additionally, the removal of the synchronized block is considered an ""Other statement changed"" (4) because it alters the thread-safety guarantee.","While the removal of the `synchronized` block affects the threading behavior of the method, it does not inherently lead to a different return value or different exception handling by the method itself. The functionality regarding how `array` is obtained and returned has not changed. Therefore, there is no Compatibility Issue as per the defined criteria (the API will behave the same in a single-threaded context). The only potential issue would be in a multi-threaded context, but that is not a direct result of how the values are returned or exceptions are handled by the method."
560,<android.content.Context: Context createFeatureContext(String)>,30,31,<android.content.Context: Context createFeatureContext(String)>,<android.content.Context: Context createFeatureContext(String)>,0,"{
    return createAttributionContext(featureId);
}","{
    return createContext(new ContextParams.Builder(getParams()).setAttributionTag(attributionTag).build());
}",1,"/**
 * @removed
 */
","/**
 * @removed
 */
",-1,"[@Deprecated, @NonNull]","[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling createAttributionContext(featureId) to calling createContext() with different parameters; this shows that a different dependent API is being used, so the code change type is 1,5.","The method implementation has shifted from one internal method to another with an altered way of creating the context, potentially leading to different return values or types. Therefore, the CI type is 1."
561,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,30,31,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // If we were actively using the last input method, then
                    // we would like to re-connect to the next input method.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && servedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // Check focus again in case that ""onWindowFocus"" is called before
                    // handling this message.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && canStartInput(servedView)) {
                        if (mCurRootView != null && mCurRootView.getImeFocusController().checkFocus(mRestartOnNextWindowFocus, false)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            mDelegate.startInput(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
        case MSG_REPORT_PRE_RENDERED:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.onPreRendered((EditorInfo) msg.obj);
                    }
                }
                return;
            }
        case MSG_APPLY_IME_VISIBILITY:
            {
                synchronized (mH) {
                    if (mImeInsetsConsumer != null) {
                        mImeInsetsConsumer.applyImeVisibility(msg.arg1 != 0);
                    }
                }
                return;
            }
        case MSG_UPDATE_ACTIVITY_VIEW_TO_SCREEN_MATRIX:
            {
                final float[] matrixValues = (float[]) msg.obj;
                final int bindSequence = msg.arg1;
                synchronized (mH) {
                    if (mBindSequence != bindSequence) {
                        return;
                    }
                    if (matrixValues == null || mActivityViewToScreenMatrix == null) {
                        // Either InputBoundResult#mActivityViewToScreenMatrixValues is null
                        // OR this app is unbound from the parent ActivityView. In this case,
                        // calling updateCursorAnchorInfo() isn't safe. Only clear the matrix.
                        mActivityViewToScreenMatrix = null;
                        return;
                    }
                    final float[] currentValues = new float[9];
                    mActivityViewToScreenMatrix.getValues(currentValues);
                    if (Arrays.equals(currentValues, matrixValues)) {
                        return;
                    }
                    mActivityViewToScreenMatrix.setValues(matrixValues);
                    if (mCursorAnchorInfo == null || mCurMethod == null || mServedInputConnectionWrapper == null) {
                        return;
                    }
                    final boolean isMonitoring = (mRequestUpdateCursorAnchorInfoMonitorMode & InputConnection.CURSOR_UPDATE_MONITOR) != 0;
                    if (!isMonitoring) {
                        return;
                    }
                    // IMS#updateCursorAnchorInfo() again.
                    try {
                        mCurMethod.updateCursorAnchorInfo(CursorAnchorInfo.createForAdditionalParentMatrix(mCursorAnchorInfo, mActivityViewToScreenMatrix));
                    } catch (RemoteException e) {
                        Log.w(TAG, ""IME died: "" + mCurId, e);
                    }
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        if (res.channel != null && res.channel != mCurChannel) {
                            res.channel.dispose();
                        }
                        return;
                    }
                    mRequestUpdateCursorAnchorInfoMonitorMode = REQUEST_UPDATE_CURSOR_ANCHOR_INFO_NONE;
                    setInputChannelLocked(res.channel);
                    // for @UnsupportedAppUsage
                    mCurMethod = res.method;
                    mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                    mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
                }
                startInputInner(StartInputReason.BOUND_TO_IMMS, null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                @UnbindReason final int reason = msg.arg2;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence + "" reason="" + InputMethodDebug.unbindReasonToString(reason));
                }
                final boolean startInput;
                synchronized (mH) {
                    if (mBindSequence != sequence) {
                        return;
                    }
                    clearBindingLocked();
                    // If we were actively using the last input method, then
                    // we would like to re-connect to the next input method.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && servedView.isFocused()) {
                        mServedConnecting = true;
                    }
                    startInput = mActive;
                }
                if (startInput) {
                    startInputInner(StartInputReason.UNBOUND_FROM_IMMS, null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                final boolean fullscreen = msg.arg2 != 0;
                final boolean reportToImeController = msg.obj != null && (boolean) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = fullscreen;
                    // Report active state to ImeFocusController to handle IME input
                    // connection lifecycle callback when it allowed.
                    final ImeFocusController controller = getFocusController();
                    final View rootView = mCurRootView != null ? mCurRootView.getView() : null;
                    if (controller != null && rootView != null && reportToImeController) {
                        rootView.post(() -> controller.onInteractiveChanged(active));
                        return;
                    }
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mRestartOnNextWindowFocus = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                    }
                    // Check focus again in case that ""onWindowFocus"" is called before
                    // handling this message.
                    final View servedView = getServedViewLocked();
                    if (servedView != null && canStartInput(servedView)) {
                        if (mCurRootView != null && mCurRootView.getImeFocusController().checkFocus(mRestartOnNextWindowFocus, false)) {
                            final int reason = active ? StartInputReason.ACTIVATED_BY_IMMS : StartInputReason.DEACTIVATED_BY_IMMS;
                            mDelegate.startInput(reason, null, 0, 0, 0);
                        }
                    }
                }
                return;
            }
        case MSG_SEND_INPUT_EVENT:
            {
                sendInputEventAndReportResultOnMainLooper((PendingEvent) msg.obj);
                return;
            }
        case MSG_TIMEOUT_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, true);
                return;
            }
        case MSG_FLUSH_INPUT_EVENT:
            {
                finishedInputEvent(msg.arg1, false, false);
                return;
            }
        case MSG_REPORT_FULLSCREEN_MODE:
            {
                final boolean fullscreen = msg.arg1 != 0;
                InputConnection ic = null;
                synchronized (mH) {
                    mFullscreenMode = fullscreen;
                    if (mServedInputConnectionWrapper != null) {
                        ic = mServedInputConnectionWrapper.getInputConnection();
                    }
                }
                if (ic != null) {
                    ic.reportFullscreenMode(fullscreen);
                }
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
562,<android.content.ClipDescription: String toString()>,30,31,<android.content.ClipDescription: String toString()>,<android.content.ClipDescription: String toString()>,0,"{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipDescription { "");
    toShortString(b);
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipDescription { "");
    toShortString(b, true);
    b.append("" }"");
    return b.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `toShortString` has been changed to include an additional parameter `toShortString(b, true)`. The change in the dependent method signature indicates the code change type is a combination of 4 (because the overall structure of the method doesn't change) and 5 (because it is a dependent API change).","As the implementation of `toShortString` is not provided and there's no information about the change in the behavior due to the modification, based only on the provided details, we cannot definitively conclude that there is a Compatibility Issue. Hence, we assume that if `toShortString` adheres to backward compatibility, the change in the dependent API should not introduce a CI, therefore the CI type is 0."
563,<android.content.pm.ShortcutManager: void disableShortcuts(List<String>)>,30,31,<android.content.pm.ShortcutManager: void disableShortcuts(List<String>)>,<android.content.pm.ShortcutManager: void disableShortcuts(List<String>)>,0,"{
    try {
        mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Disable pinned shortcuts.  For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Disable pinned shortcuts.  For more details, read
 * <a href=""/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts"">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method called within the try block is modified from mService.disableShortcuts(...) to getFutureOrThrow(mService.disableShortcuts(...)), indicating a change in a dependent API, hence the code change type is 5.","Despite the change in the invoked method, the public API's behavior in terms of exceptions thrown and potential return types (void in this case) remains unchanged. The handling of RemoteException is consistent in both versions, and since void methods don't return a value, there is no possibility of a different return value. Thus, there is no Compatibility Issue, and the CI type is 0."
564,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,30,31,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters)>,0,"{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */
","/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,5,0,"The change is that a new parameter 'mAttributionSource' is added to the method call mGatt.setPeriodicAdvertisingParameters(), so the code change type is 5.","Even though there is a change in the dependent method, this change does not affect the behavior of the API regarding its return value or the exceptions it raises. The method doesn't have a return statement (it returns void), and the exception handling for RemoteException remains the same. Therefore, there is no compatibility issue related to return values or exception handling, and the CI type is 0."
565,<android.speech.SpeechRecognizer: void destroy()>,30,31,<android.speech.SpeechRecognizer: void destroy()>,<android.speech.SpeechRecognizer: void destroy()>,0,"{
    if (mService != null) {
        try {
            mService.cancel(mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}","{
    if (mService != null) {
        try {
            mService.cancel(mListener, /*isShutdown*/
            true);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    mService = null;
    mPendingTasks.clear();
    mListener.mInternalListener = null;
}",1,"/**
 * Destroys the {@code SpeechRecognizer} object.
 */
","/**
 * Destroys the {@code SpeechRecognizer} object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementations of the early and late versions show multiple changes: the arguments of `mService.cancel` call changed reflecting the code change type 5 (Dependent API change) due to the change in parameters for the method call, an `if (mConnection != null)` block and the call to `mContext.unbindService(mConnection)` is removed indicating a 4 (Other statement changed) and 3 (Control dependency change), and `mConnection = null;` statement also got removed confirming a 4 (Other statement changed) type. These change types are not mutually exclusive so they are all applied here.","The late version of the code omits the call to `mContext.unbindService(mConnection)` which can affect the state of `mContext` by not unbinding the service and consequently affects `mConnection` handling too. This constitutes an issue where the object's state change in the late version can lead to a different behavior (CI type 1). Additionally, since `mConnection = null;` is also removed, the object `mConnection` retains a reference that it did not in the early version leading to potential different values being returned or object states (CI type 1)."
567,<android.app.Notification.Action: Action clone()>,30,31,<android.app.Notification.Action: Action clone()>,<android.app.Notification.Action: Action clone()>,0,"{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies(), getSemanticAction(), isContextual());
}","{
    return new Action(getIcon(), title, // safe to alias
    actionIntent, mExtras == null ? new Bundle() : new Bundle(mExtras), getRemoteInputs(), getAllowGeneratedReplies(), getSemanticAction(), isContextual(), isAuthenticationRequired());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of Action in the return statement has been changed, adding a new parameter isAuthenticationRequired, so the code change type is 1,5.","The addition of a new parameter to the constructor can lead to a different object being returned, thus the CI type is 1."
568,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>",30,31,"<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>","<android.accessibilityservice.AccessibilityService.MagnificationController: boolean setScale(float,boolean)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, scale, Float.NaN, Float.NaN, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setMagnificationScaleAndCenter(mDisplayId, scale, Float.NaN, Float.NaN, animate);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 8
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 */
","/**
 * Sets the magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will have
 * no effect and return {@code false}.
 *
 * @param scale the magnification scale to set, must be >= 1 and <= 8
 * @param animate {@code true} to animate from the current scale or
 * {@code false} to set the scale immediately
 * @return {@code true} on success, {@code false} on failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call inside the implementation has changed the parameter from 'mService.mConnectionId' to 'mService'. This comprises a change in dependent API, so the code change type is 5.","Even though there is a change in the dependent API call, the behavior of this method (`setScale`) itself doesn't change; it still handles the connection the same way by getting it from `getConnection()` and still returns a boolean result from `setMagnificationScaleAndCenter()`. Thus, there seems to be no compatibility issue due to this change, and the CI type is 0."
570,<android.app.admin.DevicePolicyManager: Set<String> getAlwaysOnVpnLockdownWhitelist(ComponentName)>,30,31,<android.app.admin.DevicePolicyManager: Set<String> getAlwaysOnVpnLockdownWhitelist(ComponentName)>,<android.app.admin.DevicePolicyManager: Set<String> getAlwaysOnVpnLockdownWhitelist(ComponentName)>,0,"{
    throwIfParentInstance(""getAlwaysOnVpnLockdownWhitelist"");
    if (mService != null) {
        try {
            final List<String> whitelist = mService.getAlwaysOnVpnLockdownWhitelist(admin);
            return whitelist == null ? null : new HashSet<>(whitelist);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}","{
    throwIfParentInstance(""getAlwaysOnVpnLockdownWhitelist"");
    if (mService != null) {
        try {
            final List<String> allowlist = mService.getAlwaysOnVpnLockdownAllowlist(admin);
            return allowlist == null ? null : new HashSet<>(allowlist);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Called by device or profile owner to query the set of packages that are allowed to access
 * the network directly when always-on VPN is in lockdown mode but not connected. Returns
 * {@code null} when always-on VPN is not active or not in lockdown mode.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 *
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 *
 * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)
 */
","/**
 * Called by device or profile owner to query the set of packages that are allowed to access
 * the network directly when always-on VPN is in lockdown mode but not connected. Returns
 * {@code null} when always-on VPN is not active or not in lockdown mode.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 *
 * @throws SecurityException if {@code admin} is not a device or a profile owner.
 *
 * @see #setAlwaysOnVpnPackage(ComponentName, String, boolean, Set)
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The change is within a call to a dependent API from getAlwaysOnVpnLockdownWhitelist(admin) to getAlwaysOnVpnLockdownAllowlist(admin), which indicates a change in the internal implementation of the dependent service API. The outer method's signature and its logic of exception handling and return remain the same, so the code change type is 5.","There is no Compatibility Issue since the method's contract is still the same: it returns a Set<String> or null in the same conditions, and exception handling is unchanged. The change in the dependent API name does not inherently indicate that the behavior of this method has changed from the caller's perspective; it might be a simple rename of the method without changing its behavior. Thus, no CI is detected."
571,<android.companion.AssociationRequest: int hashCode()>,30,31,<android.companion.AssociationRequest: int hashCode()>,<android.companion.AssociationRequest: int hashCode()>,0,"{
    return Objects.hash(mSingleDevice, mDeviceFilters);
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + Boolean.hashCode(mSingleDevice);
    _hash = 31 * _hash + Objects.hashCode(mDeviceFilters);
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfile);
    _hash = 31 * _hash + Objects.hashCode(mCallingPackage);
    _hash = 31 * _hash + Objects.hashCode(mDeviceProfilePrivilegesDescription);
    _hash = 31 * _hash + Long.hashCode(mCreationTime);
    _hash = 31 * _hash + Boolean.hashCode(mSkipPrompt);
    return _hash;
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode method implementation has substantially changed from using Objects.hash to manually constructing the hash with a series of operations, and new fields have been included in the hash calculation. Thus, the changes are of types 1,4.","The change in hashCode method implementation will result in a different hash value being returned, which is a compatibility issue of type 1, since the contract of the hashCode function is to return the same value for the same object, and now it might return a different value due to the different algorithm and additional fields being considered."
572,<android.app.Activity: boolean isImmersive()>,30,31,<android.app.Activity: boolean isImmersive()>,<android.app.Activity: boolean isImmersive()>,0,"{
    try {
        return ActivityTaskManager.getService().isImmersive(mToken);
    } catch (RemoteException e) {
        return false;
    }
}","{
    return ActivityClient.getInstance().isImmersive(mToken);
}",1,"/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
","/**
 * Bit indicating that this activity is ""immersive"" and should not be
 * interrupted by notifications if possible.
 *
 * This value is initially set by the manifest property
 * <code>android:immersive</code> but may be changed at runtime by
 * {@link #setImmersive}.
 *
 * @see #setImmersive(boolean)
 * @see android.content.pm.ActivityInfo#FLAG_IMMERSIVE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called within the 'return' statement has changed from ActivityTaskManager.getService().isImmersive() to ActivityClient.getInstance().isImmersive(), and the exception handling has been removed. This indicates a change in the dependent API used (5) and a change in the return statement (1).","The removal of the try-catch block that was previously handling RemoteException and the use of a different object and method for the implementation could result in this API throwing an exception where it previously would not, or returning a different value. Therefore, it presents potential Compatibility Issues due to different return values or types (1)."
573,<android.text.format.DateUtils: String getAMPMString(int)>,30,31,<android.text.format.DateUtils: String getAMPMString(int)>,<android.text.format.DateUtils: String getAMPMString(int)>,0,"{
    return LocaleData.get(Locale.getDefault()).amPm[ampm - Calendar.AM];
}","{
    String[] amPm = DateFormat.getIcuDateFormatSymbols(Locale.getDefault()).getAmPmStrings();
    return amPm[ampm - Calendar.AM];
}",1,"/**
 * Return a localized string for AM or PM.
 * @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.
 * @throws IndexOutOfBoundsException if the ampm is out of bounds.
 * @return Localized version of ""AM"" or ""PM"".
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
","/**
 * Return a localized string for AM or PM.
 * @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.
 * @throws IndexOutOfBoundsException if the ampm is out of bounds.
 * @return Localized version of ""AM"" or ""PM"".
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,5,1,"The method used to retrieve the AM/PM strings has changed from LocaleData.get(...).amPm to DateFormat.getIcuDateFormatSymbols(...).getAmPmStrings(), indicating a change in the dependent API, so the code change type is 5.","Since the method to get the AM/PM strings has been altered, which constitutes a change in a dependent API, there might be a difference in the returned value, especially if the new method returns a different set of strings or in a different order. Therefore, the CI type is 1."
574,"<android.app.ContextImpl: int checkPermission(String,int,int)>",30,31,"<android.app.ContextImpl: int checkPermission(String,int,int)>","<android.app.ContextImpl: int checkPermission(String,int,int)>",0,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    return PermissionManager.checkPermission(permission, pid, uid);
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    if (mParams.isRenouncedPermission(permission) && pid == android.os.Process.myPid() && uid == android.os.Process.myUid()) {
        Log.v(TAG, ""Treating renounced permission "" + permission + "" as denied"");
        return PERMISSION_DENIED;
    }
    return PermissionManager.checkPermission(permission, pid, uid);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"An additional control dependency (an if condition) has been introduced that checks for renounced permissions and potentially logs a message before performing the permission check. Therefore, the change type is 3, which is a control dependency change.","The added if condition does not introduce a new behavior in terms of the API's return values or the exceptions it might throw. It will only return PERMISSION_DENIED when the conditions in the if statement are met, which is an expected behavior for permission checks. Therefore, there is no Compatibility Issue since the conditions (the same process and user ID) are specific and related to renounced permissions, so it won't affect the return values or exceptions in other general scenarios. The original behavior of returning the result of PermissionManager.checkPermission(permission, pid, uid) is preserved when the new conditions are not met. Hence, the added control path only adds a specific check without altering the existing behavior, and there's no Compatibility Issue."
575,"<android.app.ActivityThread.ApplicationThread: void dumpGfxInfo(ParcelFileDescriptor,String[])>",30,31,"<android.app.ActivityThread.ApplicationThread: void dumpGfxInfo(ParcelFileDescriptor,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpGfxInfo(ParcelFileDescriptor,String[])>",0,"{
    nDumpGraphicsInfo(pfd.getFileDescriptor());
    WindowManagerGlobal.getInstance().dumpGfxInfo(pfd.getFileDescriptor(), args);
    IoUtils.closeQuietly(pfd);
}","{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = pfd.dup();
        data.token = null;
        data.args = args;
        sendMessage(H.DUMP_GFXINFO, data, 0, 0, true);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpGfxInfo failed"", e);
    } finally {
        IoUtils.closeQuietly(pfd);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The implementation of the method has completely changed from direct method calls and resource management to using a message handling system with a `try` block for resource duplication and a `catch` finally` block for exception handling and resource closure. There is a change in exception handling, addition of the control structure (`try-catch-finally`), creation of a new object (`DumpComponentInfo data`), and new method calls to sendMessage. Also, the dependent API nDumpGraphicsInfo is no longer called, and a new dependent API (`pfd.dup()`) is used. Thus the change type categories are 1,2,3,4,5.","There are potential compatibility issues due to a different method of performing the operation and handling exceptions, as well as a different control flow. The early version did not catch exceptions but now does, potentially leading to different behavior when exceptions occur. Finally, it may introduce a return value difference due to the data.fd potentially being a different FileDescriptor after the `pfd.dup()` call. The CI types are 1,2."
576,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,30,31,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,<android.hardware.biometrics.BiometricManager: int canAuthenticate()>,0,"{
    return canAuthenticate(Authenticators.BIOMETRIC_WEAK);
}","{
    @BiometricError final int result = canAuthenticate(mContext.getUserId(), Authenticators.BIOMETRIC_WEAK);
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED, false, /* isAllowedAuthenticatorsSet */
    Authenticators.EMPTY_SET, result);
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_DEPRECATED_API_USED, AUTH_DEPRECATED_APIUSED__DEPRECATED_API__API_BIOMETRIC_MANAGER_CAN_AUTHENTICATE, mContext.getApplicationInfo().uid, mContext.getApplicationInfo().targetSdkVersion);
    return result;
}",1,"/**
 * Determine if biometrics can be used. In other words, determine if
 * {@link BiometricPrompt} can be expected to be shown (hardware available, templates enrolled,
 * user-enabled). This is the equivalent of {@link #canAuthenticate(int)} with
 * {@link Authenticators#BIOMETRIC_WEAK}
 *
 * @return {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any strong
 * biometrics enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are currently
 * supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if a strong biometric can currently
 * be used (enrolled and available).
 *
 * @deprecated See {@link #canAuthenticate(int)}.
 */
","/**
 * Determine if biometrics can be used. In other words, determine if
 * {@link BiometricPrompt} can be expected to be shown (hardware available, templates enrolled,
 * user-enabled). This is the equivalent of {@link #canAuthenticate(int)} with
 * {@link Authenticators#BIOMETRIC_WEAK}
 *
 * @return {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any strong
 * biometrics enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are currently
 * supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if a strong biometric can currently
 * be used (enrolled and available).
 *
 * @deprecated See {@link #canAuthenticate(int)}.
 */
",-1,"[@Deprecated, @RequiresPermission(USE_BIOMETRIC), @BiometricError]","[@Deprecated, @RequiresPermission(USE_BIOMETRIC), @BiometricError]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement and the dependent API have changed. In the early version, the `canAuthenticate` method is called without parameters. In the late version, the `canAuthenticate` method is called with additional parameters (`mContext.getUserId()`), and there are additional method calls for logging (`FrameworkStatsLog.write(...)`). The variable used in the return statement has changed from a direct method call to storing the result in a variable and then returning it. This change encompasses a direct change to the return statement, the use of additional statements, and a change in the dependent API, hence the change type is 1,4,5.","There is a behavioral change due to the change in the parameters of the `canAuthenticate` method call and the additional logging statements. The logging does not directly affect the return type but does represent additional operations which happen as a side effect of calling `canAuthenticate`. The use of a different canAuthenticate API which now takes parameters can lead to the method returning a different result, because it is now user-specific authentication. Additionally, the introduction of new functionality for logging usage stats indicates the method has additional side effects, potentially causing different results. Therefore, the CI type is 1."
577,<android.service.autofill.SaveInfo.Builder: Builder setValidator(Validator)>,30,31,<android.service.autofill.SaveInfo.Builder: Builder setValidator(Validator)>,<android.service.autofill.SaveInfo.Builder: Builder setValidator(Validator)>,0,"{
    throwIfDestroyed();
    Preconditions.checkArgument((validator instanceof InternalValidator), ""not provided by Android System: "" + validator);
    mValidator = (InternalValidator) validator;
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((validator instanceof InternalValidator), ""not provided by Android System: %s"", validator);
    mValidator = (InternalValidator) validator;
    return this;
}",1,"/**
 * Sets an object used to validate the user input - if the input is not valid, the
 * autofill save UI is not shown.
 *
 * <p>Typically used to validate credit card numbers. Examples:
 *
 * <p>Validator for a credit number that must have exactly 16 digits:
 *
 * <pre class=""prettyprint"">
 * Validator validator = new RegexValidator(ccNumberId, Pattern.compile(""""^\\d{16}$""))
 * </pre>
 *
 * <p>Validator for a credit number that must pass a Luhn checksum and either have
 * 16 digits, or 15 digits starting with 108:
 *
 * <pre class=""prettyprint"">
 * import static android.service.autofill.Validators.and;
 * import static android.service.autofill.Validators.or;
 *
 * Validator validator =
 * and(
 * new LuhnChecksumValidator(ccNumberId),
 * or(
 * new RegexValidator(ccNumberId, Pattern.compile(""^\\d{16}$"")),
 * new RegexValidator(ccNumberId, Pattern.compile(""^108\\d{12}$""))
 * )
 * );
 * </pre>
 *
 * <p><b>Note:</b> the example above is just for illustrative purposes; the same validator
 * could be created using a single regex for the {@code OR} part:
 *
 * <pre class=""prettyprint"">
 * Validator validator =
 * and(
 * new LuhnChecksumValidator(ccNumberId),
 * new RegexValidator(ccNumberId, Pattern.compile(""""^(\\d{16}|108\\d{12})$""))
 * );
 * </pre>
 *
 * <p>Validator for a credit number contained in just 4 fields and that must have exactly
 * 4 digits on each field:
 *
 * <pre class=""prettyprint"">
 * import static android.service.autofill.Validators.and;
 *
 * Validator validator =
 * and(
 * new RegexValidator(ccNumberId1, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId2, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId3, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId4, Pattern.compile(""^\\d{4}$""))
 * );
 * </pre>
 *
 * @param validator an implementation provided by the Android System.
 * @return this builder.
 *
 * @throws IllegalArgumentException if {@code validator} is not a class provided
 * by the Android System.
 */
","/**
 * Sets an object used to validate the user input - if the input is not valid, the
 * autofill save UI is not shown.
 *
 * <p>Typically used to validate credit card numbers. Examples:
 *
 * <p>Validator for a credit number that must have exactly 16 digits:
 *
 * <pre class=""prettyprint"">
 * Validator validator = new RegexValidator(ccNumberId, Pattern.compile(""""^\\d{16}$""))
 * </pre>
 *
 * <p>Validator for a credit number that must pass a Luhn checksum and either have
 * 16 digits, or 15 digits starting with 108:
 *
 * <pre class=""prettyprint"">
 * import static android.service.autofill.Validators.and;
 * import static android.service.autofill.Validators.or;
 *
 * Validator validator =
 * and(
 * new LuhnChecksumValidator(ccNumberId),
 * or(
 * new RegexValidator(ccNumberId, Pattern.compile(""^\\d{16}$"")),
 * new RegexValidator(ccNumberId, Pattern.compile(""^108\\d{12}$""))
 * )
 * );
 * </pre>
 *
 * <p><b>Note:</b> the example above is just for illustrative purposes; the same validator
 * could be created using a single regex for the {@code OR} part:
 *
 * <pre class=""prettyprint"">
 * Validator validator =
 * and(
 * new LuhnChecksumValidator(ccNumberId),
 * new RegexValidator(ccNumberId, Pattern.compile(""""^(\\d{16}|108\\d{12})$""))
 * );
 * </pre>
 *
 * <p>Validator for a credit number contained in just 4 fields and that must have exactly
 * 4 digits on each field:
 *
 * <pre class=""prettyprint"">
 * import static android.service.autofill.Validators.and;
 *
 * Validator validator =
 * and(
 * new RegexValidator(ccNumberId1, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId2, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId3, Pattern.compile(""^\\d{4}$"")),
 * new RegexValidator(ccNumberId4, Pattern.compile(""^\\d{4}$""))
 * );
 * </pre>
 *
 * @param validator an implementation provided by the Android System.
 * @return this builder.
 *
 * @throws IllegalArgumentException if {@code validator} is not a class provided
 * by the Android System.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is only in string formatting in the method Preconditions.checkArgument, from string concatenation to using format specifiers, so the change type is 4.","There is no compatibility issue as the behavior of the method has not changed; the logic and the return type remain the same, and the exception handling does not change. The change only affects the format of the error message, not the functional behavior."
580,<android.view.View: void updateDragShadow(DragShadowBuilder)>,30,31,<android.view.View: void updateDragShadow(DragShadowBuilder)>,<android.view.View: void updateDragShadow(DragShadowBuilder)>,0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""updateDragShadow"");
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""updateDragShadow called on a detached view."");
        return;
    }
    if (mAttachInfo.mDragToken != null) {
        try {
            Canvas canvas = mAttachInfo.mDragSurface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
            }
        } catch (Exception e) {
            Log.e(VIEW_LOG_TAG, ""Unable to update drag shadow"", e);
        }
    } else {
        Log.e(VIEW_LOG_TAG, ""No active drag"");
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""updateDragShadow"");
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""updateDragShadow called on a detached view."");
        return;
    }
    if (mAttachInfo.mDragToken != null) {
        try {
            Canvas canvas = isHardwareAccelerated() ? mAttachInfo.mDragSurface.lockHardwareCanvas() : mAttachInfo.mDragSurface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                mAttachInfo.mDragSurface.unlockCanvasAndPost(canvas);
            }
        } catch (Exception e) {
            Log.e(VIEW_LOG_TAG, ""Unable to update drag shadow"", e);
        }
    } else {
        Log.e(VIEW_LOG_TAG, ""No active drag"");
    }
}",1,"/**
 * Updates the drag shadow for the ongoing drag and drop operation.
 *
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * new drag shadow.
 */
","/**
 * Updates the drag shadow for the ongoing drag and drop operation.
 *
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * new drag shadow.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in how the canvas is obtained for drawing depending on whether hardware acceleration is enabled or not. The early version always uses `mAttachInfo.mDragSurface.lockCanvas(null)`, while the late version selects between `mAttachInfo.mDragSurface.lockHardwareCanvas()` and `mAttachInfo.mDragSurface.lockCanvas(null)` depending on `isHardwareAccelerated()`. This change is reflected as both an ""Other statement changed"" (4) due to the method call change and a ""Dependent API changed"" (5) since the method `lockCanvas` or `lockHardwareCanvas` used depends on the return value of `isHardwareAccelerated()`.","No Compatibility Issue arises because, despite the changes in how the canvas is acquired, these changes do not directly affect the value returned by the method `updateDragShadow` as it is a void method, nor do they introduce different exceptions being thrown. The behaviour is effectively the same as before because all that changes is the type of canvas that might be used internally, provided that the operation succeeds. If there's a failure, the catch block will handle it as before. Therefore, the CI type is 0."
581,"<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>",30,31,"<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>",0,"{
    return new AppWidgetHostView(context, mOnClickHandler);
}","{
    return new AppWidgetHostView(context, mInteractionHandler);
}",1,"/**
 * Called to create the AppWidgetHostView.  Override to return a custom subclass if you
 * need it.  {@more}
 */
","/**
 * Called to create the AppWidgetHostView.  Override to return a custom subclass if you
 * need it.  {@more}
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The constructor argument changed from mOnClickHandler to mInteractionHandler within the new statement. Since only the name of the argument used in the constructor of AppWidgetHostView has changed, and assuming mOnClickHandler and mInteractionHandler serve the same purpose and type (as there's no context to suggest otherwise), the code change type is 5.","There is no Compatibility Issue indicated by this change. Even though the constructor argument has changed, it does not necessarily imply a change in behavior or a difference in the returned value's type. Assuming mOnClickHandler and mInteractionHandler are functionally equivalent, they would not cause a CI. If they are not equivalent, there would need to be more information to determine if a CI exists based on their functionality. However, with the given data, we assume no CI arises."
584,<android.os.VibrationEffect.Composition: VibrationEffect compose()>,30,31,<android.os.VibrationEffect.Composition: VibrationEffect compose()>,<android.os.VibrationEffect.Composition: VibrationEffect compose()>,0,"{
    if (mEffects.isEmpty()) {
        throw new IllegalStateException(""Composition must have at least one element to compose."");
    }
    return new VibrationEffect.Composed(mEffects);
}","{
    if (mSegments.isEmpty()) {
        throw new IllegalStateException(""Composition must have at least one element to compose."");
    }
    VibrationEffect effect = new Composed(mSegments, mRepeatIndex);
    effect.validate();
    return effect;
}",1,"/**
 * Compose all of the added primitives together into a single {@link VibrationEffect}.
 *
 * The {@link Composition} object is still valid after this call, so you can continue adding
 * more primitives to it and generating more {@link VibrationEffect}s by calling this method
 * again.
 *
 * @return The {@link VibrationEffect} resulting from the composition of the primitives.
 */
","/**
 * Compose all of the added primitives together into a single {@link VibrationEffect}.
 *
 * The {@link Composition} object is still valid after this call, so you can continue adding
 * more primitives to it and generating more {@link VibrationEffect}s by calling this method
 * again.
 *
 * @return The {@link VibrationEffect} resulting from the composition of the primitives.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation in the late version checks a different collection (`mSegments` vs `mEffects`), has added a new method call (`effect.validate()`), and constructs a `VibrationEffect` with different parameters (`mSegments` and `mRepeatIndex` vs `mEffects`). Thus, the code change types are 1, 3, and 4.","The change in the collection being checked (from `mEffects` to `mSegments`) and the additional call to `effect.validate()` which could potentially throw an exception not present in the early version, as well as the different parameters used to construct the `VibrationEffect` (`mSegments, mRepeatIndex`), could lead to a situation where the late version of this API returns a different `VibrationEffect` object than the early version, or throws a different exception, leading to a CI type of 1."
585,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,30,31,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,<android.view.WindowInsets: WindowInsets consumeSystemWindowInsets()>,0,"{
    return new WindowInsets(null, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this), mCompatInsetsTypes, mCompatIgnoreVisibility);
}","{
    return new WindowInsets(null, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this), mRoundedCorners, mPrivacyIndicatorBounds, mCompatInsetsTypes, mCompatIgnoreVisibility);
}",1,"/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
","/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
",-1,"[@Deprecated, @NonNull]","[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for WindowInsets() in the return statement has changed with additional parameters mRoundedCorners and mPrivacyIndicatorBounds being passed in the later version. This indicates a change in dependent API as well, hence the code change types are 1,5.","The change to the constructor call results in a potential change in the return value as more data is being initialized in the WindowInsets object. Therefore, a CI due to the potential for different return values is present, and the CI type is 1."
586,<android.content.pm.ShortcutManager: void removeAllDynamicShortcuts()>,30,31,<android.content.pm.ShortcutManager: void removeAllDynamicShortcuts()>,<android.content.pm.ShortcutManager: void removeAllDynamicShortcuts()>,0,"{
    try {
        mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Delete all dynamic shortcuts from the caller app.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Delete all dynamic shortcuts from the caller app.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from a direct call to mService.removeAllDynamicShortcuts to invoking getFutureOrThrow with the same method as parameter; this implies a change in how the result of the mService.removeAllDynamicShortcuts method is handled. The change is the introduction of a method call to getFutureOrThrow, which is a dependent API. Hence, the change types are 4 and 5.","While there is a change in the method invocation, there is no compatibility issue introduced since the outcome for the caller and how the RemoteException is handled remains consistent. The method still does not return any value or throw a different exception; thus, the caller's experience is unaffected. Therefore, No Compatibility Issue is detected."
587,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFile(ParcelFileDescriptor,long,int,String,String,long,long,int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFile(data, size, type, domain, path, mode, mtime);
    } catch (IOException e) {
        Log.d(TAG, ""onRestoreFile ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw new RuntimeException(e);
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        // And bring live SharedPreferences instances up to date
        reloadSharedPreferences();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There are no code changes between the early and late versions of the method implementation.,No Compatibility Issue could arise because there is no change in the code.
589,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",30,31,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(int,int[])>",0,"{
    return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, resId);
}","{
    synchronized (mLock) {
        return mThemeImpl.obtainStyledAttributes(this, null, attrs, 0, resId);
    }
}",1,"/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resId The desired style resource.
 * @param attrs The desired attributes in the style. These attribute IDs must be sorted in
 * ascending order.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
","/**
 * Return a TypedArray holding the values defined by the style
 * resource <var>resid</var> which are listed in <var>attrs</var>.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * @param resId The desired style resource.
 * @param attrs The desired attributes in the style. These attribute IDs must be sorted in
 * ascending order.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(AttributeSet, int[], int, int)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"The code change is the introduction of a synchronized block around the return statement, which is a change in the control dependency (type 3) and other statement (type 4), but it does not affect the return value or exception handling.",The introduction of the synchronized block does not result in a Compatibility Issue since it doesn't change the behavior of what the method returns or the exceptions it may throw; it just adds thread safety.
590,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle,Map<String, Integer>)>",30,31,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle,Map<String, Integer>)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle,Map<String, Integer>)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitlyWithVisibility(account, password, extras, visibility);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitlyWithVisibility(account, password, extras, visibility, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Adds an account directly to the AccountManager. Additionally it specifies Account visibility
 * for given list of packages.
 * <p>
 * Normally used by sign-up wizards associated with authenticators, not directly by
 * applications.
 * <p>
 * Calling this method does not update the last authenticated timestamp, referred by
 * {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>
 * This method requires the caller to have a signature match with the authenticator that owns
 * the specified account.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param extras String values to use for the account's userdata, null for none
 * @param visibility Map from packageName to visibility values which will be set before account
 * is added. See {@link #getAccountVisibility} for possible values.
 *
 * @return True if the account was successfully added, false if the account already exists, the
 * account is null, or another error occurs.
 */
","/**
 * Adds an account directly to the AccountManager. Additionally it specifies Account visibility
 * for given list of packages.
 * <p>
 * Normally used by sign-up wizards associated with authenticators, not directly by
 * applications.
 * <p>
 * Calling this method does not update the last authenticated timestamp, referred by
 * {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>
 * This method requires the caller to have a signature match with the authenticator that owns
 * the specified account.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param extras String values to use for the account's userdata, null for none
 * @param visibility Map from packageName to visibility values which will be set before account
 * is added. See {@link #getAccountVisibility} for possible values.
 *
 * @return True if the account was successfully added, false if the account already exists, the
 * account is null, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API `addAccountExplicitlyWithVisibility` has an additional parameter `mContext.getOpPackageName()` in the late version, which is not present in the early version. Thus, the code change type is 5.","The addition of a new parameter to the dependent API `addAccountExplicitlyWithVisibility` means that the behaviour of the API may change as it is now providing more information to the method, potentially causing it to return a different result. Therefore, this can cause a Compatibility Issue of type 1."
591,<android.hardware.biometrics.BiometricManager: int canAuthenticate(int)>,30,31,<android.hardware.biometrics.BiometricManager: int canAuthenticate(int)>,<android.hardware.biometrics.BiometricManager: int canAuthenticate(int)>,0,"{
    return canAuthenticate(mContext.getUserId(), authenticators);
}","{
    @BiometricError final int result = canAuthenticate(mContext.getUserId(), authenticators);
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_MANAGER_CAN_AUTHENTICATE_INVOKED, true, /* isAllowedAuthenticatorsSet */
    authenticators, result);
    return result;
}",1,"/**
 * Determine if any of the provided authenticators can be used. In other words, determine if
 * {@link BiometricPrompt} can be expected to be shown (hardware available, templates enrolled,
 * user-enabled).
 *
 * For biometric authenticators, determine if the device can currently authenticate with at
 * least the requested strength. For example, invoking this API with
 * {@link Authenticators#BIOMETRIC_WEAK} on a device that currently only has
 * {@link Authenticators#BIOMETRIC_STRONG} enrolled will return {@link #BIOMETRIC_SUCCESS}.
 *
 * Invoking this API with {@link Authenticators#DEVICE_CREDENTIAL} can be used to determine
 * if the user has a PIN/Pattern/Password set up.
 *
 * @param authenticators bit field consisting of constants defined in {@link Authenticators}.
 * If multiple authenticators are queried, a logical OR will be applied.
 * For example, if {@link Authenticators#DEVICE_CREDENTIAL} |
 * {@link Authenticators#BIOMETRIC_STRONG} is queried and only
 * {@link Authenticators#DEVICE_CREDENTIAL} is set up, this API will
 * return {@link #BIOMETRIC_SUCCESS}
 *
 * @return {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any of the
 * requested authenticators enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are
 * currently supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if one of the requested
 * authenticators can currently be used (enrolled and available).
 */
","/**
 * Determine if any of the provided authenticators can be used. In other words, determine if
 * {@link BiometricPrompt} can be expected to be shown (hardware available, templates enrolled,
 * user-enabled).
 *
 * For biometric authenticators, determine if the device can currently authenticate with at
 * least the requested strength. For example, invoking this API with
 * {@link Authenticators#BIOMETRIC_WEAK} on a device that currently only has
 * {@link Authenticators#BIOMETRIC_STRONG} enrolled will return {@link #BIOMETRIC_SUCCESS}.
 *
 * Invoking this API with {@link Authenticators#DEVICE_CREDENTIAL} can be used to determine
 * if the user has a PIN/Pattern/Password set up.
 *
 * @param authenticators bit field consisting of constants defined in {@link Authenticators}.
 * If multiple authenticators are queried, a logical OR will be applied.
 * For example, if {@link Authenticators#DEVICE_CREDENTIAL} |
 * {@link Authenticators#BIOMETRIC_STRONG} is queried and only
 * {@link Authenticators#DEVICE_CREDENTIAL} is set up, this API will
 * return {@link #BIOMETRIC_SUCCESS}
 *
 * @return {@link #BIOMETRIC_ERROR_NONE_ENROLLED} if the user does not have any of the
 * requested authenticators enrolled, or {@link #BIOMETRIC_ERROR_HW_UNAVAILABLE} if none are
 * currently supported/enabled. Returns {@link #BIOMETRIC_SUCCESS} if one of the requested
 * authenticators can currently be used (enrolled and available).
 */
",-1,"[@RequiresPermission(USE_BIOMETRIC), @BiometricError]","[@RequiresPermission(USE_BIOMETRIC), @BiometricError]",-1,-1,-1,-1,-1,-1,4,0,"In the late version, the method now logs an event to FrameworkStatsLog before returning, which represents a change of type 4 (Other statement changed).","There is no Compatibility Issue here as the statement that was added doesn't affect the return value or the exceptions being thrown by the method; it is an additional logging operation. The actual result returned from the method remains consistent, as the same canAuthenticate method is being invoked with the same parameters."
592,"<android.app.Activity: void overridePendingTransition(int,int)>",30,31,"<android.app.Activity: void overridePendingTransition(int,int)>","<android.app.Activity: void overridePendingTransition(int,int)>",0,"{
    try {
        ActivityTaskManager.getService().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
    } catch (RemoteException e) {
    }
}","{
    ActivityClient.getInstance().overridePendingTransition(mToken, getPackageName(), enterAnim, exitAnim);
}",1,"/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
","/**
 * Call immediately after one of the flavors of {@link #startActivity(Intent)}
 * or {@link #finish} to specify an explicit transition animation to
 * perform next.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#JELLY_BEAN} an alternative
 * to using this with starting activities is to supply the desired animation
 * information through a {@link ActivityOptions} bundle to
 * {@link #startActivity(Intent, Bundle)} or a related function.  This allows
 * you to specify a custom animation even when starting an activity from
 * outside the context of the current top activity.
 *
 * @param enterAnim A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitAnim A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method used to perform the action has changed from ActivityTaskManager.getService().overridePendingTransition() to ActivityClient.getInstance().overridePendingTransition(), hence the dependent API has changed, so the code change type is 5.","There are no changes in the return type or the exception handling of the method; therefore, no compatibility issue arises from this, and the CI type is 0."
594,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues,Bundle)>",30,31,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues,Bundle)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues,Bundle)>",0,"{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, mAttributionTag, url, initialValues, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    beforeRemote();
    try {
        return mContentProvider.insert(mAttributionSource, url, initialValues, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed the argument passed to mContentProvider.insert() from two separate arguments (mPackageName, mAttributionTag) to a single mAttributionSource. This change is of type 5, indicating a Dependent API change. ","There is no Compatibility Issue as there's no change in the control flow, no new exceptions are thrown, the return type remains the same, and the exception handling has not changed. The change is internal, assuming that mAttributionSource has been constructed correctly to represent the same data as the combination of mPackageName and mAttributionTag."
595,<android.bluetooth.BluetoothAdapter: String getAddress()>,30,31,<android.bluetooth.BluetoothAdapter: String getAddress()>,<android.bluetooth.BluetoothAdapter: String getAddress()>,0,"{
    try {
        return mManagerService.getAddress();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    try {
        return mManagerService.getAddress(mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the hardware address of the local Bluetooth adapter.
 * <p>For example, ""00:11:22:AA:BB:CC"".
 *
 * @return Bluetooth hardware address as string
 */
","/**
 * Returns the hardware address of the local Bluetooth adapter.
 * <p>For example, ""00:11:22:AA:BB:CC"".
 *
 * @return Bluetooth hardware address as string
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(allOf = { android.Manifest.permission.BLUETOOTH_CONNECT, android.Manifest.permission.LOCAL_MAC_ADDRESS })]",-1,-1,-1,-1,-1,-1,"1,5",0,"The method `mManagerService.getAddress()` has been changed to `mManagerService.getAddress(mAttributionSource)` by adding a new parameter. This indicates that a dependent API has changed. Besides, the method signature and exception handling remain the same, and no new return statement has been added or deleted. Therefore, the code change types are 1 for the return statement change (as the return value depends on a method call that now takes a parameter) and 5 for the dependent API changed.","Even though there's a change in the dependent API, it doesn't lead to a compatibility issue in terms of different return types or values since the method still returns the same type, and it's not inherently clear if the additional parameter will change the return behavior of `mManagerService.getAddress()`. Also, the exception handling remains the same, and the method ultimately falls back to returning `null` if an exception occurs. Therefore, there's no compatibility issue categorized as 1 or 2. The behavior in terms of what is returned or any exceptions that may be thrown does not appear to change."
596,<android.app.ApplicationExitInfo: String toString()>,30,31,<android.app.ApplicationExitInfo: String toString()>,<android.app.ApplicationExitInfo: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""ApplicationExitInfo(timestamp="");
    sb.append(new SimpleDateFormat().format(new Date(mTimestamp)));
    sb.append("" pid="").append(mPid);
    sb.append("" realUid="").append(mRealUid);
    sb.append("" packageUid="").append(mPackageUid);
    sb.append("" definingUid="").append(mDefiningUid);
    sb.append("" user="").append(UserHandle.getUserId(mPackageUid));
    sb.append("" process="").append(mProcessName);
    sb.append("" reason="").append(mReason).append("" ("").append(reasonCodeToString(mReason)).append("")"");
    sb.append("" status="").append(mStatus);
    sb.append("" importance="").append(mImportance);
    sb.append("" pss="");
    DebugUtils.sizeValueToString(mPss << 10, sb);
    sb.append("" rss="");
    DebugUtils.sizeValueToString(mRss << 10, sb);
    sb.append("" description="").append(mDescription);
    sb.append("" state="").append(ArrayUtils.isEmpty(mState) ? ""empty"" : Integer.toString(mState.length) + "" bytes"");
    sb.append("" trace="").append(mTraceFile);
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""ApplicationExitInfo(timestamp="");
    sb.append(new SimpleDateFormat().format(new Date(mTimestamp)));
    sb.append("" pid="").append(mPid);
    sb.append("" realUid="").append(mRealUid);
    sb.append("" packageUid="").append(mPackageUid);
    sb.append("" definingUid="").append(mDefiningUid);
    sb.append("" user="").append(UserHandle.getUserId(mPackageUid));
    sb.append("" process="").append(mProcessName);
    sb.append("" reason="").append(mReason).append("" ("").append(reasonCodeToString(mReason)).append("")"");
    sb.append("" subreason="").append(mSubReason).append("" ("").append(subreasonToString(mSubReason)).append("")"");
    sb.append("" status="").append(mStatus);
    sb.append("" importance="").append(mImportance);
    sb.append("" pss="");
    DebugUtils.sizeValueToString(mPss << 10, sb);
    sb.append("" rss="");
    DebugUtils.sizeValueToString(mRss << 10, sb);
    sb.append("" description="").append(mDescription);
    sb.append("" state="").append(ArrayUtils.isEmpty(mState) ? ""empty"" : Integer.toString(mState.length) + "" bytes"");
    sb.append("" trace="").append(mTraceFile);
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new field (mSubReason) and its string representation (subreasonToString(mSubReason)) are appended to the StringBuilder object, representing an additional piece of information in the output string. This is an other statement change, so the change type is 4.","Although there is a change in the composition of the string returned by toString(), this does not affect how the API behaves in terms of its return type. The method still returns a string that represents the state of the object; only the content of the string has changed. There is no change in the signature or the type of returned value, so there is no compatibility issue in terms of different return types or exception handling, and the CI type is 0."
597,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,30,31,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: void binderDied()>,0,"{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // and torch statuses will be updated.
        for (int i = 0; i < mDeviceStatus.size(); i++) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        mConcurrentCameraIdCombinations.clear();
        scheduleCameraServiceReconnectionLocked();
    }
}","{
    synchronized (mLock) {
        // Only do this once per service death
        if (mCameraService == null)
            return;
        mCameraService = null;
        // entries from the ArrayMap.
        for (int i = mDeviceStatus.size() - 1; i >= 0; i--) {
            String cameraId = mDeviceStatus.keyAt(i);
            onStatusChangedLocked(ICameraServiceListener.STATUS_NOT_PRESENT, cameraId);
        }
        for (int i = 0; i < mTorchStatus.size(); i++) {
            String cameraId = mTorchStatus.keyAt(i);
            onTorchStatusChangedLocked(ICameraServiceListener.TORCH_STATUS_NOT_AVAILABLE, cameraId);
        }
        mConcurrentCameraIdCombinations.clear();
        scheduleCameraServiceReconnectionLocked();
    }
}",1,"/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
","/**
 * Listener for camera service death.
 *
 * <p>The camera service isn't supposed to die under any normal circumstances, but can be
 * turned off during debug, or crash due to bugs.  So detect that and null out the interface
 * object, so that the next calls to the manager can try to reconnect.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The ordering of the loop that iterates over `mDeviceStatus` has been reversed without altering its functionality. The code is iterating in reverse order in the later version, but since this does not affect the final outcome (it does not modify the collection), this is classified as 'Other statement changed'. No return statements, exceptions, or control dependencies were altered that would trigger a different behavior. ",There is no Compatibility Issue because the change in the loop order does not result in a different outcome. It will still perform the same operations on all elements without any change in external behavior observable by API callers.
598,<android.content.ContentProviderResult: String toString()>,30,31,<android.content.ContentProviderResult: String toString()>,<android.content.ContentProviderResult: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""ContentProviderResult("");
    if (uri != null) {
        sb.append(""uri="" + uri + "" "");
    }
    if (count != null) {
        sb.append(""count="" + count + "" "");
    }
    if (extras != null) {
        sb.append(""extras="" + extras + "" "");
    }
    if (exception != null) {
        sb.append(""exception="" + exception + "" "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""ContentProviderResult("");
    if (uri != null) {
        sb.append(""uri="").append(uri).append(' ');
    }
    if (count != null) {
        sb.append(""count="").append(count).append(' ');
    }
    if (extras != null) {
        sb.append(""extras="").append(extras).append(' ');
    }
    if (exception != null) {
        sb.append(""exception="").append(exception).append(' ');
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string concatenation within the StringBuilder append method calls has been changed to use chained append() calls instead of the '+' operator. These changes do not affect the returned value of the toString() method, therefore the code change type is 4.",There is no Compatibility Issue since the logic and output of the toString() method remain the same despite the internal change to use StringBuilder's append method more efficiently.
599,<android.bluetooth.BluetoothAdapter: int getScanMode()>,30,31,<android.bluetooth.BluetoothAdapter: int getScanMode()>,<android.bluetooth.BluetoothAdapter: int getScanMode()>,0,"{
    if (getState() != STATE_ON) {
        return SCAN_MODE_NONE;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}","{
    if (getState() != STATE_ON) {
        return SCAN_MODE_NONE;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getScanMode(mAttributionSource);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}",1,"/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return scan mode
 */
","/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return scan mode
 */
",-1,"[@RequiresPermission(Manifest.permission.BLUETOOTH), @ScanMode]","[@RequiresLegacyBluetoothPermission, @RequiresBluetoothScanPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN), @ScanMode]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method invocation mService.getScanMode() in the early version has been changed to mService.getScanMode(mAttributionSource) in the late version, modifying the number of parameters for the method call. This change implies that there is both a change in a return statement (because the value returned by this call may be different) and a dependent API change since the underlying method signature has been altered. Therefore, the code changes are categorized as 1,5.","The change in the method signature of mService.getScanMode() could lead to this API returning different values if the behavior of getScanMode inside the Bluetooth service has changed with the additional parameter. Thus, a Compatibility Issue may arise due to potential different return values or types, which corresponds to CI type 1."
600,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doRestoreFinished(int,IBackupManager)>",0,"{
    long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } catch (Exception e) {
        Log.d(TAG, ""onRestoreFinished ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}","{
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onRestoreFinished();
    } catch (Exception e) {
        Log.d(TAG, ""onRestoreFinished ("" + BackupAgent.this.getClass().getName() + "") threw"", e);
        throw e;
    } finally {
        // Ensure that any side-effect SharedPreferences writes have landed
        waitForSharedPrefs();
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The implementation code between the early version and the late version shows no differences apart from the change of a variable declaration from 'long ident' to 'final long ident', which has no effect on the behavior of the method; it is merely a modifier that enforces immutability of the variable. Therefore, there is no change to the API behavior.","Since there is no actual change in the logic, control flow, exception handling, or return statement, no compatibility issue could arise between the versions. The method's behavior remains the same despite the change in the variable declaration."
601,<android.view.autofill.AutofillValue: CharSequence getTextValue()>,30,31,<android.view.autofill.AutofillValue: CharSequence getTextValue()>,<android.view.autofill.AutofillValue: CharSequence getTextValue()>,0,"{
    Preconditions.checkState(isText(), ""value must be a text value, not type="" + mType);
    return (CharSequence) mValue;
}","{
    Preconditions.checkState(isText(), ""value must be a text value, not type=%d"", mType);
    return (CharSequence) mValue;
}",1,"/**
 * Gets the value to autofill a text field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TEXT} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a text value
 */
","/**
 * Gets the value to autofill a text field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TEXT} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a text value
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change is in the error message string within the checkState() method, from concatenating strings to using a formatted string with a placeholder. This change doesn't affect the actual logic or return value of the method, therefore the code change type is 4.","Since this change only modifies the content of the error message and no substantive code logic is affected, there is no potential Compatibility Issue here."
602,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,30,31,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setScanResponseData(AdvertiseData)>,0,"{
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Set/update scan response data. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status
 * is delivered through {@code callback.onScanResponseDataSet()}.
 *
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place
 * when the advertising set is enabled, the data can be maximum 251 bytes long.
 */
","/**
 * Set/update scan response data. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status
 * is delivered through {@code callback.onScanResponseDataSet()}.
 *
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place
 * when the advertising set is enabled, the data can be maximum 251 bytes long.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method setScanResponseData() now includes an additional parameter mAttributionSource, so a dependent API has changed (4). Additionally, the method signature for setScanResponseData() within mGatt has been modified to accept the new parameter, which represents a change in the dependent API (5).","The handling of the RemoteException has not changed, and the introduction of a new parameter to the method (mAttriburationSource) does not alter the behavior of the API with respect to exception handling or return values. Thus, there's no Compatibility Issue in terms of the API's functionality from the perspective of the caller: it neither throws a new exception nor modifies the return variable, as there is no return value from this void method. Hence, the CI type is 0."
603,"<android.os.VibrationEffect: VibrationEffect createWaveform(long[],int[],int)>",30,31,"<android.os.VibrationEffect: VibrationEffect createWaveform(long[],int[],int)>","<android.os.VibrationEffect: VibrationEffect createWaveform(long[],int[],int)>",0,"{
    VibrationEffect effect = new Waveform(timings, amplitudes, repeat);
    effect.validate();
    return effect;
}","{
    if (timings.length != amplitudes.length) {
        throw new IllegalArgumentException(""timing and amplitude arrays must be of equal length"" + "" (timings.length="" + timings.length + "", amplitudes.length="" + amplitudes.length + "")"");
    }
    List<StepSegment> segments = new ArrayList<>();
    for (int i = 0; i < timings.length; i++) {
        float parsedAmplitude = amplitudes[i] == DEFAULT_AMPLITUDE ? DEFAULT_AMPLITUDE : (float) amplitudes[i] / MAX_AMPLITUDE;
        segments.add(new StepSegment(parsedAmplitude, /* frequency= */
        0, (int) timings[i]));
    }
    VibrationEffect effect = new Composed(segments, repeat);
    effect.validate();
    return effect;
}",1,"/**
 * Create a waveform vibration.
 *
 * Waveform vibrations are a potentially repeating series of timing and amplitude pairs. For
 * each pair, the value in the amplitude array determines the strength of the vibration and the
 * value in the timing array determines how long it vibrates for, in milliseconds. Amplitude
 * values must be between 0 and 255, and an amplitude of 0 implies no vibration (i.e. off). Any
 * pairs with a timing value of 0 will be ignored.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the timings array at which to start the
 * repetition, or -1 to disable repeating.
 * </p>
 *
 * @param timings The timing values, in milliseconds, of the timing / amplitude pairs. Timing
 * values of 0 will cause the pair to be ignored.
 * @param amplitudes The amplitude values of the timing / amplitude pairs. Amplitude values
 * must be between 0 and 255, or equal to {@link #DEFAULT_AMPLITUDE}. An
 * amplitude value of 0 implies the motor is off.
 * @param repeat The index into the timings array at which to repeat, or -1 if you you don't
 * want to repeat.
 *
 * @return The desired effect.
 */
","/**
 * Create a waveform vibration.
 *
 * Waveform vibrations are a potentially repeating series of timing and amplitude pairs. For
 * each pair, the value in the amplitude array determines the strength of the vibration and the
 * value in the timing array determines how long it vibrates for, in milliseconds. Amplitude
 * values must be between 0 and 255, and an amplitude of 0 implies no vibration (i.e. off). Any
 * pairs with a timing value of 0 will be ignored.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the timings array at which to start the
 * repetition, or -1 to disable repeating.
 * </p>
 *
 * @param timings The timing values, in milliseconds, of the timing / amplitude pairs. Timing
 * values of 0 will cause the pair to be ignored.
 * @param amplitudes The amplitude values of the timing / amplitude pairs. Amplitude values
 * must be between 0 and 255, or equal to {@link #DEFAULT_AMPLITUDE}. An
 * amplitude value of 0 implies the motor is off.
 * @param repeat The index into the timings array at which to repeat, or -1 if you you don't
 * want to repeat.
 *
 * @return The desired effect.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5","1,2","The late version of the code has introduced a new flow control (if statement) checking the length of two arrays, an exception throw for invalid input, and a new method of constructing `VibrationEffect` along with a change in the loop logic. The way that `VibrationEffect` is created has been moved from `Waveform` to `Composed` with different semantics in the constructor, which is a change in the dependent API. So, the code change types include 2 (Exception handling statement changed), 3 (Control dependency changed), 4 (Other statement changed), and 5 (Dependent API changed).","The introduction of an IllegalArgumentException when the length of `timings` and `amplitudes` are not equal indicates the late version API has introduced a new exception which was not thrown in the early version which results in a CI type 2. Additionally, the late version may return a different type of `VibrationEffect` (Composed instead of Waveform) which has a different construction logic leading to different return values or types so CI type 1 also applies."
604,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,30,31,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,<android.view.ViewGroup: void dispatchProvideStructure(ViewStructure)>,0,"{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideStructure(): not laid out, ignoring "" + childrenCount + "" children of "" + getAccessibilityViewId());
        }
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> preorderedList = buildOrderedChildList();
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}","{
    super.dispatchProvideStructure(structure);
    if (isAssistBlocked() || structure.getChildCount() != 0) {
        return;
    }
    final int childrenCount = mChildrenCount;
    if (childrenCount <= 0) {
        return;
    }
    if (!isLaidOut()) {
        if (Helper.sVerbose) {
            Log.v(VIEW_LOG_TAG, ""dispatchProvideStructure(): not laid out, ignoring "" + childrenCount + "" children of "" + getAccessibilityViewId());
        }
        return;
    }
    structure.setChildCount(childrenCount);
    ArrayList<View> tempPreorderedList = buildOrderedChildList();
    ArrayList<View> preorderedList = tempPreorderedList != null ? new ArrayList<>(tempPreorderedList) : null;
    boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex;
        try {
            childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        } catch (IndexOutOfBoundsException e) {
            childIndex = i;
            if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.M) {
                Log.w(TAG, ""Bad getChildDrawingOrder while collecting assist @ "" + i + "" of "" + childrenCount, e);
                // At least one app is failing when we call getChildDrawingOrder
                // at this point, so deal semi-gracefully with it by falling back
                // on the basic order.
                customOrder = false;
                if (i > 0) {
                    // If we failed at the first index, there really isn't
                    // anything to do -- we will just proceed with the simple
                    // sequence order.
                    // Otherwise, we failed in the middle, so need to come up
                    // with an order for the remaining indices and use that.
                    // Failed at the first one, easy peasy.
                    int[] permutation = new int[childrenCount];
                    SparseBooleanArray usedIndices = new SparseBooleanArray();
                    // Go back and collected the indices we have done so far.
                    for (int j = 0; j < i; j++) {
                        permutation[j] = getChildDrawingOrder(childrenCount, j);
                        usedIndices.put(permutation[j], true);
                    }
                    // Fill in the remaining indices with indices that have not
                    // yet been used.
                    int nextIndex = 0;
                    for (int j = i; j < childrenCount; j++) {
                        while (usedIndices.get(nextIndex, false)) {
                            nextIndex++;
                        }
                        permutation[j] = nextIndex;
                        nextIndex++;
                    }
                    // Build the final view list.
                    preorderedList = new ArrayList<>(childrenCount);
                    for (int j = 0; j < childrenCount; j++) {
                        final int index = permutation[j];
                        final View child = mChildren[index];
                        preorderedList.add(child);
                    }
                }
            } else {
                throw e;
            }
        }
        final View child = getAndVerifyPreorderedView(preorderedList, mChildren, childIndex);
        final ViewStructure cstructure = structure.newChild(i);
        child.dispatchProvideStructure(cstructure);
    }
    if (preorderedList != null) {
        preorderedList.clear();
    }
}",1,"/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
","/**
 * Dispatch creation of {@link ViewStructure} down the hierarchy.  This implementation
 * adds in all child views of the view group, in addition to calling the default View
 * implementation.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
605,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,30,31,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.PermissionBackupHelper: byte[] getBackupPayload(String)>,0,"{
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                return mPermissionManager.backupRuntimePermissions(mUser);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}","{
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                return mPermissionManager.backupRuntimePermissions(mUserId);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key, e);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter changed in the line ""return mPermissionManager.backupRuntimePermissions(mUser);"" to ""return mPermissionManager.backupRuntimePermissions(mUserId);"" and an additional parameter 'e' is added to the log statement within the catch block. This is classified under class 4 for other changes, and also class 5 if the parameter change implies that ""mUserId"" is different from ""mUser"", which depends on whether the ""mUserId"" field has the same type and value as ""mUser"".","However, the change in the parameter of the log method within the catch block does not affect the behavior of the API with regards to the return value or exception handling, so it does not introduce a CI related to different behavior. If ""mUserId"" refers to the same user as ""mUser"", then there would not be a behavior change; if they refer to different values, then that could potentially lead to different return values, but since this change is not mentioned in the given context, we cannot assume a CI based on change in dependent APIs unless explicitly specified. Thus, based on the available information, there is no Compatibility Issue."
606,<android.service.autofill.FillEventHistory.Event: String toString()>,30,31,<android.service.autofill.FillEventHistory.Event: String toString()>,<android.service.autofill.FillEventHistory.Event: String toString()>,0,"{
    return ""FillEvent [datasetId="" + mDatasetId + "", type="" + mEventType + "", selectedDatasets="" + mSelectedDatasetIds + "", ignoredDatasetIds="" + mIgnoredDatasetIds + "", changedFieldIds="" + mChangedFieldIds + "", changedDatasetsIds="" + mChangedDatasetIds + "", manuallyFilledFieldIds="" + mManuallyFilledFieldIds + "", manuallyFilledDatasetIds="" + mManuallyFilledDatasetIds + "", detectedFieldIds="" + Arrays.toString(mDetectedFieldIds) + "", detectedFieldClassifications ="" + Arrays.toString(mDetectedFieldClassifications) + ""]"";
}","{
    return ""FillEvent [datasetId="" + mDatasetId + "", type="" + mEventType + "", selectedDatasets="" + mSelectedDatasetIds + "", ignoredDatasetIds="" + mIgnoredDatasetIds + "", changedFieldIds="" + mChangedFieldIds + "", changedDatasetsIds="" + mChangedDatasetIds + "", manuallyFilledFieldIds="" + mManuallyFilledFieldIds + "", manuallyFilledDatasetIds="" + mManuallyFilledDatasetIds + "", detectedFieldIds="" + Arrays.toString(mDetectedFieldIds) + "", detectedFieldClassifications ="" + Arrays.toString(mDetectedFieldClassifications) + "", saveDialogNotShowReason="" + mSaveDialogNotShowReason + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The return statement is modified by appending an additional string concatenation for the new member variable mSaveDialogNotShowReason, so the code change type is 4.","The change leads to the method returning a different string value than before. This constitutes a potential different return value, making the CI type 1."
607,<android.bluetooth.BluetoothGattServer: void cancelConnection(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothGattServer: void cancelConnection(BluetoothDevice)>,<android.bluetooth.BluetoothGattServer: void cancelConnection(BluetoothDevice)>,0,"{
    if (DBG)
        Log.d(TAG, ""cancelConnection() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return;
    try {
        mService.serverDisconnect(mServerIf, device.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    if (DBG)
        Log.d(TAG, ""cancelConnection() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return;
    try {
        mService.serverDisconnect(mServerIf, device.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Disconnects an established connection, or cancels a connection attempt
 * currently in progress.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Remote device
 */
","/**
 * Disconnects an established connection, or cancels a connection attempt
 * currently in progress.
 *
 * @param device Remote device
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method mService.serverDisconnect(...) now includes an additional parameter, mAttributionSource, which suggests a change in the dependent API (4). The annotations also changed to include new permission requirements (5).","The change does not alter the control flow, return statement, or exception handling within the cancelConnection() method, hence there is no compatibility issue as per the definition. The method's behavior when called with the same arguments would remain consistent, aside from requiring additional permissions at runtime which are not considered as a change that would result in a CI under the provided definitions."
609,<android.widget.TextView: CharSequence getText()>,30,31,<android.widget.TextView: CharSequence getText()>,<android.widget.TextView: CharSequence getText()>,0,"{
    return mText;
}","{
    if (mUseTextPaddingForUiTranslation) {
        ViewTranslationCallback callback = getViewTranslationCallback();
        if (callback != null && callback instanceof TextViewTranslationCallback) {
            TextViewTranslationCallback defaultCallback = (TextViewTranslationCallback) callback;
            if (defaultCallback.isTextPaddingEnabled() && defaultCallback.isShowingTranslation()) {
                return defaultCallback.getPaddedText(mText, mTransformed);
            }
        }
    }
    return mText;
}",1,"/**
 * Return the text that TextView is displaying. If {@link #setText(CharSequence)} was called
 * with an argument of {@link android.widget.TextView.BufferType#SPANNABLE BufferType.SPANNABLE}
 * or {@link android.widget.TextView.BufferType#EDITABLE BufferType.EDITABLE}, you can cast
 * the return value from this method to Spannable or Editable, respectively.
 *
 * <p>The content of the return value should not be modified. If you want a modifiable one, you
 * should make your own copy first.</p>
 *
 * @return The text displayed by the text view.
 * @attr ref android.R.styleable#TextView_text
 */
","/**
 * Return the text that TextView is displaying. If {@link #setText(CharSequence)} was called
 * with an argument of {@link android.widget.TextView.BufferType#SPANNABLE BufferType.SPANNABLE}
 * or {@link android.widget.TextView.BufferType#EDITABLE BufferType.EDITABLE}, you can cast
 * the return value from this method to Spannable or Editable, respectively.
 *
 * <p>The content of the return value should not be modified. If you want a modifiable one, you
 * should make your own copy first.</p>
 *
 * @return The text displayed by the text view.
 * @attr ref android.R.styleable#TextView_text
 */
",-1,"[@ViewDebug.CapturedViewProperty, @InspectableProperty]","[@ViewDebug.CapturedViewProperty, @InspectableProperty]",-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces new control statements and an extended return statement based on conditions, so the code change types are 1,3.","The newly added if statements and their conditions can result in the API returning a modified CharSequence rather than just 'mText', thus potentially causing a CI of type 1 due to different return values."
610,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",30,31,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(int,IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = getServedViewLocked();
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags = getStartInputFlags(view, startInputFlags);
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> mDelegate.startInput(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.autofillId = view.getAutofillId();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        final View servedView = getServedViewLocked();
        if (servedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" servedView="" + dumpViewInfo(servedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        maybeCallServedViewChangedLocked(tba);
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        ControlledInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            final Handler icHandler;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new ControlledInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this, view);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            final InputBindResult res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res == null) {
                Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
                return false;
            }
            mActivityViewToScreenMatrix = res.getActivityViewToScreenMatrix();
            if (res.id != null) {
                setInputChannelLocked(res.channel);
                mBindSequence = res.sequence;
                mCurMethod = res.method;
                mCurId = res.id;
            } else if (res.channel != null && res.channel != mCurChannel) {
                res.channel.dispose();
            }
            switch(res.result) {
                case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                    mRestartOnNextWindowFocus = true;
                    break;
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = getServedViewLocked();
        // Make sure we have a window token for the served view.
        if (DEBUG) {
            Log.v(TAG, ""Starting input: view="" + dumpViewInfo(view) + "" reason="" + InputMethodDebug.startInputReasonToString(startInputReason));
        }
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    if (windowGainingFocus == null) {
        windowGainingFocus = view.getWindowToken();
        if (windowGainingFocus == null) {
            Log.e(TAG, ""ABORT input: ServedView must be attached to a Window"");
            return false;
        }
        startInputFlags = getStartInputFlags(view, startInputFlags);
        softInputMode = view.getViewRootImpl().mWindowAttributes.softInputMode;
        windowFlags = view.getViewRootImpl().mWindowAttributes.flags;
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(() -> mDelegate.startInput(startInputReason, null, 0, 0, 0));
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    // Note: Use Context#getOpPackageName() rather than Context#getPackageName() so that the
    // system can verify the consistency between the uid of this process and package name passed
    // from here. See comment of Context#getOpPackageName() for details.
    tba.packageName = view.getContext().getOpPackageName();
    tba.autofillId = view.getAutofillId();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    final Handler icHandler;
    InputBindResult res = null;
    synchronized (mH) {
        // Now that we are locked again, validate that our state hasn't
        // changed.
        final View servedView = getServedViewLocked();
        if (servedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else. view="" + dumpViewInfo(view) + "" servedView="" + dumpViewInfo(servedView) + "" mServedConnecting="" + mServedConnecting);
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            startInputFlags |= StartInputFlags.INITIAL_CONNECTION;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
            mServedInputConnectionWrapper = null;
        }
        IInputConnectionWrapper servedContext;
        final int missingMethodFlags;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            mCursorAnchorInfo = null;
            missingMethodFlags = InputConnectionInspector.getMissingMethodFlags(ic);
            if ((missingMethodFlags & InputConnectionInspector.MissingMethodFlags.GET_HANDLER) != 0) {
                // InputConnection#getHandler() is not implemented.
                icHandler = null;
            } else {
                icHandler = ic.getHandler();
            }
            servedContext = new IInputConnectionWrapper(icHandler != null ? icHandler.getLooper() : vh.getLooper(), ic, this, view);
        } else {
            servedContext = null;
            missingMethodFlags = 0;
            icHandler = null;
        }
        mServedInputConnectionWrapper = servedContext;
        if (DEBUG) {
            Log.v(TAG, ""START INPUT: view="" + dumpViewInfo(view) + "" ic="" + ic + "" tba="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
        }
        try {
            res = mService.startInputOrWindowGainedFocus(startInputReason, mClient, windowGainingFocus, startInputFlags, softInputMode, windowFlags, tba, servedContext, missingMethodFlags, view.getContext().getApplicationInfo().targetSdkVersion);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        if (DEBUG)
            Log.v(TAG, ""Starting input: Bind result="" + res);
        if (res == null) {
            Log.wtf(TAG, ""startInputOrWindowGainedFocus must not return"" + "" null. startInputReason="" + InputMethodDebug.startInputReasonToString(startInputReason) + "" editorInfo="" + tba + "" startInputFlags="" + InputMethodDebug.startInputFlagsToString(startInputFlags));
            return false;
        }
        mIsInputMethodSuppressingSpellChecker = res.isInputMethodSuppressingSpellChecker;
        if (res.id != null) {
            setInputChannelLocked(res.channel);
            mBindSequence = res.sequence;
            // for @UnsupportedAppUsage
            mCurMethod = res.method;
            mCurrentInputMethodSession = InputMethodSessionWrapper.createOrNull(res.method);
            mCurId = res.id;
        } else if (res.channel != null && res.channel != mCurChannel) {
            res.channel.dispose();
        }
        switch(res.result) {
            case InputBindResult.ResultCode.ERROR_NOT_IME_TARGET_WINDOW:
                mRestartOnNextWindowFocus = true;
                break;
        }
        if (mCurrentInputMethodSession != null && mCompletions != null) {
            mCurrentInputMethodSession.displayCompletions(mCompletions);
        }
    }
    // Notify the app that the InputConnection is initialized and ready for use.
    if (ic != null && res != null && res.method != null) {
        if (DEBUG) {
            Log.v(TAG, ""Calling View.onInputConnectionOpened: view= "" + view + "", ic="" + ic + "", tba="" + tba + "", handler="" + icHandler);
        }
        view.onInputConnectionOpenedInternal(ic, tba, icHandler);
    }
    return true;
}",1,"/**
 * Called when {@link DelegateImpl#startInput}, {@link #restartInput(View)},
 * {@link #MSG_BIND} or {@link #MSG_UNBIND}.
 * Note that this method should *NOT* be called inside of {@code mH} lock to prevent start input
 * background thread may blocked by other methods which already inside {@code mH} lock.
 */
","/**
 * Called when {@link DelegateImpl#startInput}, {@link #restartInput(View)},
 * {@link #MSG_BIND} or {@link #MSG_UNBIND}.
 * Note that this method should *NOT* be called inside of {@code mH} lock to prevent start input
 * background thread may blocked by other methods which already inside {@code mH} lock.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
611,"<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean,Set<String>)>",30,31,"<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean,Set<String>)>","<android.app.admin.DevicePolicyManager: void setAlwaysOnVpnPackage(ComponentName,String,boolean,Set<String>)>",0,"{
    throwIfParentInstance(""setAlwaysOnVpnPackage"");
    if (mService != null) {
        try {
            mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, lockdownWhitelist == null ? null : new ArrayList<>(lockdownWhitelist));
        } catch (ServiceSpecificException e) {
            switch(e.errorCode) {
                case ERROR_VPN_PACKAGE_NOT_FOUND:
                    throw new NameNotFoundException(e.getMessage());
                default:
                    throw new RuntimeException(""Unknown error setting always-on VPN: "" + e.errorCode, e);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    throwIfParentInstance(""setAlwaysOnVpnPackage"");
    if (mService != null) {
        try {
            mService.setAlwaysOnVpnPackage(admin, vpnPackage, lockdownEnabled, lockdownAllowlist == null ? null : new ArrayList<>(lockdownAllowlist));
        } catch (ServiceSpecificException e) {
            switch(e.errorCode) {
                case ERROR_VPN_PACKAGE_NOT_FOUND:
                    throw new NameNotFoundException(e.getMessage());
                default:
                    throw new RuntimeException(""Unknown error setting always-on VPN: "" + e.errorCode, e);
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * A version of {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} that allows the
 * admin to specify a set of apps that should be able to access the network directly when VPN
 * is not connected. When VPN connects these apps switch over to VPN if allowed to use that VPN.
 * System apps can always bypass VPN.
 * <p> Note that the system doesn't update the whitelist when packages are installed or
 * uninstalled, the admin app must call this method to keep the list up to date.
 * <p> When {@code lockdownEnabled} is false {@code lockdownWhitelist} is ignored . When
 * {@code lockdownEnabled} is {@code true} and {@code lockdownWhitelist} is {@code null} or
 * empty, only system apps can bypass VPN.
 * <p> Setting always-on VPN package to {@code null} or using
 * {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} clears lockdown whitelist.
 *
 * @param vpnPackage package name for an installed VPN app on the device, or {@code null}
 * to remove an existing always-on VPN configuration
 * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
 * {@code false} otherwise. This has no effect when clearing.
 * @param lockdownWhitelist Packages that will be able to access the network directly when VPN
 * is in lockdown mode but not connected. Has no effect when clearing.
 * @throws SecurityException if {@code admin} is not a device or a profile
 * owner.
 * @throws NameNotFoundException if {@code vpnPackage} or one of
 * {@code lockdownWhitelist} is not installed.
 * @throws UnsupportedOperationException if {@code vpnPackage} exists but does
 * not support being set as always-on, or if always-on VPN is not
 * available.
 */
","/**
 * A version of {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} that allows the
 * admin to specify a set of apps that should be able to access the network directly when VPN
 * is not connected. When VPN connects these apps switch over to VPN if allowed to use that VPN.
 * System apps can always bypass VPN.
 * <p> Note that the system doesn't update the allowlist when packages are installed or
 * uninstalled, the admin app must call this method to keep the list up to date.
 * <p> When {@code lockdownEnabled} is false {@code lockdownAllowlist} is ignored . When
 * {@code lockdownEnabled} is {@code true} and {@code lockdownAllowlist} is {@code null} or
 * empty, only system apps can bypass VPN.
 * <p> Setting always-on VPN package to {@code null} or using
 * {@link #setAlwaysOnVpnPackage(ComponentName, String, boolean)} clears lockdown allowlist.
 *
 * @param vpnPackage package name for an installed VPN app on the device, or {@code null}
 * to remove an existing always-on VPN configuration
 * @param lockdownEnabled {@code true} to disallow networking when the VPN is not connected or
 * {@code false} otherwise. This has no effect when clearing.
 * @param lockdownAllowlist Packages that will be able to access the network directly when VPN
 * is in lockdown mode but not connected. Has no effect when clearing.
 * @throws SecurityException if {@code admin} is not a device or a profile
 * owner.
 * @throws NameNotFoundException if {@code vpnPackage} or one of
 * {@code lockdownAllowlist} is not installed.
 * @throws UnsupportedOperationException if {@code vpnPackage} exists but does
 * not support being set as always-on, or if always-on VPN is not
 * available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The implementation code remains largely unchanged except for the renaming of variable `lockdownWhitelist` to `lockdownAllowlist`. The logic of the method and the exceptions thrown remain the same.,"Despite the variable rename, it does not alter the logic or flow of the method. Since both variables `lockdownWhitelist` and `lockdownAllowlist` serve the same purpose and renaming a variable does not affect the method's external behavior, there is no compatibility issue."
612,"<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float)>",30,31,"<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float)>","<android.os.VibrationEffect.Composition: Composition addPrimitive(int,float)>",0,"{
    addPrimitive(primitiveId, scale, /*delay*/
    0);
    return this;
}","{
    return addPrimitive(primitiveId, scale, /*delay*/
    0);
}",1,"/**
 * Add a haptic primitive to the end of the current composition.
 *
 * Similar to {@link #addPrimitive(int, float, int)}, but with no delay.
 *
 * @param primitiveId The primitive to add
 * @param scale The scale to apply to the intensity of the primitive.
 *
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
","/**
 * Add a haptic primitive to the end of the current composition.
 *
 * Similar to {@link #addPrimitive(int, float, int)}, but with no delay.
 *
 * @param primitiveId The primitive to add
 * @param scale The scale to apply to the intensity of the primitive.
 *
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The modification in the method is the inlining of the call to 'addPrimitive(primitiveId, scale, /*delay*/ 0)'; it is moved from a separate statement to inside the return statement. This is purely a syntactic change and does not affect the functionality of the method, which is still calling the same 'addPrimitive' with the same parameters and returning 'this'. Therefore, the code change type is 4 (Other statement changed).","No Compatibility Issue because even though there's a syntactic change, the behaviour of the method hasn't changed; it still returns the same 'this' instance after calling 'addPrimitive' with the same parameters. Hence, the change will not lead to any difference in the method's functionality or affect the calling code. No return values or types are changed, and no new exceptions are thrown. Therefore, there's no Compatibility Issue."
613,"<android.app.admin.DevicePolicyManager: void setSecurityLoggingEnabled(ComponentName,boolean)>",30,31,"<android.app.admin.DevicePolicyManager: void setSecurityLoggingEnabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setSecurityLoggingEnabled(ComponentName,boolean)>",0,"{
    throwIfParentInstance(""setSecurityLoggingEnabled"");
    try {
        mService.setSecurityLoggingEnabled(admin, enabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setSecurityLoggingEnabled"");
    try {
        mService.setSecurityLoggingEnabled(admin, mContext.getPackageName(), enabled);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by device owner or a profile owner of an organization-owned managed profile to
 * control the security logging feature.
 *
 * <p> Security logs contain various information intended for security auditing purposes.
 * When security logging is enabled by a profile owner of
 * an organization-owned managed profile, certain security logs are not visible (for example
 * personal app launch events) or they will be redacted (for example, details of the physical
 * volume mount events). Please see {@link SecurityEvent} for details.
 *
 * <p><strong>Note:</strong> The device owner won't be able to retrieve security logs if there
 * are unaffiliated secondary users or profiles on the device, regardless of whether the
 * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 * all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 * new users as soon as possible after provisioning via {@link #setAffiliationIds}. Profile
 * owner of organization-owned managed profile is not subject to this restriction since all
 * privacy-sensitive events happening outside the managed profile would have been redacted
 * already.
 *
 * @param admin Which device admin this request is associated with.
 * @param enabled whether security logging should be enabled or not.
 * @throws SecurityException if {@code admin} is not allowed to control security logging.
 * @see #setAffiliationIds
 * @see #retrieveSecurityLogs
 */
","/**
 * Called by device owner or a profile owner of an organization-owned managed profile to
 * control the security logging feature.
 *
 * <p> Security logs contain various information intended for security auditing purposes.
 * When security logging is enabled by a profile owner of
 * an organization-owned managed profile, certain security logs are not visible (for example
 * personal app launch events) or they will be redacted (for example, details of the physical
 * volume mount events). Please see {@link SecurityEvent} for details.
 *
 * <p><strong>Note:</strong> The device owner won't be able to retrieve security logs if there
 * are unaffiliated secondary users or profiles on the device, regardless of whether the
 * feature is enabled. Logs will be discarded if the internal buffer fills up while waiting for
 * all users to become affiliated. Therefore it's recommended that affiliation ids are set for
 * new users as soon as possible after provisioning via {@link #setAffiliationIds}. Profile
 * owner of organization-owned managed profile is not subject to this restriction since all
 * privacy-sensitive events happening outside the managed profile would have been redacted
 * already.
 *
 * @param admin Which device admin this request is associated with.
 * @param enabled whether security logging should be enabled or not.
 * @throws SecurityException if {@code admin} is not allowed to control security logging.
 * @see #setAffiliationIds
 * @see #retrieveSecurityLogs
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is an addition of mContext.getPackageName() argument to the mService.setSecurityLoggingEnabled() method call, which means the dependent API has changed, so the code change type is 5.","Although there's a change in the method call due to the additional parameter, the behaviour of the API in terms of returning a value or throwing an exception would not be different, because the method is void and the exception handling remains the same. It's just a change in the input to the dependent method call. Therefore, there is no compatibility issue, and the CI type is 0."
614,<android.bluetooth.BluetoothDevice: boolean setPin(byte[])>,30,31,<android.bluetooth.BluetoothDevice: boolean setPin(byte[])>,<android.bluetooth.BluetoothDevice: boolean setPin(byte[])>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set Remote Device pin"");
        return false;
    }
    try {
        return service.setPin(this, true, pin.length, pin);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set Remote Device pin"");
        return false;
    }
    try {
        return service.setPin(this, true, pin.length, pin, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true pin has been set false for error
 */
","/**
 * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
 *
 * @return true pin has been set false for error
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The method service.setPin() call in the late version has an additional parameter, mAttributionSource. No return statement, exception handling statement or control statement was modified, but the signature of a dependent API call changed. Hence, the code change type is 5.","The additional parameter in the method service.setPin() does not introduce a different behaviour observable by the clients of this API with respect to the return value or the exceptions thrown. It may be related to permission or attribution handling internally, but as far as the method's external contract and behaviour are concerned, there should be no compatibility issue for the existing clients. Thus, CI type is 0."
615,<android.view.Display: float[] getSupportedRefreshRates()>,30,31,<android.view.Display: float[] getSupportedRefreshRates()>,<android.view.Display: float[] getSupportedRefreshRates()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getDefaultRefreshRates();
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getDefaultRefreshRates();
    }
}",1,"/**
 * Get the supported refresh rates of this display in frames per second.
 * <p>
 * This method only returns refresh rates for the display's default modes. For more options, use
 * {@link #getSupportedModes()}.
 *
 * @deprecated use {@link #getSupportedModes()} instead
 */
","/**
 * Get the supported refresh rates of this display in frames per second.
 * <p>
 * This method only returns refresh rates for the display's default modes. For more options, use
 * {@link #getSupportedModes()}.
 *
 * @deprecated use {@link #getSupportedModes()} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"The synchronization lock object changed from 'this' to 'mLock', but the behavior of the method remains the same, so the code change type is 4.",There is no Compatibility Issue because the modification does not affect the method's return values or the exceptions it may throw. The overall behaviour of the method should remain consistent despite the internal lock object changing.
616,"<android.service.autofill.CustomDescription.Builder: Builder addOnClickAction(int,OnClickAction)>",30,31,"<android.service.autofill.CustomDescription.Builder: Builder addOnClickAction(int,OnClickAction)>","<android.service.autofill.CustomDescription.Builder: Builder addOnClickAction(int,OnClickAction)>",0,"{
    throwIfDestroyed();
    Preconditions.checkArgument((action instanceof InternalOnClickAction), ""not provided by Android System: "" + action);
    if (mActions == null) {
        mActions = new SparseArray<InternalOnClickAction>();
    }
    mActions.put(id, (InternalOnClickAction) action);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument((action instanceof InternalOnClickAction), ""not provided by Android System: %s"", action);
    if (mActions == null) {
        mActions = new SparseArray<InternalOnClickAction>();
    }
    mActions.put(id, (InternalOnClickAction) action);
    return this;
}",1,"/**
 * Sets an action to be applied to the {@link RemoteViews presentation template} when the
 * child view with the given {@code id} is clicked.
 *
 * <p>Typically used when the presentation uses a masked field (like {@code ****}) for
 * sensitive fields like passwords or credit cards numbers, but offers a an icon that the
 * user can tap to show the value for that field.
 *
 * <p>Example:
 *
 * <pre class=""prettyprint"">
 * customDescriptionBuilder
 * .addChild(R.id.password_plain, new CharSequenceTransformation
 * .Builder(passwordId, Pattern.compile(""^(.*)$""), ""$1"").build())
 * .addOnClickAction(R.id.showIcon, new VisibilitySetterAction
 * .Builder(R.id.hideIcon, View.VISIBLE)
 * .setVisibility(R.id.showIcon, View.GONE)
 * .setVisibility(R.id.password_plain, View.VISIBLE)
 * .setVisibility(R.id.password_masked, View.GONE)
 * .build())
 * .addOnClickAction(R.id.hideIcon, new VisibilitySetterAction
 * .Builder(R.id.showIcon, View.VISIBLE)
 * .setVisibility(R.id.hideIcon, View.GONE)
 * .setVisibility(R.id.password_masked, View.VISIBLE)
 * .setVisibility(R.id.password_plain, View.GONE)
 * .build());
 * </pre>
 *
 * <p><b>Note:</b> Currently only one action can be applied to a child; if this method
 * is called multiple times passing the same {@code id}, only the last call will be used.
 *
 * @param id resource id of the child view.
 * @param action action to be performed. Must be an an implementation provided by the
 * Android System.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code action} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
","/**
 * Sets an action to be applied to the {@link RemoteViews presentation template} when the
 * child view with the given {@code id} is clicked.
 *
 * <p>Typically used when the presentation uses a masked field (like {@code ****}) for
 * sensitive fields like passwords or credit cards numbers, but offers a an icon that the
 * user can tap to show the value for that field.
 *
 * <p>Example:
 *
 * <pre class=""prettyprint"">
 * customDescriptionBuilder
 * .addChild(R.id.password_plain, new CharSequenceTransformation
 * .Builder(passwordId, Pattern.compile(""^(.*)$""), ""$1"").build())
 * .addOnClickAction(R.id.showIcon, new VisibilitySetterAction
 * .Builder(R.id.hideIcon, View.VISIBLE)
 * .setVisibility(R.id.showIcon, View.GONE)
 * .setVisibility(R.id.password_plain, View.VISIBLE)
 * .setVisibility(R.id.password_masked, View.GONE)
 * .build())
 * .addOnClickAction(R.id.hideIcon, new VisibilitySetterAction
 * .Builder(R.id.showIcon, View.VISIBLE)
 * .setVisibility(R.id.hideIcon, View.GONE)
 * .setVisibility(R.id.password_masked, View.VISIBLE)
 * .setVisibility(R.id.password_plain, View.GONE)
 * .build());
 * </pre>
 *
 * <p><b>Note:</b> Currently only one action can be applied to a child; if this method
 * is called multiple times passing the same {@code id}, only the last call will be used.
 *
 * @param id resource id of the child view.
 * @param action action to be performed. Must be an an implementation provided by the
 * Android System.
 *
 * @return this builder
 *
 * @throws IllegalArgumentException if {@code action} is not a class provided
 * by the Android System.
 * @throws IllegalStateException if {@link #build()} was already called.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the method's implementation logic between the two versions. The only change is how the error message is constructed in the ""Preconditions.checkArgument"" line, which does not affect the behavior of the method.","There are no changes that could lead to Compatibility Issues, as the method's behavior is identical between versions."
617,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>",30,31,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>","<android.os.PowerManager: WakeLock newWakeLock(int,String)>",0,"{
    validateWakeLockParameters(levelAndFlags, tag);
    return new WakeLock(levelAndFlags, tag, mContext.getOpPackageName());
}","{
    validateWakeLockParameters(levelAndFlags, tag);
    return new WakeLock(levelAndFlags, tag, mContext.getOpPackageName(), Display.INVALID_DISPLAY);
}",1,"/**
 * Creates a new wake lock with the specified level and flags.
 * <p>
 * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
 * combined using the logical OR operator.
 * </p><p>
 * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
 * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
 * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
 * specified as part of the {@code levelAndFlags} parameter.
 * </p>
 * <p>
 * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
 * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
 * {@code levelAndFlags} parameters.
 * </p><p>
 * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 * </p><p>
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ... do work...
 * wl.release();
 * }
 * </p><p>
 * Although a wake lock can be created without special permissions,
 * the {@link android.Manifest.permission#WAKE_LOCK} permission is
 * required to actually acquire or release the wake lock that is returned.
 * </p><p class=""note"">
 * If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.
 * </p>
 *
 * <p>
 * Recommended naming conventions for tags to make debugging easier:
 * <ul>
 * <li>use a unique prefix delimited by a colon for your app/library (e.g.
 * gmail:mytag) to make it easier to understand where the wake locks comes
 * from. This namespace will also avoid collision for tags inside your app
 * coming from different libraries which will make debugging easier.
 * <li>use constants (e.g. do not include timestamps in the tag) to make it
 * easier for tools to aggregate similar wake locks. When collecting
 * debugging data, the platform only monitors a finite number of tags,
 * using constants will help tools to provide better debugging data.
 * <li>avoid using Class#getName() or similar method since this class name
 * can be transformed by java optimizer and obfuscator tools.
 * <li>avoid wrapping the tag or a prefix to avoid collision with wake lock
 * tags from the platform (e.g. *alarm*).
 * <li>never include personnally identifiable information for privacy
 * reasons.
 * </ul>
 * </p>
 *
 * @param levelAndFlags Combination of wake lock level and flag values defining
 * the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #PROXIMITY_SCREEN_OFF_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
","/**
 * Creates a new wake lock with the specified level and flags.
 * <p>
 * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
 * combined using the logical OR operator.
 * </p><p>
 * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
 * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
 * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
 * specified as part of the {@code levelAndFlags} parameter.
 * </p>
 * <p>
 * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
 * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
 * {@code levelAndFlags} parameters.
 * </p><p>
 * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 * </p><p>
 * {@samplecode
 * PowerManager pm = mContext.getSystemService(PowerManager.class);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ... do work...
 * wl.release();
 * }
 * </p><p>
 * Although a wake lock can be created without special permissions,
 * the {@link android.Manifest.permission#WAKE_LOCK} permission is
 * required to actually acquire or release the wake lock that is returned.
 * </p><p class=""note"">
 * If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.
 * Additionally using the flag will keep only the appropriate screen on in a
 * multi-display scenario while using a wake lock will keep every screen powered on.
 * </p>
 *
 * <p>
 * Recommended naming conventions for tags to make debugging easier:
 * <ul>
 * <li>use a unique prefix delimited by a colon for your app/library (e.g.
 * gmail:mytag) to make it easier to understand where the wake locks comes
 * from. This namespace will also avoid collision for tags inside your app
 * coming from different libraries which will make debugging easier.
 * <li>use constants (e.g. do not include timestamps in the tag) to make it
 * easier for tools to aggregate similar wake locks. When collecting
 * debugging data, the platform only monitors a finite number of tags,
 * using constants will help tools to provide better debugging data.
 * <li>avoid using Class#getName() or similar method since this class name
 * can be transformed by java optimizer and obfuscator tools.
 * <li>avoid wrapping the tag or a prefix to avoid collision with wake lock
 * tags from the platform (e.g. *alarm*).
 * <li>never include personally identifiable information for privacy
 * reasons.
 * </ul>
 * </p>
 *
 * @param levelAndFlags Combination of wake lock level and flag values defining
 * the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #PROXIMITY_SCREEN_OFF_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The 'new' statement of WakeLock has an extra parameter added: Display.INVALID_DISPLAY. This is a change in a dependent API (because the constructor for WakeLock is a different API), which also changes the return statement as different constructor overloads are being called. Therefore, the code change type is 1,5.","The introduction of a new parameter in the call to the WakeLock constructor means that a different version of the constructor is being used, potentially changing the created WakeLock object's behavior or initializing it with different internal state. This could result in a different WakeLock behavior when used, and therefore a change in the return variable. The CI type is 1."
618,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,30,31,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,<android.util.AtomicFile: void finishWrite(FileOutputStream)>,0,"{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, ""Failed to sync file output stream"");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Failed to close file output stream"", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitTag != null) {
        com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
    }
}","{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, ""Failed to sync file output stream"");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, ""Failed to close file output stream"", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitEventLogger != null) {
        mCommitEventLogger.onFinishWrite();
    }
}",1,"/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
","/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in a method call in the block if (mCommitTag != null) to if (mCommitEventLogger != null), where the method `com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime)` has been replaced with `mCommitEventLogger.onFinishWrite()`. This implies there is a change in the dependent API, so the code change type is 4,5.","Although the implementation of the method onFinishWrite() is not provided, assuming this logging function does not alter the state of the AtomicFile nor the state of the FileOutputStream ('str'), the change should not affect the behavior of the method finishWrite() with regard to how it processes the given FileOutputStream. There are no changes to the return type, exception handling, or control flow that would suggest a behavior change from an API consumerâ€™s perspective. Therefore, there is no Compatibility Issue detected, leading to CI type 0."
620,<android.os.PersistableBundle: PersistableBundle readFromStream(InputStream)>,30,31,<android.os.PersistableBundle: PersistableBundle readFromStream(InputStream)>,<android.os.PersistableBundle: PersistableBundle readFromStream(InputStream)>,0,"{
    try {
        XmlPullParser parser = XmlPullParserFactory.newInstance().newPullParser();
        parser.setInput(inputStream, UTF_8.name());
        parser.next();
        return PersistableBundle.restoreFromXml(parser);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
}","{
    try {
        TypedXmlPullParser parser = Xml.newFastPullParser();
        parser.setInput(inputStream, UTF_8.name());
        parser.next();
        return PersistableBundle.restoreFromXml(parser);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
}",1,"/**
 * Reads a {@link PersistableBundle} from an {@link InputStream}.
 *
 * <p>The stream must be generated by {@link #writeToStream}.
 *
 * @see #writeToStream
 */
","/**
 * Reads a {@link PersistableBundle} from an {@link InputStream}.
 *
 * <p>The stream must be generated by {@link #writeToStream}.
 *
 * @see #writeToStream
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The change is the instantiation of the parser using `XmlPullParserFactory.newInstance().newPullParser()` in the early version to `Xml.newFastPullParser()` in the late version. This is a change in how an object is instantiated (Other statement changed) and since `TypedXmlPullParser` is a subclass or interface change (Dependent API changed), the code change type is 4,5.","There is no Compatibility Issue since there is no change in the behavior of the API. The method still tries to parse the input stream into a `PersistableBundle` and throws an `IOException` in case of `XmlPullParserException`. The exception handling did not change and no new code paths that affect the returned value or thrown exceptions were introduced. The behavior regarding the execution and outcomes remains effectively the same. Thus, the CI type is 0."
621,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",30,31,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    final boolean wasVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        if (mIsPreRendered) {
            if (DEBUG) {
                Log.v(TAG, ""Making IME window visible"");
            }
            onPreRenderedWindowVisibilityChanged(true);
        } else {
            showWindow(true);
        }
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    // If user uses hard keyboard, IME button should always be shown.
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = mIsPreRendered ? mDecorViewVisible && mWindowVisible : isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    if (Trace.isEnabled()) {
        Binder.enableTracing();
    } else {
        Binder.disableTracing();
    }
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showSoftInput"");
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#showSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        showWindow(true);
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The checks for 'mIsPreRendered', 'mDecorViewVisible' and 'mWindowVisible' variables have been removed, additional trace-related method calls ('Trace.isEnabled()', 'Binder.enableTracing()', 'Binder.disableTracing()', 'Trace.traceBegin()', 'ImeTracing.getInstance().triggerServiceDump()', 'Trace.traceEnd()') have been added, and the method of checking visibility ('wasVisible' and 'isVisible') has been simplified, so the change type is 1,3,4.","The removal of the 'mIsPreRendered', 'mDecorViewVisible' and 'mWindowVisible' checks can lead to a change in the behavior of the method, possibly changing what 'isVisible' and 'visibilityChanged' evaluate to, and consequently what is sent to 'resultReceiver'. Additionally, the introduction of tracing changes the execution path, adding potential new behaviors (side effects of tracing methods) and logic that might throw exceptions. Therefore, the CI type is 1,2."
622,<android.view.ViewDebug.StreamingPictureCallbackHandler: void run()>,30,31,<android.view.ViewDebug.StreamingPictureCallbackHandler: void run()>,<android.view.ViewDebug.StreamingPictureCallbackHandler: void run()>,0,"{
    mLock.lock();
    final byte[] picture = mQueue.poll();
    final boolean isStopped = mStopListening;
    mLock.unlock();
    if (Thread.currentThread() == mRenderThread) {
        close();
        throw new IllegalStateException(""ViewDebug#startRenderingCommandsCapture must be given an executor that "" + ""invokes asynchronously"");
    }
    if (isStopped) {
        return;
    }
    OutputStream stream = null;
    try {
        stream = mCallback.call();
    } catch (Exception ex) {
        Log.w(""ViewDebug"", ""Aborting rendering commands capture "" + ""because callback threw exception"", ex);
    }
    if (stream != null) {
        try {
            stream.write(picture);
        } catch (IOException ex) {
            Log.w(""ViewDebug"", ""Aborting rendering commands capture "" + ""due to IOException writing to output stream"", ex);
        }
    } else {
        close();
    }
}","{
    mLock.lock();
    final Picture picture = mQueue.poll();
    final boolean isStopped = mStopListening;
    mLock.unlock();
    if (Thread.currentThread() == mRenderThread) {
        close();
        throw new IllegalStateException(""ViewDebug#startRenderingCommandsCapture must be given an executor that "" + ""invokes asynchronously"");
    }
    if (isStopped) {
        return;
    }
    OutputStream stream = null;
    try {
        stream = mCallback.call();
    } catch (Exception ex) {
        Log.w(""ViewDebug"", ""Aborting rendering commands capture "" + ""because callback threw exception"", ex);
    }
    if (stream != null) {
        try {
            picture.writeToStream(stream);
            stream.flush();
        } catch (IOException ex) {
            Log.w(""ViewDebug"", ""Aborting rendering commands capture "" + ""due to IOException writing to output stream"", ex);
        }
    } else {
        close();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The type of `picture` is changed from `byte[]` to `Picture`, and accordingly, the way of writing to `stream` is changed from `stream.write(picture)` to `picture.writeToStream(stream)`. Additionally, `stream.flush()` has been added. These changes represent a modification to a dependent API and other statement changes, so the code change type is 4,5.","These changes do not result in different return types or values nor change exception handling. The API still captures rendering commands and writes them to an output stream. The additional `stream.flush()` ensures that the content of the stream is actually written, which is more of a correctness/optimization change than a change in behavior. Therefore, there is no Compatibility Issue; the CI type is 0."
623,<android.view.Display: HdrCapabilities getHdrCapabilities()>,30,31,<android.view.Display: HdrCapabilities getHdrCapabilities()>,<android.view.Display: HdrCapabilities getHdrCapabilities()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.hdrCapabilities;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (mDisplayInfo.userDisabledHdrTypes.length == 0) {
            return mDisplayInfo.hdrCapabilities;
        }
        if (mDisplayInfo.hdrCapabilities == null) {
            return null;
        }
        ArraySet<Integer> enabledTypesSet = new ArraySet<>();
        for (int supportedType : mDisplayInfo.hdrCapabilities.getSupportedHdrTypes()) {
            boolean typeDisabled = false;
            for (int userDisabledType : mDisplayInfo.userDisabledHdrTypes) {
                if (supportedType == userDisabledType) {
                    typeDisabled = true;
                    break;
                }
            }
            if (!typeDisabled) {
                enabledTypesSet.add(supportedType);
            }
        }
        int[] enabledTypes = new int[enabledTypesSet.size()];
        int index = 0;
        for (int enabledType : enabledTypesSet) {
            enabledTypes[index++] = enabledType;
        }
        return new HdrCapabilities(enabledTypes, mDisplayInfo.hdrCapabilities.mMaxLuminance, mDisplayInfo.hdrCapabilities.mMaxAverageLuminance, mDisplayInfo.hdrCapabilities.mMinLuminance);
    }
}",1,"/**
 * Returns the display's HDR capabilities.
 *
 * @see #isHdr()
 */
","/**
 * Returns the display's HDR capabilities.
 *
 * @see #isHdr()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The synchronized block now locks on a different object (mLock instead of this), which is a change to the control dependency; additional conditional checks (mDisplayInfo.userDisabledHdrTypes.length == 0 and mDisplayInfo.hdrCapabilities == null) and processing logic to potentially alter the returned HdrCapabilities object based on user-disabled HDR types are added to the method. Therefore, the change includes both control dependency change (3) and other changes in the statements (4).","The late version introduces new behavior based on the conditions mDisplayInfo.userDisabledHdrTypes.length and mDisplayInfo.hdrCapabilities, leading to cases where a modified HdrCapabilities object is returned or null is returned where previously it would not have been. These changes potentially lead to different return values and introduce new control paths, which constitute a Compatibility Issue of type 1 (different return values or types)."
624,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",30,31,"<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>","<android.accounts.AccountManager: boolean addAccountExplicitly(Account,String,Bundle)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    try {
        return mService.addAccountExplicitly(account, password, userdata, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, the user is locked, or another error occurs.
 */
","/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, the user is locked, or another error occurs.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The addAccountExplicitly method call within the try block has been updated to include a new parameter (mContext.getOpPackageName()). Therefore, the code change type is 5 due to the introduction of a new parameter in the dependent API.","No Compatibility Issue is detected. The change to the method signature of addAccountExplicitly does not alter the behavior of the API from the caller's perspective as long as the caller's code is unaware of the internals of the addAccountExplicitly method, which is being called. The method still takes the same number of parameters, and the behavior from the perspective of the caller appears to remain the same - it accepts an account, password, userdata, and returns a boolean value depending on the successful addition of the account. The additional parameter mContext.getOpPackageName() is internally used by the API and doesn't affect how a caller would use this API or expect it to behave. Therefore, it is classified as no Compatibility Issue (0)."
625,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",30,31,"<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>","<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void onFoundOrLost(boolean,ScanResult)>",0,"{
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mScannerId <= 0) {
            return;
        }
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}","{
    Attributable.setAttributionSource(scanResult, mAttributionSource);
    if (VDBG) {
        Log.d(TAG, ""onFoundOrLost() - onFound = "" + onFound + "" "" + scanResult.toString());
    }
    // Check null in case the scan has been stopped
    synchronized (this) {
        if (mScannerId <= 0) {
            return;
        }
    }
    Handler handler = new Handler(Looper.getMainLooper());
    handler.post(new Runnable() {

        @Override
        public void run() {
            if (onFound) {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_FIRST_MATCH, scanResult);
            } else {
                mScanCallback.onScanResult(ScanSettings.CALLBACK_TYPE_MATCH_LOST, scanResult);
            }
        }
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new statement added at the beginning of the method (`Attributable.setAttributionSource(scanResult, mAttributionSource);`), which is neither a return statement, exception handling statement, nor a control dependency change. Therefore, the code change type is 4.","The newly added statement only sets attribution information for the `ScanResult` object and does not affect the method's return value or exception handling. There is no change to the method's external behavior with respect to what it returns or the exceptions it might throw; hence, there is no Compatibility Issue as per the provided definitions."
628,<android.os.VibrationAttributes: String toString()>,30,31,<android.os.VibrationAttributes: String toString()>,<android.os.VibrationAttributes: String toString()>,0,"{
    return ""VibrationAttributes:"" + "" Usage="" + usageToString() + "" Flags="" + mFlags;
}","{
    return ""VibrationAttributes:"" + "" Usage="" + usageToString() + "" Audio Usage= "" + AudioAttributes.usageToString(mOriginalAudioUsage) + "" Flags="" + mFlags;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"An additional string component "" Audio Usage= "" + AudioAttributes.usageToString(mOriginalAudioUsage) is concatenated in the return statement, so the change type is 4.","This additional string component will change the returned string value, hence the change may result in a different return value for the API. Therefore, the CI type is 1."
629,<android.bluetooth.BluetoothGatt: boolean connect()>,30,31,<android.bluetooth.BluetoothGatt: boolean connect()>,<android.bluetooth.BluetoothGatt: boolean connect()>,0,"{
    try {
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, mTransport, mOpportunistic, // autoConnect is inverse of ""isDirect""
        mPhy);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}","{
    try {
        // autoConnect is inverse of ""isDirect""
        mService.clientConnect(mClientIf, mDevice.getAddress(), false, mTransport, mOpportunistic, mPhy, mAttributionSource);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
}",1,"/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Connect back to remote device.
 *
 * <p>This method is used to re-connect to a remote device after the
 * connection has been dropped. If the device is not in range, the
 * re-connection will be triggered once the device is back in range.
 *
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The code change is associated with adding an additional parameter to the method call (mAttributionSource to mService.clientConnect). Because the call to the method 'clientConnect' now includes an additional parameter, the code change type is 5.","There is no Compatibility Issue as the overall method behavior remains the same. The return value is still consistently either true or false, with no change in the types and values returned, nor the exception handling logic. Hence, the client code calling this API will not have different behavior between the two versions due to this change."
631,<android.app.ContextImpl: Context createAttributionContext(String)>,30,31,<android.app.ContextImpl: Context createAttributionContext(String)>,<android.app.ContextImpl: Context createAttributionContext(String)>,0,"{
    return new ContextImpl(this, mMainThread, mPackageInfo, attributionTag, mSplitName, mToken, mUser, mFlags, mClassLoader, null);
}","{
    return createContext(new ContextParams.Builder(mParams).setAttributionTag(attributionTag).build());
}",1,,,-1,"[@Override, @NonNull]","[@Override, @NonNull]",-1,-1,-1,-1,-1,-1,"1,5",0,"The implementation of the method has been completely changed. It no longer calls 'new ContextImpl()' explicitly with a list of parameters but instead calls 'createContext()' with a new 'ContextParams.Builder' object being built. The dependent API changed from using the 'ContextImpl' constructor directly to leveraging a 'ContextParams.Builder' object for creation, indicating a change in how context parameters are processed. Thus, the code change type is 1,5.","However, there is no clear indication that the API returns a different value or throws a different exception based solely on the information available. Both methods ultimately aim to return a customized Context instance. If 'createContext()' and 'ContextParams.Builder' have been implemented properly to substitute the direct construction of 'ContextImpl' with the exact same results, then the behavior of the API remains unchanged. Therefore, there is no Compatibility Issue, indicated by 0."
632,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,30,31,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble) && Objects.equals(mVisuallyInterruptive, other.mVisuallyInterruptive) && Objects.equals(mIsConversation, other.mIsConversation) && // Shortcutinfo doesn't have equals either; use id
    Objects.equals((mShortcutInfo == null ? 0 : mShortcutInfo.getId()), (other.mShortcutInfo == null ? 0 : other.mShortcutInfo.getId())) && Objects.equals(mIsBubble, other.mIsBubble);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble) && Objects.equals(mVisuallyInterruptive, other.mVisuallyInterruptive) && Objects.equals(mIsConversation, other.mIsConversation) && // Shortcutinfo doesn't have equals either; use id
    Objects.equals((mShortcutInfo == null ? 0 : mShortcutInfo.getId()), (other.mShortcutInfo == null ? 0 : other.mShortcutInfo.getId())) && Objects.equals(mRankingAdjustment, other.mRankingAdjustment) && Objects.equals(mIsBubble, other.mIsBubble);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in the equals method has changed with the addition of a new comparison (Objects.equals(mRankingAdjustment, other.mRankingAdjustment)). Additionally, there is no control statement or dependent API change, so the change type includes a return statement changed (1) and an other statement changed (4) because the internal logic for comparison (equals method) has been modified.","The addition of the new field comparison potentially changes the outcome of the equals method, which means that the method may return different results for comparisons involving Ranking instances. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
633,<android.app.ActivityThread.Idler: boolean queueIdle()>,30,31,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityTaskManager am = ActivityTaskManager.getService();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    applyPendingProcessState();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        final ActivityClient ac = ActivityClient.getInstance();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                ac.activityIdle(a.token, a.createdConfig, stopProfiling);
                a.createdConfig = null;
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    applyPendingProcessState();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call has changed from `ActivityTaskManager.getService()` to `ActivityClient.getInstance()`, and the method on this object has changed from `am.activityIdle()` to `ac.activityIdle()`. Hence, the code change type is 5.",There is no Compatibility Issue detected since the return value and exception handling remain unchanged and the modification in the dependent API does not necessarily introduce a change in the behavior of `queueIdle()`. The implementation still ends with `return false;` and the exception handling for `RemoteException` has not been altered.
635,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrieveSecurityLogs(ComponentName)>,30,31,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrieveSecurityLogs(ComponentName)>,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrieveSecurityLogs(ComponentName)>,0,"{
    throwIfParentInstance(""retrieveSecurityLogs"");
    try {
        ParceledListSlice<SecurityEvent> list = mService.retrieveSecurityLogs(admin);
        if (list != null) {
            return list.getList();
        } else {
            // Rate limit exceeded.
            return null;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""retrieveSecurityLogs"");
    try {
        ParceledListSlice<SecurityEvent> list = mService.retrieveSecurityLogs(admin, mContext.getPackageName());
        if (list != null) {
            return list.getList();
        } else {
            // Rate limit exceeded.
            return null;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by device owner or profile owner of an organization-owned managed profile to retrieve
 * all new security logging entries since the last call to this API after device boots.
 *
 * <p> Access to the logs is rate limited and it will only return new logs after the device
 * owner has been notified via {@link DeviceAdminReceiver#onSecurityLogsAvailable}.
 *
 * <p> When called by a device owner, if there is any other user or profile on the device,
 * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.
 * See {@link #isAffiliatedUser}.
 *
 * @param admin Which device admin this request is associated with.
 * @return the new batch of security logs which is a list of {@link SecurityEvent},
 * or {@code null} if rate limitation is exceeded or if logging is currently disabled.
 * @throws SecurityException if {@code admin} is not allowed to access security logging,
 * or there is at least one profile or secondary user that is not affiliated with the device.
 * @see #isAffiliatedUser
 * @see DeviceAdminReceiver#onSecurityLogsAvailable
 */
","/**
 * Called by device owner or profile owner of an organization-owned managed profile to retrieve
 * all new security logging entries since the last call to this API after device boots.
 *
 * <p> Access to the logs is rate limited and it will only return new logs after the device
 * owner has been notified via {@link DeviceAdminReceiver#onSecurityLogsAvailable}.
 *
 * <p> When called by a device owner, if there is any other user or profile on the device,
 * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.
 * See {@link #isAffiliatedUser}.
 *
 * @param admin Which device admin this request is associated with.
 * @return the new batch of security logs which is a list of {@link SecurityEvent},
 * or {@code null} if rate limitation is exceeded or if logging is currently disabled.
 * @throws SecurityException if {@code admin} is not allowed to access security logging,
 * or there is at least one profile or secondary user that is not affiliated with the device.
 * @see #isAffiliatedUser
 * @see DeviceAdminReceiver#onSecurityLogsAvailable
 */
",-1,[@Nullable],"[@SuppressLint(""NullableCollection""), @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The method mService.retrieveSecurityLogs() now includes an additional parameter, the package name retrieved by mContext.getPackageName(). This change is only in the dependent API call within the method, so the code change type is 5.","Although there is a change in how the dependent API is called (an extra parameter is passed), there is no indication that the method's behavior has been modified in a way that would lead to a different return value or a different exception being thrown under the same conditions. Therefore, no compatibility issue is expected, which corresponds to CI type 0."
636,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: int hashCode()>,30,31,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: int hashCode()>,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: int hashCode()>,0,"{
    return HashCodeHelpers.hashCode(mFormat, Boolean.hashCode(mIsInput), mAvailableSizes.hashCode());
}","{
    return HashCodeHelpers.hashCode(mFormat, Boolean.hashCode(mIsInput), Boolean.hashCode(mIsUltraHighResolution), mAvailableSizes.hashCode());
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method hashCode() has been modified to include an additional Boolean.hashCode(mIsUltraHighResolution) in the hash calculation. This is a change in the return statement as it now potentially returns a different hash value due to the additional field being considered. It is also an other statement change as there is a new boolean hash code calculation added to the existing method. Therefore, the code change types are 1 and 4.","Since the hashCode() implementation has been modified to incorporate an additional field (mIsUltraHighResolution), the returned hash value may differ when comparing objects from the early version to those from the late version. This represents a potential Compatibility Issue due to possibly different return values, so the CI type is 1."
637,<android.app.ActivityThread.H: String codeToString(int)>,30,31,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
            case ATTACH_STARTUP_AGENTS:
                return ""ATTACH_STARTUP_AGENTS"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
            case ON_NEW_ACTIVITY_OPTIONS:
                return ""ON_NEW_ACTIVITY_OPTIONS"";
            case ENTER_ANIMATION_COMPLETE:
                return ""ENTER_ANIMATION_COMPLETE"";
            case LOCAL_VOICE_INTERACTION_STARTED:
                return ""LOCAL_VOICE_INTERACTION_STARTED"";
            case ATTACH_AGENT:
                return ""ATTACH_AGENT"";
            case APPLICATION_INFO_CHANGED:
                return ""APPLICATION_INFO_CHANGED"";
            case RUN_ISOLATED_ENTRY_POINT:
                return ""RUN_ISOLATED_ENTRY_POINT"";
            case EXECUTE_TRANSACTION:
                return ""EXECUTE_TRANSACTION"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PURGE_RESOURCES:
                return ""PURGE_RESOURCES"";
            case ATTACH_STARTUP_AGENTS:
                return ""ATTACH_STARTUP_AGENTS"";
            case UPDATE_UI_TRANSLATION_STATE:
                return ""UPDATE_UI_TRANSLATION_STATE"";
            case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
                return ""SET_CONTENT_CAPTURE_OPTIONS_CALLBACK"";
            case DUMP_GFXINFO:
                return ""DUMP GFXINFO"";
            case INSTRUMENT_WITHOUT_RESTART:
                return ""INSTRUMENT_WITHOUT_RESTART"";
            case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
                return ""FINISH_INSTRUMENTATION_WITHOUT_RESTART"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
639,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,30,31,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,<android.app.ContextImpl: Context createDeviceProtectedStorageContext()>,0,"{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, mSplitName, mToken, mUser, flags, mClassLoader, null);
}","{
    final int flags = (mFlags & ~Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE) | Context.CONTEXT_DEVICE_PROTECTED_STORAGE;
    return new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, flags, mClassLoader, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The creation of the ContextImpl object has changed due to the different parameters passed to its constructor. This indicates a change in the dependent API (constructor of ContextImpl) and an ""Other statement changed"" due to the change in how the constructor is called. The changes include the addition of 'mParams', 'mAttributionSource.getAttributionTag()', and 'mAttributionSource.getNext()' instead of 'mAttributionTag', suggesting a change in the dependent API as well as how the new ContextImpl object is created.","The change is an internal change in the way the new ContextImpl is instantiated, with additional information being passed to it. However, this does not indicate a compatibility issue, as the return type remains Context and no new exceptions have been introduced or existing exceptions altered that could cause different exception handling behavior. The control flow of the method has not been altered, nor has the logic that could lead to different returned values, so no compatibility issue due to different returned values or exceptions is expected. Therefore, no compatibility issue is expected from this change."
640,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,30,31,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: boolean setShowMode(int)>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setSoftKeyboardShowMode(showMode);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.setSoftKeyboardShowMode(showMode);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Sets the soft keyboard show mode.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
","/**
 * Sets the soft keyboard show mode.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been called) or the
 * service has been disconnected, this method will have no effect and return {@code false}.
 *
 * @param showMode the new show mode for the soft keyboard
 * @return {@code true} on success
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There is a change in the parameter passed to getInstance() method of AccessibilityInteractionClient from mService.mConnectionId to mService, so the code change type is 5.",There is no Compatibility Issue as the change in method parameters does not affect the return value or exception handling of the setShowMode method itself; the method's behavior is unchanged from the perspective of the caller.
641,"<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>",30,31,"<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>","<android.content.ContentResolver: Bundle call(String,String,String,Bundle)>",0,"{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    try {
        if (mWrapped != null)
            return mWrapped.call(authority, method, arg, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        final Bundle res = provider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    try {
        if (mWrapped != null)
            return mWrapped.call(authority, method, arg, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(authority);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown authority "" + authority);
    }
    try {
        final Bundle res = provider.call(mContext.getAttributionSource(), authority, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,,,-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method provider.call() within the try block now receives 'mContext.getAttributionSource()' instead of 'mPackageName' and 'mAttributionTag'. This change indicates altered method parameters for a dependent API call, thereby classified as code change types 4 and 5.","Despite the change in the parameters passed to the provider.call() method, the change itself does not directly lead to different return values/types or cause changes in exception handling. The wrapper of provider.call() is expected to resolve the attribution source internally, potentially maintaining API behavior consistency. Therefore, this modification does not constitute a compatibility issue."
642,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>",30,31,"<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>","<android.content.res.ResourcesImpl.ThemeImpl: TypedArray resolveAttributes(Theme,int[],int[])>",0,"{
    synchronized (mKey) {
        final int len = attrs.length;
        if (values == null || len != values.length) {
            throw new IllegalArgumentException(""Base attribute values must the same length as attrs"");
        }
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        mAssets.resolveAttrs(mTheme, 0, 0, values, attrs, array.mData, array.mIndices);
        array.mTheme = wrapper;
        array.mXml = null;
        return array;
    }
}","{
    final int len = attrs.length;
    if (values == null || len != values.length) {
        throw new IllegalArgumentException(""Base attribute values must the same length as attrs"");
    }
    final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
    mAssets.resolveAttrs(mTheme, 0, 0, values, attrs, array.mData, array.mIndices);
    array.mTheme = wrapper;
    array.mXml = null;
    return array;
}",1,,,-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3,4",0,"There is a removal of the 'synchronized' block, which is a control dependency change (3). No other statements that could affect the execution flow or return type/value were changed. The annotations have remained the same. So, aside from the synchronization change, there is also an Other statement changed (4) due to the removal of the 'synchronized' keyword.","Removing the 'synchronized' block doesn't lead to a change in behavior related to the values being returned or the exceptions being thrown; however, it does affect thread safety. The API function will execute the same code with or without synchronization when called independently, not affecting the return values or the exceptions thrown. Thus, no Compatibility Issue is expected from this specific change in terms of API contract (0)."
643,<android.view.Display: boolean isValid()>,30,31,<android.view.Display: boolean isValid()>,<android.view.Display: boolean isValid()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mIsValid;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mIsValid;
    }
}",1,"/**
 * Returns true if this display is still valid, false if the display has been removed.
 *
 * If the display is invalid, then the methods of this class will
 * continue to report the most recently observed display information.
 * However, it is unwise (and rather fruitless) to continue using a
 * {@link Display} object after the display's demise.
 *
 * It's possible for a display that was previously invalid to become
 * valid again if a display with the same id is reconnected.
 *
 * @return True if the display is still valid.
 */
","/**
 * Returns true if this display is still valid, false if the display has been removed.
 *
 * If the display is invalid, then the methods of this class will
 * continue to report the most recently observed display information.
 * However, it is unwise (and rather fruitless) to continue using a
 * {@link Display} object after the display's demise.
 *
 * It's possible for a display that was previously invalid to become
 * valid again if a display with the same id is reconnected.
 *
 * @return True if the display is still valid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object used for synchronization has changed from 'this' to 'mLock', which is an other statement change.","This change in the locking object does not affect the return value nor does it introduce new exception handling. The method still returns 'mIsValid', and the synchronization is an internal mechanism to ensure thread-safety. Hence, there isn't any compatibility issue caused by this change."
645,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",30,31,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, true, true, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,4,0,"The only modification is in one of the parameters of the method `ActivityManager.getService().broadcastIntentWithFeature`, where the literal `null` is passed instead of `AppOpsManager.OP_NONE`. This is an internal change affecting a literal value within a method call, which constitutes an ""Other statement changed"" (type 4) scenario.","There is no Compatibility Issue because the change is related to an internal parameter and assuming that `null` and `AppOpsManager.OP_NONE` have the same effect within the method call `broadcastIntentWithFeature`, it will not affect the outgoing behavior of the `sendStickyOrderedBroadcast` method itself. Therefore, there are no return value changes or exceptions being handled differently from the public API perspective."
646,<android.bluetooth.BluetoothGatt: boolean readRemoteRssi()>,30,31,<android.bluetooth.BluetoothGatt: boolean readRemoteRssi()>,<android.bluetooth.BluetoothGatt: boolean readRemoteRssi()>,0,"{
    if (DBG)
        Log.d(TAG, ""readRssi() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.readRemoteRssi(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""readRssi() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.readRemoteRssi(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Read the RSSI for a connected remote device.
 *
 * <p>The {@link BluetoothGattCallback#onReadRemoteRssi} callback will be
 * invoked when the RSSI value has been read.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the RSSI value has been requested successfully
 */
","/**
 * Read the RSSI for a connected remote device.
 *
 * <p>The {@link BluetoothGattCallback#onReadRemoteRssi} callback will be
 * invoked when the RSSI value has been read.
 *
 * @return true, if the RSSI value has been requested successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The signature of the dependent API 'mService.readRemoteRssi' has changed with an additional parameter 'mAttributionSource' being passed in the late version, making the code change type 5.","There's no Compatibility Issue detected because the change does not affect the return value or the exceptions thrown by the method directly; the method still returns 'true' upon success or 'false' if the service is not available or if 'mClientIf' equals 0, as it did in the early version. The exception handling has not been modified either. The change in the dependent API is internal and does not imply a change in behavior from the perspective of the client code using this API."
647,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,30,31,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,<android.bluetooth.le.BluetoothLeScanner: void stopScan(PendingIntent)>,0,"{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, mOpPackageName);
    } catch (RemoteException e) {
    }
}","{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, mAttributionSource);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Stops an ongoing Bluetooth LE scan started using a PendingIntent. When creating the
 * PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT flag. Otherwise, the stop
 * scan may have no effect.
 *
 * @param callbackIntent The PendingIntent that was used to start the scan.
 * @see #startScan(List, ScanSettings, PendingIntent)
 */
","/**
 * Stops an ongoing Bluetooth LE scan started using a PendingIntent. When creating the
 * PendingIntent parameter, please do not use the FLAG_CANCEL_CURRENT flag. Otherwise, the stop
 * scan may have no effect.
 *
 * @param callbackIntent The PendingIntent that was used to start the scan.
 * @see #startScan(List, ScanSettings, PendingIntent)
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothScanPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)]",-1,-1,-1,-1,-1,-1,5,0,"The parameter passed to gatt.stopScanForIntent() has changed from mOpPackageName to mAttributionSource, which indicates a change in a dependent API, so the code change type is 5.","The change in parameters being passed to the dependent API does not lead to a change in the return type or value, nor does it change the exception handling. The method itself still does not return a value or throw a new exception. Therefore, no compatibility issue is introduced, and the CI type is 0."
648,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",30,31,"<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>","<android.content.res.Resources.Theme: TypedArray obtainStyledAttributes(AttributeSet,int[],int,int)>",0,"{
    return mThemeImpl.obtainStyledAttributes(this, set, attrs, defStyleAttr, defStyleRes);
}","{
    synchronized (mLock) {
        return mThemeImpl.obtainStyledAttributes(this, set, attrs, defStyleAttr, defStyleRes);
    }
}",1,"/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved. These attribute IDs must be sorted
 * in ascending order.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
","/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the ""style"" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * ""style"").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor=""#ff000000""&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved. These attribute IDs must be sorted
 * in ascending order.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"3, 4",0,"The late version adds a synchronization block (synchronized (mLock)) around the return statement, which is a control dependency change (type 3). It is not a change in the functionality of the method itself, but rather the way it is accessed, so it also includes an 'Other statement changed' (type 4) due to the introduction of synchronization.","There is no Compatibility Issue because the synchronization only affects the thread-safety of the method; it does not change the behavior, value, or type of the return, nor does it introduce new exceptions or change exception handling. So, callers of this method will not experience any difference in the method's output or behavior as a result of this change."
651,<android.app.Activity: void showLockTaskEscapeMessage()>,30,31,<android.app.Activity: void showLockTaskEscapeMessage()>,<android.app.Activity: void showLockTaskEscapeMessage()>,0,"{
    try {
        ActivityTaskManager.getService().showLockTaskEscapeMessage(mToken);
    } catch (RemoteException e) {
    }
}","{
    ActivityClient.getInstance().showLockTaskEscapeMessage(mToken);
}",1,"/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
","/**
 * Shows the user the system defined message for telling the user how to exit
 * lock task mode. The task containing this activity must be in lock task mode at the time
 * of this call for the message to be displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method being called has changed from ActivityTaskManager.getService().showLockTaskEscapeMessage to ActivityClient.getInstance().showLockTaskEscapeMessage, which indicates that there is a change in the dependent API, so the code change type is 4,5.","Given that the new method call is still encapsulated in the same try-catch block structure and there's no catch body that could lead to different behaviors, no new return or exception handling statement has been introduced or deleted. The catch block is empty in both versions; therefore, there would be no Compatibility Issue due to changing the method used to show the lock task escape message as long as the new method calls are functionally equivalent in terms of exception handling and return values (the return type is void, so no return value is affected), the CI type is 0."
652,<android.bluetooth.BluetoothManager: List<BluetoothDevice> getConnectedDevices(int)>,30,31,<android.bluetooth.BluetoothManager: List<BluetoothDevice> getConnectedDevices(int)>,<android.bluetooth.BluetoothManager: List<BluetoothDevice> getConnectedDevices(int)>,0,"{
    if (DBG)
        Log.d(TAG, ""getConnectedDevices"");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException(""Profile not supported: "" + profile);
    }
    List<BluetoothDevice> connectedDevices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return connectedDevices;
        connectedDevices = iGatt.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED });
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return connectedDevices;
}","{
    if (DBG)
        Log.d(TAG, ""getConnectedDevices"");
    return getDevicesMatchingConnectionStates(profile, new int[] { BluetoothProfile.STATE_CONNECTED });
}",1,"/**
 * Get connected devices for the specified profile.
 *
 * <p> Return the set of devices which are in state {@link BluetoothProfile#STATE_CONNECTED}
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of Bluetooth for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of Bluetooth.
 *
 * @param profile GATT or GATT_SERVER
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get connected devices for the specified profile.
 *
 * <p> Return the set of devices which are in state {@link BluetoothProfile#STATE_CONNECTED}
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of Bluetooth for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of Bluetooth.
 *
 * @param profile GATT or GATT_SERVER
 * @return List of devices. The list will be empty on error.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The early implementation contains a conditional statement with a subsequent `throw` for illegal argument (profile validation), a try-catch block involving remote method calls, and explicit creation of an `ArrayList<BluetoothDevice>`. In the late implementation, this has been replaced with a single return statement calling `getDevicesMatchingConnectionStates`, and the explicit check and throw of `IllegalArgumentException` has been removed, as well as the remote invocation code within the try-catch block. The implementation has significantly changed to rely on a different method that is now also responsible for throwing exceptions for unsupported profiles. Moreover, annotation changes indicate permission requirements changes. This indicates changes in dependent APIs, other statements, and return statements due to a change in flow and potential output of the method, hence the change type is 1,4,5.","By directly invoking a new method that likely contains the profile check internally, this change could lead to different exceptions being thrown (for example, by changing the exception type or message), which would be a CI introduced due to potentially different exception handlings (type 2). Changes in the method behavior due to the removal of explicit local checks and exception handling also prompt concerns about the possibility of changing the return value in case the `getDevicesMatchingConnectionStates` behaves differently than the original inline code, accounting for CI type 1. Additionally, the annotations now include more specific permission requirements, suggesting there's an applied change that may affect the behaviour of the method when permissions are differently handled, which could also change the return value depending on the permission enforcement logic, further confirming CI type 1."
653,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",30,31,"<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>","<android.os.BaseBundle: void writeToParcelInner(Parcel,int)>",0,"{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // dummy, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}","{
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    synchronized (this) {
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }
    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    // placeholder, will hold length
    parcel.writeInt(-1);
    parcel.writeInt(BUNDLE_MAGIC);
    int startPos = parcel.dataPosition();
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();
    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the implementations of writeToParcelInner method between the early version and the late version.,"Since there is no change in the implementation, there is no compatibility issue."
657,"<android.app.Activity: void finishActivityFromChild(Activity,int)>",30,31,"<android.app.Activity: void finishActivityFromChild(Activity,int)>","<android.app.Activity: void finishActivityFromChild(Activity,int)>",0,"{
    try {
        ActivityTaskManager.getService().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
    } catch (RemoteException e) {
    // Empty
    }
}","{
    ActivityClient.getInstance().finishSubActivity(mToken, child.mEmbeddedID, requestCode);
}",1,"/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 * @deprecated Use {@link #finishActivity(int)} instead.
 */
","/**
 * This is called when a child activity of this one calls its
 * finishActivity().
 *
 * @param child The activity making the call.
 * @param requestCode Request code that had been used to start the
 * activity.
 * @deprecated Use {@link #finishActivity(int)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,5",2,"The try-catch block has been removed, and the method used to finish a subactivity has changed from ActivityTaskManager.getService().finishSubActivity to ActivityClient.getInstance().finishSubActivity, resulting in both an exception handling statement change (type 2) and a change in the dependent API being called (type 5).","The removal of the try-catch block means that any RemoteExceptions previously caught will now propagate up the call stack, potentially causing a different behavior when exceptions are thrown, so the CI type is 2."
659,<android.content.pm.ShortcutManager: Intent createShortcutResultIntent(ShortcutInfo)>,30,31,<android.content.pm.ShortcutManager: Intent createShortcutResultIntent(ShortcutInfo)>,<android.content.pm.ShortcutManager: Intent createShortcutResultIntent(ShortcutInfo)>,0,"{
    try {
        return mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getFutureOrThrow(mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns an Intent which can be used by the default launcher to pin a shortcut containing the
 * given {@link ShortcutInfo}. This method should be used by an Activity to set a result in
 * response to {@link Intent#ACTION_CREATE_SHORTCUT}.
 *
 * @param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
 * or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
 * be set, in which case, the target shortcut must be enabled.
 * If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @return The intent that should be set as the result for the calling activity, or
 * <code>null</code> if the current launcher doesn't support shortcuts.
 *
 * @see Intent#ACTION_CREATE_SHORTCUT
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 */
","/**
 * Returns an Intent which can be used by the default launcher to pin a shortcut containing the
 * given {@link ShortcutInfo}. This method should be used by an Activity to set a result in
 * response to {@link Intent#ACTION_CREATE_SHORTCUT}.
 *
 * @param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
 * or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
 * be set, in which case, the target shortcut must be enabled.
 * If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @return The intent that should be set as the result for the calling activity, or
 * <code>null</code> if the current launcher doesn't support shortcuts.
 *
 * @see Intent#ACTION_CREATE_SHORTCUT
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,"4,5",0,"The method getFutureOrThrow() wraps the call to mService.createShortcutResultIntent() but does not necessarily indicate a change in return value or behavior, assuming getFutureOrThrow() simply retrieves the result from a Future without altering it. However, there is a dependent API changed because getFutureOrThrow() wraps the service call which is considered a dependency, so the code change type is 4,5.","Since getFutureOrThrow() is assumed to return the same value as mService.createShortcutResultIntent() would directly (as it gets the result from the Future object), there is no compatibility issue related to return value difference. Therefore, no compatibility issue is detected, and the CI type is 0."
660,<android.view.View: int[] onCreateDrawableState(int)>,30,31,<android.view.View: int[] onCreateDrawableState(int)>,<android.view.View: int[] onCreateDrawableState(int)>,0,"{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= StateSet.VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= StateSet.VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= StateSet.VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && ThreadedRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= StateSet.VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_CAN_ACCEPT;
    }
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_HOVERED;
    }
    drawableState = StateSet.get(viewStateIndex);
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}","{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= StateSet.VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= StateSet.VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= StateSet.VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= StateSet.VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= StateSet.VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_CAN_ACCEPT;
    }
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        viewStateIndex |= StateSet.VIEW_STATE_DRAG_HOVERED;
    }
    drawableState = StateSet.get(viewStateIndex);
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}",1,"/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
","/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
661,<android.app.PendingIntent: String toString()>,30,31,<android.app.PendingIntent: String toString()>,<android.app.PendingIntent: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""PendingIntent{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("": "");
    sb.append(mTarget != null ? mTarget.asBinder() : null);
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""PendingIntent{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("": "");
    sb.append(mTarget.asBinder());
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The control dependency has been removed (mTarget != null is removed) and a part of the statement in the StringBuilder has been changed (from mTarget != null ? mTarget.asBinder() : null to mTarget.asBinder()), so the code change type is 1,4.","The removal of the null check on mTarget potentially changes the return value of the method. If mTarget is null, the early version returns 'null' as part of the string whereas the late version would throw a NullPointerException, resulting in a different program behavior. Therefore, there is a Compatibility Issue caused by a potential different return value, and thus the CI type is 1."
662,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",30,31,"<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>","<android.accessibilityservice.AccessibilityService: boolean dispatchGesture(GestureDescription,GestureResultCallback,Handler)>",0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    List<GestureDescription.GestureStep> steps = MotionEventGenerator.getGestureStepsFromGestureDescription(gesture, 16);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.dispatchGesture(mGestureStatusCallbackSequence, new ParceledListSlice<>(steps), gesture.getDisplayId());
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection == null) {
        return false;
    }
    int sampleTimeMs = calculateGestureSampleTimeMs(gesture.getDisplayId());
    List<GestureDescription.GestureStep> steps = MotionEventGenerator.getGestureStepsFromGestureDescription(gesture, sampleTimeMs);
    try {
        synchronized (mLock) {
            mGestureStatusCallbackSequence++;
            if (callback != null) {
                if (mGestureStatusCallbackInfos == null) {
                    mGestureStatusCallbackInfos = new SparseArray<>();
                }
                GestureResultCallbackInfo callbackInfo = new GestureResultCallbackInfo(gesture, callback, handler);
                mGestureStatusCallbackInfos.put(mGestureStatusCallbackSequence, callbackInfo);
            }
            connection.dispatchGesture(mGestureStatusCallbackSequence, new ParceledListSlice<>(steps), gesture.getDisplayId());
        }
    } catch (RemoteException re) {
        throw new RuntimeException(re);
    }
    return true;
}",1,"/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
","/**
 * Dispatch a gesture to the touch screen. Any gestures currently in progress, whether from
 * the user, this service, or another service, will be cancelled.
 * <p>
 * The gesture will be dispatched as if it were performed directly on the screen by a user, so
 * the events may be affected by features such as magnification and explore by touch.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to dispatch gestures, your service
 * must declare the capability by setting the
 * {@link android.R.styleable#AccessibilityService_canPerformGestures}
 * property in its meta-data. For more information, see
 * {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @param gesture The gesture to dispatch
 * @param callback The object to call back when the status of the gesture is known. If
 * {@code null}, no status is reported.
 * @param handler The handler on which to call back the {@code callback} object. If
 * {@code null}, the object is called back on the service's main thread.
 *
 * @return {@code true} if the gesture is dispatched, {@code false} if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The method call to `AccessibilityInteractionClient.getInstance()` has been updated to pass in `this` as an argument indicating a change in how the instance is obtained, which is a dependent API change. The gesture sample time calculation is now dynamic, being determined by `calculateGestureSampleTimeMs(gesture.getDisplayId())` rather than fixed to the constant value `16`, thus there is a control dependency change and an other statement changed. These changes in how the steps are computed and how the connection is obtained are classified as type 3, 4, 5.","As the method now computes the sample time dynamically, the gesture steps calculated and consequently the behavior of the `dispatchGesture` method could be different. This variation may result in a different return value (true if the dispatch is successful, false otherwise) under certain conditions, so the CI type is 1."
663,<android.content.pm.LauncherActivityInfo: String getName()>,30,31,<android.content.pm.LauncherActivityInfo: String getName()>,<android.content.pm.LauncherActivityInfo: String getName()>,0,"{
    return mActivityInfo.name;
}","{
    return getActivityInfo().name;
}",1,"/**
 * Returns the name for the acitivty from  android:name in the manifest.
 * @return the name from android:name for the acitivity.
 */
","/**
 * Returns the name for the activity from  android:name in the manifest.
 * @return the name from android:name for the activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change in the method used to obtain the activity information: from directly accessing mActivityInfo to calling getActivityInfo(). However, this does not necessarily indicate a change in behavior as long as getActivityInfo() returns the same mActivityInfo. The code change type is 4 due to calling a different method, and 5 because there's a possibility that the implementation of getActivityInfo() might have changed which affects this API.","Since there is no change in the structure of control dependencies or exception handling, and assuming getActivityInfo() is intended to return the same mActivityInfo object as used in the earlier version, there is no indication of a compatibility issue based on the provided code snippet. The return value should remain consistent assuming getActivityInfo() serves the same purpose and behaves consistently. Therefore, the CI type is 0."
664,<android.accessibilityservice.AccessibilityService: FingerprintGestureController getFingerprintGestureController()>,30,31,<android.accessibilityservice.AccessibilityService: FingerprintGestureController getFingerprintGestureController()>,<android.accessibilityservice.AccessibilityService: FingerprintGestureController getFingerprintGestureController()>,0,"{
    if (mFingerprintGestureController == null) {
        mFingerprintGestureController = new FingerprintGestureController(AccessibilityInteractionClient.getInstance().getConnection(mConnectionId));
    }
    return mFingerprintGestureController;
}","{
    if (mFingerprintGestureController == null) {
        mFingerprintGestureController = new FingerprintGestureController(AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId));
    }
    return mFingerprintGestureController;
}",1,"/**
 * Get the controller for fingerprint gestures. This feature requires {@link
 * AccessibilityServiceInfo#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES}.
 *
 * <strong>Note: </strong> The service must be connected before this method is called.
 *
 * @return The controller for fingerprint gestures, or {@code null} if gestures are unavailable.
 */
","/**
 * Get the controller for fingerprint gestures. This feature requires {@link
 * AccessibilityServiceInfo#CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES}.
 *
 * <strong>Note: </strong> The service must be connected before this method is called.
 *
 * @return The controller for fingerprint gestures, or {@code null} if gestures are unavailable.
 */
",-1,"[@RequiresPermission(android.Manifest.permission.USE_FINGERPRINT), @NonNull]","[@RequiresPermission(android.Manifest.permission.USE_FINGERPRINT), @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The change is related to the instantiation of `FingerprintGestureController` where the `getInstance` method of `AccessibilityInteractionClient` has been called with a different parameter; it has changed from `getInstance().getConnection(mConnectionId)` to `getInstance(this).getConnection(mConnectionId)`. This indicates a change to a dependent API, so the code change type is 5.","Since this change only affects the internal object creation and does not affect the return value or exception handling of the `getFingerprintGestureController()` method, there is no compatibility issue. Therefore, the CI type is 0."
665,<android.net.Uri.Part: Part fromDecoded(String)>,30,31,<android.net.Uri.Part: Part fromDecoded(String)>,<android.net.Uri.Part: Part fromDecoded(String)>,0,"{
    return from(NOT_CACHED, decoded);
}","{
    return from(NotCachedHolder.NOT_CACHED, decoded);
}",1,"/**
 * Creates a part from the decoded string.
 *
 * @param decoded part string
 */
","/**
 * Creates a part from the decoded string.
 *
 * @param decoded part string
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in how the NOT_CACHED constant is accessed. It is accessed through the NotCachedHolder class in the late version instead of directly, so the code change type is 5.","This change does not cause any potential behavior change that would lead to a CI as the value of NOT_CACHED remains the same and is simply being accessed through a different mechanism (presumably an inner class or similar construct). The returned Part object will still be constructed with the same parameter values, implying no CI, so the CI type is 0."
666,<android.view.textclassifier.TextClassificationSession: TextLinks generateLinks(Request)>,30,31,<android.view.textclassifier.TextClassificationSession: TextLinks generateLinks(Request)>,<android.view.textclassifier.TextClassificationSession: TextLinks generateLinks(Request)>,0,"{
    checkDestroyed();
    return mDelegate.generateLinks(request);
}","{
    return checkDestroyedAndRun(() -> mDelegate.generateLinks(request));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",0,"The implementation has been changed from a direct method call with a check to a lambda expression encapsulated in the method checkDestroyedAndRun(). This introduces a change in the control dependency and a new dependent API, so the change type is 1,3,5.","There are changes made to how the method operates internally, but these changes do not affect the behavior visible to the caller of generateLinks(). The return value is still the result of mDelegate.generateLinks(request) and assuming checkDestroyedAndRun() is properly implemented to only run the lambda if not destroyed, there should be no Compatibility Issue. Therefore, the CI type is 0."
667,<android.view.inputmethod.InlineSuggestionInfo: String toString()>,30,31,<android.view.inputmethod.InlineSuggestionInfo: String toString()>,<android.view.inputmethod.InlineSuggestionInfo: String toString()>,0,"{
    return ""InlineSuggestionInfo { "" + ""inlinePresentationSpec = "" + mInlinePresentationSpec + "", "" + ""source = "" + mSource + "", "" + ""autofillHints = "" + java.util.Arrays.toString(mAutofillHints) + "", "" + ""type = "" + mType + "", "" + ""pinned = "" + mPinned + "" }"";
}","{
    return ""InlineSuggestionInfo { "" + ""inlinePresentationSpec = "" + mInlinePresentationSpec + "", "" + ""source = "" + mSource + "", "" + ""autofillHints = "" + java.util.Arrays.toString(mAutofillHints) + "", "" + ""type = "" + mType + "", "" + ""pinned = "" + mPinned + "", "" + ""tooltip = "" + mTooltip + "" }"";
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,0,"There is a new string concatenation with the member variable `mTooltip` added to the return statement of the method, which is classified as another statement changed (code change type 4).","The modification to the implementation of `toString()` method is a non-breaking change that only affects the string representation of the object but does not alter its behavior in a way that could cause existing clients to face issues. As such, this change does not cause a compatibility issue (CI type 0)."
668,<android.view.Display: void getRealMetrics(DisplayMetrics)>,30,31,<android.view.Display: void getRealMetrics(DisplayMetrics)>,<android.view.Display: void getRealMetrics(DisplayMetrics)>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, null);
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustMetrics(outMetrics, mDisplayInfo.rotation);
        }
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (shouldReportMaxBounds()) {
            mDisplayInfo.getMaxBoundsMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mResources.getConfiguration());
            if (DEBUG) {
                Log.d(TAG, ""getRealMetrics determined from max bounds: "" + outMetrics);
            }
            // should already reflect the expected rotation.
            return;
        }
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, null);
        if (mMayAdjustByFixedRotation) {
            getDisplayAdjustments().adjustMetrics(outMetrics, mDisplayInfo.rotation);
        }
    }
}",1,"/**
 * Gets display metrics based on the real size of this display.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * </p><p>
 * The real size may be smaller than the physical size of the screen when the
 * window manager is emulating a smaller display (using adb shell wm size).
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 */
","/**
 * Gets the size of the largest region of the display accessible to an app in the current system
 * state, without subtracting any window decor or applying scaling factors.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * <p></p>
 * The returned size will fall into one of these scenarios:
 * <ol>
 * <li>The device has no partitions on the display. The returned value is the largest region
 * of the display accessible to an app in the current system state, regardless of windowing
 * mode.</li>
 * <li>The device divides a single display into multiple partitions. An application is
 * restricted to a portion of the display. This is common in devices where the display changes
 * size, such as foldables or large screens. The returned size will match the portion of
 * the display the application is restricted to.</li>
 * <li>The window manager is emulating a different display size, using {@code adb shell wm
 * size}. The returned size will match the emulated display size.</li>
 * </ol>
 * </p><p>
 * The returned value is <b>unsuitable to use when sizing and placing UI elements</b>, since it
 * does not reflect the application window size in any of these scenarios.
 * {@link WindowManager#getCurrentWindowMetrics()} is an alternative that returns the size
 * of the current application window, even if the window is on a device with a partitioned
 * display. This helps prevent UI bugs where UI elements are misaligned or placed beyond the
 * bounds of the window.
 * <p></p>
 * Handling multi-window mode correctly is necessary since applications are not always
 * fullscreen. A user on a large screen device, such as a tablet or Chrome OS devices, is more
 * likely to use multi-window modes.
 * <p></p>
 * For example, consider a device with a display partitioned into two halves. The user may have
 * a fullscreen application open on the first partition. They may have two applications open in
 * split screen (an example of multi-window mode) on the second partition, with each application
 * consuming half of the partition. In this case,
 * {@link WindowManager#getCurrentWindowMetrics()} reports the fullscreen window is half of the
 * screen in size, and each split screen window is a quarter of the screen in size. On the other
 * hand, {@link #getRealMetrics} reports half of the screen size for all windows, since the
 * application windows are all restricted to their respective partitions.
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 * @deprecated Use {@link WindowManager#getCurrentWindowMetrics()} to identify the current size
 * of the activity window. UI-related work, such as choosing UI layouts, should rely
 * upon {@link WindowMetrics#getBounds()}. Use {@link Configuration#densityDpi} to
 * get the current density.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,4",1,There are several changes in the method body:,"3. The presence of a `return;` statement within the new condition block indicates a ""Return statement changed""."
669,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,30,31,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleViewDebug: Chunk handleChunk(Chunk)>,0,"{
    int type = request.type;
    if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else if (op == VURT_DUMP_THEME)
            return dumpTheme(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    int type = request.type;
    if (type == CHUNK_VULW) {
        return listWindows();
    }
    ByteBuffer in = wrapChunk(request);
    int op = in.getInt();
    View rootView = getRootView(in);
    if (rootView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid View Root"");
    }
    if (type == CHUNK_VURT) {
        if (op == VURT_DUMP_HIERARCHY)
            return dumpHierarchy(rootView, in);
        else if (op == VURT_CAPTURE_LAYERS)
            return captureLayers(rootView);
        else if (op == VURT_DUMP_THEME)
            return dumpTheme(rootView);
        else
            return createFailChunk(ERR_INVALID_OP, ""Unknown view root operation: "" + op);
    }
    final View targetView = getTargetView(rootView, in);
    if (targetView == null) {
        return createFailChunk(ERR_INVALID_PARAM, ""Invalid target view"");
    }
    if (type == CHUNK_VUOP) {
        switch(op) {
            case VUOP_CAPTURE_VIEW:
                return captureView(rootView, targetView);
            case VUOP_DUMP_DISPLAYLIST:
                return dumpDisplayLists(rootView, targetView);
            case VUOP_PROFILE_VIEW:
                return profileView(rootView, targetView);
            case VUOP_INVOKE_VIEW_METHOD:
                return invokeViewMethod(rootView, targetView, in);
            case VUOP_SET_LAYOUT_PARAMETER:
                return setLayoutParameter(rootView, targetView, in);
            default:
                return createFailChunk(ERR_INVALID_OP, ""Unknown view operation: "" + op);
        }
    } else {
        throw new RuntimeException(""Unknown packet "" + name(type));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change identified is the replacement of `ChunkHandler.name(type)` with `name(type)` in the `RuntimeException` message. This is considered an ""Other statement changed"" change because it doesn't affect the actual method execution flow or the return values, just the error message content. So, the code change type is 4.","Since the change in the code only affects the exception message and not the behavior of the method in terms of how it executes or the values it returns, there is no Compatibility Issue. Thus, the CI type is 0."
670,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,30,31,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,<android.speech.tts.TextToSpeech.Connection.SetupConnectionAsyncTask: Integer doInBackground(Void)>,0,"{
    synchronized (mStartLock) {
        if (isCancelled()) {
            return null;
        }
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            if (mParams.getString(Engine.KEY_PARAM_LANGUAGE) == null) {
                String[] defaultLanguage = mService.getClientDefaultLanguage();
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, defaultLanguage[0]);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, defaultLanguage[1]);
                mParams.putString(Engine.KEY_PARAM_VARIANT, defaultLanguage[2]);
                // Get the default voice for the locale.
                String defaultVoiceName = mService.getDefaultVoiceNameFor(defaultLanguage[0], defaultLanguage[1], defaultLanguage[2]);
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, defaultVoiceName);
            }
            Log.i(TAG, ""Set up connection to "" + mName);
            return SUCCESS;
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            return ERROR;
        }
    }
}","{
    synchronized (mStartLock) {
        if (isCancelled()) {
            return null;
        }
        try {
            mService.setCallback(getCallerIdentity(), mCallback);
            if (mParams.getString(Engine.KEY_PARAM_LANGUAGE) == null) {
                String[] defaultLanguage = mService.getClientDefaultLanguage();
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, defaultLanguage[0]);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, defaultLanguage[1]);
                mParams.putString(Engine.KEY_PARAM_VARIANT, defaultLanguage[2]);
                // Get the default voice for the locale.
                String defaultVoiceName = mService.getDefaultVoiceNameFor(defaultLanguage[0], defaultLanguage[1], defaultLanguage[2]);
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, defaultVoiceName);
            }
            Log.i(TAG, ""Setting up the connection to TTS engine..."");
            return SUCCESS;
        } catch (RemoteException re) {
            Log.e(TAG, ""Error connecting to service, setCallback() failed"");
            return ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There's only a change in the log message text from ""Set up connection to "" to ""Setting up the connection to TTS engine..."", which does not change the behavior of the code; thus, the change type is 4.","No Compatibility Issue arises because the modification does not affect the return value or the exception handling of the method; the only change made is in a debug log message, which has no impact on the API's functionality or output. Hence, the CI type is 0."
671,"<android.service.autofill.SaveInfo.Builder: Builder addSanitizer(Sanitizer,AutofillId)>",30,31,"<android.service.autofill.SaveInfo.Builder: Builder addSanitizer(Sanitizer,AutofillId)>","<android.service.autofill.SaveInfo.Builder: Builder addSanitizer(Sanitizer,AutofillId)>",0,"{
    throwIfDestroyed();
    Preconditions.checkArgument(!ArrayUtils.isEmpty(ids), ""ids cannot be empty or null"");
    Preconditions.checkArgument((sanitizer instanceof InternalSanitizer), ""not provided by Android System: "" + sanitizer);
    if (mSanitizers == null) {
        mSanitizers = new ArrayMap<>();
        mSanitizerIds = new ArraySet<>(ids.length);
    }
    // Check for duplicates first.
    for (AutofillId id : ids) {
        Preconditions.checkArgument(!mSanitizerIds.contains(id), ""already added %s"", id);
        mSanitizerIds.add(id);
    }
    mSanitizers.put((InternalSanitizer) sanitizer, ids);
    return this;
}","{
    throwIfDestroyed();
    Preconditions.checkArgument(!ArrayUtils.isEmpty(ids), ""ids cannot be empty or null"");
    Preconditions.checkArgument((sanitizer instanceof InternalSanitizer), ""not provided by Android System: %s"", sanitizer);
    if (mSanitizers == null) {
        mSanitizers = new ArrayMap<>();
        mSanitizerIds = new ArraySet<>(ids.length);
    }
    // Check for duplicates first.
    for (AutofillId id : ids) {
        Preconditions.checkArgument(!mSanitizerIds.contains(id), ""already added %s"", id);
        mSanitizerIds.add(id);
    }
    mSanitizers.put((InternalSanitizer) sanitizer, ids);
    return this;
}",1,"/**
 * Adds a sanitizer for one or more field.
 *
 * <p>When a sanitizer is set for a field, the {@link AutofillValue} is sent to the
 * sanitizer before a save request is <a href=""#TriggeringSaveRequest"">triggered</a>.
 *
 * <p>Typically used to avoid displaying the save UI for values that are autofilled but
 * reformattedby the app. For example, to remove spaces between every 4 digits of a
 * credit card number:
 *
 * <pre class=""prettyprint"">
 * builder.addSanitizer(new TextValueSanitizer(
 * Pattern.compile(""^(\\d{4})\\s?(\\d{4})\\s?(\\d{4})\\s?(\\d{4})$"", ""$1$2$3$4"")),
 * ccNumberId);
 * </pre>
 *
 * <p>The same sanitizer can be reused to sanitize multiple fields. For example, to trim
 * both the username and password fields:
 *
 * <pre class=""prettyprint"">
 * builder.addSanitizer(
 * new TextValueSanitizer(Pattern.compile(""^\\s*(.*)\\s*$""), ""$1""),
 * usernameId, passwordId);
 * </pre>
 *
 * <p>The sanitizer can also be used as an alternative for a
 * {@link #setValidator(Validator) validator}. If any of the {@code ids} is a
 * {@link #Builder(int, AutofillId[]) required id} and the {@code sanitizer} fails
 * because of it, then the save UI is not shown.
 *
 * @param sanitizer an implementation provided by the Android System.
 * @param ids id of fields whose value will be sanitized.
 * @return this builder.
 *
 * @throws IllegalArgumentException if a sanitizer for any of the {@code ids} has already
 * been added or if {@code ids} is empty.
 */
","/**
 * Adds a sanitizer for one or more field.
 *
 * <p>When a sanitizer is set for a field, the {@link AutofillValue} is sent to the
 * sanitizer before a save request is <a href=""#TriggeringSaveRequest"">triggered</a>.
 *
 * <p>Typically used to avoid displaying the save UI for values that are autofilled but
 * reformattedby the app. For example, to remove spaces between every 4 digits of a
 * credit card number:
 *
 * <pre class=""prettyprint"">
 * builder.addSanitizer(new TextValueSanitizer(
 * Pattern.compile(""^(\\d{4})\\s?(\\d{4})\\s?(\\d{4})\\s?(\\d{4})$"", ""$1$2$3$4"")),
 * ccNumberId);
 * </pre>
 *
 * <p>The same sanitizer can be reused to sanitize multiple fields. For example, to trim
 * both the username and password fields:
 *
 * <pre class=""prettyprint"">
 * builder.addSanitizer(
 * new TextValueSanitizer(Pattern.compile(""^\\s*(.*)\\s*$""), ""$1""),
 * usernameId, passwordId);
 * </pre>
 *
 * <p>The sanitizer can also be used as an alternative for a
 * {@link #setValidator(Validator) validator}. If any of the {@code ids} is a
 * {@link #Builder(int, AutofillId[]) required id} and the {@code sanitizer} fails
 * because of it, then the save UI is not shown.
 *
 * @param sanitizer an implementation provided by the Android System.
 * @param ids id of fields whose value will be sanitized.
 * @return this builder.
 *
 * @throws IllegalArgumentException if a sanitizer for any of the {@code ids} has already
 * been added or if {@code ids} is empty.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,0,0,"There is no change to the implementation of the method. The only difference is the error message in one of the `Preconditions.checkArgument` calls, but the conditions themselves are the same. Therefore, there is no effective code change.","Because there is no effective change to the method's behavior, no compatibility issue arises."
672,<android.view.MotionEvent: String toString()>,30,31,<android.view.MotionEvent: String toString()>,<android.view.MotionEvent: String toString()>,0,"{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    appendUnless(""0"", msg, "", actionButton="", buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        appendUnless(i, msg, "", id["" + i + ""]="", getPointerId(i));
        float x = getX(i);
        float y = getY(i);
        if (!DEBUG_CONCISE_TOSTRING || x != 0f || y != 0f) {
            msg.append("", x["").append(i).append(""]="").append(x);
            msg.append("", y["").append(i).append(""]="").append(y);
        }
        appendUnless(TOOL_TYPE_SYMBOLIC_NAMES.get(TOOL_TYPE_FINGER), msg, "", toolType["" + i + ""]="", toolTypeToString(getToolType(i)));
    }
    appendUnless(""0"", msg, "", buttonState="", MotionEvent.buttonStateToString(getButtonState()));
    appendUnless(classificationToString(CLASSIFICATION_NONE), msg, "", classification="", classificationToString(getClassification()));
    appendUnless(""0"", msg, "", metaState="", KeyEvent.metaStateToString(getMetaState()));
    appendUnless(""0"", msg, "", flags=0x"", Integer.toHexString(getFlags()));
    appendUnless(""0"", msg, "", edgeFlags=0x"", Integer.toHexString(getEdgeFlags()));
    appendUnless(1, msg, "", pointerCount="", pointerCount);
    appendUnless(0, msg, "", historySize="", getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    if (!DEBUG_CONCISE_TOSTRING) {
        msg.append("", downTime="").append(getDownTime());
        msg.append("", deviceId="").append(getDeviceId());
        msg.append("", source=0x"").append(Integer.toHexString(getSource()));
        msg.append("", displayId="").append(getDisplayId());
    }
    msg.append("" }"");
    return msg.toString();
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    appendUnless(""0"", msg, "", actionButton="", buttonStateToString(getActionButton()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        appendUnless(i, msg, "", id["" + i + ""]="", getPointerId(i));
        float x = getX(i);
        float y = getY(i);
        if (!DEBUG_CONCISE_TOSTRING || x != 0f || y != 0f) {
            msg.append("", x["").append(i).append(""]="").append(x);
            msg.append("", y["").append(i).append(""]="").append(y);
        }
        appendUnless(TOOL_TYPE_SYMBOLIC_NAMES.get(TOOL_TYPE_FINGER), msg, "", toolType["" + i + ""]="", toolTypeToString(getToolType(i)));
    }
    appendUnless(""0"", msg, "", buttonState="", MotionEvent.buttonStateToString(getButtonState()));
    appendUnless(classificationToString(CLASSIFICATION_NONE), msg, "", classification="", classificationToString(getClassification()));
    appendUnless(""0"", msg, "", metaState="", KeyEvent.metaStateToString(getMetaState()));
    appendUnless(""0"", msg, "", flags=0x"", Integer.toHexString(getFlags()));
    appendUnless(""0"", msg, "", edgeFlags=0x"", Integer.toHexString(getEdgeFlags()));
    appendUnless(1, msg, "", pointerCount="", pointerCount);
    appendUnless(0, msg, "", historySize="", getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    if (!DEBUG_CONCISE_TOSTRING) {
        msg.append("", downTime="").append(getDownTime());
        msg.append("", deviceId="").append(getDeviceId());
        msg.append("", source=0x"").append(Integer.toHexString(getSource()));
        msg.append("", displayId="").append(getDisplayId());
        msg.append("", eventId="").append(getId());
    }
    msg.append("" }"");
    return msg.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version implementation of toString() adds a new piece of information to the string ("", eventId="").append(getId()), which is reflected by a new statement in the implementation that is not related to control or exception handling. Thus, the change type is 1,4.","The addition of new information to the output of the toString() method will change the return value. Therefore, a Compatibility Issue exists due to a potential different return value, and the CI type is 1."
673,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,30,31,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,0,"{
    if (address == null || address.length != 6) {
        throw new IllegalArgumentException(""Bluetooth address must have 6 bytes"");
    }
    return new BluetoothDevice(String.format(Locale.US, ""%02X:%02X:%02X:%02X:%02X:%02X"", address[0], address[1], address[2], address[3], address[4], address[5]));
}","{
    if (address == null || address.length != 6) {
        throw new IllegalArgumentException(""Bluetooth address must have 6 bytes"");
    }
    final BluetoothDevice res = new BluetoothDevice(String.format(Locale.US, ""%02X:%02X:%02X:%02X:%02X:%02X"", address[0], address[1], address[2], address[3], address[4], address[5]));
    res.setAttributionSource(mAttributionSource);
    return res;
}",1,"/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method
 * expects the address in network byte order (MSB first).
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address Bluetooth MAC address (6 bytes)
 * @throws IllegalArgumentException if address is invalid
 */
","/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method
 * expects the address in network byte order (MSB first).
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address Bluetooth MAC address (6 bytes)
 * @throws IllegalArgumentException if address is invalid
 */
",-1,,[@RequiresNoPermission],-1,-1,-1,-1,-1,-1,4,0,"The code change involves adding a method call (setAttributionSource(mAttributionSource)) on the BluetoothDevice object before it is returned, without altering the control flow or the return value, so the change type is 4.","The change of calling setAttributionSource(mAttributionSource) on the returned BluetoothDevice object does not cause a different value to be returned by the API nor does it introduce a different exception handling path; it is simply adding additional information to the object. Therefore, there is no Compatibility Issue, CI type is 0."
675,<android.content.pm.LauncherActivityInfo: ApplicationInfo getApplicationInfo()>,30,31,<android.content.pm.LauncherActivityInfo: ApplicationInfo getApplicationInfo()>,<android.content.pm.LauncherActivityInfo: ApplicationInfo getApplicationInfo()>,0,"{
    return mActivityInfo.applicationInfo;
}","{
    return getActivityInfo().applicationInfo;
}",1,"/**
 * Returns the application info for the appliction this activity belongs to.
 * @return
 */
","/**
 * Returns the application info for the application this activity belongs to.
 * @return
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The early version directly returns mActivityInfo.applicationInfo, while the late version calls getActivityInfo() to get ActivityInfo and then returns applicationInfo. Therefore, there is a change in the dependent API, which classifies as type 5.","There's no Compatibility Issue detected as the code change pertains to an internal implementation difference and does not affect the return type or value, nor does it introduce different exceptions. The behavior of the API should remain the same assuming getActivityInfo() returns the same ActivityInfo object as mActivityInfo."
676,<android.app.Notification.BigPictureStyle: BigPictureStyle bigPicture(Bitmap)>,30,31,<android.app.Notification.BigPictureStyle: BigPictureStyle bigPicture(Bitmap)>,<android.app.Notification.BigPictureStyle: BigPictureStyle bigPicture(Bitmap)>,0,"{
    mPicture = b;
    return this;
}","{
    mPictureIcon = b == null ? null : Icon.createWithBitmap(b);
    return this;
}",1,"/**
 * Provide the bitmap to be used as the payload for the BigPicture notification.
 */
","/**
 * Provide the bitmap to be used as the payload for the BigPicture notification.
 */
",-1,,[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The variable to which the bitmap is being assigned has changed from 'mPicture' to 'mPictureIcon', which is a transformation using a new method `Icon.createWithBitmap(b)` if 'b' isn't null. However, the return type has not changed and both versions return 'this', so only Other statement changed (type 4).","There is No Compatibility Issue because the return type remains the same, which is 'this' object, and the method signature is unchanged. The functionality is internally about how the bitmap is being stored or represented within the object, which does not directly affect the API return type or exception handling from a user's perspective. Therefore, it retains the same behavior from the standpoint of someone using this method."
677,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,30,31,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,<android.view.textclassifier.TextSelection.Request.Builder: Request build()>,0,"{
    return new Request(new SpannedString(mText), mStartIndex, mEndIndex, mDefaultLocales, mDarkLaunchAllowed, mExtras == null ? Bundle.EMPTY : mExtras);
}","{
    return new Request(new SpannedString(mText), mStartIndex, mEndIndex, mDefaultLocales, mDarkLaunchAllowed, mIncludeTextClassification, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns the request object.
 */
","/**
 * Builds and returns the request object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for `Request` in the return statement has been changed with an additional parameter, `mIncludeTextClassification`, in the late version. Given that a new parameter is added, the code change type is 1,5.","The addition of the new parameter `mIncludeTextClassification` to the constructor could potentially cause the method to return a different value as this new parameter might influence the behavior of the `Request` object being constructed, therefore the CI type is 1."
678,<android.util.AtomicFile: FileOutputStream startWrite()>,30,31,<android.util.AtomicFile: FileOutputStream startWrite()>,<android.util.AtomicFile: FileOutputStream startWrite()>,0,"{
    return startWrite(mCommitTag != null ? SystemClock.uptimeMillis() : 0);
}","{
    return startWrite(0);
}",1,"/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
","/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The parameter passed to the startWrite() method has been changed from a conditional expression to a constant value, which results in the change of the return statement, thus marking it as code change type 1. Also, this change is not related to a control structure, an exception handling, or a dependent API, so another type is 4 for other statement changed.","The change in the parameter could potentially lead to the API returning a different result since it could cause a different behavior of startWrite depending on the value passed, which is now always 0 instead of conditional based on uptimeMillis(). Therefore, the CI type is 1."
679,<android.content.pm.ShortcutInfo: Intent[] getIntents()>,30,31,<android.content.pm.ShortcutInfo: Intent[] getIntents()>,<android.content.pm.ShortcutInfo: Intent[] getIntents()>,0,"{
    final Intent[] ret = new Intent[mIntents.length];
    for (int i = 0; i < ret.length; i++) {
        ret[i] = new Intent(mIntents[i]);
        setIntentExtras(ret[i], mIntentPersistableExtrases[i]);
    }
    return ret;
}","{
    if (mIntents == null) {
        return null;
    }
    final Intent[] ret = new Intent[mIntents.length];
    for (int i = 0; i < ret.length; i++) {
        ret[i] = new Intent(mIntents[i]);
        setIntentExtras(ret[i], mIntentPersistableExtrases[i]);
    }
    return ret;
}",1,"/**
 * Return the intent set with {@link Builder#setIntents(Intent[])}.
 *
 * <p>Launcher apps <b>cannot</b> see the intents.  If a {@link ShortcutInfo} is
 * obtained via {@link LauncherApps}, then this method will always return null.
 * Launchers can only start a shortcut intent with {@link LauncherApps#startShortcut}.
 *
 * @see Builder#setIntents(Intent[])
 */
","/**
 * Return the intent set with {@link Builder#setIntents(Intent[])}.
 *
 * <p>Launcher apps <b>cannot</b> see the intents.  If a {@link ShortcutInfo} is
 * obtained via {@link LauncherApps}, then this method will always return null.
 * Launchers can only start a shortcut intent with {@link LauncherApps#startShortcut}.
 *
 * @see Builder#setIntents(Intent[])
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,1,"The code change includes the addition of a new control dependency; if `mIntents` is null, it now returns null directly, which is a control dependency change, so the change type is 3.","The addition of a null check for `mIntents` adds a new code path that returns null, which could lead to the API returning a different value under certain circumstances (when `mIntents` is null), and the CI type is 1."
680,<android.view.Display: ColorSpace getPreferredWideGamutColorSpace()>,30,31,<android.view.Display: ColorSpace getPreferredWideGamutColorSpace()>,<android.view.Display: ColorSpace getPreferredWideGamutColorSpace()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        if (mDisplayInfo.isWideColorGamut()) {
            return mGlobal.getPreferredWideGamutColorSpace();
        }
        return null;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        if (mDisplayInfo.isWideColorGamut()) {
            return mGlobal.getPreferredWideGamutColorSpace();
        }
        return null;
    }
}",1,"/**
 * Returns the preferred wide color space of the Display.
 * The returned wide gamut color space is based on hardware capability and
 * is preferred by the composition pipeline.
 * Returns null if the display doesn't support wide color gamut.
 * {@link Display#isWideColorGamut()}.
 */
","/**
 * Returns the preferred wide color space of the Display.
 * The returned wide gamut color space is based on hardware capability and
 * is preferred by the composition pipeline.
 * Returns null if the display doesn't support wide color gamut.
 * {@link Display#isWideColorGamut()}.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,3,0,"The synchronization object changed from 'this' to 'mLock', so the code change type is 3.","There is no Compatibility Issue since the locking strategy change (which synchronization object is used) does not affect the method's return value or the exceptions it can throw. Hence, the behavior of the API remains consistent across the two versions from the perspective of external code, assuming no external factors are affecting the state of 'mLock' versus 'this'."
683,<android.app.PendingIntent: int getCreatorUid()>,30,31,<android.app.PendingIntent: int getCreatorUid()>,<android.app.PendingIntent: int getCreatorUid()>,0,"{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getCachedInfo().getCreatorUid();
}",1,"/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
","/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation changes from directly querying the ActivityManager service to using a getCachedInfo() method. Hence, a dependent API change and a change in the return statement have occurred, so the change type is 1,5.","The method now uses a potentially different mechanism to obtain the creator UID, which could lead to different returned values, so the CI type is 1."
684,<android.net.IpSecTransform: void close()>,30,31,<android.net.IpSecTransform: void close()>,<android.net.IpSecTransform: void close()>,0,"{
    Log.d(TAG, ""Removing Transform with Id "" + mResourceId);
    // Always safe to attempt cleanup
    if (mResourceId == INVALID_RESOURCE_ID) {
        mCloseGuard.close();
        return;
    }
    try {
        IIpSecService svc = getIpSecService();
        svc.deleteTransform(mResourceId);
        stopNattKeepalive();
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    } catch (Exception e) {
        // On close we swallow all random exceptions since failure to close is not
        // actionable by the user.
        Log.e(TAG, ""Failed to close "" + this + "", Exception="" + e);
    } finally {
        mResourceId = INVALID_RESOURCE_ID;
        mCloseGuard.close();
    }
}","{
    Log.d(TAG, ""Removing Transform with Id "" + mResourceId);
    // Always safe to attempt cleanup
    if (mResourceId == INVALID_RESOURCE_ID) {
        mCloseGuard.close();
        return;
    }
    try {
        IIpSecService svc = getIpSecService();
        svc.deleteTransform(mResourceId);
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    } catch (Exception e) {
        // On close we swallow all random exceptions since failure to close is not
        // actionable by the user.
        Log.e(TAG, ""Failed to close "" + this + "", Exception="" + e);
    } finally {
        mResourceId = INVALID_RESOURCE_ID;
        mCloseGuard.close();
    }
}",1,"/**
 * Deactivate this {@code IpSecTransform} and free allocated resources.
 *
 * <p>Deactivating a transform while it is still applied to a socket will result in errors on
 * that socket. Make sure to remove transforms by calling {@link
 * IpSecManager#removeTransportModeTransforms}. Note, removing an {@code IpSecTransform} from a
 * socket will not deactivate it (because one transform may be applied to multiple sockets).
 *
 * <p>It is safe to call this method on a transform that has already been deactivated.
 */
","/**
 * Deactivate this {@code IpSecTransform} and free allocated resources.
 *
 * <p>Deactivating a transform while it is still applied to a socket will result in errors on
 * that socket. Make sure to remove transforms by calling {@link
 * IpSecManager#removeTransportModeTransforms}. Note, removing an {@code IpSecTransform} from a
 * socket will not deactivate it (because one transform may be applied to multiple sockets).
 *
 * <p>It is safe to call this method on a transform that has already been deactivated.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""stopNattKeepalive();"" has been deleted. However, this change does not affect the method's return type or the exceptions thrown by the method. This means the change type is 4.","The removal of ""stopNattKeepalive();"" is an internal implementation detail that does not impact the external behavior of the ""close()"" method in terms of its interface contract. No return value or exception handling is different for clients of this method, thus, there is no Compatibility Issue. The CI type is 0."
686,<android.view.contentcapture.ContentCaptureSession: void destroy()>,30,31,<android.view.contentcapture.ContentCaptureSession: void destroy()>,<android.view.contentcapture.ContentCaptureSession: void destroy()>,0,"{
    synchronized (mLock) {
        if (mDestroyed) {
            if (sDebug)
                Log.d(TAG, ""destroy("" + mId + ""): already destroyed"");
            return;
        }
        mDestroyed = true;
        // id) and send it to the cache of batched commands
        if (sVerbose) {
            Log.v(TAG, ""destroy(): state="" + getStateAsString(mState) + "", mId="" + mId);
        }
        // Finish children first
        if (mChildren != null) {
            final int numberChildren = mChildren.size();
            if (sVerbose)
                Log.v(TAG, ""Destroying "" + numberChildren + "" children first"");
            for (int i = 0; i < numberChildren; i++) {
                final ContentCaptureSession child = mChildren.get(i);
                try {
                    child.destroy();
                } catch (Exception e) {
                    Log.w(TAG, ""exception destroying child session #"" + i + "": "" + e);
                }
            }
        }
    }
    try {
        flush(FLUSH_REASON_SESSION_FINISHED);
    } finally {
        onDestroy();
    }
}","{
    synchronized (mLock) {
        if (mDestroyed) {
            if (sDebug)
                Log.d(TAG, ""destroy("" + mId + ""): already destroyed"");
            return;
        }
        mDestroyed = true;
        // id) and send it to the cache of batched commands
        if (sVerbose) {
            Log.v(TAG, ""destroy(): state="" + getStateAsString(mState) + "", mId="" + mId);
        }
        // Finish children first
        if (mChildren != null) {
            final int numberChildren = mChildren.size();
            if (sVerbose)
                Log.v(TAG, ""Destroying "" + numberChildren + "" children first"");
            for (int i = 0; i < numberChildren; i++) {
                final ContentCaptureSession child = mChildren.get(i);
                try {
                    child.destroy();
                } catch (Exception e) {
                    Log.w(TAG, ""exception destroying child session #"" + i + "": "" + e);
                }
            }
        }
    }
    onDestroy();
}",1,"/**
 * Destroys this session, flushing out all pending notifications to the service.
 *
 * <p>Once destroyed, any new notification will be dropped.
 */
","/**
 * Destroys this session, flushing out all pending notifications to the service.
 *
 * <p>Once destroyed, any new notification will be dropped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"The 'try' and 'finally' blocks have been removed, leaving only the call to onDestroy(), and the flush(FLUSH_REASON_SESSION_FINISHED) method call within the 'try' block has been removed, making the change type 2 (Exception handling statement changed) and 4 (Other statement changed).","The removal of the flush(FLUSH_REASON_SESSION_FINISHED) call inside the 'try' block potentially removes an exception that could have been thrown, changing the exception behavior of the API. This can lead to a compatibility issue of type 2 (Compatibility Issue caused by potential different exception handlings)."
687,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,30,31,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,<android.view.textclassifier.TextClassificationSession: void onSelectionEvent(SelectionEvent)>,0,"{
    try {
        if (mEventHelper.sanitizeEvent(event)) {
            mDelegate.onSelectionEvent(event);
        }
    } catch (Exception e) {
        // Avoid crashing for event reporting.
        Log.e(LOG_TAG, ""Error reporting text classifier selection event"", e);
    }
}","{
    checkDestroyedAndRun(() -> {
        try {
            if (mEventHelper.sanitizeEvent(event)) {
                mDelegate.onSelectionEvent(event);
            }
        } catch (Exception e) {
            // Avoid crashing for event reporting.
            Log.e(LOG_TAG, ""Error reporting text classifier selection event"", e);
        }
        return null;
    });
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The early implementation directly runs the event handling code, whereas the late implementation wraps the existing code inside a lambda function, which is passed to the checkDestroyedAndRun method. Additionally, there's a new dependent API call to checkDestroyedAndRun, so the change type includes both 3 and 5.","While the code is wrapped in a new method (checkDestroyedAndRun) and thus has changed structurally, the actual behavior of processing the event does not change as long as the new checkDestroyedAndRun method simply executes the given lambda without altering its behavior. There is no indication that the return value or exception handling has changed; therefore, it is classified as no Compatibility Issue (0)."
689,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",30,31,"<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>","<android.app.backup.BackupAgent.BackupServiceBinder: void doFullBackup(ParcelFileDescriptor,long,int,IBackupManager,int)>",0,"{
    // Ensure that we're running with the app's normal permission level
    long ident = Binder.clearCallingIdentity();
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data, quotaBytes, transportFlags));
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""doFullBackup() invoked"");
    // Ensure that any SharedPreferences writes have landed *before*
    // we potentially try to back up the underlying files directly.
    waitForSharedPrefs();
    // Ensure that we're running with the app's normal permission level
    final long ident = Binder.clearCallingIdentity();
    try {
        BackupAgent.this.onFullBackup(new FullBackupDataOutput(data, quotaBytes, transportFlags));
    } catch (IOException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw new RuntimeException(ex);
    } catch (RuntimeException ex) {
        Log.d(TAG, ""onFullBackup ("" + BackupAgent.this.getClass().getName() + "") threw"", ex);
        throw ex;
    } finally {
        // ... and then again after, as in the doBackup() case
        waitForSharedPrefs();
        // forthcoming from this agent.
        try {
            FileOutputStream out = new FileOutputStream(data.getFileDescriptor());
            byte[] buf = new byte[4];
            out.write(buf);
        } catch (IOException e) {
            Log.e(TAG, ""Unable to finalize backup stream!"");
        }
        Binder.restoreCallingIdentity(ident);
        try {
            callbackBinder.opCompleteForUser(getBackupUserId(), token, 0);
        } catch (RemoteException e) {
        // we'll time out anyway, so we're safe
        }
        if (Binder.getCallingPid() != Process.myPid()) {
            IoUtils.closeQuietly(data);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code moved the line `long ident = Binder.clearCallingIdentity();` to after the `waitForSharedPrefs();` and adjust the `ident` variable to be `final`. No other changes affecting the logic or behaviour of the method are detected, therefore the code change is classified as 4.","The minor change in the variable declaration timing and scope does not affect the public-facing behavior of the API or its return values, thus there is no compatibility issue. Therefore the CI type is 0."
690,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,30,31,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,<android.util.TimeUtils: List<String> getTimeZoneIdsForCountryCode(String)>,0,"{
    if (countryCode == null) {
        throw new NullPointerException(""countryCode == null"");
    }
    TimeZoneFinder timeZoneFinder = TimeZoneFinder.getInstance();
    CountryTimeZones countryTimeZones = timeZoneFinder.lookupCountryTimeZones(countryCode.toLowerCase());
    if (countryTimeZones == null) {
        return null;
    }
    List<String> timeZoneIds = new ArrayList<>();
    for (TimeZoneMapping timeZoneMapping : countryTimeZones.getTimeZoneMappings()) {
        if (timeZoneMapping.isShownInPicker()) {
            timeZoneIds.add(timeZoneMapping.getTimeZoneId());
        }
    }
    return Collections.unmodifiableList(timeZoneIds);
}","{
    if (countryCode == null) {
        throw new NullPointerException(""countryCode == null"");
    }
    TimeZoneFinder timeZoneFinder = TimeZoneFinder.getInstance();
    CountryTimeZones countryTimeZones = timeZoneFinder.lookupCountryTimeZones(countryCode.toLowerCase());
    if (countryTimeZones == null) {
        return null;
    }
    List<String> timeZoneIds = new ArrayList<>();
    for (TimeZoneMapping timeZoneMapping : countryTimeZones.getTimeZoneMappings()) {
        if (timeZoneMapping.isShownInPickerAt(MIN_USE_DATE_OF_TIMEZONE)) {
            timeZoneIds.add(timeZoneMapping.getTimeZoneId());
        }
    }
    return Collections.unmodifiableList(timeZoneIds);
}",1,"/**
 * Returns time zone IDs for time zones known to be associated with a country.
 *
 * <p>The list returned may be different from other on-device sources like
 * {@link android.icu.util.TimeZone#getRegion(String)} as it can be curated to avoid
 * contentious or obsolete mappings.
 *
 * @param countryCode the ISO 3166-1 alpha-2 code for the country as can be obtained using
 * {@link java.util.Locale#getCountry()}
 * @return IDs that can be passed to {@link java.util.TimeZone#getTimeZone(String)} or similar
 * methods, or {@code null} if the countryCode is unrecognized
 */
","/**
 * Returns time zone IDs for time zones known to be associated with a country.
 *
 * <p>The list returned may be different from other on-device sources like
 * {@link android.icu.util.TimeZone#getRegion(String)} as it can be curated to avoid
 * contentious or obsolete mappings.
 *
 * @param countryCode the ISO 3166-1 alpha-2 code for the country as can be obtained using
 * {@link java.util.Locale#getCountry()}
 * @return IDs that can be passed to {@link java.util.TimeZone#getTimeZone(String)} or similar
 * methods, or {@code null} if the countryCode is unrecognized
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,The method isShownInPicker() was replaced with isShownInPickerAt(MIN_USE_DATE_OF_TIMEZONE) which means the dependent API has changed (the dependent method and its parameters have been altered). The change type is 4 (Other statement changed) and 5 (Dependent API changed).,"Since there's a change in the dependent API that affects which time zones are added to the list (based on the new criterion using MIN_USE_DATE_OF_TIMEZONE), the list returned by the method might differ. Therefore, the API could potentially return different values, so the CI type is 1."
691,"<android.hardware.camera2.CameraManager: boolean isConcurrentSessionConfigurationSupported(Map<String, SessionConfiguration>)>",30,31,"<android.hardware.camera2.CameraManager: boolean isConcurrentSessionConfigurationSupported(Map<String, SessionConfiguration>)>","<android.hardware.camera2.CameraManager: boolean isConcurrentSessionConfigurationSupported(Map<String, SessionConfiguration>)>",0,"{
    return CameraManagerGlobal.get().isConcurrentSessionConfigurationSupported(cameraIdAndSessionConfig);
}","{
    return CameraManagerGlobal.get().isConcurrentSessionConfigurationSupported(cameraIdAndSessionConfig, mContext.getApplicationInfo().targetSdkVersion);
}",1,"/**
 * Checks whether the provided set of camera devices and their corresponding
 * {@link SessionConfiguration} can be configured concurrently.
 *
 * <p>This method performs a runtime check of the given {@link SessionConfiguration} and camera
 * id combinations. The result confirms whether or not the passed session configurations can be
 * successfully used to create camera capture sessions concurrently, on the given camera
 * devices using {@link CameraDevice#createCaptureSession(SessionConfiguration)}.
 * </p>
 *
 * <p>The method can be called at any point before, during and after active capture sessions.
 * It will not impact normal camera behavior in any way and must complete significantly
 * faster than creating a regular or constrained capture session.</p>
 *
 * <p>Although this method is faster than creating a new capture session, it is not intended
 * to be used for exploring the entire space of supported concurrent stream combinations. The
 * available mandatory concurrent stream combinations may be obtained by querying
 * {@link #getCameraCharacteristics} for the key
 * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}. </p>
 *
 * <p>Note that session parameters will be ignored and calls to
 * {@link SessionConfiguration#setSessionParameters} are not required.</p>
 *
 * @return {@code true} if the given combination of session configurations and corresponding
 * camera ids are concurrently supported by the camera sub-system,
 * {@code false} otherwise OR if the set of camera devices provided is not a subset of
 * those returned by {@link #getConcurrentCameraIds}.
 *
 * @throws CameraAccessException if one of the camera devices queried is no longer connected.
 */
","/**
 * Checks whether the provided set of camera devices and their corresponding
 * {@link SessionConfiguration} can be configured concurrently.
 *
 * <p>This method performs a runtime check of the given {@link SessionConfiguration} and camera
 * id combinations. The result confirms whether or not the passed session configurations can be
 * successfully used to create camera capture sessions concurrently, on the given camera
 * devices using {@link CameraDevice#createCaptureSession(SessionConfiguration)}.
 * </p>
 *
 * <p>The method can be called at any point before, during and after active capture sessions.
 * It will not impact normal camera behavior in any way and must complete significantly
 * faster than creating a regular or constrained capture session.</p>
 *
 * <p>Although this method is faster than creating a new capture session, it is not intended
 * to be used for exploring the entire space of supported concurrent stream combinations. The
 * available mandatory concurrent stream combinations may be obtained by querying
 * {@link #getCameraCharacteristics} for the key
 * {@link android.hardware.camera2.CameraCharacteristics#SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS}. </p>
 *
 * <p>Note that session parameters will be ignored and calls to
 * {@link SessionConfiguration#setSessionParameters} are not required.</p>
 *
 * @return {@code true} if the given combination of session configurations and corresponding
 * camera ids are concurrently supported by the camera sub-system,
 * {@code false} otherwise OR if the set of camera devices provided is not a subset of
 * those returned by {@link #getConcurrentCameraIds}.
 *
 * @throws CameraAccessException if one of the camera devices queried is no longer connected.
 */
",-1,[@RequiresPermission(android.Manifest.permission.CAMERA)],[@RequiresPermission(android.Manifest.permission.CAMERA)],-1,-1,-1,-1,-1,-1,"4,5",0,"The code change falls into the category of a change in a dependent API's method call, since an additional parameter (mContext.getApplicationInfo().targetSdkVersion) is passed to the isConcurrentSessionConfigurationSupported method. Thus, the code change types are 4 (other statement changed) and 5 (dependent API changed).","There is no evidence suggesting the additional parameter would cause the API to return a different value or throw exceptions differently based solely on the given code snippets. Therefore, it does not by itself introduce a Compatibility Issue. It's presumably a compatibility behavior within the method that takes the target SDK version into account. However, without more context or changes in isConcurrentSessionConfigurationSupported's handling of the new parameter, we cannot assume a CI, so the prediction is 0 for No Compatibility Issue."
692,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,30,31,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,<android.service.voice.VoiceInteractionSession: void onHandleAssist(AssistState)>,0,"{
    if (state.getIndex() == 0) {
        onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent());
    } else {
        onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount());
    }
}","{
    if (state.getAssistData() == null && state.getAssistStructure() == null && state.getAssistContent() == null) {
        return;
    } else if (state.getIndex() == 0) {
        onHandleAssist(state.getAssistData(), state.getAssistStructure(), state.getAssistContent());
    } else {
        onHandleAssistSecondary(state.getAssistData(), state.getAssistStructure(), state.getAssistContent(), state.getIndex(), state.getCount());
    }
}",1,"/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started.  If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, this method will not be called.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
","/**
 * Called to receive data from the application that the user was currently viewing when
 * an assist session is started. If the original show request did not specify
 * {@link #SHOW_WITH_ASSIST}, {@link AssistState} parameter will only provide
 * {@link ActivityId}.
 *
 * <p>This method is called for all activities along with an index and count that indicates
 * which activity the data is for. {@code index} will be between 0 and {@code count}-1 and
 * this method is called once for each activity in no particular order. The {@code count}
 * indicates how many activities to expect assist data for, including the top focused one.
 * The focused activity can be determined by calling {@link AssistState#isFocused()}.
 *
 * <p>To be responsive to assist requests, process assist data as soon as it is received,
 * without waiting for all queued activities to return assist data.
 *
 * @param state The state object capturing the state of an activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow has been altered by adding an additional 'if' check for the null condition of state's getAssistData(), getAssistStructure(), and getAssistContent(). A new return statement has also been introduced in the new 'if' check, so the code change type is 1,3.","Due to the added 'if' condition that checks for null values, the added return statement can result in the method exiting early without calling onHandleAssist() or onHandleAssistSecondary() depending on the state data. Thus, the CI type is 1, as the new condition can lead to a changed return behavior of the API where it might return without performing any operation, which is different from the early version."
693,"<android.accessibilityservice.AccessibilityService: void setTouchExplorationPassthroughRegion(int,Region)>",30,31,"<android.accessibilityservice.AccessibilityService: void setTouchExplorationPassthroughRegion(int,Region)>","<android.accessibilityservice.AccessibilityService: void setTouchExplorationPassthroughRegion(int,Region)>",0,"{
    Preconditions.checkNotNull(region, ""region cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.setTouchExplorationPassthroughRegion(displayId, region);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}","{
    Preconditions.checkNotNull(region, ""region cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.setTouchExplorationPassthroughRegion(displayId, region);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}",1,"/**
 * When {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is enabled, this
 * function requests that touch interactions starting in the specified region of the screen
 * bypass the touch explorer and go straight to the view hierarchy. There can only be one touch
 * exploration passthrough region per display. Requesting a new touch explorationpassthrough
 * region clears the existing one. To disable this passthrough and return to the original
 * behavior, pass in an empty region. When {@link
 * AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is disabled this function has
 * no effect.
 *
 * @param displayId The display on which to set this region.
 * @param region the region of the screen .
 */
","/**
 * When {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is enabled, this
 * function requests that touch interactions starting in the specified region of the screen
 * bypass the touch explorer and go straight to the view hierarchy. There can only be one touch
 * exploration passthrough region per display. Requesting a new touch explorationpassthrough
 * region clears the existing one. To disable this passthrough and return to the original
 * behavior, pass in an empty region. When {@link
 * AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is disabled this function has
 * no effect.
 *
 * @param displayId The display on which to set this region.
 * @param region the region of the screen .
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call to getInstance has an added parameter 'this' in the late version. Therefore, the code change type is 5.","The modification of the getInstance method with a new parameter does not indicate different behaviors or outputs from the setTouchExplorationPassthroughRegion API because this change does not affect the control flow, what exception is thrown, or the value returned. There is no Compatibility Issue, so the CI type is 0."
694,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,30,31,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,<android.view.WindowInsets: WindowInsets consumeDisplayCutout()>,0,"{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null, /* displayCutout */
    mCompatInsetsTypes, mCompatIgnoreVisibility);
}","{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null, /* displayCutout */
    mRoundedCorners, mPrivacyIndicatorBounds, mCompatInsetsTypes, mCompatIgnoreVisibility);
}",1,"/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
","/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */
",-1,"[@Deprecated, @NonNull]","[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,4,1,"There are new parameters added to the constructor of WindowInsets: mRoundedCorners, mPrivacyIndicatorBounds which indicates an ""Other statement changed"".","The introduction of new parameters in the constructor new WindowInsets(â€¦) may result in a different return object than before, leading to a potential Compatibility Issue by returning a different value, which is a CI type 1."
696,<android.service.autofill.FillResponse: String toString()>,30,31,<android.service.autofill.FillResponse: String toString()>,<android.service.autofill.FillResponse: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    if (mCancelIds != null) {
        builder.append("", mCancelIds="").append(mCancelIds.length);
    }
    builder.append("", mSupportInlinePresentations="").append(mSupportsInlineSuggestions);
    return builder.append(""]"").toString();
}","{
    if (!sDebug)
        return super.toString();
    // TODO: create a dump() method instead
    final StringBuilder builder = new StringBuilder(""FillResponse : [mRequestId="" + mRequestId);
    if (mDatasets != null) {
        builder.append("", datasets="").append(mDatasets.getList());
    }
    if (mSaveInfo != null) {
        builder.append("", saveInfo="").append(mSaveInfo);
    }
    if (mClientState != null) {
        builder.append("", hasClientState"");
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mHeader != null) {
        builder.append("", hasHeader"");
    }
    if (mFooter != null) {
        builder.append("", hasFooter"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    if (mAuthenticationIds != null) {
        builder.append("", authenticationIds="").append(Arrays.toString(mAuthenticationIds));
    }
    builder.append("", disableDuration="").append(mDisableDuration);
    if (mFlags != 0) {
        builder.append("", flags="").append(mFlags);
    }
    if (mFieldClassificationIds != null) {
        builder.append(Arrays.toString(mFieldClassificationIds));
    }
    if (mUserData != null) {
        builder.append("", userData="").append(mUserData);
    }
    if (mCancelIds != null) {
        builder.append("", mCancelIds="").append(mCancelIds.length);
    }
    builder.append("", mSupportInlinePresentations="").append(mSupportsInlineSuggestions);
    return builder.append(""]"").toString();
}",1,"// ///////////////////////////////////
","// ///////////////////////////////////
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change between the versions is the addition of a new block:,"    builder.append("", hasInlineTooltipPresentation"");"
697,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",30,31,"<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>","<android.bluetooth.BluetoothGattServer: boolean connect(BluetoothDevice,boolean)>",0,"{
    if (DBG) {
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    }
    if (mService == null || mServerIf == 0)
        return false;
    try {
        // autoConnect is inverse of ""isDirect""
        mService.serverConnect(mServerIf, device.getAddress(), !autoConnect, mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""connect() - device: "" + device.getAddress() + "", auto: "" + autoConnect);
    }
    if (mService == null || mServerIf == 0)
        return false;
    try {
        // autoConnect is inverse of ""isDirect""
        mService.serverConnect(mServerIf, device.getAddress(), !autoConnect, mTransport, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
","/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The `mService.serverConnect()` method call within the try block now includes an additional parameter, `mAttributionSource`, thus changing the method's signature. This represents a change in the dependent API (change type 5). There are also new annotations added in the late version which are related to permission requirements (but annotations are not considered as CI since they do not change runtime behavior), which can be noted as an ""other statement changed"" (change type 4) considering the broader Java context.","No Compatibility Issue is detected because the change in parameters does not impact the API's return type or value, nor does it introduce any new exception handling. The internal call to `serverConnect` is updated with an additional argument, but the method's return behavior remains consistent before and after the change."
699,<android.content.ContentProvider: String getCallingPackage()>,30,31,<android.content.ContentProvider: String getCallingPackage()>,<android.content.ContentProvider: String getCallingPackage()>,0,"{
    final Pair<String, String> pkg = mCallingPackage.get();
    if (pkg != null) {
        mTransport.mAppOpsManager.checkPackage(Binder.getCallingUid(), pkg.first);
        return pkg.first;
    }
    return null;
}","{
    final AttributionSource callingAttributionSource = getCallingAttributionSource();
    return (callingAttributionSource != null) ? callingAttributionSource.getPackageName() : null;
}",1,"/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have been
 * verified to belong to the calling UID. Returns {@code null} if not
 * currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 * @throws SecurityException if the calling package doesn't belong to the
 * calling UID.
 */
","/**
 * Return the package name of the caller that initiated the request being
 * processed on the current thread. The returned package will have been
 * verified to belong to the calling UID. Returns {@code null} if not
 * currently processing a request.
 * <p>
 * This will always return {@code null} when processing
 * {@link #getType(Uri)} or {@link #getStreamTypes(Uri, String)} requests.
 *
 * @see Binder#getCallingUid()
 * @see Context#grantUriPermission(String, Uri, int)
 * @throws SecurityException if the calling package doesn't belong to the
 * calling UID.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The method implementation has changed to use a new API `getCallingAttributionSource()` and its `getPackageName()`. The old API `mCallingPackage.get()` and additional operations like `mTransport.mAppOpsManager.checkPackage()` have been removed. Hence, the dependent API has changed, making the code change type 5.","There is no Compatibility Issue here because the method's responsibilityâ€”a String representing the calling packageâ€”is still being met. Both versions of the method ultimately return the package name or null, preserving compatibility."
700,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForHwVideoEncoder(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForHwVideoEncoder(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForHwVideoEncoder(Surface)>,0,"{
    return LegacyCameraDevice.isVideoEncoderConsumer(surface);
}","{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}",1,"/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */
","/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The late implementation replaced the call to `LegacyCameraDevice.isVideoEncoderConsumer(surface)` with a manual check of surface usage flags and surface format, along with adding new method calls like `checkNotNull(surface)`, `nativeDetectSurfaceUsageFlags(surface)`, and `getSurfaceFormat(surface)`. This means that not only have the statements changed, but the dependent APIs have changed as well, making the code change types 1,4,5.","Given that the implementation now manually checks flags and formats rather than delegating the call, and since these checks are different from the early version, the return value could be different. Therefore, there is a Compatibility Issue caused by potential different return values or types, and the CI type is 1."
701,<android.app.Notification.Builder: Notification build()>,30,31,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    // Check shortcut id matches
    if (mN.mShortcutId != null && mN.mBubbleMetadata != null && mN.mBubbleMetadata.getShortcutId() != null && !mN.mShortcutId.equals(mN.mBubbleMetadata.getShortcutId())) {
        throw new IllegalArgumentException(""Notification and BubbleMetadata shortcut id's don't match,"" + "" notification: "" + mN.mShortcutId + "" vs bubble: "" + mN.mBubbleMetadata.getShortcutId());
    }
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && (useExistingRemoteView())) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}","{
    // Check shortcut id matches
    if (mN.mShortcutId != null && mN.mBubbleMetadata != null && mN.mBubbleMetadata.getShortcutId() != null && !mN.mShortcutId.equals(mN.mBubbleMetadata.getShortcutId())) {
        throw new IllegalArgumentException(""Notification and BubbleMetadata shortcut id's don't match,"" + "" notification: "" + mN.mShortcutId + "" vs bubble: "" + mN.mBubbleMetadata.getShortcutId());
    }
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && !styleDisplaysCustomViewInline()) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 *
 * If this notification has {@link BubbleMetadata} attached that was created with
 * a shortcutId a check will be performed to ensure the shortcutId supplied to bubble
 * metadata matches the shortcutId set on the  notification builder, if one was set.
 * If the shortcutId's were specified but do not match, an exception is thrown here.
 *
 * @see BubbleMetadata.Builder#Builder(String)
 * @see #setShortcutId(String)
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 *
 * If this notification has {@link BubbleMetadata} attached that was created with
 * a shortcutId a check will be performed to ensure the shortcutId supplied to bubble
 * metadata matches the shortcutId set on the  notification builder, if one was set.
 * If the shortcutId's were specified but do not match, an exception is thrown here.
 *
 * @see BubbleMetadata.Builder#Builder(String)
 * @see #setShortcutId(String)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,The condition in the if-statement has changed from useExistingRemoteView() to !styleDisplaysCustomViewInline(). This represents a change type 4 as it is an 'Other statement changed'. It is not a change in the return type or an exception handling change.,"No Compatibility Issue arises from this change because it only affects which branch of the if-statement code will be executed, but the eventual returned object (mN) is the same regardless of the branch taken, assuming the rest of the code and object state are unchanged. Therefore, the behavior as observed by the API consumers should remain consistent."
702,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,30,31,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,<android.content.ContentResolver: Uri uncanonicalize(Uri)>,0,"{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.uncanonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.uncanonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        final UriResultListener resultListener = new UriResultListener();
        provider.uncanonicalizeAsync(mContext.getAttributionSource(), url, new RemoteCallback(resultListener));
        resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);
        if (resultListener.exception != null) {
            throw resultListener.exception;
        }
        return resultListener.result;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
","/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The control dependency has changed as the method of invoking `provider.uncanonicalize` is modified to asynchronous call `provider.uncanonicalizeAsync` with a callback mechanism, plus a new class `UriResultListener` and `RemoteCallback` are used. Additionally, there's a new exception handling statement that throws an exception based on a condition related to `resultListener.exception`. These are changes in the control flow structure and dependent APIs, so the code change type is 3,4,5.","The method no longer returns value directly from the content provider synchronously, but instead uses an asynchronous method with a callback and blocks until a result or exception is provided. This introduces two potential CI:"
704,<android.app.Activity: ComponentName getCallingActivity()>,30,31,<android.app.Activity: ComponentName getCallingActivity()>,<android.app.Activity: ComponentName getCallingActivity()>,0,"{
    try {
        return ActivityTaskManager.getService().getCallingActivity(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    return ActivityClient.getInstance().getCallingActivity(mToken);
}",1,"/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the activity that invoked this activity.  This is
 * who the data in {@link #setResult setResult()} will be sent to.  You
 * can use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.
 *
 * @return The ComponentName of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The method of obtaining the calling activity has been modified. It went from using `ActivityTaskManager.getService().getCallingActivity(mToken)` to using `ActivityClient.getInstance().getCallingActivity(mToken)`. This is a dependent API change, hence code change type 4,5.","Despite the change in the underlying implementation details, the semantic contract of the method appears to remain the sameâ€”it returns the ComponentName of the activity that called the current activity, or null otherwise. Since the return type hasnâ€™t changed and the method is designed to return null in case of failure (the catch block is omitted in the late version, and there is no new exception-handling logic that suggests different behavior), there is no indication of a compatibility issue based on the information provided. The annotation remains the same (@Nullable), which also indicates that the API contract regarding nullability has not changed. Therefore, there is no compatibility issue, thus CI type 0."
705,<android.content.pm.ShortcutManager: void pushDynamicShortcut(ShortcutInfo)>,30,31,<android.content.pm.ShortcutManager: void pushDynamicShortcut(ShortcutInfo)>,<android.content.pm.ShortcutManager: void pushDynamicShortcut(ShortcutInfo)>,0,"{
    try {
        mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        getFutureOrThrow(mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Publish a single dynamic shortcut. If there are already dynamic or pinned shortcuts with the
 * same ID, each mutable shortcut is updated.
 *
 * <p>This method is useful when posting notifications which are tagged with shortcut IDs; In
 * order to make sure shortcuts exist and are up-to-date, without the need to explicitly handle
 * the shortcut count limit.
 * @see android.app.NotificationManager#notify(int, Notification)
 * @see Notification.Builder#setShortcutId(String)
 *
 * <p>If {@link #getMaxShortcutCountPerActivity()} is already reached, an existing shortcut with
 * the lowest rank will be removed to add space for the new shortcut.
 *
 * <p>If the rank of the shortcut is not explicitly set, it will be set to zero, and shortcut
 * will be added to the top of the list.
 *
 * @throws IllegalArgumentException if trying to update an immutable shortcut.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Publish a single dynamic shortcut. If there are already dynamic or pinned shortcuts with the
 * same ID, each mutable shortcut is updated.
 *
 * <p>This method is useful when posting notifications which are tagged with shortcut IDs; In
 * order to make sure shortcuts exist and are up-to-date, without the need to explicitly handle
 * the shortcut count limit.
 * @see android.app.NotificationManager#notify(int, Notification)
 * @see Notification.Builder#setShortcutId(String)
 *
 * <p>If {@link #getMaxShortcutCountPerActivity()} is already reached, an existing shortcut with
 * the lowest rank will be removed to add space for the new shortcut.
 *
 * <p>If the rank of the shortcut is not explicitly set, it will be set to zero, and shortcut
 * will be added to the top of the list.
 *
 * @throws IllegalArgumentException if trying to update an immutable shortcut.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement within the 'try' block changed from directly calling mService.pushDynamicShortcut to calling getFutureOrThrow with the result of mService.pushDynamicShortcut. This change is considered type 4 (Other statement changed) because the invocation itself has been altered, though this does not affect the return type or value since the method is void. Type 5 (Dependent API changed) because the method that is being called on the mService object has been wrapped inside another method (getFutureOrThrow), this adds a layer of abstraction but does not directly change the API's expected behavior considering the wrapping function should handle the result in the same way as the previous direct call.","There is no Compatibility Issue since the method is void and does not return any value, and the exception handling stays the same. Thus, there's no change affecting the returned value or the exceptions thrown, and the potential API behavior remains consistent with the earlier version from the perspective of the caller."
706,"<android.hardware.camera2.impl.CameraDeviceImpl: void onDeviceError(int,CaptureResultExtras)>",30,31,"<android.hardware.camera2.impl.CameraDeviceImpl: void onDeviceError(int,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraDeviceImpl: void onDeviceError(int,CaptureResultExtras)>",0,"{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onDeviceError(errorCode, resultExtras);
            return;
        }
        switch(errorCode) {
            case CameraDeviceCallbacks.ERROR_CAMERA_DISCONNECTED:
                final long ident = Binder.clearCallingIdentity();
                try {
                    mDeviceExecutor.execute(mCallOnDisconnected);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
                break;
            case CameraDeviceCallbacks.ERROR_CAMERA_REQUEST:
            case CameraDeviceCallbacks.ERROR_CAMERA_RESULT:
            case CameraDeviceCallbacks.ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            case CameraDeviceCallbacks.ERROR_CAMERA_DEVICE:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DEVICE);
                break;
            case CameraDeviceCallbacks.ERROR_CAMERA_DISABLED:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DISABLED);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
                scheduleNotifyError(StateCallback.ERROR_CAMERA_SERVICE);
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, String.format(""Device error received, code %d, frame number %d, request ID %d, subseq ID %d"", errorCode, resultExtras.getFrameNumber(), resultExtras.getRequestId(), resultExtras.getSubsequenceId()));
    }
    synchronized (mInterfaceLock) {
        if (mRemoteDevice == null) {
            // Camera already closed
            return;
        }
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onDeviceError(errorCode, resultExtras);
            return;
        }
        switch(errorCode) {
            case CameraDeviceCallbacks.ERROR_CAMERA_DISCONNECTED:
                {
                    final long ident = Binder.clearCallingIdentity();
                    try {
                        mDeviceExecutor.execute(mCallOnDisconnected);
                    } finally {
                        Binder.restoreCallingIdentity(ident);
                    }
                    break;
                }
            case CameraDeviceCallbacks.ERROR_CAMERA_REQUEST:
            case CameraDeviceCallbacks.ERROR_CAMERA_RESULT:
            case CameraDeviceCallbacks.ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            case CameraDeviceCallbacks.ERROR_CAMERA_DEVICE:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DEVICE);
                break;
            case CameraDeviceCallbacks.ERROR_CAMERA_DISABLED:
                scheduleNotifyError(StateCallback.ERROR_CAMERA_DISABLED);
                break;
            default:
                Log.e(TAG, ""Unknown error from camera device: "" + errorCode);
                scheduleNotifyError(StateCallback.ERROR_CAMERA_SERVICE);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the early and late versions is the additional scope `{}` around the case block for `CameraDeviceCallbacks.ERROR_CAMERA_DISCONNECTED`. This change is purely syntactical and does not affect the control flow or the behavior of the method, so the code change type is 4.","The code change does not lead to any Compatibility Issue as it does not affect the API's behaviour; the method will still execute the same code as before in the same circumstances. Therefore, no CI is detected, and the CI type is 0."
707,"<com.android.server.backup.SliceBackupHelper: void applyRestoredPayload(String,byte[])>",30,31,"<com.android.server.backup.SliceBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.SliceBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    if (DEBUG)
        Slog.v(TAG, ""Got restore of "" + key);
    if (KEY_SLICES.equals(key)) {
        try {
            ISliceManager sm = ISliceManager.Stub.asInterface(ServiceManager.getService(Context.SLICE_SERVICE));
            // TODO: http://b/22388012
            sm.applyRestore(payload, UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with slice manager"");
        }
    }
}","{
    if (DEBUG)
        Slog.v(TAG, ""Got restore of "" + key);
    if (KEY_SLICES.equals(key)) {
        try {
            ISliceManager sm = ISliceManager.Stub.asInterface(ServiceManager.getService(Context.SLICE_SERVICE));
            // TODO: http://b/22388012
            sm.applyRestore(payload, UserHandle.USER_SYSTEM);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with slice manager"", e);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is only in the log message details; an exception has been added to the Slog.e() statement within the catch block, which doesn't affect the method's signature or behavior, thus the code change type is 4.","There is no Compatibility Issue, as the change only adds more detail to a log statement, which does not modify the control flow or the behavior externally observable by the API consumers. Hence, this type of change is purely internal and does not represent a CI."
708,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName)>,30,31,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName)>,<android.app.admin.DevicePolicyManager: List<SecurityEvent> retrievePreRebootSecurityLogs(ComponentName)>,0,"{
    throwIfParentInstance(""retrievePreRebootSecurityLogs"");
    try {
        ParceledListSlice<SecurityEvent> list = mService.retrievePreRebootSecurityLogs(admin);
        if (list != null) {
            return list.getList();
        } else {
            return null;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""retrievePreRebootSecurityLogs"");
    try {
        ParceledListSlice<SecurityEvent> list = mService.retrievePreRebootSecurityLogs(admin, mContext.getPackageName());
        if (list != null) {
            return list.getList();
        } else {
            return null;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Called by device owner or profile owner of an organization-owned managed profile to retrieve
 * device logs from before the device's last reboot.
 * <p>
 * <strong> This API is not supported on all devices. Calling this API on unsupported devices
 * will result in {@code null} being returned. The device logs are retrieved from a RAM region
 * which is not guaranteed to be corruption-free during power cycles, as a result be cautious
 * about data corruption when parsing. </strong>
 *
 * <p> When called by a device owner, if there is any other user or profile on the device,
 * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.
 * See {@link #isAffiliatedUser}.
 *
 * @param admin Which device admin this request is associated with.
 * @return Device logs from before the latest reboot of the system, or {@code null} if this API
 * is not supported on the device.
 * @throws SecurityException if {@code admin} is not allowed to access security logging, or
 * there is at least one profile or secondary user that is not affiliated with the device.
 * @see #isAffiliatedUser
 * @see #retrieveSecurityLogs
 */
","/**
 * Called by device owner or profile owner of an organization-owned managed profile to retrieve
 * device logs from before the device's last reboot.
 * <p>
 * <strong> This API is not supported on all devices. Calling this API on unsupported devices
 * will result in {@code null} being returned. The device logs are retrieved from a RAM region
 * which is not guaranteed to be corruption-free during power cycles, as a result be cautious
 * about data corruption when parsing. </strong>
 *
 * <p> When called by a device owner, if there is any other user or profile on the device,
 * it must be affiliated with the device. Otherwise a {@link SecurityException} will be thrown.
 * See {@link #isAffiliatedUser}.
 *
 * @param admin Which device admin this request is associated with.
 * @return Device logs from before the latest reboot of the system, or {@code null} if this API
 * is not supported on the device.
 * @throws SecurityException if {@code admin} is not allowed to access security logging, or
 * there is at least one profile or secondary user that is not affiliated with the device.
 * @see #isAffiliatedUser
 * @see #retrieveSecurityLogs
 */
",-1,[@Nullable],"[@SuppressLint(""NullableCollection""), @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"Only the dependent API mService.retrievePreRebootSecurityLogs(...) has a change in the types or number of parameters (a new parameter has been added: mContext.getPackageName()). There are no changes to the method's return type or exception handling, so the code change type is 5.","Adding an extra parameter to the dependent API call does not directly lead to a compatibility issue, as the return type and the exception being thrown remain the same. There is no indication that the behavior of retrievePreRebootSecurityLogs has changed fundamentally in a way that affects return values or exceptions, so no CI is detected."
709,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,30,31,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setPeriodicAdvertisingData(AdvertiseData)>,0,"{
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Used to set periodic advertising data, must be called after setPeriodicAdvertisingParameters,
 * or after advertising was started with periodic advertising data set. This method returns
 * immediately, the operation status is delivered through
 * {@code callback.onPeriodicAdvertisingDataSet()}.
 *
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place when the
 * periodic advertising is enabled for this set, the data can be maximum 251 bytes long.
 */
","/**
 * Used to set periodic advertising data, must be called after setPeriodicAdvertisingParameters,
 * or after advertising was started with periodic advertising data set. This method returns
 * immediately, the operation status is delivered through
 * {@code callback.onPeriodicAdvertisingDataSet()}.
 *
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place when the
 * periodic advertising is enabled for this set, the data can be maximum 251 bytes long.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,5,0,"The implementation uses a new parameter mAttributionSource in the call to mGatt.setPeriodicAdvertisingData. This indicates the change is the type of a Dependent API changed, so the code change type is 5.","There is no Compatibility Issue detected because the method signature is the same, the exception handling has not changed, and the changes are internal to the method implementation without affecting the return type or the behavior from an API consumer's point of view."
710,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,30,31,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,<android.app.LoadedApk.ReceiverDispatcher.Args: Runnable getRunnable()>,0,"{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            intent.prepareToEnterProcess();
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}","{
    return () -> {
        final BroadcastReceiver receiver = mReceiver;
        final boolean ordered = mOrdered;
        if (ActivityThread.DEBUG_BROADCAST) {
            int seq = mCurIntent.getIntExtra(""seq"", -1);
            Slog.i(ActivityThread.TAG, ""Dispatching broadcast "" + mCurIntent.getAction() + "" seq="" + seq + "" to "" + mReceiver);
            Slog.i(ActivityThread.TAG, ""  mRegistered="" + mRegistered + "" mOrderedHint="" + ordered);
        }
        final IActivityManager mgr = ActivityManager.getService();
        final Intent intent = mCurIntent;
        if (intent == null) {
            Log.wtf(TAG, ""Null intent being dispatched, mDispatched="" + mDispatched + (mRunCalled ? "", run() has already been called"" : """"));
        }
        mCurIntent = null;
        mDispatched = true;
        mRunCalled = true;
        if (receiver == null || intent == null || mForgotten) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing null broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveReg"");
        try {
            ClassLoader cl = mReceiver.getClass().getClassLoader();
            intent.setExtrasClassLoader(cl);
            // TODO: determine at registration time if caller is
            // protecting themselves with signature permission
            intent.prepareToEnterProcess(ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource());
            setExtrasClassLoader(cl);
            receiver.setPendingResult(this);
            receiver.onReceive(mContext, intent);
        } catch (Exception e) {
            if (mRegistered && ordered) {
                if (ActivityThread.DEBUG_BROADCAST)
                    Slog.i(ActivityThread.TAG, ""Finishing failed broadcast to "" + mReceiver);
                sendFinished(mgr);
            }
            if (mInstrumentation == null || !mInstrumentation.onException(mReceiver, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(""Error receiving broadcast "" + intent + "" in "" + mReceiver, e);
            }
        }
        if (receiver.getPendingResult() != null) {
            finish();
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    };
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method invocation within the lambda expression `intent.prepareToEnterProcess(...)` has changed by adding additional parameters `ActivityThread.isProtectedBroadcast(intent), mContext.getAttributionSource()` to the call. This is neither a return statement nor an exception handling statement, and it does not change the control flow (no new control dependency was introduced), so the code change type is 4.","While the method `intent.prepareToEnterProcess()` now receives additional parameters, this alone does not necessarily lead to a different behavior visible from outside the method; it simply affects the internal state of the `Intent` object as it is being prepared for processing. There is no indication that these changes will cause a difference in values returned by the `getRunnable()` method or in exceptions thrown by it, assuming normal use and the additional parameters do not cause a difference in behavior for external callers. Therefore, there is no compatibility issue due to different return values or exception handlings, so the CI type is 0."
711,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",30,31,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onResultReceived(result, resultExtras, physicalResults);
            return;
        }
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onResultReceived(result, resultExtras, physicalResults);
            return;
        }
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(getId(), result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(getId(), result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
713,"<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,File)>",30,31,"<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,File)>","<android.speech.tts.TextToSpeech: int addSpeech(CharSequence,File)>",0,"{
    synchronized (mStartLock) {
        mUtterances.put(text, Uri.fromFile(file));
        return SUCCESS;
    }
}","{
    return addSpeech(text, Uri.fromFile(file));
}",1,"/**
 * Adds a mapping between a CharSequence (may be spanned with TtsSpans and a sound file.
 * Using this, it is possible to add custom pronounciations for a string of text. After a call
 * to this method, subsequent calls to {@link #speak(CharSequence, int, Bundle, String)}
 * will play the specified sound resource if it is available, or synthesize the text it is
 * missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param file
 * File object pointing to the sound file.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a CharSequence (may be spanned with TtsSpans) and a sound file.
 * Using this, it is possible to add custom pronounciations for a string of text. After a call
 * to this method, subsequent calls to {@link #speak(CharSequence, int, Bundle, String)}
 * will play the specified sound resource if it is available, or synthesize the text it is
 * missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param file
 * File object pointing to the sound file.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method body has changed from using a synchronized block with mUtterances.put(text, Uri.fromFile(file)) and returning SUCCESS to calling another method addSpeech(text, Uri.fromFile(file)). It's a structural change, so the change type is 4,5.","The API now delegates to another addSpeech method, which could have a different implementation or behavior leading to different return values. Hence, it is a potential compatibility issue of type 1, as the return may be different."
714,"<android.view.Surface: void setFrameRate(float,int)>",30,31,"<android.view.Surface: void setFrameRate(float,int)>","<android.view.Surface: void setFrameRate(float,int)>",0,"{
    synchronized (mLock) {
        checkNotReleasedLocked();
        int error = nativeSetFrameRate(mNativeObject, frameRate, compatibility);
        if (error == -EINVAL) {
            throw new IllegalArgumentException(""Invalid argument to Surface.setFrameRate()"");
        } else if (error != 0) {
            throw new RuntimeException(""Failed to set frame rate on Surface"");
        }
    }
}","{
    setFrameRate(frameRate, compatibility, CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS);
}",1,"/**
 * Sets the intended frame rate for this surface.
 *
 * <p>On devices that are capable of running the display at different refresh rates,
 * the system may choose a display refresh rate to better match this surface's frame
 * rate. Usage of this API won't introduce frame rate throttling, or affect other
 * aspects of the application's frame production pipeline. However, because the system
 * may change the display refresh rate, calls to this function may result in changes
 * to Choreographer callback timings, and changes to the time interval at which the
 * system releases buffers back to the application.</p>
 *
 * <p>Note that this only has an effect for surfaces presented on the display. If this
 * surface is consumed by something other than the system compositor, e.g. a media
 * codec, this call has no effect.</p>
 *
 * @param frameRate The intended frame rate of this surface, in frames per second. 0
 * is a special value that indicates the app will accept the system's choice for the
 * display frame rate, which is the default behavior if this function isn't
 * called. The frameRate param does <em>not</em> need to be a valid refresh rate for
 * this device's display - e.g., it's fine to pass 30fps to a device that can only run
 * the display at 60fps.
 *
 * @param compatibility The frame rate compatibility of this surface. The
 * compatibility value may influence the system's choice of display frame rate. See
 * the FRAME_RATE_COMPATIBILITY_* values for more info.
 *
 * @throws IllegalArgumentException If frameRate or compatibility are invalid.
 */
","/**
 * Sets the intended frame rate for this surface. Any switching of refresh rates is
 * most probably going to be seamless.
 *
 * @see #setFrameRate(float, int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The entire body of the method has been replaced with a call to setFrameRate with three parameters, and therefore it's an example of changes 4 and 5 'Other statement changed' and 'Dependent API changed', as the code now depends on an overloaded method of setFrameRate.","Even though the internal implementation has changed, this is a dependent API change where the new implementation delegates to an overloaded setFrameRate with a new parameter. This overload is expected to handle the frameRate and compatibility parameters as before, but with an additional flag for changing the frame rate only if seamless. This additional flag is an implementation detail that is not affecting the method signature or the expected behavior from an API consumer's standpoint when using setFrameRate(float, int). If the overloaded method maintains consistent behavior where the new parameter has no impact unless signalled, then no compatibility issue should arise as far as the observable behavior from this method signature is concerned. Thus, the CI type is 0."
716,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",30,31,"<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>","<android.hardware.camera2.params.OutputConfiguration: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    dest.writeInt(mRotation);
    dest.writeInt(mSurfaceGroupId);
    dest.writeInt(mSurfaceType);
    dest.writeInt(mConfiguredSize.getWidth());
    dest.writeInt(mConfiguredSize.getHeight());
    dest.writeInt(mIsDeferredConfig ? 1 : 0);
    dest.writeInt(mIsShared ? 1 : 0);
    dest.writeTypedList(mSurfaces);
    dest.writeString(mPhysicalCameraId);
    dest.writeInt(mIsMultiResolution ? 1 : 0);
    // writeList doesn't seem to work well with Integer list.
    dest.writeIntArray(convertIntegerToIntList(mSensorPixelModesUsed));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"New statements are added at the end of the method that write additional fields to the Parcel, so the code change type is 4.","There is no Compatibility Issue in this change because the additional data written to the Parcel are new fields that do not affect the behavior of existing code or change the handling of the object's existing state. The method signatures and exception throws remain the same. This added information is for future use, and older clients that do not know about the new fields will still be able to use this API without any issues since they won't try to read these new fields from the Parcel."
717,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,30,31,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,0,"{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}","{
    if (getState() != STATE_ON) {
        return toDeviceSet(Arrays.asList());
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return toDeviceSet(Attributable.setAttributionSource(Arrays.asList(mService.getBondedDevices(mAttributionSource)), mAttributionSource));
        }
        return toDeviceSet(Arrays.asList());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}",1,"/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
","/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement has changed from `return toDeviceSet(new BluetoothDevice[0]);` to `return toDeviceSet(Arrays.asList());` which could potentially return a different type, and a new dependent API `Attributable.setAttributionSource()` is added, making the code change types 1 and 5. Besides, a control dependency change is observed with the introduction of `Attributable.setAttributionSource()` within the 'if' statement block, making the code change type also be 3.","The altered return statements (usage of `Arrays.asList()` instead of `new BluetoothDevice[0]` for empty collections) and addition of new method (`Attributable.setAttributionSource`) for setting the attribution source will change the type or value returned by `getBondedDevices()`. Also, changes to annotations could alter the permissions required to use the method successfully when transitioning from the early to the late version. Thus, there is a potential Compatibility Issue of type 1."
718,"<android.view.inputmethod.EditorInfo: CharSequence getInitialTextBeforeCursor(int,int)>",30,31,"<android.view.inputmethod.EditorInfo: CharSequence getInitialTextBeforeCursor(int,int)>","<android.view.inputmethod.EditorInfo: CharSequence getInitialTextBeforeCursor(int,int)>",0,"{
    return mInitialSurroundingText.getInitialTextBeforeCursor(length, flags);
}","{
    if (mInitialSurroundingText == null) {
        return null;
    }
    int selStart = Math.min(mInitialSurroundingText.getSelectionStart(), mInitialSurroundingText.getSelectionEnd());
    int n = Math.min(length, selStart);
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selStart - n, selStart) : TextUtils.substring(mInitialSurroundingText.getText(), selStart - n, selStart);
}",1,"/**
 * Get <var>length</var> characters of text before the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text before the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text before the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */
","/**
 * Get <var>length</var> characters of text before the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text before the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text before the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the implementation introduces an 'if' condition to check if `mInitialSurroundingText` is null and returns null if it is. It also changes calculation for `selStart` and the value to be returned based on flags, which involves a new control statement and other new statements. Therefore, the code change type is 3,4.","There is no Compatibility Issue as the 'null' case for `mInitialSurroundingText` should have been handled by the early version implicitly. The refactored code in the late version makes this check explicit and preserves the behavior of the previous implicit check. Additionally, the flags handling preserves the contract of the method based on provided flags. Hence, the changes do not lead to any new behaviors that might cause Compatibility Issues."
719,<android.text.format.TimeFormatter: String formatMillisWithFixedFormat(long)>,30,31,<android.text.format.TimeFormatter: String formatMillisWithFixedFormat(long)>,<android.text.format.TimeFormatter: String formatMillisWithFixedFormat(long)>,0,"{
    // This method is deliberately not a general purpose replacement for
    // format(String, ZoneInfo.WallTime, ZoneInfo): It hard-codes the pattern used; many of the
    // pattern characters supported by Time.format() have unusual behavior which would make
    // using java.time.format or similar packages difficult. It would be a lot of work to share
    // behavior and many internal Android usecases can be covered by this common pattern
    // behavior.
    // No need to worry about overflow / underflow: long millis is representable by Instant and
    // LocalDateTime with room to spare.
    Instant instant = Instant.ofEpochMilli(timeMillis);
    // Date/times are calculated in the current system default time zone.
    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
    // You'd think it would be as simple as:
    // DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss"", locale);
    // return formatter.format(localDateTime);
    // but we retain Time's behavior around digits.
    StringBuilder stringBuilder = new StringBuilder(19);
    // This effectively uses the US locale because number localization is handled separately
    // (see below).
    stringBuilder.append(localDateTime.getYear());
    stringBuilder.append('-');
    append2DigitNumber(stringBuilder, localDateTime.getMonthValue());
    stringBuilder.append('-');
    append2DigitNumber(stringBuilder, localDateTime.getDayOfMonth());
    stringBuilder.append(' ');
    append2DigitNumber(stringBuilder, localDateTime.getHour());
    stringBuilder.append(':');
    append2DigitNumber(stringBuilder, localDateTime.getMinute());
    stringBuilder.append(':');
    append2DigitNumber(stringBuilder, localDateTime.getSecond());
    String result = stringBuilder.toString();
    return localizeDigits(result);
}","{
    // This method is deliberately not a general purpose replacement for format(String,
    // ZoneInfoData.WallTime, ZoneInfoData): It hard-codes the pattern used; many of the
    // pattern characters supported by Time.format() have unusual behavior which would make
    // using java.time.format or similar packages difficult. It would be a lot of work to share
    // behavior and many internal Android usecases can be covered by this common pattern
    // behavior.
    // No need to worry about overflow / underflow: long millis is representable by Instant and
    // LocalDateTime with room to spare.
    Instant instant = Instant.ofEpochMilli(timeMillis);
    // Date/times are calculated in the current system default time zone.
    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
    // You'd think it would be as simple as:
    // DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss"", locale);
    // return formatter.format(localDateTime);
    // but we retain Time's behavior around digits.
    StringBuilder stringBuilder = new StringBuilder(19);
    // This effectively uses the US locale because number localization is handled separately
    // (see below).
    stringBuilder.append(localDateTime.getYear());
    stringBuilder.append('-');
    append2DigitNumber(stringBuilder, localDateTime.getMonthValue());
    stringBuilder.append('-');
    append2DigitNumber(stringBuilder, localDateTime.getDayOfMonth());
    stringBuilder.append(' ');
    append2DigitNumber(stringBuilder, localDateTime.getHour());
    stringBuilder.append(':');
    append2DigitNumber(stringBuilder, localDateTime.getMinute());
    stringBuilder.append(':');
    append2DigitNumber(stringBuilder, localDateTime.getSecond());
    String result = stringBuilder.toString();
    return localizeDigits(result);
}",1,"/**
 * The implementation of {@link TimeMigrationUtils#formatMillisWithFixedFormat(long)} for
 * 2038-safe formatting with the pattern ""%Y-%m-%d %H:%M:%S"" and including the historic
 * incorrect digit localization behavior.
 */
","/**
 * The implementation of {@link TimeMigrationUtils#formatMillisWithFixedFormat(long)} for
 * 2038-safe formatting with the pattern ""%Y-%m-%d %H:%M:%S"" and including the historic
 * incorrect digit localization behavior.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change in the actual implementation between the two versions; the differences are only in the comments.,"As there is no change in the implementation, no potential Compatibility Issue could arise."
720,<android.database.AbstractCursor: void finalize()>,30,31,<android.database.AbstractCursor: void finalize()>,<android.database.AbstractCursor: void finalize()>,0,"{
    if (mSelfObserver != null && mSelfObserverRegistered == true) {
        mContentResolver.unregisterContentObserver(mSelfObserver);
    }
    try {
        if (!mClosed)
            close();
    } catch (Exception e) {
    }
}","{
    if (mSelfObserver != null && mSelfObserverRegistered == true) {
        mContentResolver.unregisterContentObserver(mSelfObserver);
    }
    try {
        if (mCloseGuard != null)
            mCloseGuard.warnIfOpen();
        if (!mClosed)
            close();
    } catch (Exception e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional method call (mCloseGuard.warnIfOpen()) is introduced in the try block. This represents an ""other statement changed,"" hence the code change type is 4.","The addition of mCloseGuard.warnIfOpen() does not affect the return type or value since the method is void, nor does it introduce different exception handling as the catch block remains the same. Therefore, there is no compatibility issue, and the CI type is 0."
723,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",30,31,"<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>","<android.view.NotificationHeaderView.HeaderTouchListener: boolean onTouch(View,MotionEvent)>",0,"{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mDownX = x;
                mDownY = y;
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                if (mAppOps.isVisibleToUser() && (mAppOpsRect.contains((int) x, (int) y) || mAppOpsRect.contains((int) mDownX, (int) mDownY))) {
                    mAppOps.performClick();
                    return true;
                }
                mExpandButton.performClick();
            }
            break;
    }
    return mTrackGesture;
}","{
    float x = event.getX();
    float y = event.getY();
    switch(event.getActionMasked() & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            mTrackGesture = false;
            if (isInside(x, y)) {
                mDownX = x;
                mDownY = y;
                mTrackGesture = true;
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mTrackGesture) {
                if (Math.abs(mDownX - x) > mTouchSlop || Math.abs(mDownY - y) > mTouchSlop) {
                    mTrackGesture = false;
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mTrackGesture) {
                float topLineX = mTopLineView.getX();
                float topLineY = mTopLineView.getY();
                if (mTopLineView.onTouchUp(x - topLineX, y - topLineY, mDownX - topLineX, mDownY - topLineY)) {
                    break;
                }
                mExpandButton.performClick();
            }
            break;
    }
    return mTrackGesture;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4","1,2","There is an additional statement ""float topLineX = mTopLineView.getX();"" and ""float topLineY = mTopLineView.getY();"" which are new local variable declarations. An additional if condition ""if (mTopLineView.onTouchUp(x - topLineX, y - topLineY, mDownX - topLineX, mDownY - topLineY))"" that includes a method call ""mTopLineView.onTouchUp()"" with changed parameters and a break statement in case of MotionEvent.ACTION_UP, results in altered control flow and exception handling, so the change type is 2,3,4.","The new if condition can alter the method behaviour by not performing a click on mExpandButton and potentially returning earlier, which leads to a different return value. Also, the new onTouchUp method call in 'mTopLineView' introduces a new potential RemoteException handling by executing this method, which could result in a different exception being thrown, thus the CI type is 1,2."
725,<android.app.PendingIntent: String getCreatorPackage()>,30,31,<android.app.PendingIntent: String getCreatorPackage()>,<android.app.PendingIntent: String getCreatorPackage()>,0,"{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getCachedInfo().getCreatorPackage();
}",1,"/**
 * Return the package name of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */
","/**
 * Return the package name of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * <p class=""note"">Be careful about how you use this.  All this tells you is
 * who created the PendingIntent.  It does <strong>not</strong> tell you who
 * handed the PendingIntent to you: that is, PendingIntent objects are intended to be
 * passed between applications, so the PendingIntent you receive from an application
 * could actually be one it received from another application, meaning the result
 * you get here will identify the original application.  Because of this, you should
 * only use this information to identify who you expect to be interacting with
 * through a {@link #send} call, not who gave you the PendingIntent.</p>
 *
 * @return The package name of the PendingIntent.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from invoking ActivityManager.getService().getPackageForIntentSender(mTarget) to getCachedInfo().getCreatorPackage(), and the logic of how to get the creator package has also changed significantly. Thus the code change types are 1 for return statement change and 5 for dependent API change.","Since the method of obtaining the creator package has shifted from a direct system service call to retrieving cached information, the returned value may differ between versions due to this alteration in data retrieval logic, which could potentially lead to different return values. Therefore, the CI type is 1."
726,"<android.hardware.biometrics.BiometricPrompt.Builder: Builder setNegativeButton(CharSequence,Executor,OnClickListener)>",30,31,"<android.hardware.biometrics.BiometricPrompt.Builder: Builder setNegativeButton(CharSequence,Executor,OnClickListener)>","<android.hardware.biometrics.BiometricPrompt.Builder: Builder setNegativeButton(CharSequence,Executor,OnClickListener)>",0,"{
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException(""Text must be set and non-empty"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Executor must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    mBundle.putCharSequence(KEY_NEGATIVE_TEXT, text);
    mNegativeButtonInfo = new ButtonInfo(executor, listener);
    return this;
}","{
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException(""Text must be set and non-empty"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""Executor must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    mPromptInfo.setNegativeButtonText(text);
    mNegativeButtonInfo = new ButtonInfo(executor, listener);
    return this;
}",1,"/**
 * Required: Sets the text, executor, and click listener for the negative button on the
 * prompt. This is typically a cancel button, but may be also used to show an alternative
 * method for authentication, such as a screen that asks for a backup password.
 *
 * <p>Note that this setting is not required, and in fact is explicitly disallowed, if
 * device credential authentication is enabled via {@link #setAllowedAuthenticators(int)} or
 * {@link #setDeviceCredentialAllowed(boolean)}.
 *
 * @param text Text to be shown on the negative button for the prompt.
 * @param executor Executor that will be used to run the on click callback.
 * @param listener Listener containing a callback to be run when the button is pressed.
 * @return This builder.
 */
","/**
 * Required: Sets the text, executor, and click listener for the negative button on the
 * prompt. This is typically a cancel button, but may be also used to show an alternative
 * method for authentication, such as a screen that asks for a backup password.
 *
 * <p>Note that this setting is not required, and in fact is explicitly disallowed, if
 * device credential authentication is enabled via {@link #setAllowedAuthenticators(int)} or
 * {@link #setDeviceCredentialAllowed(boolean)}.
 *
 * @param text Text to be shown on the negative button for the prompt.
 * @param executor Executor that will be used to run the on click callback.
 * @param listener Listener containing a callback to be run when the button is pressed.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The method implementation changes how the negative button text is set. In the early version, the text is put into a bundle with mBundle.putCharSequence(KEY_NEGATIVE_TEXT, text), while in the late version, the text is set directly on mPromptInfo with mPromptInfo.setNegativeButtonText(text). Additionally, this indicates that the underlying implementation of setting the text has changed, which corresponds to a Dependent API change in the setter of the negative button text, so the code change type is 4,5.","There is no Compatibility Issue detected for the API usage because the API's contract in terms of expected inputs (arguments) and outputs (the Builder object itself) remains unchanged. The changes within the implementation maintain the same functionality from the perspective of the caller; thus, they do not affect the API's external behavior or the way exceptions are handled or values returned by the API. The argument and method annotations have also remained the same. Hence, there is no CI."
727,<android.view.SurfaceControlViewHost: SurfacePackage getSurfacePackage()>,30,31,<android.view.SurfaceControlViewHost: SurfacePackage getSurfacePackage()>,<android.view.SurfaceControlViewHost: SurfacePackage getSurfacePackage()>,0,"{
    if (mSurfaceControl != null && mAccessibilityEmbeddedConnection != null) {
        return new SurfacePackage(mSurfaceControl, mAccessibilityEmbeddedConnection);
    } else {
        return null;
    }
}","{
    if (mSurfaceControl != null && mAccessibilityEmbeddedConnection != null) {
        return new SurfacePackage(mSurfaceControl, mAccessibilityEmbeddedConnection, mViewRoot.getInputToken());
    } else {
        return null;
    }
}",1,"/**
 * Return a SurfacePackage for the root SurfaceControl of the embedded hierarchy.
 * Rather than be directly reparented using {@link SurfaceControl.Transaction} this
 * SurfacePackage should be passed to {@link SurfaceView#setChildSurfacePackage}
 * which will not only reparent the Surface, but ensure the accessibility hierarchies
 * are linked.
 */
","/**
 * Return a SurfacePackage for the root SurfaceControl of the embedded hierarchy.
 * Rather than be directly reparented using {@link SurfaceControl.Transaction} this
 * SurfacePackage should be passed to {@link SurfaceView#setChildSurfacePackage}
 * which will not only reparent the Surface, but ensure the accessibility hierarchies
 * are linked.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed because a new parameter mViewRoot.getInputToken() has been added to the constructor of SurfacePackage. Additionally, the number of parameters in the constructor call of a dependent API (SurfacePackage) has changed. Hence, the change type is 1,5.","Because the number of parameters in the constructor of SurfacePackage has changed (which is a dependent API), this can potentially lead to different return values for the getSurfacePackage() method when different versions of the API are used. Therefore, the CI type is 1."
728,<android.widget.AnalogClock: void onAttachedToWindow()>,30,31,<android.widget.AnalogClock: void onAttachedToWindow()>,<android.widget.AnalogClock: void onAttachedToWindow()>,0,"{
    super.onAttachedToWindow();
    if (!mAttached) {
        mAttached = true;
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views machanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For exmaple, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, getHandler());
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the Time
    mClock = Clock.systemDefaultZone();
    // Make sure we update to the current time
    onTimeChanged();
}","{
    super.onAttachedToWindow();
    IntentFilter filter = new IntentFilter();
    if (!mReceiverAttached) {
        filter.addAction(Intent.ACTION_TIME_CHANGED);
        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
        // OK, this is gross but needed. This class is supported by the
        // remote views mechanism and as a part of that the remote views
        // can be inflated by a context for another user without the app
        // having interact users permission - just for loading resources.
        // For example, when adding widgets from a user profile to the
        // home screen. Therefore, we register the receiver as the current
        // user not the one the context is for.
        getContext().registerReceiverAsUser(mIntentReceiver, android.os.Process.myUserHandle(), filter, null, getHandler());
        mReceiverAttached = true;
    }
    // NOTE: It's safe to do these after registering the receiver since the receiver always runs
    // in the main thread, therefore the receiver can't run before this method returns.
    // The time zone may have changed while the receiver wasn't registered, so update the clock.
    createClock();
    // Make sure we update to the current time
    onTimeChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,The method implementation changes include: ,- The 'mClock' object was replaced by a call to 'createClock()' method.
729,<android.net.Uri.PathPart: PathPart fromDecoded(String)>,30,31,<android.net.Uri.PathPart: PathPart fromDecoded(String)>,<android.net.Uri.PathPart: PathPart fromDecoded(String)>,0,"{
    return from(NOT_CACHED, decoded);
}","{
    return from(NotCachedHolder.NOT_CACHED, decoded);
}",1,"/**
 * Creates a path from the decoded string.
 *
 * @param decoded part string
 */
","/**
 * Creates a path from the decoded string.
 *
 * @param decoded part string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a change from accessing a directly named constant NOT_CACHED to accessing it through an intermediary NotCachedHolder class (NotCachedHolder.NOT_CACHED). This represents changes related to the internal reference to the constant, which is a change type 4. Also, because this is about how the NOT_CACHED constant is accessed rather than the value itself changing, it constitutes a dependent API change, thus change type 5.","This change is unlikely to produce a different runtime behavior. The value of NOT_CACHED is assumed to remain the same, just its access pattern has changed. Therefore there's no Compatibility Issue; pred_CI is 0."
730,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>",30,31,"<android.app.LocalActivityManager: Window startActivity(String,Intent)>","<android.app.LocalActivityManager: Window startActivity(String,Intent)>",0,"{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                mActivityThread.handleNewIntent(r, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}","{
    if (mCurState == INITIALIZING) {
        throw new IllegalStateException(""Activities can't be added until the containing group has been created."");
    }
    boolean adding = false;
    boolean sameIntent = false;
    ActivityInfo aInfo = null;
    // Already have information about the new activity id?
    LocalActivityRecord r = mActivities.get(id);
    if (r == null) {
        // Need to create it...
        r = new LocalActivityRecord(id, intent);
        adding = true;
    } else if (r.intent != null) {
        sameIntent = r.intent.filterEquals(intent);
        if (sameIntent) {
            // We are starting the same activity.
            aInfo = r.activityInfo;
        }
    }
    if (aInfo == null) {
        aInfo = mActivityThread.resolveActivityInfo(intent);
    }
    // activity is allowed to be running at a time.
    if (mSingleMode) {
        LocalActivityRecord old = mResumed;
        // activity, we need to stop it.
        if (old != null && old != r && mCurState == RESUMED) {
            moveToState(old, STARTED);
        }
    }
    if (adding) {
        // It's a brand new world.
        mActivities.put(id, r);
        mActivityArray.add(r);
    } else if (r.activityInfo != null) {
        // we may be able to reuse it.
        if (aInfo == r.activityInfo || (aInfo.name.equals(r.activityInfo.name) && aInfo.packageName.equals(r.activityInfo.packageName))) {
            if (aInfo.launchMode != ActivityInfo.LAUNCH_MULTIPLE || (intent.getFlags() & Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0) {
                // The activity wants onNewIntent() called.
                ArrayList<ReferrerIntent> intents = new ArrayList<>(1);
                intents.add(new ReferrerIntent(intent, mParent.getPackageName()));
                if (localLOGV)
                    Log.v(TAG, r.id + "": new intent"");
                final ActivityClientRecord clientRecord = mActivityThread.getActivityClient(r);
                mActivityThread.handleNewIntent(clientRecord, intents);
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
            if (sameIntent && (intent.getFlags() & Intent.FLAG_ACTIVITY_CLEAR_TOP) == 0) {
                // We are showing the same thing, so this activity is
                // just resumed and stays as-is.
                r.intent = intent;
                moveToState(r, mCurState);
                if (mSingleMode) {
                    mResumed = r;
                }
                return r.window;
            }
        }
        // The new activity is different than the current one, or it
        // is a multiple launch activity, so we need to destroy what
        // is currently there.
        performDestroy(r, true);
    }
    r.intent = intent;
    r.curState = INITIALIZING;
    r.activityInfo = aInfo;
    moveToState(r, mCurState);
    // When in single mode keep track of the current activity
    if (mSingleMode) {
        mResumed = r;
    }
    return r.window;
}",1,"/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
","/**
 * Start a new activity running in the group.  Every activity you start
 * must have a unique string ID associated with it -- this is used to keep
 * track of the activity, so that if you later call startActivity() again
 * on it the same activity object will be retained.
 *
 * <p>When there had previously been an activity started under this id,
 * it may either be destroyed and a new one started, or the current
 * one re-used, based on these conditions, in order:</p>
 *
 * <ul>
 * <li> If the Intent maps to a different activity component than is
 * currently running, the current activity is finished and a new one
 * started.
 * <li> If the current activity uses a non-multiple launch mode (such
 * as singleTop), or the Intent has the
 * {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag set, then the current
 * activity will remain running and its
 * {@link Activity#onNewIntent(Intent) Activity.onNewIntent()} method
 * called.
 * <li> If the new Intent is the same (excluding extras) as the previous
 * one, and the new Intent does not have the
 * {@link Intent#FLAG_ACTIVITY_CLEAR_TOP} set, then the current activity
 * will remain running as-is.
 * <li> Otherwise, the current activity will be finished and a new
 * one started.
 * </ul>
 *
 * <p>If the given Intent can not be resolved to an available Activity,
 * this method throws {@link android.content.ActivityNotFoundException}.
 *
 * <p>Warning: There is an issue where, if the Intent does not
 * include an explicit component, we can restore the state for a different
 * activity class than was previously running when the state was saved (if
 * the set of available activities changes between those points).
 *
 * @param id Unique identifier of the activity to be started
 * @param intent The Intent describing the activity to be started
 *
 * @return Returns the window of the activity.  The caller needs to take
 * care of adding this window to a view hierarchy, and likewise dealing
 * with removing the old window if the activity has changed.
 *
 * @throws android.content.ActivityNotFoundException
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
731,"<android.app.UiAutomation: boolean injectInputEvent(InputEvent,boolean)>",30,31,"<android.app.UiAutomation: boolean injectInputEvent(InputEvent,boolean)>","<android.app.UiAutomation: boolean injectInputEvent(InputEvent,boolean)>",0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Injecting: "" + event + "" sync: "" + sync);
        }
        // Calling out without a lock held.
        return mUiAutomationConnection.injectInputEvent(event, sync);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while injecting input event!"", re);
    }
    return false;
}","{
    return injectInputEvent(event, sync, true);
}",1,"/**
 * A method for injecting an arbitrary input event.
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the event.
 * </p>
 * @param event The event to inject.
 * @param sync Whether to inject the event synchronously.
 * @return Whether event injection succeeded.
 */
","/**
 * A method for injecting an arbitrary input event.
 *
 * This method waits for all window container animations and surface operations to complete.
 *
 * <p>
 * <strong>Note:</strong> It is caller's responsibility to recycle the event.
 * </p>
 *
 * @param event The event to inject.
 * @param sync Whether to inject the event synchronously.
 * @return Whether event injection succeeded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire block of code inside the early implementation has been replaced with a single return statement that calls a different method with an additional parameter, so the methodâ€™s behavior is altered; hence the change types include 1 (Return statement changed) and 4 (Other statement changed).","This change will potentially result in a different return value or type since the new method being called could have different implementation details not visible in the provided context. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
733,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,30,31,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getCenterX()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterX(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center X"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationCenterX(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain center X"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 0.0f;
}",1,"/**
 * Returns the unscaled screen-relative X coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative X coordinate of the center of
 * the magnified region
 */
","/**
 * Returns the unscaled screen-relative X coordinate of the focal
 * center of the magnified region. This is the point around which
 * zooming occurs and is guaranteed to lie within the magnified
 * region.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 0.0f}.
 *
 * @return the unscaled screen-relative X coordinate of the center of
 * the magnified region
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The only change is in the argument passed to getInstance() method of AccessibilityInteractionClient; from 'getInstance().getConnection(...)' to 'getInstance(mService).getConnection(...)'. This is a dependent API change, so the code change type is 5.","There is no change in the behavior of how the method operates or handles exceptions, and the return value remains the same. Assuming 'getInstance(mService)' returns equivalent functionality to just 'getInstance()', the dependent API change should not introduce a compatibility issue. Therefore, there is no compatibility issue, and the CI type is 0."
734,<android.app.usage.UsageStats: void add(UsageStats)>,30,31,<android.app.usage.UsageStats: void add(UsageStats)>,<android.app.usage.UsageStats: void add(UsageStats)>,0,"{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mergeEventMap(mActivities, right.mActivities);
        mergeEventMap(mForegroundServices, right.mForegroundServices);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
        mLastTimeVisible = Math.max(mLastTimeVisible, right.mLastTimeVisible);
        mLastTimeForegroundServiceUsed = Math.max(mLastTimeForegroundServiceUsed, right.mLastTimeForegroundServiceUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mTotalTimeVisible += right.mTotalTimeVisible;
    mTotalTimeForegroundServiceUsed += right.mTotalTimeForegroundServiceUsed;
    mLaunchCount += right.mLaunchCount;
    mAppLaunchCount += right.mAppLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}","{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException(""Can't merge UsageStats for package '"" + mPackageName + ""' with UsageStats for package '"" + right.mPackageName + ""'."");
    }
    // regards to their mEndTimeStamp.
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // Even though incoming UsageStat begins after this one, its last time used fields
        // may somehow be empty or chronologically preceding the older UsageStat.
        mergeEventMap(mActivities, right.mActivities);
        mergeEventMap(mForegroundServices, right.mForegroundServices);
        mLastTimeUsed = Math.max(mLastTimeUsed, right.mLastTimeUsed);
        mLastTimeVisible = Math.max(mLastTimeVisible, right.mLastTimeVisible);
        mLastTimeComponentUsed = Math.max(mLastTimeComponentUsed, right.mLastTimeComponentUsed);
        mLastTimeForegroundServiceUsed = Math.max(mLastTimeForegroundServiceUsed, right.mLastTimeForegroundServiceUsed);
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mTotalTimeVisible += right.mTotalTimeVisible;
    mTotalTimeForegroundServiceUsed += right.mTotalTimeForegroundServiceUsed;
    mLaunchCount += right.mLaunchCount;
    mAppLaunchCount += right.mAppLaunchCount;
    if (mChooserCounts == null) {
        mChooserCounts = right.mChooserCounts;
    } else if (right.mChooserCounts != null) {
        final int chooserCountsSize = right.mChooserCounts.size();
        for (int i = 0; i < chooserCountsSize; i++) {
            String action = right.mChooserCounts.keyAt(i);
            ArrayMap<String, Integer> counts = right.mChooserCounts.valueAt(i);
            if (!mChooserCounts.containsKey(action) || mChooserCounts.get(action) == null) {
                mChooserCounts.put(action, counts);
                continue;
            }
            final int annotationSize = counts.size();
            for (int j = 0; j < annotationSize; j++) {
                String key = counts.keyAt(j);
                int rightValue = counts.valueAt(j);
                int leftValue = mChooserCounts.get(action).getOrDefault(key, 0);
                mChooserCounts.get(action).put(key, leftValue + rightValue);
            }
        }
    }
}",1,"/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
","/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change observed is the renaming of a variable within an assignment operation: mLastTimeComponentUsed has replaced mLastTimeVisible. This is a type of Other statement changed, so the code change type is 4.","Despite the change, there is no impact on the potential behavior of the API from an external perspective. The merging of statistics still occurs in the same way, and the change is strictly internal with no effect observable by the API users. Therefore, there's no Compatibility Issue, and the CI type is 0."
735,<android.service.wallpaper.WallpaperService.Engine: void detach()>,30,31,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mIWallpaperEngine.mDisplayManager != null) {
        mIWallpaperEngine.mDisplayManager.unregisterDisplayListener(mDisplayListener);
    }
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputEventReceiver != null) {
                mInputEventReceiver.dispose();
                mInputEventReceiver = null;
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        if (mBlastBufferQueue != null) {
            mBlastBufferQueue.destroy();
            mBlastBufferQueue = null;
        }
        if (mBbqSurfaceControl != null) {
            new SurfaceControl.Transaction().remove(mBbqSurfaceControl).apply();
            mBbqSurfaceControl = null;
        }
        mCreated = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,There are new lines of code that handle the destruction of `mBlastBufferQueue` and `mBbqSurfaceControl` objects added to the late version implementation that are absent from the early version. This constitutes a change type of 4 (Other statement changed).,"Even though new steps have been added to resource cleanup, no compatibility issue arises from this change because these additions do not result in a different return value or exception handling from the API's perspective. Existing clients calling `detach()` wouldn't notice these internal changes, as there's no change in the observable behavior of the method. Thus, the CI type is 0 (No Compatibility Issue)."
736,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,30,31,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevicesWithAttribution(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement includes a call to a modified dependent API, where `getConnectedDevices()` has been changed to `getConnectedDevicesWithAttribution(mAttributionSource)` and the result is further processed by `Attributable.setAttributionSource()`. Additionally, new annotations have also been introduced, suggesting changes in the required permissions to use the API. Thus, the code change types are 1 (return statement changed), 4 (other statement changed), and 5 (dependent API changed).","The API potentially returns different values because the dependent method call has changed, and now includes additional processing with `Attributable.setAttributionSource()`. The method also additionally requires new permissions as indicated by the new annotations. Therefore, the compatibility issue arises due to the potential difference in return values, and CI type is classified as 1."
737,<android.service.controls.ControlsProviderService.SubscriberProxy: void onNext(Control)>,30,31,<android.service.controls.ControlsProviderService.SubscriberProxy: void onNext(Control)>,<android.service.controls.ControlsProviderService.SubscriberProxy: void onNext(Control)>,0,"{
    Preconditions.checkNotNull(control);
    try {
        if (mEnforceStateless && !isStatelessControl(control)) {
            Log.w(TAG, ""onNext(): control is not stateless. Use the "" + ""Control.StatelessBuilder() to build the control."");
            control = new Control.StatelessBuilder(control).build();
        }
        mCs.onNext(mToken, control);
    } catch (RemoteException ex) {
        ex.rethrowAsRuntimeException();
    }
}","{
    Preconditions.checkNotNull(control);
    try {
        if (mEnforceStateless && !isStatelessControl(control)) {
            Log.w(TAG, ""onNext(): control is not stateless. Use the "" + ""Control.StatelessBuilder() to build the control."");
            control = new Control.StatelessBuilder(control).build();
        }
        if (mContext != null) {
            control.getControlTemplate().prepareTemplateForBinder(mContext);
        }
        mCs.onNext(mToken, control);
    } catch (RemoteException ex) {
        ex.rethrowAsRuntimeException();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new if statement is added to check if mContext is non-null, and then calls a method on control. Also, there is a new method invocation control.getControlTemplate().prepareTemplateForBinder(mContext) within the new if statement. This is a change in control dependency and introduction of a new method call, so the change types are 3 and 4.","The addition of a new if condition and the method call to control.getControlTemplate().prepareTemplateForBinder(mContext) do not inherently cause a different value to be returned or a different exception to be thrown by the API, so there is no compatibility issue (0) based on the given implementation. The API's behavior remains consistent in how it handles the 'control' parameter and rethrows exceptions as runtime exceptions."
739,"<android.os.VibrationAttributes.Builder: Builder setFlags(int,int)>",30,31,"<android.os.VibrationAttributes.Builder: Builder setFlags(int,int)>","<android.os.VibrationAttributes.Builder: Builder setFlags(int,int)>",0,"{
    mFlags = (mFlags & ~mask) | (flags & mask);
    return this;
}","{
    mask &= FLAG_ALL_SUPPORTED;
    mFlags = (mFlags & ~mask) | (flags & mask);
    return this;
}",1,"/**
 * Set flags
 * @param flags combination of flags to be set.
 * @param mask Bit range that should be changed.
 * @return the same Builder instance.
 */
","/**
 * Set flags
 * @param flags combination of flags to be set.
 * @param mask Bit range that should be changed.
 * @return the same Builder instance.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"There is an additional assignment operation to 'mask' before it's used in the bitwise operations on 'mFlags', so the code change type is 4 (Other statement changed).","Since the new assignment to 'mask' utilizes a bitwise AND with a constant (FLAG_ALL_SUPPORTED), which is presumably defining which flags are supported, it should not introduce a Compatibility Issue as long as FLAG_ALL_SUPPORTED includes all flags previously supported. The method still returns 'this' (the Builder object), and there's no change in the method's return type, exception throwing, or the value of 'this'. Therefore, there is no Compatibility Issue."
740,<android.net.Uri.Part: String getEncoded()>,30,31,<android.net.Uri.Part: String getEncoded()>,<android.net.Uri.Part: String getEncoded()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NOT_CACHED;
    return hasEncoded ? encoded : (encoded = encode(decoded));
}","{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NotCachedHolder.NOT_CACHED;
    return hasEncoded ? encoded : (encoded = encode(decoded));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The reference to the NOT_CACHED variable has been altered to refer to NotCachedHolder.NOT_CACHED, which indicates the use of a different or nested class to hold the constant. This change is classified as type 4 (Other statement changed) since it involves a change in the structure of how the constant is accessed but does not affect control flow or method behavior. It also indicates a dependent API change (type 5) because it relies on the NotCachedHolder class or its static field.","There is no Compatibility Issue detected because the result of evaluating encoded != NOT_CACHED is equivalent to encoded != NotCachedHolder.NOT_CACHED if the constant value hasn't changed. The assignment (encoded = encode(decoded)) remains the same, indicating the return value should behave consistently between versions regardless of the constant's source. Hence, the change should not affect the method's external behavior."
741,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,30,31,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,<android.service.notification.NotificationAssistantService.MyHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                NotificationChannel channel = (NotificationChannel) args.arg2;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn, channel);
                setAdjustmentIssuer(adjustment);
                if (adjustment != null) {
                    if (!isBound()) {
                        Log.w(TAG, ""MSG_ON_NOTIFICATION_ENQUEUED: service not bound, skip."");
                        return;
                    }
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    } catch (SecurityException e) {
                        // app cannot catch and recover from this, so do on their behalf
                        Log.w(TAG, ""Enqueue adjustment failed; no longer connected"", e);
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
        case MSG_ON_NOTIFICATIONS_SEEN:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                List<String> keys = (List<String>) args.arg1;
                args.recycle();
                onNotificationsSeen(keys);
                break;
            }
        case MSG_ON_NOTIFICATION_EXPANSION_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isUserAction = args.argi1 == 1;
                boolean isExpanded = args.argi2 == 1;
                args.recycle();
                onNotificationExpansionChanged(key, isUserAction, isExpanded);
                break;
            }
        case MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationDirectReplied(key);
                break;
            }
        case MSG_ON_SUGGESTED_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                CharSequence reply = (CharSequence) args.arg2;
                int source = args.argi2;
                args.recycle();
                onSuggestedReplySent(key, reply, source);
                break;
            }
        case MSG_ON_ACTION_INVOKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                Notification.Action action = (Notification.Action) args.arg2;
                int source = args.argi2;
                args.recycle();
                onActionInvoked(key, action, source);
                break;
            }
        case MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED:
            {
                onAllowedAdjustmentsChanged();
                break;
            }
        case MSG_ON_PANEL_REVEALED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int items = args.argi1;
                args.recycle();
                onPanelRevealed(items);
                break;
            }
        case MSG_ON_PANEL_HIDDEN:
            {
                onPanelHidden();
                break;
            }
        case MSG_ON_NOTIFICATION_VISIBILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isVisible = args.argi1 == 1;
                args.recycle();
                onNotificationVisibilityChanged(key, isVisible);
                break;
            }
    }
}","{
    switch(msg.what) {
        case MSG_ON_NOTIFICATION_ENQUEUED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                NotificationChannel channel = (NotificationChannel) args.arg2;
                RankingMap ranking = (RankingMap) args.arg3;
                args.recycle();
                Adjustment adjustment = onNotificationEnqueued(sbn, channel, ranking);
                setAdjustmentIssuer(adjustment);
                if (adjustment != null) {
                    if (!isBound()) {
                        Log.w(TAG, ""MSG_ON_NOTIFICATION_ENQUEUED: service not bound, skip."");
                        return;
                    }
                    try {
                        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
                    } catch (android.os.RemoteException ex) {
                        Log.v(TAG, ""Unable to contact notification manager"", ex);
                        throw ex.rethrowFromSystemServer();
                    } catch (SecurityException e) {
                        // app cannot catch and recover from this, so do on their behalf
                        Log.w(TAG, ""Enqueue adjustment failed; no longer connected"", e);
                    }
                }
                break;
            }
        case MSG_ON_NOTIFICATION_SNOOZED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                StatusBarNotification sbn = (StatusBarNotification) args.arg1;
                String snoozeCriterionId = (String) args.arg2;
                args.recycle();
                onNotificationSnoozedUntilContext(sbn, snoozeCriterionId);
                break;
            }
        case MSG_ON_NOTIFICATIONS_SEEN:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                List<String> keys = (List<String>) args.arg1;
                args.recycle();
                onNotificationsSeen(keys);
                break;
            }
        case MSG_ON_NOTIFICATION_EXPANSION_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isUserAction = args.argi1 == 1;
                boolean isExpanded = args.argi2 == 1;
                args.recycle();
                onNotificationExpansionChanged(key, isUserAction, isExpanded);
                break;
            }
        case MSG_ON_NOTIFICATION_DIRECT_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationDirectReplied(key);
                break;
            }
        case MSG_ON_SUGGESTED_REPLY_SENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                CharSequence reply = (CharSequence) args.arg2;
                int source = args.argi2;
                args.recycle();
                onSuggestedReplySent(key, reply, source);
                break;
            }
        case MSG_ON_ACTION_INVOKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                Notification.Action action = (Notification.Action) args.arg2;
                int source = args.argi2;
                args.recycle();
                onActionInvoked(key, action, source);
                break;
            }
        case MSG_ON_ALLOWED_ADJUSTMENTS_CHANGED:
            {
                onAllowedAdjustmentsChanged();
                break;
            }
        case MSG_ON_PANEL_REVEALED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                int items = args.argi1;
                args.recycle();
                onPanelRevealed(items);
                break;
            }
        case MSG_ON_PANEL_HIDDEN:
            {
                onPanelHidden();
                break;
            }
        case MSG_ON_NOTIFICATION_VISIBILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                boolean isVisible = args.argi1 == 1;
                args.recycle();
                onNotificationVisibilityChanged(key, isVisible);
                break;
            }
        case MSG_ON_NOTIFICATION_CLICKED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                args.recycle();
                onNotificationClicked(key);
                break;
            }
        case MSG_ON_NOTIFICATION_FEEDBACK_RECEIVED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String key = (String) args.arg1;
                RankingMap ranking = (RankingMap) args.arg2;
                Bundle feedback = (Bundle) args.arg3;
                args.recycle();
                onNotificationFeedbackReceived(key, ranking, feedback);
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
742,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>",30,31,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>","<android.view.inputmethod.BaseInputConnection: CharSequence getTextAfterCursor(int,int)>",0,"{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Guard against the case where the cursor has not been positioned yet.
    if (b < 0) {
        b = 0;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}","{
    Preconditions.checkArgumentNonnegative(length);
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Guard against the case where the cursor has not been positioned yet.
    if (b < 0) {
        b = 0;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}",1,"/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
","/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,4,0,"The introduction of `Preconditions.checkArgumentNonnegative(length);` is a change in the statements other than return statements, exception handling statements, and control dependency statements. Therefore, the code change type is 4.","The added precondition check for the `length` argument does not constitute a compatibility issue as it ensures that the `length` passed is non-negative, which is a reasonable expectation for the method to function correctly. If the `length` was negative in the previous version, it would have resulted in an `IndexOutOfBoundsException` when attempting to create a substring. Therefore, it simply enforces a valid use of the method without changing its expected behavior. Thus, there is no compatibility issue here."
744,<android.app.Activity: void setTurnScreenOn(boolean)>,30,31,<android.app.Activity: void setTurnScreenOn(boolean)>,<android.app.Activity: void setTurnScreenOn(boolean)>,0,"{
    try {
        ActivityTaskManager.getService().setTurnScreenOn(mToken, turnScreenOn);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    ActivityClient.getInstance().setTurnScreenOn(mToken, turnScreenOn);
}",1,"/**
 * Specifies whether the screen should be turned on when the {@link Activity} is resumed.
 * Normally an activity will be transitioned to the stopped state if it is started while the
 * screen if off, but with this flag set the activity will cause the screen to turn on if the
 * activity will be visible and resumed due to the screen coming on. The screen will not be
 * turned on if the activity won't be visible after the screen is turned on. This flag is
 * normally used in conjunction with the {@link android.R.attr#showWhenLocked} flag to make sure
 * the activity is visible after the screen is turned on when the lockscreen is up. In addition,
 * if this flag is set and the activity calls {@link
 * KeyguardManager#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)}
 * the screen will turn on.
 *
 * @param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
 *
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 */
","/**
 * Specifies whether the screen should be turned on when the {@link Activity} is resumed.
 * Normally an activity will be transitioned to the stopped state if it is started while the
 * screen if off, but with this flag set the activity will cause the screen to turn on if the
 * activity will be visible and resumed due to the screen coming on. The screen will not be
 * turned on if the activity won't be visible after the screen is turned on. This flag is
 * normally used in conjunction with the {@link android.R.attr#showWhenLocked} flag to make sure
 * the activity is visible after the screen is turned on when the lockscreen is up. In addition,
 * if this flag is set and the activity calls {@link
 * KeyguardManager#requestDismissKeyguard(Activity, KeyguardManager.KeyguardDismissCallback)}
 * the screen will turn on. If the screen is off and device is not secured, this flag can turn
 * screen on and dismiss keyguard to make this activity visible and resume, which can be used to
 * replace {@link PowerManager#ACQUIRE_CAUSES_WAKEUP}
 *
 * @param turnScreenOn {@code true} to turn on the screen; {@code false} otherwise.
 *
 * @see #setShowWhenLocked(boolean)
 * @see android.R.attr#turnScreenOn
 * @see android.R.attr#showWhenLocked
 * @see KeyguardManager#isDeviceSecure()
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API used in the method has changed from ActivityTaskManager.getService().setTurnScreenOn to ActivityClient.getInstance().setTurnScreenOn. Therefore, the code change is of type 5.","Even though a different dependent API is used in the late implementation, as there is no change in the return value or exception handling, there is no Compatibility Issue (the same boolean input will result in the same behavior without different outcomes or exceptions). Hence, CI type is 0."
745,<android.content.ContentProviderOperation: String toString()>,30,31,<android.content.ContentProviderOperation: String toString()>,<android.content.ContentProviderOperation: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""ContentProviderOperation("");
    sb.append(""type="" + typeToString(mType) + "" "");
    if (mUri != null) {
        sb.append(""uri="" + mUri + "" "");
    }
    if (mValues != null) {
        sb.append(""values="" + mValues + "" "");
    }
    if (mSelection != null) {
        sb.append(""selection="" + mSelection + "" "");
    }
    if (mSelectionArgs != null) {
        sb.append(""selectionArgs="" + mSelectionArgs + "" "");
    }
    if (mExpectedCount != null) {
        sb.append(""expectedCount="" + mExpectedCount + "" "");
    }
    if (mYieldAllowed) {
        sb.append(""yieldAllowed "");
    }
    if (mExceptionAllowed) {
        sb.append(""exceptionAllowed "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""ContentProviderOperation("");
    sb.append(""type="").append(typeToString(mType)).append(' ');
    if (mUri != null) {
        sb.append(""uri="").append(mUri).append(' ');
    }
    if (mValues != null) {
        sb.append(""values="").append(mValues).append(' ');
    }
    if (mSelection != null) {
        sb.append(""selection="").append(mSelection).append(' ');
    }
    if (mSelectionArgs != null) {
        sb.append(""selectionArgs="").append(mSelectionArgs).append(' ');
    }
    if (mExpectedCount != null) {
        sb.append(""expectedCount="").append(mExpectedCount).append(' ');
    }
    if (mYieldAllowed) {
        sb.append(""yieldAllowed "");
    }
    if (mExceptionAllowed) {
        sb.append(""exceptionAllowed "");
    }
    sb.deleteCharAt(sb.length() - 1);
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The concatenation inside the append method has been modified to use separate append calls for each variable. This change does not affect the output of the method but is a change to improve the efficiency of StringBuilder, so the code change type is 4.","This change does not lead to a Compatibility Issue because the final value produced by the StringBuilder and returned by toString() remains the same. Thus, there is no CI."
746,<android.app.PendingIntent: String getTargetPackage()>,30,31,<android.app.PendingIntent: String getTargetPackage()>,<android.app.PendingIntent: String getTargetPackage()>,0,"{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return getCreatorPackage();
}",1,"/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
","/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
",-1,[@Deprecated],"[@Deprecated, @Nullable]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has been changed from calling ActivityManager.getService().getPackageForIntentSender(mTarget) directly to calling another method getCreatorPackage(). Therefore, the code change type is 1,5 due to the replaced return statement and change in the method dependencies.","Since the implementation now calls a different method (getCreatorPackage() instead of ActivityManager.getService().getPackageForIntentSender(mTarget)), it has the potential to return different values. Therefore, the CI type is 1, indicating a potential difference in return values or types."
747,<android.app.Activity: void setRequestedOrientation(int)>,30,31,<android.app.Activity: void setRequestedOrientation(int)>,<android.app.Activity: void setRequestedOrientation(int)>,0,"{
    if (mParent == null) {
        try {
            ActivityTaskManager.getService().setRequestedOrientation(mToken, requestedOrientation);
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}","{
    if (mParent == null) {
        ActivityClient.getInstance().setRequestedOrientation(mToken, requestedOrientation);
    } else {
        mParent.setRequestedOrientation(requestedOrientation);
    }
}",1,"/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
","/**
 * Change the desired orientation of this activity.  If the activity
 * is currently in the foreground or otherwise impacting the screen
 * orientation, the screen will immediately be changed (possibly causing
 * the activity to be restarted). Otherwise, this will be used the next
 * time the activity is visible.
 *
 * @param requestedOrientation An orientation constant as used in
 * {@link ActivityInfo#screenOrientation ActivityInfo.screenOrientation}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The implementation of setting requested orientation has changed from using `ActivityTaskManager.getService().setRequestedOrientation()` to `ActivityClient.getInstance().setRequestedOrientation()`, and the exception handling code was removed. Therefore, the change types are 3, as the control flow changed by removing the try-catch block, and 5, because there is a change in the dependent API used to set the requested orientation.","There is no Compatibility Issue as the behavior of setting the requested orientation for the activity remains the same. The client code that calls `setRequestedOrientation` does not expect any return value or exception to be thrown, hence the removal of the try-catch block does not affect the callers. The handling of `RemoteException` is internal and does not change the way the method should be used or its observable effects from the outside. Thus, there is no CI."
748,<android.bluetooth.BluetoothDevice: boolean setPairingConfirmation(boolean)>,30,31,<android.bluetooth.BluetoothDevice: boolean setPairingConfirmation(boolean)>,<android.bluetooth.BluetoothDevice: boolean setPairingConfirmation(boolean)>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set pairing confirmation"");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot set pairing confirmation"");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out false for error
 */
","/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out false for error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)],"[@RequiresPermission(allOf = { android.Manifest.permission.BLUETOOTH_CONNECT, android.Manifest.permission.BLUETOOTH_PRIVILEGED })]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change involves calling the method setPairingConfirmation with an additional parameter, mAttributionSource, thus signaling a change in the dependent API, which is 5. There's also an alteration in the annotations indicating a change in required permissions, which falls under other statement changed, indicated as 4.","The change in the method's arguments and required permissions does not directly lead to a different variable returned or a different exception thrown. The method's internal logic and its return behavior remain unchanged, and there are also no new exceptions introduced. Therefore, it does not introduce a compatibility issue, and the pred_CI is 0."
749,<android.os.Looper: void loop()>,30,31,<android.os.Looper: void loop()>,<android.os.Looper: void loop()>,0,"{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    if (me.mInLoop) {
        Slog.w(TAG, ""Loop again would have the queued messages be executed"" + "" before this one completed."");
    }
    me.mInLoop = true;
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, ""Drained"");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, ""delivery"", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, ""dispatch"", msg);
        }
        if (logging != null) {
            logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
        }
        msg.recycleUnchecked();
    }
}","{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    if (me.mInLoop) {
        Slog.w(TAG, ""Loop again would have the queued messages be executed"" + "" before this one completed."");
    }
    me.mInLoop = true;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt(""log.looper."" + Process.myUid() + ""."" + Thread.currentThread().getName() + "".slow"", 0);
    me.mSlowDeliveryDetected = false;
    for (; ; ) {
        if (!loopOnce(me, ident, thresholdOverride)) {
            return;
        }
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",-1,,"[@SuppressWarnings(""AndroidFrameworkBinderIdentity"")]",-1,-1,-1,-1,-1,-1,,,,
750,<android.view.DisplayCutout: String toString()>,30,31,<android.view.DisplayCutout: String toString()>,<android.view.DisplayCutout: String toString()>,0,"{
    return ""DisplayCutout{insets="" + mSafeInsets + "" waterfall="" + mWaterfallInsets + "" boundingRect={"" + mBounds + ""}"" + ""}"";
}","{
    return ""DisplayCutout{insets="" + mSafeInsets + "" waterfall="" + mWaterfallInsets + "" boundingRect={"" + mBounds + ""}"" + "" cutoutPathParserInfo={"" + mCutoutPathParserInfo + ""}"" + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A string literal has been added to the return statement. No change to the type or the control flow of the method, so the code change type is 4.","The modification is only appending additional information to a string that is being returned. There is no change in behavior or logic that could lead to a compatibility issue, so there is no CI."
751,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDescription(CharSequence)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDescription(CharSequence)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setDescription(CharSequence)>,0,"{
    mBundle.putCharSequence(KEY_DESCRIPTION, description);
    return this;
}","{
    mPromptInfo.setDescription(description);
    return this;
}",1,"/**
 * Optional: Sets a description that will be shown on the prompt.
 * @param description The description to display.
 * @return This builder.
 */
","/**
 * Optional: Sets a description that will be shown on the prompt.
 * @param description The description to display.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation changed from directly interacting with a Bundle object to calling a method on another object (mPromptInfo.setDescription(description)), so the change is related to a Dependent API, categorized as type 5.","Although there is a change in the way the description is set, as long as the setDescription method on mPromptInfo behaves the same way as the original code which adds the description to the Bundle with KEY_DESCRIPTION, there would be no compatibility issue. The return type remains the same and no new exception is thrown, hence there is no CI."
753,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,30,31,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,<android.accessibilityservice.AccessibilityServiceInfo: String toString()>,0,"{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""nonInteractiveUiTimeout: "").append(mNonInteractiveUiTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""interactiveUiTimeout: "").append(mInteractiveUiTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder();
    appendEventTypes(stringBuilder, eventTypes);
    stringBuilder.append("", "");
    appendPackageNames(stringBuilder, packageNames);
    stringBuilder.append("", "");
    appendFeedbackTypes(stringBuilder, feedbackType);
    stringBuilder.append("", "");
    stringBuilder.append(""notificationTimeout: "").append(notificationTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""nonInteractiveUiTimeout: "").append(mNonInteractiveUiTimeout);
    stringBuilder.append("", "");
    stringBuilder.append(""interactiveUiTimeout: "").append(mInteractiveUiTimeout);
    stringBuilder.append("", "");
    appendFlags(stringBuilder, flags);
    stringBuilder.append("", "");
    stringBuilder.append(""id: "").append(getId());
    stringBuilder.append("", "");
    stringBuilder.append(""resolveInfo: "").append(mResolveInfo);
    stringBuilder.append("", "");
    stringBuilder.append(""settingsActivityName: "").append(mSettingsActivityName);
    stringBuilder.append("", "");
    stringBuilder.append(""summary: "").append(mNonLocalizedSummary);
    stringBuilder.append("", "");
    stringBuilder.append(""isAccessibilityTool: "").append(mIsAccessibilityTool);
    stringBuilder.append("", "");
    appendCapabilities(stringBuilder, mCapabilities);
    return stringBuilder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new append statement has been introduced which adds ""isAccessibilityTool: "" along with the mIsAccessibilityTool value to the stringBuilder object, so the code change type is 4 (Other statement changed).","The addition of a new string to the stringBuilder will result in a different return value. Therefore, there is a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
754,<android.view.Display.Mode: String toString()>,30,31,<android.view.Display.Mode: String toString()>,<android.view.Display.Mode: String toString()>,0,"{
    return new StringBuilder(""{"").append(""id="").append(mModeId).append("", width="").append(mWidth).append("", height="").append(mHeight).append("", fps="").append(mRefreshRate).append(""}"").toString();
}","{
    return new StringBuilder(""{"").append(""id="").append(mModeId).append("", width="").append(mWidth).append("", height="").append(mHeight).append("", fps="").append(mRefreshRate).append("", alternativeRefreshRates="").append(Arrays.toString(mAlternativeRefreshRates)).append(""}"").toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method's body has changed by adding more information into the StringBuilder ("", alternativeRefreshRates="").append(Arrays.toString(mAlternativeRefreshRates)), which is not present in the early version. Also a new method call to Arrays.toString() has been introduced. This is an example of both 'Return statement changed' and 'Other statement changed', so the code change type is 1,4.","This change will alter the output of the toString() method by including additional data about alternative refresh rates, which means the return value will be different from the previous version. Thus, the CI type is 1."
755,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,30,31,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,<android.widget.SelectionActionModeHelper.TextClassificationHelper: SelectionResult suggestSelection()>,0,"{
    mHot = true;
    trimText();
    final TextSelection selection;
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
        final TextSelection.Request request = new TextSelection.Request.Builder(mTrimmedText, mRelativeStart, mRelativeEnd).setDefaultLocales(mDefaultLocales).setDarkLaunchAllowed(true).build();
        selection = mTextClassifier.get().suggestSelection(request);
    } else {
        // Use old APIs.
        selection = mTextClassifier.get().suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mDefaultLocales);
    }
    // Do not classify new selection boundaries if TextClassifier should be dark launched.
    if (!isDarkLaunchEnabled()) {
        mSelectionStart = Math.max(0, selection.getSelectionStartIndex() + mTrimStart);
        mSelectionEnd = Math.min(mText.length(), selection.getSelectionEndIndex() + mTrimStart);
    }
    return performClassification(selection);
}","{
    mInitialized = true;
    trimText();
    final TextSelection selection;
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
        final TextSelection.Request request = new TextSelection.Request.Builder(mTrimmedText, mRelativeStart, mRelativeEnd).setDefaultLocales(mDefaultLocales).setDarkLaunchAllowed(true).setIncludeTextClassification(true).build();
        selection = mTextClassifier.get().suggestSelection(request);
    } else {
        // Use old APIs.
        selection = mTextClassifier.get().suggestSelection(mTrimmedText, mRelativeStart, mRelativeEnd, mDefaultLocales);
    }
    // Do not classify new selection boundaries if TextClassifier should be dark launched.
    if (!isDarkLaunchEnabled()) {
        mSelectionStart = Math.max(0, selection.getSelectionStartIndex() + mTrimStart);
        mSelectionEnd = Math.min(mText.length(), selection.getSelectionEndIndex() + mTrimStart);
    }
    return performClassification(selection);
}",1,,,-1,[@WorkerThread],[@WorkerThread],-1,-1,-1,-1,-1,-1,4,0,"The assignment to the boolean flag has changed from `mHot = true` to `mInitialized = true`, and a new method call `.setIncludeTextClassification(true)` has been added to the TextSelection.Request builder. This represents a change in the other statements, so the code change type is 4.","Both changes should have negligible impact on the behavior from an API consumer perspective. The flag change is internal and does not affect the return value or the exceptions thrown. The additional request property set with `.setIncludeTextClassification(true)` does not impact the API's behavior unless it changes the behavior of `performClassification(selection)` which implies that the classification might include more information in the late version, but it is not certain that this will lead to a different return value from the perspective of the method's signature. Assuming `performClassification(selection)` behaves the same independent of this flag, there would be no compatibility issue, so the CI is 0. If `performClassification(selection)`'s behavior changes significantly based on the flag, it would need to be addressed on a case-by-case basis, but there is not enough information to confirm a CI based on the current context."
756,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,30,31,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,<android.hardware.camera2.params.OutputConfiguration: int hashCode()>,0,"{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
}","{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode method has additional parameters in its return statements in the late version (mIsMultiResolution and mSensorPixelModesUsed.hashCode()), and these parameters are not conditioned by a control structure, so the code change type is 1,4.","Since new parameters are included in the hash code computation, the method will potentially return different values. Therefore, the CI type is 1."
757,<android.hardware.camera2.utils.SurfaceUtils: boolean isFlexibleConsumer(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: boolean isFlexibleConsumer(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: boolean isFlexibleConsumer(Surface)>,0,"{
    return LegacyCameraDevice.isFlexibleConsumer(output);
}","{
    checkNotNull(output);
    long usageFlags = nativeDetectSurfaceUsageFlags(output);
    // Keep up to date with allowed consumer types in
    // frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
    long disallowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE | USAGE_RENDERSCRIPT;
    long allowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | HardwareBuffer.USAGE_CPU_READ_OFTEN | USAGE_HW_COMPOSER;
    boolean flexibleConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    return flexibleConsumer;
}",1,"/**
 * Return true is the consumer is one of the consumers that can accept
 * producer overrides of the default dimensions and format.
 */
","/**
 * Return true is the consumer is one of the consumers that can accept
 * producer overrides of the default dimensions and format.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation of the method has changed completely, introducing new local variables, control flow (bitwise operations), and a different method call. Additionally, there is a dependency on a newly introduced native method `nativeDetectSurfaceUsageFlags(output)` and a change in the dependent API from `LegacyCameraDevice.isFlexibleConsumer(output)` to direct usage flag checks, which includes usage of `HardwareBuffer` constants. Hence, the code change types include 1 (due to the new return statement logic), 3 (for the new control flow), 4 (other statements introduced), and 5 (due to changes in the dependent API).","The change in implementation can potentially lead to different return values since the condition for determining if a consumer is flexible has been altered significantly. There is no change in exception handling, so the possible CI is of type 1."
759,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",30,31,"<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>","<android.app.ContextImpl: Context createApplicationContext(ApplicationInfo,int)>",0,"{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, null, null, mToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}","{
    LoadedApk pi = mMainThread.getPackageInfo(application, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE);
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, ContextParams.EMPTY, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), null, mToken, new UserHandle(UserHandle.getUserId(application.uid)), flags, null, null);
        final int displayId = getDisplayId();
        final Integer overrideDisplayId = mForceDisplayOverrideInResources ? displayId : null;
        c.setResources(createResources(mToken, pi, null, overrideDisplayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    throw new PackageManager.NameNotFoundException(""Application package "" + application.packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",0,"The method signatures are the same; however, there are several changes in the implementations:",- A new `ContextParams.EMPTY` argument is passed to `ContextImpl`.
760,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",30,31,"<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcastAsUser(Intent,UserHandle,String,int,Bundle,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, null, /*excludedPermissions=*/
        appOp, options, true, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The only change in the code is the replacement of `appOp` with `null /*excludedPermissions=*/` and `appOp` in the `ActivityManager.getService().broadcastIntentWithFeature` method call, which indicates a change in the dependent API since the sequence and meaning of the parameters have changed.","This change in the parameter list of a method call could potentially lead to the API behaving differently because the null passed for ""excludedPermissions"" implies a different behavior than passing a possibly non-null value for ""appOp"". If appOp was serving a purpose previously and is no longer being provided, the API could return different results or side effects based on its internal implementation. Thus, a CI caused by potential different return values or types is present."
761,<android.app.Activity: void stopLockTask()>,30,31,<android.app.Activity: void stopLockTask()>,<android.app.Activity: void stopLockTask()>,0,"{
    try {
        ActivityTaskManager.getService().stopLockTaskModeByToken(mToken);
    } catch (RemoteException e) {
    }
}","{
    ActivityClient.getInstance().stopLockTaskModeByToken(mToken);
}",1,"/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its whitelist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
","/**
 * Stop the current task from being locked.
 *
 * <p>Called to end the LockTask or screen pinning mode started by {@link #startLockTask()}.
 * This can only be called by activities that have called {@link #startLockTask()} previously.
 *
 * <p><strong>Note:</strong> If the device is in LockTask mode that is not initially started
 * by this activity, then calling this method will not terminate the LockTask mode, but only
 * finish its own task. The device will remain in LockTask mode, until the activity which
 * started the LockTask mode calls this method, or until its allowlist authorization is revoked
 * by {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}.
 *
 * @see #startLockTask()
 * @see android.R.attr#lockTaskMode
 * @see ActivityManager#getLockTaskModeState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The implementation has changed from calling `ActivityTaskManager.getService().stopLockTaskModeByToken(mToken)` inside a try-catch block to directly invoking `ActivityClient.getInstance().stopLockTaskModeByToken(mToken)` without a try-catch block. The try-catch block for `RemoteException` has been removed and a different method is being called in the late version. This corresponds to code change types 4 (other statement changed) and 5 (dependent API changed).,"There is no Compatibility Issue here. Even though the method being called has changed, it's an internal mechanism and does not change the behavior exposed to the user or the output of the method. The absence of the try-catch block for `RemoteException` does not introduce a CI because `RemoteException` is a checked exception which must be either caught or declared in the method signature. Since the method signature did not declare `throws RemoteException`, and the original code did not handle the exception (empty catch block), the removal of the try-catch block does not alter the method's behavior from the API consumer's perspective."
762,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,30,31,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,0,"{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, ""BT not enabled. Cannot fetchUuidsWithSdp"");
        return false;
    }
    try {
        return service.fetchRemoteUuidsWithAttribution(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 *
 * @return False if the sanity check fails, True if the process of initiating an ACL connection
 * to the remote device was started.
 */
","/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time, or the device is bonding and
 * we have its UUIDs cached, {@link #ACTION_UUID} intent is sent with the UUIDs that is
 * currently present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed. If there is an ongoing bonding process,
 * service discovery or device inquiry, the request will be queued.
 *
 * @return False if the check fails, True if the process of initiating an ACL connection
 * to the remote device was started or cached UUIDs will be broadcast.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",1,"The method called within the 'try' block has changed from fetchRemoteUuids(this) to fetchRemoteUuidsWithAttribution(this, mAttributionSource), although the return type and exception handling remain the same. The method signature has changed by adding a second parameter, which is a dependent API change. Other statements remain the same, so only the dependent API and another statement related to that change are detected, which is class 4,5.","The change in the dependent API call from fetchRemoteUuids to fetchRemoteUuidsWithAttribution with an additional parameter mAttributionSource could potentially lead to different return values since the logic within the new method could be different from the former. Hence, it could cause a compatibility issue related to different return values or types, indicated by CI type 1."
763,<android.app.WallpaperColors: boolean equals(Object)>,30,31,<android.app.WallpaperColors: boolean equals(Object)>,<android.app.WallpaperColors: boolean equals(Object)>,0,"{
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    WallpaperColors other = (WallpaperColors) o;
    return mMainColors.equals(other.mMainColors) && mColorHints == other.mColorHints;
}","{
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    WallpaperColors other = (WallpaperColors) o;
    return mMainColors.equals(other.mMainColors) && mAllColors.equals(other.mAllColors) && mColorHints == other.mColorHints;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement is extended with an additional condition (mAllColors.equals(other.mAllColors)), which is added in the late version. Therefore, the change type is 1.","The change in the return statement with the added condition makes it possible for the late version API to return a different value even when comparing the same objects. Consequently, this can lead to a compatibility issue as the behavior or result of the equals method could change. Thus, the CI type is 1."
764,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",30,31,"<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentResolver: int bulkInsert(Uri,ContentValues[])>",0,"{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(values, ""values"");
    try {
        if (mWrapped != null)
            return mWrapped.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, mAttributionTag, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(values, ""values"");
    try {
        if (mWrapped != null)
            return mWrapped.bulkInsert(url, values);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mContext.getAttributionSource(), url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""bulkinsert"", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
","/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The method parameter passed to `bulkInsert` has changed. In the early version, it's `provider.bulkInsert(mPackageName, mAttributionTag, url, values)`, while the late version uses `provider.bulkInsert(mContext.getAttributionSource(), url, values)`. This indicates a change in the dependent API invocation, but not in the method signature itself. Therefore, the change type is marked as 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in how the arguments are obtained and passed to the `bulkInsert` method, the semantics of the method's execution do not inherently imply a change in the method's outward behavior or the type/value of its return. The external signature of the method `bulkInsert(Uri, ContentValues[])` remains unchanged, and so long as the contracts of `mPackageName`, `mAttributionTag`, and `mContext.getAttributionSource()` convey the same eventual information to the invoked method, the calling code should remain compatible. Therefore, there seems to be no compatibility issue, resulting in the predication of CI type 0 (No Compatibility Issue)."
765,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,30,31,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,<android.view.ViewRootImpl.InputStage: boolean shouldDropInputEvent(QueuedInputEvent)>,0,"{
    if (mView == null || !mAdded) {
        Slog.w(mTag, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    } else if ((!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isAutofillUiShowing()) || mStopped || (mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) || (mPausedForTransition && !isBack(q.mEvent))) {
        // but the window has lost focus or stopped in the meantime.
        if (isTerminalInputEvent(q.mEvent)) {
            // Don't drop terminal input events, however mark them as canceled.
            q.mEvent.cancel();
            Slog.w(mTag, ""Cancelling event due to no window focus: "" + q.mEvent);
            return false;
        }
        // Drop non-terminal input events.
        Slog.w(mTag, ""Dropping event due to no window focus: "" + q.mEvent);
        return true;
    }
    return false;
}","{
    if (mView == null || !mAdded) {
        Slog.w(mTag, ""Dropping event due to root view being removed: "" + q.mEvent);
        return true;
    }
    // Find a reason for dropping or canceling the event.
    final String reason;
    if (!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isAutofillUiShowing()) {
        // This is a non-pointer event and the window doesn't currently have input focus
        // This could be an event that came back from the previous stage
        // but the window has lost focus or stopped in the meantime.
        reason = ""no window focus"";
    } else if (mStopped) {
        reason = ""window is stopped"";
    } else if (mIsAmbientMode && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_BUTTON)) {
        reason = ""non-button event in ambient mode"";
    } else if (mPausedForTransition && !isBack(q.mEvent)) {
        reason = ""paused for transition"";
    } else {
        // Most common path: no reason to drop or cancel the event
        return false;
    }
    if (isTerminalInputEvent(q.mEvent)) {
        // Don't drop terminal input events, however mark them as canceled.
        q.mEvent.cancel();
        Slog.w(mTag, ""Cancelling event ("" + reason + ""):"" + q.mEvent);
        return false;
    }
    // Drop non-terminal input events.
    Slog.w(mTag, ""Dropping event ("" + reason + ""):"" + q.mEvent);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change involves the addition of a new variable `reason` and reorganization of how debugging messages are logged. A new block of conditions has been added to assign a specific reason when determining whether to drop the event, but the fundamental logic of whether to drop or cancel events has not changed. This constitutes a change in a non-return, non-exception statement, which is type 4. Along with this, statements under the main condition checks have changed position and are now under different control dependencies, involving a change of type 3.","There is no Compatibility Issue detected because the modifications are related to logging improvements and internal variable assignments without changing the method's external behavior regarding the return value or exception handling. The fundamental conditions that determine the event handling (dropped or canceled) and the return value remain identical; thus, the behavior remains consistent between the two versions."
766,<android.bluetooth.BluetoothGattServer: void clearServices()>,30,31,<android.bluetooth.BluetoothGattServer: void clearServices()>,<android.bluetooth.BluetoothGattServer: void clearServices()>,0,"{
    if (DBG)
        Log.d(TAG, ""clearServices()"");
    if (mService == null || mServerIf == 0)
        return;
    try {
        mService.clearServices(mServerIf);
        mServices.clear();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    if (DBG)
        Log.d(TAG, ""clearServices()"");
    if (mService == null || mServerIf == 0)
        return;
    try {
        mService.clearServices(mServerIf, mAttributionSource);
        mServices.clear();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Remove all services from the list of provided services.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
","/**
 * Remove all services from the list of provided services.
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The method mService.clearServices is now called with an additional parameter mAttributionSource, and annotations have been added for permission requirements, so the change type is 5.",There is no Compatibility Issue arising from these changes since they are related to permissions and an internal implementation detail (passing an additional parameter inside a method call) that does not affect the behavior as observed by the calling code. There is no change in the return value or exception handling that would be experienced by the API consumers.
768,<android.service.notification.NotificationListenerService.Ranking: List<CharSequence> getSmartReplies()>,30,31,<android.service.notification.NotificationListenerService.Ranking: List<CharSequence> getSmartReplies()>,<android.service.notification.NotificationListenerService.Ranking: List<CharSequence> getSmartReplies()>,0,"{
    return mSmartReplies;
}","{
    return mSmartReplies == null ? Collections.emptyList() : mSmartReplies;
}",1,"/**
 * Returns a list of smart replies that can be added by the
 * {@link NotificationAssistantService}
 */
","/**
 * Returns a list of smart replies that can be added by the
 * {@link NotificationAssistantService}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The return statement has been modified to include a conditional check and potentially returns a different value (Collections.emptyList()) if mSmartReplies is null, so the change type is 1.","The modification adds a null-check for mSmartReplies and changes the return value to return an empty list instead of null which alter the behavior of the API, thus it can cause a CI of type 1."
769,"<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>",30,31,"<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.PreferredActivityBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        // TODO: http://b/22388012
        switch(key) {
            case KEY_PREFERRED:
                pm.restorePreferredActivities(payload, UserHandle.USER_SYSTEM);
                break;
            case KEY_DEFAULT_APPS:
                pm.restoreDefaultApps(payload, UserHandle.USER_SYSTEM);
                break;
            case KEY_INTENT_VERIFICATION:
                pm.restoreIntentFilterVerification(payload, UserHandle.USER_SYSTEM);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}","{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PREFERRED:
                pm.restorePreferredActivities(payload, mUserId);
                break;
            case KEY_DEFAULT_APPS:
                pm.restoreDefaultApps(payload, mUserId);
                break;
            case KEY_INTENT_VERIFICATION:
                // Deprecated
                break;
            case KEY_DOMAIN_VERIFICATION:
                pm.restoreDomainVerification(payload, mUserId);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to restore key "" + key, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5","1,2","Control dependency has changed within the switch statement, as a new case has been added (KEY_DOMAIN_VERIFICATION), an old case has been altered (KEY_INTENT_VERIFICATION does nothing now), and the hardcoded user ID has been replaced with a variable mUserId in calls to the PackageManager, this contributes to change type 3. The level of logging within the catch block has been increased from a warning to an error, contributing to change type 4. The modified parameters within the PackageManager calls contribute to change type 5.","Given the nature of the changes: 1) the different handling of the KEY_INTENT_VERIFICATION case (no operation as opposed to a function call), 2) the addition of a new case KEY_DOMAIN_VERIFICATION, and 3) replacing UserHandle.USER_SYSTEM with mUserId, the behaviour of this API method could differ between the two versions leading to both different return values or a lack thereof (if an exception is caught, since the catch block logging level has changed), marking a CI type 1. Additionally, the different log level in the exception handling could influence the handling of exceptions and user debugging experience, hence the CI type 2."
770,<android.os.Parcel: Creator<?> readParcelableCreator(ClassLoader)>,30,31,<android.os.Parcel: Creator<?> readParcelableCreator(ClassLoader)>,<android.os.Parcel: Creator<?> readParcelableCreator(ClassLoader)>,0,"{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<?> creator;
    HashMap<String, Parcelable.Creator<?>> map;
    synchronized (mCreators) {
        map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
    }
    if (creator != null) {
        return creator;
    }
    try {
        // If loader == null, explicitly emulate Class.forName(String) ""caller
        // classloader"" behavior.
        ClassLoader parcelableClassLoader = (loader == null ? getClass().getClassLoader() : loader);
        // Avoid initializing the Parcelable class until we know it implements
        // Parcelable and has the necessary CREATOR field. http://b/1171613.
        Class<?> parcelableClass = Class.forName(name, false, /* initialize */
        parcelableClassLoader);
        if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
            throw new BadParcelableException(""Parcelable protocol requires subclassing "" + ""from Parcelable on class "" + name);
        }
        Field f = parcelableClass.getField(""CREATOR"");
        if ((f.getModifiers() & Modifier.STATIC) == 0) {
            throw new BadParcelableException(""Parcelable protocol requires "" + ""the CREATOR object to be static on class "" + name);
        }
        Class<?> creatorType = f.getType();
        if (!Parcelable.Creator.class.isAssignableFrom(creatorType)) {
            // parcelableClass unnecessarily.
            throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name);
        }
        creator = (Parcelable.Creator<?>) f.get(null);
    } catch (IllegalAccessException e) {
        Log.e(TAG, ""Illegal access when unmarshalling: "" + name, e);
        throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, ""Class not found when unmarshalling: "" + name, e);
        throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name);
    } catch (NoSuchFieldException e) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name);
    }
    if (creator == null) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""non-null Parcelable.Creator object called "" + ""CREATOR on class "" + name);
    }
    synchronized (mCreators) {
        map.put(name, creator);
    }
    return creator;
}","{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<?> creator;
    HashMap<String, Parcelable.Creator<?>> map;
    synchronized (mCreators) {
        map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
    }
    if (creator != null) {
        return creator;
    }
    try {
        // If loader == null, explicitly emulate Class.forName(String) ""caller
        // classloader"" behavior.
        ClassLoader parcelableClassLoader = (loader == null ? getClass().getClassLoader() : loader);
        // Avoid initializing the Parcelable class until we know it implements
        // Parcelable and has the necessary CREATOR field. http://b/1171613.
        Class<?> parcelableClass = Class.forName(name, false, /* initialize */
        parcelableClassLoader);
        if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
            throw new BadParcelableException(""Parcelable protocol requires subclassing "" + ""from Parcelable on class "" + name);
        }
        Field f = parcelableClass.getField(""CREATOR"");
        if ((f.getModifiers() & Modifier.STATIC) == 0) {
            throw new BadParcelableException(""Parcelable protocol requires "" + ""the CREATOR object to be static on class "" + name);
        }
        Class<?> creatorType = f.getType();
        if (!Parcelable.Creator.class.isAssignableFrom(creatorType)) {
            // parcelableClass unnecessarily.
            throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name);
        }
        creator = (Parcelable.Creator<?>) f.get(null);
    } catch (IllegalAccessException e) {
        Log.e(TAG, ""Illegal access when unmarshalling: "" + name, e);
        throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name, e);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, ""Class not found when unmarshalling: "" + name, e);
        throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name, e);
    } catch (NoSuchFieldException e) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + ""CREATOR on class "" + name, e);
    }
    if (creator == null) {
        throw new BadParcelableException(""Parcelable protocol requires a "" + ""non-null Parcelable.Creator object called "" + ""CREATOR on class "" + name);
    }
    synchronized (mCreators) {
        map.put(name, creator);
    }
    return creator;
}",1,"/**
 * Read and return a Parcelable.Creator from the parcel. The given class loader will be used to
 * load the {@link Parcelable.Creator}. If it is null, the default class loader will be used.
 *
 * @param loader A ClassLoader from which to instantiate the {@link Parcelable.Creator}
 * object, or null for the default class loader.
 * @return the previously written {@link Parcelable.Creator}, or null if a null Creator was
 * written.
 * @throws BadParcelableException Throws BadParcelableException if there was an error trying to
 * read the {@link Parcelable.Creator}.
 *
 * @see #writeParcelableCreator
 */
","/**
 * Read and return a Parcelable.Creator from the parcel. The given class loader will be used to
 * load the {@link Parcelable.Creator}. If it is null, the default class loader will be used.
 *
 * @param loader A ClassLoader from which to instantiate the {@link Parcelable.Creator}
 * object, or null for the default class loader.
 * @return the previously written {@link Parcelable.Creator}, or null if a null Creator was
 * written.
 * @throws BadParcelableException Throws BadParcelableException if there was an error trying to
 * read the {@link Parcelable.Creator}.
 *
 * @see #writeParcelableCreator
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
771,<android.bluetooth.le.AdvertiseData: String toString()>,30,31,<android.bluetooth.le.AdvertiseData: String toString()>,<android.bluetooth.le.AdvertiseData: String toString()>,0,"{
    return ""AdvertiseData [mServiceUuids="" + mServiceUuids + "", mManufacturerSpecificData="" + BluetoothLeUtils.toString(mManufacturerSpecificData) + "", mServiceData="" + BluetoothLeUtils.toString(mServiceData) + "", mIncludeTxPowerLevel="" + mIncludeTxPowerLevel + "", mIncludeDeviceName="" + mIncludeDeviceName + ""]"";
}","{
    return ""AdvertiseData [mServiceUuids="" + mServiceUuids + "", mServiceSolicitationUuids="" + mServiceSolicitationUuids + "", mManufacturerSpecificData="" + BluetoothLeUtils.toString(mManufacturerSpecificData) + "", mServiceData="" + BluetoothLeUtils.toString(mServiceData) + "", mIncludeTxPowerLevel="" + mIncludeTxPowerLevel + "", mIncludeDeviceName="" + mIncludeDeviceName + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement in the toString method has been altered by adding a new field (mServiceSolicitationUuids), resulting in a different string representation, so the code change type is 1.","Since the API will now return a string representation with an additional field, the return value has potentially changed, leading to a CI type of 1."
772,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",30,31,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>","<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",0,"{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new IpPrefix(address, prefixLength), null));
    mConfig.updateAllowedFamilies(address);
    return this;
}","{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new IpPrefix(address, prefixLength), null, null, RouteInfo.RTN_UNICAST));
    mConfig.updateAllowedFamilies(address);
    return this;
}",1,"/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
","/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * Adding a route implicitly allows traffic from that address family
 * (i.e., IPv4 or IPv6) to be routed over the VPN. @see #allowFamily
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API RouteInfo constructor has a new parameter added in the late version, but since it's properly supplied as a new `null` value and a constant (`RouteInfo.RTN_UNICAST`), this would not cause a change in the return value of the method, so the code change type is 4,5.","The changes to the constructor call of RouteInfo do not introduce differences in the behaviour of the `addRoute` method that would be visible to callers. An additional null parameter and a constant are provided for the new fields, which would not change the functional outcome of this method. As such, no Compatibility Issue arises from these changes."
774,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController(int)>,30,31,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController(int)>,<android.accessibilityservice.AccessibilityService: AccessibilityButtonController getAccessibilityButtonController(int)>,0,"{
    synchronized (mLock) {
        AccessibilityButtonController controller = mAccessibilityButtonControllers.get(displayId);
        if (controller == null) {
            controller = new AccessibilityButtonController(AccessibilityInteractionClient.getInstance().getConnection(mConnectionId));
            mAccessibilityButtonControllers.put(displayId, controller);
        }
        return controller;
    }
}","{
    synchronized (mLock) {
        AccessibilityButtonController controller = mAccessibilityButtonControllers.get(displayId);
        if (controller == null) {
            controller = new AccessibilityButtonController(AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId));
            mAccessibilityButtonControllers.put(displayId, controller);
        }
        return controller;
    }
}",1,"/**
 * Returns the controller of specified logical display for the accessibility button within the
 * system's navigation area. This instance may be used to query the accessibility button's
 * state and register listeners for interactions with and state changes for the accessibility
 * button when {@link AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON} is set.
 * <p>
 * <strong>Note:</strong> Not all devices are capable of displaying the accessibility button
 * within a navigation area, and as such, use of this class should be considered only as an
 * optional feature or shortcut on supported device implementations.
 * </p>
 *
 * @param displayId The logic display id, use {@link Display#DEFAULT_DISPLAY} for default
 * display.
 * @return the accessibility button controller for this {@link AccessibilityService}
 */
","/**
 * Returns the controller of specified logical display for the accessibility button within the
 * system's navigation area. This instance may be used to query the accessibility button's
 * state and register listeners for interactions with and state changes for the accessibility
 * button when {@link AccessibilityServiceInfo#FLAG_REQUEST_ACCESSIBILITY_BUTTON} is set.
 * <p>
 * <strong>Note:</strong> Not all devices are capable of displaying the accessibility button
 * within a navigation area, and as such, use of this class should be considered only as an
 * optional feature or shortcut on supported device implementations.
 * </p>
 *
 * @param displayId The logic display id, use {@link Display#DEFAULT_DISPLAY} for default
 * display.
 * @return the accessibility button controller for this {@link AccessibilityService}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call within the 'new AccessibilityButtonController(...)' constructor changed from 'AccessibilityInteractionClient.getInstance()' to 'AccessibilityInteractionClient.getInstance(this)'. Hence, the code change type is 5.","There are no changes in return values, exception handling, or control flow. The modification is in the instance creation of 'AccessibilityInteractionClient', where a parameter 'this' is added to the method call. As the result returned by 'getAccessibilityButtonController' is not affected by the parameter passed to 'getInstance', and the construction of 'AccessibilityButtonController' appears to remain consistent, there should not be a Compatibility Issue directly caused by this change; hence, CI type is 0."
775,<android.view.SurfaceView: int getImportantForAccessibility()>,30,31,<android.view.SurfaceView: int getImportantForAccessibility()>,<android.view.SurfaceView: int getImportantForAccessibility()>,0,"{
    final int mode = super.getImportantForAccessibility();
    // an embedded hierarchy.
    if (mRemoteAccessibilityEmbeddedConnection == null || mode != IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        return mode;
    }
    return IMPORTANT_FOR_ACCESSIBILITY_YES;
}","{
    final int mode = super.getImportantForAccessibility();
    // an embedded hierarchy.
    if ((mRemoteAccessibilityController != null && !mRemoteAccessibilityController.connected()) || mode != IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        return mode;
    }
    return IMPORTANT_FOR_ACCESSIBILITY_YES;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"There is a change in control dependency by altering the condition in the 'if' statement. The reference mRemoteAccessibilityEmbeddedConnection is replaced by mRemoteAccessibilityController and its method connected() is added to the condition. This indicates changes in both the control dependency and the dependent API, therefore the code change types are 3,5.","The altered 'if' condition can potentially affect whether 'mode' or IMPORTANT_FOR_ACCESSIBILITY_YES is returned. Because the return value may differ depending on the new condition involving the mRemoteAccessibilityController and its connection status, this may lead to a different behavior, so the CI type is 1."
777,<android.app.LoadedApk.SplitDependencyLoaderImpl: ClassLoader getClassLoaderForSplit(String)>,30,31,<android.app.LoadedApk.SplitDependencyLoaderImpl: ClassLoader getClassLoaderForSplit(String)>,<android.app.LoadedApk.SplitDependencyLoaderImpl: ClassLoader getClassLoaderForSplit(String)>,0,"{
    return mCachedClassLoaders[ensureSplitLoaded(splitName)];
}","{
    final int idx = ensureSplitLoaded(splitName);
    synchronized (mLock) {
        return mCachedClassLoaders[idx];
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The addition of the synchronized block (`synchronized (mLock) { ... }`) around the return statement is a change in the control dependency (3) as well as other statement changed (4), because a new synchronization mechanism has been introduced.","This change does not lead to a compatibility issue. The addition of a synchronized block ensures that there is mutual exclusion when accessing `mCachedClassLoaders`. The behavior in terms of what `getClassLoaderForSplit` returns has not been affected; it still returns the same class loader object for the split, just with added thread safety. Therefore, there is no compatibility issue (0)."
779,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",30,31,"<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>","<android.view.ViewGroup: PointerIcon onResolvePointerIcon(MotionEvent,int)>",0,"{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            View childWithAccessibilityFocus = event.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                // safer given the timeframe.
                if (childWithAccessibilityFocus != null) {
                    if (childWithAccessibilityFocus != child) {
                        continue;
                    }
                    childWithAccessibilityFocus = null;
                    i = childrenCount - 1;
                }
                event.setTargetAccessibilityFocus(false);
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}","{
    final float x = event.getX(pointerIndex);
    final float y = event.getY(pointerIndex);
    if (isOnScrollbarThumb(x, y) || isDraggingScrollBar()) {
        return PointerIcon.getSystemIcon(mContext, PointerIcon.TYPE_ARROW);
    }
    // Check what the child under the pointer says about the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            final PointerIcon pointerIcon = dispatchResolvePointerIcon(event, pointerIndex, child);
            if (pointerIcon != null) {
                if (preorderedList != null)
                    preorderedList.clear();
                return pointerIcon;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // implementation.
    return super.onResolvePointerIcon(event, pointerIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The block of code dealing with the childWithAccessibilityFocus variable and setting the target accessibility focus on the event has been removed. This results in changes to both algorithmic logic (change type 3 since it's under a 'for' control structure) and other statements (change type 4 due to deletion of statements not directly related to control structures, exception handling, or returns).","There is no Compatibility Issue related to potential different return values, types, or exceptions being thrown due to these changes. The missing code pertains to an internal conditional check and subsequent modification of a loop index and the event's accessibility focus, which does not affect the API's return value or exception handling. The removal of this code could change the internal flow of the method, but it does not introduce a case where the API would behave outwardly different in terms of what it returns or the exceptions it might throw, given that the return statements and the essence of the method, including remaining control structures and the final return statement, are unaltered."
780,"<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",30,31,"<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>","<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    synchronized (mInterfaceLock) {
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, mCharacteristics.get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraOfflineSessionImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        final Executor executor = holder.getCallback().getExecutor();
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    final CameraCaptureSession.CaptureCallback callback = holder.getCallback().getSessionCallback();
                    if (!CameraOfflineSessionImpl.this.isClosed() && (callback != null)) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                final CaptureResult resultInBatch = new CaptureResult(resultLocal, holder.getRequest(i), resultExtras);
                                final CaptureRequest cbRequest = holder.getRequest(i);
                                callback.onCaptureProgressed(CameraOfflineSessionImpl.this, cbRequest, resultInBatch);
                            }
                        } else {
                            callback.onCaptureProgressed(CameraOfflineSessionImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    final CameraCaptureSession.CaptureCallback callback = holder.getCallback().getSessionCallback();
                    if (!CameraOfflineSessionImpl.this.isClosed() && (callback != null)) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                final CaptureRequest cbRequest = holder.getRequest(i);
                                callback.onCaptureCompleted(CameraOfflineSessionImpl.this, cbRequest, resultInBatch);
                            }
                        } else {
                            callback.onCaptureCompleted(CameraOfflineSessionImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        if (executor != null) {
            final long ident = Binder.clearCallingIdentity();
            try {
                executor.execute(resultDispatch);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    synchronized (mInterfaceLock) {
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, mCharacteristics.get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraOfflineSessionImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        final Executor executor = holder.getCallback().getExecutor();
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(mCameraId, result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    final CameraCaptureSession.CaptureCallback callback = holder.getCallback().getSessionCallback();
                    if (!CameraOfflineSessionImpl.this.isClosed() && (callback != null)) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                final CaptureResult resultInBatch = new CaptureResult(mCameraId, resultLocal, holder.getRequest(i), resultExtras);
                                final CaptureRequest cbRequest = holder.getRequest(i);
                                callback.onCaptureProgressed(CameraOfflineSessionImpl.this, cbRequest, resultInBatch);
                            }
                        } else {
                            callback.onCaptureProgressed(CameraOfflineSessionImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(mCameraId, result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    final CameraCaptureSession.CaptureCallback callback = holder.getCallback().getSessionCallback();
                    if (!CameraOfflineSessionImpl.this.isClosed() && (callback != null)) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(mCameraId, resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                final CaptureRequest cbRequest = holder.getRequest(i);
                                callback.onCaptureCompleted(CameraOfflineSessionImpl.this, cbRequest, resultInBatch);
                            }
                        } else {
                            callback.onCaptureCompleted(CameraOfflineSessionImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        if (executor != null) {
            final long ident = Binder.clearCallingIdentity();
            try {
                executor.execute(resultDispatch);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
782,<android.view.WindowInsets: boolean hasInsets()>,30,31,<android.view.WindowInsets: boolean hasInsets()>,<android.view.WindowInsets: boolean hasInsets()>,0,"{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null;
}","{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null || mRoundedCorners != null;
}",1,"/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
","/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is extended with an additional condition ""|| mRoundedCorners != null"", so the code change type is 1.","With the addition of the new condition ""mRoundedCorners != null"" to the return statement, the API now potentially returns 'true' in cases where it previously would have returned 'false' if mRoundedCorners is not null. This change thus leads to a difference in return value, and the CI type is 1."
784,<android.net.Uri.OpaqueUri: String toString()>,30,31,<android.net.Uri.OpaqueUri: String toString()>,<android.net.Uri.OpaqueUri: String toString()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean cached = cachedString != NOT_CACHED;
    if (cached) {
        return cachedString;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(scheme).append(':');
    sb.append(getEncodedSchemeSpecificPart());
    if (!fragment.isEmpty()) {
        sb.append('#').append(fragment.getEncoded());
    }
    return cachedString = sb.toString();
}","{
    @SuppressWarnings(""StringEquality"") boolean cached = cachedString != NotCachedHolder.NOT_CACHED;
    if (cached) {
        return cachedString;
    }
    StringBuilder sb = new StringBuilder();
    sb.append(scheme).append(':');
    sb.append(getEncodedSchemeSpecificPart());
    if (!fragment.isEmpty()) {
        sb.append('#').append(fragment.getEncoded());
    }
    return cachedString = sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The check for caching changed from `cachedString != NOT_CACHED` to `cachedString != NotCachedHolder.NOT_CACHED`. Although this is a change in how the cached value is determined, it's an internal change without affecting the API's contract or behavior. This change is referring to a potentially different way of accessing the NOT_CACHED constant, which is a change in a dependent API. Hence, the code change types are 4 for the different reference used and 5 for the change in the dependent constant reference.","There's no Compatibility Issue arising from this change because the behavior of the API remains the same; it still returns a cached value if available and assembles a new string representation otherwise, using the same approach and steps as before. Therefore, the change does not lead to a different return value or different exception handling from the perspective of an API client."
785,<android.app.NotificationManager: String addAutomaticZenRule(AutomaticZenRule)>,30,31,<android.app.NotificationManager: String addAutomaticZenRule(AutomaticZenRule)>,<android.app.NotificationManager: String addAutomaticZenRule(AutomaticZenRule)>,0,"{
    INotificationManager service = getService();
    try {
        return service.addAutomaticZenRule(automaticZenRule);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    INotificationManager service = getService();
    try {
        return service.addAutomaticZenRule(automaticZenRule, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Creates the given zen rule.
 *
 * <p>
 * Throws a SecurityException if policy access is not granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 *
 * @param automaticZenRule the rule to create.
 * @return The id of the newly created rule; null if the rule could not be created.
 */
","/**
 * Creates the given zen rule.
 *
 * <p>
 * Throws a SecurityException if policy access is not granted to this package.
 * See {@link #isNotificationPolicyAccessGranted}.
 *
 * @param automaticZenRule the rule to create.
 * @return The id of the newly created rule; null if the rule could not be created.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"There's an addition of a parameter to the 'addAutomaticZenRule' method call, which indicates that the dependent API has changed, so the code change type is 5.","Although there's an added parameter to the method call within the API, this doesn't change the return type or throw a new exception. As such, it doesn't directly lead to a compatibility issue based on the given rules. The calling code should work without changes as long as it uses the appropriate API level, hence the CI type is 0."
786,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",30,31,"<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>","<android.app.usage.UsageStatsManager: List<UsageStats> queryUsageStats(int,long,long)>",0,"{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return the empty list.
    }
    return Collections.emptyList();
}","{
    try {
        @SuppressWarnings(""unchecked"") ParceledListSlice<UsageStats> slice = mService.queryUsageStats(intervalType, beginTime, endTime, mContext.getOpPackageName(), mContext.getUserId());
        if (slice != null) {
            return slice.getList();
        }
    } catch (RemoteException e) {
    // fallthrough and return the empty list.
    }
    return Collections.emptyList();
}",1,"/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 *
 * <p>
 * The returned list will contain one or more {@link UsageStats} objects for each package, with
 * usage data that covers at least the given time range.
 * Note: The begin and end times of the time range may be expanded to the nearest whole interval
 * period.
 * </p>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's
 * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),
 * then {@code null} will be returned.</em>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime The exclusive end of the range of stats to include in the results. Defined
 * in terms of ""Unix time"", see {@link java.lang.System#currentTimeMillis}.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
","/**
 * Gets application usage stats for the given time range, aggregated by the specified interval.
 *
 * <p>
 * The returned list will contain one or more {@link UsageStats} objects for each package, with
 * usage data that covers at least the given time range.
 * Note: The begin and end times of the time range may be expanded to the nearest whole interval
 * period.
 * </p>
 *
 * <p> The caller must have {@link android.Manifest.permission#PACKAGE_USAGE_STATS} </p>
 * <em>Note: Starting from {@link android.os.Build.VERSION_CODES#R Android R}, if the user's
 * device is not in an unlocked state (as defined by {@link UserManager#isUserUnlocked()}),
 * then {@code null} will be returned.</em>
 *
 * @param intervalType The time interval by which the stats are aggregated.
 * @param beginTime The inclusive beginning of the range of stats to include in the results.
 * Defined in terms of ""Unix time"", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime The exclusive end of the range of stats to include in the results. Defined
 * in terms of ""Unix time"", see {@link java.lang.System#currentTimeMillis}.
 * @return A list of {@link UsageStats}
 *
 * @see #INTERVAL_DAILY
 * @see #INTERVAL_WEEKLY
 * @see #INTERVAL_MONTHLY
 * @see #INTERVAL_YEARLY
 * @see #INTERVAL_BEST
 */
",-1,,[@UserHandleAware],-1,-1,-1,-1,-1,-1,5,0,"The dependent API call mService.queryUsageStats() now includes an additional parameter mContext.getUserId() in the late version. Therefore, the change type is 5.","Despite the dependent API call having an additional parameter, the overall behavior of queryUsageStats remains unchanged: it still returns a list of UsageStats or an empty list. Adding a parameter for user context does not inherently alter the return type or exception handling. Therefore, there is no compatibility issue, and CI type is 0."
787,<android.app.PictureInPictureParams.Builder: PictureInPictureParams build()>,30,31,<android.app.PictureInPictureParams.Builder: PictureInPictureParams build()>,<android.app.PictureInPictureParams.Builder: PictureInPictureParams build()>,0,"{
    PictureInPictureParams params = new PictureInPictureParams(mAspectRatio, mUserActions, mSourceRectHint);
    return params;
}","{
    PictureInPictureParams params = new PictureInPictureParams(mAspectRatio, mUserActions, mSourceRectHint, mAutoEnterEnabled, mSeamlessResizeEnabled);
    return params;
}",1,"/**
 * @return an immutable {@link PictureInPictureParams} to be used when entering or updating
 * the activity in picture-in-picture.
 *
 * @see Activity#enterPictureInPictureMode(PictureInPictureParams)
 * @see Activity#setPictureInPictureParams(PictureInPictureParams)
 */
","/**
 * @return an immutable {@link PictureInPictureParams} to be used when entering or updating
 * the activity in picture-in-picture.
 *
 * @see Activity#enterPictureInPictureMode(PictureInPictureParams)
 * @see Activity#setPictureInPictureParams(PictureInPictureParams)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The constructor of PictureInPictureParams has new parameters added (mAutoEnterEnabled, mSeamlessResizeEnabled), so the dependent API constructor of PictureInPictureParams has changed, hence the code change type is 5.","Even though the constructor of PictureInPictureParams has additional parameters in the late version, this change will not cause a compatibility issue because the method signature of `build()` hasn't changed, and it does not affect how the method behaves from the caller's perspective. The `build()` method still returns an instance of `PictureInPictureParams`, and the construction of this object is internal to the method. The addition of fields to the `PictureInPictureParams` class does not inherently constitute a compatibility issue unless those new fields require new input from the caller or change the behavior of existing methods. Therefore, assuming that there is no requirement for new input from the API user and no change to existing behavior, there is no compatibility issue in this case."
788,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,30,31,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (mWindowContextToken == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        mWindowContextToken = o.mWindowContextToken;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (preferredMinDisplayRefreshRate != o.preferredMinDisplayRefreshRate) {
        preferredMinDisplayRefreshRate = o.preferredMinDisplayRefreshRate;
        changes |= PREFERRED_MIN_DISPLAY_REFRESH_RATE;
    }
    if (preferredMaxDisplayRefreshRate != o.preferredMaxDisplayRefreshRate) {
        preferredMaxDisplayRefreshRate = o.preferredMaxDisplayRefreshRate;
        changes |= PREFERRED_MAX_DISPLAY_REFRESH_RATE;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (receiveInsetsIgnoringZOrder != o.receiveInsetsIgnoringZOrder) {
        receiveInsetsIgnoringZOrder = o.receiveInsetsIgnoringZOrder;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    if (mBlurBehindRadius != o.mBlurBehindRadius) {
        mBlurBehindRadius = o.mBlurBehindRadius;
        changes |= BLUR_BEHIND_RADIUS_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
790,<android.view.VerifiedMotionEvent: int hashCode()>,30,31,<android.view.VerifiedMotionEvent: int hashCode()>,<android.view.VerifiedMotionEvent: int hashCode()>,0,"{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + getDeviceId();
    _hash = 31 * _hash + Long.hashCode(getEventTimeNanos());
    _hash = 31 * _hash + getSource();
    _hash = 31 * _hash + getDisplayId();
    _hash = 31 * _hash + Float.hashCode(mRawX);
    _hash = 31 * _hash + Float.hashCode(mRawY);
    _hash = 31 * _hash + mActionMasked;
    _hash = 31 * _hash + Long.hashCode(mDownTimeNanos);
    _hash = 31 * _hash + mFlags;
    _hash = 31 * _hash + mMetaState;
    _hash = 31 * _hash + mButtonState;
    return _hash;
}","{
    // You can override field hashCode logic by defining methods like:
    // int fieldNameHashCode() { ... }
    int _hash = 1;
    _hash = 31 * _hash + super.hashCode();
    _hash = 31 * _hash + Float.hashCode(mRawX);
    _hash = 31 * _hash + Float.hashCode(mRawY);
    _hash = 31 * _hash + mActionMasked;
    _hash = 31 * _hash + Long.hashCode(mDownTimeNanos);
    _hash = 31 * _hash + mFlags;
    _hash = 31 * _hash + mMetaState;
    _hash = 31 * _hash + mButtonState;
    return _hash;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The calculation of the hash value (_hash) has been changed by removing several lines of calculation and by introducing a call to super.hashCode() in the late implementation, which represents both a return statement change and an other statement change. Therefore, the code change type is 1,4.","The modification in the way the hash value is computed will result in a different value being returned by the hashCode() method between the two versions, meaning a potential Compatibility Issue of type 1 arises due to the different return value."
791,<android.app.UiAutomation: boolean setRotation(int)>,30,31,<android.app.UiAutomation: boolean setRotation(int)>,<android.app.UiAutomation: boolean setRotation(int)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    switch(rotation) {
        case ROTATION_FREEZE_0:
        case ROTATION_FREEZE_90:
        case ROTATION_FREEZE_180:
        case ROTATION_FREEZE_270:
        case ROTATION_UNFREEZE:
        case ROTATION_FREEZE_CURRENT:
            {
                try {
                    // Calling out without a lock held.
                    mUiAutomationConnection.setRotation(rotation);
                    return true;
                } catch (RemoteException re) {
                    Log.e(LOG_TAG, ""Error while setting rotation!"", re);
                }
            }
            return false;
        default:
            {
                throw new IllegalArgumentException(""Invalid rotation."");
            }
    }
}","{
    switch(rotation) {
        case ROTATION_FREEZE_0:
        case ROTATION_FREEZE_90:
        case ROTATION_FREEZE_180:
        case ROTATION_FREEZE_270:
        case ROTATION_UNFREEZE:
        case ROTATION_FREEZE_CURRENT:
            {
                try {
                    // Calling out without a lock held.
                    mUiAutomationConnection.setRotation(rotation);
                    return true;
                } catch (RemoteException re) {
                    Log.e(LOG_TAG, ""Error while setting rotation!"", re);
                }
            }
            return false;
        default:
            {
                throw new IllegalArgumentException(""Invalid rotation."");
            }
    }
}",1,"/**
 * Sets the device rotation. A client can freeze the rotation in
 * desired state or freeze the rotation to its current state or
 * unfreeze the rotation (rotating the device changes its rotation
 * state).
 *
 * @param rotation The desired rotation.
 * @return Whether the rotation was set successfully.
 *
 * @see #ROTATION_FREEZE_0
 * @see #ROTATION_FREEZE_90
 * @see #ROTATION_FREEZE_180
 * @see #ROTATION_FREEZE_270
 * @see #ROTATION_FREEZE_CURRENT
 * @see #ROTATION_UNFREEZE
 */
","/**
 * Sets the device rotation. A client can freeze the rotation in
 * desired state or freeze the rotation to its current state or
 * unfreeze the rotation (rotating the device changes its rotation
 * state).
 *
 * @param rotation The desired rotation.
 * @return Whether the rotation was set successfully.
 *
 * @see #ROTATION_FREEZE_0
 * @see #ROTATION_FREEZE_90
 * @see #ROTATION_FREEZE_180
 * @see #ROTATION_FREEZE_270
 * @see #ROTATION_FREEZE_CURRENT
 * @see #ROTATION_UNFREEZE
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The control dependency change here involves the removal of a synchronized block around throwIfNotConnectedLocked().,"Even though there's a control dependency change, there's no indication that this will affect the return value or exception handling of the API. The code within the switch statement that dictates the API behavior remains unchanged. Therefore, based on the information provided and the change observed, there does not seem to be a Compatibility Issue related to return value or exceptions."
792,<android.ddm.DdmHandleHello: Chunk handleChunk(Chunk)>,30,31,<android.ddm.DdmHandleHello: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleHello: Chunk handleChunk(Chunk)>,0,"{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no actual code change. The only difference is the removal of ChunkHandler before the name() method which doesn't affect functionality because name() is used correctly according to the context (most likely due to an import statement that allows this method to be accessed directly in the later version).,There is no compatibility issue as there is no change in behavior between the early and late implementation.
793,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setConfirmationRequired(boolean)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setConfirmationRequired(boolean)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setConfirmationRequired(boolean)>,0,"{
    mBundle.putBoolean(KEY_REQUIRE_CONFIRMATION, requireConfirmation);
    return this;
}","{
    mPromptInfo.setConfirmationRequested(requireConfirmation);
    return this;
}",1,"/**
 * Optional: Sets a hint to the system for whether to require user confirmation after
 * authentication. For example, implicit modalities like face and iris are passive, meaning
 * they don't require an explicit user action to complete authentication. If set to true,
 * these modalities should require the user to take some action (e.g. press a button)
 * before {@link AuthenticationCallback#onAuthenticationSucceeded(AuthenticationResult)} is
 * called. Defaults to true.
 *
 * <p>A typical use case for not requiring confirmation would be for low-risk transactions,
 * such as re-authenticating a recently authenticated application. A typical use case for
 * requiring confirmation would be for authorizing a purchase.
 *
 * <p>Note that this just passes a hint to the system, which the system may then ignore. For
 * example, a value of false may be ignored if the user has disabled implicit authentication
 * in Settings, or if it does not apply to a particular modality (e.g. fingerprint).
 *
 * @param requireConfirmation true if explicit user confirmation should be required, or
 * false otherwise.
 * @return This builder.
 */
","/**
 * Optional: Sets a hint to the system for whether to require user confirmation after
 * authentication. For example, implicit modalities like face and iris are passive, meaning
 * they don't require an explicit user action to complete authentication. If set to true,
 * these modalities should require the user to take some action (e.g. press a button)
 * before {@link AuthenticationCallback#onAuthenticationSucceeded(AuthenticationResult)} is
 * called. Defaults to true.
 *
 * <p>A typical use case for not requiring confirmation would be for low-risk transactions,
 * such as re-authenticating a recently authenticated application. A typical use case for
 * requiring confirmation would be for authorizing a purchase.
 *
 * <p>Note that this just passes a hint to the system, which the system may then ignore. For
 * example, a value of false may be ignored if the user has disabled implicit authentication
 * in Settings, or if it does not apply to a particular modality (e.g. fingerprint).
 *
 * @param requireConfirmation true if explicit user confirmation should be required, or
 * false otherwise.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The method invoked on the object has changed: the early version uses `mBundle.putBoolean` while the late version uses `mPromptInfo.setConfirmationRequested`. This is a change in a dependent API, so the change type is 5.","The compatibility issue does not arise due to this change because both versions essentially aim to set whether confirmation is required or not, and they are both chained method calls returning `this` which is the instance of the builder. Assuming `mPromptInfo.setConfirmationRequested` is an internal change that keeps the semantic meaning intact with just an internal refactoring, there shouldn't be a behavioral change from an API consumer's standpoint. Thus, there is no CI."
794,"<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>",30,31,"<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>","<android.bluetooth.BluetoothGattServer: boolean sendResponse(BluetoothDevice,int,int,int,byte[])>",0,"{
    if (VDBG)
        Log.d(TAG, ""sendResponse() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""sendResponse() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */
","/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API call 'mService.sendResponse' has received an additional parameter 'mAttributionSource' in the late version. In terms of annotations, new permissions are added in the late version. Therefore, the code change type is 4,5.","These changes do not alter the control flow or the output value of the API, and the exception handling remains the same. Although the dependent API 'mService.sendResponse' has an extra parameter, this does not inherently result in a Compatibility Issue, as it is an internal change that should be handled by the 'BluetoothGattServer' class. The added permissions annotations do not change the behavior of the API as such; they simply specify the necessary permissions to be granted by the application using the API. Therefore, there is no Compatibility Issue detected."
795,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",30,31,"<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>","<android.view.inputmethod.InputMethodManager: void displayCompletions(View,CompletionInfo[])>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.displayCompletions(view, completions);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        mCompletions = completions;
        if (mCurMethod != null) {
            try {
                mCurMethod.displayCompletions(mCompletions);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.displayCompletions(view, completions);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view)) {
            return;
        }
        mCompletions = completions;
        if (mCurrentInputMethodSession != null) {
            mCurrentInputMethodSession.displayCompletions(mCompletions);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed from calling mCurMethod.displayCompletions(mCompletions) to mCurrentInputMethodSession.displayCompletions(mCompletions). This is a change in the dependent API, so the code change type is 1,5.","The change from mCurMethod to mCurrentInputMethodSession changes the object through which the method is called, potentially altering the behavior and causing a different outcome to be produced. Therefore, this change could lead to a different return in behavior, so the CI type is 1."
796,<android.bluetooth.BluetoothDevice: int getType()>,30,31,<android.bluetooth.BluetoothDevice: int getType()>,<android.bluetooth.BluetoothDevice: int getType()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device type"");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device type"");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}",1,"/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link
 * #DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */
","/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link
 * #DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API getRemoteType(this) has been altered to getRemoteType(this, mAttributionSource) with an extra parameter, indicating a change in the Dependent API, which corresponds to code change type 5. Additionally, there is a change in the annotations, which corresponds to code change type 4. However, this annotation change pertains to permissions and does not directly affect the runtime behavior of the method itself.","There is no Compatibility Issue caused by potential different return values or exceptions because the logic of the method and its exceptions handling did not change. The change in Dependent API does not modify the behavior of how the method handles return values or exceptions. Therefore, the code will not lead to different return values or exception handlings in the changed context."
797,<android.app.LoadedApk.SplitDependencyLoaderImpl: String[] getSplitPathsForSplit(String)>,30,31,<android.app.LoadedApk.SplitDependencyLoaderImpl: String[] getSplitPathsForSplit(String)>,<android.app.LoadedApk.SplitDependencyLoaderImpl: String[] getSplitPathsForSplit(String)>,0,"{
    return mCachedResourcePaths[ensureSplitLoaded(splitName)];
}","{
    final int idx = ensureSplitLoaded(splitName);
    synchronized (mLock) {
        return mCachedResourcePaths[idx];
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new synchronization block with `synchronized (mLock) { ... }` has been added around the return statement. This is a control dependency change because a new synchronization construct has been introduced, so the code change type is 3. Additionally, the read access to `mCachedResourcePaths[idx]` has been moved inside the synchronization block, which is an other statement changed, resulting in code change type 4.","In terms of the API's external behavior, the additional synchronization does not affect the value returned by `getSplitPathsForSplit`. It only ensures thread-safe access to `mCachedResourcePaths`. Therefore, there is no Compatibility Issue as it doesn't lead to a different return value or type nor a different exception handling, so the CI type is 0."
798,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: boolean equals(Object)>,30,31,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: boolean equals(Object)>,<android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation: boolean equals(Object)>,0,"{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof MandatoryStreamInformation) {
        final MandatoryStreamInformation other = (MandatoryStreamInformation) obj;
        if ((mFormat != other.mFormat) || (mIsInput != other.mIsInput) || (mAvailableSizes.size() != other.mAvailableSizes.size())) {
            return false;
        }
        return mAvailableSizes.equals(other.mAvailableSizes);
    }
    return false;
}","{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof MandatoryStreamInformation) {
        final MandatoryStreamInformation other = (MandatoryStreamInformation) obj;
        if ((mFormat != other.mFormat) || (mIsInput != other.mIsInput) || (mIsUltraHighResolution != other.mIsUltraHighResolution) || (mAvailableSizes.size() != other.mAvailableSizes.size())) {
            return false;
        }
        return mAvailableSizes.equals(other.mAvailableSizes);
    }
    return false;
}",1,"/**
 * Check if this {@link MandatoryStreamInformation} is equal to another
 * {@link MandatoryStreamInformation}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is
 * equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
","/**
 * Check if this {@link MandatoryStreamInformation} is equal to another
 * {@link MandatoryStreamInformation}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is
 * equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There is an additional condition `(mIsUltraHighResolution != other.mIsUltraHighResolution)` in the `if` statement, which is neither a return statement change, exception handling change, nor a control dependency change, so the code change type is 4.","Because of the added condition `(mIsUltraHighResolution != other.mIsUltraHighResolution)` in the comparison, this change potentially leads the method to return different comparison results (`true` or `false`), hence the CI type is 1."
799,<android.app.Activity: void performPause()>,30,31,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    dispatchActivityPrePaused();
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    EventLogTags.writeWmOnPausedCalled(mIdent, getComponentName().getClassName(), ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    dispatchActivityPostPaused();
}","{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_WINDOW_MANAGER)) {
        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, ""performPause:"" + mComponent.getClassName());
    }
    dispatchActivityPrePaused();
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    EventLogTags.writeWmOnPausedCalled(mIdent, getComponentName().getClassName(), ""performPause"");
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    dispatchActivityPostPaused();
    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new code added is related to the tracing functionality using Trace.isTagEnabled() and Trace.traceBegin()/Trace.traceEnd(). These changes do not affect the return value, exception handling, or control flow of the API; thus, the code change type is 4, which falls under 'Other statement changed'.","There are no differences in the behavior regarding return values, exception handling, or control flow of the method. The tracing functionality is meant for debugging or logging and doesn't impact the existing functionality of the method. Therefore, the CI type is 0, meaning no Compatibility Issue."
801,"<android.content.ContentResolver: Uri insert(Uri,ContentValues,Bundle)>",30,31,"<android.content.ContentResolver: Uri insert(Uri,ContentValues,Bundle)>","<android.content.ContentResolver: Uri insert(Uri,ContentValues,Bundle)>",0,"{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.insert(url, values, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, mAttributionTag, url, values, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.insert(url, values, extras);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URL "" + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mContext.getAttributionSource(), url, values, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, ""insert"", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return the URL of the newly created row. May return <code>null</code> if the underlying
 * content provider returns <code>null</code>, or if it crashes.
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
","/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return the URL of the newly created row. May return <code>null</code> if the underlying
 * content provider returns <code>null</code>, or if it crashes.
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The only change here is the parameter inside the provider.insert() method call, where mPackageName, mAttributionTag is replaced with mContext.getAttributionSource(). Hence, the change type is 5.","There is no Compatibility Issue indicated by the changes in the code, as the API still handles exceptions similarly and returns results based on the database operation outcome. The change in the dependent API (the argument passed to provider.insert()) does not directly affect the return type or value, nor the exception handling of the current API. So, the CI type is 0."
802,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,30,31,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The method mService.readDescriptor() has an additional parameter, mAttributionSource, in the implementation but there is no change in the method signature or the way the method outputs the result, so the code change type is 5.","There is no Compatibility Issue with the return value or exception handling of the API as a result of the addition of the mAttributionSource parameter to the mService.readDescriptor() method, so the CI type is 0. The calling sequence and expected results for users of the readDescriptor method remain the same, even though it now includes an additional internal parameter for attribution."
803,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,30,31,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,<android.app.admin.DevicePolicyManager: List<String> getPermittedInputMethods(ComponentName)>,0,"{
    throwIfParentInstance(""getPermittedInputMethods"");
    if (mService != null) {
        try {
            return mService.getPermittedInputMethods(admin);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}","{
    if (mService != null) {
        try {
            return mService.getPermittedInputMethods(admin, mParentInstance);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return null;
}",1,"/**
 * Returns the list of permitted input methods set by this device or profile owner.
 * <p>
 * An empty list means no input methods except system input methods are allowed. Null means all
 * input methods are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of input method package names.
 * @throws SecurityException if {@code admin} is not a device or profile owner.
 */
","/**
 * Returns the list of permitted input methods set by this device or profile owner.
 * <p>
 * This method can be called on the {@link DevicePolicyManager} instance,
 * returned by {@link #getParentProfileInstance(ComponentName)}, where the caller must be
 * a profile owner of an organization-owned managed profile. If called on the parent instance,
 * then the returned list of permitted input methods are those which are applied on the
 * personal profile.
 * <p>
 * An empty list means no input methods except system input methods are allowed. Null means all
 * input methods are allowed.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @return List of input method package names.
 * @throws SecurityException if {@code admin} is not a device, profile owner or if called on
 * the parent profile and the {@code admin} is not a profile owner
 * of an organization-owned managed profile.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The method throwIfParentInstance(""getPermittedInputMethods"") was removed, and the parameter list of the call to mService.getPermittedInputMethods has been expanded to include mParentInstance, so the code change type is 4 for the method call (not the control dependency or return statement) and 5 because it's a change in the call to a dependent API.","Despite the changes, the behavior of the method remains consistent with the previous version. The method still attempts to return the result of mService.getPermittedInputMethods and will throw an exception or return null for the same conditions as it previously did. No new return or exception paths have been added, and no control dependencies have been altered to change the method's behavior. Therefore, no Compatibility Issue is detected in this case."
804,"<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>",30,31,"<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>","<android.text.format.DateFormat: String getBestDateTimePattern(Locale,String)>",0,"{
    return ICU.getBestDateTimePattern(skeleton, locale);
}","{
    DateTimePatternGenerator dtpg = DateTimePatternGenerator.getInstance(locale);
    boolean allowDuplicateFields = !CompatChanges.isChangeEnabled(DISALLOW_DUPLICATE_FIELD_IN_SKELETON);
    return dtpg.getBestPattern(skeleton, DateTimePatternGenerator.MATCH_NO_OPTIONS, allowDuplicateFields);
}",1,"/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href=""http://www.unicode.org/reports/tr35/#Date_Format_Patterns"">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, ""MMMMd"" will return
 * ""MMMM d"" in the {@code en_US} locale, but ""d. MMMM"" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * ""d 'de' MMMM"".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same ""MMMMd"" input, this method will return ""d LLLL"" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so ""Md"" would give a different result to ""MMMd"", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */
","/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href=""http://www.unicode.org/reports/tr35/#Date_Format_Patterns"">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, ""MMMMd"" will return
 * ""MMMM d"" in the {@code en_US} locale, but ""d. MMMM"" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * ""d 'de' MMMM"".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same ""MMMMd"" input, this method will return ""d LLLL"" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so ""Md"" would give a different result to ""MMMd"", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"There is a change in the method implementation where it no longer directly calls ICU.getBestDateTimePattern but instead uses an instance of DateTimePatternGenerator and a new method getBestPattern that considers additional parameters (flags and a flag related to duplicate fields in the pattern skeleton). It introduces a new dependent API change DateTimePatternGenerator.getInstance and DateTimePatternGenerator.getBestPattern, and a control dependency based on the result of CompatChanges.isChangeEnabled, thus the code change type is 3,5.","The addition of conditional logic based on the CompatChanges.isChangeEnabled method and the use of different parameters when getting the best pattern can lead to a different return value from this method, thus the CI type is 1."
805,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",30,31,"<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>","<android.bluetooth.BluetoothHidDevice: boolean reportError(BluetoothDevice,byte)>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.reportError(device, error, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends error handshake message as reply for invalid SET_REPORT request from {@link
 * Callback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method `service.reportError` is now called with an extra argument `mAttributionSource` in the late version, which is a change in the dependent API parameters (5). Additionally, there are new annotations added indicating required permissions (4), which could change the preconditions for using the method. The boolean `result` assignment has changed due to a different method signature being used in the implementation, which suggests a potential change in the returned value (1).","The change in the dependent API potentially leads to a different return value because the method now includes an additional parameter, which might alter the behavior of how errors are reported. There's also a potential permissions enforcement that wasn't present in the early version, which could lead to different handling of permissions and potentially cause the method to fail or behave differently under certain security contexts (1)."
807,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",30,31,"<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>","<android.provider.Settings.NameValueCache: String getStringForUser(ContentResolver,String,int)>",0,"{
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                                currentGeneration = generation;
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getPackageName(), cr.getAttributionTag(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getPackageName(), cr.getAttributionTag(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}","{
    // still be regarded as readable.
    if (!isCallerExemptFromReadableRestriction() && mAllFields.contains(name)) {
        if (!mReadableFields.contains(name)) {
            throw new SecurityException(""Settings key: <"" + name + ""> is not readable. From S+, settings keys "" + ""annotated with @hide are restricted to system_server and "" + ""system apps only, unless they are annotated with @Readable."");
        } else {
            // target sdk is higher than the maxTargetSdk of the annotation, reject access.
            if (mReadableFieldsWithMaxTargetSdk.containsKey(name)) {
                final int maxTargetSdk = mReadableFieldsWithMaxTargetSdk.get(name);
                final Application application = ActivityThread.currentApplication();
                final boolean targetSdkCheckOk = application != null && application.getApplicationInfo() != null && application.getApplicationInfo().targetSdkVersion <= maxTargetSdk;
                if (!targetSdkCheckOk) {
                    throw new SecurityException(""Settings key: <"" + name + ""> is only readable to apps with "" + ""targetSdkVersion lower than or equal to: "" + maxTargetSdk);
                }
            }
        }
    }
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    int currentGeneration = -1;
    if (isSelf) {
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null) {
                if (mGenerationTracker.isGenerationChanged()) {
                    if (DEBUG) {
                        Log.i(TAG, ""Generation changed for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                    mValues.clear();
                } else if (mValues.containsKey(name)) {
                    return mValues.get(name);
                }
                if (mGenerationTracker != null) {
                    currentGeneration = mGenerationTracker.getCurrentGeneration();
                }
            }
        }
    } else {
        if (LOCAL_LOGV)
            Log.v(TAG, ""get setting for user "" + userHandle + "" by user "" + UserHandle.myUserId() + "" so skipping cache"");
    }
    IContentProvider cp = mProviderHolder.getProvider(cr);
    // interface.
    if (mCallGetCommand != null) {
        try {
            Bundle args = null;
            if (!isSelf) {
                args = new Bundle();
                args.putInt(CALL_METHOD_USER_KEY, userHandle);
            }
            boolean needsGenerationTracker = false;
            synchronized (NameValueCache.this) {
                if (isSelf && mGenerationTracker == null) {
                    needsGenerationTracker = true;
                    if (args == null) {
                        args = new Bundle();
                    }
                    args.putString(CALL_METHOD_TRACK_GENERATION_KEY, null);
                    if (DEBUG) {
                        Log.i(TAG, ""Requested generation tracker for type: "" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle);
                    }
                }
            }
            Bundle b;
            // clearCallingIdentity or use a ContentResolver from the caller as needed.
            if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
                final long token = Binder.clearCallingIdentity();
                try {
                    b = cp.call(cr.getAttributionSource(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
                } finally {
                    Binder.restoreCallingIdentity(token);
                }
            } else {
                b = cp.call(cr.getAttributionSource(), mProviderHolder.mUri.getAuthority(), mCallGetCommand, name, args);
            }
            if (b != null) {
                String value = b.getString(Settings.NameValueTable.VALUE);
                // Don't update our cache for reads of other users' data
                if (isSelf) {
                    synchronized (NameValueCache.this) {
                        if (needsGenerationTracker) {
                            MemoryIntArray array = b.getParcelable(CALL_METHOD_TRACK_GENERATION_KEY);
                            final int index = b.getInt(CALL_METHOD_GENERATION_INDEX_KEY, -1);
                            if (array != null && index >= 0) {
                                final int generation = b.getInt(CALL_METHOD_GENERATION_KEY, 0);
                                if (DEBUG) {
                                    Log.i(TAG, ""Received generation tracker for type:"" + mUri.getPath() + "" in package:"" + cr.getPackageName() + "" and user:"" + userHandle + "" with index:"" + index);
                                }
                                if (mGenerationTracker != null) {
                                    mGenerationTracker.destroy();
                                }
                                mGenerationTracker = new GenerationTracker(array, index, generation, () -> {
                                    synchronized (NameValueCache.this) {
                                        Log.e(TAG, ""Error accessing generation"" + "" tracker - removing"");
                                        if (mGenerationTracker != null) {
                                            GenerationTracker generationTracker = mGenerationTracker;
                                            mGenerationTracker = null;
                                            generationTracker.destroy();
                                            mValues.clear();
                                        }
                                    }
                                });
                                currentGeneration = generation;
                            }
                        }
                        if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                            mValues.put(name, value);
                        }
                    }
                } else {
                    if (LOCAL_LOGV)
                        Log.i(TAG, ""call-query of user "" + userHandle + "" by "" + UserHandle.myUserId() + "" so not updating cache"");
                }
                return value;
            }
        // If the response Bundle is null, we fall through
        // to the query interface below.
        } catch (RemoteException e) {
        // Not supported by the remote side?  Fall through
        // to query().
        }
    }
    Cursor c = null;
    try {
        Bundle queryArgs = ContentResolver.createSqlQueryBundle(NAME_EQ_PLACEHOLDER, new String[] { name }, null);
        // Same workaround as above.
        if (Settings.isInSystemServer() && Binder.getCallingUid() != Process.myUid()) {
            final long token = Binder.clearCallingIdentity();
            try {
                c = cp.query(cr.getAttributionSource(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            c = cp.query(cr.getAttributionSource(), mUri, SELECT_VALUE_PROJECTION, queryArgs, null);
        }
        if (c == null) {
            Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri);
            return null;
        }
        String value = c.moveToNext() ? c.getString(0) : null;
        synchronized (NameValueCache.this) {
            if (mGenerationTracker != null && currentGeneration == mGenerationTracker.getCurrentGeneration()) {
                mValues.put(name, value);
            }
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, ""cache miss ["" + mUri.getLastPathSegment() + ""]: "" + name + "" = "" + (value == null ? ""(null)"" : value));
        }
        return value;
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't get key "" + name + "" from "" + mUri, e);
        // Return null, but don't cache it.
        return null;
    } finally {
        if (c != null)
            c.close();
    }
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,,,,
808,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",30,31,"<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGattServer: boolean notifyCharacteristicChanged(BluetoothDevice,BluetoothGattCharacteristic,boolean)>",0,"{
    if (VDBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException(""Chracteristic value is empty. Use "" + ""BluetoothGattCharacteristic#setvalue to update"");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), characteristic.getInstanceId(), confirm, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""notifyCharacteristicChanged() - device: "" + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    if (characteristic.getValue() == null) {
        throw new IllegalArgumentException(""Chracteristic value is empty. Use "" + ""BluetoothGattCharacteristic#setvalue to update"");
    }
    try {
        mService.sendNotification(mServerIf, device.getAddress(), characteristic.getInstanceId(), confirm, characteristic.getValue(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication), false to send a
 * notification
 * @return true, if the notification has been triggered successfully
 * @throws IllegalArgumentException
 */
","/**
 * Send a notification or indication that a local characteristic has been
 * updated.
 *
 * <p>A notification or indication is sent to the remote device to signal
 * that the characteristic has been updated. This function should be invoked
 * for every client that requests notifications/indications by writing
 * to the ""Client Configuration"" descriptor for the given characteristic.
 *
 * @param device The remote device to receive the notification/indication
 * @param characteristic The local characteristic that has been updated
 * @param confirm true to request confirmation from the client (indication), false to send a
 * notification
 * @return true, if the notification has been triggered successfully
 * @throws IllegalArgumentException
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the implementation is related to adding an additional parameter (mAttributionSource) to the method call mService.sendNotification(), therefore, the code change type is 4 (Other statement changed), and 5 (Dependent API changed).","There is no change to the exception thrown or the values returned by the method; the behavior of the method from the caller's perspective remains unchanged. The addition of an extra parameter to a method call within the implementation doesn't affect the callers of notifyCharacteristicChanged directly because the method signature for notifyCharacteristicChanged remains the same and there is no evidence that the behavior of sendNotification would change in a way that alters how notifyCharacteristicChanged behaves. Therefore, there is no compatibility issue; the CI type is 0."
811,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",30,31,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mWinFrame, mContentInsets, mStableInsets, mDisplayCutout, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrame, mContentInsets, mVisibleInsets, mStableInsets, mBackdropFrame, mDisplayCutout, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize, mTmpSurfaceControl);
            if (mSurfaceControl.isValid()) {
                mSurfaceHolder.mSurface.copyFrom(mSurfaceControl);
                mSurfaceControl.release();
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            int h = mWinFrame.height();
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                mContentInsets.left += padding.left;
                mContentInsets.top += padding.top;
                mContentInsets.right += padding.right;
                mContentInsets.bottom += padding.bottom;
                mStableInsets.left += padding.left;
                mStableInsets.top += padding.top;
                mStableInsets.right += padding.right;
                mStableInsets.bottom += padding.bottom;
                mDisplayCutout.set(mDisplayCutout.get().inset(-padding.left, -padding.top, -padding.right, -padding.bottom));
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            insetsChanged |= !mDispatchedContentInsets.equals(mContentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(mStableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(mDisplayCutout.get());
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(mContentInsets);
                    mDispatchedStableInsets.set(mStableInsets);
                    mDispatchedDisplayCutout = mDisplayCutout.get();
                    mFinalStableInsets.set(mDispatchedStableInsets);
                    WindowInsets insets = new WindowInsets(mFinalSystemInsets, mFinalStableInsets, getResources().getConfiguration().isScreenRound(), false, mDispatchedDisplayCutout);
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + insets);
                    }
                    onApplyWindowInsets(insets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow, null);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mInsetsState, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrames, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize);
            if (mSurfaceControl.isValid()) {
                if (mBbqSurfaceControl == null) {
                    mBbqSurfaceControl = new SurfaceControl.Builder().setName(""Wallpaper BBQ wrapper"").setHidden(false).setMetadata(METADATA_WINDOW_TYPE, TYPE_WALLPAPER).setBLASTLayer().setParent(mSurfaceControl).setCallsite(""Wallpaper#relayout"").build();
                    updateSurfaceDimming();
                }
                // Propagate transform hint from WM so we can use the right hint for the
                // first frame.
                mBbqSurfaceControl.setTransformHint(mSurfaceControl.getTransformHint());
                Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x, mSurfaceSize.y, mFormat);
                // would then inc the generation ID and cause EGL resources to be recreated.
                if (blastSurface != null) {
                    mSurfaceHolder.mSurface.transferFrom(blastSurface);
                }
            }
            if (!mLastSurfaceSize.equals(mSurfaceSize)) {
                mLastSurfaceSize.set(mSurfaceSize.x, mSurfaceSize.y);
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrames);
            int w = mWinFrames.frame.width();
            int h = mWinFrames.frame.height();
            final DisplayCutout rawCutout = mInsetsState.getDisplayCutout();
            final Configuration config = getResources().getConfiguration();
            final Rect visibleFrame = new Rect(mWinFrames.frame);
            visibleFrame.intersect(mInsetsState.getDisplayFrame());
            WindowInsets windowInsets = mInsetsState.calculateInsets(visibleFrame, null, /* ignoringVisibilityState */
            config.isScreenRound(), false, /* alwaysConsumeSystemBars */
            mLayout.softInputMode, mLayout.flags, SYSTEM_UI_FLAG_VISIBLE, mLayout.type, config.windowConfiguration.getWindowingMode(), null);
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                windowInsets = windowInsets.insetUnchecked(-padding.left, -padding.top, -padding.right, -padding.bottom);
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            final Rect contentInsets = windowInsets.getSystemWindowInsets().toRect();
            final Rect stableInsets = windowInsets.getStableInsets().toRect();
            final DisplayCutout displayCutout = windowInsets.getDisplayCutout() != null ? windowInsets.getDisplayCutout() : rawCutout;
            insetsChanged |= !mDispatchedContentInsets.equals(contentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(stableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(displayCutout);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(contentInsets);
                    mDispatchedStableInsets.set(stableInsets);
                    mDispatchedDisplayCutout = displayCutout;
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + windowInsets);
                    }
                    onApplyWindowInsets(windowInsets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    resetWindowPages();
                    mSession.finishDrawing(mWindow, null);
                    processLocalColors(mPendingXOffset, mPendingXOffsetStep);
                }
                reposition();
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
812,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,30,31,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setName(name, mAttributionSource);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @param name a valid Bluetooth name
 * @return true if the name was set, false otherwise
 */
","/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @param name a valid Bluetooth name
 * @return true if the name was set, false otherwise
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,1,"The dependent API called within this method, mService.setName(), has been changed with an additional parameter, mAttributionSource, being passed to it in the late version. This change classifies as a Dependent API changed (5).","The addition of the parameter mAttributionSource in the late version changes the dependent method's signature which can lead to a different behavior and potential incompatibility issues when updating from the early version to the late version. The calling code might not provide this additional parameter, potentially causing a Compatibility Issue due to different return values or types (CI type 1)."
813,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,30,31,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0 && !isMouseEvent;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessibility focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);
                    final float y = isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildTouchDispatchChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
                        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
814,<android.bluetooth.BluetoothGattServer: void readPhy(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothGattServer: void readPhy(BluetoothDevice)>,<android.bluetooth.BluetoothGattServer: void readPhy(BluetoothDevice)>,0,"{
    try {
        mService.serverReadPhy(mServerIf, device.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    try {
        mService.serverReadPhy(mServerIf, device.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattServerCallback#onPhyRead}
 *
 * @param device The remote device to send this response to
 */
","/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattServerCallback#onPhyRead}
 *
 * @param device The remote device to send this response to
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mService.serverReadPhy` method call has changed to include a new parameter `mAttributionSource`, so the code change type is 5.","There is no Compatibility Issue since the method signature remains unchanged and the change pertains to internal implementation detail (additional parameter in the method call) which doesn't affect the behavior of the method as exposed to the caller. The method signature for `readPhy` and its exception handling remain the same, hence no CI."
815,<android.app.Activity: boolean moveTaskToBack(boolean)>,30,31,<android.app.Activity: boolean moveTaskToBack(boolean)>,<android.app.Activity: boolean moveTaskToBack(boolean)>,0,"{
    try {
        return ActivityTaskManager.getService().moveActivityTaskToBack(mToken, nonRoot);
    } catch (RemoteException e) {
    // Empty
    }
    return false;
}","{
    return ActivityClient.getInstance().moveActivityTaskToBack(mToken, nonRoot);
}",1,"/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
","/**
 * Move the task containing this activity to the back of the activity
 * stack.  The activity's order within the task is unchanged.
 *
 * @param nonRoot If false then this only works if the activity is the root
 * of a task; if true it will work for any activity in
 * a task.
 *
 * @return If the task was moved (or it was already at the
 * back) true is returned, else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The exception handling has been removed and it is now using a different method (ActivityClient.getInstance().moveActivityTaskToBack instead of ActivityTaskManager.getService().moveActivityTaskToBack). Hence, the code change type is 2,5.","The removal of the try-catch block could lead to different exception handling behavior, and any exceptions thrown by the new method would not be caught and would propagate up the call stack. Since the implementation now relies on a different method from possibly a different class, this can affect the return value as well. So the CI type is 1,2."
816,<android.os.Vibrator: boolean[] arePrimitivesSupported(int)>,30,31,<android.os.Vibrator: boolean[] arePrimitivesSupported(int)>,<android.os.Vibrator: boolean[] arePrimitivesSupported(int)>,0,"{
    return new boolean[primitiveIds.length];
}","{
    VibratorInfo info = getInfo();
    boolean[] supported = new boolean[primitiveIds.length];
    for (int i = 0; i < primitiveIds.length; i++) {
        supported[i] = info.isPrimitiveSupported(primitiveIds[i]);
    }
    return supported;
}",1,"/**
 * Query whether the vibrator supports the given primitives.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain whether the effect at that same index in the querying array is supported or
 * not.
 *
 * @param primitiveIds Which primitives to query for.
 * @return Whether the primitives are supported.
 */
","/**
 * Query whether the vibrator supports the given primitives.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain whether the effect at that same index in the querying array is supported or
 * not.
 *
 * @param primitiveIds Which primitives to query for.
 * @return Whether the primitives are supported.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The early version simply returns a new boolean array initialized with false for each element, whereas the late version uses a `for` loop to fill the array with specific boolean values obtained from calling `info.isPrimitiveSupported()` on each element from `primitiveIds`. In addition, the implementation now includes a call to `getInfo()`. The presence of a `for` loop and the invocation of `info.isPrimitiveSupported()` denotes both control dependency change (3) and dependent API change (5), and the initialization of the array with specific values signifies a return statement change (1).","The change from returning an array with default boolean values to returning an array filled with the results of `info.isPrimitiveSupported()` for each element could lead to different return values, which indicates a compatibility issue of type 1."
817,"<android.service.dataloader.DataLoaderService.DataLoaderBinderService: void create(int,DataLoaderParamsParcel,FileSystemControlParcel,IDataLoaderStatusListener)>",30,31,"<android.service.dataloader.DataLoaderService.DataLoaderBinderService: void create(int,DataLoaderParamsParcel,FileSystemControlParcel,IDataLoaderStatusListener)>","<android.service.dataloader.DataLoaderService.DataLoaderBinderService: void create(int,DataLoaderParamsParcel,FileSystemControlParcel,IDataLoaderStatusListener)>",0,"{
    try {
        nativeCreateDataLoader(id, control, params, listener);
    } catch (Exception ex) {
        Slog.e(TAG, ""Failed to create native loader for "" + id, ex);
        destroy(id);
        throw new RuntimeException(ex);
    } finally {
        if (control.incremental != null) {
            IoUtils.closeQuietly(control.incremental.cmd);
            IoUtils.closeQuietly(control.incremental.pendingReads);
            IoUtils.closeQuietly(control.incremental.log);
        }
    }
}","{
    try {
        nativeCreateDataLoader(id, control, params, listener);
    } catch (Exception ex) {
        Slog.e(TAG, ""Failed to create native loader for "" + id, ex);
        destroy(id);
        throw new RuntimeException(ex);
    } finally {
        if (control.incremental != null) {
            IoUtils.closeQuietly(control.incremental.cmd);
            IoUtils.closeQuietly(control.incremental.pendingReads);
            IoUtils.closeQuietly(control.incremental.log);
            IoUtils.closeQuietly(control.incremental.blocksWritten);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change is the addition of `IoUtils.closeQuietly(control.incremental.blocksWritten);` in the `finally` block, which is an other statement changed (4).","The addition of the `closeQuietly` call in the `finally` block does not affect the normal execution flow, return values, or exception handling of the method; it's meant to ensure resources are closed which would not introduce a Compatibility Issue. Hence, there is no Compatibility Issue (0)."
818,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,30,31,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getDevicesMatchingConnectionStates(states);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStatesWithAttribution(states, mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed because a new method 'getDevicesMatchingConnectionStatesWithAttribution(states, mAttributionSource)' is called rather than the previous 'getDevicesMatchingConnectionStates(states)', and then 'Attributable.setAttriburationSource' is applied to the return value. Additionally, there are new annotations added which change the permissions required to invoke the method. Thus, the change types include Return statement changed (1), Other statement changed (4), and Dependent API changed (5). ","The CI is caused by a potential different return value due to the change in the API call (usage of 'getDevicesMatchingConnectionStatesWithAttribution' instead of 'getDevicesMatchingConnectionStates') and the application of 'setAttributionSource' on the returned object, which means the method may return different BluetoothDevice lists. The change in required permissions can lead to a SecurityException for apps that haven't been updated accordingly. Thus, the CI type is 1."
819,"<android.os.DropBoxManager: void addData(String,byte[],int)>",30,31,"<android.os.DropBoxManager: void addData(String,byte[],int)>","<android.os.DropBoxManager: void addData(String,byte[],int)>",0,"{
    if (data == null)
        throw new NullPointerException(""data == null"");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data, so it was ignored"", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}","{
    if (data == null)
        throw new NullPointerException(""data == null"");
    try {
        mService.addData(tag, data, flags);
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data, so it was ignored"", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
","/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API call inside the try block has changed from mService.add(new Entry(tag, 0, data, flags)) to mService.addData(tag, data, flags). Therefore, the code change type is 5.","There is no compatibility issue detected since the change only reflects an internal implementation detailâ€“the use of a different method to accomplish the same task. The overall method contract, behavior, expected inputs, and outputs appear to remain unchanged."
822,<android.bluetooth.le.ScanFilter.Builder: Builder setDeviceAddress(String)>,30,31,<android.bluetooth.le.ScanFilter.Builder: Builder setDeviceAddress(String)>,<android.bluetooth.le.ScanFilter.Builder: Builder setDeviceAddress(String)>,0,"{
    if (deviceAddress != null && !BluetoothAdapter.checkBluetoothAddress(deviceAddress)) {
        throw new IllegalArgumentException(""invalid device address "" + deviceAddress);
    }
    mDeviceAddress = deviceAddress;
    return this;
}","{
    if (deviceAddress == null) {
        mDeviceAddress = deviceAddress;
        return this;
    }
    return setDeviceAddress(deviceAddress, BluetoothDevice.ADDRESS_TYPE_PUBLIC);
}",1,"/**
 * Set filter on device address.
 *
 * @param deviceAddress The device Bluetooth address for the filter. It needs to be in the
 * format of ""01:02:03:AB:CD:EF"". The device address can be validated using {@link
 * BluetoothAdapter#checkBluetoothAddress}.
 * @throws IllegalArgumentException If the {@code deviceAddress} is invalid.
 */
","/**
 * Set filter on device address.
 *
 * @param deviceAddress The device Bluetooth address for the filter. It needs to be in the
 * format of ""01:02:03:AB:CD:EF"". The device address can be validated using {@link
 * BluetoothAdapter#checkBluetoothAddress}.  The @AddressType is defaulted to {@link
 * BluetoothDevice#ADDRESS_TYPE_PUBLIC}
 * @throws IllegalArgumentException If the {@code deviceAddress} is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The early version contains a check for a valid Bluetooth address and throws an IllegalArgumentException if the check fails. In the late version, this check is removed, and instead, there's an additional method call with different parameters (setDeviceAddress(deviceAddress, BluetoothDevice.ADDRESS_TYPE_PUBLIC)) if deviceAddress is non-null. These changes are a control dependency change and an other statement changed, so the code change type is 3,4.","Although the check for a valid Bluetooth address has been removed and the method call has been changed, the API still seems to accept a device address and sets it. The exception that used to be thrown in the early version won't be thrown anymore; however, since it was replaced with another method call that is likely to perform a similar check internally, it does not necessarily imply a behaviour that is different visible from the outside of the API. Based on the available information, we cannot conclude that this change will lead to a compatibility issue. Thus, the CI type is 0."
825,"<android.content.Intent: Intent parseUri(String,int)>",30,31,"<android.content.Intent: Intent parseUri(String,int)>","<android.content.Intent: Intent parseUri(String,int)>",0,"{
    int i = 0;
    try {
        final boolean androidApp = uri.startsWith(""android-app:"");
        // Validate intent scheme if requested.
        if ((flags & (URI_INTENT_SCHEME | URI_ANDROID_APP_SCHEME)) != 0) {
            if (!uri.startsWith(""intent:"") && !androidApp) {
                Intent intent = new Intent(ACTION_VIEW);
                try {
                    intent.setData(Uri.parse(uri));
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
                return intent;
            }
        }
        i = uri.lastIndexOf(""#"");
        // simple case
        if (i == -1) {
            if (!androidApp) {
                return new Intent(ACTION_VIEW, Uri.parse(uri));
            }
        // old format Intent URI
        } else if (!uri.startsWith(""#Intent;"", i)) {
            if (!androidApp) {
                return getIntentOld(uri, flags);
            } else {
                i = -1;
            }
        }
        // new format
        Intent intent = new Intent(ACTION_VIEW);
        Intent baseIntent = intent;
        boolean explicitAction = false;
        boolean inSelector = false;
        // fetch data part, if present
        String scheme = null;
        String data;
        if (i >= 0) {
            data = uri.substring(0, i);
            // length of ""#Intent;""
            i += 8;
        } else {
            data = uri;
        }
        // loop over contents of Intent, all name=value;
        while (i >= 0 && !uri.startsWith(""end"", i)) {
            int eq = uri.indexOf('=', i);
            if (eq < 0)
                eq = i - 1;
            int semi = uri.indexOf(';', i);
            String value = eq < semi ? Uri.decode(uri.substring(eq + 1, semi)) : """";
            // action
            if (uri.startsWith(""action="", i)) {
                intent.setAction(value);
                if (!inSelector) {
                    explicitAction = true;
                }
            } else // categories
            if (uri.startsWith(""category="", i)) {
                intent.addCategory(value);
            } else // type
            if (uri.startsWith(""type="", i)) {
                intent.mType = value;
            } else // identifier
            if (uri.startsWith(""identifier="", i)) {
                intent.mIdentifier = value;
            } else // launch flags
            if (uri.startsWith(""launchFlags="", i)) {
                intent.mFlags = Integer.decode(value).intValue();
                if ((flags & URI_ALLOW_UNSAFE) == 0) {
                    intent.mFlags &= ~IMMUTABLE_FLAGS;
                }
            } else // package
            if (uri.startsWith(""package="", i)) {
                intent.mPackage = value;
            } else // component
            if (uri.startsWith(""component="", i)) {
                intent.mComponent = ComponentName.unflattenFromString(value);
            } else // scheme
            if (uri.startsWith(""scheme="", i)) {
                if (inSelector) {
                    intent.mData = Uri.parse(value + "":"");
                } else {
                    scheme = value;
                }
            } else // source bounds
            if (uri.startsWith(""sourceBounds="", i)) {
                intent.mSourceBounds = Rect.unflattenFromString(value);
            } else // selector
            if (semi == (i + 3) && uri.startsWith(""SEL"", i)) {
                intent = new Intent();
                inSelector = true;
            } else // extra
            {
                String key = Uri.decode(uri.substring(i + 2, eq));
                // create Bundle if it doesn't already exist
                if (intent.mExtras == null)
                    intent.mExtras = new Bundle();
                Bundle b = intent.mExtras;
                // add EXTRA
                if (uri.startsWith(""S."", i))
                    b.putString(key, value);
                else if (uri.startsWith(""B."", i))
                    b.putBoolean(key, Boolean.parseBoolean(value));
                else if (uri.startsWith(""b."", i))
                    b.putByte(key, Byte.parseByte(value));
                else if (uri.startsWith(""c."", i))
                    b.putChar(key, value.charAt(0));
                else if (uri.startsWith(""d."", i))
                    b.putDouble(key, Double.parseDouble(value));
                else if (uri.startsWith(""f."", i))
                    b.putFloat(key, Float.parseFloat(value));
                else if (uri.startsWith(""i."", i))
                    b.putInt(key, Integer.parseInt(value));
                else if (uri.startsWith(""l."", i))
                    b.putLong(key, Long.parseLong(value));
                else if (uri.startsWith(""s."", i))
                    b.putShort(key, Short.parseShort(value));
                else
                    throw new URISyntaxException(uri, ""unknown EXTRA type"", i);
            }
            // move to the next item
            i = semi + 1;
        }
        if (inSelector) {
            // The Intent had a selector; fix it up.
            if (baseIntent.mPackage == null) {
                baseIntent.setSelector(intent);
            }
            intent = baseIntent;
        }
        if (data != null) {
            if (data.startsWith(""intent:"")) {
                data = data.substring(7);
                if (scheme != null) {
                    data = scheme + ':' + data;
                }
            } else if (data.startsWith(""android-app:"")) {
                if (data.charAt(12) == '/' && data.charAt(13) == '/') {
                    // Correctly formed android-app, first part is package name.
                    int end = data.indexOf('/', 14);
                    if (end < 0) {
                        // All we have is a package name.
                        intent.mPackage = data.substring(14);
                        if (!explicitAction) {
                            intent.setAction(ACTION_MAIN);
                        }
                        data = """";
                    } else {
                        // Target the Intent at the given package name always.
                        String authority = null;
                        intent.mPackage = data.substring(14, end);
                        int newEnd;
                        if ((end + 1) < data.length()) {
                            if ((newEnd = data.indexOf('/', end + 1)) >= 0) {
                                // Found a scheme, remember it.
                                scheme = data.substring(end + 1, newEnd);
                                end = newEnd;
                                if (end < data.length() && (newEnd = data.indexOf('/', end + 1)) >= 0) {
                                    // Found a authority, remember it.
                                    authority = data.substring(end + 1, newEnd);
                                    end = newEnd;
                                }
                            } else {
                                // All we have is a scheme.
                                scheme = data.substring(end + 1);
                            }
                        }
                        if (scheme == null) {
                            // If there was no scheme, then this just targets the package.
                            if (!explicitAction) {
                                intent.setAction(ACTION_MAIN);
                            }
                            data = """";
                        } else if (authority == null) {
                            data = scheme + "":"";
                        } else {
                            data = scheme + ""://"" + authority + data.substring(end);
                        }
                    }
                } else {
                    data = """";
                }
            }
            if (data.length() > 0) {
                try {
                    intent.mData = Uri.parse(data);
                } catch (IllegalArgumentException e) {
                    throw new URISyntaxException(uri, e.getMessage());
                }
            }
        }
        return intent;
    } catch (IndexOutOfBoundsException e) {
        throw new URISyntaxException(uri, ""illegal Intent URI format"", i);
    }
}","{
    Intent intent = parseUriInternal(uri, flags);
    intent.mLocalFlags |= LOCAL_FLAG_FROM_URI;
    return intent;
}",1,"/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
","/**
 * Create an intent from a URI.  This URI may encode the action,
 * category, and other intent fields, if it was returned by
 * {@link #toUri}.  If the Intent was not generate by toUri(), its data
 * will be the entire URI and its action will be ACTION_VIEW.
 *
 * <p>The URI given here must not be relative -- that is, it must include
 * the scheme and full path.
 *
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.
 *
 * @return Intent The newly created Intent object.
 *
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntax
 * it bad (as parsed by the Uri class) or the Intent data within the
 * URI is invalid.
 *
 * @see #toUri
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
827,<android.content.res.XmlBlock.Parser: String getText()>,30,31,<android.content.res.XmlBlock.Parser: String getText()>,<android.content.res.XmlBlock.Parser: String getText()>,0,"{
    int id = nativeGetText(mParseState);
    return id >= 0 ? mStrings.get(id).toString() : null;
}","{
    int id = nativeGetText(mParseState);
    return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : null;
}",1,,,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from utilizing `mStrings.get(id).toString()` to `getSequenceString(mStrings.getSequence(id))`. This indicates not only a change in the return expression but also a potential change in the behavior or type of object returned because the method and the way of obtaining the string from 'mStrings' has changed. Hence, the code change type is 1,5.","The alteration in the method of obtaining the string could potentially return a different value or even a different type (as CharSequence and String are not identical in general usage) depending on the implementation of `getSequenceString()`. Given that this method is used in obtaining the return value and may change the behavior of the method, the CI type is 1."
828,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,30,31,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,0,"{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    writeDataTypesToXml(serializer);
    N = countMimeGroups();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, GROUP_STR);
        serializer.attribute(null, NAME_STR, mMimeGroups.get(i));
        serializer.endTag(null, GROUP_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}","{
    if (getAutoVerify()) {
        serializer.attribute(null, AUTO_VERIFY_STR, Boolean.toString(true));
    }
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    writeDataTypesToXml(serializer);
    N = countMimeGroups();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, GROUP_STR);
        serializer.attribute(null, NAME_STR, mMimeGroups.get(i));
        serializer.endTag(null, GROUP_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SUFFIX:
                serializer.attribute(null, SUFFIX_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_ADVANCED_GLOB:
                serializer.attribute(null, AGLOB_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SUFFIX:
                serializer.attribute(null, SUFFIX_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}",1,"/**
 * Write the contents of the IntentFilter as an XML stream.
 */
","/**
 * Write the contents of the IntentFilter as an XML stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
830,<android.view.ViewRootImpl.WindowInputEventReceiver: void onBatchedInputEventPending(int)>,30,31,<android.view.ViewRootImpl.WindowInputEventReceiver: void onBatchedInputEventPending(int)>,<android.view.ViewRootImpl.WindowInputEventReceiver: void onBatchedInputEventPending(int)>,0,"{
    // mStopped: There will be no more choreographer callbacks if we are stopped,
    // so we must consume all input immediately to prevent ANR
    final boolean unbuffered = mUnbufferedInputDispatch || (source & mUnbufferedInputSource) != SOURCE_CLASS_NONE || mStopped;
    if (unbuffered) {
        if (mConsumeBatchedInputScheduled) {
            unscheduleConsumeBatchedInput();
        }
        // Consume event immediately if unbuffered input dispatch has been requested.
        consumeBatchedInputEvents(-1);
        return;
    }
    scheduleConsumeBatchedInput();
}","{
    final boolean unbuffered = mUnbufferedInputDispatch || (source & mUnbufferedInputSource) != SOURCE_CLASS_NONE;
    if (unbuffered) {
        if (mConsumeBatchedInputScheduled) {
            unscheduleConsumeBatchedInput();
        }
        // Consume event immediately if unbuffered input dispatch has been requested.
        consumeBatchedInputEvents(-1);
        return;
    }
    scheduleConsumeBatchedInput();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed. The condition for assigning 'true' to the variable 'unbuffered' has been altered by removing '|| mStopped' from the boolean expression, so the change type is 3.","Although the control dependency has changed, it should not cause a CI because the logic for determining 'unbuffered' only changes the circumstances in which batched input events are consumed immediately. If 'mStopped' was true before, it would have forced immediate consumption, whereas now it does not. It does not change the behavior of the method in a way that would lead to a CI, as the method does not return a value or throw a new exception due to this change, and the contract of when and how input events are consumed remains the same. The method always ends with a 'return' or a call to 'scheduleConsumeBatchedInput()', so the change does not impact the outcome from the caller's perspective. Hence, no CI is detected, which implies the compatibility remains unaffected based on the code snippets provided."
831,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,30,31,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,<android.inputmethodservice.InputMethodService: boolean isInputViewShown()>,0,"{
    return mCanPreRender ? mWindowVisible : mIsInputViewShown && mDecorViewVisible;
}","{
    return mDecorViewVisible;
}",1,"/**
 * Return whether the soft input view is <em>currently</em> shown to the
 * user.  This is the state that was last determined and
 * applied by {@link #updateInputViewShown()}.
 */
","/**
 * Return whether the soft input view is <em>currently</em> shown to the
 * user.  This is the state that was last determined and
 * applied by {@link #updateInputViewShown()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning the result of a conditional expression (mCanPreRender ? mWindowVisible : mIsInputViewShown && mDecorViewVisible) to simply returning the boolean value of mDecorViewVisible, so the code change type is 1.","Since the expression used to determine the return value has changed, this could potentially lead to different return values under certain conditions, thus causing a change in behavior. Therefore, the CI type is 1."
832,<android.companion.AssociationRequest: String toString()>,30,31,<android.companion.AssociationRequest: String toString()>,<android.companion.AssociationRequest: String toString()>,0,"{
    return ""AssociationRequest{"" + ""mSingleDevice="" + mSingleDevice + "", mDeviceFilters="" + mDeviceFilters + '}';
}","{
    return ""AssociationRequest { "" + ""singleDevice = "" + mSingleDevice + "", "" + ""deviceFilters = "" + mDeviceFilters + "", "" + ""deviceProfile = "" + mDeviceProfile + "", "" + ""callingPackage = "" + mCallingPackage + "", "" + ""deviceProfilePrivilegesDescription = "" + mDeviceProfilePrivilegesDescription + "", "" + ""creationTime = "" + mCreationTime + "", "" + ""skipPrompt = "" + mSkipPrompt + "" }"";
}",1,,,-1,[@Override],"[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString method has been changed with added fields (mDeviceProfile, mCallingPackage, mDeviceProfilePrivilegesDescription, mCreationTime, mSkipPrompt), which means a return statement is altered to include additional information. Additionally, there has been a change in formatting (the way the result string is composed). Therefore, the code change includes return statement changed and other statement changed, leading to change types 1 and 4.","The API's return value is altered due to the change in the implementation of the toString() method. The additional fields added to the string will lead to a different result being returned by the method, creating a compatibility issue due to potentially different return values. Therefore, the CI type is 1."
835,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,30,31,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, null, 0, null, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    context.mIsSystemOrSystemUiContext = true;
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, null);
    context.setResources(packageInfo.getResources());
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetrics());
    context.mContextType = CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI;
    return context;
}",1,,,-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"4,5",0,"The changes include adding `ContextParams.EMPTY` in the constructor of `ContextImpl` and changing the assignment of a boolean field to an assignment of a constant to a different field. The change in parameter passed to the constructor and the field assigned signify a dependency on a potentially modified or new API, as well as other statement changes. So, the change type is 4,5.","Even though there are changes in the implementation and a new constant is introduced, these do not imply a compatibility issue since they do not alter the return type or exception handling of the method. The method still returns an instance of `ContextImpl`, and no new exceptions are thrown. Hence, there is no compatibility issue."
836,"<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>",30,31,"<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>","<android.bluetooth.BluetoothHidDevice: boolean replyReport(BluetoothDevice,byte,byte,byte[])>",0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.replyReport(device, type, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.replyReport(device, type, id, data, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Sends report to remote host as reply for GET_REPORT request from {@link
 * Callback#onGetReport(BluetoothDevice, byte, byte, int)}.
 *
 * @param type Report Type, as in request.
 * @param id Report Id, as in request.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Sends report to remote host as reply for GET_REPORT request from {@link
 * Callback#onGetReport(BluetoothDevice, byte, byte, int)}.
 *
 * @param type Report Type, as in request.
 * @param id Report Id, as in request.
 * @param data Report data, not including Report Id.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API service.replyReport() has an additional parameter mAttributionSource in the late implementation. There are no changes detected in the return statement, exception handling, or control dependency statements. Annotations have changed, indicating new permission requirements, which are not directly related to code execution but to the API's usage. Therefore, this would be considered a change in other statements due to the change in annotations, as well as a dependent API change because the signature of the method service.replyReport(...) has been altered.","Despite the dependent API change, the behavior of the current API does not change in terms of return values or exception handling. The addition of a parameter to the call does not affect the boolean result returned, nor does it change what exceptions are caught. Therefore, there is no Compatibility Issue according to the definitions provided."
837,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,30,31,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,<android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask: Void doInBackground(Void)>,0,"{
    int availability = internalGetInitialAvailability();
    synchronized (mLock) {
        if (availability == STATE_NOT_READY) {
            internalUpdateEnrolledKeyphraseMetadata();
            if (mKeyphraseMetadata != null) {
                availability = STATE_KEYPHRASE_ENROLLED;
            } else {
                availability = STATE_KEYPHRASE_UNENROLLED;
            }
        }
        if (DBG) {
            Slog.d(TAG, ""Hotword availability changed from "" + mAvailability + "" -> "" + availability);
        }
        mAvailability = availability;
        notifyStateChangedLocked();
    }
    return null;
}","{
    try {
        int availability = internalGetInitialAvailability();
        synchronized (mLock) {
            if (availability == STATE_NOT_READY) {
                internalUpdateEnrolledKeyphraseMetadata();
                if (mKeyphraseMetadata != null) {
                    availability = STATE_KEYPHRASE_ENROLLED;
                } else {
                    availability = STATE_KEYPHRASE_UNENROLLED;
                }
            }
            updateAndNotifyStateChangedLocked(availability);
        }
    } catch (SecurityException e) {
        Slog.w(TAG, ""Failed to refresh availability"", e);
        if (mTargetSdkVersion <= Build.VERSION_CODES.R) {
            throw e;
        }
        synchronized (mLock) {
            updateAndNotifyStateChangedLocked(STATE_ERROR);
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,4",2,The changes in the code are:,"- Additionally, there's an alteration to the control flow with the addition of the if condition `if (mTargetSdkVersion <= Build.VERSION_CODES.R)` inside the catch block, which could change the behavior depending on the SDK version (change type 3)."
838,<android.content.res.Resources.Theme: int getChangingConfigurations()>,30,31,<android.content.res.Resources.Theme: int getChangingConfigurations()>,<android.content.res.Resources.Theme: int getChangingConfigurations()>,0,"{
    return mThemeImpl.getChangingConfigurations();
}","{
    synchronized (mLock) {
        return mThemeImpl.getChangingConfigurations();
    }
}",1,"/**
 * Returns a bit mask of configuration changes that will impact this
 * theme (and thus require completely reloading it).
 *
 * @return a bit mask of configuration changes, as defined by
 * {@link ActivityInfo}
 * @see ActivityInfo
 */
","/**
 * Returns a bit mask of configuration changes that will impact this
 * theme (and thus require completely reloading it).
 *
 * @return a bit mask of configuration changes, as defined by
 * {@link ActivityInfo}
 * @see ActivityInfo
 */
",-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,"3, 4",0,"The late version of the method adds a synchronized block around the existing return statement, but the statement itself is unchanged. The 'synchronized' is a control dependency that has been added, so the code changes include types 3 and 4.","The addition of the synchronized block does not change the value returned by the method or introduce any new exceptions, it only adds thread safety to the operation. Thus, no compatibility issue should arise from this change."
839,<android.view.DisplayCutout: boolean equals(Object)>,30,31,<android.view.DisplayCutout: boolean equals(Object)>,<android.view.DisplayCutout: boolean equals(Object)>,0,"{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets);
    }
    return false;
}","{
    if (o == this) {
        return true;
    }
    if (o instanceof DisplayCutout) {
        DisplayCutout c = (DisplayCutout) o;
        return mSafeInsets.equals(c.mSafeInsets) && mBounds.equals(c.mBounds) && mWaterfallInsets.equals(c.mWaterfallInsets) && mCutoutPathParserInfo.equals(c.mCutoutPathParserInfo);
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The equals method's return statement has been modified to include an additional condition check (mCutoutPathParserInfo.equals(c.mCutoutPathParserInfo)), so the change types are 1 for the return statement and 4 for other changes within the statements.","The modification in the return statement adds an additional field comparison, which could potentially result in a different boolean outcome when comparing DisplayCutout objects. Therefore, the CI type is 1 due to the potential for different return values."
840,"<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>",30,31,"<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>","<android.bluetooth.BluetoothHidDevice: boolean registerApp(BluetoothHidDeviceAppSdpSettings,BluetoothHidDeviceAppQosSettings,BluetoothHidDeviceAppQosSettings,Executor,Callback)>",0,"{
    boolean result = false;
    if (sdp == null) {
        throw new IllegalArgumentException(""sdp parameter cannot be null"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""executor parameter cannot be null"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""callback parameter cannot be null"");
    }
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            CallbackWrapper cbw = new CallbackWrapper(executor, callback);
            result = service.registerApp(sdp, inQos, outQos, cbw);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    if (sdp == null) {
        throw new IllegalArgumentException(""sdp parameter cannot be null"");
    }
    if (executor == null) {
        throw new IllegalArgumentException(""executor parameter cannot be null"");
    }
    if (callback == null) {
        throw new IllegalArgumentException(""callback parameter cannot be null"");
    }
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            CallbackWrapper cbw = new CallbackWrapper(executor, callback, mAttributionSource);
            result = service.registerApp(sdp, inQos, outQos, cbw, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Registers application to be used for HID device. Connections to HID Device are only possible
 * when application is registered. Only one application can be registered at one time. When an
 * application is registered, the HID Host service will be disabled until it is unregistered.
 * When no longer used, application should be unregistered using {@link #unregisterApp()}. The
 * app will be automatically unregistered if it is not foreground. The registration status
 * should be tracked by the application by handling callback from Callback#onAppStatusChanged.
 * The app registration status is not related to the return value of this method.
 *
 * @param sdp {@link BluetoothHidDeviceAppSdpSettings} object of HID Device SDP record. The HID
 * Device SDP record is required.
 * @param inQos {@link BluetoothHidDeviceAppQosSettings} object of Incoming QoS Settings. The
 * Incoming QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param outQos {@link BluetoothHidDeviceAppQosSettings} object of Outgoing QoS Settings. The
 * Outgoing QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param executor {@link Executor} object on which callback will be executed. The Executor
 * object is required.
 * @param callback {@link Callback} object to which callback messages will be sent. The Callback
 * object is required.
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Registers application to be used for HID device. Connections to HID Device are only possible
 * when application is registered. Only one application can be registered at one time. When an
 * application is registered, the HID Host service will be disabled until it is unregistered.
 * When no longer used, application should be unregistered using {@link #unregisterApp()}. The
 * app will be automatically unregistered if it is not foreground. The registration status
 * should be tracked by the application by handling callback from Callback#onAppStatusChanged.
 * The app registration status is not related to the return value of this method.
 *
 * @param sdp {@link BluetoothHidDeviceAppSdpSettings} object of HID Device SDP record. The HID
 * Device SDP record is required.
 * @param inQos {@link BluetoothHidDeviceAppQosSettings} object of Incoming QoS Settings. The
 * Incoming QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param outQos {@link BluetoothHidDeviceAppQosSettings} object of Outgoing QoS Settings. The
 * Outgoing QoS Settings is not required. Use null or default
 * BluetoothHidDeviceAppQosSettings.Builder for default values.
 * @param executor {@link Executor} object on which callback will be executed. The Executor
 * object is required.
 * @param callback {@link Callback} object to which callback messages will be sent. The Callback
 * object is required.
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"There is a new parameter 'mAttributionSource' passed to the constructor of CallbackWrapper and to the 'registerApp' method, so the code change type is 4,5 for other statement change and dependent API change, respectively.","Although a new parameter is added for internal use and the 'registerApp' method's signature remains the same, it doesn't cause a compatibility issue as the behaviour of the API remains consistent with respect to the execution from the caller's perspective, assuming 'mAttributionSource' is handled correctly internally. Therefore, there is no Compatibility Issue."
841,<android.app.Activity: void finishAffinity()>,30,31,<android.app.Activity: void finishAffinity()>,<android.app.Activity: void finishAffinity()>,0,"{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    try {
        if (ActivityTaskManager.getService().finishActivityAffinity(mToken)) {
            mFinished = true;
        }
    } catch (RemoteException e) {
    // Empty
    }
}","{
    if (mParent != null) {
        throw new IllegalStateException(""Can not be called from an embedded activity"");
    }
    if (mResultCode != RESULT_CANCELED || mResultData != null) {
        throw new IllegalStateException(""Can not be called to deliver a result"");
    }
    if (ActivityClient.getInstance().finishActivityAffinity(mToken)) {
        mFinished = true;
    }
}",1,"/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
","/**
 * Finish this activity as well as all activities immediately below it
 * in the current task that have the same affinity.  This is typically
 * used when an application can be launched on to another task (such as
 * from an ACTION_VIEW of a content type it understands) and the user
 * has used the up navigation to switch out of the current task and in
 * to its own task.  In this case, if the user has navigated down into
 * any other activities of the second application, all of those should
 * be removed from the original task as part of the task switch.
 *
 * <p>Note that this finish does <em>not</em> allow you to deliver results
 * to the previous activity, and an exception will be thrown if you are trying
 * to do so.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,The change is in the way the method to finish an activity's affinity is called: It was previously a call to a remote service (ActivityTaskManager.getService().finishActivityAffinity(mToken)) and has been changed to a local call within the process (ActivityClient.getInstance().finishActivityAffinity(mToken)). So the change type is 5 (Dependent API changed).,"The modification does not necessarily lead to a Compatibility Issue as there is no change in the method signature, return type, exception handling or control flow that is exposed to the caller. The method's internals implementation is changed, but it should achieve the same end result from the caller's perspective, hence no compatibility issue is expected (0)."
846,<android.app.UiAutomation: Bitmap takeScreenshot()>,30,31,<android.app.UiAutomation: Bitmap takeScreenshot()>,<android.app.UiAutomation: Bitmap takeScreenshot()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    int rotation = display.getRotation();
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot(new Rect(0, 0, displaySize.x, displaySize.y), rotation);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screnshot!"", re);
        return null;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}","{
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    int rotation = display.getRotation();
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot(new Rect(0, 0, displaySize.x, displaySize.y));
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while taking screenshot!"", re);
        return null;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}",1,"/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
","/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method `takeScreenshot` from `mUiAutomationConnection` has a removed parameter `rotation` in the late implementation compared to the early implementation. Besides, there is a removal of the synchronized block, which changes the exception handling flow. The code changes include a return statement change, control dependency change, other statement changes due to removal of the lock, and a dependent API change which changes the footprint of the dependent method `takeScreenshot`. Hence the code change type is 1,3,4,5.","Since there is a change in the API call `takeScreenshot` (removed parameter `rotation`) that affects the return value and the removal of the synchronized block, there may also be a change in how exceptions are handled. The API could potentially return a different Bitmap due to the missing rotation parameter, which is significant for the screenshot outcome. Moreover, without the synchronized block, concurrent modifications that may have been prevented in the early version can now proceed in the late version, leading to potential behavioral changes regarding resource access timing. Thus, the CI type is 1."
848,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,30,31,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,<android.bluetooth.BluetoothAdapter: BluetoothLeScanner getBluetoothLeScanner()>,0,"{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService, getOpPackageName(), getAttributionTag());
        }
    }
    return sBluetoothLeScanner;
}","{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (mBluetoothLeScanner == null) {
            mBluetoothLeScanner = new BluetoothLeScanner(this);
        }
        return mBluetoothLeScanner;
    }
}",1,"/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
","/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */
",-1,,[@RequiresNoPermission],-1,-1,-1,-1,-1,-1,"1,4",1,"The instantiation of `BluetoothLeScanner` has been changed from using `mManagerService, getOpPackageName(), getAttributionTag()` to using `this` as an argument. Additionally, there is a change in the variable referenced from `sBluetoothLeScanner` to `mBluetoothLeScanner`, and the return statement's scope has been moved inside the synchronized block, which leads to code change type 1,4.","The change in how the `BluetoothLeScanner` is instantiated, along with the change in the variable storing the reference, could lead to a different return value. Moreover, moving the return statement inside the synchronized block may affect the timing and condition under which the result is returned. Therefore, the CI type is 1."
849,<android.widget.SelectionActionModeHelper.TextClassificationAsyncTask: SelectionResult doInBackground(Void)>,30,31,<android.widget.SelectionActionModeHelper.TextClassificationAsyncTask: SelectionResult doInBackground(Void)>,<android.widget.SelectionActionModeHelper.TextClassificationAsyncTask: SelectionResult doInBackground(Void)>,0,"{
    final Runnable onTimeOut = this::onTimeOut;
    mTextView.postDelayed(onTimeOut, mTimeOutDuration);
    final SelectionResult result = mSelectionResultSupplier.get();
    mTextView.removeCallbacks(onTimeOut);
    return result;
}","{
    final Runnable onTimeOut = this::onTimeOut;
    mTextView.postDelayed(onTimeOut, mTimeOutDuration);
    SelectionResult result = null;
    try {
        result = mSelectionResultSupplier.get();
    } catch (IllegalStateException e) {
        // TODO(b/174300371): Only swallows the exception if the TCSession is destroyed
        Log.w(LOG_TAG, ""TextClassificationAsyncTask failed."", e);
    }
    mTextView.removeCallbacks(onTimeOut);
    return result;
}",1,,,-1,"[@Override, @WorkerThread]","[@Override, @WorkerThread]",-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The implementation in the late version has additional try-catch statements and initializes the 'result' variable as null compared to the early version, which means that changes have been made to exception handling, variable initialization, and control dependencies. Thus, the code change type is 2,3,4.","A new exception handling statement has been introduced for an `IllegalStateException`, and there's a control dependency change regarding the try-catch block. These changes can cause a Compatibility Issue as the method may handle exceptions differently (resulting in potential different behavior when an exception occurs) and could potentially return different results (in cases where an exception is caught, 'result' could now be null where it would have previously been a non-null value). Therefore, CI types are 1,2."
850,"<android.view.InsetsController.InternalAnimationControlListener: void onReady(WindowInsetsAnimationController,int)>",30,31,"<android.view.InsetsController.InternalAnimationControlListener: void onReady(WindowInsetsAnimationController,int)>","<android.view.InsetsController.InternalAnimationControlListener: void onReady(WindowInsetsAnimationController,int)>",0,"{
    mController = controller;
    if (DEBUG)
        Log.d(TAG, ""default animation onReady types: "" + types);
    if (mDisable) {
        onAnimationFinish();
        return;
    }
    mAnimator = ValueAnimator.ofFloat(0f, 1f);
    mAnimator.setDuration(mDurationMs);
    mAnimator.setInterpolator(new LinearInterpolator());
    Insets hiddenInsets = controller.getHiddenStateInsets();
    // IME with zero insets is a special case: it will animate-in from offscreen and end
    // with final insets of zero and vice-versa.
    hiddenInsets = controller.hasZeroInsetsIme() ? Insets.of(hiddenInsets.left, hiddenInsets.top, hiddenInsets.right, mFloatingImeBottomInset) : hiddenInsets;
    Insets start = mShow ? hiddenInsets : controller.getShownStateInsets();
    Insets end = mShow ? controller.getShownStateInsets() : hiddenInsets;
    Interpolator insetsInterpolator = getInterpolator();
    Interpolator alphaInterpolator = getAlphaInterpolator();
    mAnimator.addUpdateListener(animation -> {
        float rawFraction = animation.getAnimatedFraction();
        float alphaFraction = mShow ? rawFraction : 1 - rawFraction;
        float insetsFraction = insetsInterpolator.getInterpolation(rawFraction);
        controller.setInsetsAndAlpha(sEvaluator.evaluate(insetsFraction, start, end), alphaInterpolator.getInterpolation(alphaFraction), rawFraction);
        if (DEBUG)
            Log.d(TAG, ""Default animation setInsetsAndAlpha fraction: "" + insetsFraction);
    });
    mAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            onAnimationFinish();
        }
    });
    if (!mHasAnimationCallbacks) {
        mAnimator.setAnimationHandler(mSfAnimationHandlerThreadLocal.get());
    }
    mAnimator.start();
}","{
    mController = controller;
    if (DEBUG)
        Log.d(TAG, ""default animation onReady types: "" + types);
    if (mDisable) {
        onAnimationFinish();
        return;
    }
    mAnimator = ValueAnimator.ofFloat(0f, 1f);
    mAnimator.setDuration(mDurationMs);
    mAnimator.setInterpolator(new LinearInterpolator());
    Insets hiddenInsets = controller.getHiddenStateInsets();
    // IME with zero insets is a special case: it will animate-in from offscreen and end
    // with final insets of zero and vice-versa.
    hiddenInsets = controller.hasZeroInsetsIme() ? Insets.of(hiddenInsets.left, hiddenInsets.top, hiddenInsets.right, mFloatingImeBottomInset) : hiddenInsets;
    Insets start = mShow ? hiddenInsets : controller.getShownStateInsets();
    Insets end = mShow ? controller.getShownStateInsets() : hiddenInsets;
    Interpolator insetsInterpolator = getInsetsInterpolator();
    Interpolator alphaInterpolator = getAlphaInterpolator();
    mAnimator.addUpdateListener(animation -> {
        float rawFraction = animation.getAnimatedFraction();
        float alphaFraction = mShow ? rawFraction : 1 - rawFraction;
        float insetsFraction = insetsInterpolator.getInterpolation(rawFraction);
        controller.setInsetsAndAlpha(sEvaluator.evaluate(insetsFraction, start, end), alphaInterpolator.getInterpolation(alphaFraction), rawFraction);
        if (DEBUG)
            Log.d(TAG, ""Default animation setInsetsAndAlpha fraction: "" + insetsFraction);
    });
    mAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            onAnimationFinish();
        }
    });
    if (!mHasAnimationCallbacks) {
        mAnimator.setAnimationHandler(mSfAnimationHandlerThreadLocal.get());
    }
    mAnimator.start();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method name called within the implementation has changed from getInterpolator() to getInsetsInterpolator(), so the code change type is 4.","The change from getInterpolator() to getInsetsInterpolator() is a name change of the method being called, which likely refers to an internal rename without change in behavior. Without any modifications to the return values, exception handling, or control dependencies that could alter the method's behavior from the perspective of an API consumer, there is no indication of a compatibility issue, so the CI type is 0."
851,<android.view.View: boolean onDragEvent(DragEvent)>,30,31,<android.view.View: boolean onDragEvent(DragEvent)>,<android.view.View: boolean onDragEvent(DragEvent)>,0,"{
    return false;
}","{
    if (mListenerInfo == null || mListenerInfo.mOnReceiveContentListener == null) {
        return false;
    }
    // Accept drag events by default if there's an OnReceiveContentListener set.
    if (event.getAction() == DragEvent.ACTION_DRAG_STARTED) {
        return true;
    }
    if (event.getAction() == DragEvent.ACTION_DROP) {
        final DragAndDropPermissions permissions = DragAndDropPermissions.obtain(event);
        if (permissions != null) {
            permissions.takeTransient();
        }
        final ContentInfo payload = new ContentInfo.Builder(event.getClipData(), SOURCE_DRAG_AND_DROP).setDragAndDropPermissions(permissions).build();
        ContentInfo remainingPayload = performReceiveContent(payload);
        // Return true unless none of the payload was consumed.
        return remainingPayload != payload;
    }
    return false;
}",1,"/**
 * Handles drag events sent by the system following a call to
 * {@link android.view.View#startDragAndDrop(ClipData,DragShadowBuilder,Object,int)
 * startDragAndDrop()}.
 * <p>
 * When the system calls this method, it passes a
 * {@link android.view.DragEvent} object. A call to
 * {@link android.view.DragEvent#getAction()} returns one of the action type constants defined
 * in DragEvent. The method uses these to determine what is happening in the drag and drop
 * operation.
 * @param event The {@link android.view.DragEvent} sent by the system.
 * The {@link android.view.DragEvent#getAction()} method returns an action type constant defined
 * in DragEvent, indicating the type of drag event represented by this object.
 * @return {@code true} if the method was successful, otherwise {@code false}.
 * <p>
 * The method should return {@code true} in response to an action type of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED} to receive drag events for the current
 * operation.
 * </p>
 * <p>
 * The method should also return {@code true} in response to an action type of
 * {@link android.view.DragEvent#ACTION_DROP} if it consumed the drop, or
 * {@code false} if it didn't.
 * </p>
 * <p>
 * For all other events, the return value is ignored.
 * </p>
 */
","/**
 * Handles drag events sent by the system following a call to
 * {@link android.view.View#startDragAndDrop(ClipData,DragShadowBuilder,Object,int)
 * startDragAndDrop()}.
 * <p>
 * When the system calls this method, it passes a
 * {@link android.view.DragEvent} object. A call to
 * {@link android.view.DragEvent#getAction()} returns one of the action type constants defined
 * in DragEvent. The method uses these to determine what is happening in the drag and drop
 * operation.
 * </p>
 * <p>
 * The default implementation returns false, except if an {@link OnReceiveContentListener}
 * is {@link #setOnReceiveContentListener set} for this view. If an
 * {@link OnReceiveContentListener} is set, the default implementation...
 * <ul>
 * <li>returns true for an
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED ACTION_DRAG_STARTED} event
 * <li>calls {@link #performReceiveContent} for an
 * {@link android.view.DragEvent#ACTION_DROP ACTION_DROP} event
 * <li>returns true for an {@link android.view.DragEvent#ACTION_DROP ACTION_DROP} event, if
 * the listener consumed some or all of the content
 * </ul>
 * </p>
 *
 * @param event The {@link android.view.DragEvent} sent by the system.
 * The {@link android.view.DragEvent#getAction()} method returns an action type constant defined
 * in DragEvent, indicating the type of drag event represented by this object.
 * @return {@code true} if the method was successful, otherwise {@code false}.
 * <p>
 * The method should return {@code true} in response to an action type of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED} to receive drag events for the current
 * operation.
 * </p>
 * <p>
 * The method should also return {@code true} in response to an action type of
 * {@link android.view.DragEvent#ACTION_DROP} if it consumed the drop, or
 * {@code false} if it didn't.
 * </p>
 * <p>
 * For all other events, the return value is ignored.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The new version of the method introduces control flow statements (if conditions and control flow based on `event.getAction()`) and changes the returned value based on conditions, so the code change type is 1,3.","Previously, the method always returned `false`. In the new version, `true` can be returned under certain conditions based on the action of the `DragEvent`. This constitutes a potential Compatibility Issue caused by potential different return values or types, and hence the CI type is 1."
852,<android.content.ClipData.Item: String toString()>,30,31,<android.content.ClipData.Item: String toString()>,<android.content.ClipData.Item: String toString()>,0,"{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipData.Item { "");
    toShortString(b);
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder(128);
    b.append(""ClipData.Item { "");
    toShortString(b, true);
    b.append("" }"");
    return b.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method `toShortString` is called with an additional parameter `true` in the late implementation, indicating a change in its behaviour, so the change type is 1,5.","Since the dependent method `toShortString` is now being called with a different parameter, it can alter the return value of the `toString` method, which constitutes a CI type of 1."
853,<android.widget.Editor.InsertionPointCursorController: void onTouchEvent(MotionEvent)>,30,31,<android.widget.Editor.InsertionPointCursorController: void onTouchEvent(MotionEvent)>,<android.widget.Editor.InsertionPointCursorController: void onTouchEvent(MotionEvent)>,0,"{
    if (hasSelectionController() && getSelectionController().isCursorBeingModified()) {
        return;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_MOVE:
            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
                break;
            }
            if (mIsDraggingCursor) {
                performCursorDrag(event);
            } else if (mFlagCursorDragFromAnywhereEnabled && mTextView.getLayout() != null && mTextView.isFocused() && mTouchState.isMovedEnoughForDrag() && !mTouchState.isDragCloseToVertical()) {
                startCursorDrag(event);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mIsDraggingCursor) {
                endCursorDrag(event);
            }
            break;
    }
}","{
    if (hasSelectionController() && getSelectionController().isCursorBeingModified()) {
        return;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_MOVE:
            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
                break;
            }
            if (mIsDraggingCursor) {
                performCursorDrag(event);
            } else if (mFlagCursorDragFromAnywhereEnabled && mTextView.getLayout() != null && mTextView.isFocused() && mTouchState.isMovedEnoughForDrag() && (mTouchState.getInitialDragDirectionXYRatio() > mCursorDragDirectionMinXYRatio || mTouchState.isOnHandle())) {
                startCursorDrag(event);
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mIsDraggingCursor) {
                endCursorDrag(event);
            }
            break;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code change is present in the condition within the 'else if' statement where `!mTouchState.isDragCloseToVertical()` is replaced with the compound condition `(mTouchState.getInitialDragDirectionXYRatio() > mCursorDragDirectionMinXYRatio || mTouchState.isOnHandle())`. As the conditions for initiating `startCursorDrag(event)` have been altered, this qualifies as a control dependency change.","Despite the change in the control dependency of the 'else if' statement, the method does not introduce a new return statement or a different exception handling mechanism; thus, there is no Compatibility Issue arising from potentially different return values or exception handlings. The modified conditions still govern the same action (`startCursorDrag(event)`), and the purpose of the change seems to be a refinement of the drag behavior rather than an alteration of the core functionality."
854,<android.app.Activity: void setTaskDescription(TaskDescription)>,30,31,<android.app.Activity: void setTaskDescription(TaskDescription)>,<android.app.Activity: void setTaskDescription(TaskDescription)>,0,"{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(Icon.createWithBitmap(icon));
        }
    }
    try {
        ActivityTaskManager.getService().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}","{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(Icon.createWithBitmap(icon));
        }
    }
    ActivityClient.getInstance().setTaskDescription(mToken, mTaskDescription);
}",1,"/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
","/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The try-catch block for RemoteException has been removed, and the method for setting the task description has changed from ActivityTaskManager.getService().setTaskDescription to ActivityClient.getInstance().setTaskDescription. This change is internal and not related to exception throwing or return value. Therefore, the change type is 4.","There is no Compatibility Issue regarding return values or exception handling, as the API's external behavior remains essentially unchanged. It still performs the action of setting the task description for the activity. Hence, the CI type is 0."
855,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,30,31,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,0,"{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}","{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_INTERNAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}",1,"/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
","/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There's an additional call to addPresentationDisplaysLocked() with different arguments (Display.TYPE_INTERNAL) within the 'else if' block, which is a change in the control dependency because it's under an 'if' statement. Additionally, the constant parameter passed to the method represents a change in the other statements, so the changes are classified as 3 and 4.","The additional call to addPresentationDisplaysLocked() adds more displays of TYPE_INTERNAL if they exist, which means the array returned by getDisplays() for the DISPLAY_CATEGORY_PRESENTATION category could include additional elements that were not present in the earlier version. This difference in returned elements constitutes a change in the behavior of the method, hence this is classified as a CI due to potential different return values, and the CI type is 1."
858,"<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>",30,31,"<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,String,Bundle)>",0,"{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(authority, ""authority"");
    Objects.requireNonNull(method, ""method"");
    beforeRemote();
    try {
        return mContentProvider.call(mAttributionSource, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The method signature of mContentProvider.call() has changed, replacing `mPackageName, mAttributionTag` with a single `mAttributionSource` parameter, and thus the change type is 5.","There is no compatibility issue arising from this change as the method still performs the same function and the exception handling remains unchanged. The alteration is internal and does not affect the method contract visible to the caller. The method return type remains a Bundle, and the exceptions thrown remain the same. The objects passed to the call simply have been refactored or restructured."
859,"<android.app.UiAutomation: void grantRuntimePermissionAsUser(String,String,UserHandle)>",30,31,"<android.app.UiAutomation: void grantRuntimePermissionAsUser(String,String,UserHandle)>","<android.app.UiAutomation: void grantRuntimePermissionAsUser(String,String,UserHandle)>",0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Granting runtime permission"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.grantRuntimePermission(packageName, permission, userHandle.getIdentifier());
    } catch (Exception e) {
        throw new SecurityException(""Error granting runtime permission"", e);
    }
}","{
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Granting runtime permission"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.grantRuntimePermission(packageName, permission, userHandle.getIdentifier());
    } catch (Exception e) {
        throw new SecurityException(""Error granting runtime permission"", e);
    }
}",1,"/**
 * Grants a runtime permission to a package for a user.
 * @param packageName The package to which to grant.
 * @param permission The permission to grant.
 * @throws SecurityException if unable to grant the permission.
 */
","/**
 * Grants a runtime permission to a package for a user.
 *
 * @param packageName The package to which to grant.
 * @param permission The permission to grant.
 * @throws SecurityException if unable to grant the permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronized block with mLock and the call to throwIfNotConnectedLocked() have been removed in the late version of the code. The change type is 4, as this is neither a return statement change, exception handling change, control dependency change, nor dependent API change.","The removal of the synchronized block and the throwIfNotConnectedLocked method call does not directly affect the behavior of the method in terms of what it returns or what exceptions it may throw, assuming that throwIfNotConnectedLocked only throws a runtime exception if the UiAutomation is not connected, which was not a documented behavior of the API in the first place. Thus, there is no Compatibility Issue as per the given rules."
860,<android.app.Activity: boolean isTopOfTask()>,30,31,<android.app.Activity: boolean isTopOfTask()>,<android.app.Activity: boolean isTopOfTask()>,0,"{
    if (mToken == null || mWindow == null) {
        return false;
    }
    try {
        return ActivityTaskManager.getService().isTopOfTask(getActivityToken());
    } catch (RemoteException e) {
        return false;
    }
}","{
    if (mToken == null || mWindow == null) {
        return false;
    }
    return ActivityClient.getInstance().isTopOfTask(getActivityToken());
}",1,"/**
 * Indication of whether this is the highest level activity in this task. Can be used to
 * determine whether an activity launched by this activity was placed in the same task or
 * another task.
 *
 * @return true if this is the topmost, non-finishing activity in its task.
 */
","/**
 * Indication of whether this is the highest level activity in this task. Can be used to
 * determine whether an activity launched by this activity was placed in the same task or
 * another task.
 *
 * @return true if this is the topmost, non-finishing activity in its task.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5",2,"The late version removes the try-catch block entirely and changes the service method used for the check. The method getSource() is changed to ActivityClient.getInstance(). Thus, both exception handling statements and dependent API have changed, making the change type 2 and 5.","As the try-catch block that handled RemoteException has been removed, and the API call itself within the try block is now invoking a different method (ActivityClient.getInstance().isTopOfTask(getActivityToken()) instead of ActivityTaskManager.getService().isTopOfTask(getActivityToken())), a RemoteException that occurs would no longer be caught and false would not be returned. In the late version, if a RemoteException occurs, it would no longer be caught, and thus the method would throw an exception instead of returning false. The change in the dependent API (ActivityClient.getInstance()) may also potentially throw different exceptions or no exceptions at all compared to the previous version. For these reasons, the CI type is 2."
861,<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(BluetoothDevice)>,<android.bluetooth.BluetoothHeadset: boolean stopVoiceRecognition(BluetoothDevice)>,0,"{
    if (DBG)
        log(""stopVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (DBG)
        log(""stopVoiceRecognition()"");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Stop Bluetooth Voice Recognition mode, and shut down the
 * Bluetooth audio path.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected, or voice recognition has not started,
 * or voice recognition has ended on this headset, or on error, true otherwise
 */
","/**
 * Stop Bluetooth Voice Recognition mode, and shut down the
 * Bluetooth audio path.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected, or voice recognition has not started,
 * or voice recognition has ended on this headset, or on error, true otherwise
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation of the late version calls a different method 'service.stopVoiceRecognition(device, mAttributionSource)' with an extra parameter compared to the early version, which results in a change of dependency, therefore the code change type is 4,5.","Despite the introduction of an additional parameter in the method call, the return type of the method remains boolean, and there is no indication that this change will lead to a different return value under the same condition or that it will throw new exceptions or handle exceptions differently. Therefore, there is no compatibility issue as long as the caller respects the new method signature, and the CI type is 0."
862,<android.hardware.camera2.CameraCharacteristics: Set<String> getPhysicalCameraIds()>,30,31,<android.hardware.camera2.CameraCharacteristics: Set<String> getPhysicalCameraIds()>,<android.hardware.camera2.CameraCharacteristics: Set<String> getPhysicalCameraIds()>,0,"{
    int[] availableCapabilities = get(REQUEST_AVAILABLE_CAPABILITIES);
    if (availableCapabilities == null) {
        throw new AssertionError(""android.request.availableCapabilities must be non-null "" + ""in the characteristics"");
    }
    if (!ArrayUtils.contains(availableCapabilities, REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA)) {
        return Collections.emptySet();
    }
    byte[] physicalCamIds = get(LOGICAL_MULTI_CAMERA_PHYSICAL_IDS);
    String physicalCamIdString = null;
    try {
        physicalCamIdString = new String(physicalCamIds, ""UTF-8"");
    } catch (java.io.UnsupportedEncodingException e) {
        throw new AssertionError(""android.logicalCam.physicalIds must be UTF-8 string"");
    }
    String[] physicalCameraIdArray = physicalCamIdString.split(""\0"");
    return Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(physicalCameraIdArray)));
}","{
    return mProperties.getPhysicalCameraIds();
}",1,"/**
 * Returns the set of physical camera ids that this logical {@link CameraDevice} is
 * made up of.
 *
 * <p>A camera device is a logical camera if it has
 * REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA capability. If the camera device
 * doesn't have the capability, the return value will be an empty set. </p>
 *
 * <p>Prior to API level 29, all returned IDs are guaranteed to be returned by {@link
 * CameraManager#getCameraIdList}, and can be opened directly by
 * {@link CameraManager#openCamera}. Starting from API level 29, for each of the returned ID,
 * if it's also returned by {@link CameraManager#getCameraIdList}, it can be used as a
 * standalone camera by {@link CameraManager#openCamera}. Otherwise, the camera ID can only be
 * used as part of the current logical camera.</p>
 *
 * <p>The set returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * @return Set of physical camera ids for this logical camera device.
 */
","/**
 * Returns the set of physical camera ids that this logical {@link CameraDevice} is
 * made up of.
 *
 * <p>A camera device is a logical camera if it has
 * REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA capability. If the camera device
 * doesn't have the capability, the return value will be an empty set. </p>
 *
 * <p>Prior to API level 29, all returned IDs are guaranteed to be returned by {@link
 * CameraManager#getCameraIdList}, and can be opened directly by
 * {@link CameraManager#openCamera}. Starting from API level 29, for each of the returned ID,
 * if it's also returned by {@link CameraManager#getCameraIdList}, it can be used as a
 * standalone camera by {@link CameraManager#openCamera}. Otherwise, the camera ID can only be
 * used as part of the current logical camera.</p>
 *
 * <p>The set returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * @return Set of physical camera ids for this logical camera device.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The method's implementation has been completely replaced with a call to another method: return mProperties.getPhysicalCameraIds(), this is a major overhaul of the logic and hence constitutes both a return statement change and a dependent API change, so the code change type is 1, 5.","The change of the complete logic the method uses to obtain the return value can result in a different set of camera IDs being returned (based on what mProperties.getPhysicalCameraIds() returns). Therefore, the CI type is 1."
863,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,30,31,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,<android.widget.RemoteViews.AsyncApplyTask: ViewTree doInBackground(Void)>,0,"{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCancelled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}","{
    try {
        if (mResult == null) {
            mResult = inflateView(mContext, mRV, mParent, 0, mColorResources);
        }
        mTree = new ViewTree(mResult);
        if (mRV.mActions != null) {
            int count = mRV.mActions.size();
            mActions = new Action[count];
            for (int i = 0; i < count && !isCancelled(); i++) {
                // TODO: check if isCancelled in nested views.
                mActions[i] = mRV.mActions.get(i).initActionAsync(mTree, mParent, mHandler, mColorResources);
            }
        } else {
            mActions = null;
        }
        return mTree;
    } catch (Exception e) {
        mError = e;
        return null;
    }
}",1,,,-1,[@Override],"[@Nullable, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method `inflateView` and the method `initActionAsync` have added a new parameter `mColorResources`, and there is no return statement or exception handling statement changed. So, the code change types are 4 and 5 due to changes in the method parameters of `inflateView` and `initActionAsync`.","Despite changes in method invocations, there are no changes to the return values or exception handling visible in the fragment given. Both methods used within the try block appear to have additional parameters but they still return their respective types, and the outer method's return statement and exception handling are unchanged. Therefore, there's no Compatibility Issue caused by potential different return values, types, or exception handling; hence, the type is 0."
864,<android.app.ContextImpl: Context createContextForSplit(String)>,30,31,<android.app.ContextImpl: Context createContextForSplit(String)>,<android.app.ContextImpl: Context createContextForSplit(String)>,0,"{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, splitName, mToken, mUser, mFlags, classLoader, null);
    final int displayId = getDisplayId();
    context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, displayId, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders()));
    return context;
}","{
    if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
        // All Splits are always loaded.
        return this;
    }
    final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
    final String[] paths = mPackageInfo.getSplitPaths(splitName);
    final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), splitName, mToken, mUser, mFlags, classLoader, null);
    context.setResources(ResourcesManager.getInstance().getResources(mToken, mPackageInfo.getResDir(), paths, mPackageInfo.getOverlayDirs(), mPackageInfo.getOverlayPaths(), mPackageInfo.getApplicationInfo().sharedLibraryFiles, mForceDisplayOverrideInResources ? getDisplayId() : null, null, mPackageInfo.getCompatibilityInfo(), classLoader, mResources.getLoaders()));
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5","1,5",The method ContextImpl constructor call changed in the following ways:,"- 'mAttributionSource.getNext()' parameter is introduced, with no corresponding parameter in the early version."
865,<android.nfc.NfcAdapter: boolean isEnabled()>,30,31,<android.nfc.NfcAdapter: boolean isEnabled()>,<android.nfc.NfcAdapter: boolean isEnabled()>,0,"{
    try {
        return sService.getState() == STATE_ON;
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    try {
        return sService.getState() == STATE_ON;
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, ""Failed to recover NFC Service."");
            return false;
        }
        try {
            return sService.getState() == STATE_ON;
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover NFC Service."");
        }
        return false;
    }
}",1,"/**
 * Return true if this NFC Adapter has any features enabled.
 *
 * <p>If this method returns false, the NFC hardware is guaranteed not to
 * generate or respond to any NFC communication over its NFC radio.
 * <p>Applications can use this to check if NFC is enabled. Applications
 * can request Settings UI allowing the user to toggle NFC using:
 * <p><pre>startActivity(new Intent(Settings.ACTION_NFC_SETTINGS))</pre>
 *
 * @see android.provider.Settings#ACTION_NFC_SETTINGS
 * @return true if this NFC Adapter has any features enabled
 */
","/**
 * Return true if this NFC Adapter has any features enabled.
 *
 * <p>If this method returns false, the NFC hardware is guaranteed not to
 * generate or respond to any NFC communication over its NFC radio.
 * <p>Applications can use this to check if NFC is enabled. Applications
 * can request Settings UI allowing the user to toggle NFC using:
 * <p><pre>startActivity(new Intent(Settings.ACTION_NFC_SETTINGS))</pre>
 *
 * @see android.provider.Settings#ACTION_NFC_SETTINGS
 * @return true if this NFC Adapter has any features enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4","1,2","The late implementation introduces a new code block that attempts to recover from a RemoteException by retrying the getState() call on the service. This includes another try-catch block and additional logging. This is a change in exception handling and other statements (but not exclusively a control dependency change), hence the code change type is 2,4.","Due to added logic for retrying the call to sService.getState(), there is now an increased chance that the late version API will return 'true' in cases where the early version would have returned 'false' due to the RemoteException not being recovered from (the new logic to check sService and possibly retry the operation could lead to different behavior). This addition introduces both the possibility of a different return value and different exception handling (an additional RemoteException is caught and logged), so the CI types are 1,2."
866,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,30,31,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,<android.accessibilityservice.AccessibilityService.MagnificationController: float getScale()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationScale(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 1.0f;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationScale(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain scale"", re);
            re.rethrowFromSystemServer();
        }
    }
    return 1.0f;
}",1,"/**
 * Returns the current magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 1.0f}.
 *
 * @return the current magnification scale
 */
","/**
 * Returns the current magnification scale.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return a default value of {@code 1.0f}.
 *
 * @return the current magnification scale
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code change is in the part of the code that retrieves the IAccessibilityServiceConnection. The method getInstance() is now being passed ""mService"" instead of no arguments, indicating a change in the dependent API. This results in the code change type 5.","There is no compatibility issue detected between the early and late versions of the API, as the return behavior and exception handling have not changed. The dependent API change does not affect the returns or exceptions of the current API. Hence, the CI type is 0."
867,<android.app.Activity: void stopLocalVoiceInteraction()>,30,31,<android.app.Activity: void stopLocalVoiceInteraction()>,<android.app.Activity: void stopLocalVoiceInteraction()>,0,"{
    try {
        ActivityTaskManager.getService().stopLocalVoiceInteraction(mToken);
    } catch (RemoteException re) {
    }
}","{
    ActivityClient.getInstance().stopLocalVoiceInteraction(mToken);
}",1,"/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
","/**
 * Request to terminate the current voice interaction that was previously started
 * using {@link #startLocalVoiceInteraction(Bundle)}. When the interaction is
 * terminated, {@link #onLocalVoiceInteractionStopped()} will be called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation has changed from calling ActivityTaskManager.getService().stopLocalVoiceInteraction(mToken) to ActivityClient.getInstance().stopLocalVoiceInteraction(mToken), which indicates a change in the dependent method being called. This is a dependent API change, and also qualifies as another statement changed because the method being called within the try block is different. Hence, the code change type is 4,5.","Although the method called has been altered, the behaviour of the API as seen by the caller has not changed because it does not affect the return value or the exception handling of the method (since the original method also did not handle the RemoteException). Thus, there is no compatibility issue, and the CI type is 0."
868,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,30,31,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,<android.app.SystemServiceRegistry.CachedServiceFetcher: T getService(ContextImpl)>,0,"{
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    boolean interrupted = false;
    T ret = null;
    for (; ; ) {
        boolean doInitialize = false;
        synchronized (cache) {
            // Return it if we already have a cached instance.
            T service = (T) cache[mCacheIndex];
            if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                ret = service;
                // exit the for (;;)
                break;
            }
            // We start over from STATE_UNINITIALIZED.
            if (gates[mCacheIndex] == ContextImpl.STATE_READY) {
                gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;
            }
            // At this point, the gate must be either UNINITIALIZED or INITIALIZING.
            if (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) {
                doInitialize = true;
                gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;
            }
        }
        if (doInitialize) {
            // Only the first thread gets here.
            T service = null;
            @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
            try {
                // This thread is the first one to get here. Instantiate the service
                // *without* the cache lock held.
                service = createService(ctx);
                newState = ContextImpl.STATE_READY;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            } finally {
                synchronized (cache) {
                    cache[mCacheIndex] = service;
                    gates[mCacheIndex] = newState;
                    cache.notifyAll();
                }
            }
            ret = service;
            // exit the for (;;)
            break;
        }
        // and go back to the top and retry.
        synchronized (cache) {
            // path, so we remember the interrupt state here and re-interrupt later.
            while (gates[mCacheIndex] < ContextImpl.STATE_READY) {
                try {
                    // Clear the interrupt state.
                    interrupted |= Thread.interrupted();
                    cache.wait();
                } catch (InterruptedException e) {
                    // This shouldn't normally happen, but if someone interrupts the
                    // thread, it will.
                    Slog.w(TAG, ""getService() interrupted"");
                    interrupted = true;
                }
            }
        }
    }
    if (interrupted) {
        Thread.currentThread().interrupt();
    }
    return ret;
}","{
    final Object[] cache = ctx.mServiceCache;
    final int[] gates = ctx.mServiceInitializationStateArray;
    boolean interrupted = false;
    T ret = null;
    for (; ; ) {
        boolean doInitialize = false;
        synchronized (cache) {
            // Return it if we already have a cached instance.
            T service = (T) cache[mCacheIndex];
            if (service != null) {
                ret = service;
                // exit the for (;;)
                break;
            }
            // Similarly, if the previous attempt returned null, we'll retry again.
            if (gates[mCacheIndex] == ContextImpl.STATE_READY || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                gates[mCacheIndex] = ContextImpl.STATE_UNINITIALIZED;
            }
            // At this point, the gate must be either UNINITIALIZED or INITIALIZING.
            if (gates[mCacheIndex] == ContextImpl.STATE_UNINITIALIZED) {
                doInitialize = true;
                gates[mCacheIndex] = ContextImpl.STATE_INITIALIZING;
            }
        }
        if (doInitialize) {
            // Only the first thread gets here.
            T service = null;
            @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
            try {
                // This thread is the first one to get here. Instantiate the service
                // *without* the cache lock held.
                service = createService(ctx);
                newState = ContextImpl.STATE_READY;
            } catch (ServiceNotFoundException e) {
                onServiceNotFound(e);
            } finally {
                synchronized (cache) {
                    cache[mCacheIndex] = service;
                    gates[mCacheIndex] = newState;
                    cache.notifyAll();
                }
            }
            ret = service;
            // exit the for (;;)
            break;
        }
        // and go back to the top and retry.
        synchronized (cache) {
            // path, so we remember the interrupt state here and re-interrupt later.
            while (gates[mCacheIndex] < ContextImpl.STATE_READY) {
                try {
                    // Clear the interrupt state.
                    interrupted |= Thread.interrupted();
                    cache.wait();
                } catch (InterruptedException e) {
                    // This shouldn't normally happen, but if someone interrupts the
                    // thread, it will.
                    Slog.w(TAG, ""getService() interrupted"");
                    interrupted = true;
                }
            }
        }
    }
    if (interrupted) {
        Thread.currentThread().interrupt();
    }
    return ret;
}",1,,,-1,"[@Override, @SuppressWarnings(""unchecked"")]","[@Override, @SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,,,,
869,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",30,31,"<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>","<android.app.Activity: void onApplyThemeResource(Theme,int,boolean)>",0,"{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
    if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
        mTaskDescription.setBackgroundColor(colorBackground);
    }
    final int statusBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
    if (statusBarColor != 0) {
        mTaskDescription.setStatusBarColor(statusBarColor);
    }
    final int navigationBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
    if (navigationBarColor != 0) {
        mTaskDescription.setNavigationBarColor(navigationBarColor);
    }
    final int targetSdk = getApplicationInfo().targetSdkVersion;
    final boolean targetPreQ = targetSdk < Build.VERSION_CODES.Q;
    if (!targetPreQ) {
        mTaskDescription.setEnsureStatusBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceStatusBarContrast, false));
        mTaskDescription.setEnsureNavigationBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceNavigationBarContrast, true));
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}","{
    if (mParent == null) {
        super.onApplyThemeResource(theme, resid, first);
    } else {
        try {
            theme.setTo(mParent.getTheme());
        } catch (Exception e) {
        // Empty
        }
        theme.applyStyle(resid, false);
    }
    // Get the primary color and update the TaskDescription for this activity
    TypedArray a = theme.obtainStyledAttributes(com.android.internal.R.styleable.ActivityTaskDescription);
    if (mTaskDescription.getPrimaryColor() == 0) {
        int colorPrimary = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
        if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
            mTaskDescription.setPrimaryColor(colorPrimary);
        }
    }
    int colorBackground = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
    if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
        mTaskDescription.setBackgroundColor(colorBackground);
    }
    int colorBackgroundFloating = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_colorBackgroundFloating, 0);
    if (colorBackgroundFloating != 0 && Color.alpha(colorBackgroundFloating) == 0xFF) {
        mTaskDescription.setBackgroundColorFloating(colorBackgroundFloating);
    }
    final int statusBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
    if (statusBarColor != 0) {
        mTaskDescription.setStatusBarColor(statusBarColor);
    }
    final int navigationBarColor = a.getColor(com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
    if (navigationBarColor != 0) {
        mTaskDescription.setNavigationBarColor(navigationBarColor);
    }
    final int targetSdk = getApplicationInfo().targetSdkVersion;
    final boolean targetPreQ = targetSdk < Build.VERSION_CODES.Q;
    if (!targetPreQ) {
        mTaskDescription.setEnsureStatusBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceStatusBarContrast, false));
        mTaskDescription.setEnsureNavigationBarContrastWhenTransparent(a.getBoolean(R.styleable.ActivityTaskDescription_enforceNavigationBarContrast, true));
    }
    a.recycle();
    setTaskDescription(mTaskDescription);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"A new variable assignment for `colorBackgroundFloating` and a method invocation `mTaskDescription.setBackgroundColorFloating(colorBackgroundFloating)` have been added to the late version. Consequently, the change type is 3,4 due to the new statements introduced within the control flow.",There is no Compatibility Issue since the newly added statements are not modifying existing behavior but rather adding additional behavior that does not alter the previous flow or expected results from the method. No return or exception handling statements have been modified or introduced that would alter the contract of the API.
870,"<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setLookasideConfig(int,int)>",30,31,"<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setLookasideConfig(int,int)>","<android.database.sqlite.SQLiteDatabase.OpenParams.Builder: Builder setLookasideConfig(int,int)>",0,"{
    Preconditions.checkArgument(slotSize >= 0, ""lookasideSlotCount cannot be negative"");
    Preconditions.checkArgument(slotCount >= 0, ""lookasideSlotSize cannot be negative"");
    Preconditions.checkArgument((slotSize > 0 && slotCount > 0) || (slotCount == 0 && slotSize == 0), ""Invalid configuration: "" + slotSize + "", "" + slotCount);
    mLookasideSlotSize = slotSize;
    mLookasideSlotCount = slotCount;
    return this;
}","{
    Preconditions.checkArgument(slotSize >= 0, ""lookasideSlotCount cannot be negative"");
    Preconditions.checkArgument(slotCount >= 0, ""lookasideSlotSize cannot be negative"");
    Preconditions.checkArgument((slotSize > 0 && slotCount > 0) || (slotCount == 0 && slotSize == 0), ""Invalid configuration: %d, %d"", slotSize, slotCount);
    mLookasideSlotSize = slotSize;
    mLookasideSlotCount = slotCount;
    return this;
}",1,"/**
 * Configures
 * <a href=""https://sqlite.org/malloc.html#lookaside"">lookaside memory allocator</a>
 *
 * <p>SQLite default settings will be used, if this method isn't called.
 * Use {@code setLookasideConfig(0,0)} to disable lookaside
 *
 * <p><strong>Note:</strong> Provided slotSize/slotCount configuration is just a
 * recommendation. The system may choose different values depending on a device, e.g.
 * lookaside allocations can be disabled on low-RAM devices
 *
 * @param slotSize The size in bytes of each lookaside slot.
 * @param slotCount The total number of lookaside memory slots per database connection.
 */
","/**
 * Configures
 * <a href=""https://sqlite.org/malloc.html#lookaside"">lookaside memory allocator</a>
 *
 * <p>SQLite default settings will be used, if this method isn't called.
 * Use {@code setLookasideConfig(0,0)} to disable lookaside
 *
 * <p><strong>Note:</strong> Provided slotSize/slotCount configuration is just a
 * recommendation. The system may choose different values depending on a device, e.g.
 * lookaside allocations can be disabled on low-RAM devices
 *
 * @param slotSize The size in bytes of each lookaside slot.
 * @param slotCount The total number of lookaside memory slots per database connection.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is in the error message string of Preconditions.checkArgument, where it went from concatenation to a formatted string. The check itself and logic are the same, so the code change type is 4.",There is no Compatibility Issue because the change in the error message does not affect the actual slots configuration or behavior of the method; it only affects the format of the error message if an IllegalArgumentException is thrown.
872,"<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>",30,31,"<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>","<android.app.ActivityOptions: ActivityOptions makeSceneTransitionAnimation(Activity,Pair<View, String>)>",0,"{
    ActivityOptions opts = new ActivityOptions();
    makeSceneTransitionAnimation(activity, activity.getWindow(), opts, activity.mExitTransitionListener, sharedElements);
    return opts;
}","{
    ActivityOptions opts = new ActivityOptions();
    ExitTransitionCoordinator exit = makeSceneTransitionAnimation(new ActivityExitTransitionCallbacks(activity), activity.mExitTransitionListener, activity.getWindow(), opts, sharedElements);
    opts.mExitCoordinatorIndex = activity.mActivityTransitionState.addExitTransitionCoordinator(exit);
    return opts;
}",1,"/**
 * Create an ActivityOptions to transition between Activities using cross-Activity scene
 * animations. This method carries the position of multiple shared elements to the started
 * Activity. The position of the first element in sharedElements
 * will be used as the epicenter for the exit Transition. The position of the associated
 * shared element in the launched Activity will be the epicenter of its entering Transition.
 *
 * <p>This requires {@link android.view.Window#FEATURE_ACTIVITY_TRANSITIONS} to be
 * enabled on the calling Activity to cause an exit transition. The same must be in
 * the called Activity to get an entering transition.</p>
 * @param activity The Activity whose window contains the shared elements.
 * @param sharedElements The names of the shared elements to transfer to the called
 * Activity and their associated Views. The Views must each have
 * a unique shared element name.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @see android.transition.Transition#setEpicenterCallback(
 * android.transition.Transition.EpicenterCallback)
 */
","/**
 * Create an ActivityOptions to transition between Activities using cross-Activity scene
 * animations. This method carries the position of multiple shared elements to the started
 * Activity. The position of the first element in sharedElements
 * will be used as the epicenter for the exit Transition. The position of the associated
 * shared element in the launched Activity will be the epicenter of its entering Transition.
 *
 * <p>This requires {@link android.view.Window#FEATURE_ACTIVITY_TRANSITIONS} to be
 * enabled on the calling Activity to cause an exit transition. The same must be in
 * the called Activity to get an entering transition.</p>
 * @param activity The Activity whose window contains the shared elements.
 * @param sharedElements The names of the shared elements to transfer to the called
 * Activity and their associated Views. The Views must each have
 * a unique shared element name.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @see android.transition.Transition#setEpicenterCallback(
 * android.transition.Transition.EpicenterCallback)
 */
",-1,[@SafeVarargs],[@SafeVarargs],-1,-1,-1,-1,-1,-1,"3,4",1,"The method's internal implementation and control flow have been altered in the following ways: a creation of a new `ExitTransitionCoordinator` object, adjustment to how `makeSceneTransitionAnimation` is called with new arguments, addition of a new statement to set the `mExitCoordinatorIndex`, and overall modification to the logic of setting up the transition. Thus, the code change is classified as 3 (Control dependency change) and 4 (Other statement changed).","The modifications result in potentially different return values for the `opts` object since the `mExitCoordinatorIndex` is now being set in the late version, which was not the case in the early version. These internal object state differences could lead to varying behavior when the `ActivityOptions` object is used. Hence, there could be a Compatibility Issue caused by potential different return values or types, which is type 1."
873,"<android.content.res.Resources.Theme: int[] getAttributeResolutionStack(int,int,int)>",30,31,"<android.content.res.Resources.Theme: int[] getAttributeResolutionStack(int,int,int)>","<android.content.res.Resources.Theme: int[] getAttributeResolutionStack(int,int,int)>",0,"{
    int[] stack = mThemeImpl.getAttributeResolutionStack(defStyleAttr, defStyleRes, explicitStyleRes);
    if (stack == null) {
        return new int[0];
    } else {
        return stack;
    }
}","{
    synchronized (mLock) {
        int[] stack = mThemeImpl.getAttributeResolutionStack(defStyleAttr, defStyleRes, explicitStyleRes);
        if (stack == null) {
            return new int[0];
        } else {
            return stack;
        }
    }
}",1,"/**
 * Returns the ordered list of resource ID that are considered when resolving attribute
 * values when making an equivalent call to
 * {@link #obtainStyledAttributes(AttributeSet, int[], int, int)} . The list will include
 * a set of explicit styles ({@code explicitStyleRes} and it will include the default styles
 * ({@code defStyleAttr} and {@code defStyleRes}).
 *
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 * @param explicitStyleRes A resource identifier of an explicit style resource.
 * @return ordered list of resource ID that are considered when resolving attribute values.
 */
","/**
 * Returns the ordered list of resource ID that are considered when resolving attribute
 * values when making an equivalent call to
 * {@link #obtainStyledAttributes(AttributeSet, int[], int, int)} . The list will include
 * a set of explicit styles ({@code explicitStyleRes} and it will include the default styles
 * ({@code defStyleAttr} and {@code defStyleRes}).
 *
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 * @param explicitStyleRes A resource identifier of an explicit style resource.
 * @return ordered list of resource ID that are considered when resolving attribute values.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,3,0,A new 'synchronized' block has been added to the late version of the code while the rest of the implementation remains unchanged. This is a control dependency change (type 3).,"Since the behavior of the method's return value and error handling does not change (it still returns an empty array or the attribute stack as appropriate), there are no compatibility issues introduced by this synchronization change. The change only affects the thread-safety of the method and does not result in a different value being returned or a different exception being thrown. Therefore, the CI type is 0."
874,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,30,31,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,<android.bluetooth.le.ScanFilter.Builder: ScanFilter build()>,0,"{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}","{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask, mAddressType, mIrk);
}",1,"/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */
","/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for `ScanFilter` in the late version has two extra arguments (`mAddressType, mIrk`) compared to the early version, so the code change type is 1,5.","The change in the constructor parameters indicates that the type `ScanFilter` has changed in such a way that could potentially affect the return value. Therefore, the late version of the API could return a `ScanFilter` object with additional information, which leads to a CI type 1."
875,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,30,31,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,<android.hardware.fingerprint.FingerprintManager: boolean isHardwareDetected()>,0,"{
    if (mService != null) {
        try {
            return mService.isHardwareDetected(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}","{
    FrameworkStatsLog.write(FrameworkStatsLog.AUTH_DEPRECATED_API_USED, AUTH_DEPRECATED_APIUSED__DEPRECATED_API__API_FINGERPRINT_MANAGER_IS_HARDWARE_DETECTED, mContext.getApplicationInfo().uid, mContext.getApplicationInfo().targetSdkVersion);
    if (mService != null) {
        try {
            return mService.isHardwareDetectedDeprecated(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Slog.w(TAG, ""isFingerprintHardwareDetected(): Service not connected!"");
    }
    return false;
}",1,"/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
","/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 * @deprecated See {@link BiometricPrompt} and
 * {@link FingerprintManager#FINGERPRINT_ERROR_HW_UNAVAILABLE}
 */
",-1,"[@Deprecated, @RequiresPermission(USE_FINGERPRINT), @Override]","[@Deprecated, @RequiresPermission(USE_FINGERPRINT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"An additional statement to call FrameworkStatsLog.write() is included at the beginning of the method, and in the 'try' block the method called has changed from 'isHardwareDetected' to 'isHardwareDetectedDeprecated'. These are classified as ""Other statement changed"" and ""Dependent API changed"", so the code change type is 4,5.","While the changes in the code include an additional logging statement and change of the called method, these changes are not expected to lead to any CI as there is no alteration in the expected behavior, returned types, or exception handling that affects the external API contract. The API still returns a boolean value as before, and the exception handling mechanism remains unchanged, hence no compatibility issue."
876,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,30,31,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,<android.appwidget.AppWidgetProviderInfo: AppWidgetProviderInfo clone()>,0,"{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeHeight;
    that.minResizeHeight = this.minResizeHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label;
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    that.widgetFeatures = this.widgetFeatures;
    return that;
}","{
    AppWidgetProviderInfo that = new AppWidgetProviderInfo();
    that.provider = this.provider == null ? null : this.provider.clone();
    that.minWidth = this.minWidth;
    that.minHeight = this.minHeight;
    that.minResizeWidth = this.minResizeWidth;
    that.minResizeHeight = this.minResizeHeight;
    that.maxResizeWidth = this.maxResizeWidth;
    that.maxResizeHeight = this.maxResizeHeight;
    that.targetCellWidth = this.targetCellWidth;
    that.targetCellHeight = this.targetCellHeight;
    that.updatePeriodMillis = this.updatePeriodMillis;
    that.initialLayout = this.initialLayout;
    that.initialKeyguardLayout = this.initialKeyguardLayout;
    that.configure = this.configure == null ? null : this.configure.clone();
    that.label = this.label;
    that.icon = this.icon;
    that.previewImage = this.previewImage;
    that.previewLayout = this.previewLayout;
    that.autoAdvanceViewId = this.autoAdvanceViewId;
    that.resizeMode = this.resizeMode;
    that.widgetCategory = this.widgetCategory;
    that.providerInfo = this.providerInfo;
    that.widgetFeatures = this.widgetFeatures;
    that.descriptionRes = this.descriptionRes;
    return that;
}",1,,,-1,"[@Override, @SuppressWarnings(""deprecation"")]","[@Override, @SuppressWarnings(""deprecation"")]",-1,-1,-1,-1,-1,-1,"1,4",1,"New fields have been added to the cloned object (maxResizeWidth, maxResizeHeight, targetCellWidth, targetCellHeight, previewLayout, and descriptionRes) and one field has been fixed (minResizeWidth = this.minResizeWidth instead of minResizeWidth = this.minResizeHeight). These are not control dependency changes, exception handling, nor dependent API changes, thus it is of type 1,4.","The cloned object in the late version includes additional fields compared to the early version, and one field value is corrected. It leads to different return value from the clone method. Therefore, this is a CI of type 1."
878,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,30,31,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.NotificationBackupHelper: byte[] getBackupPayload(String)>,0,"{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            newPayload = nm.getBackupPayload(mUserId);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
            newPayload = null;
        }
    }
    return newPayload;
}","{
    byte[] newPayload = null;
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            newPayload = nm.getBackupPayload(mUserId);
        } catch (Exception e) {
            // Treat as no data
            Slog.e(TAG, ""Couldn't communicate with notification manager"", e);
            newPayload = null;
        }
    }
    return newPayload;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is in a logging statement, Slog.e(...) which includes an additional parameter in the late version (the exception 'e'), so the type of modification is 4.","The change is purely in a logging statement which does not affect the API's behaviour or the values it returns. There is no change in the control flow, return statements, or exception handling that would affect the outward functionality of the API. Hence, there is no Compatibility Issue."
879,<android.widget.SpellChecker.SpellParser: void parse()>,30,31,<android.widget.SpellChecker.SpellParser: void parse()>,<android.widget.SpellChecker.SpellParser: void parse()>,0,"{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck && wordStart != BreakIterator.DONE && wordStart <= end) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        removeRangeSpan(editable);
    }
    spellCheck();
}","{
    Editable editable = (Editable) mTextView.getText();
    final int textChangeStart = editable.getSpanStart(mRange);
    final int textChangeEnd = editable.getSpanEnd(mRange);
    Range<Integer> sentenceBoundary = detectSentenceBoundary(editable, textChangeStart, textChangeEnd);
    int sentenceStart = sentenceBoundary.getLower();
    int sentenceEnd = sentenceBoundary.getUpper();
    if (sentenceStart == sentenceEnd) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        stop();
        return;
    }
    boolean scheduleOtherSpellCheck = false;
    if (sentenceEnd < textChangeEnd) {
        if (DBG) {
            Log.i(TAG, ""schedule other spell check."");
        }
        // Several batches needed on that region. Cut after last previous word
        scheduleOtherSpellCheck = true;
    }
    int spellCheckEnd = sentenceEnd;
    do {
        int spellCheckStart = sentenceStart;
        boolean createSpellCheckSpan = true;
        // Cancel or merge overlapped spell check spans
        for (int i = 0; i < mLength; ++i) {
            final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
            if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                continue;
            }
            final int spanStart = editable.getSpanStart(spellCheckSpan);
            final int spanEnd = editable.getSpanEnd(spellCheckSpan);
            if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                // No need to merge
                continue;
            }
            if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                // There is a completely overlapped spell check span
                // skip this span
                createSpellCheckSpan = false;
                if (DBG) {
                    Log.i(TAG, ""The range is overrapped. Skip spell check."");
                }
                break;
            }
            // This spellCheckSpan is replaced by the one we are creating
            editable.removeSpan(spellCheckSpan);
            spellCheckStart = Math.min(spanStart, spellCheckStart);
            spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
        }
        if (DBG) {
            Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
        }
        // Stop spell checking when there are no characters in the range.
        if (spellCheckEnd <= spellCheckStart) {
            Log.w(TAG, ""Trying to spellcheck invalid region, from "" + sentenceStart + "" to "" + spellCheckEnd);
            break;
        }
        if (createSpellCheckSpan) {
            addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
        }
    } while (false);
    sentenceStart = spellCheckEnd;
    if (scheduleOtherSpellCheck && sentenceStart != BreakIterator.DONE && sentenceStart <= textChangeEnd) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, sentenceStart, textChangeEnd);
    } else {
        removeRangeSpan(editable);
    }
    spellCheck(mForceCheckWhenEditingWord);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
880,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: boolean isA2dpPlaying(BluetoothDevice)>,0,"{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.isA2dpPlaying(device);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}","{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.isA2dpPlaying(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}",1,"/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */
","/**
 * Check if A2DP profile is streaming music.
 *
 * @param device BluetoothDevice device
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The method call service.isA2dpPlaying(device) has changed to service.isA2dpPlaying(device, mAttributionSource) with an additional parameter, which affects a dependent API, hence the code change type is 1 for the return statement and 5 for the dependent API change.",The change in the dependent API call could potentially result in different return values because a new parameter has been added to the method call. This difference is considered as a Compatibility Issue of type 1 caused by potential different return values.
882,<android.app.NotificationChannel: boolean equals(Object)>,30,31,<android.app.NotificationChannel: boolean equals(Object)>,<android.app.NotificationChannel: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && isBlockable() == that.isBlockable() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp && mOriginalImportance == that.mOriginalImportance && Objects.equals(getParentChannelId(), that.getParentChannelId()) && Objects.equals(getConversationId(), that.getConversationId()) && isDemoted() == that.isDemoted() && isImportantConversation() == that.isImportantConversation();
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    NotificationChannel that = (NotificationChannel) o;
    return getImportance() == that.getImportance() && mBypassDnd == that.mBypassDnd && getLockscreenVisibility() == that.getLockscreenVisibility() && mLights == that.mLights && getLightColor() == that.getLightColor() && getUserLockedFields() == that.getUserLockedFields() && isFgServiceShown() == that.isFgServiceShown() && mVibrationEnabled == that.mVibrationEnabled && mShowBadge == that.mShowBadge && isDeleted() == that.isDeleted() && getDeletedTimeMs() == that.getDeletedTimeMs() && isBlockable() == that.isBlockable() && mAllowBubbles == that.mAllowBubbles && Objects.equals(getId(), that.getId()) && Objects.equals(getName(), that.getName()) && Objects.equals(mDesc, that.mDesc) && Objects.equals(getSound(), that.getSound()) && Arrays.equals(mVibration, that.mVibration) && Objects.equals(getGroup(), that.getGroup()) && Objects.equals(getAudioAttributes(), that.getAudioAttributes()) && mImportanceLockedByOEM == that.mImportanceLockedByOEM && mImportanceLockedDefaultApp == that.mImportanceLockedDefaultApp && mOriginalImportance == that.mOriginalImportance && Objects.equals(getParentChannelId(), that.getParentChannelId()) && Objects.equals(getConversationId(), that.getConversationId()) && isDemoted() == that.isDemoted() && isImportantConversation() == that.isImportantConversation();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An additional condition `getDeletedTimeMs() == that.getDeletedTimeMs()` has been added to the comparison logic, which is not a control structure change, an exception handling change, a dependent API change, or a return statement change, so this change falls under the category of ""Other statement changed.""","The additional condition `getDeletedTimeMs() == that.getDeletedTimeMs()` in the comparison logic does not lead to a compatibility issue because the method's behavior remains consistent with its contract to check for equality. Clients using this method would expect it to perform an equality check, and any additional fields being checked would be consistent with this expected behavior. Therefore, adding a field to the equality check does not introduce a difference in exception handling or the value/type returned by the method."
883,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void clearScores()>,30,31,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void clearScores()>,<android.net.NetworkScoreManager.NetworkScoreCallbackProxy: void clearScores()>,0,"{
    Binder.clearCallingIdentity();
    mExecutor.execute(() -> {
        mCallback.onScoresInvalidated();
    });
}","{
    final long token = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onScoresInvalidated();
        });
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"The late implementation introduces try-finally block to ensure the identity is restored after the operation, and it also stores the returned token from Binder.clearCallingIdentity(), which are changes that belong to the types 2 and 4.","The changes between the two versions do not affect how the method behaves in terms of returning a different value or throwing different exceptions. The try-finally block is meant for correctly restoring the thread's identity after the method execution and does not change the logic related to how the method behaves at runtime from an API consumer's perspective. Therefore, there is no Compatibility Issue."
885,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",30,31,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>","<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",0,"{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    StrictMode.assertUiContext(mContext, ""suggestDesiredDimensions"");
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt(""sys.max_texture_size"", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, ""WallpaperService not running"");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName(), mContext.getDisplayId());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p class=""note"">Calling this method from apps other than the active
 * home app is not guaranteed to work properly.  Other apps that supply
 * wallpaper imagery should use {@link #getDesiredMinimumWidth()} and
 * {@link #getDesiredMinimumHeight()} and construct a wallpaper that
 * matches those dimensions.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p class=""note"">Calling this method from apps other than the active
 * home app is not guaranteed to work properly.  Other apps that supply
 * wallpaper imagery should use {@link #getDesiredMinimumWidth()} and
 * {@link #getDesiredMinimumHeight()} and construct a wallpaper that
 * matches those dimensions.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has changed with the addition of a single statement at the beginning of the method: StrictMode.assertUiContext(mContext, ""suggestDesiredDimensions""). This is an additional method call, so the code change type is 4.","The addition of StrictMode.assertUiContext(mContext, ""suggestDesiredDimensions"") does not change the return type, the value returned, or the exceptions thrown by the method 'suggestDesiredDimensions'. It's an additional precondition check that might throw an exception if the UI context is incorrect, but it does not affect the other behaviors of the method. Therefore, there is no Compatibility Issue in terms of return value or exception handling that can arise due to this change. The Compatibility Issues situation is 0."
886,<android.app.UiAutomation: void dropShellPermissionIdentity()>,30,31,<android.app.UiAutomation: void dropShellPermissionIdentity()>,<android.app.UiAutomation: void dropShellPermissionIdentity()>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.dropShellPermissionIdentity();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing dropping shell permission identity!"", re);
    }
}","{
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.dropShellPermissionIdentity();
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing dropping shell permission identity!"", re);
    }
}",1,"/**
 * Drop the shell permission identity adopted by a previous call to
 * {@link #adoptShellPermissionIdentity()}. If you did not adopt the shell permission
 * identity this method would be a no-op.
 *
 * @see #adoptShellPermissionIdentity()
 */
","/**
 * Drop the shell permission identity adopted by a previous call to
 * {@link #adoptShellPermissionIdentity()}. If you did not adopt the shell permission
 * identity this method would be a no-op.
 *
 * @see #adoptShellPermissionIdentity()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change involves removing the synchronized block with mLock and the call to throwIfNotConnectedLocked(). Since the RemoteExpection handling remains unchanged, the code change type is 4.","There is no change to the return value nor the exceptions thrown visible to the caller, as the RemoteException was already being caught and logged, and the method returns void. The change to synchronization and connection check does not directly affect the method's external behavior regarding return values or exception throwing, thus no CI is detected (CI type is 0)."
888,<android.content.res.Configuration: int hashCode()>,30,31,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + mLocaleList.hashCode();
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + colorMode;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    result = 31 * result + assetsSeq;
    return result;
}","{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + mLocaleList.hashCode();
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + colorMode;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    result = 31 * result + assetsSeq;
    result = 31 * result + fontWeightAdjustment;
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1, 4",1,"The difference between the early and late implementations is the addition of a new multiplier of fontWeightAdjustment in the hashCode computation, so the code change type is 1 as a new return value computation step is added, and 4 since it's an addition of a non-control and non-exception handling-related statement.","With the addition of the new step in computing the result, the late version will potentially return a different value for the hashCode method compared to the early version. Therefore, a Compatibility Issue could arise from a potential different return value, so the CI type is 1."
889,"<android.content.ContentResolver: int update(Uri,ContentValues,Bundle)>",30,31,"<android.content.ContentResolver: int update(Uri,ContentValues,Bundle)>","<android.content.ContentResolver: int update(Uri,ContentValues,Bundle)>",0,"{
    Objects.requireNonNull(uri, ""uri"");
    try {
        if (mWrapped != null)
            return mWrapped.update(uri, values, extras);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, mAttributionTag, uri, values, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", null);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    try {
        if (mWrapped != null)
            return mWrapped.update(uri, values, extras);
    } catch (RemoteException e) {
        return 0;
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException(""Unknown URI "" + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mContext.getAttributionSource(), uri, values, extras);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, ""update"", null);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
","/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param extras A Bundle containing additional information necessary for
 * the operation. Arguments may include SQL style arguments, such
 * as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that
 * the documentation for each individual provider will indicate
 * which arguments they support.
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 * @throws IllegalArgumentException if the provider doesn't support one of
 * the requested Bundle arguments.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The method provider.update() has changed in the parameters it receives: from `(mPackageName, mAttributionTag, uri, values, extras)` to `(mContext.getAttributionSource(), uri, values, extras)`. This means the type of the first parameter has changed and that the way it is obtained has also changed. A dependent API `getAttributionSource()` is now used instead of instance variable `mAttributionTag`, which relates to the change type 5.","However, as long as `getAttributionSource()` returns an object which includes `mPackageName` and `mAttributionTag`, there's no change in the effective behavior of the `update()` method in terms of its output. Therefore, as per the provided functionality, there are no Compatibility Issues since the operation of the `update` method itself and the handling of exceptions remain unchanged, so the CI type is 0."
890,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,30,31,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,<android.app.servertransaction.PendingTransactionActions.StopInfo: void run()>,0,"{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + mActivity);
        // TODO(lifecycler): Use interface callback instead of AMS.
        ActivityTaskManager.getService().activityStopped(mActivity.token, mState, mPersistentState, mDescription);
    } catch (RemoteException ex) {
        // Dump statistics about bundle to help developers debug
        final LogWriter writer = new LogWriter(Log.WARN, TAG);
        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
        pw.println(""Bundle stats:"");
        Bundle.dumpStats(pw, mState);
        pw.println(""PersistableBundle stats:"");
        Bundle.dumpStats(pw, mPersistentState);
        if (ex instanceof TransactionTooLargeException && mActivity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex.rethrowFromSystemServer();
    }
}","{
    // Tell activity manager we have been stopped.
    try {
        if (DEBUG_MEMORY_TRIM)
            Slog.v(TAG, ""Reporting activity stopped: "" + mActivity);
        // TODO(lifecycler): Use interface callback instead of AMS.
        ActivityClient.getInstance().activityStopped(mActivity.token, mState, mPersistentState, mDescription);
    } catch (RuntimeException ex) {
        // Dump statistics about bundle to help developers debug
        final LogWriter writer = new LogWriter(Log.WARN, TAG);
        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
        pw.println(""Bundle stats:"");
        Bundle.dumpStats(pw, mState);
        pw.println(""PersistableBundle stats:"");
        Bundle.dumpStats(pw, mPersistentState);
        if (ex.getCause() instanceof TransactionTooLargeException && mActivity.packageInfo.getTargetSdkVersion() < Build.VERSION_CODES.N) {
            Log.e(TAG, ""App sent too much data in instance state, so it was ignored"", ex);
            return;
        }
        throw ex;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5",2,"There are changes in exception handling and the method called within the try block. The catch block's exception type has been changed from 'RemoteException' to 'RuntimeException' and also the method call `ActivityTaskManager.getService().activityStopped` is changed to `ActivityClient.getInstance().activityStopped`, so the change type is 2,4,5.","The change in the type of exception caught from RemoteException to RuntimeException, combined with the changed throw statement, could lead to different exception handling behaviour; hence there is a potential Compatibility Issue of type 2."
892,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",30,31,"<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>","<android.content.pm.LauncherApps: LauncherActivityInfo resolveActivity(Intent,UserHandle)>",0,"{
    logErrorForInvalidProfileAccess(user);
    try {
        ActivityInfo ai = mService.resolveActivity(mContext.getPackageName(), intent.getComponent(), user);
        if (ai != null) {
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ai, user);
            return info;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}","{
    logErrorForInvalidProfileAccess(user);
    try {
        LauncherActivityInfoInternal ai = mService.resolveLauncherActivityInternal(mContext.getPackageName(), intent.getComponent(), user);
        if (ai == null) {
            return null;
        }
        return new LauncherActivityInfo(mContext, user, ai);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
","/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method used to obtain the `ActivityInfo` has changed from `mService.resolveActivity(...)` to `mService.resolveLauncherActivityInternal(...)`, which is a different dependent API (5). There is also a control dependency change (3) since the `if` condition has been inverted, and the return statement within the try block now creates a `LauncherActivityInfo` object with a different constructor (1).","The changes result in potential different return values due to both the use of a different method to obtain the activity info and the change in the creation of the `LauncherActivityInfo` object, which could lead the API to return different values or types in some cases. Thus, the CI is type 1."
893,"<android.view.inputmethod.InputMethodManager.DelegateImpl: void startInputAsyncOnWindowFocusGain(View,int,int,boolean)>",30,31,"<android.view.inputmethod.InputMethodManager.DelegateImpl: void startInputAsyncOnWindowFocusGain(View,int,int,boolean)>","<android.view.inputmethod.InputMethodManager.DelegateImpl: void startInputAsyncOnWindowFocusGain(View,int,int,boolean)>",0,"{
    final int startInputFlags = getStartInputFlags(focusedView, 0);
    final ImeFocusController controller = getFocusController();
    if (controller == null) {
        return;
    }
    if (controller.checkFocus(forceNewFocus, false)) {
        // smooth.
        if (startInput(StartInputReason.WINDOW_FOCUS_GAIN, focusedView, startInputFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    synchronized (mH) {
        // we'll just do a window focus gain and call it a day.
        try {
            View servedView = controller.getServedView();
            boolean nextFocusHasConnection = servedView != null && servedView == focusedView && hasActiveConnection(focusedView);
            if (DEBUG) {
                Log.v(TAG, ""Reporting focus gain, without startInput"" + "", nextFocusIsServedView="" + nextFocusHasConnection);
            }
            final int startInputReason = nextFocusHasConnection ? WINDOW_FOCUS_GAIN_REPORT_WITH_CONNECTION : WINDOW_FOCUS_GAIN_REPORT_WITHOUT_CONNECTION;
            mService.startInputOrWindowGainedFocus(startInputReason, mClient, focusedView.getWindowToken(), startInputFlags, softInputMode, windowFlags, null, null, 0, /* missingMethodFlags */
            mCurRootView.mContext.getApplicationInfo().targetSdkVersion);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}","{
    int startInputFlags = getStartInputFlags(focusedView, 0);
    startInputFlags |= StartInputFlags.WINDOW_GAINED_FOCUS;
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager.DelegateImpl#startInputAsyncOnWindowFocusGain"", InputMethodManager.this, null);
    final ImeFocusController controller = getFocusController();
    if (controller == null) {
        return;
    }
    if (controller.checkFocus(forceNewFocus, false)) {
        // smooth.
        if (startInput(StartInputReason.WINDOW_FOCUS_GAIN, focusedView, startInputFlags, softInputMode, windowFlags)) {
            return;
        }
    }
    synchronized (mH) {
        // we'll just do a window focus gain and call it a day.
        try {
            View servedView = controller.getServedView();
            boolean nextFocusHasConnection = servedView != null && servedView == focusedView && hasActiveConnection(focusedView);
            if (DEBUG) {
                Log.v(TAG, ""Reporting focus gain, without startInput"" + "", nextFocusIsServedView="" + nextFocusHasConnection);
            }
            final int startInputReason = nextFocusHasConnection ? WINDOW_FOCUS_GAIN_REPORT_WITH_CONNECTION : WINDOW_FOCUS_GAIN_REPORT_WITHOUT_CONNECTION;
            // ignore the result
            mService.startInputOrWindowGainedFocus(startInputReason, mClient, focusedView.getWindowToken(), startInputFlags, softInputMode, windowFlags, null, null, 0, /* missingMethodFlags */
            mCurRootView.mContext.getApplicationInfo().targetSdkVersion);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}",1,"/**
 * For {@link ImeFocusController} to start input asynchronously when focus gain.
 */
","/**
 * For {@link ImeFocusController} to start input asynchronously when focus gain.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,There are two main changes in the late version implementation:,These changes are classified as Other statement changed (4) due to the added method call for tracing and Control dependency changed (3) due to the change in how `startInputFlags` is computed.
894,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int,String,String)>",30,31,"<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int,String,String)>","<android.app.AppOpsManager: int noteProxyOpNoThrow(String,String,int,String,String)>",0,"{
    return noteProxyOpNoThrow(strOpToOp(op), proxiedPackageName, proxiedUid, proxiedAttributionTag, message);
}","{
    return noteProxyOpNoThrow(strOpToOp(op), new AttributionSource(mContext.getAttributionSource(), new AttributionSource(proxiedUid, proxiedPackageName, proxiedAttributionTag, mContext.getAttributionSource().getToken())), message, /*skipProxyOperation*/
    false);
}",1,"/**
 * Like {@link #noteProxyOp(String, String, int, String, String)} but instead
 * of throwing a {@link SecurityException} it returns {@link #MODE_ERRORED}.
 *
 * <p>This API requires package with the {@code proxiedPackageName} to belong to
 * {@code proxiedUid}.
 *
 * @param op The op to note
 * @param proxiedPackageName The package to note the op for
 * @param proxiedUid The uid the package belongs to
 * @param proxiedAttributionTag The proxied {@link Context#createAttributionContext
 * attribution tag} or {@code null} for default attribution
 * @param message A message describing the reason the op was noted
 */
","/**
 * Like {@link #noteProxyOp(String, String, int, String, String)} but instead
 * of throwing a {@link SecurityException} it returns {@link #MODE_ERRORED}.
 *
 * @see #noteOpNoThrow(String, int, String, String, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The arguments passed to the `noteProxyOpNoThrow` method changed, particularly introducing a new `AttributionSource` object as a parameter, which indicates that the Dependent API has changed. This alteration in the method signature of `noteProxyOpNoThrow` would suggest a change in the dependent API, making the code change type 5.","Since the change to the `noteProxyOpNoThrow` method involves additional parameters and wrapping existing ones into an `AttributionSource` object, without evidence of a change in behaviour such as a return type/value change or an exception handling change, there is no CI. The new object creation and parameter wrapping likely maintain the business logic but adapt to the newer method signature. Therefore, based on the given implementation details, there are no indications of a Compatibility Issue."
895,<android.view.Display: long getAppVsyncOffsetNanos()>,30,31,<android.view.Display: long getAppVsyncOffsetNanos()>,<android.view.Display: long getAppVsyncOffsetNanos()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.appVsyncOffsetNanos;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.appVsyncOffsetNanos;
    }
}",1,"/**
 * Gets the app VSYNC offset, in nanoseconds.  This is a positive value indicating
 * the phase offset of the VSYNC events provided by Choreographer relative to the
 * display refresh.  For example, if Choreographer reports that the refresh occurred
 * at time N, it actually occurred at (N - appVsyncOffset).
 * <p>
 * Apps generally do not need to be aware of this.  It's only useful for fine-grained
 * A/V synchronization.
 */
","/**
 * Gets the app VSYNC offset, in nanoseconds.  This is a positive value indicating
 * the phase offset of the VSYNC events provided by Choreographer relative to the
 * display refresh.  For example, if Choreographer reports that the refresh occurred
 * at time N, it actually occurred at (N - appVsyncOffset).
 * <p>
 * Apps generally do not need to be aware of this.  It's only useful for fine-grained
 * A/V synchronization.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronization object has changed from 'this' to 'mLock', so the code change type is 4 (Other statement changed).","The mere change of the synchronization object does not inherently change the behavior of the method's return value or the exceptions it may throw, assuming that 'mLock' is functionally equivalent to 'this' for synchronization purposes. Therefore, there is no Compatibility Issue."
897,<android.view.SurfaceControl.Builder: SurfaceControl build()>,30,31,<android.view.SurfaceControl.Builder: SurfaceControl build()>,<android.view.SurfaceControl.Builder: SurfaceControl build()>,0,"{
    if (mWidth < 0 || mHeight < 0) {
        throw new IllegalStateException(""width and height must be positive or unset"");
    }
    if ((mWidth > 0 || mHeight > 0) && (isEffectLayer() || isContainerLayer())) {
        throw new IllegalStateException(""Only buffer layers can set a valid buffer size."");
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata, mLocalOwnerView, mCallsite);
}","{
    if (mWidth < 0 || mHeight < 0) {
        throw new IllegalStateException(""width and height must be positive or unset"");
    }
    if ((mWidth > 0 || mHeight > 0) && (isEffectLayer() || isContainerLayer())) {
        throw new IllegalStateException(""Only buffer layers can set a valid buffer size."");
    }
    if ((mFlags & FX_SURFACE_MASK) == FX_SURFACE_NORMAL) {
        setBLASTLayer();
    }
    return new SurfaceControl(mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata, mLocalOwnerView, mCallsite);
}",1,"/**
 * Construct a new {@link SurfaceControl} with the set parameters. The builder
 * remains valid.
 */
","/**
 * Construct a new {@link SurfaceControl} with the set parameters. The builder
 * remains valid.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change is the addition of a new if-control statement that sets the BLAST layer. However, this does not modify the return type or the return value directly, nor does it change exception handling. So, the change type is 4.","The code change does not affect the return value or the exceptions thrown by the method and therefore does not present a compatibility issue. The new if-control may cause additional effects internally but does not change the method's behavior from an API consumer's perspective. Therefore, there's no compatibility issue."
898,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>",30,31,"<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>","<android.bluetooth.le.BluetoothLeAdvertiser: void startAdvertisingSet(AdvertisingSetParameters,AdvertiseData,AdvertiseData,PeriodicAdvertisingParameters,AdvertiseData,int,int,AdvertisingSetCallback,Handler)>",0,"{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth GATT - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    if (gatt == null) {
        Log.e(TAG, ""Bluetooth GATT is null"");
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}","{
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException(""callback cannot be null"");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException(""Legacy scan response data too big"");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException(""Unsupported primary PHY selected"");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException(""Unsupported secondary PHY selected"");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException(""Advertising data too big"");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException(""Scan response data too big"");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException(""Periodic advertising data too big"");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException(""Controller does not support LE Periodic Advertising"");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException(""maxExtendedAdvertisingEvents out of range: "" + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException(""Can't use maxExtendedAdvertisingEvents with controller that don't support "" + ""LE Extended Advertising"");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException(""duration out of range: "" + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to get Bluetooth GATT - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    if (gatt == null) {
        Log.e(TAG, ""Bluetooth GATT is null"");
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException(""callback instance already associated with advertising"");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to start advertising set - "", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}",1,"/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 *
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use Periodic Advertising
 * feature is made when it's not supported by the controller, or when
 * maxExtendedAdvertisingEvents is used on a controller that doesn't support the LE Extended
 * Advertising
 */
","/**
 * Creates a new advertising set. If operation succeed, device will start advertising. This
 * method returns immediately, the operation status is delivered through
 * {@code callback.onAdvertisingSetStarted()}.
 * <p>
 *
 * @param parameters Advertising set parameters.
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags.
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param periodicParameters Periodic advertisng parameters. If null, periodic advertising will
 * not be started.
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms). 0 means advertising should continue until stopped.
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255. 0 means no maximum.
 * @param callback Callback for advertising set.
 * @param handler Thread upon which the callbacks will be invoked.
 * @throws IllegalArgumentException When any of the data parameter exceed the maximum allowable
 * size, or unsupported advertising PHY is selected, or when attempt to use Periodic Advertising
 * feature is made when it's not supported by the controller, or when
 * maxExtendedAdvertisingEvents is used on a controller that doesn't support the LE Extended
 * Advertising
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,,,,
899,<android.content.Intent: Intent putExtras(Bundle)>,30,31,<android.content.Intent: Intent putExtras(Bundle)>,<android.content.Intent: Intent putExtras(Bundle)>,0,"{
    if (mExtras == null) {
        mExtras = new Bundle();
    }
    mExtras.putAll(extras);
    return this;
}","{
    // If the provided Bundle has not yet been unparceled then treat this as unfiltered extras.
    if (extras.isParcelled()) {
        mLocalFlags |= LOCAL_FLAG_UNFILTERED_EXTRAS;
    }
    if (mExtras == null) {
        mExtras = new Bundle();
    }
    mExtras.putAll(extras);
    return this;
}",1,"/**
 * Add a set of extended data to the intent.  The keys must include a package
 * prefix, for example the app com.android.contacts would use names
 * like ""com.android.contacts.ShowAll"".
 *
 * @param extras The Bundle of extras to add to this intent.
 *
 * @see #putExtra
 * @see #removeExtra
 */
","/**
 * Add a set of extended data to the intent.  The keys must include a package
 * prefix, for example the app com.android.contacts would use names
 * like ""com.android.contacts.ShowAll"".
 *
 * @param extras The Bundle of extras to add to this intent.
 *
 * @see #putExtra
 * @see #removeExtra
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"A new condition and setting a flag statement have been introduced, but the signature, return type, and the overall behavior related to the returned 'Intent' object remain unchanged, so the code change type is 4.","No Compatibility Issue detected, since the additional code does not alter the return value of the method nor does it introduce different exception handling. The method's contract still guarantees that 'this' (the current Intent object) is returned, with the bundled extras attached. The change is internal and does not affect clients of the method in terms of API contract."
900,<android.hardware.camera2.CameraManager.CameraManagerGlobal: boolean cameraIdHasConcurrentStreamsLocked(String)>,30,31,<android.hardware.camera2.CameraManager.CameraManagerGlobal: boolean cameraIdHasConcurrentStreamsLocked(String)>,<android.hardware.camera2.CameraManager.CameraManagerGlobal: boolean cameraIdHasConcurrentStreamsLocked(String)>,0,"{
    if (!mDeviceStatus.containsKey(cameraId)) {
        Log.e(TAG, ""cameraIdHasConcurrentStreamsLocked called on non existing camera id"");
        return false;
    }
    for (Set<String> comb : mConcurrentCameraIdCombinations) {
        if (comb.contains(cameraId)) {
            return true;
        }
    }
    return false;
}","{
    if (!mDeviceStatus.containsKey(cameraId)) {
        // physical camera ids aren't advertised in concurrent camera id combinations.
        if (DEBUG) {
            Log.v(TAG, "" physical camera id "" + cameraId + "" is hidden."" + "" Available logical camera ids : "" + mDeviceStatus.toString());
        }
        return false;
    }
    for (Set<String> comb : mConcurrentCameraIdCombinations) {
        if (comb.contains(cameraId)) {
            return true;
        }
    }
    return false;
}",1,"/**
 * Helper function to find out if a camera id is in the set of combinations returned by
 * getConcurrentCameraIds()
 * @param cameraId the unique identifier of the camera device to query
 * @return Whether the camera device was found in the set of combinations returned by
 * getConcurrentCameraIds
 */
","/**
 * Helper function to find out if a camera id is in the set of combinations returned by
 * getConcurrentCameraIds()
 * @param cameraId the unique identifier of the camera device to query
 * @return Whether the camera device was found in the set of combinations returned by
 * getConcurrentCameraIds
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The early version has a Log.e statement, but the late version includes an additional conditional check (if (DEBUG)) to control the Log.v output. This is an additional logging control mechanism that doesn't change the API's behavior regarding its return values or the exceptions it might throw. The code change type is thus categorized as 4.","Since the change in code is confined to the debug logging, which does not affect the return value or exception handling of the API, there is no Compatibility Issue. The API will behave the same way in terms of the functional outcome whether the debug logging is enabled or not. Therefore, the CI type is 0."
901,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,30,31,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,0,"{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mPendingService = service;
    try {
        mService.addService(mServerIf, service);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mPendingService = service;
    try {
        mService.addService(mServerIf, service, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the list, the service and its
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>The {@link BluetoothGattServerCallback#onServiceAdded} callback will indicate
 * whether this service has been added successfully. Do not add another service
 * before this callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided by this device.
 * @return true, if the request to add service has been initiated
 */
","/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the list, the service and its
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>The {@link BluetoothGattServerCallback#onServiceAdded} callback will indicate
 * whether this service has been added successfully. Do not add another service
 * before this callback.
 *
 * @param service Service to be added to the list of services provided by this device.
 * @return true, if the request to add service has been initiated
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The code change includes an additional parameter 'mAttributionSource' in the method call mService.addService(mServerIf, service, mAttributionSource); hence, the change type is 4 (Other statement changed) and 5 (Dependent API changed).","The addition of a new parameter to the method call does not change the behavior of the method in terms of its execution flow, return values, or exception handling from the perspective of an application using this API. Therefore, there is no Compatibility Issue (CI type 0)."
902,<android.app.Activity: void reportFullyDrawn()>,30,31,<android.app.Activity: void reportFullyDrawn()>,<android.app.Activity: void reportFullyDrawn()>,0,"{
    if (mDoReportFullyDrawn) {
        mDoReportFullyDrawn = false;
        try {
            ActivityTaskManager.getService().reportActivityFullyDrawn(mToken, mRestoredFromBundle);
            VMRuntime.getRuntime().notifyStartupCompleted();
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDoReportFullyDrawn) {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""reportFullyDrawn() for "" + mComponent.toShortString());
        }
        mDoReportFullyDrawn = false;
        try {
            ActivityClient.getInstance().reportActivityFullyDrawn(mToken, mRestoredFromBundle);
            VMRuntime.getRuntime().notifyStartupCompleted();
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        }
    }
}",1,"/**
 * Report to the system that your app is now fully drawn, for diagnostic and
 * optimization purposes.  The system may adjust optimizations to prioritize
 * work that happens before reportFullyDrawn is called, to improve app startup.
 * Misrepresenting the startup window by calling reportFullyDrawn too late or too
 * early may decrease application and startup performance.<p>
 * This is also used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 * <p>If this method is called before the activity's window is <em>first</em> drawn
 * and displayed as measured by the system, the reported time here will be shifted
 * to the system measured time.
 */
","/**
 * Report to the system that your app is now fully drawn, for diagnostic and
 * optimization purposes.  The system may adjust optimizations to prioritize
 * work that happens before reportFullyDrawn is called, to improve app startup.
 * Misrepresenting the startup window by calling reportFullyDrawn too late or too
 * early may decrease application and startup performance.<p>
 * This is also used to help instrument application launch times, so that the
 * app can report when it is fully in a usable state; without this, the only thing
 * the system itself can determine is the point at which the activity's window
 * is <em>first</em> drawn and displayed.  To participate in app launch time
 * measurement, you should always call this method after first launch (when
 * {@link #onCreate(android.os.Bundle)} is called), at the point where you have
 * entirely drawn your UI and populated with all of the significant data.  You
 * can safely call this method any time after first launch as well, in which case
 * it will simply be ignored.
 * <p>If this method is called before the activity's window is <em>first</em> drawn
 * and displayed as measured by the system, the reported time here will be shifted
 * to the system measured time.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,The late implementation has added a new conditional check for a Trace flag and a try-finally block to include Trace.traceBegin and Trace.traceEnd methods around the existing functionality. The call to the ActivityTaskManager.getService().reportActivityFullyDrawn has been replaced with ActivityClient.getInstance().reportActivityFullyDrawn. These changes reflect in changes of type 3 (Control dependency changed) due to the additional Trace check and 4 (Other statement changed) due to the new Trace methods and the replacement of the reportActivityFullyDrawn method.,"Although there are some changes in the implementation, these changes do not directly affect the behavior of the public API in terms of changing the return variable or the exceptions thrown. The new control dependency is only for tracing purposes and will not impact the API's return value or the exceptions it might throw. The main functionality of the API remains the same, as the sequence of calling reportActivityFullyDrawn and notifyStartupCompleted has not been altered. Therefore, there is no Compatibility Issue arising from the code change."
903,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",30,31,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.PBAP:
            BluetoothPbap pbap = (BluetoothPbap) proxy;
            pbap.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}","{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.PBAP:
            BluetoothPbap pbap = (BluetoothPbap) proxy;
            pbap.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
            break;
        case BluetoothProfile.LE_AUDIO:
            BluetoothLeAudio leAudio = (BluetoothLeAudio) proxy;
            leAudio.close();
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,"[@SuppressLint({ ""AndroidFrameworkRequiresPermission"", ""AndroidFrameworkBluetoothPermission"" })]",-1,-1,-1,-1,-1,-1,,,,
904,"<android.text.format.DateUtils: String getDayOfWeekString(int,int)>",30,31,"<android.text.format.DateUtils: String getDayOfWeekString(int,int)>","<android.text.format.DateUtils: String getDayOfWeekString(int,int)>",0,"{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longWeekdayNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORT:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORTER:
            names = d.shortWeekdayNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyWeekdayNames;
            break;
        default:
            names = d.shortWeekdayNames;
            break;
    }
    return names[dayOfWeek];
}","{
    DateFormatSymbols dfs = DateFormatSymbols.getInstance();
    final int width;
    switch(abbrev) {
        case LENGTH_LONG:
            width = DateFormatSymbols.WIDE;
            break;
        case LENGTH_SHORTEST:
            width = DateFormatSymbols.NARROW;
            break;
        case LENGTH_MEDIUM:
        // TODO
        case LENGTH_SHORT:
        // TODO
        case LENGTH_SHORTER:
        default:
            width = DateFormatSymbols.ABBREVIATED;
            break;
    }
    return dfs.getWeekdays(DateFormatSymbols.FORMAT, width)[dayOfWeek];
}",1,"/**
 * Return a string for the day of the week.
 * @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},
 * {@link Calendar#MONDAY Calendar.MONDAY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},
 * {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.
 * Note that in most languages, {@link #LENGTH_SHORT}
 * will return the same as {@link #LENGTH_MEDIUM}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
","/**
 * Return a string for the day of the week.
 * @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},
 * {@link Calendar#MONDAY Calendar.MONDAY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},
 * {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.
 * Note that in most languages, {@link #LENGTH_SHORT}
 * will return the same as {@link #LENGTH_MEDIUM}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5",1,"The type of data structure used to store weekday names has been changed from 'LocaleData' to 'DateFormatSymbols'; the way to get the weekday names has been altered, and the abbreviated names are now retrieved using the 'getWeekdays(DateFormatSymbols.FORMAT, width)' method with defined 'width' constants. Also, the 'switch' cases' assignment to 'names' variable has changed to direct 'return' with specific constants. Additionally, there are changes in the assignment of equivalent lengths (e.g., LENGTH_LONG now maps to DateFormatSymbols.WIDE), and new constants are used to get the abbreviated names. Altogether, this is a change in dependent API, return statements, and control dependency. Therefore, the change type is classified as 1,3,5.","Because the method of obtaining the week names has changed significantly, it could lead to different values being returned. Different mappings for the length of abbreviations are used, and the resulting string values that correspond to the 'dayOfWeek' index may differ between implementations. Consequently, these changes could cause the API to return different values between version 30 and 31. Thus, the CI type is 1."
905,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,30,31,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,<com.android.server.backup.PreferredActivityBackupHelper: byte[] getBackupPayload(String)>,0,"{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        // TODO: http://b/22388012
        switch(key) {
            case KEY_PREFERRED:
                return pm.getPreferredActivityBackup(UserHandle.USER_SYSTEM);
            case KEY_DEFAULT_APPS:
                return pm.getDefaultAppsBackup(UserHandle.USER_SYSTEM);
            case KEY_INTENT_VERIFICATION:
                return pm.getIntentFilterVerificationBackup(UserHandle.USER_SYSTEM);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key);
    }
    return null;
}","{
    IPackageManager pm = AppGlobals.getPackageManager();
    if (DEBUG) {
        Slog.d(TAG, ""Handling backup of "" + key);
    }
    try {
        switch(key) {
            case KEY_PREFERRED:
                return pm.getPreferredActivityBackup(mUserId);
            case KEY_DEFAULT_APPS:
                return pm.getDefaultAppsBackup(mUserId);
            case KEY_INTENT_VERIFICATION:
                // Deprecated
                return null;
            case KEY_DOMAIN_VERIFICATION:
                return pm.getDomainVerificationBackup(mUserId);
            default:
                Slog.w(TAG, ""Unexpected backup key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to store payload "" + key, e);
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There is a change in the switch control structure with a case 'KEY_INTENT_VERIFICATION' returning null instead of calling a method on pm object. A new case 'KEY_DOMAIN_VERIFICATION' is added as well. Additionally, 'UserHandle.USER_SYSTEM' has been replaced with 'mUserId', and there is a new parameter to the log statement in the catch block (e), making this change type 1,3,4,5.","The change in the behavior of case 'KEY_INTENT_VERIFICATION' to return null directly instead of calling pm.getIntentFilterVerificationBackup() and the change in the parameter from a constant UserHandle.USER_SYSTEM to a variable mUserId for other cases will cause the method to potentially return different values, so the CI type is 1."
906,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged(boolean)>,30,31,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged(boolean)>,<android.service.wallpaper.WallpaperService.Engine: void doOffsetsChanged(boolean)>,0,"{
    if (mDestroyed) {
        return;
    }
    if (!always && !mOffsetsChanged) {
        return;
    }
    float xOffset;
    float yOffset;
    float xOffsetStep;
    float yOffsetStep;
    boolean sync;
    synchronized (mLock) {
        xOffset = mPendingXOffset;
        yOffset = mPendingYOffset;
        xOffsetStep = mPendingXOffsetStep;
        yOffsetStep = mPendingYOffsetStep;
        sync = mPendingSync;
        mPendingSync = false;
        mOffsetMessageEnqueued = false;
    }
    if (mSurfaceCreated) {
        if (mReportedVisible) {
            if (DEBUG)
                Log.v(TAG, ""Offsets change in "" + this + "": "" + xOffset + "","" + yOffset);
            final int availw = mIWallpaperEngine.mReqWidth - mCurWidth;
            final int xPixels = availw > 0 ? -(int) (availw * xOffset + .5f) : 0;
            final int availh = mIWallpaperEngine.mReqHeight - mCurHeight;
            final int yPixels = availh > 0 ? -(int) (availh * yOffset + .5f) : 0;
            onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixels, yPixels);
        } else {
            mOffsetsChanged = true;
        }
    }
    if (sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting offsets change complete"");
            mSession.wallpaperOffsetsComplete(mWindow.asBinder());
        } catch (RemoteException e) {
        }
    }
}","{
    if (mDestroyed) {
        return;
    }
    if (!always && !mOffsetsChanged) {
        return;
    }
    float xOffset;
    float yOffset;
    float xOffsetStep;
    float yOffsetStep;
    boolean sync;
    synchronized (mLock) {
        xOffset = mPendingXOffset;
        yOffset = mPendingYOffset;
        xOffsetStep = mPendingXOffsetStep;
        yOffsetStep = mPendingYOffsetStep;
        sync = mPendingSync;
        mPendingSync = false;
        mOffsetMessageEnqueued = false;
    }
    if (mSurfaceCreated) {
        if (mReportedVisible) {
            if (DEBUG)
                Log.v(TAG, ""Offsets change in "" + this + "": "" + xOffset + "","" + yOffset);
            final int availw = mIWallpaperEngine.mReqWidth - mCurWidth;
            final int xPixels = availw > 0 ? -(int) (availw * xOffset + .5f) : 0;
            final int availh = mIWallpaperEngine.mReqHeight - mCurHeight;
            final int yPixels = availh > 0 ? -(int) (availh * yOffset + .5f) : 0;
            onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixels, yPixels);
        } else {
            mOffsetsChanged = true;
        }
    }
    if (sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting offsets change complete"");
            mSession.wallpaperOffsetsComplete(mWindow.asBinder());
        } catch (RemoteException e) {
        }
    }
    // setup local color extraction data
    processLocalColors(xOffset, xOffsetStep);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call, processLocalColors(xOffset, xOffsetStep), has been added at the end of the late version implementation without changing any control flow or return statements. That suggests code change type 4.","Since the new method call does not alter any existing control flows, return statements, or exception handling mechanisms, it does not introduce a compatibility issue as per the information provided. Thus, the CI type is 0."
907,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getConnectedDevices()>,30,31,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHearingAid: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (VDBG)
        log(""getConnectedDevices()"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled()) {
            return service.getConnectedDevices();
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    final IBluetoothHearingAid service = getService();
    try {
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, ""Proxy not attached to service"");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@Override, @NonNull]","[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT), @NonNull]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method body's return statement has been altered with a call to Attributable.setAttributionSource() wrapping around the service.getConnectedDevices() call and passing the mAttributionSource as a parameter. This is a change in the dependent API (type 5), as service.getConnectedDevices() now has additional behavior through Attributable.setAttributionSource(). There is potential manipulation of the returned list (type 1). Additionally, other statements have been changed, since new code was introduced that does not change control flow but affects how the return value is processed (type 4).","The introduction of Attributable.setAttributionSource() on the return value might affect the returned list of devices by modifying their attribution sources. Consequently, different return values might be passed back to the callers of this method between the two versions, indicating a compatibility issue of type 1."
908,<android.view.Display: int getRotation()>,30,31,<android.view.Display: int getRotation()>,<android.view.Display: int getRotation()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getRotation(mDisplayInfo.rotation) : mDisplayInfo.rotation;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mMayAdjustByFixedRotation ? getDisplayAdjustments().getRotation(mDisplayInfo.rotation) : mDisplayInfo.rotation;
    }
}",1,"/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
","/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
",-1,[@Surface.Rotation],[@Surface.Rotation],-1,-1,-1,-1,-1,-1,4,0,"The only change in the implementation is the lock object in the synchronized block. In the early version, it uses 'this', while in the late version, it uses a different lock object 'mLock'. This is an internal synchronization detail that doesn't affect the external behavior of the method. Therefore, the code change type is 4.","This change only affects which object is used for synchronization and doesn't affect the methodâ€™s return values or exception handling. Thus, it does not introduce a Compatibility Issue, and the CI type is 0."
909,<android.provider.CallLog.Calls: String getLastOutgoingCall(Context)>,30,31,<android.provider.CallLog.Calls: String getLastOutgoingCall(Context)>,<android.provider.CallLog.Calls: String getLastOutgoingCall(Context)>,0,"{
    final ContentResolver resolver = context.getContentResolver();
    Cursor c = null;
    try {
        c = resolver.query(CONTENT_URI, new String[] { NUMBER }, TYPE + "" = "" + OUTGOING_TYPE, null, DEFAULT_SORT_ORDER + "" LIMIT 1"");
        if (c == null || !c.moveToFirst()) {
            return """";
        }
        return c.getString(0);
    } finally {
        if (c != null)
            c.close();
    }
}","{
    final ContentResolver resolver = context.getContentResolver();
    Cursor c = null;
    try {
        c = resolver.query(CONTENT_URI_LIMIT_1, new String[] { NUMBER }, TYPE + "" = "" + OUTGOING_TYPE, null, DEFAULT_SORT_ORDER);
        if (c == null || !c.moveToFirst()) {
            return """";
        }
        return c.getString(0);
    } finally {
        if (c != null)
            c.close();
    }
}",1,"/**
 * Query the call log database for the last dialed number.
 * @param context Used to get the content resolver.
 * @return The last phone number dialed (outgoing) or an empty
 * string if none exist yet.
 */
","/**
 * Query the call log database for the last dialed number.
 * @param context Used to get the content resolver.
 * @return The last phone number dialed (outgoing) or an empty
 * string if none exist yet.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter passed to the query function has been changed from CONTENT_URI with ""LIMIT 1"" as part of the sort order to CONTENT_URI_LIMIT_1 without ""LIMIT 1"" in the sort order, indicating that the underlying URI might have changed to always limit the results to 1. As such, a change has been made to a dependent API (the URI being queried), which is why the code change type includes 1 and 5.","The change in the URI (CONTENT_URI vs. CONTENT_URI_LIMIT_1) that's being queried may affect the result returned by the query, and therefore the return value of the `getLastOutgoingCall` method may potentially be different. Thus, a CI occurs due to the potential different return values, and the CI type is 1."
911,<android.content.Intent: Intent getIntentOld(String)>,30,31,<android.content.Intent: Intent getIntentOld(String)>,<android.content.Intent: Intent getIntentOld(String)>,0,"{
    return getIntentOld(uri, 0);
}","{
    Intent intent = getIntentOld(uri, 0);
    intent.mLocalFlags |= LOCAL_FLAG_FROM_URI;
    return intent;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is an addition of a new statement that modifies the 'intent' variable before it is returned, by setting a flag, so the code change type is 4.","The change includes setting a flag on the 'intent' object before returning it, which makes the method potentially return an 'Intent' object with different internal state, and hence, the CI type is 1."
912,<android.hardware.lights.LightsRequest.Builder: Builder clearLight(Light)>,30,31,<android.hardware.lights.LightsRequest.Builder: Builder clearLight(Light)>,<android.hardware.lights.LightsRequest.Builder: Builder clearLight(Light)>,0,"{
    Preconditions.checkNotNull(light);
    mChanges.put(light.getId(), null);
    return this;
}","{
    Preconditions.checkNotNull(light);
    mChanges.put(light, null);
    return this;
}",1,"/**
 * Removes the override for the color and intensity of a given light.
 *
 * @param light the light to modify
 */
","/**
 * Removes the override for the color and intensity of a given light.
 *
 * @param light the light to modify
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a change in the method call for putting an item in the map (from light.getId() to light directly), so the code change type is 4. This is also considered a change in the dependent API because the map's key type has potentially changed from an integer (assuming getId() returns an integer) to a Light object, so the change type is 5.","There is no Compatibility Issue since the change does not affect the value returned by the method or the exceptions it might throw. The behavior of 'clearLight' method in terms of how it affects the 'mChanges' map will practically remain the same from the caller's perspective since it still stores a mapping that represents clearing a light (whether by id or the Light object doesn't affect the outcome). Thus, no CI is detected, and the code can handle Light objects directly, which is an internal detail not affecting API consumers."
913,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",30,31,"<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>","<android.app.ContextImpl: void sendBroadcastAsUser(Intent,UserHandle,String,int)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    String[] receiverPermissions = receiverPermission == null ? null : new String[] { receiverPermission };
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        appOp, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is in the ordering of the parameters for the method call to 'broadcastIntentWithFeature', specifically a ""null"" parameter has been added and the parameter `appOp` has been moved after this new `null` comment. This is an example of Other statement changed type 4.","This change does not affect the return type or value, nor does it introduce any new behavior in exception handling within this API. Therefore, there is no Compatibility Issue, so the CI type is 0."
915,<android.widget.TextView: void setCursorVisible(boolean)>,30,31,<android.widget.TextView: void setCursorVisible(boolean)>,<android.widget.TextView: void setCursorVisible(boolean)>,0,"{
    // visible is the default value with no edit data
    if (visible && mEditor == null)
        return;
    createEditorIfNeeded();
    if (mEditor.mCursorVisible != visible) {
        mEditor.mCursorVisible = visible;
        invalidate();
        mEditor.makeBlink();
        // InsertionPointCursorController depends on mCursorVisible
        mEditor.prepareCursorControllers();
    }
}","{
    mCursorVisibleFromAttr = visible;
    updateCursorVisibleInternal();
}",1,"/**
 * Set whether the cursor is visible. The default is true. Note that this property only
 * makes sense for editable TextView.
 *
 * @see #isCursorVisible()
 *
 * @attr ref android.R.styleable#TextView_cursorVisible
 */
","/**
 * Set whether the cursor is visible. The default is true. Note that this property only
 * makes sense for editable TextView. If IME is consuming the input, the cursor will always be
 * invisible, visibility will be updated as the last state when IME does not consume
 * the input anymore.
 *
 * @see #isCursorVisible()
 *
 * @attr ref android.R.styleable#TextView_cursorVisible
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"1,5",1,"The late implementation no longer has a conditional check or direct modifications to properties of `mEditor` object and calls to methods like `invalidate()` and `prepareCursorControllers()`. Instead, it sets a flag and calls a new method `updateCursorVisibleInternal()`. It's a sign of dependent API changed since the implementation now depends on this new method, and the return statement change classification occurs as the behavior and flow are changed. Thus, the code change types are 1,5.","Since the new implementation changes the flow of how the cursor visibility is set and there are no checks or method calls like in the earlier implementation, there is a potential compatibility issue due to different return values or types as the method might now behave differently especially if `updateCursorVisibleInternal()` has a different implementation than the previous direct field modification and method calls. Therefore, the CI type is 1."
916,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,30,31,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,<android.bluetooth.BluetoothGatt: boolean readCharacteristic(BluetoothGattCharacteristic)>,0,"{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, ""readCharacteristic() - uuid: "" + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method signature remains unchanged, but the call to mService.readCharacteristic(...) includes an extra parameter mAttributionSource in the late version. The change to the dependent API call without altering the method signature indicates the change type is 4. Since the annotations have added requirements for certain permissions (@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)) in the late version, it is also a change type 5; however, these annotation changes don't affect the runtime behavior of the API, but rather the requirements to use the API at compile time or before.","No Compatibility Issue should arise due to the introduced parameter mAttributionSource, as this appears to be an implementation detail and should not affect the method's output or error handling from the perspective of the API consumer. The annotations change the requirements for calling the method but do not influence the functionality of the method itself once permissions are properly handled. Therefore, the compatibility remains intact, and no CI is introduced due to these changes."
917,<android.content.ClipData: void addItem(Item)>,30,31,<android.content.ClipData: void addItem(Item)>,<android.content.ClipData: void addItem(Item)>,0,"{
    if (item == null) {
        throw new NullPointerException(""item is null"");
    }
    mItems.add(item);
}","{
    if (item == null) {
        throw new NullPointerException(""item is null"");
    }
    mItems.add(item);
    if (mItems.size() == 1) {
        mClipDescription.setIsStyledText(isStyledText());
    }
}",1,"/**
 * Add a new Item to the overall ClipData container.
 * <p> This method will <em>not</em> update the list of available MIME types in the
 * {@link ClipDescription}. It should be used only when adding items which do not add new
 * MIME types to this clip. If this is not the case, use {@link #addItem(ContentResolver, Item)}
 * or call {@link #ClipData(CharSequence, String[], Item)} with a complete list of MIME types.
 * @param item Item to be added.
 */
","/**
 * Add a new Item to the overall ClipData container.
 * <p> This method will <em>not</em> update the list of available MIME types in the
 * {@link ClipDescription}. It should be used only when adding items which do not add new
 * MIME types to this clip. If this is not the case, use {@link #addItem(ContentResolver, Item)}
 * or call {@link #ClipData(CharSequence, String[], Item)} with a complete list of MIME types.
 * @param item Item to be added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the API includes a new if condition and a method call (mClipDescription.setIsStyledText()), so the change type is 3 (control dependency change) and 4 (other statement changed).","Despite the changes, the behaviour of the method addItem(Item) in respect to adding an item and throwing potential exceptions when 'item' is null remains the same. The new if condition checks for the size of 'mItems' and applies a style if there is only one item, but it doesn't affect the return type or value of the method, and no exception handling related to this new condition is added. As a result, there is no Compatibility Issue; hence, CI type is 0."
918,<android.view.inputmethod.InlineSuggestion: boolean equals(Object)>,30,31,<android.view.inputmethod.InlineSuggestion: boolean equals(Object)>,<android.view.inputmethod.InlineSuggestion: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestion that = (InlineSuggestion) o;
    // noinspection PointlessBooleanExpression
    return true && java.util.Objects.equals(mInfo, that.mInfo) && java.util.Objects.equals(mContentProvider, that.mContentProvider) && java.util.Objects.equals(mInlineContentCallback, that.mInlineContentCallback);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestion that = (InlineSuggestion) o;
    // noinspection PointlessBooleanExpression
    return true && java.util.Objects.equals(mInfo, that.mInfo) && java.util.Objects.equals(mContentProvider, that.mContentProvider) && java.util.Objects.equals(mInlineContentCallback, that.mInlineContentCallback) && java.util.Objects.equals(mInlineTooltipUi, that.mInlineTooltipUi);
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,1,"An additional call to java.util.Objects.equals for mInlineTooltipUi has been added to the return statement, which is not a control dependency, exception handling, or a dependent API change. Hence, the change type is 4 (Other statement changed).","The addition of a new comparison in the return statement could potentially lead to a different return value when checking for equality, as there is a new field included in the comparison that may not exist or be equal in the object being compared. This is classified as a CI type 1 (Compatibility Issue caused by potential different return values or types)."
919,<android.app.WallpaperColors: WallpaperColors fromBitmap(Bitmap)>,30,31,<android.app.WallpaperColors: WallpaperColors fromBitmap(Bitmap)>,<android.app.WallpaperColors: WallpaperColors fromBitmap(Bitmap)>,0,"{
    if (bitmap == null) {
        throw new IllegalArgumentException(""Bitmap can't be null"");
    }
    final int bitmapArea = bitmap.getWidth() * bitmap.getHeight();
    boolean shouldRecycle = false;
    if (bitmapArea > MAX_WALLPAPER_EXTRACTION_AREA) {
        shouldRecycle = true;
        Size optimalSize = calculateOptimalSize(bitmap.getWidth(), bitmap.getHeight());
        bitmap = Bitmap.createScaledBitmap(bitmap, optimalSize.getWidth(), optimalSize.getHeight(), true);
    }
    final Palette palette = Palette.from(bitmap).setQuantizer(new VariationalKMeansQuantizer()).maximumColorCount(5).clearFilters().resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    // Remove insignificant colors and sort swatches by population
    final ArrayList<Palette.Swatch> swatches = new ArrayList<>(palette.getSwatches());
    final float minColorArea = bitmap.getWidth() * bitmap.getHeight() * MIN_COLOR_OCCURRENCE;
    swatches.removeIf(s -> s.getPopulation() < minColorArea);
    swatches.sort((a, b) -> b.getPopulation() - a.getPopulation());
    final int swatchesSize = swatches.size();
    Color primary = null, secondary = null, tertiary = null;
    swatchLoop: for (int i = 0; i < swatchesSize; i++) {
        Color color = Color.valueOf(swatches.get(i).getRgb());
        switch(i) {
            case 0:
                primary = color;
                break;
            case 1:
                secondary = color;
                break;
            case 2:
                tertiary = color;
                break;
            default:
                // out of bounds
                break swatchLoop;
        }
    }
    int hints = calculateDarkHints(bitmap);
    if (shouldRecycle) {
        bitmap.recycle();
    }
    return new WallpaperColors(primary, secondary, tertiary, HINT_FROM_BITMAP | hints);
}","{
    if (bitmap == null) {
        throw new IllegalArgumentException(""Bitmap can't be null"");
    }
    final int bitmapArea = bitmap.getWidth() * bitmap.getHeight();
    boolean shouldRecycle = false;
    if (bitmapArea > MAX_WALLPAPER_EXTRACTION_AREA) {
        shouldRecycle = true;
        Size optimalSize = calculateOptimalSize(bitmap.getWidth(), bitmap.getHeight());
        bitmap = Bitmap.createScaledBitmap(bitmap, optimalSize.getWidth(), optimalSize.getHeight(), false);
    }
    final Palette palette;
    if (ActivityManager.isLowRamDeviceStatic()) {
        palette = Palette.from(bitmap, new VariationalKMeansQuantizer()).maximumColorCount(5).resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    } else {
        palette = Palette.from(bitmap, new CelebiQuantizer()).maximumColorCount(128).resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    }
    // Remove insignificant colors and sort swatches by population
    final ArrayList<Palette.Swatch> swatches = new ArrayList<>(palette.getSwatches());
    swatches.sort((a, b) -> b.getPopulation() - a.getPopulation());
    final int swatchesSize = swatches.size();
    final Map<Integer, Integer> populationByColor = new HashMap<>();
    for (int i = 0; i < swatchesSize; i++) {
        Palette.Swatch swatch = swatches.get(i);
        int colorInt = swatch.getInt();
        populationByColor.put(colorInt, swatch.getPopulation());
    }
    int hints = calculateDarkHints(bitmap);
    if (shouldRecycle) {
        bitmap.recycle();
    }
    return new WallpaperColors(populationByColor, HINT_FROM_BITMAP | hints);
}",1,"/**
 * Constructs {@link WallpaperColors} from a bitmap.
 * <p>
 * Main colors will be extracted from the bitmap.
 *
 * @param bitmap Source where to extract from.
 */
","/**
 * Constructs {@link WallpaperColors} from a bitmap.
 * <p>
 * Main colors will be extracted from the bitmap.
 *
 * @param bitmap Source where to extract from.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The implementation method has multiple changes including changes in the return statement, control dependency, and other statements, as well as changes to the dependent API. The boolean parameter in Bitmap.createScaledBitmap(...) has changed from true to false. A new control dependency on ActivityManager.isLowRamDeviceStatic() has been introduced, and a new Palette initialization approach with either VariationalKMeansQuantizer or CelebiQuantizer depending on the device's memory status. Moreover, the instantiation of the WallpaperColors object in the return statement now takes the populationByColor Map instead of separate Color elements and the constructor of WallpaperColors itself is a dependent API that has changed. Therefore, the pred_change is classified into 1,3,4,5.","As the way the WallpaperColors object is instantiated in the return statement has changed and the parameters passed to its constructor differ, this could potentially lead to a change in the return value. The control dependency change could also cause a different code execution path leading to potentially different return values. In addition, the dependent API changed as a different constructor of WallpaperColors seems to be used. As a result, there is a Compatibility Issue due to potential different return values, and hence the CI type is 1."
920,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,30,31,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    final int actionMasked = ev.getActionMasked();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroll != null && mFastScroll.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                mNestedYOffset = 0;
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, null)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                stopNestedScroll();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    final int actionMasked = ev.getActionMasked();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroll != null && mFastScroll.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (isGlowActive()) {
                    // Pressed during edge effect, so this is considered the same as a fling catch.
                    touchMode = mTouchMode = TOUCH_MODE_FLING;
                } else if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                mNestedYOffset = 0;
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, null)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                stopNestedScroll();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
921,<android.view.inputmethod.InlineSuggestionInfo: boolean equals(Object)>,30,31,<android.view.inputmethod.InlineSuggestionInfo: boolean equals(Object)>,<android.view.inputmethod.InlineSuggestionInfo: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestionInfo that = (InlineSuggestionInfo) o;
    // noinspection PointlessBooleanExpression
    return true && java.util.Objects.equals(mInlinePresentationSpec, that.mInlinePresentationSpec) && java.util.Objects.equals(mSource, that.mSource) && java.util.Arrays.equals(mAutofillHints, that.mAutofillHints) && java.util.Objects.equals(mType, that.mType) && mPinned == that.mPinned;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") InlineSuggestionInfo that = (InlineSuggestionInfo) o;
    // noinspection PointlessBooleanExpression
    return true && java.util.Objects.equals(mInlinePresentationSpec, that.mInlinePresentationSpec) && java.util.Objects.equals(mSource, that.mSource) && java.util.Arrays.equals(mAutofillHints, that.mAutofillHints) && java.util.Objects.equals(mType, that.mType) && mPinned == that.mPinned && java.util.Objects.equals(mTooltip, that.mTooltip);
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,"1,4",1,"The method now includes additional comparison of 'mTooltip' using java.util.Objects.equals, thus changing the logic of the method. This is classified under Other statement changed (4) and since it affects the return value, it's also classified as Return statement changed (1).","The change in the equals method could potentially lead to a different return value when comparing InlineSuggestionInfo objects, particularly in cases where 'mTooltip' is different but all other compared fields are equal. This could break equality checks between objects of this class in the new version. Therefore, the CI type is 1."
922,<android.hardware.camera2.params.InputConfiguration: String toString()>,30,31,<android.hardware.camera2.params.InputConfiguration: String toString()>,<android.hardware.camera2.params.InputConfiguration: String toString()>,0,"{
    return String.format(""InputConfiguration(w:%d, h:%d, format:%d)"", mWidth, mHeight, mFormat);
}","{
    return String.format(""InputConfiguration(w:%d, h:%d, format:%d, isMultiResolution %b)"", mWidth, mHeight, mFormat, mIsMultiResolution);
}",1,"/**
 * Return this {@link InputConfiguration} as a string representation.
 *
 * <p> {@code ""InputConfiguration(w:%d, h:%d, format:%d)""}, where {@code %d} represents
 * the width, height, and format, respectively.</p>
 *
 * @return string representation of {@link InputConfiguration}
 */
","/**
 * Return this {@link InputConfiguration} as a string representation.
 *
 * <p> {@code ""InputConfiguration(w:%d, h:%d, format:%d, isMultiResolution:%d)""},
 * where {@code %d} represents the width, height, format, and multi-resolution flag
 * respectively.</p>
 *
 * @return string representation of {@link InputConfiguration}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement format is changed with the addition of 'mIsMultiResolution' in the late version, which results in a different string format being returned. Therefore, the change type is 1.","The inclusion of an additional piece of data ('mIsMultiResolution') in the 'toString' result will cause the method to return a different value than before. Consequently, the CI type is 1."
923,<android.text.format.Formatter: String formatIpAddress(int)>,30,31,<android.text.format.Formatter: String formatIpAddress(int)>,<android.text.format.Formatter: String formatIpAddress(int)>,0,"{
    return NetworkUtils.intToInetAddress(ipv4Address).getHostAddress();
}","{
    return Inet4AddressUtils.intToInet4AddressHTL(ipv4Address).getHostAddress();
}",1,"/**
 * Returns a string in the canonical IPv4 format ###.###.###.### from a packed integer
 * containing the IP address. The IPv4 address is expected to be in little-endian
 * format (LSB first). That is, 0x01020304 will return ""4.3.2.1"".
 *
 * @deprecated Use {@link java.net.InetAddress#getHostAddress()}, which supports both IPv4 and
 * IPv6 addresses. This method does not support IPv6 addresses.
 */
","/**
 * Returns a string in the canonical IPv4 format ###.###.###.### from a packed integer
 * containing the IP address. The IPv4 address is expected to be in little-endian
 * format (LSB first). That is, 0x01020304 will return ""4.3.2.1"".
 *
 * @deprecated Use {@link java.net.InetAddress#getHostAddress()}, which supports both IPv4 and
 * IPv6 addresses. This method does not support IPv6 addresses.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changed from using `NetworkUtils.intToInetAddress` to `Inet4AddressUtils.intToInet4AddressHTL`. No control statements, return statements, or exception handling have been altered directly within the method (although the function name and possibly the implemention it calls have changed). This is classified as code change type 4 (Other statement changed) and type 5 (Dependent API changed) because of the change in the dependent function being utilized.","There is no apparent change that directly affects the behavior of the method regarding its return type or the exceptions it throws. Unless `Inet4AddressUtils.intToInet4AddressHTL` has different behavior concerning the return value compared to `NetworkUtils.intToInetAddress`, which we cannot verify from the provided information alone, the compatibility issue would not be present. It is assumed that the wrapper merely reflects an internal refactoring without changing the contract of the formatting of the IP address. Hence, we conclude that there is no compatibility issue (0). If there were differences in the behavior of these two methods, which cannot be concluded from the given information, there would be a compatibility issue, but for the rule of strict interpretation, we are led to conclude no CI."
925,<android.os.HandlerThread: Looper getLooper()>,30,31,<android.os.HandlerThread: Looper getLooper()>,<android.os.HandlerThread: Looper getLooper()>,0,"{
    if (!isAlive()) {
        return null;
    }
    // If the thread has been started, wait until the looper has been created.
    synchronized (this) {
        while (isAlive() && mLooper == null) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
    }
    return mLooper;
}","{
    if (!isAlive()) {
        return null;
    }
    boolean wasInterrupted = false;
    // If the thread has been started, wait until the looper has been created.
    synchronized (this) {
        while (isAlive() && mLooper == null) {
            try {
                wait();
            } catch (InterruptedException e) {
                wasInterrupted = true;
            }
        }
    }
    /*
         * We may need to restore the thread's interrupted flag, because it may
         * have been cleared above since we eat InterruptedExceptions
         */
    if (wasInterrupted) {
        Thread.currentThread().interrupt();
    }
    return mLooper;
}",1,"/**
 * This method returns the Looper associated with this thread. If this thread not been started
 * or for any reason isAlive() returns false, this method will return null. If this thread
 * has been started, this method will block until the looper has been initialized.
 * @return The looper.
 */
","/**
 * This method returns the Looper associated with this thread. If this thread not been started
 * or for any reason isAlive() returns false, this method will return null. If this thread
 * has been started, this method will block until the looper has been initialized.
 * @return The looper.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The introduction of the variable `wasInterrupted` and setting the interrupted status of the current thread when `wasInterrupted` is true, are additional operations that do not affect the main functionality, so these are under 'Other statement changed' which is type 4. Additionally, by introducing the 'if (wasInterrupted)' check, a control dependency has been added, which falls under 'Control dependency change' which is type 3.","These code changes do not introduce a Compatibility Issue since the API still returns `mLooper` regardless of the introduction of the new variable and the additional logic to reset the thread's interrupt status. The logic flow and the method contract remain the same: it returns the `mLooper` if the thread is alive, or `null` if it's not. The handling of `InterruptedException` has been slightly changed but this does not affect the API's behavior from the caller's perspective, as `InterruptedException` was caught and ignored in both versions."
927,<android.app.UiAutomation: void setOnAccessibilityEventListener(OnAccessibilityEventListener)>,30,31,<android.app.UiAutomation: void setOnAccessibilityEventListener(OnAccessibilityEventListener)>,<android.app.UiAutomation: void setOnAccessibilityEventListener(OnAccessibilityEventListener)>,0,"{
    synchronized (mLock) {
        mOnAccessibilityEventListener = listener;
    }
}","{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
        mOnAccessibilityEventListener = listener;
    }
}",1,"/**
 * Sets a callback for observing the stream of {@link AccessibilityEvent}s.
 * The callbacks are delivered on the main application thread.
 *
 * @param listener The callback.
 */
","/**
 * Sets a callback for observing the stream of {@link AccessibilityEvent}s.
 * The callbacks are delivered on the main application thread.
 *
 * @param listener The callback.
 *
 * @throws IllegalStateException If the connection to the accessibility subsystem is not
 * established.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"A new method call throwIfNotConnectedLocked() is introduced inside the synchronized block, which is an exception handling change (type 2). This also qualifies as an ""other statement changed"" (type 4) since it is an addition of a new operation in the existing method body.",The new method call throwIfNotConnectedLocked() potentially throws an exception before the existing behavior of assigning a value to mOnAccessibilityEventListener can occur. This represents a CI caused by potential different exception handling (type 2).
928,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",30,31,"<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>","<android.widget.SelectionActionModeHelper.SelectionTracker: boolean resetSelection(int,Editor)>",0,"{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            final int[] sortedSelectionIndices = sortSelctionIndicesFromTextView(textView);
            mSelectionStart = sortedSelectionIndices[0];
            mSelectionEnd = sortedSelectionIndices[1];
            mLogger.logSelectionAction(sortedSelectionIndices[0], sortedSelectionIndices[1], SelectionEvent.ACTION_RESET, /* actionLabel= */
            null, /* classification= */
            null);
        }
        return selected;
    }
    return false;
}","{
    final TextView textView = editor.getTextView();
    if (isSelectionStarted() && mAllowReset && textIndex >= mSelectionStart && textIndex <= mSelectionEnd && getText(textView) instanceof Spannable) {
        mAllowReset = false;
        boolean selected = editor.selectCurrentWord();
        if (selected) {
            final int[] sortedSelectionIndices = sortSelectionIndicesFromTextView(textView);
            mSelectionStart = sortedSelectionIndices[0];
            mSelectionEnd = sortedSelectionIndices[1];
            mLogger.logSelectionAction(sortedSelectionIndices[0], sortedSelectionIndices[1], SelectionEvent.ACTION_RESET, /* actionLabel= */
            null, /* classification= */
            null);
        }
        return selected;
    }
    return false;
}",1,"/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
","/**
 * Returns true if the current smart selection should be reset to normal selection based on
 * information that has been recorded about the original selection and the smart selection.
 * The expected UX here is to allow the user to select a word inside of the smart selection
 * on a single tap.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the early and late versions, besides a slight spelling correction in a method name which doesn't affect the functionality (from sortSelctionIndicesFromTextView to sortSelectionIndicesFromTextView).","Since there is no functional change to the method's implementation, there is no compatibility issue."
929,<android.hardware.biometrics.BiometricPrompt: CharSequence getDescription()>,30,31,<android.hardware.biometrics.BiometricPrompt: CharSequence getDescription()>,<android.hardware.biometrics.BiometricPrompt: CharSequence getDescription()>,0,"{
    return mBundle.getCharSequence(KEY_DESCRIPTION);
}","{
    return mPromptInfo.getDescription();
}",1,"/**
 * Gets the description for the prompt, as set by {@link Builder#setDescription(CharSequence)}.
 * @return The description for the prompt, or null if the prompt has no description.
 */
","/**
 * Gets the description for the prompt, as set by {@link Builder#setDescription(CharSequence)}.
 * @return The description for the prompt, or null if the prompt has no description.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,1,"The method that is being called to obtain the description has changed from mBundle.getCharSequence(KEY_DESCRIPTION) to mPromptInfo.getDescription(), which indicates a Dependent API change, thus the code change type is 5.","Since there is a change in which object and method is providing the description, it could result in a different value being returned, even if the final type (CharSequence) remains the same. This change may cause the method to return a different value, therefore the CI type is 1."
930,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",30,31,"<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.NotificationBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            nm.applyRestore(payload, mUserId);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"");
        }
    }
}","{
    if (DEBUG) {
        Slog.v(TAG, ""Got restore of "" + key);
    }
    if (KEY_NOTIFICATIONS.equals(key)) {
        try {
            INotificationManager nm = INotificationManager.Stub.asInterface(ServiceManager.getService(""notification""));
            nm.applyRestore(payload, mUserId);
        } catch (Exception e) {
            Slog.e(TAG, ""Couldn't communicate with notification manager"", e);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The change is an addition of the exception object to the log statement. This only affects the information logged and does not change the API's behavior.,There are no compatibility issues as the change just provides more information in the log and does not affect the return values or exceptions thrown by the method.
931,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,30,31,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth(), 1.f - ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth(), ev.getY(activePointerIndex) / getHeight());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if (!mScroller.isFinished()) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                final float displacement = ev.getY(activePointerIndex) / getHeight();
                if (canOverscroll) {
                    int consumed = 0;
                    if (deltaX < 0 && mEdgeGlowRight.getDistance() != 0f) {
                        consumed = Math.round(getWidth() * mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement));
                    } else if (deltaX > 0 && mEdgeGlowLeft.getDistance() != 0f) {
                        consumed = Math.round(-getWidth() * mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1 - displacement));
                    }
                    deltaX -= consumed;
                }
                // Calling overScrollBy will call onOverScrolled, which
                // calls onScrollChanged if applicable.
                overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true);
                if (canOverscroll && deltaX != 0f) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPullDistance((float) -deltaX / getWidth(), 1.f - displacement);
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPullDistance((float) deltaX / getWidth(), displacement);
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (shouldDisplayEdgeEffects()) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
932,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,30,31,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,0,"{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(STATIC_TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDynamicDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(GROUP_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addMimeGroup(name);
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((path = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_ADVANCED_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}","{
    String autoVerify = parser.getAttributeValue(null, AUTO_VERIFY_STR);
    setAutoVerify(TextUtils.isEmpty(autoVerify) ? false : Boolean.getBoolean(autoVerify));
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(STATIC_TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDynamicDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(GROUP_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addMimeGroup(name);
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_ADVANCED_GLOB);
            } else if ((ssp = parser.getAttributeValue(null, SUFFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SUFFIX);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            } else if ((path = parser.getAttributeValue(null, AGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_ADVANCED_GLOB);
            } else if ((path = parser.getAttributeValue(null, SUFFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SUFFIX);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
933,"<android.accessibilityservice.AccessibilityService: void setGestureDetectionPassthroughRegion(int,Region)>",30,31,"<android.accessibilityservice.AccessibilityService: void setGestureDetectionPassthroughRegion(int,Region)>","<android.accessibilityservice.AccessibilityService: void setGestureDetectionPassthroughRegion(int,Region)>",0,"{
    Preconditions.checkNotNull(region, ""region cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.setGestureDetectionPassthroughRegion(displayId, region);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}","{
    Preconditions.checkNotNull(region, ""region cannot be null"");
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(this).getConnection(mConnectionId);
    if (connection != null) {
        try {
            connection.setGestureDetectionPassthroughRegion(displayId, region);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        }
    }
}",1,"/**
 * When {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is enabled, this
 * function requests that touch interactions starting in the specified region of the screen
 * bypass the gesture detector. There can only be one gesture detection passthrough region per
 * display. Requesting a new gesture detection passthrough region clears the existing one. To
 * disable this passthrough and return to the original behavior, pass in an empty region. When
 * {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is disabled this
 * function has no effect.
 *
 * @param displayId The display on which to set this region.
 * @param region the region of the screen.
 */
","/**
 * When {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is enabled, this
 * function requests that touch interactions starting in the specified region of the screen
 * bypass the gesture detector. There can only be one gesture detection passthrough region per
 * display. Requesting a new gesture detection passthrough region clears the existing one. To
 * disable this passthrough and return to the original behavior, pass in an empty region. When
 * {@link AccessibilityServiceInfo#FLAG_REQUEST_TOUCH_EXPLORATION_MODE} is disabled this
 * function has no effect.
 *
 * @param displayId The display on which to set this region.
 * @param region the region of the screen.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The change is in the way the instance of AccessibilityInteractionClient is obtained. In the early version, it is a static method call: AccessibilityInteractionClient.getInstance(). In the late version, it involves passing 'this' as a parameter: AccessibilityInteractionClient.getInstance(this). It does not change the control flow or exception handling of the method, but it does reflect a change in the dependent API.","There is no Compatibility Issue introduced as the change does not affect the method's return value or exception handling behavior; it merely changes how an instance of AccessibilityInteractionClient is retrieved, which should not impact the client-facing behavior of setGestureDetectionPassthroughRegion method."
934,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",30,31,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String,CancellationSignal)>",0,"{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mode, ""mode"");
    try {
        if (mWrapped != null)
            return mWrapped.openAssetFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, mAttributionTag, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, mAttributionTag, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    Objects.requireNonNull(uri, ""uri"");
    Objects.requireNonNull(mode, ""mode"");
    try {
        if (mWrapped != null)
            return mWrapped.openAssetFile(uri, mode, cancellationSignal);
    } catch (RemoteException e) {
        return null;
    }
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mContext.getAttributionSource(), uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mContext.getAttributionSource(), uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the
 * provider recently crashed. You own this descriptor and are responsible for closing it
 * when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*&#47;*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The string representation of the file mode. Can be ""r"", ""w"", ""wt"", ""wa"", ""rw""
 * or ""rwt"". See{@link ParcelFileDescriptor#parseMode} for more details.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file or {@code null} if the
 * provider recently crashed. You own this descriptor and are responsible for closing it
 * when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,,,,
935,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,30,31,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getDynamicShortcuts()>,0,"{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],"[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent method called within the return statement was changed from 'mService.getShortcuts' to 'getFutureOrThrow(mService.getShortcuts)'. Even though this may add additional logic to handle the future result of `getShortcuts`, if the underlying service API and behaviour have not changed, this would not lead to a different return type or value, assuming proper implementation. However, without details about what 'getFutureOrThrow' does internally, it's impossible to fully determine if the behaviour has changed; therefore it's classified under 'Other statement changed' and 'Dependent API changed' which is 4,5.","Without further information on the implementation details of 'getFutureOrThrow', from what is presented, there is no clear indication that a different value or type would be returned or that different exceptions would be thrown, therefore there is no Compatibility Issue; hence, the CI type is 0."
938,"<android.text.format.DateUtils: String getMonthString(int,int)>",30,31,"<android.text.format.DateUtils: String getMonthString(int,int)>","<android.text.format.DateUtils: String getMonthString(int,int)>",0,"{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longMonthNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORT:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTER:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyMonthNames;
            break;
        default:
            names = d.shortMonthNames;
            break;
    }
    return names[month];
}","{
    DateFormatSymbols dfs = DateFormat.getIcuDateFormatSymbols(Locale.getDefault());
    final int width;
    switch(abbrev) {
        case LENGTH_LONG:
            width = DateFormatSymbols.WIDE;
            break;
        case LENGTH_SHORTEST:
            width = DateFormatSymbols.NARROW;
            break;
        case LENGTH_MEDIUM:
        case LENGTH_SHORT:
        case LENGTH_SHORTER:
        default:
            width = DateFormatSymbols.ABBREVIATED;
            break;
    }
    return dfs.getMonths(DateFormatSymbols.FORMAT, width)[month];
}",1,"/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
","/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3,5","1,5","The method implementation has changed significantly, with the use of a completely different class (DateFormatSymbols instead of LocaleData), switch case conditions changed, and the way month names are retrieved. This involves control dependency change (3), other statement change (4), and dependent API change (5).","The change in the dependent API which now uses DateFormatSymbols instead of LocaleData to fetch the month names, different switch case logic and different arrays, introduces potential Compatibility Issue due to different return values or types. Additionally, the underlying data source for the month names has changed. Therefore, there might be a CI due to different return values or types (1) and a change in the dependent API (5)."
940,<android.hardware.camera2.utils.SurfaceUtils: long getSurfaceId(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: long getSurfaceId(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: long getSurfaceId(Surface)>,0,"{
    try {
        return LegacyCameraDevice.getSurfaceId(surface);
    } catch (BufferQueueAbandonedException e) {
        return 0;
    }
}","{
    checkNotNull(surface);
    try {
        return nativeGetSurfaceId(surface);
    } catch (IllegalArgumentException e) {
        return 0;
    }
}",1,"/**
 * Get the native object id of a surface.
 *
 * @param surface The surface to be checked.
 * @return the native object id of the surface, 0 if surface is not backed by a native object.
 */
","/**
 * Get the native object id of a surface.
 *
 * @param surface The surface to be checked.
 * @return the native object id of the surface, 0 if surface is not backed by a native object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The dependent API called within the try block has changed from LegacyCameraDevice.getSurfaceId(surface) to nativeGetSurfaceId(surface), which is a Dependent API changed (5). Additionally, an Other statement changed (4) with the introduction of checkNotNull(surface) before the try block. Moreover, the type of exception caught has changed from BufferQueueAbandonedException to IllegalArgumentException, which is an Exception handling statement changed (2). Finally, the introduced checkNotNull(surface) could potentially throw a NullPointerException, indicated as a new throw statement not explicitly catching it, so it's also marked as a Return statement changed (1).","The change in the dependent API (from LegacyCameraDevice.getSurfaceId to nativeGetSurfaceId) could potentially lead to different values being returned, hence a Compatibility Issue caused by potential different return values or types (1). The change in exception handling (from BufferQueueAbandonedException to IllegalArgumentException) indicates that different exceptions may be thrown for the same inputs, leading to Compatibility Issue caused by potential different exception handlings (2)."
941,"<android.service.autofill.UserData.Builder: Builder add(String,String)>",30,31,"<android.service.autofill.UserData.Builder: Builder add(String,String)>","<android.service.autofill.UserData.Builder: Builder add(String,String)>",0,"{
    throwIfDestroyed();
    checkNotEmpty(""categoryId"", categoryId);
    checkValidValue(value);
    if (!mUniqueCategoryIds.contains(categoryId)) {
        // New category - check size
        Preconditions.checkState(mUniqueCategoryIds.size() < getMaxCategoryCount(), ""already added "" + mUniqueCategoryIds.size() + "" unique category ids"");
    }
    Preconditions.checkState(mValues.size() < getMaxUserDataSize(), ""already added "" + mValues.size() + "" elements"");
    addMapping(value, categoryId);
    return this;
}","{
    throwIfDestroyed();
    checkNotEmpty(""categoryId"", categoryId);
    checkValidValue(value);
    if (!mUniqueCategoryIds.contains(categoryId)) {
        // New category - check size
        Preconditions.checkState(mUniqueCategoryIds.size() < getMaxCategoryCount(), ""already added %d unique category ids"", mUniqueCategoryIds.size());
    }
    Preconditions.checkState(mValues.size() < getMaxUserDataSize(), ""already added %d elements"", mValues.size());
    addMapping(value, categoryId);
    return this;
}",1,"/**
 * Adds a new value for user data.
 *
 * @param value value of the user data.
 * @param categoryId string used to identify the category the value is associated with.
 *
 * @throws IllegalStateException if:
 * <ul>
 * <li>{@link #build()} already called</li>
 * <li>the {@code value} has already been added (<b>Note: </b> this restriction was
 * lifted on Android {@link android.os.Build.VERSION_CODES#Q} and later)</li>
 * <li>the number of unique {@code categoryId} values added so far is more than
 * {@link UserData#getMaxCategoryCount()}</li>
 * <li>the number of {@code values} added so far is is more than
 * {@link UserData#getMaxUserDataSize()}</li>
 * </ul>
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code id} is empty</li>
 * <li>{@code categoryId} is empty</li>
 * <li>{@code value} is empty</li>
 * <li>the length of {@code value} is lower than {@link UserData#getMinValueLength()}</li>
 * <li>the length of {@code value} is higher than
 * {@link UserData#getMaxValueLength()}</li>
 * </ul>
 */
","/**
 * Adds a new value for user data.
 *
 * @param value value of the user data.
 * @param categoryId string used to identify the category the value is associated with.
 *
 * @throws IllegalStateException if:
 * <ul>
 * <li>{@link #build()} already called</li>
 * <li>the {@code value} has already been added (<b>Note: </b> this restriction was
 * lifted on Android {@link android.os.Build.VERSION_CODES#Q} and later)</li>
 * <li>the number of unique {@code categoryId} values added so far is more than
 * {@link UserData#getMaxCategoryCount()}</li>
 * <li>the number of {@code values} added so far is is more than
 * {@link UserData#getMaxUserDataSize()}</li>
 * </ul>
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code id} is empty</li>
 * <li>{@code categoryId} is empty</li>
 * <li>{@code value} is empty</li>
 * <li>the length of {@code value} is lower than {@link UserData#getMinValueLength()}</li>
 * <li>the length of {@code value} is higher than
 * {@link UserData#getMaxValueLength()}</li>
 * </ul>
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The change lies in the change of error message format in checkState. The functionality of the method essentially remains unaltered, with no change in control flow, return statement, or exception handling, so the code change type is 4.","As only string literals within the error messages are updated and the instructions governing behavior remain constant, there is no CI in this context. The method's behavior doesn't change between versions, as it still throws an IllegalStateException when the preconditions are not met. The updates to the error messages do not modify the type of exception thrown or the conditions under which it would be thrown, so no Compatibility Issue is introduced."
942,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,30,31,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,0,"{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}","{
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.cancelDiscovery(mAttributionSource);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothScanPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed to include an additional parameter in the call mService.cancelDiscovery(mAttributionSource) and it also introduced a new parameter usage in the dependent API call, so the code change types are 1,5.","Since the method signature of cancelDiscovery() has changed to include the new parameter mAttributionSource, this change potentially alters the behavior of the method by introducing a new possible flow of execution in the dependent API, which could result in a different value being returned or potentially different exceptions being thrown. Therefore, the CI type is 1."
943,"<android.content.res.ResourcesImpl.ThemeImpl: boolean resolveAttribute(int,TypedValue,boolean)>",30,31,"<android.content.res.ResourcesImpl.ThemeImpl: boolean resolveAttribute(int,TypedValue,boolean)>","<android.content.res.ResourcesImpl.ThemeImpl: boolean resolveAttribute(int,TypedValue,boolean)>",0,"{
    synchronized (mKey) {
        return mAssets.getThemeValue(mTheme, resid, outValue, resolveRefs);
    }
}","{
    return mAssets.getThemeValue(mTheme, resid, outValue, resolveRefs);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change is the removal of the synchronized block around the return statement. There are no changes to the return statement or the control flow, so the change type is 4 (Other statement changed).","The removal of the synchronized block does not affect the returned value or the exceptions thrown by the method, thus there's no Compatibility Issue in this context. The behavior from the perspective of the method's contract remains the same. The synchronization change might affect thread safety, but this does not constitute a change in behavior per the method's functionality requirements."
944,<android.app.admin.DevicePolicyManager: boolean isSecurityLoggingEnabled(ComponentName)>,30,31,<android.app.admin.DevicePolicyManager: boolean isSecurityLoggingEnabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isSecurityLoggingEnabled(ComponentName)>,0,"{
    throwIfParentInstance(""isSecurityLoggingEnabled"");
    try {
        return mService.isSecurityLoggingEnabled(admin);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isSecurityLoggingEnabled"");
    try {
        return mService.isSecurityLoggingEnabled(admin, mContext.getPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Return whether security logging is enabled or not by the admin.
 *
 * <p>Can only be called by the device owner or a profile owner of an organization-owned
 * managed profile, otherwise a {@link SecurityException} will be thrown.
 *
 * @param admin Which device admin this request is associated with.
 * @return {@code true} if security logging is enabled by device owner, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not allowed to control security logging.
 */
","/**
 * Return whether security logging is enabled or not by the admin.
 *
 * <p>Can only be called by the device owner or a profile owner of an organization-owned
 * managed profile, otherwise a {@link SecurityException} will be thrown.
 *
 * @param admin Which device admin this request is associated with.
 * @return {@code true} if security logging is enabled by device owner, {@code false} otherwise.
 * @throws SecurityException if {@code admin} is not allowed to control security logging.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `isSecurityLoggingEnabled` from `mService` used inside the API implementation now takes an additional parameter `mContext.getPackageName()`. This implies that the dependent API `isSecurityLoggingEnabled` has changed, so the code change type is 5.","Although `isSecurityLoggingEnabled` now includes an additional parameter, this doesn't constitute a compatibility issue under the assumption that the method's inner implementation accounts for backward compatibility and that the added parameter does not impact the returned result from the perspective of the API caller. Therefore, there is no CI, and the type is 0."
945,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextBeforeCursor(int,int)>",30,31,"<android.view.inputmethod.BaseInputConnection: CharSequence getTextBeforeCursor(int,int)>","<android.view.inputmethod.BaseInputConnection: CharSequence getTextBeforeCursor(int,int)>",0,"{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a <= 0) {
        return """";
    }
    if (length > a) {
        length = a;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a - length, a);
    }
    return TextUtils.substring(content, a - length, a);
}","{
    Preconditions.checkArgumentNonnegative(length);
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a <= 0) {
        return """";
    }
    if (length > a) {
        length = a;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a - length, a);
    }
    return TextUtils.substring(content, a - length, a);
}",1,"/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
","/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */
",-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"There's an additional method call `Preconditions.checkArgumentNonnegative(length)` added at the beginning of the method. No return statements, exception handling, or control dependencies have changed. However, since a call to another API `Preconditions.checkArgumentNonnegative` is added, it could be classified under both dependent API changed (5) and other statement changed (4) because it is not a change to the return statement, exception handling or control dependency.","This change should not cause a Compatibility Issue since the added precondition check ensures that the length argument is non-negative, which the method's logic already supports by returning `null` or empty string when necessary. If the length is negative, the Preconditions check will throw an IllegalArgumentException, which is a runtime exception and part of the method's expected behavior if invalid arguments are provided. This does not represent a change in behavior of the method itself with valid arguments; it's an enforcement of the contract that clients of the method should adhere to valid argument values."
946,<android.os.Debug: void startNativeTracing()>,30,31,<android.os.Debug: void startNativeTracing()>,<android.os.Debug: void startNativeTracing()>,0,"{
    // Open the sysfs file for writing and write ""1"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""1"");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
    VMDebug.startEmulatorTracing();
}","{
    // Open the sysfs file for writing and write ""1"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""1"");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
}",1,"/**
 * Enable qemu tracing. For this to work requires running everything inside
 * the qemu emulator; otherwise, this method will have no effect. The trace
 * file is specified on the command line when the emulator is started. For
 * example, the following command line <br />
 * <code>emulator -trace foo</code><br />
 * will start running the emulator and create a trace file named ""foo"". This
 * method simply enables writing the trace records to the trace file.
 *
 * <p>
 * The main differences between this and {@link #startMethodTracing()} are
 * that tracing in the qemu emulator traces every cpu instruction of every
 * process, including kernel code, so we have more complete information,
 * including all context switches. We can also get more detailed information
 * such as cache misses. The sequence of calls is determined by
 * post-processing the instruction trace. The qemu tracing is also done
 * without modifying the application or perturbing the timing of calls
 * because no instrumentation is added to the application being traced.
 * </p>
 *
 * <p>
 * One limitation of using this method compared to using
 * {@link #startMethodTracing()} on the real device is that the emulator
 * does not model all of the real hardware effects such as memory and
 * bus contention.  The emulator also has a simple cache model and cannot
 * capture all the complexities of a real cache.
 * </p>
 */
","/**
 * Enable qemu tracing. For this to work requires running everything inside
 * the qemu emulator; otherwise, this method will have no effect. The trace
 * file is specified on the command line when the emulator is started. For
 * example, the following command line <br />
 * <code>emulator -trace foo</code><br />
 * will start running the emulator and create a trace file named ""foo"". This
 * method simply enables writing the trace records to the trace file.
 *
 * <p>
 * The main differences between this and {@link #startMethodTracing()} are
 * that tracing in the qemu emulator traces every cpu instruction of every
 * process, including kernel code, so we have more complete information,
 * including all context switches. We can also get more detailed information
 * such as cache misses. The sequence of calls is determined by
 * post-processing the instruction trace. The qemu tracing is also done
 * without modifying the application or perturbing the timing of calls
 * because no instrumentation is added to the application being traced.
 * </p>
 *
 * <p>
 * One limitation of using this method compared to using
 * {@link #startMethodTracing()} on the real device is that the emulator
 * does not model all of the real hardware effects such as memory and
 * bus contention.  The emulator also has a simple cache model and cannot
 * capture all the complexities of a real cache.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""VMDebug.startEmulatorTracing();"" has been removed from the implementation, so the code change type is 4.","Since the statement removed is a method call that does not influence the existing return value or exception handling (as there were none to begin with), thus, no Compatibility Issue arises from this change, and the CI type is 0."
947,<android.widget.EdgeEffect: int getMaxHeight()>,30,31,<android.widget.EdgeEffect: int getMaxHeight()>,<android.widget.EdgeEffect: int getMaxHeight()>,0,"{
    return (int) (mBounds.height() * MAX_GLOW_SCALE + 0.5f);
}","{
    return (int) mHeight;
}",1,"/**
 * Return the maximum height that the edge effect will be drawn at given the original
 * {@link #setSize(int, int) input size}.
 * @return The maximum height of the edge effect
 */
","/**
 * Return the maximum height that the edge effect will be drawn at given the original
 * {@link #setSize(int, int) input size}.
 * @return The maximum height of the edge effect
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from a calculation involving mBounds.height() to directly returning the value of mHeight, so the code change type is 1.","As the return statement is altered and now returns a different value, the API could potentially return a different value than before, therefore the CI type is 1."
950,<android.os.Parcel: void recycle()>,30,31,<android.os.Parcel: void recycle()>,<android.os.Parcel: void recycle()>,0,"{
    if (DEBUG_RECYCLE)
        mStack = null;
    freeBuffer();
    final Parcel[] pool;
    if (mOwnsNativeParcelObject) {
        pool = sOwnedPool;
    } else {
        mNativePtr = 0;
        pool = sHolderPool;
    }
    synchronized (pool) {
        for (int i = 0; i < POOL_SIZE; i++) {
            if (pool[i] == null) {
                pool[i] = this;
                return;
            }
        }
    }
}","{
    if (DEBUG_RECYCLE)
        mStack = null;
    freeBuffer();
    if (mOwnsNativeParcelObject) {
        synchronized (sPoolSync) {
            if (sOwnedPoolSize < POOL_SIZE) {
                mPoolNext = sOwnedPool;
                sOwnedPool = this;
                sOwnedPoolSize++;
            }
        }
    } else {
        mNativePtr = 0;
        synchronized (sPoolSync) {
            if (sHolderPoolSize < POOL_SIZE) {
                mPoolNext = sHolderPool;
                sHolderPool = this;
                sHolderPoolSize++;
            }
        }
    }
}",1,"/**
 * Put a Parcel object back into the pool.  You must not touch
 * the object after this call.
 */
","/**
 * Put a Parcel object back into the pool.  You must not touch
 * the object after this call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The structure of pooling logic has been changed significantly - instead of checking each pool array item for a null to place the recycled object, the new code uses pool size to determine whether to place the object. Additionally, a synchronized block with a new synchronized lock object (sPoolSync) is introduced and the pool arrays themselves are replaced by reference chaining (using mPoolNext) rather than direct array item assignment. There is no direct change to the method's return type or exception handling, but the method's internal object pooling logic has been changed, so the change types are 3 (for the control flow change due to the introduction of size check and synchronized on a different object) and 4 (for the changes in internal logic which does not affect the method signature but changes how recycling is done internally).","There is no compatibility issue, since the API's contract, from the point of view of the caller, remains the same - the calling code is not affected by how the Parcel is recycled internally. Thus, the external behavior of the method remains consistent despite the refactoring."
952,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",30,31,"<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>","<android.bluetooth.BluetoothGatt: boolean setCharacteristicNotification(BluetoothGattCharacteristic,boolean)>",0,"{
    if (DBG) {
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    }
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG) {
        Log.d(TAG, ""setCharacteristicNotification() - uuid: "" + characteristic.getUuid() + "" enable: "" + enable);
    }
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
","/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"There's an additional parameter, mAttributionSource, passed to the mService.registerForNotification method in the late version, and the introduction of new annotations such as @RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, and @RequiresPermission, so the code change types are 4 (other statement changed due to the addition of a new parameter) and 5 (dependent API changed).","Despite the addition of a new parameter to the method call and new permission annotations, there is no actual change in the behavior of the method that could cause Compatibility Issues. The method's control flow and returned values remain the same, and it does not introduce any new exceptions. The new parameters and annotations enforce permissions checks at compile-time but do not affect the runtime behavior provided the permissions are correctly handled by the calling app. Therefore, there is no Compatibility Issue."
953,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,30,31,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,<android.os.BatteryStats.HistoryItem: boolean sameNonEvent(HistoryItem)>,0,"{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && batteryChargeUAh == o.batteryChargeUAh && modemRailChargeMah == o.modemRailChargeMah && wifiRailChargeMah == o.wifiRailChargeMah && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}","{
    return batteryLevel == o.batteryLevel && batteryStatus == o.batteryStatus && batteryHealth == o.batteryHealth && batteryPlugType == o.batteryPlugType && batteryTemperature == o.batteryTemperature && batteryVoltage == o.batteryVoltage && batteryChargeUah == o.batteryChargeUah && modemRailChargeMah == o.modemRailChargeMah && wifiRailChargeMah == o.wifiRailChargeMah && states == o.states && states2 == o.states2 && currentTime == o.currentTime;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change detected is in the capitalization of 'batteryChargeUAh' to 'batteryChargeUah'. This is a simple variable name change in the Java code, and since Java is case-sensitive, it could be considered an 'Other statement changed'. The logic of the method remains the same, and this type of change is typically internal and should not affect the APIâ€™s contract.",The change in variable capitalization does not affect behavior from the API consumers' perspective. There seems to be no Compatibility Issue arising from this change as the method's behavior itself is not modified; it's still comparing the same fields between two `HistoryItem` objects.
954,<android.app.Activity: boolean showAssist(Bundle)>,30,31,<android.app.Activity: boolean showAssist(Bundle)>,<android.app.Activity: boolean showAssist(Bundle)>,0,"{
    try {
        return ActivityTaskManager.getService().showAssistFromActivity(mToken, args);
    } catch (RemoteException e) {
    }
    return false;
}","{
    return ActivityClient.getInstance().showAssistFromActivity(mToken, args);
}",1,"/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
","/**
 * Ask to have the current assistant shown to the user.  This only works if the calling
 * activity is the current foreground activity.  It is the same as calling
 * {@link android.service.voice.VoiceInteractionService#showSession
 * VoiceInteractionService.showSession} and requesting all of the possible context.
 * The receiver will always see
 * {@link android.service.voice.VoiceInteractionSession#SHOW_SOURCE_APPLICATION} set.
 * @return Returns true if the assistant was successfully invoked, else false.  For example
 * false will be returned if the caller is not the current top activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The called method inside the return statement changed from ActivityTaskManager.getService().showAssistFromActivity to ActivityClient.getInstance().showAssistFromActivity, and no exception is caught in the late version. So, this is categorized as return statement changed (1) and dependent API changed (5).","Since the called method within the return statement changed, and the late version doesn't handle RemoteException anymore, there's a potential change in behavior that would lead to a different return value. Moreover, the removal of the try-catch block results in a different exception handling mechanism, which could lead to a different exception being thrown or propagated. Therefore, the CI type is 1."
955,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: boolean disconnect(BluetoothDevice)>,0,"{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}","{
    boolean result = false;
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            result = service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return result;
}",1,"/**
 * Disconnects from currently connected host. The connection state should be tracked by the
 * application by handling callback from Callback#onConnectionStateChanged. The connection state
 * is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
","/**
 * Disconnects from currently connected host. The connection state should be tracked by the
 * application by handling callback from Callback#onConnectionStateChanged. The connection state
 * is not related to the return value of this method.
 *
 * @return true if the command is successfully sent; otherwise false.
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API 'service.disconnect(device)' in the early version has an additional parameter 'mAttributionSource' in the late version, resulting in a change to the method signature. Hence, the code change type is 5.","Though the method signature has changed to include an additional parameter 'mAttributionSource,' it does not affect the return type or the exception handling of the existing API method. Therefore, there are no changes that could potentially lead to different behavior in terms of return values or exception handling, which means no compatibility issue is introduced and the CI type is 0."
956,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,30,31,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,<android.bluetooth.le.AdvertisingSet: void setAdvertisingData(AdvertiseData)>,0,"{
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Set/update data being Advertised. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingDataSet()}.
 * <p>
 * Advertising data must be empty if non-legacy scannable advertising is used.
 *
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags. If the update takes place when the advertising set is
 * enabled, the data can be maximum 251 bytes long.
 */
","/**
 * Set/update data being Advertised. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingDataSet()}.
 * <p>
 * Advertising data must be empty if non-legacy scannable advertising is used.
 *
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags. If the update takes place when the advertising set is
 * enabled, the data can be maximum 251 bytes long.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method `setAdvertisingData` now includes an additional parameter `mAttriburationSource`. This change indicates a dependency on a modified API, hence the code change type is 5.","Despite the addition of a new parameter in the method call, the behavior of the API regarding return values or thrown exceptions hasn't changed since the method signature remains the same and the method still catches `RemoteException` without throwing it. Therefore, there is no Compatibility Issue in this case, which corresponds to type 0."
957,"<android.accounts.AccountManager: String getUserData(Account,String)>",30,31,"<android.accounts.AccountManager: String getUserData(Account,String)>","<android.accounts.AccountManager: String getUserData(Account,String)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (key == null)
        throw new IllegalArgumentException(""key is null"");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    return mUserDataCache.query(new AccountKeyData(account, key));
}",1,"/**
 * Gets the user data named by ""key"" associated with the account. This is intended for
 * authenticators and related code to store arbitrary metadata along with accounts. The meaning
 * of the keys and values is up to the authenticator for the account.
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * <p>
 * This method requires the caller to have a signature match with the authenticator that owns
 * the specified account.
 *
 * <p>
 * <b>NOTE:</b> If targeting your app to work on API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} and before, AUTHENTICATE_ACCOUNTS
 * permission is needed for those platforms. See docs for this function in API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account, key doesn't exist, or the user is locked
 */
","/**
 * Gets the user data named by ""key"" associated with the account. This is intended for
 * authenticators and related code to store arbitrary metadata along with accounts. The meaning
 * of the keys and values is up to the authenticator for the account.
 *
 * <p>
 * It is safe to call this method from the main thread.
 *
 * <p>
 * This method requires the caller to have a signature match with the authenticator that owns
 * the specified account.
 *
 * <p>
 * <b>NOTE:</b> If targeting your app to work on API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1} and before, AUTHENTICATE_ACCOUNTS
 * permission is needed for those platforms. See docs for this function in API level
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account, key doesn't exist, or the user is locked
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has completely been changed from directly using a service call to retrieve user data to using an internal cache mechanism (mUserDataCache.query(new AccountKeyData(account, key))), indicating changes in both the return statement and the dependent API, so the code change type is 1,5.","Given the complete overhaul of the implementation with a transition from a service-based retrieval to a cache-based retrieval, there is the potential for different data being returned by the new method, thus introducing a Compatibility Issue of type 1."
960,<android.content.pm.Signature: int hashCode()>,30,31,<android.content.pm.Signature: int hashCode()>,<android.content.pm.Signature: int hashCode()>,0,"{
    if (mHaveHashCode) {
        return mHashCode;
    }
    mHashCode = Arrays.hashCode(mSignature);
    mHaveHashCode = true;
    return mHashCode;
}","{
    if (mHaveHashCode) {
        return mHashCode;
    }
    // Note, similar to equals some classes rely on the hash code not including
    // the flags for Set membership checks.
    mHashCode = Arrays.hashCode(mSignature);
    mHaveHashCode = true;
    return mHashCode;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no change in the API implementation except the addition of a comment, which does not affect the code's execution. Thus the code change type is 0.","Since there is no actual code change apart from the addition of a comment, there is no Compatibility Issue. The behavior of the method remains the same between the two versions."
964,<android.app.admin.DevicePolicyManager: boolean isAffiliatedUser()>,30,31,<android.app.admin.DevicePolicyManager: boolean isAffiliatedUser()>,<android.app.admin.DevicePolicyManager: boolean isAffiliatedUser()>,0,"{
    throwIfParentInstance(""isAffiliatedUser"");
    try {
        return mService.isAffiliatedUser();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""isAffiliatedUser"");
    try {
        return mService.isCallingUserAffiliated();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Returns whether this user is affiliated with the device.
 * <p>
 * By definition, the user that the device owner runs on is always affiliated with the device.
 * Any other user is considered affiliated with the device if the set specified by its
 * profile owner via {@link #setAffiliationIds} intersects with the device owner's.
 * @see #setAffiliationIds
 */
","/**
 * Returns whether this user is affiliated with the device.
 * <p>
 * By definition, the user that the device owner runs on is always affiliated with the device.
 * Any other user is considered affiliated with the device if the set specified by its
 * profile owner via {@link #setAffiliationIds} intersects with the device owner's.
 * @see #setAffiliationIds
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API within the method body has changed from mService.isAffiliatedUser() to mService.isCallingUserAffiliated(), so the change type is 5.","Since the dependent API method has changed, this could potentially return a different value when the new API isCallingUserAffiliated() behaves differently than the previous isAffiliatedUser(). Therefore, the CI type is 1."
965,<android.nfc.NfcAdapter: boolean isSecureNfcEnabled()>,30,31,<android.nfc.NfcAdapter: boolean isSecureNfcEnabled()>,<android.nfc.NfcAdapter: boolean isSecureNfcEnabled()>,0,"{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.isNfcSecureEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.isNfcSecureEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, ""Failed to recover NFC Service."");
            return false;
        }
        try {
            return sService.isNfcSecureEnabled();
        } catch (RemoteException ee) {
            Log.e(TAG, ""Failed to recover NFC Service."");
        }
        return false;
    }
}",1,"/**
 * Checks Secure NFC feature is enabled.
 *
 * @return True if Secure NFC is enabled, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @throws UnsupportedOperationException if device doesn't support
 * Secure NFC functionality. {@link #isSecureNfcSupported}
 */
","/**
 * Checks Secure NFC feature is enabled.
 *
 * @return True if Secure NFC is enabled, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @throws UnsupportedOperationException if device doesn't support
 * Secure NFC functionality. {@link #isSecureNfcSupported}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the late version, new control dependency change has been introduced where an additional attempt to recover the NFC service is made and this includes another `try` block with return statement, also an additional catch `RemoteException` block. So, the change type is 2,3.","The late version introduces a second attempt to call `sService.isNfcSecureEnabled()` which means that in the case of a `RemoteException`, the behavior of the method has changed because it tries the operation again instead of returning false immediately. This could lead to different return values under certain conditions (first call to `sService.isNfcSecureEnabled()` fails but the second succeeds), which is a compatibility issue related to return values (type 1). Furthermore, the method in the early version never logged an error message in the `RemoteException` catch block, while the late version does, which could be considered an exception handling change leading to observable behavioral differences such as log output (type 2)."
966,<android.net.metrics.NetworkMetrics.Summary: String toString()>,30,31,<android.net.metrics.NetworkMetrics.Summary: String toString()>,<android.net.metrics.NetworkMetrics.Summary: String toString()>,0,"{
    StringJoiner j = new StringJoiner("", "", ""{"", ""}"");
    j.add(""netId="" + netId);
    for (int t : BitUtils.unpackBits(transports)) {
        j.add(NetworkCapabilities.transportNameOf(t));
    }
    j.add(String.format(""dns avg=%dms max=%dms err=%.1f%% tot=%d"", (int) dnsLatencies.average(), (int) dnsLatencies.max, 100 * dnsErrorRate.average(), dnsErrorRate.count));
    j.add(String.format(""connect avg=%dms max=%dms err=%.1f%% tot=%d"", (int) connectLatencies.average(), (int) connectLatencies.max, 100 * connectErrorRate.average(), connectErrorRate.count));
    j.add(String.format(""tcp avg_loss=%.1f%% total_sent=%d total_lost=%d"", 100 * tcpLossRate.average(), tcpLossRate.count, (int) tcpLossRate.sum));
    j.add(String.format(""tcp rtt=%dms"", (int) (roundTripTimeUs.average() / 1000)));
    j.add(String.format(""tcp sent-ack_diff=%dms"", (int) sentAckTimeDiffenceMs.average()));
    return j.toString();
}","{
    StringJoiner j = new StringJoiner("", "", ""{"", ""}"");
    j.add(""netId="" + netId);
    j.add(""transports="" + BitSet.valueOf(new long[] { transports }));
    j.add(String.format(""dns avg=%dms max=%dms err=%.1f%% tot=%d"", (int) dnsLatencies.average(), (int) dnsLatencies.max, 100 * dnsErrorRate.average(), dnsErrorRate.count));
    j.add(String.format(""connect avg=%dms max=%dms err=%.1f%% tot=%d"", (int) connectLatencies.average(), (int) connectLatencies.max, 100 * connectErrorRate.average(), connectErrorRate.count));
    j.add(String.format(""tcp avg_loss=%.1f%% total_sent=%d total_lost=%d"", 100 * tcpLossRate.average(), tcpLossRate.count, (int) tcpLossRate.sum));
    j.add(String.format(""tcp rtt=%dms"", (int) (roundTripTimeUs.average() / 1000)));
    j.add(String.format(""tcp sent-ack_diff=%dms"", (int) sentAckTimeDiffenceMs.average()));
    return j.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"An individual statement within the method was changed without altering the method's control flow or exception handling. Specifically, the line that adds information about transports was altered from a loop that unpacked and processed bits to directly converting the bit information into a `BitSet`. This changes the way the transports information is appended to the `StringJoiner` but does not change the control flow, exception handling, or dependencies of the method, hence type 4.","There is no Compatibility Issue here because the method still returns a String representation of the object's state. The string resulting from the changed statement will be formatted differently but the fact that it's just a change in the string formatting, without altering the method's behavior or the type of its return value, means it does not cause a compatibility issue."
968,<android.content.IntentSender: String getTargetPackage()>,30,31,<android.content.IntentSender: String getTargetPackage()>,<android.content.IntentSender: String getTargetPackage()>,0,"{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}","{
    return getCreatorPackage();
}",1,"/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
","/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method has changed from directly interacting with the ActivityManager service to calling another method getCreatorPackage(), so the code change type is 4,5.","As the implementation now relies on a different method to obtain the target package, it could potentially change the return value, leading to CI type 1."
969,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,30,31,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,<android.app.Instrumentation: void sendPointerSync(MotionEvent)>,0,"{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    try {
        WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
    } catch (RemoteException e) {
    }
}","{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    try {
        WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH, true);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
","/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change in the method is the addition of a boolean argument `true` to the `injectInputAfterTransactionsApplied()` method call, indicating a change in the arguments of the dependent API. Thus, the code change types are 4,5.","There is no CI regarding compatible behavior since the catch block for RemoteException is the same in both versions, and there is no indication of return value or exception behavior being affected by the additional argument from the context given. The method does not have a return statement, and the extra parameter seems to be part of the normal operation flow of the method rather than a change that would modify the control flow leading to an exception. Therefore, no Compatibility Issue is detected."
970,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",30,31,"<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>","<android.app.ContextImpl: void sendBroadcastAsUserMultiplePermissions(Intent,UserHandle,String[])>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change in the code is the addition of a comment `/*excludedPermissions=*/` before an argument in a method call of `ActivityManager.getService().broadcastIntentWithFeature(...)`. This change is purely stylistic/documentation and does not affect the behavior or functionality of the code, so the code change type is 4.","The code change does not affect the API's behavior in terms of return values, exception handling, or control flow; it is simply a comment for clarity. Therefore, there is no Compatibility Issue, and the CI type is 0."
971,<android.service.notification.NotificationListenerService.Ranking: Action> getSmartActions()>,30,31,<android.service.notification.NotificationListenerService.Ranking: Action> getSmartActions()>,<android.service.notification.NotificationListenerService.Ranking: Action> getSmartActions()>,0,"{
    return mSmartActions;
}","{
    return mSmartActions == null ? Collections.emptyList() : mSmartActions;
}",1,"/**
 * Returns a list of smart {@link Notification.Action} that can be added by the
 * {@link NotificationAssistantService}
 */
","/**
 * Returns a list of smart {@link Notification.Action} that can be added by the
 * {@link NotificationAssistantService}
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,There is a change in the return statement that includes a conditional check in the late version to determine whether to return an empty list or the existing `mSmartActions`. This change of behavior in the return statement is identified as change type 1.,The late version of the API could potentially return a different value (an empty list) when `mSmartActions` is null as opposed to the early version which would return `mSmartActions` directly even if it's null. This results in a Compatibility Issue of type 1 due to a possible different return value.
972,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",30,31,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String,CancellationSignal)>",0,"{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, mAttributionTag, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(mode, ""mode"");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mAttributionSource, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The change can be observed in the parameters passed to mContentProvider.openFile with 'mPackageName' and 'mAttributionTag' being replaced by 'mAttributionSource' as well as the deletion of the last parameter 'null'. Since this change affects the parameters of a dependent API call, the code change type is 5.","Since there is no change in the return type or the exception thrown by the method, and the change is purely internal to the parameters passed to another API, there's no Compatibility Issue according to the given rules. Therefore, the CI type is 0."
973,<android.app.Activity: String getCallingPackage()>,30,31,<android.app.Activity: String getCallingPackage()>,<android.app.Activity: String getCallingPackage()>,0,"{
    try {
        return ActivityTaskManager.getService().getCallingPackage(mToken);
    } catch (RemoteException e) {
        return null;
    }
}","{
    return ActivityClient.getInstance().getCallingPackage(mToken);
}",1,"/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
","/**
 * Return the name of the package that invoked this activity.  This is who
 * the data in {@link #setResult setResult()} will be sent to.  You can
 * use this information to validate that the recipient is allowed to
 * receive the data.
 *
 * <p class=""note"">Note: if the calling activity is not expecting a result (that is it
 * did not use the {@link #startActivityForResult}
 * form that includes a request code), then the calling package will be
 * null.</p>
 *
 * <p class=""note"">Note: prior to {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * the result from this method was unstable.  If the process hosting the calling
 * package was no longer running, it would return null instead of the proper package
 * name.  You can use {@link #getCallingActivity()} and retrieve the package name
 * from that instead.</p>
 *
 * @return The package of the activity that will receive your
 * reply, or null if none.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API call has changed from ActivityTaskManager.getService().getCallingPackage(mToken) to ActivityClient.getInstance().getCallingPackage(mToken). There's no change in return statements, exception handling, or control flow, therefore the code change types are 4 and 5.","Despite the change in the method used to obtain the calling package, there is no change to the method signature, return type, or exception handling that affects the outward behavior of the API from the caller's perspective. Both methods return a string or null, and there's no change in the annotations (@Nullable remains the same), which indicates that the possibility of returning null remains unchanged. Hence, there is no compatibility issue in terms of the return value or exception handling, so the CI is 0."
975,<android.app.UiAutomation: void adoptShellPermissionIdentity(String)>,30,31,<android.app.UiAutomation: void adoptShellPermissionIdentity(String)>,<android.app.UiAutomation: void adoptShellPermissionIdentity(String)>,0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.adoptShellPermissionIdentity(Process.myUid(), permissions);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing adopting shell permission identity!"", re);
    }
}","{
    try {
        // Calling out without a lock held.
        mUiAutomationConnection.adoptShellPermissionIdentity(Process.myUid(), permissions);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error executing adopting shell permission identity!"", re);
    }
}",1,"/**
 * Adopt the permission identity of the shell UID only for the provided permissions.
 * This allows you to call APIs protected permissions which normal apps cannot hold
 * but are granted to the shell UID. If you already adopted the specified shell
 * permissions by calling this method or {@link #adoptShellPermissionIdentity()} a
 * subsequent call would be a no-op. Note that your permission state becomes that of the
 * shell UID and it is not a combination of your and the shell UID permissions.
 * <p>
 * <strong>Note:<strong/> Calling this method adopts only the specified shell permissions
 * and overrides all adopted permissions via {@link #adoptShellPermissionIdentity()}.
 *
 * @param permissions The permissions to adopt or <code>null</code> to adopt all.
 *
 * @see #adoptShellPermissionIdentity()
 * @see #dropShellPermissionIdentity()
 */
","/**
 * Adopt the permission identity of the shell UID only for the provided permissions.
 * This allows you to call APIs protected permissions which normal apps cannot hold
 * but are granted to the shell UID. If you already adopted shell permissions by calling
 * this method, or {@link #adoptShellPermissionIdentity()} a subsequent call will replace any
 * previous adoption.
 * <p>
 * <strong>Note:<strong/> This method behave differently from
 * {@link #adoptShellPermissionIdentity()}. Only the listed permissions will use the shell
 * identity and other permissions will still check against the original UID
 *
 * @param permissions The permissions to adopt or <code>null</code> to adopt all.
 *
 * @see #adoptShellPermissionIdentity()
 * @see #dropShellPermissionIdentity()
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The synchronized block has been removed, so the change is related to control flow, making the code change type 3.","The lock was not controlling the API behavior regarding its output or exceptions. It was ensuring thread safety for sections of the internal code. Removing it does not affect the return value or the exceptions thrown by the actual API method; therefore, there would be no compatibility issue in terms of the API's behavior from an external point of view. Hence, the CI type is 0."
976,"<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>",30,31,"<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>","<com.android.server.backup.PermissionBackupHelper: void applyRestoredPayload(String,byte[])>",0,"{
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                mPermissionManager.restoreRuntimePermissions(payload, mUser);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.w(TAG, ""Unable to restore key "" + key);
    }
}","{
    if (DEBUG) {
        Slog.d(TAG, ""Handling restore of "" + key);
    }
    try {
        switch(key) {
            case KEY_PERMISSIONS:
                mPermissionManager.restoreRuntimePermissions(payload, mUserId);
                break;
            default:
                Slog.w(TAG, ""Unexpected restore key "" + key);
        }
    } catch (Exception e) {
        Slog.e(TAG, ""Unable to restore key "" + key, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable name has changed from mUser to mUserId inside the case block, and the log level in the catch block has changed from Slog.w to Slog.e, which are categorized as other statement changes, so the code change type is 4.","However, these changes do not affect the execution flow or outcome of the method itself; the value returned and exceptions thrown remain the same. The alteration in variable name does not affect the method signature or behavior, as it is an internal change and assumes that the `mUserId` is functionally equivalent to `mUser`. Similarly, changing the log level does not alter the execution logic or external behavior of the method. Therefore, there is no Compatibility Issue, and the CI type is 0."
978,<android.provider.Telephony.Sms.Intents: SmsMessage[] getMessagesFromIntent(Intent)>,30,31,<android.provider.Telephony.Sms.Intents: SmsMessage[] getMessagesFromIntent(Intent)>,<android.provider.Telephony.Sms.Intents: SmsMessage[] getMessagesFromIntent(Intent)>,0,"{
    Object[] messages;
    try {
        messages = (Object[]) intent.getSerializableExtra(""pdus"");
    } catch (ClassCastException e) {
        Rlog.e(TAG, ""getMessagesFromIntent: "" + e);
        return null;
    }
    if (messages == null) {
        Rlog.e(TAG, ""pdus does not exist in the intent"");
        return null;
    }
    String format = intent.getStringExtra(""format"");
    int subId = intent.getIntExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SubscriptionManager.getDefaultSmsSubscriptionId());
    Rlog.v(TAG, "" getMessagesFromIntent sub_id : "" + subId);
    int pduCount = messages.length;
    SmsMessage[] msgs = new SmsMessage[pduCount];
    for (int i = 0; i < pduCount; i++) {
        byte[] pdu = (byte[]) messages[i];
        msgs[i] = SmsMessage.createFromPdu(pdu, format);
    }
    return msgs;
}","{
    Object[] messages;
    try {
        messages = (Object[]) intent.getSerializableExtra(""pdus"");
    } catch (ClassCastException e) {
        Rlog.e(TAG, ""getMessagesFromIntent: "" + e);
        return null;
    }
    if (messages == null) {
        Rlog.e(TAG, ""pdus does not exist in the intent"");
        return null;
    }
    String format = intent.getStringExtra(""format"");
    int subId = intent.getIntExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        Rlog.v(TAG, ""getMessagesFromIntent with valid subId : "" + subId);
    } else {
        Rlog.v(TAG, ""getMessagesFromIntent"");
    }
    int pduCount = messages.length;
    SmsMessage[] msgs = new SmsMessage[pduCount];
    for (int i = 0; i < pduCount; i++) {
        byte[] pdu = (byte[]) messages[i];
        msgs[i] = SmsMessage.createFromPdu(pdu, format);
    }
    return msgs;
}",1,"/**
 * Read the PDUs out of an {@link #SMS_RECEIVED_ACTION} or a
 * {@link #DATA_SMS_RECEIVED_ACTION} intent.
 *
 * @param intent the intent to read from
 * @return an array of SmsMessages for the PDUs
 */
","/**
 * Read the PDUs out of an {@link #SMS_RECEIVED_ACTION} or a
 * {@link #DATA_SMS_RECEIVED_ACTION} intent.
 *
 * @param intent the intent to read from
 * @return an array of SmsMessages for the PDUs
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's a change in how the subId is obtained from the intent's extras, using SubscriptionManager.INVALID_SUBSCRIPTION_ID as default instead of SubscriptionManager.getDefaultSmsSubscriptionId(). Moreover, there's an addition of a conditional log statement checking if the subId is valid, so the code change type is 4.","As the logic's change only pertains to the logging and the default value for a variable that does not alter the method's behavior or the returned value (SmsMessage[] msgs), there is no Compatibility Issue. The method's final behavior, which is returning an array of SmsMessage objects, remains unchanged despite the different subId value potentially used for logging. Hence, the API's functionality from an external standpoint remains consistent between the versions."
979,<android.content.res.XmlBlock.Parser: String getNamespace()>,30,31,<android.content.res.XmlBlock.Parser: String getNamespace()>,<android.content.res.XmlBlock.Parser: String getNamespace()>,0,"{
    int id = nativeGetNamespace(mParseState);
    return id >= 0 ? mStrings.get(id).toString() : """";
}","{
    int id = nativeGetNamespace(mParseState);
    return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : """";
}",1,,,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using mStrings.get(id).toString() to using getSequenceString(mStrings.getSequence(id)), and a new method getSequenceString() is called with potentially a different behavior. So, the code change type is 1,5.","The change in the way the namespace string is obtained may result in a different return value since a new method getSequenceString() is introduced which could return a different string compared to toString(). Thus, the CI type is 1."
980,<android.bluetooth.BluetoothAdapter: boolean enable()>,30,31,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    if (isEnabled()) {
        if (DBG) {
            Log.d(TAG, ""enable(): BT already enabled!"");
        }
        return true;
    }
    try {
        return mManagerService.enable(ActivityThread.currentPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (isEnabled()) {
        if (DBG) {
            Log.d(TAG, ""enable(): BT already enabled!"");
        }
        return true;
    }
    try {
        return mManagerService.enable(mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 *
 * @return true to indicate adapter startup has begun, or false on immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 *
 * @return true to indicate adapter startup has begun, or false on immediate error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)],"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mManagerService.enable()` has changed from receiving `ActivityThread.currentPackageName()` as a parameter to receiving `mAttributionSource`. However, the return values and the exception handling have not been altered, so the change type is 5.","Since none of the return values or the exception handling logic has changed in the new version, the compatibility issue type should be 0; no potential difference in behavior is expected only because of the change in the parameters passed to a dependent API, assuming that `mAttriburationSource` correctly reflects the same contextual information as `ActivityThread.currentPackageName()`."
981,<android.bluetooth.BluetoothGatt: void disconnect()>,30,31,<android.bluetooth.BluetoothGatt: void disconnect()>,<android.bluetooth.BluetoothGatt: void disconnect()>,0,"{
    if (DBG)
        Log.d(TAG, ""cancelOpen() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.clientDisconnect(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    if (DBG)
        Log.d(TAG, ""cancelOpen() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.clientDisconnect(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Disconnects an established connection, or cancels a connection attempt
 * currently in progress.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
","/**
 * Disconnects an established connection, or cancels a connection attempt
 * currently in progress.
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The implementation change is that an additional parameter (mAttributionSource) has been added to the method call mService.clientDisconnect. This indicates that there is a change in the dependent API, hence the code change type is 5.","The changes do not affect the behavior of the method from the caller's perspective in terms of returned values or handled exceptions; hence, there is no compatibility issue, so CI type is 0. The method signature has remained the same, and the change in implementation is only providing additional context to the existing service call, which is managed internally."
982,<android.hardware.biometrics.BiometricPrompt: int getAllowedAuthenticators()>,30,31,<android.hardware.biometrics.BiometricPrompt: int getAllowedAuthenticators()>,<android.hardware.biometrics.BiometricPrompt: int getAllowedAuthenticators()>,0,"{
    return mBundle.getInt(KEY_AUTHENTICATORS_ALLOWED, 0);
}","{
    return mPromptInfo.getAuthenticators();
}",1,"/**
 * Gets the type(s) of authenticators that may be invoked by the prompt to authenticate the
 * user, as set by {@link Builder#setAllowedAuthenticators(int)}.
 *
 * @return A bit field representing the type(s) of authenticators that may be invoked by the
 * prompt (as defined by {@link Authenticators}), or 0 if this field was not set.
 */
","/**
 * Gets the type(s) of authenticators that may be invoked by the prompt to authenticate the
 * user, as set by {@link Builder#setAllowedAuthenticators(int)}.
 *
 * @return A bit field representing the type(s) of authenticators that may be invoked by the
 * prompt (as defined by {@link Authenticators}), or 0 if this field was not set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,"The method invoked for returning value has changed from mBundle.getInt(...) to mPromptInfo.getAuthenticators(), which means the implementation has changed to use a different API, so the code change types are 4 and 5.","Since the method used to obtain the return value has changed, it may potentially lead to the API returning a different value. Therefore, the potential CI type is 1."
983,"<android.os.FileObserver.ObserverThread: int[] startWatching(List<File>,int,FileObserver)>",30,31,"<android.os.FileObserver.ObserverThread: int[] startWatching(List<File>,int,FileObserver)>","<android.os.FileObserver.ObserverThread: int[] startWatching(List<File>,int,FileObserver)>",0,"{
    final int count = files.size();
    final String[] paths = new String[count];
    for (int i = 0; i < count; ++i) {
        paths[i] = files.get(i).getAbsolutePath();
    }
    final int[] wfds = new int[count];
    Arrays.fill(wfds, -1);
    startWatching(m_fd, paths, mask, wfds);
    final WeakReference<FileObserver> fileObserverWeakReference = new WeakReference<>(observer);
    synchronized (m_observers) {
        for (int wfd : wfds) {
            if (wfd >= 0) {
                m_observers.put(wfd, fileObserverWeakReference);
            }
        }
    }
    return wfds;
}","{
    final int count = files.size();
    final String[] paths = new String[count];
    for (int i = 0; i < count; ++i) {
        paths[i] = files.get(i).getAbsolutePath();
    }
    final int[] wfds = new int[count];
    Arrays.fill(wfds, -1);
    startWatching(m_fd, paths, mask, wfds);
    final WeakReference<FileObserver> fileObserverWeakReference = new WeakReference<>(observer);
    synchronized (mRealObservers) {
        for (int wfd : wfds) {
            if (wfd >= 0) {
                mRealObservers.put(wfd, fileObserverWeakReference);
            }
        }
    }
    return wfds;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable `m_observers` has been changed to `mRealObservers`, representing a change in the implementation detail. This change does not affect the returned value or the exceptions thrown by the method, so the code change type is 4.","There seem to be no Compatibility Issues as the functionality of the method appears unchanged from the perspective of the API user. The internals of how the observers are stored have changed, but this would not affect the return value or the exception handling of the method. It is an internal change that should be invisible to the users of the API. The difference in the name of the variable does not impact the method's external behavior."
984,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",30,31,"<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>","<android.content.res.AssetManager: boolean getResourceValue(int,int,TypedValue,boolean)>",0,"{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            outValue.string = getPooledStringForCookie(cookie, outValue.data);
        }
        return true;
    }
}","{
    Objects.requireNonNull(outValue, ""outValue"");
    synchronized (this) {
        ensureValidLocked();
        final int cookie = nativeGetResourceValue(mObject, resId, (short) densityDpi, outValue, resolveRefs);
        if (cookie <= 0) {
            return false;
        }
        // Convert the changing configurations flags populated by native code.
        outValue.changingConfigurations = ActivityInfo.activityInfoConfigNativeToJava(outValue.changingConfigurations);
        if (outValue.type == TypedValue.TYPE_STRING) {
            if ((outValue.string = getPooledStringForCookie(cookie, outValue.data)) == null) {
                return false;
            }
        }
        return true;
    }
}",1,"/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
","/**
 * Populates {@code outValue} with the data associated a particular
 * resource identifier for the current configuration.
 *
 * @param resId the resource identifier to load
 * @param densityDpi the density bucket for which to load the resource
 * @param outValue the typed value in which to put the data
 * @param resolveRefs {@code true} to resolve references, {@code false}
 * to leave them unresolved
 * @return {@code true} if the data was loaded into {@code outValue},
 * {@code false} otherwise
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"3,4",1,"The assignment statement for `outValue.string` within the if block has been changed to include a null check and has introduced a new return statement for the case when `getPooledStringForCookie` returns null. This represents control dependency change (since the additional null check introduces a new control flow path) and other statement change due to the altered assignment condition, so the change types are 3 and 4.","The condition introduced by the null check can potentially cause the method to return a different value (false in case `getPooledStringForCookie` returns null where it would previously have proceeded to return true), leading to a change in the API's behavior. Hence the CI type is 1."
985,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",30,31,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(initialValues, ""initialValues"");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, mAttributionTag, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}","{
    Objects.requireNonNull(url, ""url"");
    Objects.requireNonNull(initialValues, ""initialValues"");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mAttributionSource, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The change in the implementation is the removal of 'mPackageName' and 'mAttributionTag' and the addition of 'mAttributionSource' in the 'mContentProvider.bulkInsert' method call, there is no change in exception handling or return statements, so the change type is 5 (Dependent API changed).","The change seems to simply update the method to use a new parameter 'mAttributionSource', which likely encapsulates 'mPackageName' and 'mAttributionTag'. Provided that 'mAttributionSource' is correctly initialized with 'mPackageName' and 'mAttributionTag', this change should not introduce a compatibility issue concerning different return values or exception handling behavior, therefore, the CI type is 0 (No Compatibility Issue)."
986,<android.companion.AssociationRequest.Builder: AssociationRequest build()>,30,31,<android.companion.AssociationRequest.Builder: AssociationRequest build()>,<android.companion.AssociationRequest.Builder: AssociationRequest build()>,0,"{
    markUsed();
    return new AssociationRequest(mSingleDevice, mDeviceFilters);
}","{
    markUsed();
    return new AssociationRequest(mSingleDevice, emptyIfNull(mDeviceFilters), mDeviceProfile, null, null, -1L, false);
}",1,"/**
 * @inheritDoc
 */
","/**
 * @inheritDoc
 */
",-1,"[@NonNull, @Override]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters passed to the constructor of AssociationRequest have changed, adding new parameters (mDeviceProfile, null, null, -1L, false), which implies that the method now relies on a modified internal API (the constructor of AssociationRequest) and the parameters vary between versions. Therefore, the change type is 1 for the return statement changed and 5 for the dependent API changed.","Since the constructor parameters for AssociationRequest have changed, the object created and returned by the build() method could potentially have different behavior or state. This means the API could return different values between versions, hence the CI type is 1."
987,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,30,31,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,<android.app.Activity: boolean shouldUpRecreateTask(Intent)>,0,"{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityTaskManager.getService().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}","{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityClient.getInstance().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (NameNotFoundException e) {
        return false;
    }
}",1,"/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
","/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","1,2","The dependent API called within the try block has changed from ActivityTaskManager.getService().shouldUpRecreateTask to ActivityClient.getInstance().shouldUpRecreateTask, which is a change type 5. Additionally, the exception handling statement for RemoteException has been deleted in the late version, which is a change type 2.","The change of the dependent API could possibly lead to a different return value due to differences in the implementation of shouldUpRecreateTask method between ActivityTaskManager and ActivityClient, which is a CI type 1. The removal of RemoteException handling no longer returns false when a RemoteException is thrown, thereby causing a different behavior, which is a CI type 2."
988,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onAppStatusChanged(BluetoothDevice,boolean)>",30,31,"<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onAppStatusChanged(BluetoothDevice,boolean)>","<android.bluetooth.BluetoothHidDevice.CallbackWrapper: void onAppStatusChanged(BluetoothDevice,boolean)>",0,"{
    clearCallingIdentity();
    mExecutor.execute(() -> mCallback.onAppStatusChanged(pluggedDevice, registered));
}","{
    Attributable.setAttributionSource(pluggedDevice, mAttributionSource);
    final long token = clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onAppStatusChanged(pluggedDevice, registered));
    } finally {
        restoreCallingIdentity(token);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The changes between the early and late versions include the addition of setting the attribution source for pluggedDevice and managing calling identity with a try-finally block (clearCallingIdentity and restoreCallingIdentity). These modifications do not impact the return type or value of the method since the method's return type is void and has no return statement. Because these changes are about code maintainability and security (preserving and restoring the identity of the caller), they classify as 4 (Other statement changed).",There is no Compatibility Issue since the behavior of the method in terms of its input-output contract remains the same; it still executes the lambda expression in mExecutor without changing the outcome for the API consumer. The addition of attribution source management and calling identity does not affect the API's observable behavior or any exception it may throw.
989,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,30,31,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,<android.view.ViewConfiguration: ViewConfiguration get(Context)>,0,"{
    if (!context.isUiContext() && vmIncorrectContextUseEnabled()) {
        final String errorMessage = ""Tried to access UI constants from a non-visual Context:"" + context;
        final String message = ""UI constants, such as display metrics or window metrics, "" + ""must be accessed from Activity or other visual Context. "" + ""Use an Activity or a Context created with "" + ""Context#createWindowContext(int, Bundle), which are adjusted to the "" + ""configuration and visual bounds of an area on screen"";
        final Exception exception = new IllegalArgumentException(errorMessage);
        StrictMode.onIncorrectContextUsed(message, exception);
        Log.e(TAG, errorMessage + message, exception);
    }
    final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    final int density = (int) (100.0f * metrics.density);
    ViewConfiguration configuration = sConfigurations.get(density);
    if (configuration == null) {
        configuration = new ViewConfiguration(context);
        sConfigurations.put(density, configuration);
    }
    return configuration;
}","{
    StrictMode.assertConfigurationContext(context, ""ViewConfiguration"");
    final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    final int density = (int) (100.0f * metrics.density);
    ViewConfiguration configuration = sConfigurations.get(density);
    if (configuration == null) {
        configuration = new ViewConfiguration(context);
        sConfigurations.put(density, configuration);
    }
    return configuration;
}",1,"/**
 * Returns a configuration for the specified visual {@link Context}. The configuration depends
 * on various parameters of the {@link Context}, like the dimension of the display or the
 * density of the display.
 *
 * @param context A visual {@link Context} used to initialize the view configuration. It must
 * be {@link Activity} or other {@link Context} created with
 * {@link Context#createWindowContext(int, Bundle)}.
 */
","// TODO(b/182007470): Use @ConfigurationContext instead
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4,5",0,"The exception handling statement has changed significantly, and there is a control dependency change where a logging statement has been removed along with the manual exception throwing since it's replaced with the StrictMode.assertConfigurationContext method. Additionally, the dependent API has changed from vmIncorrectContextUseEnabled() and manual exception construction to StrictMode.assertConfigurationContext, which is a different method with a different purpose. Other statements have been removed as part of this change process (log message construction and logging), so the change types are 2,3,4,5.","While the exception handling statement has changed, it does not necessarily lead to a Compatibility Issue related to the behavior of the method's returns or exception throws because StrictMode.assertConfigurationContext enforces the same policy with a different implementation, intending to throw an exception in case of an incorrect context use. Since it's an internal consistency check regarding the usage of the context, and should the context be incorrect, both versions would result in a similar kind of exception, though the exception details might differ. The API's external behavior in terms of returning a ViewConfiguration object remains unchanged. Hence, there's no Compatibility Issue."
991,<android.net.VpnService: boolean protect(int)>,30,31,<android.net.VpnService: boolean protect(int)>,<android.net.VpnService: boolean protect(int)>,0,"{
    return NetworkUtils.protectFromVpn(socket);
}","{
    return NetworkUtilsInternal.protectFromVpn(socket);
}",1,"/**
 * Protect a socket from VPN connections. After protecting, data sent
 * through this socket will go directly to the underlying network,
 * so its traffic will not be forwarded through the VPN.
 * This method is useful if some connections need to be kept
 * outside of VPN. For example, a VPN tunnel should protect itself if its
 * destination is covered by VPN routes. Otherwise its outgoing packets
 * will be sent back to the VPN interface and cause an infinite loop. This
 * method will fail if the application is not prepared or is revoked.
 *
 * <p class=""note"">The socket is NOT closed by this method.
 *
 * @return {@code true} on success.
 */
","/**
 * Protect a socket from VPN connections. After protecting, data sent
 * through this socket will go directly to the underlying network,
 * so its traffic will not be forwarded through the VPN.
 * This method is useful if some connections need to be kept
 * outside of VPN. For example, a VPN tunnel should protect itself if its
 * destination is covered by VPN routes. Otherwise its outgoing packets
 * will be sent back to the VPN interface and cause an infinite loop. This
 * method will fail if the application is not prepared or is revoked.
 *
 * <p class=""note"">The socket is NOT closed by this method.
 *
 * @return {@code true} on success.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from NetworkUtils.protectFromVpn(socket) to NetworkUtilsInternal.protectFromVpn(socket), so the code change type is 5.","Assuming NetworkUtilsInternal.protectFromVpn(socket) is designed to work exactly as NetworkUtils.protectFromVpn(socket), with perhaps just an internal refactor that does not alter the external contract of the protect(int) method, there may not be a Compatibility Issue. Therefore, the CI type is 0, as the returned value is expected to behave the same way from the caller's perspective, and there's no direct change to the API signature or behavior as per the information provided. However, without explicit information about the behavior of the new dependent method, this assessment is based on an assumption and should ideally be validated with the actual implementation details of NetworkUtilsInternal.protectFromVpn(socket)."
992,<android.hardware.biometrics.BiometricPrompt: CharSequence getSubtitle()>,30,31,<android.hardware.biometrics.BiometricPrompt: CharSequence getSubtitle()>,<android.hardware.biometrics.BiometricPrompt: CharSequence getSubtitle()>,0,"{
    return mBundle.getCharSequence(KEY_SUBTITLE);
}","{
    return mPromptInfo.getSubtitle();
}",1,"/**
 * Gets the subtitle for the prompt, as set by {@link Builder#setSubtitle(CharSequence)}.
 * @return The subtitle for the prompt, or null if the prompt has no subtitle.
 */
","/**
 * Gets the subtitle for the prompt, as set by {@link Builder#setSubtitle(CharSequence)}.
 * @return The subtitle for the prompt, or null if the prompt has no subtitle.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation of the method changed from using 'mBundle.getCharSequence(KEY_SUBTITLE)' to 'mPromptInfo.getSubtitle()', which is a change in the method through which the subtitle is retrieved. This is classified as another statement changed (4) and a change in the dependent API (5).","Even though the annotations haven't changed and both are annotated as @Nullable, the source from which the subtitle is retrieved has changed. Because 'mBundle.getCharSequence(KEY_SUBTITLE)' might not return the same value as 'mPromptInfo.getSubtitle()', there's a potential that the API will return different values, leading to a compatibility issue (1)."
993,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",30,31,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>","<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",0,"{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append(""INSERT"");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append("" INTO "");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && !initialValues.isEmpty()) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "","" : """");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append("" VALUES ("");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? "",?"" : ""?"");
            }
        } else {
            sql.append(nullColumnHack + "") VALUES (NULL"");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        StringBuilder sql = new StringBuilder();
        sql.append(""INSERT"");
        sql.append(CONFLICT_VALUES[conflictAlgorithm]);
        sql.append("" INTO "");
        sql.append(table);
        sql.append('(');
        Object[] bindArgs = null;
        int size = (initialValues != null && !initialValues.isEmpty()) ? initialValues.size() : 0;
        if (size > 0) {
            bindArgs = new Object[size];
            int i = 0;
            for (String colName : initialValues.keySet()) {
                sql.append((i > 0) ? "","" : """");
                sql.append(colName);
                bindArgs[i++] = initialValues.get(colName);
            }
            sql.append(')');
            sql.append("" VALUES ("");
            for (i = 0; i < size; i++) {
                sql.append((i > 0) ? "",?"" : ""?"");
            }
        } else {
            sql.append(nullColumnHack).append("") VALUES (NULL"");
        }
        sql.append(')');
        SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);
        try {
            return statement.executeInsert();
        } finally {
            statement.close();
        }
    } finally {
        releaseReference();
    }
}",1,"/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 * input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 * or an error occurred.
 */
","/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack optional; may be <code>null</code>.
 * SQL doesn't allow inserting a completely empty row without
 * naming at least one column name.  If your provided <code>initialValues</code> is
 * empty, no column names are known and an empty row can't be inserted.
 * If not set to null, the <code>nullColumnHack</code> parameter
 * provides the name of nullable column name to explicitly insert a NULL into
 * in the case where your <code>initialValues</code> is empty.
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row OR <code>-1</code> if either the
 * input parameter <code>conflictAlgorithm</code> = {@link #CONFLICT_IGNORE}
 * or an error occurred.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the line where `nullColumnHack` is appended to the `StringBuilder sql`. In the early version, the operation is done with `sql.append(nullColumnHack + "") VALUES (NULL"");`, which uses string concatenation before appending to `sql`. In the late version, it is split into `sql.append(nullColumnHack).append("") VALUES (NULL"");`, which appends two separate strings to `sql` without string concatenation. This is a change in the string append operation, which is categorized as ""Other statement changed"".","This change does not affect the return value or the exception handling of the method. It is only a refactoring of code for better performance or readability. Thus, there is no Compatibility Issue as it doesn't alter the behavior of the method from the API user's perspective."
994,<android.view.WindowInsets.Builder: WindowInsets build()>,30,31,<android.view.WindowInsets.Builder: WindowInsets build()>,<android.view.WindowInsets.Builder: WindowInsets build()>,0,"{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, systemBars(), false);
}","{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, mRoundedCorners, mPrivacyIndicatorBounds, systemBars(), false);
}",1,"/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */
","/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,1,1,"The constructor for WindowInsets called in the return statement has additional parameters in the late version (mRoundedCorners, mPrivacyIndicatorBounds), so the code change type is 1.","The additional parameters in the constructor may result in a different WindowInsets object being returned, which indicates a changed return value. Hence, the CI type is 1."
995,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int,boolean)>",30,31,"<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int,boolean)>","<android.provider.Settings.NameValueCache: boolean putStringForUser(ContentResolver,String,String,String,boolean,int,boolean)>",0,"{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        if (tag != null) {
            arg.putString(CALL_METHOD_TAG_KEY, tag);
        }
        if (makeDefault) {
            arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
        }
        if (overrideableByRestore) {
            arg.putBoolean(CALL_METHOD_OVERRIDEABLE_BY_RESTORE_KEY, true);
        }
        IContentProvider cp = mProviderHolder.getProvider(cr);
        cp.call(cr.getPackageName(), cr.getAttributionTag(), mProviderHolder.mUri.getAuthority(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}","{
    try {
        Bundle arg = new Bundle();
        arg.putString(Settings.NameValueTable.VALUE, value);
        arg.putInt(CALL_METHOD_USER_KEY, userHandle);
        if (tag != null) {
            arg.putString(CALL_METHOD_TAG_KEY, tag);
        }
        if (makeDefault) {
            arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
        }
        if (overrideableByRestore) {
            arg.putBoolean(CALL_METHOD_OVERRIDEABLE_BY_RESTORE_KEY, true);
        }
        IContentProvider cp = mProviderHolder.getProvider(cr);
        cp.call(cr.getAttributionSource(), mProviderHolder.mUri.getAuthority(), mCallSetCommand, name, arg);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't set key "" + name + "" in "" + mUri, e);
        return false;
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method signature remains the same, but the implementation has been changed with a different call to the 'cp.call()' method, where the parameter cr.getPackageName(), cr.getAttributionTag() has been replaced with cr.getAttributionSource() in the late version, meaning that a dependent API's method call has changed its parameters. This classifies as the code change type 5.","The change in the dependent API call parameters might potentially lead to different behavior of the 'cp.call()' method, and as a result, the return value of the current API might be different. Therefore, the potential Compatibility Issue could arise from the different return value, categorizing it as CI type 1."
996,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",30,31,"<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>","<android.provider.DocumentsProvider: void attachInfo(Context,ProviderInfo)>",0,"{
    registerAuthority(info.authority);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}","{
    registerAuthority(info.authority);
    // Validity check our setup
    if (!info.exported) {
        throw new SecurityException(""Provider must be exported"");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException(""Provider must grantUriPermissions"");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException(""Provider must be protected by MANAGE_DOCUMENTS"");
    }
    super.attachInfo(context, info);
}",1,"/**
 * Implementation is provided by the parent class.
 */
","/**
 * Implementation is provided by the parent class.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is only a comment change from ""Sanity check our setup"" to ""Validity check our setup"". There is no change to the executable code itself between the early and the late versions.","No compatibility issue exists as there is no change in the executable code; therefore, the behavior of the API remains the same across both versions."
997,<android.content.res.XmlBlock.Parser: String getAttributeValue(int)>,30,31,<android.content.res.XmlBlock.Parser: String getAttributeValue(int)>,<android.content.res.XmlBlock.Parser: String getAttributeValue(int)>,0,"{
    int id = nativeGetAttributeStringValue(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeValue of "" + index + "" = "" + id);
    if (id >= 0)
        return mStrings.get(id).toString();
    // May be some other type...  check and try to convert if so.
    int t = nativeGetAttributeDataType(mParseState, index);
    if (t == TypedValue.TYPE_NULL) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    int v = nativeGetAttributeData(mParseState, index);
    return TypedValue.coerceToString(t, v);
}","{
    int id = nativeGetAttributeStringValue(mParseState, index);
    if (DEBUG)
        System.out.println(""getAttributeValue of "" + index + "" = "" + id);
    if (id >= 0)
        return getSequenceString(mStrings.getSequence(id));
    // May be some other type...  check and try to convert if so.
    int t = nativeGetAttributeDataType(mParseState, index);
    if (t == TypedValue.TYPE_NULL) {
        throw new IndexOutOfBoundsException(String.valueOf(index));
    }
    int v = nativeGetAttributeData(mParseState, index);
    return TypedValue.coerceToString(t, v);
}",1,,,-1,,[@NonNull],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method used to get the string value has changed from mStrings.get(id).toString() to getSequenceString(mStrings.getSequence(id)), and the return value may be different due to this change. Additionally, there is a dependent API change because getSequenceString method is used in the late version instead of toString. The introduction of the NonNull annotation in the late version means the method is not expected to return null but that does not imply a compatibility issue by itself, as it's a contract for callers rather than a change in behavior. Therefore, the changes are classified as 1 for the return statement change, 4 for the change in internal method calls, and 5 for utilizing a changed dependent API.","As the implementation of getting the attribute string value has changed, this could potentially lead to different return values being produced. Thus, there is a compatibility issue of type 1 caused by potential different return values."
998,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,30,31,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,<android.accessibilityservice.AccessibilityService.SoftKeyboardController: int getShowMode()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getSoftKeyboardShowMode();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return SHOW_MODE_AUTO;
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getSoftKeyboardShowMode();
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to set soft keyboard behavior"", re);
            re.rethrowFromSystemServer();
        }
    }
    return SHOW_MODE_AUTO;
}",1,"/**
 * Returns the show mode of the soft keyboard.
 *
 * @return the current soft keyboard show mode
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
","/**
 * Returns the show mode of the soft keyboard.
 *
 * @return the current soft keyboard show mode
 *
 * @see AccessibilityService#SHOW_MODE_AUTO
 * @see AccessibilityService#SHOW_MODE_HIDDEN
 * @see AccessibilityService#SHOW_MODE_IGNORE_HARD_KEYBOARD
 */
",-1,[@SoftKeyboardShowMode],[@SoftKeyboardShowMode],-1,-1,-1,-1,-1,-1,5,0,"The dependent API AccessibilityInteractionClient.getInstance() is now receiving a different parameter (mService instead of no parameter), which indicates that the dependent API has changed and therefore change type is 5.",There is no compatibility issue detected since the change does not affect the return values or exception handling of the method itself. The change to the parameter of the getInstance method is unrelated to how the getShowMode method behaves once the connection is obtained. The rest of the code and the behavior remain consistent between versions.
999,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,30,31,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothHidDevice: int getConnectionState(BluetoothDevice)>,0,"{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return STATE_DISCONNECTED;
}","{
    final IBluetoothHidDevice service = getService();
    if (service != null) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, ""Proxy not attached to service"");
    }
    return STATE_DISCONNECTED;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],"[@Override, @RequiresBluetoothConnectPermission, @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The call to getConnectionState in the late version includes an additional parameter, mAttributionSource. The annotations have also been updated to include new permission requirements. Therefore, the code change types are 4 (for the addition of a new parameter to the method call) and 5 (for dependent API change due to the additional parameter requirement).","Although there is an additional parameter in the method call and new annotations for permissions, these changes do not affect the return value or the exception handling of the method. The API still returns the connection state or STATE_DISCONNECTED, and the RemoteException handling remains the same. Therefore, there is no compatibility issue, and the CI type is 0."
1000,"<android.app.UiAutomation: void revokeRuntimePermissionAsUser(String,String,UserHandle)>",30,31,"<android.app.UiAutomation: void revokeRuntimePermissionAsUser(String,String,UserHandle)>","<android.app.UiAutomation: void revokeRuntimePermissionAsUser(String,String,UserHandle)>",0,"{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Revoking runtime permission"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.revokeRuntimePermission(packageName, permission, userHandle.getIdentifier());
    } catch (Exception e) {
        throw new SecurityException(""Error granting runtime permission"", e);
    }
}","{
    try {
        if (DEBUG) {
            Log.i(LOG_TAG, ""Revoking runtime permission"");
        }
        // Calling out without a lock held.
        mUiAutomationConnection.revokeRuntimePermission(packageName, permission, userHandle.getIdentifier());
    } catch (Exception e) {
        throw new SecurityException(""Error granting runtime permission"", e);
    }
}",1,"/**
 * Revokes a runtime permission from a package.
 * @param packageName The package to which to grant.
 * @param permission The permission to grant.
 * @throws SecurityException if unable to revoke the permission.
 */
","/**
 * Revokes a runtime permission from a package.
 *
 * @param packageName The package to which to grant.
 * @param permission The permission to grant.
 * @throws SecurityException if unable to revoke the permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The synchronized block and the call to throwIfNotConnectedLocked() within it have been removed, so the code change type is 4.","The functionality to check and ensure the connection ('throwIfNotConnectedLocked') before attempting to revoke a permission has been removed. Since this check is removed and it does not change the return value or type, nor does it introduce new exception handling scenarios, there should be no Compatibility Issue with respect to the external behavior of the method. The change affects only internal checks without altering the external contract of the API method, so the CI type is 0."
1001,<android.os.BugreportManager.DumpstateListener: void onFinished()>,30,31,<android.os.BugreportManager.DumpstateListener: void onFinished()>,<android.os.BugreportManager.DumpstateListener: void onFinished()>,0,"{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onFinished();
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}","{
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> mCallback.onFinished());
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The difference between the two implementations is a slight simplification in the lambda expression within `execute()` method from `() -> { mCallback.onFinished(); }` to `() -> mCallback.onFinished()`. Both lambda expressions are functionally identical; the latter is just a more concise way to write the former when only a single expression is being executed in the lambda. This is simply a syntactic change and does not alter the behavior of the method. Therefore, the code change type is 4.","There is no Compatibility Issue because the change between the two versions doesn't alter the functional behavior of the method `onFinished()`. The difference is purely in syntax and does not affect the method's outputs or side effects when it is called. Thus, the CI type is 0."
1002,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo getRootInActiveWindow()>,30,31,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo getRootInActiveWindow()>,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo getRootInActiveWindow()>,0,"{
    return AccessibilityInteractionClient.getInstance().getRootInActiveWindow(mConnectionId);
}","{
    return AccessibilityInteractionClient.getInstance(this).getRootInActiveWindow(mConnectionId);
}",1,"/**
 * Gets the root node in the currently active window if this service
 * can retrieve window content. The active window is the one that the user
 * is currently touching or the window with input focus, if the user is not
 * touching any window. It could be from any logical display.
 * <p>
 * The currently active window is defined as the window that most recently fired one
 * of the following events:
 * {@link AccessibilityEvent#TYPE_WINDOW_STATE_CHANGED},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_ENTER},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_EXIT}.
 * In other words, the last window shown that also has input focus.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to access the root node your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @return The root node if this service can retrieve window content.
 */
","/**
 * Gets the root node in the currently active window if this service
 * can retrieve window content. The active window is the one that the user
 * is currently touching or the window with input focus, if the user is not
 * touching any window. It could be from any logical display.
 * <p>
 * The currently active window is defined as the window that most recently fired one
 * of the following events:
 * {@link AccessibilityEvent#TYPE_WINDOW_STATE_CHANGED},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_ENTER},
 * {@link AccessibilityEvent#TYPE_VIEW_HOVER_EXIT}.
 * In other words, the last window shown that also has input focus.
 * </p>
 * <p>
 * <strong>Note:</strong> In order to access the root node your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * </p>
 *
 * @return The root node if this service can retrieve window content.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method getInstance() is called with a different argument; it went from getInstance() to getInstance(this), which indicates that there is a change in the dependent API.","There is no indication that the change in how getInstance() is called would affect the return value or the exception handling of the getRootInActiveWindow() method since the method signature of getRootInActiveWindow() itself hasn't changed. It is assumed that the altered getInstance argument still supports the same method contract for getRootInActiveWindow(). Therefore, based on the information provided, there should be no Compatibility Issue."
1003,<android.os.UserHandle: boolean equals(Object)>,30,31,<android.os.UserHandle: boolean equals(Object)>,<android.os.UserHandle: boolean equals(Object)>,0,"{
    try {
        if (obj != null) {
            UserHandle other = (UserHandle) obj;
            return mHandle == other.mHandle;
        }
    } catch (ClassCastException e) {
    }
    return false;
}","{
    try {
        if (obj != null) {
            UserHandle other = (UserHandle) obj;
            return mHandle == other.mHandle;
        }
    } catch (ClassCastException ignore) {
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual code logic, only the name of the exception variable was changed from 'e' to 'ignore', which doesn't affect how the code executes.","No compatibility issue is introduced because there is no change in regard to the difference in return values, exception handling, or any other behavior of the method."
1004,<android.os.Vibrator: int[] areEffectsSupported(int)>,30,31,<android.os.Vibrator: int[] areEffectsSupported(int)>,<android.os.Vibrator: int[] areEffectsSupported(int)>,0,"{
    final int[] support = new int[effectIds.length];
    Arrays.fill(support, VIBRATION_EFFECT_SUPPORT_NO);
    return support;
}","{
    VibratorInfo info = getInfo();
    int[] supported = new int[effectIds.length];
    for (int i = 0; i < effectIds.length; i++) {
        supported[i] = info.isEffectSupported(effectIds[i]);
    }
    return supported;
}",1,"/**
 * Query whether the vibrator supports the given effects.
 *
 * Not all hardware reports its effect capabilities, so the system may not necessarily know
 * whether an effect is supported or not.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain {@link #VIBRATION_EFFECT_SUPPORT_YES} if the effect at that same index in the
 * querying array is supported, {@link #VIBRATION_EFFECT_SUPPORT_NO} if it isn't supported, or
 * {@link #VIBRATION_EFFECT_SUPPORT_UNKNOWN} if the system can't determine whether it's
 * supported or not.
 *
 * @param effectIds Which effects to query for.
 * @return An array containing the systems current knowledge about whether the given effects
 * are supported or not.
 */
","/**
 * Query whether the vibrator supports the given effects.
 *
 * Not all hardware reports its effect capabilities, so the system may not necessarily know
 * whether an effect is supported or not.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain {@link #VIBRATION_EFFECT_SUPPORT_YES} if the effect at that same index in the
 * querying array is supported, {@link #VIBRATION_EFFECT_SUPPORT_NO} if it isn't supported, or
 * {@link #VIBRATION_EFFECT_SUPPORT_UNKNOWN} if the system can't determine whether it's
 * supported or not.
 *
 * @param effectIds Which effects to query for.
 * @return An array containing the systems current knowledge about whether the given effects
 * are supported or not.
 */
",-1,"[@NonNull, @VibrationEffectSupport]","[@NonNull, @VibrationEffectSupport]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method has changed from filling an array with 'VIBRATION_EFFECT_SUPPORT_NO' to invoking 'info.isEffectSupported(effectIds[i])' for each element of the array, which is a dependent API change (5). Also, return statement changed since it now returns the result of the 'isEffectSupported' method instead of a static value (1).","The behavior of the API has changed significantly because the method now returns an array based on the results of 'info.isEffectSupported' method for each ID provided, instead of returning an array filled with 'VIBRATION_EFFECT_SUPPORT_NO'. This change in the return value is a clear compatibility issue, thus CI type is 1."
1006,<android.os.BatterySaverPolicyConfig.Builder: Builder setDisableSoundTrigger(boolean)>,30,31,<android.os.BatterySaverPolicyConfig.Builder: Builder setDisableSoundTrigger(boolean)>,<android.os.BatterySaverPolicyConfig.Builder: Builder setDisableSoundTrigger(boolean)>,0,"{
    mDisableSoundTrigger = disableSoundTrigger;
    return this;
}","{
    if (disableSoundTrigger) {
        mSoundTriggerMode = PowerManager.SOUND_TRIGGER_MODE_ALL_DISABLED;
    } else {
        mSoundTriggerMode = PowerManager.SOUND_TRIGGER_MODE_ALL_ENABLED;
    }
    return this;
}",1,"/**
 * Set whether or not to disable  {@link android.hardware.soundtrigger.SoundTrigger}
 * while in Battery Saver.
 */
","/**
 * Set whether or not to disable  {@link android.hardware.soundtrigger.SoundTrigger}
 * while in Battery Saver.
 * @deprecated Use {@link #setSoundTriggerMode(int)} instead.
 */
",-1,[@NonNull],"[@Deprecated, @NonNull]",-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency and assignment statement have changed. In the early version, the method directly sets the 'mDisableSoundTrigger' field, whereas in the late version, it sets 'mSoundTriggerMode' to a value based on 'disableSoundTrigger', resulting in a control dependency and other statement changes (3,4).","Despite the change in the actual properties being modified within the method, the method's contract, as represented by its signature and return type, has not been altered. The method returns 'this' (the same Builder object) in both versions which implies it maintains the method chaining pattern without changing the expected return type or value. Therefore, there is no Compatibility Issue because the caller of this method will receive the same output type (the Builder object) irrespective of the internal changes."
1007,<android.os.WorkSource: boolean add(WorkSource)>,30,31,<android.os.WorkSource: boolean add(WorkSource)>,<android.os.WorkSource: boolean add(WorkSource)>,0,"{
    synchronized (sTmpWorkSource) {
        boolean uidAdded = updateLocked(other, false, false);
        boolean chainAdded = false;
        if (other.mChains != null) {
            // is large. We could look into optimizing it if it proves problematic.
            if (mChains == null) {
                mChains = new ArrayList<>(other.mChains.size());
            }
            for (WorkChain wc : other.mChains) {
                if (!mChains.contains(wc)) {
                    mChains.add(new WorkChain(wc));
                }
            }
        }
        return uidAdded || chainAdded;
    }
}","{
    synchronized (sTmpWorkSource) {
        boolean uidAdded = updateLocked(other, false, false);
        boolean chainAdded = false;
        if (other.mChains != null) {
            // is large. We could look into optimizing it if it proves problematic.
            if (mChains == null) {
                mChains = new ArrayList<>(other.mChains.size());
            }
            for (WorkChain wc : other.mChains) {
                if (!mChains.contains(wc)) {
                    mChains.add(new WorkChain(wc));
                    chainAdded = true;
                }
            }
        }
        return uidAdded || chainAdded;
    }
}",1,"/**
 * Merge the contents of <var>other</var> WorkSource in to this one.
 *
 * @param other The other WorkSource whose contents are to be merged.
 * @return Returns true if any new sources were added.
 */
","/**
 * Merge the contents of <var>other</var> WorkSource in to this one.
 *
 * @param other The other WorkSource whose contents are to be merged.
 * @return Returns true if any new sources were added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code change is within a for-loop where a 'chainAdded = true;' statement has been added, and thus falls under the category of ""Other statement changed.""","Because the 'chainAdded' variable is now being updated within the loop, which was not the case in the early version, this leads to a change in the return value of the method dependent on the condition. If 'mChains.contains(wc)' is false for any 'wc' in 'other.mChains', 'chainAdded' will now be set to true, which can affect the final return value. Therefore, this can lead to a CI caused by potential different return values, classified as type 1."
1010,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,30,31,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,0,"{
    final String canonicalValue;
    if (mCanonicalRepresentation == REPRESENTATION_ENCODED) {
        canonicalValue = encoded;
    } else if (mCanonicalRepresentation == REPRESENTATION_DECODED) {
        canonicalValue = decoded;
    } else {
        throw new IllegalArgumentException(""Unknown representation: "" + mCanonicalRepresentation);
    }
    if (canonicalValue == NOT_CACHED) {
        throw new AssertionError(""Canonical value not cached ("" + mCanonicalRepresentation + "")"");
    }
    parcel.writeInt(mCanonicalRepresentation);
    parcel.writeString8(canonicalValue);
}","{
    final String canonicalValue;
    if (mCanonicalRepresentation == REPRESENTATION_ENCODED) {
        canonicalValue = encoded;
    } else if (mCanonicalRepresentation == REPRESENTATION_DECODED) {
        canonicalValue = decoded;
    } else {
        throw new IllegalArgumentException(""Unknown representation: "" + mCanonicalRepresentation);
    }
    if (canonicalValue == NotCachedHolder.NOT_CACHED) {
        throw new AssertionError(""Canonical value not cached ("" + mCanonicalRepresentation + "")"");
    }
    parcel.writeInt(mCanonicalRepresentation);
    parcel.writeString8(canonicalValue);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the reference to NOT_CACHED has changed to NotCachedHolder.NOT_CACHED, which suggests a change in how the NOT_CACHED constant is accessed rather than the logic of the method itself. This could be due to a refactoring to store constants in a common holder class. Since the actual value checked against canonicalValue remains the same, there is no change in the behavior of the method, so the code change type is 4.","There is no Compatibility Issue because the value of canonicalValue against which the check is made hasn't changed, only the way it is referenced has changed, thus it does not affect how the API behaves."
1011,<android.net.Uri.AbstractHierarchicalUri: String getHost()>,30,31,<android.net.Uri.AbstractHierarchicalUri: String getHost()>,<android.net.Uri.AbstractHierarchicalUri: String getHost()>,0,"{
    @SuppressWarnings(""StringEquality"") boolean cached = (host != NOT_CACHED);
    return cached ? host : (host = parseHost());
}","{
    @SuppressWarnings(""StringEquality"") boolean cached = (host != NotCachedHolder.NOT_CACHED);
    return cached ? host : (host = parseHost());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The value checked against the 'host' variable has been updated from a direct value to one from an inner class (NotCachedHolder.NOT_CACHED). This qualifies as an 'Other statement changed' since it's a modification of an expression value. Also, this change may be considered as 'Dependent API changed' since the reference to NOT_CACHED has changed to an inner class static member, which could come from an external dependency.",This change does not create a compatibility issue because the logic of how `host` is determined remains functionally equivalent. The conditional statement's logic itself is not altered nor does it introduce any new behavior or way the method might fail. It is essentially a refactoring that maintains the same logic but refers to 'NOT_CACHED' from possibly a different location or in a different way.
1012,"<android.view.inputmethod.InlineSuggestion: void inflate(Context,Size,Executor,Consumer<InlineContentView>)>",30,31,"<android.view.inputmethod.InlineSuggestion: void inflate(Context,Size,Executor,Consumer<InlineContentView>)>","<android.view.inputmethod.InlineSuggestion: void inflate(Context,Size,Executor,Consumer<InlineContentView>)>",0,"{
    final Size minSize = mInfo.getInlinePresentationSpec().getMinSize();
    final Size maxSize = mInfo.getInlinePresentationSpec().getMaxSize();
    if (!isValid(size.getWidth(), minSize.getWidth(), maxSize.getWidth()) || !isValid(size.getHeight(), minSize.getHeight(), maxSize.getHeight())) {
        throw new IllegalArgumentException(""size is neither between min:"" + minSize + "" and max:"" + maxSize + "", nor wrap_content"");
    }
    mInlineContentCallback = getInlineContentCallback(context, callbackExecutor, callback);
    if (mContentProvider == null) {
        callbackExecutor.execute(() -> callback.accept(/* view */
        null));
        return;
    }
    try {
        mContentProvider.provideContent(size.getWidth(), size.getHeight(), new InlineContentCallbackWrapper(mInlineContentCallback));
    } catch (RemoteException e) {
        Slog.w(TAG, ""Error creating suggestion content surface: "" + e);
        callbackExecutor.execute(() -> callback.accept(/* view */
        null));
    }
}","{
    final Size minSize = mInfo.getInlinePresentationSpec().getMinSize();
    final Size maxSize = mInfo.getInlinePresentationSpec().getMaxSize();
    if (!isValid(size.getWidth(), minSize.getWidth(), maxSize.getWidth()) || !isValid(size.getHeight(), minSize.getHeight(), maxSize.getHeight())) {
        throw new IllegalArgumentException(""size is neither between min:"" + minSize + "" and max:"" + maxSize + "", nor wrap_content"");
    }
    InlineSuggestion toolTip = mInfo.getTooltip();
    if (toolTip != null) {
        if (mInlineTooltipUi == null) {
            mInlineTooltipUi = new InlineTooltipUi(context);
        }
    } else {
        mInlineTooltipUi = null;
    }
    mInlineContentCallback = getInlineContentCallback(context, callbackExecutor, callback, mInlineTooltipUi);
    if (mContentProvider == null) {
        callbackExecutor.execute(() -> callback.accept(/* view */
        null));
        mInlineTooltipUi = null;
        return;
    }
    try {
        mContentProvider.provideContent(size.getWidth(), size.getHeight(), new InlineContentCallbackWrapper(mInlineContentCallback));
    } catch (RemoteException e) {
        Slog.w(TAG, ""Error creating suggestion content surface: "" + e);
        callbackExecutor.execute(() -> callback.accept(/* view */
        null));
    }
    if (toolTip == null)
        return;
    final Size tooltipSize = new Size(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
    mInfo.getTooltip().inflate(context, tooltipSize, callbackExecutor, view -> {
        Handler.getMain().post(() -> mInlineTooltipUi.setTooltipView(view));
    });
}",1,"/**
 * Inflates a view with the content of this suggestion at a specific size.
 *
 * <p> Each dimension of the size must satisfy one of the following conditions:
 *
 * <ol>
 * <li>between {@link android.widget.inline.InlinePresentationSpec#getMinSize()} and
 * {@link android.widget.inline.InlinePresentationSpec#getMaxSize()} of the presentation spec
 * from {@code mInfo}
 * <li>{@link ViewGroup.LayoutParams#WRAP_CONTENT}
 * </ol>
 *
 * If the size is set to {@link
 * ViewGroup.LayoutParams#WRAP_CONTENT}, then the size of the inflated view will be just large
 * enough to fit the content, while still conforming to the min / max size specified by the
 * {@link android.widget.inline.InlinePresentationSpec}.
 *
 * <p> The caller can attach an {@link android.view.View.OnClickListener} and/or an
 * {@link android.view.View.OnLongClickListener} to the view in the {@code callback} to receive
 * click and long click events on the view.
 *
 * @param context  Context in which to inflate the view.
 * @param size     The size at which to inflate the suggestion. For each dimension, it maybe an
 * exact value or {@link ViewGroup.LayoutParams#WRAP_CONTENT}.
 * @param callback Callback for receiving the inflated view, where the {@link
 * ViewGroup.LayoutParams} of the view is set as the actual size of the
 * underlying remote view.
 * @throws IllegalArgumentException If an invalid argument is passed.
 * @throws IllegalStateException    If this method is already called.
 */
","/**
 * Inflates a view with the content of this suggestion at a specific size.
 *
 * <p> Each dimension of the size must satisfy one of the following conditions:
 *
 * <ol>
 * <li>between {@link android.widget.inline.InlinePresentationSpec#getMinSize()} and
 * {@link android.widget.inline.InlinePresentationSpec#getMaxSize()} of the presentation spec
 * from {@code mInfo}
 * <li>{@link ViewGroup.LayoutParams#WRAP_CONTENT}
 * </ol>
 *
 * If the size is set to {@link
 * ViewGroup.LayoutParams#WRAP_CONTENT}, then the size of the inflated view will be just large
 * enough to fit the content, while still conforming to the min / max size specified by the
 * {@link android.widget.inline.InlinePresentationSpec}.
 *
 * <p> The caller can attach an {@link android.view.View.OnClickListener} and/or an
 * {@link android.view.View.OnLongClickListener} to the view in the {@code callback} to receive
 * click and long click events on the view.
 *
 * @param context  Context in which to inflate the view.
 * @param size     The size at which to inflate the suggestion. For each dimension, it maybe an
 * exact value or {@link ViewGroup.LayoutParams#WRAP_CONTENT}.
 * @param callback Callback for receiving the inflated view, where the {@link
 * ViewGroup.LayoutParams} of the view is set as the actual size of the
 * underlying remote view.
 * @throws IllegalArgumentException If an invalid argument is passed.
 * @throws IllegalStateException    If this method is already called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"Changes include adding a new block that handles the tooltip, conditionally setting the `mInlineTooltipUi`, and passing `mInlineTooltipUi` as an additional argument to `getInlineContentCallback()`. Also, at the end of the method there's a new block of code to handle tooltips. These additions result in changed other statements and control dependency, so the code change type is 3,4. ","Although there are changes to other statements and control dependencies, these changes are related to the new tooltip feature that does not interfere with the originally intended behavior of the API which is to populate `InlineContentView`. The core functionality and exception handling remain untouched with these additions. The method's signature, return type, and exception handling capabilities are preserved. Therefore, there is no Compatibility Issue as none of the alterations result in different return values/types or exceptions being thrown; they introduce additional functionality but maintain the API's original contract."
1013,"<android.bluetooth.BluetoothManager: List<BluetoothDevice> getDevicesMatchingConnectionStates(int,int[])>",30,31,"<android.bluetooth.BluetoothManager: List<BluetoothDevice> getDevicesMatchingConnectionStates(int,int[])>","<android.bluetooth.BluetoothManager: List<BluetoothDevice> getDevicesMatchingConnectionStates(int,int[])>",0,"{
    if (DBG)
        Log.d(TAG, ""getDevicesMatchingConnectionStates"");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException(""Profile not supported: "" + profile);
    }
    List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return devices;
        devices = iGatt.getDevicesMatchingConnectionStates(states);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return devices;
}","{
    if (DBG)
        Log.d(TAG, ""getDevicesMatchingConnectionStates"");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException(""Profile not supported: "" + profile);
    }
    List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return devices;
        devices = Attributable.setAttributionSource(iGatt.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return devices;
}",1,"/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of the local Bluetooth adapter for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of the local adapter.
 *
 * @param profile GATT or GATT_SERVER
 * @param states Array of states. States can be one of {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING}, {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
","/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of the local Bluetooth adapter for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of the local adapter.
 *
 * @param profile GATT or GATT_SERVER
 * @param states Array of states. States can be one of {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING}, {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",1,"The invocation `iGatt.getDevicesMatchingConnectionStates(states)` is now wrapped with `Attributable.setAttributionSource(...)`, which indicates that a dependent API `Attributable.setAttributionSource` has been added to modify the output of `getDevicesMatchingConnectionStates`. There are no changes to return or exception handling statements or control flow dependencies. So, the code change types are 4 (other statement changed) and 5 (dependent API changed).","Because the result of `iGatt.getDevicesMatchingConnectionStates(states)` is now manipulated by another method `Attributable.setAttributionSource(...)`, it may potentially alter the list of devices being returned. This means that there's a possibility of the API returning a different value between the two versions, resulting in a CI type of 1."
1014,<android.content.pm.parsing.result.ParseInput.DeferredError: int getTargetSdkForChange(long)>,30,31,<android.content.pm.parsing.result.ParseInput.DeferredError: int getTargetSdkForChange(long)>,<android.content.pm.parsing.result.ParseInput.DeferredError: int getTargetSdkForChange(long)>,0,"{
    if (changeId == MISSING_APP_TAG || changeId == EMPTY_INTENT_ACTION_CATEGORY || changeId == RESOURCES_ARSC_COMPRESSED) {
        return Build.VERSION_CODES.Q;
    }
    return -1;
}","{
    if (changeId == MISSING_APP_TAG || changeId == EMPTY_INTENT_ACTION_CATEGORY || changeId == RESOURCES_ARSC_COMPRESSED) {
        return Build.VERSION_CODES.Q;
    }
    if (changeId == MISSING_EXPORTED_FLAG) {
        return Build.VERSION_CODES.R;
    }
    return -1;
}",1,"/**
 * TODO(chiuwinson): This is required because PackageManager#getPackageArchiveInfo
 * cannot read the targetSdk info from the changeId because it requires the
 * READ_COMPAT_CHANGE_CONFIG which cannot be obtained automatically without entering the
 * server process. This should be removed once an alternative is found, or if the API
 * is removed.
 * @return the targetSdk that this change is gated on (> check), or -1 if disabled
 */
","/**
 * TODO(chiuwinson): This is required because PackageManager#getPackageArchiveInfo
 * cannot read the targetSdk info from the changeId because it requires the
 * READ_COMPAT_CHANGE_CONFIG which cannot be obtained automatically without entering the
 * server process. This should be removed once an alternative is found, or if the API
 * is removed.
 * @return the targetSdk that this change is gated on (> check), or -1 if disabled
 */
",-1,"[@IntRange(from = -1, to = Integer.MAX_VALUE)]","[@IntRange(from = -1, to = Integer.MAX_VALUE)]",-1,-1,-1,-1,-1,-1,"1,3",1,"The late version has an additional control dependency, a new 'if' statement including a return statement that returns a different value for a new case (changeId == MISSING_EXPORTED_FLAG), so the code change types are 1 and 3.","The new 'if' control statement with a return statement for the case (changeId == MISSING_EXPORTED_FLAG) means that this API will now return a different value for some inputs where it previously returned -1 in the early version. Therefore, the CI type is 1, as it could return a different value."
1015,"<android.content.res.XmlBlock.Parser: int getAttributeListValue(int,String[],int)>",30,31,"<android.content.res.XmlBlock.Parser: int getAttributeListValue(int,String[],int)>","<android.content.res.XmlBlock.Parser: int getAttributeListValue(int,String[],int)>",0,"{
    int t = nativeGetAttributeDataType(mParseState, idx);
    int v = nativeGetAttributeData(mParseState, idx);
    if (t == TypedValue.TYPE_STRING) {
        return XmlUtils.convertValueToList(mStrings.get(v), options, defaultValue);
    }
    return v;
}","{
    int t = nativeGetAttributeDataType(mParseState, idx);
    int v = nativeGetAttributeData(mParseState, idx);
    if (t == TypedValue.TYPE_STRING) {
        return XmlUtils.convertValueToList(mStrings.getSequence(v), options, defaultValue);
    }
    return v;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The implementation calls `mStrings.getSequence(v)` instead of `mStrings.get(v)` within the 'if' condition block, which suggests a change in the method being called from the `mStrings` object, so the change type is 4,5.","The `mStrings.getSequence(v)` may return different data compared to `mStrings.get(v)`, altering the return value of the method if the condition `t == TypedValue.TYPE_STRING` is true. Therefore, it can lead to a Compatibility Issue due to potentially different return values, so the CI type is 1."
1016,"<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean startInput(int,View,int,int,int)>",30,31,"<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean startInput(int,View,int,int,int)>","<android.view.inputmethod.InputMethodManager.DelegateImpl: boolean startInput(int,View,int,int,int)>",0,"{
    final View servedView;
    synchronized (mH) {
        mCurrentTextBoxAttribute = null;
        mCompletions = null;
        mServedConnecting = true;
        servedView = getServedViewLocked();
    }
    if (servedView != null && servedView.getHandler() != null) {
        // Make sure View checks should be on the UI thread.
        servedView.getHandler().post(() -> {
            if (!servedView.onCheckIsTextEditor()) {
                // servedView has changed and it's not editable.
                synchronized (mH) {
                    maybeCallServedViewChangedLocked(null);
                }
            }
        });
    }
    return startInputInner(startInputReason, focusedView != null ? focusedView.getWindowToken() : null, startInputFlags, softInputMode, windowFlags);
}","{
    final View servedView;
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager.DelegateImpl#startInput"", InputMethodManager.this, null);
    synchronized (mH) {
        mCurrentTextBoxAttribute = null;
        mCompletions = null;
        mServedConnecting = true;
        servedView = getServedViewLocked();
    }
    return startInputInner(startInputReason, focusedView != null ? focusedView.getWindowToken() : null, startInputFlags, softInputMode, windowFlags);
}",1,"/**
 * Used by {@link ImeFocusController} to start input connection.
 */
","/**
 * Used by {@link ImeFocusController} to start input connection.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new method call (ImeTracing.getInstance().triggerClientDump(...)) introduced in the late version, and omission of a large if block that posts a Runnable to a Handler, which does not lead to a change in return statements, control flow, or dependent APIs. The code change type is 4.","The omitted block does not affect the outcome (return value or exceptions thrown) of the startInput method; it's a behavioral aspect that's unlinked from the API's functionality from the caller's perspective. Hence, there is no Compatibility Issue."
1017,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withMatrix(Matrix)>,30,31,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withMatrix(Matrix)>,<android.view.SyncRtSurfaceTransactionApplier.SurfaceParams.Builder: Builder withMatrix(Matrix)>,0,"{
    this.matrix = matrix;
    flags |= FLAG_MATRIX;
    return this;
}","{
    this.matrix = new Matrix(matrix);
    flags |= FLAG_MATRIX;
    return this;
}",1,"/**
 * @param matrix The matrix to apply to the surface.
 * @return this Builder
 */
","/**
 * @param matrix The matrix to apply to the surface.
 * @return this Builder
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement has changed from `this.matrix = matrix;` to `this.matrix = new Matrix(matrix);`, which is not a 'return', 'exception handling', or 'control dependency' change, however, the new object created suggests a change in the way the matrix is stored in `this.matrix`, so the code change type is 4.","There is no Compatibility Issue because this change still assigns a matrix to `this.matrix`, and for the caller, the behaviour of the method remains the same - it sets a matrix and returns the same Builder object for chaining. The change does not affect the returned value or the matrix values after the method call, nor does it introduce changes to exception handling. The change simply ensures that a new copy of the matrix object is created instead of a reference copy. This encapsulation does not alter API behavior externally; therefore, it should not cause any Compatibility Issues."
1020,"<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>",30,31,"<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>","<android.widget.ExpandableListView: boolean setSelectedChild(int,int,boolean)>",0,"{
    ExpandableListPosition elChildPos = ExpandableListPosition.obtainChildPosition(groupPosition, childPosition);
    PositionMetadata flatChildPos = mConnector.getFlattenedPos(elChildPos);
    if (flatChildPos == null) {
        // Shouldn't expand the group, so return false for we didn't set the selection
        if (!shouldExpandGroup)
            return false;
        expandGroup(groupPosition);
        flatChildPos = mConnector.getFlattenedPos(elChildPos);
        // Sanity check
        if (flatChildPos == null) {
            throw new IllegalStateException(""Could not find child"");
        }
    }
    int absoluteFlatPosition = getAbsoluteFlatPosition(flatChildPos.position.flatListPos);
    super.setSelection(absoluteFlatPosition);
    elChildPos.recycle();
    flatChildPos.recycle();
    return true;
}","{
    ExpandableListPosition elChildPos = ExpandableListPosition.obtainChildPosition(groupPosition, childPosition);
    PositionMetadata flatChildPos = mConnector.getFlattenedPos(elChildPos);
    if (flatChildPos == null) {
        // Shouldn't expand the group, so return false for we didn't set the selection
        if (!shouldExpandGroup)
            return false;
        expandGroup(groupPosition);
        flatChildPos = mConnector.getFlattenedPos(elChildPos);
        // Validity check
        if (flatChildPos == null) {
            throw new IllegalStateException(""Could not find child"");
        }
    }
    int absoluteFlatPosition = getAbsoluteFlatPosition(flatChildPos.position.flatListPos);
    super.setSelection(absoluteFlatPosition);
    elChildPos.recycle();
    flatChildPos.recycle();
    return true;
}",1,"/**
 * Sets the selection to the specified child. If the child is in a collapsed
 * group, the group will only be expanded and child subsequently selected if
 * shouldExpandGroup is set to true, otherwise the method will return false.
 *
 * @param groupPosition The position of the group that contains the child.
 * @param childPosition The position of the child within the group.
 * @param shouldExpandGroup Whether the child's group should be expanded if
 * it is collapsed.
 * @return Whether the selection was successfully set on the child.
 */
","/**
 * Sets the selection to the specified child. If the child is in a collapsed
 * group, the group will only be expanded and child subsequently selected if
 * shouldExpandGroup is set to true, otherwise the method will return false.
 *
 * @param groupPosition The position of the group that contains the child.
 * @param childPosition The position of the child within the group.
 * @param shouldExpandGroup Whether the child's group should be expanded if
 * it is collapsed.
 * @return Whether the selection was successfully set on the child.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the implementation code. The only difference is in the comment, which has no effect on the execution or behavior of the method.","Since there is no change in the implementation code, no compatibility issue could arise."
1021,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,30,31,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,<android.bluetooth.BluetoothAdapter: BluetoothLeAdvertiser getBluetoothLeAdvertiser()>,0,"{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}","{
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (mBluetoothLeAdvertiser == null) {
            mBluetoothLeAdvertiser = new BluetoothLeAdvertiser(this);
        }
        return mBluetoothLeAdvertiser;
    }
}",1,"/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
","/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */
",-1,,[@RequiresNoPermission],-1,-1,-1,-1,-1,-1,"1,4",1,"The name of the returned instance variable has changed from sBluetoothLeAdvertiser to mBluetoothLeAdvertiser and there's a change in the instance creation (new BluetoothLeAdvertiser(mManagerService) to new BluetoothLeAdvertiser(this)) resulting in another instance being returned. Also, the placement of the return statement is now within the synchronized block. These constitute a ""Return statement changed"" and ""Other statement changed"", hence the code change types are 1,4.","Since the API now potentially returns a different instance of BluetoothLeAdvertiser (due to the change from sBluetoothLeAdvertiser to mBluetoothLeAdvertiser and from new BluetoothLeAdvertiser(mManagerService) to new BluetoothLeAdvertiser(this)), the behavior could differ from the previous version. This could potentially result in Compatibility Issues due to different return values, so the CI is type 1."
1022,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",30,31,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].migrateExtraStreamToClipData(context);
        intents[i].prepareToLeaveProcess(context);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManager.getService().getIntentSenderWithFeature(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, context.getAttributionTag(), null, null, requestCode, intents, resolvedTypes, flags, options, context.getUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null
    final UserHandle user = context.getUser();
    return getActivitiesAsUser(context, requestCode, intents, flags, options, user != null ? user : UserHandle.of(context.getUserId()));
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The last Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent} objects
 * you supply here should almost always be <em>explicit intents</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,"[@SuppressWarnings(""AndroidFrameworkPendingIntentMutability"")]",-1,-1,-1,-1,-1,-1,"4,5",1,"There is a significant refactoring: the early implementation contains the logic to handle the creation of a PendingIntent explicitly, while the late implementation uses a call to getActivitiesAsUser() instead. This represents not just a dependent API change, but also an 'other statement changed' change type because the statements in the method's body have been entirely altered, thus the code change type is 4,5.","The refactoring to use getActivitiesAsUser() reflects a structural change to the underlying implementation that likely affects the original methodâ€™s behavior. This dependency on the new method implies that if getActivitiesAsUser() has a different implementation or interpretation of parameters, the PendingIntent returned could be different. As a result, the CI type is 1."
1023,<android.os.VibrationEffect: Composition startComposition()>,30,31,<android.os.VibrationEffect: Composition startComposition()>,<android.os.VibrationEffect: Composition startComposition()>,0,"{
    return new VibrationEffect.Composition();
}","{
    return new Composition();
}",1,"/**
 * Start composing a haptic effect.
 *
 * @see VibrationEffect.Composition
 */
","/**
 * Start composing a haptic effect.
 *
 * @see VibrationEffect.Composition
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The class name used in the return statement changed from fully qualified to non-fully qualified due to the different import statements (assumed). The creation of the `Composition` object remains semantically the same; this suggests that there is an import statement for the `Composition` class in the late version. Thus, the change type is 5 since there's a change in the dependent API by simplifying the reference. ","There is no Compatibility Issue as the returned object type has not changed and will behave the same way as long as the constructor signature remains the same. Hence, the pred_CI is 0."
1025,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForPreview(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForPreview(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: boolean isSurfaceForPreview(Surface)>,0,"{
    return LegacyCameraDevice.isPreviewConsumer(surface);
}","{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | HardwareBuffer.USAGE_GPU_COLOR_OUTPUT;
    boolean previewConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return previewConsumer;
}",1,"/**
 * Check if a surface is for preview consumer based on consumer end point Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for preview consumer, false otherwise.
 */
","/**
 * Check if a surface is for preview consumer based on consumer end point Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for preview consumer, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The change includes the introduction of additional local variables and control structures, a new method call to checkNotNull(surface), a change to the logic that determines the boolean previewConsumer, and a completely new method call to getSurfaceFormat(surface). It also removes the call to LegacyCameraDevice.isPreviewConsumer(surface). Hence the code changes include Return statement changed (1), Control dependency changed (3), Other statement changed (4), and Dependent API changed (5).","Given that the logic for determining whether the surface is for preview has fundamentally changed, including new conditions for allowed and disallowed flags, as well as the additional check on the format of the surface, the changes have the potential to alter the return value of the method. Therefore, a Compatibility Issue could arise caused by potential different return values (1)."
1026,<android.app.WallpaperColors: int hashCode()>,30,31,<android.app.WallpaperColors: int hashCode()>,<android.app.WallpaperColors: int hashCode()>,0,"{
    return 31 * mMainColors.hashCode() + mColorHints;
}","{
    return (31 * mMainColors.hashCode() * mAllColors.hashCode()) + mColorHints;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The hashCode calculation now includes the hash of mAllColors in the late version which wasn't present in the early version. The specific calculation has been modified, which is classified under other statement changed (4) and return statement changed (1) since this directly affects the output of the method.","The modification in the hashCode calculation formula could lead to a different integer being returned by the method, hence it's classified as a Compatibility Issue caused by potential different return values or types (1)."
1027,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,30,31,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
                deltaY -= mScrollConsumed[1];
                vtev.offsetLocation(0, mScrollOffset[1]);
                mNestedYOffset += mScrollOffset[1];
            }
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y - mScrollOffset[1];
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) && !hasNestedScrollingParent()) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                final int scrolledDeltaY = mScrollY - oldY;
                final int unconsumedY = deltaY - scrolledDeltaY;
                if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) {
                    mLastMotionY -= mScrollOffset[1];
                    vtev.offsetLocation(0, mScrollOffset[1]);
                    mNestedYOffset += mScrollOffset[1];
                } else if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight(), ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight(), 1.f - ev.getX(activePointerIndex) / getWidth());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                    flingWithNestedDispatch(-initialVelocity);
                } else if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}","{
    initVelocityTrackerIfNotExists();
    MotionEvent vtev = MotionEvent.obtain(ev);
    final int actionMasked = ev.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        mNestedYOffset = 0;
    }
    vtev.offsetLocation(0, mNestedYOffset);
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if (!mScroller.isFinished()) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (dispatchNestedPreScroll(0, deltaY, mScrollConsumed, mScrollOffset)) {
                deltaY -= mScrollConsumed[1];
                vtev.offsetLocation(0, mScrollOffset[1]);
                mNestedYOffset += mScrollOffset[1];
            }
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y - mScrollOffset[1];
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                final float displacement = ev.getX(activePointerIndex) / getWidth();
                if (canOverscroll) {
                    int consumed = 0;
                    if (deltaY < 0 && mEdgeGlowBottom.getDistance() != 0f) {
                        consumed = Math.round(getHeight() * mEdgeGlowBottom.onPullDistance((float) deltaY / getHeight(), 1 - displacement));
                    } else if (deltaY > 0 && mEdgeGlowTop.getDistance() != 0f) {
                        consumed = Math.round(-getHeight() * mEdgeGlowTop.onPullDistance((float) -deltaY / getHeight(), displacement));
                    }
                    deltaY -= consumed;
                }
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true) && !hasNestedScrollingParent()) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                final int scrolledDeltaY = mScrollY - oldY;
                final int unconsumedY = deltaY - scrolledDeltaY;
                if (dispatchNestedScroll(0, scrolledDeltaY, 0, unconsumedY, mScrollOffset)) {
                    mLastMotionY -= mScrollOffset[1];
                    vtev.offsetLocation(0, mScrollOffset[1]);
                    mNestedYOffset += mScrollOffset[1];
                } else if (canOverscroll && deltaY != 0f) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPullDistance((float) -deltaY / getHeight(), displacement);
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPullDistance((float) deltaY / getHeight(), 1.f - displacement);
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (shouldDisplayEdgeEffects() && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                    flingWithNestedDispatch(-initialVelocity);
                } else if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    if (mVelocityTracker != null) {
        mVelocityTracker.addMovement(vtev);
    }
    vtev.recycle();
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1028,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",30,31,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        if (maxNum < 0) {
            throw new IllegalArgumentException(""The requested number of tasks should be >= 0"");
        }
        return getTaskService().getRecentTasks(maxNum, flags, mContext.getUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    if (maxNum < 0) {
        throw new IllegalArgumentException(""The requested number of tasks should be >= 0"");
    }
    return ActivityTaskManager.getInstance().getRecentTasks(maxNum, flags, mContext.getUserId());
}",1,"/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
","/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The internal API used to get recent tasks has changed from using getTaskService().getRecentTasks() to ActivityTaskManager.getInstance().getRecentTasks(). There are no changes to the structure of the control flow or to the exception handling, thus the change is of types 4 and 5.","Despite the change to the API used internally, which is a Dependent API change, there is no apparent change to the method signature, return type, thrown exceptions, or control flow that affects how the exceptions are handled. Therefore, there is no Compatibility Issue."
1029,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,30,31,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Bluetooth Class"");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Bluetooth Class"");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this, mAttributionSource);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */
","/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */
",-1,[@RequiresPermission(Manifest.permission.BLUETOOTH)],"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method service.getRemoteClass(this) in the early version has been changed to service.getRemoteClass(this, mAttributionSource) in the late version which indicates a change in the method's signature (number of its parameters) and hence is a dependent API change. Additionally, the method call for getting the Bluetooth class now requires an additional argument (`mAttributionSource`), indicating a change in how the dependent API is used, but no changes in return statements, exception handling statements, or control dependencies were introduced. The annotations also changed which reflects a potential change in permissions required to use the API, but it does not affect the behavior - only what is needed to lawfully invoke the method. ","There is no change detected that affects the behavior of the method itself. Although there is an additional parameter in the method call, it does not inherently affect the return type or value of the `getBluetoothClass` method assuming the new parameter is correctly provided when invoking `getRemoteClass`. Therefore, there is no compatibility issue based on the change in the dependent API or annotations in this case."
1030,<android.app.AutomaticZenRule: boolean equals(Object)>,30,31,<android.app.AutomaticZenRule: boolean equals(Object)>,<android.app.AutomaticZenRule: boolean equals(Object)>,0,"{
    if (!(o instanceof AutomaticZenRule))
        return false;
    if (o == this)
        return true;
    final AutomaticZenRule other = (AutomaticZenRule) o;
    return other.enabled == enabled && other.mModified == mModified && Objects.equals(other.name, name) && other.interruptionFilter == interruptionFilter && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.owner, owner) && Objects.equals(other.mZenPolicy, mZenPolicy) && Objects.equals(other.configurationActivity, configurationActivity) && other.creationTime == creationTime;
}","{
    if (!(o instanceof AutomaticZenRule))
        return false;
    if (o == this)
        return true;
    final AutomaticZenRule other = (AutomaticZenRule) o;
    return other.enabled == enabled && other.mModified == mModified && Objects.equals(other.name, name) && other.interruptionFilter == interruptionFilter && Objects.equals(other.conditionId, conditionId) && Objects.equals(other.owner, owner) && Objects.equals(other.mZenPolicy, mZenPolicy) && Objects.equals(other.configurationActivity, configurationActivity) && Objects.equals(other.mPkg, mPkg) && other.creationTime == creationTime;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The equals comparison logic has been updated by changing one of the fields that is being compared; specifically, the comparison now includes other.mPkg instead of the previous version's field. This represents a change in return statement (1) and other statement change (4), as the conditions under which the method returns 'true' or 'false' have been altered.","A Compatibility Issue arises because the behavior of comparing 'AutomaticZenRule' objects can differ between the two versions. The new field included in the comparison might lead to returning 'false' where the earlier implementation would return 'true', or vice versa. This potential difference in return values typifies it as CI type 1 (Compatibility Issue caused by potential different return values)."
1031,<android.content.res.XmlBlock.Parser: String getIdAttribute()>,30,31,<android.content.res.XmlBlock.Parser: String getIdAttribute()>,<android.content.res.XmlBlock.Parser: String getIdAttribute()>,0,"{
    int id = nativeGetIdAttribute(mParseState);
    return id >= 0 ? mStrings.get(id).toString() : null;
}","{
    int id = nativeGetIdAttribute(mParseState);
    return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : null;
}",1,,,-1,,[@Nullable],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method of retrieving the ID attribute string has been altered from `mStrings.get(id).toString()` to `getSequenceString(mStrings.getSequence(id))`. This represents a change in how the id attribute's string representation is obtained (Other statement changed). Additionally, because there is a change in how the string is obtained, which will affect the value that is returned by the method, and thus is a Return statement changed. The dependent method for obtaining the string representation (getSequenceString or mStrings.get) has been modified, so a Dependent API changed category is also applicable.","Any change in the mechanism for obtaining the string value of the ID attribute, especially if it involves different methods to accomplish the task, could result in different return values being generated by the method. This is particularly true if the string conversion or sequence retrieval process behavior changes between versions. Therefore, this change has the potential to cause Compatibility Issue due to different return values."
1032,<android.widget.TextView: boolean canPasteAsPlainText()>,30,31,<android.widget.TextView: boolean canPasteAsPlainText()>,<android.widget.TextView: boolean canPasteAsPlainText()>,0,"{
    if (!canPaste()) {
        return false;
    }
    final ClipData clipData = getClipboardManagerForUser().getPrimaryClip();
    final ClipDescription description = clipData.getDescription();
    final boolean isPlainType = description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN);
    final CharSequence text = clipData.getItemAt(0).getText();
    if (isPlainType && (text instanceof Spanned)) {
        Spanned spanned = (Spanned) text;
        if (TextUtils.hasStyleSpan(spanned)) {
            return true;
        }
    }
    return description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML);
}","{
    if (!canPaste()) {
        return false;
    }
    final ClipDescription description = getClipboardManagerForUser().getPrimaryClipDescription();
    final boolean isPlainType = description.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN);
    return (isPlainType && description.isStyledText()) || description.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method implementations have changed significantly. The late version no longer retrieves the ClipData and no longer checks if the text is an instance of Spanned. Instead, it calls description.isStyledText(). These changes include deletion of a variable declaration statement (ClipData clipData), the removal of control dependency (if (isPlainType && (text instanceof Spanned))), and a modification of the final return statement. Therefore, the code change types are 1,3,4,5.","Since the conditional logic to determine the return value has changed significantly, the late version of the method might return a different result compared to the early version under the same conditions. This is because the spanned text condition is replaced with a styled text check which is a part of the clip description, and the logic to retrieve and check the text data has been removed. Thus, there is a potential Compatibility Issue due to a different return value, and the CI type is 1."
1033,"<android.view.textservice.SpellCheckerSession: void getSentenceSuggestions(TextInfo[],int)>",30,31,"<android.view.textservice.SpellCheckerSession: void getSentenceSuggestions(TextInfo[],int)>","<android.view.textservice.SpellCheckerSession: void getSentenceSuggestions(TextInfo[],int)>",0,"{
    mSpellCheckerSessionListenerImpl.getSentenceSuggestionsMultiple(textInfos, suggestionsLimit);
}","{
    final InputMethodManager imm = mTextServicesManager.getInputMethodManager();
    if (imm != null && imm.isInputMethodSuppressingSpellChecker()) {
        handleOnGetSentenceSuggestionsMultiple(new SentenceSuggestionsInfo[0]);
        return;
    }
    mSpellCheckerSessionListenerImpl.getSentenceSuggestionsMultiple(textInfos, suggestionsLimit);
}",1,"/**
 * Get suggestions from the specified sentences
 * @param textInfos an array of text metadata for a spell checker
 * @param suggestionsLimit the maximum number of suggestions that will be returned
 */
","/**
 * Get suggestions from the specified sentences
 * @param textInfos an array of text metadata for a spell checker
 * @param suggestionsLimit the maximum number of suggestions that will be returned
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version introduces new control statements and other statements that check for input method suppression of the spell checker. If the input method is suppressing spell checker, it calls handleOnGetSentenceSuggestionsMultiple with an empty array rather than delegating to mSpellCheckerSessionListenerImpl. However, it does not introduce new return types or exception handling. So the change types are 3 and 4.","There is no Compatibility Issue because the additional control flow and method call do not affect the existing API contract. The API does not specify what happens when spell checker is suppressed; it only defines functionality for retrieving sentence suggestions. If the input method is not suppressing the spell checker, the original behavior stays intact. The added logic seems to be a fallback and does not affect the method's fulfillment of its intended purpose. Thus, there is no change that would result in a different return type or different exception handling under the expected conditions of API usage. The behavior change when the input method is suppressing the spell checker does not violate the API's existing contract because there seems to be no specified behavior for such a condition in the previous version."
1035,"<android.service.voice.VoiceInteractionSessionService: void doNewSession(IBinder,Bundle,int)>",30,31,"<android.service.voice.VoiceInteractionSessionService: void doNewSession(IBinder,Bundle,int)>","<android.service.voice.VoiceInteractionSessionService: void doNewSession(IBinder,Bundle,int)>",0,"{
    if (mSession != null) {
        mSession.doDestroy();
        mSession = null;
    }
    mSession = onNewSession(args);
    try {
        mSystemService.deliverNewSession(token, mSession.mSession, mSession.mInteractor);
        mSession.doCreate(mSystemService, token);
    } catch (RemoteException e) {
    }
}","{
    if (mSession != null) {
        mSession.doDestroy();
        mSession = null;
    }
    mSession = onNewSession(args);
    if (deliverSession(token)) {
        mSession.doCreate(mSystemService, token);
    } else {
        // TODO(b/178777121): Add an onError() method to let the application know what happened.
        mSession.doDestroy();
        mSession = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The try-catch block from the early version has been replaced with an if-else statement in the late version, and mSystemService.deliverNewSession(...) has been replaced with deliverSession(token). Inside the else statement, there is a call to mSession.doDestroy() and assigning null to mSession which wasn't there before. The change involves return statement changed because mSession state after execution could be different, control dependency because of the change from try-catch to if-else, and other statement changed because of addition of new operations (mSession.doDestroy() and mSession = null).","This code change could lead to a compatibility issue because the mSession state may differ after execution of the method, which was not the case in the early version. This can affect the state of the object that the API returns through other methods, potentially leading to different behaviours when the session gets destroyed in cases where deliverSession(token) returns false, which was not previously handled. Therefore, the compatibility issue type is 1 due to a possible change in the returned variable."
1036,<android.bluetooth.BluetoothGatt: void readPhy()>,30,31,<android.bluetooth.BluetoothGatt: void readPhy()>,<android.bluetooth.BluetoothGatt: void readPhy()>,0,"{
    try {
        mService.clientReadPhy(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    try {
        mService.clientReadPhy(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}",1,"/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattCallback#onPhyRead}
 */
","/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattCallback#onPhyRead}
 */
",-1,,"[@RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API changed, as an additional parameter (mAttributionSource) is passed to mService.clientReadPhy(), but there is no change in control statements, exception handling, or return statements. This classifies as change type 5.","There is no compatibility issue introduced since there are no return or exception handling statement changes that impact the behavior of the API, so the CI type is 0."
1037,<android.appwidget.AppWidgetHostView: View getDefaultView()>,30,31,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            if (!(defaultView instanceof AdapterView)) {
                // AdapterView does not support onClickListener
                defaultView.setOnClickListener(this::onDefaultViewClicked);
            }
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            if (!(defaultView instanceof AdapterView)) {
                // AdapterView does not support onClickListener
                defaultView.setOnClickListener(this::onDefaultViewClicked);
            }
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo, exception);
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is in the logging statement within the exception handling block. Instead of logging exception.toString(), the exception itself is being logged. Therefore the change type is 4.","Logging is a side effect which does not affect the logic of the method's operation, hence no compatibility issue should arise from this change."
1040,"<android.app.ContextImpl: WindowContext createWindowContext(int,Bundle)>",30,31,"<android.app.ContextImpl: WindowContext createWindowContext(int,Bundle)>","<android.app.ContextImpl: WindowContext createWindowContext(int,Bundle)>",0,"{
    if (getDisplay() == null) {
        throw new UnsupportedOperationException(""WindowContext can only be created from "" + ""other visual contexts, such as Activity or one created with "" + ""Context#createDisplayContext(Display)"");
    }
    return new WindowContext(this, type, options);
}","{
    if (getDisplay() == null) {
        throw new UnsupportedOperationException(""Please call this API with context associated"" + "" with a display instance, such as Activity or context created via"" + "" Context#createDisplayContext(Display), or try to invoke"" + "" Context#createWindowContext(Display, int, Bundle)"");
    }
    return createWindowContextInternal(getDisplay(), type, options);
}",1,,,-1,"[@Override, @NonNull]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"The exception message string was updated, but this does not affect the runtime behavior of the API, and the method called in the return statement has changed from `new WindowContext()` to `createWindowContextInternal()`. Therefore, the change type is 4 for the string message and 5 for the dependent API method name change.","Despite the changes in the exception message string and the dependent API method name, there is no indication of a different return value or type, or a different exception handling that would affect clients of this API. The contract of the API appears to remain the same, suggesting no compatibility issue would occur, which makes the CI type 0."
1042,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,30,31,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,0,"{
    if (sAdapter == null) {
        IBinder b = ServiceManager.getService(BLUETOOTH_MANAGER_SERVICE);
        if (b != null) {
            IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);
            sAdapter = new BluetoothAdapter(managerService);
        } else {
            Log.e(TAG, ""Bluetooth binder is null"");
        }
    }
    return sAdapter;
}","{
    if (sAdapter == null) {
        sAdapter = createAdapter(BluetoothManager.resolveAttributionSource(null));
    }
    return sAdapter;
}",1,"/**
 * Get a handle to the default local Bluetooth adapter.
 * <p>Currently Android only supports one Bluetooth adapter, but the API
 * could be extended to support more. This will always return the default
 * adapter.
 * </p>
 *
 * @return the default local adapter, or null if Bluetooth is not supported on this hardware
 * platform
 */
","/**
 * Get a handle to the default local Bluetooth adapter.
 * <p>
 * Currently Android only supports one Bluetooth adapter, but the API could
 * be extended to support more. This will always return the default adapter.
 * </p>
 *
 * @return the default local adapter, or null if Bluetooth is not supported
 * on this hardware platform
 * @deprecated this method will continue to work, but developers are
 * strongly encouraged to migrate to using
 * {@link BluetoothManager#getAdapter()}, since that approach
 * enables support for {@link Context#createAttributionContext}.
 */
",-1,,"[@Deprecated, @RequiresNoPermission]",-1,-1,-1,-1,-1,-1,5,1,"The implementation of the method changed the way the BluetoothAdapter instance is created, by replacing the service retrieval and direct instantiation with a call to `createAdapter`. Since `createAdapter` is not shown here, but the method of creation differs, this indicates a dependent API change; thus, the code change type is 5.","The change in the method of creating the BluetoothAdapter instance implies that the `sAdapter` returned by `getDefaultAdapter()` could potentially be different because the initialization process has changed. This difference in the object creation logic could result in a different BluetoothAdapter state, configuration, or behavior, leading to a compatibility issue caused by potential different return values or types; hence, the CI type is 1."
1043,<android.hardware.camera2.utils.SurfaceUtils: Size getSurfaceSize(Surface)>,30,31,<android.hardware.camera2.utils.SurfaceUtils: Size getSurfaceSize(Surface)>,<android.hardware.camera2.utils.SurfaceUtils: Size getSurfaceSize(Surface)>,0,"{
    try {
        return LegacyCameraDevice.getSurfaceSize(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException(""Surface was abandoned"", e);
    }
}","{
    checkNotNull(surface);
    int[] dimens = new int[2];
    int errorFlag = nativeDetectSurfaceDimens(surface, /*out*/
    dimens);
    if (errorFlag == BAD_VALUE)
        throw new IllegalArgumentException(""Surface was abandoned"");
    return new Size(dimens[0], dimens[1]);
}",1,"/**
 * Get the Surface size.
 *
 * @param surface The surface to be queried for size.
 * @return Size of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
","/**
 * Get the Surface size.
 *
 * @param surface The surface to be queried for size.
 * @return Size of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */
",-1,[@UnsupportedAppUsage],[@UnsupportedAppUsage],-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","The early version solely uses LegacyCameraDevice.getSurfaceSize(surface) within a try-catch block, while the late version introduces a series of changes: a new check (checkNotNull(surface)), an array (dimens), a native method call (nativeDetectSurfaceDimens), altered exception handling logic, and a direct construction of a new Size object from the array. These changes affect return statements, exception handling statements, introduce other statements, and rely on the behavior of a native method which we assume is a dependent API, thus code change types are 1,2,4,5.","Both the return value and the exception handling have changed. The early version could throw an IllegalArgumentException with a cause (the original BufferQueueAbandonedException), while the latter could throw an IllegalArgumentException without a cause, and only if 'errorFlag == BAD_VALUE'. The potential return value has also changed from LegacyCameraDevice.getSurfaceSize(surface) to a new Size object constructed from the dimensions array. Therefore, both potential return type/value and exceptions thrown are affected, hence CI types are 1,2."
1044,"<android.content.pm.ShortcutManager: boolean requestPinShortcut(ShortcutInfo,IntentSender)>",30,31,"<android.content.pm.ShortcutManager: boolean requestPinShortcut(ShortcutInfo,IntentSender)>","<android.content.pm.ShortcutManager: boolean requestPinShortcut(ShortcutInfo,IntentSender)>",0,"{
    try {
        return mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return (boolean) getFutureOrThrow(mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Request to create a pinned shortcut.  The default launcher will receive this request and
 * ask the user for approval.  If the user approves it, the shortcut will be created, and
 * {@code resultIntent} will be sent. If a request is denied by the user, however, no response
 * will be sent to the caller.
 *
 * <p>Only apps with a foreground activity or a foreground service can call this method.
 * Otherwise, it'll throw {@link IllegalStateException}.
 *
 * <p>It's up to the launcher to decide how to handle previous pending requests when the same
 * package calls this API multiple times in a row. One possible strategy is to ignore any
 * previous requests.
 *
 * <p><b>Note:</b> See also the support library counterpart
 * {@link android.support.v4.content.pm.ShortcutManagerCompat#requestPinShortcut(
 * Context, ShortcutInfoCompat, IntentSender)},
 * which supports Android versions lower than {@link VERSION_CODES#O} using the
 * legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
 *
 * @param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
 * or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
 * to be set, the target shortcut must be enabled.
 *
 * <p>If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @param resultIntent If not null, this intent will be sent when the shortcut is pinned.
 * Use {@link android.app.PendingIntent#getIntentSender()} to create an {@link IntentSender}.
 * To avoid background execution limits, use an unexported, manifest-declared receiver.
 * For more details, see
 * <a href=""/guide/topics/ui/shortcuts/creating-shortcuts.html#pinned"">
 * Creating pinned shortcuts</a>.
 *
 * @return {@code TRUE} if the launcher supports this feature.  Note the API will return without
 * waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
 * the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
 * feature.
 *
 * @see #isRequestPinShortcutSupported()
 * @see IntentSender
 * @see android.app.PendingIntent#getIntentSender()
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 * @throws IllegalStateException The caller doesn't have a foreground activity or a foreground
 * service, or the device is locked.
 */
","/**
 * Request to create a pinned shortcut.  The default launcher will receive this request and
 * ask the user for approval.  If the user approves it, the shortcut will be created, and
 * {@code resultIntent} will be sent. If a request is denied by the user, however, no response
 * will be sent to the caller.
 *
 * <p>Only apps with a foreground activity or a foreground service can call this method.
 * Otherwise, it'll throw {@link IllegalStateException}.
 *
 * <p>It's up to the launcher to decide how to handle previous pending requests when the same
 * package calls this API multiple times in a row. One possible strategy is to ignore any
 * previous requests.
 *
 * <p><b>Note:</b> See also the support library counterpart
 * {@link android.support.v4.content.pm.ShortcutManagerCompat#requestPinShortcut(
 * Context, ShortcutInfoCompat, IntentSender)},
 * which supports Android versions lower than {@link VERSION_CODES#O} using the
 * legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
 *
 * @param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
 * or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
 * to be set, the target shortcut must be enabled.
 *
 * <p>If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @param resultIntent If not null, this intent will be sent when the shortcut is pinned.
 * Use {@link android.app.PendingIntent#getIntentSender()} to create an {@link IntentSender}.
 * To avoid background execution limits, use an unexported, manifest-declared receiver.
 * For more details, see
 * <a href=""/guide/topics/ui/shortcuts/creating-shortcuts.html#pinned"">
 * Creating pinned shortcuts</a>.
 *
 * @return {@code TRUE} if the launcher supports this feature.  Note the API will return without
 * waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
 * the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
 * feature.
 *
 * @see #isRequestPinShortcutSupported()
 * @see IntentSender
 * @see android.app.PendingIntent#getIntentSender()
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 * @throws IllegalStateException The caller doesn't have a foreground activity or a foreground
 * service, or the device is locked.
 */
",-1,,[@WorkerThread],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The cast to boolean and the use of getFutureOrThrow() indicates a change in how the result is obtained, potentially involving a change in the method signature of the dependent API (mService.requestPinShortcut). Additionally, the return value processing has also changed. These modifications constitute other statement changes and dependent API changes, so the code change types include 1, 4, and 5.","Because the late version wraps the call to the service with getFutureOrThrow(), it implicitly changes the behavior of how the exception from the service is handled and potentially changes the timing of when the exception is thrown. This could affect the return value if the timing or manner in which exceptions are processed leads to differences. Therefore, the CI type is 1."
1045,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",30,31,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, mAttributionTag, null, mToken, user, flags, null, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mAttributionTag, null, mToken, user, flags, null, null);
        final int displayId = getDisplayId();
        c.setResources(createResources(mToken, pi, null, displayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        // the context without reloading Resources.
        return new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), null, mToken, user, flags, null, null);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags | CONTEXT_REGISTER_PACKAGE, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), null, mToken, user, flags, null, null);
        final int displayId = getDisplayId();
        final Integer overrideDisplayId = mForceDisplayOverrideInResources ? displayId : null;
        c.setResources(createResources(mToken, pi, null, overrideDisplayId, null, getDisplayAdjustments(displayId).getCompatibilityInfo(), null));
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5",1,"The type of parameter in ContextImpl constructor call has changed (from mAttributionTag, null to mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext()), and the `getDisplayId` logic is wrapped with a condition `mForceDisplayOverrideInResources`. Two variables 'mParams' and 'mForceDisplayOverrideInResources' are additionally used which were not used in the early version. This means there are new logic and control dependencies introduced, other statement changes (parameter changes in constructor calls), and the dependent API changed (use of new variables implies potentially different API dependencies from the extended class). The code change is thus classified under 3, 4, 5 types.","Due to the changes in constructor parameters used which can change the instance state and behaviors, and logic introduced with the 'mForceDisplayOverrideInResources' conditional adding new branching, the method potentially returns different ContextImpl instances, resulting in a different return value or type. Hence, CI type is 1."
1046,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,30,31,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingDisplayCutout.get().equals(args.arg9) && mPendingBackDropFrame.equals(args.arg8) && mLastReportedMergedConfiguration.equals(args.arg4) && args.argi1 == 0 && mDisplay.getDisplayId() == args.argi3) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                final int displayId = args.argi3;
                MergedConfiguration mergedConfiguration = (MergedConfiguration) args.arg4;
                final boolean displayChanged = mDisplay.getDisplayId() != displayId;
                boolean configChanged = false;
                if (!mLastReportedMergedConfiguration.equals(mergedConfiguration)) {
                    // If configuration changed - notify about that and, maybe,
                    // about move to display.
                    performConfigurationChange(mergedConfiguration, false, /* force */
                    displayChanged ? displayId : INVALID_DISPLAY);
                    configChanged = true;
                } else if (displayChanged) {
                    // Moved to display without config change - report last applied one.
                    onMovedToDisplay(displayId, mLastConfigurationFromResources);
                }
                final boolean framesChanged = !mWinFrame.equals(args.arg1) || !mPendingDisplayCutout.get().equals(args.arg9);
                setFrame((Rect) args.arg1);
                mPendingDisplayCutout.set((DisplayCutout) args.arg9);
                mPendingBackDropFrame.set((Rect) args.arg8);
                mForceNextWindowRelayout = args.argi1 != 0;
                mPendingAlwaysConsumeSystemBars = args.argi2 != 0;
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    reportNextDraw();
                }
                if (mView != null && (framesChanged || configChanged)) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_INSETS_CHANGED:
            mInsetsController.onStateChanged((InsetsState) msg.obj);
            break;
        case MSG_INSETS_CONTROL_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                // Deliver state change before control change, such that:
                // a) When gaining control, controller can compare with server state to evaluate
                // whether it needs to run animation.
                // b) When loosing control, controller can restore server state by taking last
                // dispatched state as truth.
                mInsetsController.onStateChanged((InsetsState) args.arg1);
                mInsetsController.onControlsChanged((InsetsSourceControl[]) args.arg2);
                break;
            }
        case MSG_SHOW_INSETS:
            {
                if (mView == null) {
                    Log.e(TAG, String.format(""Calling showInsets(%d,%b) on window that no longer"" + "" has views."", msg.arg1, msg.arg2 == 1));
                }
                mInsetsController.show(msg.arg1, msg.arg2 == 1);
                break;
            }
        case MSG_HIDE_INSETS:
            {
                mInsetsController.hide(msg.arg1, msg.arg2 == 1);
                break;
            }
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mTmpFrame.left = l;
                mTmpFrame.right = l + w;
                mTmpFrame.top = t;
                mTmpFrame.bottom = t + h;
                setFrame(mTmpFrame);
                mPendingBackDropFrame.set(mWinFrame);
                maybeHandleWindowMove(mWinFrame);
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                handleWindowFocusChanged();
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                InputEvent event = (InputEvent) args.arg1;
                InputEventReceiver receiver = (InputEventReceiver) args.arg2;
                enqueueInputEvent(event, receiver, 0, true);
                args.recycle();
            }
            break;
        case MSG_SYNTHESIZE_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_UNHANDLED, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_AUTOFILL:
            {
                if (LOCAL_LOGV) {
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from Autofill to "" + mView);
                }
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                getImeFocusController().checkFocus(false, true);
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
            {
            }
        // fall through
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastReportedMergedConfiguration.getMergedConfiguration())) {
                    // If we already have a newer merged config applied - use its global part.
                    config = mLastReportedMergedConfiguration.getGlobalConfiguration();
                }
                // Use the newer global config and last reported override config.
                mPendingMergedConfiguration.setConfiguration(config, mLastReportedMergedConfiguration.getOverrideConfiguration());
                performConfigurationChange(mPendingMergedConfiguration, false, /* force */
                INVALID_DISPLAY);
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_DISPATCH_WINDOW_SHOWN:
            {
                handleDispatchWindowShown();
            }
            break;
        case MSG_REQUEST_KEYBOARD_SHORTCUTS:
            {
                final IResultReceiver receiver = (IResultReceiver) msg.obj;
                final int deviceId = msg.arg1;
                handleRequestKeyboardShortcuts(receiver, deviceId);
            }
            break;
        case MSG_UPDATE_POINTER_ICON:
            {
                MotionEvent event = (MotionEvent) msg.obj;
                resetPointerIcon(event);
            }
            break;
        case MSG_POINTER_CAPTURE_CHANGED:
            {
                final boolean hasCapture = msg.arg1 != 0;
                handlePointerCaptureChanged(hasCapture);
            }
            break;
        case MSG_DRAW_FINISHED:
            {
                pendingDrawFinished();
            }
            break;
        case MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED:
            {
                systemGestureExclusionChanged();
            }
            break;
        case MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED:
            {
                updateLocationInParentDisplay(msg.arg1, msg.arg2);
            }
            break;
        case MSG_REQUEST_SCROLL_CAPTURE:
            handleScrollCaptureRequest((IScrollCaptureController) msg.obj);
            break;
    }
}","{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, getMessageName(msg));
    }
    try {
        handleMessageImpl(msg);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1048,<android.content.res.Configuration: int updateFrom(Configuration)>,30,31,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    if (windowConfiguration.updateFrom(delta.windowConfiguration) != 0) {
        changed |= ActivityInfo.CONFIG_WINDOW_CONFIGURATION;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    fixUpLocaleList();
    delta.fixUpLocaleList();
    if (!delta.mLocaleList.isEmpty() && !mLocaleList.equals(delta.mLocaleList)) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        mLocaleList = delta.mLocaleList;
        // delta.locale can't be null, since delta.mLocaleList is not empty.
        if (!delta.locale.equals(locale)) {
            locale = (Locale) delta.locale.clone();
            // If locale has changed, then layout direction is also changed ...
            changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
            // ... and we need to update the layout direction (represented by the first
            // 2 most significant bits in screenLayout).
            setLayoutDirection(locale);
        }
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (((delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != SCREENLAYOUT_SIZE_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_SIZE_MASK) != (screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_SIZE_MASK) | (delta.screenLayout & SCREENLAYOUT_SIZE_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_LONG_MASK) != SCREENLAYOUT_LONG_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_LONG_MASK) != (screenLayout & SCREENLAYOUT_LONG_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_LONG_MASK) | (delta.screenLayout & SCREENLAYOUT_LONG_MASK);
    }
    if (((delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != SCREENLAYOUT_ROUND_UNDEFINED) && (delta.screenLayout & SCREENLAYOUT_ROUND_MASK) != (screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_ROUND_MASK) | (delta.screenLayout & SCREENLAYOUT_ROUND_MASK);
    }
    if ((delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED) != (screenLayout & SCREENLAYOUT_COMPAT_NEEDED) && delta.screenLayout != 0) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = (screenLayout & ~SCREENLAYOUT_COMPAT_NEEDED) | (delta.screenLayout & SCREENLAYOUT_COMPAT_NEEDED);
    }
    if (((delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED) && (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK) != (colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_WIDE_COLOR_GAMUT_MASK) | (delta.colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
    }
    if (((delta.colorMode & COLOR_MODE_HDR_MASK) != COLOR_MODE_HDR_UNDEFINED) && (delta.colorMode & COLOR_MODE_HDR_MASK) != (colorMode & COLOR_MODE_HDR_MASK)) {
        changed |= ActivityInfo.CONFIG_COLOR_MODE;
        colorMode = (colorMode & ~COLOR_MODE_HDR_MASK) | (delta.colorMode & COLOR_MODE_HDR_MASK);
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
        changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
        assetsSeq = delta.assetsSeq;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    if (windowConfiguration.updateFrom(delta.windowConfiguration) != 0) {
        changed |= ActivityInfo.CONFIG_WINDOW_CONFIGURATION;
    }
    if (delta.fontWeightAdjustment != FONT_WEIGHT_ADJUSTMENT_UNDEFINED && delta.fontWeightAdjustment != fontWeightAdjustment) {
        changed |= ActivityInfo.CONFIG_FONT_WEIGHT_ADJUSTMENT;
        fontWeightAdjustment = delta.fontWeightAdjustment;
    }
    return changed;
}",1,"/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
","/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 */
",-1,[@Config],[@Config],-1,-1,-1,-1,-1,-1,,,,
1049,<android.view.Display: float getRefreshRate()>,30,31,<android.view.Display: float getRefreshRate()>,<android.view.Display: float getRefreshRate()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getMode().getRefreshRate();
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getRefreshRate();
    }
}",1,"/**
 * Gets the refresh rate of this display in frames per second.
 */
","/**
 * Gets the refresh rate of this display in frames per second.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The synchronization lock has changed from 'this' to 'mLock', which is a control dependency change. The method invocation has changed from 'mDisplayInfo.getMode().getRefreshRate()' to 'mDisplayInfo.getRefreshRate()', which is a change in the dependent API as well as an other statement change. Hence, the code change types are 3, 4, and 5.","The change in the lock object could potentially affect the thread-safety of this method if 'mLock' is used for additional synchronization purposes within the class. Additionally, the change in the way the refresh rate is being accessed can lead to a different value being returned if 'getMode().getRefreshRate()' and 'getRefreshRate()' do not always return the same value. Therefore, we can classify the CI type as 1."
1050,<android.view.contentcapture.ContentCaptureContext: String toString()>,30,31,<android.view.contentcapture.ContentCaptureContext: String toString()>,<android.view.contentcapture.ContentCaptureContext: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder(""Context["");
    if (fromServer()) {
        builder.append(""act="").append(ComponentName.flattenToShortString(mComponentName)).append("", taskId="").append(mTaskId).append("", displayId="").append(mDisplayId).append("", flags="").append(mFlags);
    } else {
        builder.append(""id="").append(mId);
        if (mExtras != null) {
            // NOTE: cannot print because it could contain PII
            builder.append("", hasExtras"");
        }
    }
    if (mParentSessionId != NO_SESSION_ID) {
        builder.append("", parentId="").append(mParentSessionId);
    }
    return builder.append(']').toString();
}","{
    final StringBuilder builder = new StringBuilder(""Context["");
    if (fromServer()) {
        builder.append(""act="").append(ComponentName.flattenToShortString(mComponentName)).append("", activityId="").append(mActivityId).append("", displayId="").append(mDisplayId).append("", flags="").append(mFlags);
    } else {
        builder.append(""id="").append(mId);
        if (mExtras != null) {
            // NOTE: cannot print because it could contain PII
            builder.append("", hasExtras"");
        }
    }
    if (mParentSessionId != NO_SESSION_ID) {
        builder.append("", parentId="").append(mParentSessionId);
    }
    return builder.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method implementation has changed the string that's appended to the StringBuilder from ""taskId="" to ""activityId="". Since the method is intended to return a string representation of the object, and given the method's behavior, this is a simple change of the textual output format without altering return types or throwing new exceptions, falling under change type 4.","There is no Compatibility Issue because the method consistently returns a string and changing the content of the string does not affect the method's behavior; method contracts are typically not about specific textual content, but about the format and type. Thus, the method's behavior essentially remains the same from the caller's perspective."
1051,<android.os.VibrationEffect.Composition: Composition addPrimitive(int)>,30,31,<android.os.VibrationEffect.Composition: Composition addPrimitive(int)>,<android.os.VibrationEffect.Composition: Composition addPrimitive(int)>,0,"{
    addPrimitive(primitiveId, /*scale*/
    1.0f, /*delay*/
    0);
    return this;
}","{
    return addPrimitive(primitiveId, /*scale*/
    1.0f, /*delay*/
    0);
}",1,"/**
 * Add a haptic primitive to the end of the current composition.
 *
 * Similar to {@link #addPrimitive(int, float, int)}, but with no delay and a
 * default scale applied.
 *
 * @param primitiveId The primitive to add
 *
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
","/**
 * Add a haptic primitive to the end of the current composition.
 *
 * Similar to {@link #addPrimitive(int, float, int)}, but with no delay and a
 * default scale applied.
 *
 * @param primitiveId The primitive to add
 *
 * @return The {@link Composition} object to enable adding multiple primitives in one chain.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the removal of the separate call to addPrimitive followed by a return, which is now combined into a single line. This does not change the behavior or output of the method, so the code change type is 4.","There is no Compatibility Issue since the method still performs the same operation, with the same parameters, and returns the same value (`this`), so the behavior is unchanged."
1052,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,30,31,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,<android.view.textclassifier.TextSelection.Builder: TextSelection build()>,0,"{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mId, mExtras == null ? Bundle.EMPTY : mExtras);
}","{
    return new TextSelection(mStartIndex, mEndIndex, mEntityConfidence, mId, mTextClassification, mExtras == null ? Bundle.EMPTY : mExtras);
}",1,"/**
 * Builds and returns {@link TextSelection} object.
 */
","/**
 * Builds and returns {@link TextSelection} object.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of TextSelection now includes an additional parameter, mTextClassification, that wasn't in the previous version, which means that the return type of the build() method is constructed differently, so the code change type is 1,5.","Since the new implementation of build() includes an additional parameter passed to the TextSelection constructor, this change can potentially cause the method to return a different value as the constructed object now includes more information than before. Therefore, the CI type is 1."
1053,<android.view.Display: String toString()>,30,31,<android.view.Display: String toString()>,<android.view.Display: String toString()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        final DisplayAdjustments adjustments = getDisplayAdjustments();
        mDisplayInfo.getAppMetrics(mTempMetrics, adjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + (mMayAdjustByFixedRotation ? ("", "" + adjustments.getFixedRotationAdjustments() + "", "") : "", "") + mTempMetrics + "", isValid="" + mIsValid;
    }
}","{
    synchronized (mLock) {
        updateDisplayInfoLocked();
        final DisplayAdjustments adjustments = getDisplayAdjustments();
        mDisplayInfo.getAppMetrics(mTempMetrics, adjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + (mMayAdjustByFixedRotation ? ("", "" + adjustments.getFixedRotationAdjustments() + "", "") : "", "") + mTempMetrics + "", isValid="" + mIsValid;
    }
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the code is the object that is used for synchronization, from 'this' to 'mLock'. Therefore, the change type is 4, which is an ""Other statement changed"".","The modification in the synchronization block does not affect the behavior of the toString() method's return value. It simply changes the lock object, which does not create a Compatibility Issue since it does not affect the externally observable behavior of the method. Therefore, there is no Compatibility Issue here."
1054,"<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>",30,31,"<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>","<android.app.admin.DevicePolicyManager: int setGlobalPrivateDnsModeSpecifiedHost(ComponentName,String)>",0,"{
    throwIfParentInstance(""setGlobalPrivateDnsModeSpecifiedHost"");
    Objects.requireNonNull(privateDnsHost, ""dns resolver is null"");
    if (mService == null) {
        return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;
    }
    if (NetworkUtils.isWeaklyValidatedHostname(privateDnsHost)) {
        if (!PrivateDnsConnectivityChecker.canConnectToPrivateDnsServer(privateDnsHost)) {
            return PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING;
        }
    }
    try {
        return mService.setGlobalPrivateDns(admin, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, privateDnsHost);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}","{
    throwIfParentInstance(""setGlobalPrivateDnsModeSpecifiedHost"");
    Objects.requireNonNull(privateDnsHost, ""dns resolver is null"");
    if (mService == null) {
        return PRIVATE_DNS_SET_ERROR_FAILURE_SETTING;
    }
    if (NetworkUtilsInternal.isWeaklyValidatedHostname(privateDnsHost)) {
        if (!PrivateDnsConnectivityChecker.canConnectToPrivateDnsServer(privateDnsHost)) {
            return PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING;
        }
    }
    try {
        return mService.setGlobalPrivateDns(admin, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, privateDnsHost);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}",1,"/**
 * Sets the global Private DNS host to be used.
 * May only be called by the device owner.
 *
 * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,
 * to ensure it is valid. Because of that, the method should not be called on any thread that
 * relates to user interaction, such as the UI thread.
 *
 * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver
 * must be reachable both from within and outside the VPN. Otherwise, the device may lose
 * the ability to resolve hostnames as system traffic to the resolver may not go through the
 * VPN.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with.
 * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).
 *
 * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,
 * {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or
 * {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not
 * implement RFC7858.
 *
 * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.
 *
 * @throws SecurityException if the caller is not the device owner.
 */
","/**
 * Sets the global Private DNS host to be used.
 * May only be called by the device owner.
 *
 * <p>Note that the method is blocking as it will perform a connectivity check to the resolver,
 * to ensure it is valid. Because of that, the method should not be called on any thread that
 * relates to user interaction, such as the UI thread.
 *
 * <p>In case a VPN is used in conjunction with Private DNS resolver, the Private DNS resolver
 * must be reachable both from within and outside the VPN. Otherwise, the device may lose
 * the ability to resolve hostnames as system traffic to the resolver may not go through the
 * VPN.
 *
 * <p>Note: The device owner won't be able to set the global private DNS mode if there are
 * unaffiliated secondary users or profiles on the device. It's recommended that affiliation
 * ids are set for new users as soon as possible after provisioning via
 * {@link #setAffiliationIds}.
 *
 * @param admin which {@link DeviceAdminReceiver} this request is associated with.
 * @param privateDnsHost The hostname of a server that implements DNS over TLS (RFC7858).
 *
 * @return {@code PRIVATE_DNS_SET_NO_ERROR} if the mode was set successfully,
 * {@code PRIVATE_DNS_SET_ERROR_FAILURE_SETTING} if it could not be set or
 * {@code PRIVATE_DNS_SET_ERROR_HOST_NOT_SERVING} if the specified host does not
 * implement RFC7858.
 *
 * @throws IllegalArgumentException if the {@code privateDnsHost} is not a valid hostname.
 *
 * @throws SecurityException if the caller is not the device owner.
 */
",-1,"[@WorkerThread, @PrivateDnsModeErrorCodes]","[@WorkerThread, @PrivateDnsModeErrorCodes]",-1,-1,-1,-1,-1,-1,"4,5",0,"The change is in the method call NetworkUtils.isWeaklyValidatedHostname(privateDnsHost) to NetworkUtilsInternal.isWeaklyValidatedHostname(privateDnsHost). This indicates a change in the dependent API used within the method, classifying the change type as 4 and 5.","There's no evidence that changing from NetworkUtils to NetworkUtilsInternal would lead to any differences in behavior from the perspective of this method's caller, as long as the logic of isWeaklyValidatedHostname remains the same. Without information to the contrary, we assume that the internal contract and behavior of isWeaklyValidatedHostname is maintained. Therefore, this change doesn't inherently suggest a compatibility issue; the pred_CI is 0."
1055,<android.app.ContextImpl: PackageManager getPackageManager()>,30,31,<android.app.ContextImpl: PackageManager getPackageManager()>,<android.app.ContextImpl: PackageManager getPackageManager()>,0,"{
    if (mPackageManager != null) {
        return mPackageManager;
    }
    final IPackageManager pm = ActivityThread.getPackageManager();
    final IPermissionManager permissionManager = ActivityThread.getPermissionManager();
    if (pm != null && permissionManager != null) {
        // Doesn't matter if we make more than one instance.
        return (mPackageManager = new ApplicationPackageManager(this, pm, permissionManager));
    }
    return null;
}","{
    if (mPackageManager != null) {
        return mPackageManager;
    }
    final IPackageManager pm = ActivityThread.getPackageManager();
    if (pm != null) {
        // Doesn't matter if we make more than one instance.
        return (mPackageManager = new ApplicationPackageManager(this, pm));
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The line `final IPermissionManager permissionManager = ActivityThread.getPermissionManager();` is removed and the constructor call for `ApplicationPackageManager` has one fewer parameter in the late version, which indicates there is a dependent API change. However, there are no return statement changes, exception handling statement changes, or control dependency changes. Thus, the changes are 4, for the removal of a line and change in a method call, and 5 for the dependent API change.","There is no Compatibility Issue detected since the same `return null` is executed when `pm` is null, and the removal of `permissionManager` does not affect the return type or value outside of the condition where `pm` is not null. If the dependent API `ApplicationPackageManager` constructor handles the missing `permissionManager` parameter internally without affecting the public API contract, no CI would occur. The behavior and outcome of `getPackageManager()` remain the same under the same conditions, hence the pred_CI is 0."
1056,<android.widget.TextView: boolean onDragEvent(DragEvent)>,30,31,<android.widget.TextView: boolean onDragEvent(DragEvent)>,<android.widget.TextView: boolean onDragEvent(DragEvent)>,0,"{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return mEditor != null && mEditor.hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            if (mText instanceof Spannable) {
                final int offset = getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection(mSpannable, offset);
            }
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}","{
    if (mEditor == null || !mEditor.hasInsertionController()) {
        // drag events depending on whether the listener is/isn't set.
        return super.onDragEvent(event);
    }
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return true;
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            if (mText instanceof Spannable) {
                final int offset = getOffsetForPosition(event.getX(), event.getY());
                Selection.setSelection(mSpannable, offset);
            }
            return true;
        case DragEvent.ACTION_DROP:
            if (mEditor != null)
                mEditor.onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}",1,,"/**
 * Handles drag events sent by the system following a call to
 * {@link android.view.View#startDragAndDrop(ClipData,DragShadowBuilder,Object,int)
 * startDragAndDrop()}.
 *
 * <p>If this text view is not editable, delegates to the default {@link View#onDragEvent}
 * implementation.
 *
 * <p>If this text view is editable, accepts all drag actions (returns true for an
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED ACTION_DRAG_STARTED} event and all
 * subsequent drag events). While the drag is in progress, updates the cursor position
 * to follow the touch location. Once a drop event is received, handles content insertion
 * via {@link #performReceiveContent}.
 *
 * @param event The {@link android.view.DragEvent} sent by the system.
 * The {@link android.view.DragEvent#getAction()} method returns an action type constant
 * defined in DragEvent, indicating the type of drag event represented by this object.
 * @return Returns true if this text view is editable and delegates to super otherwise.
 * See {@link View#onDragEvent}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"There is a new if-statement introduced before the switch statement that potentially alters the control flow. Additionally, there is a call to `super.onDragEvent(event)` if the condition is met, which indicates a dependent API changed. Thus, the types of changes are 3 and 5.","The new conditional check that precedes the switch-case structure could cause the method to return the result of `super.onDragEvent(event)` instead of proceeding with the original action logic based on `event.getAction()`. If `mEditor` is null or `mEditor.hasInsertionController()` is false, the behavior will be altered, leading to a compatibility issue of type 1, as the method could return a different value than in the previous version."
1057,<android.service.notification.StatusBarNotification: String toString()>,30,31,<android.service.notification.StatusBarNotification: String toString()>,<android.service.notification.StatusBarNotification: String toString()>,0,"{
    return String.format(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s key=%s: %s)"", this.pkg, this.user, this.id, this.tag, this.key, this.notification);
}","{
    return formatSimple(""StatusBarNotification(pkg=%s user=%s id=%d tag=%s key=%s: %s)"", this.pkg, this.user, this.id, this.tag, this.key, this.notification);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The change from `String.format` to a method `formatSimple` indicates that there is a change in the dependent API being called for constructing the string, which means the code change type is 4,5.","There is no compatibility issue as it appears just to be a refactoring of the string formatting method, without altering the contract of the `toString` method. Assuming that `formatSimple` method is an internal change that does not alter the output of the `toString` method, there should be no difference in behavior or output for the end user, hence CI type is 0."
1059,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,30,31,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,<android.bluetooth.le.BluetoothLeScanner.BleScanCallbackWrapper: void flushPendingBatchResults()>,0,"{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.flushPendingBatchResults(mScannerId);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get pending scan results"", e);
        }
    }
}","{
    synchronized (this) {
        if (mScannerId <= 0) {
            Log.e(TAG, ""Error state, mLeHandle: "" + mScannerId);
            return;
        }
        try {
            mBluetoothGatt.flushPendingBatchResults(mScannerId, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to get pending scan results"", e);
        }
    }
}",1,,,-1,,[@RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)],-1,-1,-1,-1,-1,-1,"4,5",0,"The method `flushPendingBatchResults` inside the `try` block now takes an additional parameter `mAttributionSource`, and there's the introduction of a new annotation for permission requirement, so the class numbers are 4,5.","Since the change in the parameter list of the method `flushPendingBatchResults` does not alter the behavior of the `flushPendingBatchResults()` API itself in any way that affects the control flow or the value it returns (there is no change in return values or exception handling in the surrounding code), and the new annotation only enforces compile-time or runtime permission checks rather than changing any behavior, this should not introduce a compatibility issue. Therefore, there is no compatibility issue, and the number is 0."
1060,<android.accessibilityservice.AccessibilityGestureEvent: String toString()>,30,31,<android.accessibilityservice.AccessibilityGestureEvent: String toString()>,<android.accessibilityservice.AccessibilityGestureEvent: String toString()>,0,"{
    StringBuilder stringBuilder = new StringBuilder(""AccessibilityGestureEvent["");
    stringBuilder.append(""gestureId: "").append(eventTypeToString(mGestureId));
    stringBuilder.append("", "");
    stringBuilder.append(""displayId: "").append(mDisplayId);
    stringBuilder.append(']');
    return stringBuilder.toString();
}","{
    StringBuilder stringBuilder = new StringBuilder(""AccessibilityGestureEvent["");
    stringBuilder.append(""gestureId: "").append(gestureIdToString(mGestureId));
    stringBuilder.append("", "");
    stringBuilder.append(""displayId: "").append(mDisplayId);
    stringBuilder.append("", "");
    stringBuilder.append(""Motion Events: ["");
    for (int i = 0; i < mMotionEvents.size(); ++i) {
        String action = MotionEvent.actionToString(mMotionEvents.get(i).getActionMasked());
        stringBuilder.append(action);
        if (i < (mMotionEvents.size() - 1)) {
            stringBuilder.append("", "");
        } else {
            stringBuilder.append(""]"");
        }
    }
    stringBuilder.append(']');
    return stringBuilder.toString();
}",1,,,-1,"[@NonNull, @Override]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"1,3,4",1,"There is a change in the method used to convert the gesture ID to a string (from eventTypeToString() to gestureIdToString()), an addition of a new for-loop to concatenate motion events information to the StringBuilder, and the string literal inside the StringBuilder has been modified. Thus, the code change types are 1, 3, and 4.","The changes in the string conversion method and the additional loop for motion events introduce new content to the return value of the toString() method, which means the returned String could differ from the previous version. This is a classic case where the return value has been altered, leading to CI type 1."
1062,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,30,31,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,<android.accessibilityservice.AccessibilityService.MagnificationController: Region getMagnificationRegion()>,0,"{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationRegion(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain magnified region"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Region.obtain();
}","{
    final IAccessibilityServiceConnection connection = AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId);
    if (connection != null) {
        try {
            return connection.getMagnificationRegion(mDisplayId);
        } catch (RemoteException re) {
            Log.w(LOG_TAG, ""Failed to obtain magnified region"", re);
            re.rethrowFromSystemServer();
        }
    }
    return Region.obtain();
}",1,"/**
 * Returns the region of the screen currently active for magnification. Changes to
 * magnification scale and center only affect this portion of the screen. The rest of the
 * screen, for example input methods, cannot be magnified. This region is relative to the
 * unscaled screen and is independent of the scale and center point.
 * <p>
 * The returned region will be empty if magnification is not active. Magnification is active
 * if magnification gestures are enabled or if a service is running that can control
 * magnification.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return an empty region.
 *
 * @return the region of the screen currently active for magnification, or an empty region
 * if magnification is not active.
 */
","/**
 * Returns the region of the screen currently active for magnification. Changes to
 * magnification scale and center only affect this portion of the screen. The rest of the
 * screen, for example input methods, cannot be magnified. This region is relative to the
 * unscaled screen and is independent of the scale and center point.
 * <p>
 * The returned region will be empty if magnification is not active. Magnification is active
 * if magnification gestures are enabled or if a service is running that can control
 * magnification.
 * <p>
 * <strong>Note:</strong> If the service is not yet connected (e.g.
 * {@link AccessibilityService#onServiceConnected()} has not yet been
 * called) or the service has been disconnected, this method will
 * return an empty region.
 *
 * @return the region of the screen currently active for magnification, or an empty region
 * if magnification is not active.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"There is a change in the code where 'AccessibilityInteractionClient.getInstance().getConnection(mService.mConnectionId)' has been altered to 'AccessibilityInteractionClient.getInstance(mService).getConnection(mService.mConnectionId)'. The change is within the argument passed to the 'getInstance()' method of 'AccessibilityInteractionClient', which indicates a change in the dependent API.","There is no Compatibility Issue as the signature, return type, and exception handling of the method have not been modified. The logic also remains effectively the same, as the changed part is related to how the 'AccessibilityInteractionClient' instance is obtained but does not affect the behavior of the 'getMagnificationRegion()' method's return value or the exceptions it may throw."
1063,<android.view.WindowInsets: boolean equals(Object)>,30,31,<android.view.WindowInsets: boolean equals(Object)>,<android.view.WindowInsets: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || !(o instanceof WindowInsets))
        return false;
    WindowInsets that = (WindowInsets) o;
    return mIsRound == that.mIsRound && mAlwaysConsumeSystemBars == that.mAlwaysConsumeSystemBars && mSystemWindowInsetsConsumed == that.mSystemWindowInsetsConsumed && mStableInsetsConsumed == that.mStableInsetsConsumed && mDisplayCutoutConsumed == that.mDisplayCutoutConsumed && Arrays.equals(mTypeInsetsMap, that.mTypeInsetsMap) && Arrays.equals(mTypeMaxInsetsMap, that.mTypeMaxInsetsMap) && Arrays.equals(mTypeVisibilityMap, that.mTypeVisibilityMap) && Objects.equals(mDisplayCutout, that.mDisplayCutout);
}","{
    if (this == o)
        return true;
    if (o == null || !(o instanceof WindowInsets))
        return false;
    WindowInsets that = (WindowInsets) o;
    return mIsRound == that.mIsRound && mAlwaysConsumeSystemBars == that.mAlwaysConsumeSystemBars && mSystemWindowInsetsConsumed == that.mSystemWindowInsetsConsumed && mStableInsetsConsumed == that.mStableInsetsConsumed && mDisplayCutoutConsumed == that.mDisplayCutoutConsumed && Arrays.equals(mTypeInsetsMap, that.mTypeInsetsMap) && Arrays.equals(mTypeMaxInsetsMap, that.mTypeMaxInsetsMap) && Arrays.equals(mTypeVisibilityMap, that.mTypeVisibilityMap) && Objects.equals(mDisplayCutout, that.mDisplayCutout) && Objects.equals(mRoundedCorners, that.mRoundedCorners) && Objects.equals(mPrivacyIndicatorBounds, that.mPrivacyIndicatorBounds);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in the equals method has been altered by adding new conditions to check, which are Objects.equals(mRoundedCorners, that.mRoundedCorners) and Objects.equals(mPrivacyIndicatorBounds, that.mPrivacyIndicatorBounds). These conditions use Objects.equals to compare additional fields in the object that were not considered in the early version. This qualifies as ""Other statement changed"" since it's a change in the method's logic related to equality checks of new fields, and it's also a ""Return statement changed"" since it's an alteration in the logical expression used to compute the return value.","Because the return condition in the equals method has been expanded with additional checks, the method may produce different results from before; i.e., cases where objects were considered equal in the earlier version may not be in the later version if these new fields do not match. This change can potentially return a different boolean value when comparing WindowInsets objects, thus introducing a ""Compatibility Issue caused by potential different return values or types."""
1066,<android.app.PropertyInvalidatedCache.AutoCorker: void autoCork()>,30,31,<android.app.PropertyInvalidatedCache.AutoCorker: void autoCork()>,<android.app.PropertyInvalidatedCache.AutoCorker: void autoCork()>,0,"{
    if (Looper.getMainLooper() == null) {
        // We're not ready to auto-cork yet, so just invalidate the cache immediately.
        if (DEBUG) {
            Log.w(TAG, ""invalidating instead of autocorking early in init: "" + mPropertyName);
        }
        PropertyInvalidatedCache.invalidateCache(mPropertyName);
        return;
    }
    synchronized (mLock) {
        boolean alreadyQueued = mUncorkDeadlineMs >= 0;
        if (DEBUG) {
            Log.w(TAG, String.format(""autoCork mUncorkDeadlineMs=%s"", mUncorkDeadlineMs));
        }
        mUncorkDeadlineMs = SystemClock.uptimeMillis() + mAutoCorkDelayMs;
        if (!alreadyQueued) {
            getHandlerLocked().sendEmptyMessageAtTime(0, mUncorkDeadlineMs);
            PropertyInvalidatedCache.corkInvalidations(mPropertyName);
        }
    }
}","{
    if (Looper.getMainLooper() == null) {
        // We're not ready to auto-cork yet, so just invalidate the cache immediately.
        if (DEBUG) {
            Log.w(TAG, ""invalidating instead of autocorking early in init: "" + mPropertyName);
        }
        PropertyInvalidatedCache.invalidateCache(mPropertyName);
        return;
    }
    synchronized (mLock) {
        boolean alreadyQueued = mUncorkDeadlineMs >= 0;
        if (DEBUG) {
            Log.w(TAG, String.format(""autoCork %s mUncorkDeadlineMs=%s"", mPropertyName, mUncorkDeadlineMs));
        }
        mUncorkDeadlineMs = SystemClock.uptimeMillis() + mAutoCorkDelayMs;
        if (!alreadyQueued) {
            getHandlerLocked().sendEmptyMessageAtTime(0, mUncorkDeadlineMs);
            PropertyInvalidatedCache.corkInvalidations(mPropertyName);
        } else {
            final long count = sCorkedInvalidates.getOrDefault(mPropertyName, (long) 0);
            sCorkedInvalidates.put(mPropertyName, count + 1);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has changed since there is a new 'else' block added in the late version. There are new statements within the 'else' block related to updating the 'sCorkedInvalidates' map, so the code change type is 3,4.","There are no changes in the method's return value or the exceptions it might throw. The method's execution path has been extended to include a case where 'alreadyQueued' is true, but this additional behavior only affects an internal static map and does not alter the output returned or exceptions thrown by the method. There is no indication that these changes would result in a compatibility issue, thus the CI type is 0."
1068,<android.app.TaskInfo: String toString()>,30,31,<android.app.TaskInfo: String toString()>,<android.app.TaskInfo: String toString()>,0,"{
    return ""TaskInfo{userId="" + userId + "" stackId="" + stackId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" topActivityInfo="" + topActivityInfo;
}","{
    return ""TaskInfo{userId="" + userId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" supportsMultiWindow="" + supportsMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" displayCutoutSafeInsets="" + displayCutoutInsets + "" topActivityInfo="" + topActivityInfo + "" launchCookies="" + launchCookies + "" positionInParent="" + positionInParent + "" parentTaskId="" + parentTaskId + "" isFocused="" + isFocused + "" isVisible="" + isVisible + "" topActivityInSizeCompat="" + topActivityInSizeCompat + "" locusId= "" + mTopActivityLocusId + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The string that is being returned has been modified, with some fields being removed (e.g., ""stackId="") and new fields added (e.g., ""supportsMultiWindow="", ""displayCutoutSafeInsets="", ""launchCookies="", ""positionInParent="", ""isFocused="", ""isVisible="", ""topActivityInSizeCompat="", ""locusId=""). Such a change in the return statement indicates a change type of 1 and 4 since the structure of the returned String value has been altered.","The API now potentially returns a different string value due to the altered return statement, so the CI type is 1."
1069,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",30,31,"<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>","<android.app.ContextImpl: void sendBroadcastMultiplePermissions(Intent,String[])>",0,"{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, null, false, false, getUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method `ActivityManager.getService().broadcastIntentWithFeature` has a change in the parameter list where a new `null` parameter is added, and the comment `/*excludedPermissions=*/` is introduced before `AppOpsManager.OP_NONE`. This represents a change to the order and number of arguments passed to the method call, so the code change type is 4.","There is no Compatibility Issue detected. The internal implementation details of how the `broadcastIntentWithFeature` method handles the parameters have changed, but it does not affect the behavior of the `sendBroadcastMultiplePermissions` method from the caller's perspective, and therefore it does not lead to a CI."
1070,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,30,31,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getPinnedShortcuts()>,0,"{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],"[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The method call mService.getShortcuts(...) in the return statement has been wrapped with getFutureOrThrow(...) in the late version, which indicates a change in how the results are obtained. Thus, the change is classified as type 5, Dependent API changed.","Even though there is a modification in how the shortcut information is retrieved, there are no indications that this would lead to different return values or different exceptions being thrown, assuming getFutureOrThrow correctly propagates the internals of the Future it presumably wraps. Thus, without any indications that the behavior is directly modified, there is no Compatibility Issue."
1071,<android.text.format.Time: String toString()>,30,31,<android.text.format.Time: String toString()>,<android.text.format.Time: String toString()>,0,"{
    // toString() uses its own TimeCalculator rather than the shared one. Otherwise crazy stuff
    // happens during debugging when the debugger calls toString().
    TimeCalculator calculator = new TimeCalculator(this.timezone);
    calculator.copyFieldsFromTime(this);
    return calculator.toStringInternal();
}","{
    // toString() uses its own TimeCalculator rather than the shared one. Otherwise weird stuff
    // happens during debugging when the debugger calls toString().
    TimeCalculator calculator = new TimeCalculator(this.timezone);
    calculator.copyFieldsFromTime(this);
    return calculator.toStringInternal();
}",1,"/**
 * Return the current time in YYYYMMDDTHHMMSS&lt;tz&gt; format
 */
","/**
 * Return the current time in YYYYMMDDTHHMMSS&lt;tz&gt; format
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no changes in the implementation between the two versions, only a comment within the code has been slightly modified (changing the word ""crazy"" to ""weird""). Comments do not affect the execution or behaviour of the code.",Since there were no changes made to the actual code - only comments have been altered - there is no compatibility issue between these two versions.
1072,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,30,31,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,<android.bluetooth.le.AdvertisingSet: void setAdvertisingParameters(AdvertisingSetParameters)>,0,"{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */
","/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,5,0,"The late version of the implementation includes an additional parameter, mAttributionSource, being passed to the method mGatt.setAdvertisingParameters which indicates that there is a change in the dependent API, so the code change type is 5.","Although a new parameter is added in the method call, it does not impact the return type or value, nor does it change the exception handling. As such, there is no Compatibility Issue by definition, thus the CI type is 0."
1073,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",30,31,"<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>","<android.app.ContextImpl: void sendStickyBroadcastAsUser(Intent,UserHandle,Bundle)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.prepareToLeaveProcess(this);
        ActivityManager.getService().broadcastIntentWithFeature(mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, null, /*excludedPermissions=*/
        AppOpsManager.OP_NONE, options, false, true, user.getIdentifier());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,,,-1,"[@Override, @Deprecated]","[@Override, @Deprecated]",-1,-1,-1,-1,-1,-1,4,0,"The change involves a comment addition ""/*excludedPermissions=*/"" in the sequence of arguments for the method call to `ActivityManager.getService().broadcastIntentWithFeature`. This does not affect the behavior of the code nor does it modify any functionality; it's merely a comment to clarify the argument being passed.","There is no Compatibility Issue since the code change does not affect the execution or outcome of the method, meaning it will neither change the return values nor the exception handling. The code behavior remains the same across both versions."
1074,<android.text.style.SuggestionSpan: int getUnderlineColor()>,30,31,<android.text.style.SuggestionSpan: int getUnderlineColor()>,<android.text.style.SuggestionSpan: int getUnderlineColor()>,0,"{
    // The order here should match what is used in updateDrawState
    final boolean misspelled = (mFlags & FLAG_MISSPELLED) != 0;
    final boolean easy = (mFlags & FLAG_EASY_CORRECT) != 0;
    final boolean autoCorrection = (mFlags & FLAG_AUTO_CORRECTION) != 0;
    if (easy) {
        if (!misspelled) {
            return mEasyCorrectUnderlineColor;
        } else {
            return mMisspelledUnderlineColor;
        }
    } else if (autoCorrection) {
        return mAutoCorrectionUnderlineColor;
    }
    return 0;
}","{
    // The order here should match what is used in updateDrawState
    final boolean misspelled = (mFlags & FLAG_MISSPELLED) != 0;
    final boolean easy = (mFlags & FLAG_EASY_CORRECT) != 0;
    final boolean autoCorrection = (mFlags & FLAG_AUTO_CORRECTION) != 0;
    final boolean grammarError = (mFlags & FLAG_GRAMMAR_ERROR) != 0;
    if (easy) {
        if (grammarError) {
            return mGrammarErrorUnderlineColor;
        } else if (misspelled) {
            return mMisspelledUnderlineColor;
        } else {
            return mEasyCorrectUnderlineColor;
        }
    } else if (autoCorrection) {
        return mAutoCorrectionUnderlineColor;
    } else if (misspelled) {
        return mMisspelledUnderlineColor;
    } else if (grammarError) {
        return mGrammarErrorUnderlineColor;
    }
    return 0;
}",1,"/**
 * @return The color of the underline for that span, or 0 if there is no underline
 */
","/**
 * @return The color of the underline for that span, or 0 if there is no underline
 */
",-1,[@ColorInt],[@ColorInt],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The late implementation introduces a new condition check for 'grammarError', adds new branches with different return statements, and reorders existing ones. The changes include a new local variable declaration, modified control dependencies, and new return statements which correspond to change types 1, 3, and 4.","Due to the introduction of new conditions affecting which underline color is returned, and the additional return statements for those new conditions, the late implementation can return different values compared to the early version. Thus, the return value may change, causing a CI of type 1."
1075,"<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>",30,31,"<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>","<android.view.inputmethod.InputMethodManager: void toggleSoftInputFromWindow(IBinder,int,int)>",0,"{
    synchronized (mH) {
        final View servedView = getServedViewLocked();
        if (servedView == null || servedView.getWindowToken() != windowToken) {
            return;
        }
        if (mCurMethod != null) {
            try {
                mCurMethod.toggleSoftInput(showFlags, hideFlags);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    ImeTracing.getInstance().triggerClientDump(""InputMethodManager#toggleSoftInputFromWindow"", InputMethodManager.this, null);
    synchronized (mH) {
        final View servedView = getServedViewLocked();
        if (servedView == null || servedView.getWindowToken() != windowToken) {
            return;
        }
        toggleSoftInput(showFlags, hideFlags);
    }
}",1,"/**
 * This method toggles the input method window display.
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 */
","/**
 * This method toggles the input method window display.
 * If the input window is already displayed, it gets hidden.
 * If not the input window will be displayed.
 * @param windowToken The token of the window that is making the request,
 * as returned by {@link View#getWindowToken() View.getWindowToken()}.
 * @param showFlags Provides additional operating flags.  May be
 * 0 or have the {@link #SHOW_IMPLICIT},
 * {@link #SHOW_FORCED} bit set.
 * @param hideFlags Provides additional operating flags.  May be
 * 0 or have the {@link #HIDE_IMPLICIT_ONLY},
 * {@link #HIDE_NOT_ALWAYS} bit set.
 *
 * @deprecated Use {@link #showSoftInput(View, int)} or
 * {@link #hideSoftInputFromWindow(IBinder, int)} explicitly instead.
 * In particular during focus changes, the current visibility of the IME is not
 * well defined. Starting in {@link Build.VERSION_CODES#S Android S}, this only
 * has an effect if the calling app is the current IME focus.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"3,4,5",0,"A new method call ""ImeTracing.getInstance().triggerClientDump()"" has been introduced outside of the synchronized block which is of type 4. Inside the synchronized block, the invocation of toggleSoftInput(showFlags, hideFlags) replaces a call to mCurMethod.toggleSoftInput(showFlags, hideFlags), implying a change in the flow of internal calls which is a dependent API change (type 5). There is no modification to the return or throw statements (no new return or throw), so we have an other statement change and a dependent API changed, but the essence of behavior within this context seems preserved without any exception handling changes.","The added tracing statement should not affect the functionality of the method from the client's perspective (no change in the API's external behavior), and the change of internal method call does not alter the method's return value or thrown exceptions since it's just refactoring of the internal implementation to another method call with seemingly the same functionality. The @Deprecated annotation does not introduce a CI because it's a compile-time marker indicating that clients should move away from using this API; it does not affect the runtime behavior. Therefore, there is no CI here."
1076,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,30,31,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,<android.app.admin.DevicePolicyManager: boolean isProfileOwnerApp(String)>,0,"{
    throwIfParentInstance(""isProfileOwnerApp"");
    if (mService != null) {
        try {
            ComponentName profileOwner = mService.getProfileOwner(myUserId());
            return profileOwner != null && profileOwner.getPackageName().equals(packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}","{
    throwIfParentInstance(""isProfileOwnerApp"");
    if (mService != null) {
        try {
            ComponentName profileOwner = mService.getProfileOwnerAsUser(myUserId());
            return profileOwner != null && profileOwner.getPackageName().equals(packageName);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    return false;
}",1,"/**
 * Used to determine if a particular package is registered as the profile owner for the
 * user. A profile owner is a special device admin that has additional privileges
 * within the profile.
 *
 * @param packageName The package name of the app to compare with the registered profile owner.
 * @return Whether or not the package is registered as the profile owner.
 */
","/**
 * Used to determine if a particular package is registered as the profile owner for the
 * user. A profile owner is a special device admin that has additional privileges
 * within the profile.
 *
 * @param packageName The package name of the app to compare with the registered profile owner.
 * @return Whether or not the package is registered as the profile owner.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed slightly: the method call within the try block has changed from mService.getProfileOwner(myUserId()) to mService.getProfileOwnerAsUser(myUserId()). This indicates that a dependent API has changed, so the code change type is 5.","The change is internal to the method logic, and the change from getProfileOwner to getProfileOwnerAsUser does not imply a different behavior in terms of what is returned or what exception is thrown, assuming that the new method is meant to replace the old one and maintains the same logic. Therefore, there is no compatibility issue, and the CI type is 0."
1078,<android.view.InputDevice: String toString()>,30,31,<android.view.InputDevice: String toString()>,<android.view.InputDevice: String toString()>,0,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE_RELATIVE, ""mouse_relative"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Descriptor: "").append(mDescriptor).append(""\n"");
    description.append(""  Generation: "").append(mGeneration).append(""\n"");
    description.append(""  Location: "").append(mIsExternal ? ""external"" : ""built-in"").append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Has Vibrator: "").append(mHasVibrator).append(""\n"");
    description.append(""  Has Sensor: "").append(mHasSensor).append(""\n"");
    description.append(""  Has battery: "").append(mHasBattery).append(""\n"");
    description.append(""  Has mic: "").append(mHasMicrophone).append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE_RELATIVE, ""mouse_relative"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append("" resolution="").append(range.mResolution);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
1079,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,30,31,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}","{
    if (VDBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,"[@RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The method mService.writeDescriptor() has a new parameter added: mAttributionSource. This is an ""Other statement changed"" because it is an additional parameter, but not a change in return type, exception handling, or control flow. Therefore, the code change type is 4. Moreover, a change in a method's parameter list where the method is external to the current API class is considered a ""Dependent API changed"", so the code change type also includes 5.","The change does not lead to different return values, and there is no modification in the method logic that would alter the circumstances under which exceptions are thrown. The return and exception behavior of the method should remain unchanged despite the added parameter, as this parameter is likely used for internal tracking or permissions checking. Therefore, there is no Compatibility Issue, and the CI type is 0."
1080,<android.service.voice.AlwaysOnHotwordDetector.MyHandler: void handleMessage(Message)>,30,31,<android.service.voice.AlwaysOnHotwordDetector.MyHandler: void handleMessage(Message)>,<android.service.voice.AlwaysOnHotwordDetector.MyHandler: void handleMessage(Message)>,0,"{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID) {
            Slog.w(TAG, ""Received message: "" + msg.what + "" for an invalid detector"");
            return;
        }
    }
    switch(msg.what) {
        case MSG_AVAILABILITY_CHANGED:
            mExternalCallback.onAvailabilityChanged(msg.arg1);
            break;
        case MSG_HOTWORD_DETECTED:
            mExternalCallback.onDetected((EventPayload) msg.obj);
            break;
        case MSG_DETECTION_ERROR:
            mExternalCallback.onError();
            break;
        case MSG_DETECTION_PAUSE:
            mExternalCallback.onRecognitionPaused();
            break;
        case MSG_DETECTION_RESUME:
            mExternalCallback.onRecognitionResumed();
            break;
        default:
            super.handleMessage(msg);
    }
}","{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID) {
            Slog.w(TAG, ""Received message: "" + msg.what + "" for an invalid detector"");
            return;
        }
    }
    switch(msg.what) {
        case MSG_AVAILABILITY_CHANGED:
            mExternalCallback.onAvailabilityChanged(msg.arg1);
            break;
        case MSG_HOTWORD_DETECTED:
            mExternalCallback.onDetected((EventPayload) msg.obj);
            break;
        case MSG_DETECTION_ERROR:
            mExternalCallback.onError();
            break;
        case MSG_DETECTION_PAUSE:
            mExternalCallback.onRecognitionPaused();
            break;
        case MSG_DETECTION_RESUME:
            mExternalCallback.onRecognitionResumed();
            break;
        case MSG_HOTWORD_REJECTED:
            mExternalCallback.onRejected((HotwordRejectedResult) msg.obj);
            break;
        case MSG_HOTWORD_STATUS_REPORTED:
            mExternalCallback.onHotwordDetectionServiceInitialized(msg.arg1);
            break;
        case MSG_PROCESS_RESTARTED:
            mExternalCallback.onHotwordDetectionServiceRestarted();
            break;
        default:
            super.handleMessage(msg);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"New case statements have been added to the 'switch' construct, so the code change type is 3. However, the logic encapsulated in the early version is still present and functions the same way.",No Compatibility Issue could arise from this change because the existing functionality and the way existing messages are handled remain unchanged. The added cases handle new message types that wouldn't affect the behavior of the method with respect to the messages it was already handling.
1081,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",30,31,"<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>","<android.bluetooth.BluetoothAdapter: boolean startLeScan(UUID[],LeScanCallback)>",0,"{
    if (DBG) {
        Log.d(TAG, ""startLeScan(): "" + Arrays.toString(serviceUuids));
    }
    if (callback == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: null callback"");
        }
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        }
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG) {
                Log.e(TAG, ""LE Scan has already started"");
            }
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG) {
                                Log.d(TAG, ""uuids does not match"");
                            }
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}","{
    if (DBG) {
        Log.d(TAG, ""startLeScan(): "" + Arrays.toString(serviceUuids));
    }
    if (callback == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: null callback"");
        }
        return false;
    }
    BluetoothLeScanner scanner = getBluetoothLeScanner();
    if (scanner == null) {
        if (DBG) {
            Log.e(TAG, ""startLeScan: cannot get BluetoothLeScanner"");
        }
        return false;
    }
    synchronized (mLeScanClients) {
        if (mLeScanClients.containsKey(callback)) {
            if (DBG) {
                Log.e(TAG, ""LE Scan has already started"");
            }
            return false;
        }
        try {
            IBluetoothGatt iGatt = mManagerService.getBluetoothGatt();
            if (iGatt == null) {
                // BLE is not supported
                return false;
            }
            @SuppressLint(""AndroidFrameworkBluetoothPermission"") ScanCallback scanCallback = new ScanCallback() {

                @Override
                public void onScanResult(int callbackType, ScanResult result) {
                    if (callbackType != ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
                        // Should not happen.
                        Log.e(TAG, ""LE Scan has already started"");
                        return;
                    }
                    ScanRecord scanRecord = result.getScanRecord();
                    if (scanRecord == null) {
                        return;
                    }
                    if (serviceUuids != null) {
                        List<ParcelUuid> uuids = new ArrayList<ParcelUuid>();
                        for (UUID uuid : serviceUuids) {
                            uuids.add(new ParcelUuid(uuid));
                        }
                        List<ParcelUuid> scanServiceUuids = scanRecord.getServiceUuids();
                        if (scanServiceUuids == null || !scanServiceUuids.containsAll(uuids)) {
                            if (DBG) {
                                Log.d(TAG, ""uuids does not match"");
                            }
                            return;
                        }
                    }
                    callback.onLeScan(result.getDevice(), result.getRssi(), scanRecord.getBytes());
                }
            };
            ScanSettings settings = new ScanSettings.Builder().setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES).setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
            List<ScanFilter> filters = new ArrayList<ScanFilter>();
            if (serviceUuids != null && serviceUuids.length > 0) {
                // Note scan filter does not support matching an UUID array so we put one
                // UUID to hardware and match the whole array in callback.
                ScanFilter filter = new ScanFilter.Builder().setServiceUuid(new ParcelUuid(serviceUuids[0])).build();
                filters.add(filter);
            }
            scanner.startScan(filters, settings, scanCallback);
            mLeScanClients.put(callback, scanCallback);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, """", e);
        }
    }
    return false;
}",1,"/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
","/**
 * Starts a scan for Bluetooth LE devices, looking for devices that
 * advertise given services.
 *
 * <p>Devices which advertise all specified services are reported using the
 * {@link LeScanCallback#onLeScan} callback.
 *
 * @param serviceUuids Array of services to look for
 * @param callback the callback LE scan results are delivered
 * @return true, if the scan was started successfully
 * @deprecated use {@link BluetoothLeScanner#startScan(List, ScanSettings, ScanCallback)}
 * instead.
 */
",-1,"[@Deprecated, @RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)]","[@Deprecated, @RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothScanPermission, @RequiresBluetoothLocationPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_SCAN)]",-1,-1,-1,-1,-1,-1,,,,
1082,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",30,31,"<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>","<android.inputmethodservice.InputMethodService: void doStartInput(InputConnection,EditorInfo,boolean)>",0,"{
    if (!restarting) {
        doFinishInput();
    }
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    mInlineSuggestionSessionController.notifyOnStartInput(attribute == null ? null : attribute.packageName, attribute == null ? null : attribute.autofillId);
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            mInlineSuggestionSessionController.notifyOnStartInputView();
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    } else if (mCanPreRender && mInputEditorInfo != null && mStartedInputConnection != null) {
        // pre-render IME window and keep it invisible.
        if (DEBUG)
            Log.v(TAG, ""Pre-Render IME for "" + mInputEditorInfo.fieldName);
        if (mInShowWindow) {
            Log.w(TAG, ""Re-entrance in to showWindow"");
            return;
        }
        mDecorViewWasVisible = mDecorViewVisible;
        mInShowWindow = true;
        startViews(prepareWindow(true));
        // compute visibility
        mIsPreRendered = true;
        onPreRenderedWindowVisibilityChanged(false);
        // When IME is not pre-rendered, this will actually show the IME.
        if (DEBUG)
            Log.v(TAG, ""showWindow: draw decorView!"");
        mWindow.show();
        maybeNotifyPreRendered();
        mDecorViewWasVisible = true;
        mInShowWindow = false;
    } else {
        mIsPreRendered = false;
    }
}","{
    if (!restarting && mInputStarted) {
        doFinishInput();
    }
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService#doStartInput"", this, null);
    mInputStarted = true;
    mStartedInputConnection = ic;
    mInputEditorInfo = attribute;
    initialize();
    mInlineSuggestionSessionController.notifyOnStartInput(attribute == null ? null : attribute.packageName, attribute == null ? null : attribute.autofillId);
    if (DEBUG)
        Log.v(TAG, ""CALL: onStartInput"");
    onStartInput(attribute, restarting);
    if (mDecorViewVisible) {
        if (mShowInputRequested) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartInputView"");
            mInputViewStarted = true;
            mInlineSuggestionSessionController.notifyOnStartInputView();
            onStartInputView(mInputEditorInfo, restarting);
            startExtractingText(true);
        } else if (mCandidatesVisibility == View.VISIBLE) {
            if (DEBUG)
                Log.v(TAG, ""CALL: onStartCandidatesView"");
            mCandidatesViewStarted = true;
            onStartCandidatesView(mInputEditorInfo, restarting);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition to call doFinishInput() has changed, incorporating a check for mInputStarted, the call to ImeTracing.getInstance().triggerServiceDump(...) is added, and the block for pre-rendering the IME window has been removed. Therefore, the changes are 3 (Control dependency changed due to the new condition in the if statement) and 4 (Other statement changed due to the addition of a method call and the removal of code related to pre-rendering the IME window).","None of the changes should cause a Compatibility Issue as they don't affect the return value or threw exceptions in ways that should affect the caller. The condition change simply refines the condition under which doFinishInput() is called without changing the method's observable behavior in terms of outputs or exceptions. The addition of the ImeTracing service dump is for debugging and should not influence the method's public behavior. The removed code related to pre-rendering does not seem to change the output values or exceptions from this method's perspective since it's related to internal state handling and UI rendering which isn't part of the API's contract; thus, these changes should not be visible or impactful to the client code in a way that would constitute a Compatibility Issue."
1084,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,30,31,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter(Context)>,0,"{
    if (context == null) {
        throw new IllegalArgumentException(""context cannot be null"");
    }
    context = context.getApplicationContext();
    if (context == null) {
        throw new IllegalArgumentException(""context not associated with any application (using a mock context?)"");
    }
    /* use getSystemService() for consistency */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    if (manager == null) {
        // NFC not available
        return null;
    }
    return manager.getDefaultAdapter();
}","{
    if (context == null) {
        throw new IllegalArgumentException(""context cannot be null"");
    }
    context = context.getApplicationContext();
    if (context == null) {
        throw new IllegalArgumentException(""context not associated with any application (using a mock context?)"");
    }
    if (getServiceInterface() == null) {
        // NFC is not available
        return null;
    }
    /* use getSystemService() for consistency */
    NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
    if (manager == null) {
        // NFC not available
        return null;
    }
    return manager.getDefaultAdapter();
}",1,"/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
","/**
 * Helper to get the default NFC Adapter.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 * <p>
 * This helper is the equivalent of:
 * <pre>
 * NfcManager manager = (NfcManager) context.getSystemService(Context.NFC_SERVICE);
 * NfcAdapter adapter = manager.getDefaultAdapter();</pre>
 * @param context the calling application's context
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"A new if-statement `if (getServiceInterface() == null)` has been introduced to check if the NFC service interface is available, which potentially affects service availability checks, so the code change type is 3. The dependent API `getServiceInterface()` has been added which could change the control flow based on the availability of the NFC service and therefore it is also categorized as 5.","Since the newly introduced check for `getServiceInterface() == null` simply returns null which is consistent with the behavior of the early version when the NfcManager is `null`, this does not directly lead to a CI. It performs a service availability check and acts accordingly without changing the exception handling or altering the data type that is returned from the `getDefaultAdapter()` method, hence no Compatibility Issue is detected, and the CI type is 0."
1085,<android.widget.CompoundButton: void setChecked(boolean)>,30,31,<android.widget.CompoundButton: void setChecked(boolean)>,<android.widget.CompoundButton: void setChecked(boolean)>,0,"{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
    // setStateDescription will not send out event if the description is unchanged.
    setDefaultStateDescritption();
}","{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            // setStateDescription will not send out event if the description is unchanged.
            setDefaultStateDescription();
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
    // setStateDescription will not send out event if the description is unchanged.
    setDefaultStateDescription();
}",1,"/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
","/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The call to setDefaultStateDescription() has been moved inside the if-check for mBroadcasting, and also there is a duplicate call at the end, so the change type is 4. Since there is an extra call ensuring the state description is set regardless of the if-condition, this also counts as a control dependency change, type 3.","There are no Compatibility Issues here because even though the placement of setDefaultStateDescription() has been shifted within the control flow, the state description is always set regardless of the if-condition. The invocation of this method is guaranteed both in the early and late versions due to the call at the end of the function, which means the behavior of setChecked() is preserved."
1086,"<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>",30,31,"<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>","<android.bluetooth.le.AdvertisingSet: void enableAdvertising(boolean,int,int)>",0,"{
    try {
        mGatt.enableAdvertisingSet(mAdvertiserId, enable, duration, maxExtendedAdvertisingEvents);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}","{
    try {
        mGatt.enableAdvertisingSet(mAdvertiserId, enable, duration, maxExtendedAdvertisingEvents, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, ""remote exception - "", e);
    }
}",1,"/**
 * Enables Advertising. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingEnabled()}.
 * <p>
 * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param enable whether the advertising should be enabled (true), or disabled (false)
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms)
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255.
 */
","/**
 * Enables Advertising. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingEnabled()}.
 *
 * @param enable whether the advertising should be enabled (true), or disabled (false)
 * @param duration advertising duration, in 10ms unit. Valid range is from 1 (10ms) to 65535
 * (655,350 ms)
 * @param maxExtendedAdvertisingEvents maximum number of extended advertising events the
 * controller shall attempt to send prior to terminating the extended advertising, even if the
 * duration has not expired. Valid range is from 1 to 255.
 */
",-1,,"[@RequiresLegacyBluetoothAdminPermission, @RequiresBluetoothAdvertisePermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_ADVERTISE)]",-1,-1,-1,-1,-1,-1,5,0,"The method enableAdvertisingSet of the mGatt object has an additional parameter (mAttributionSource) in the late version, which means the dependent API has changed. So the code change type is 5.","Despite the addition of the mAttributionSource parameter in the late version, the change does not lead to a different return value/type or different exception handlings as the try-catch block remains the same and the API method itself has no return statement or different catch logic. Therefore, there is no Compatibility Issue, and the CI type is 0."
1087,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,30,31,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,<android.view.accessibility.AccessibilityNodeInfo: List<AccessibilityNodeInfo> findAccessibilityNodeInfosByViewId(String)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewId(mConnectionId, mWindowId, mSourceNodeId, viewId);
}","{
    enforceSealed();
    if (viewId == null) {
        Log.e(TAG, ""returns empty list due to null viewId."");
        return Collections.emptyList();
    }
    if (!canPerformRequestOverConnection(mConnectionId, mWindowId, mSourceNodeId)) {
        return Collections.emptyList();
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfosByViewId(mConnectionId, mWindowId, mSourceNodeId, viewId);
}",1,"/**
 * Finds {@link AccessibilityNodeInfo}s by the fully qualified view id's resource
 * name where a fully qualified id is of the from ""package:id/id_resource_name"".
 * For example, if the target application's package is ""foo.bar"" and the id
 * resource name is ""baz"", the fully qualified resource id is ""foo.bar:id/baz"".
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * <p>
 * <strong>Note:</strong> The primary usage of this API is for UI test automation
 * and in order to report the fully qualified view id if an {@link AccessibilityNodeInfo}
 * the client has to set the {@link AccessibilityServiceInfo#FLAG_REPORT_VIEW_IDS}
 * flag when configuring his {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 * <p>
 * <strong>Note:</strong> If this view hierarchy has a {@link SurfaceView} embedding another
 * view hierarchy via {@link SurfaceView#setChildSurfacePackage}, there is a limitation that
 * this API won't be able to find the node for the view on the embedded view hierarchy. It's
 * because views don't know about the embedded hierarchies. Instead, you could traverse all
 * the children to find the node.
 * </p>
 *
 * @param viewId The fully qualified resource name of the view id to find.
 * @return A list of node info.
 */
","/**
 * Finds {@link AccessibilityNodeInfo}s by the fully qualified view id's resource
 * name where a fully qualified id is of the from ""package:id/id_resource_name"".
 * For example, if the target application's package is ""foo.bar"" and the id
 * resource name is ""baz"", the fully qualified resource id is ""foo.bar:id/baz"".
 *
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * <p>
 * <strong>Note:</strong> The primary usage of this API is for UI test automation
 * and in order to report the fully qualified view id if an {@link AccessibilityNodeInfo}
 * the client has to set the {@link AccessibilityServiceInfo#FLAG_REPORT_VIEW_IDS}
 * flag when configuring the {@link android.accessibilityservice.AccessibilityService}.
 * </p>
 * <p>
 * <strong>Note:</strong> If this view hierarchy has a {@link SurfaceView} embedding another
 * view hierarchy via {@link SurfaceView#setChildSurfacePackage}, there is a limitation that
 * this API won't be able to find the node for the view on the embedded view hierarchy. It's
 * because views don't know about the embedded hierarchies. Instead, you could traverse all
 * the children to find the node.
 * </p>
 *
 * @param viewId The fully qualified resource name of the view id to find.
 * @return A list of node info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An if condition checking if viewId is null has been added which could lead to an early return of an empty list. This is both a return statement change and a control dependency change because it introduces a new branch in the logic, so the code change type is 1,3.","Due to the introduction of a new if condition that checks for a null viewId, there is a potential for different return values if viewId is null, which was not handled in the early version. This would cause the API to return an empty list where previously it might have executed a different behavior, thereby potentially leading to different return values or types. The CI type is 1."
1088,<android.view.VerifiedKeyEvent: boolean equals(Object)>,30,31,<android.view.VerifiedKeyEvent: boolean equals(Object)>,<android.view.VerifiedKeyEvent: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") VerifiedKeyEvent that = (VerifiedKeyEvent) o;
    // noinspection PointlessBooleanExpression
    return true && getDeviceId() == that.getDeviceId() && getEventTimeNanos() == that.getEventTimeNanos() && getSource() == that.getSource() && getDisplayId() == that.getDisplayId() && mAction == that.mAction && mDownTimeNanos == that.mDownTimeNanos && mFlags == that.mFlags && mKeyCode == that.mKeyCode && mScanCode == that.mScanCode && mMetaState == that.mMetaState && mRepeatCount == that.mRepeatCount;
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    @SuppressWarnings(""unchecked"") VerifiedKeyEvent that = (VerifiedKeyEvent) o;
    // noinspection PointlessBooleanExpression
    return true && super.equals(that) && mAction == that.mAction && mDownTimeNanos == that.mDownTimeNanos && mFlags == that.mFlags && mKeyCode == that.mKeyCode && mScanCode == that.mScanCode && mMetaState == that.mMetaState && mRepeatCount == that.mRepeatCount;
}",1,,,-1,"[@Override, @DataClass.Generated.Member]","[@Override, @DataClass.Generated.Member]",-1,-1,-1,-1,-1,-1,4,0,"The code change is the removal of the direct field comparisons like getDeviceId(), getEventTimeNanos(), getSource(), and getDisplayId() in the return statement, and replacing them with a call to super.equals(that). This is considered an ""Other statement changed"" because it alters how the logic is carried out.","Despite the change, there is no Compatibility Issue because the object's equality check is still based on the same logical comparison. The earlier version did a direct comparison of multiple fields, whereas the latest version introduces a call to super.equals(that), which should logically perform the same check, assuming the superclass's equals method is designed according to the contract of equals to perform field-wise comparison. Therefore, the behavior expected by the API consumer should remain consistent between versions."
1092,<android.view.ViewGroup: void detachAllViewsFromParent()>,30,31,<android.view.ViewGroup: void detachAllViewsFromParent()>,<android.view.ViewGroup: void detachAllViewsFromParent()>,0,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    for (int i = count - 1; i >= 0; i--) {
        children[i].mParent = null;
        children[i] = null;
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    for (int i = count - 1; i >= 0; i--) {
        children[i].mParent = null;
        children[i].setDetached(true);
        children[i] = null;
    }
}",1,"/**
 * Detaches all views from the parent. Detaching a view should be followed
 * either by a call to
 * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}
 * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be
 * temporary; reattachment or removal should happen within the same drawing cycle as
 * detachment. When a view is detached, its parent is null and cannot be retrieved by a
 * call to {@link #getChildAt(int)}.
 *
 * @see #detachViewFromParent(View)
 * @see #detachViewFromParent(int)
 * @see #detachViewsFromParent(int, int)
 * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
 * @see #removeDetachedView(View, boolean)
 */
","/**
 * Detaches all views from the parent. Detaching a view should be followed
 * either by a call to
 * {@link #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)}
 * or a call to {@link #removeDetachedView(View, boolean)}. Detachment should only be
 * temporary; reattachment or removal should happen within the same drawing cycle as
 * detachment. When a view is detached, its parent is null and cannot be retrieved by a
 * call to {@link #getChildAt(int)}.
 *
 * @see #detachViewFromParent(View)
 * @see #detachViewFromParent(int)
 * @see #detachViewsFromParent(int, int)
 * @see #attachViewToParent(View, int, android.view.ViewGroup.LayoutParams)
 * @see #removeDetachedView(View, boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new method call `children[i].setDetached(true);` has been introduced within the loop, therefore, the change type is 4.","Despite this new method call, the behavior of detaching views from parent, which is the main purpose of the method, remains the same. This additional statement does not affect the return value nor does it introduce new exceptions; since the method is void, it only changes internal state. Therefore, there is no Compatibility Issue, and the CI type is 0."
1093,<android.service.autofill.Dataset: String toString()>,30,31,<android.service.autofill.Dataset: String toString()>,<android.service.autofill.Dataset: String toString()>,0,"{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldInlinePresentations != null) {
        builder.append("", fieldInlinePresentations="").append(mFieldInlinePresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}","{
    if (!sDebug)
        return super.toString();
    final StringBuilder builder = new StringBuilder(""Dataset["");
    if (mId == null) {
        builder.append(""noId"");
    } else {
        // Cannot disclose id because it could contain PII.
        builder.append(""id="").append(mId.length()).append(""_chars"");
    }
    if (mFieldIds != null) {
        builder.append("", fieldIds="").append(mFieldIds);
    }
    if (mFieldValues != null) {
        builder.append("", fieldValues="").append(mFieldValues);
    }
    if (mFieldContent != null) {
        builder.append("", fieldContent="").append(mFieldContent);
    }
    if (mFieldPresentations != null) {
        builder.append("", fieldPresentations="").append(mFieldPresentations.size());
    }
    if (mFieldInlinePresentations != null) {
        builder.append("", fieldInlinePresentations="").append(mFieldInlinePresentations.size());
    }
    if (mFieldInlineTooltipPresentations != null) {
        builder.append("", fieldInlineTooltipInlinePresentations="").append(mFieldInlineTooltipPresentations.size());
    }
    if (mFieldFilters != null) {
        builder.append("", fieldFilters="").append(mFieldFilters.size());
    }
    if (mPresentation != null) {
        builder.append("", hasPresentation"");
    }
    if (mInlinePresentation != null) {
        builder.append("", hasInlinePresentation"");
    }
    if (mInlineTooltipPresentation != null) {
        builder.append("", hasInlineTooltipPresentation"");
    }
    if (mAuthentication != null) {
        builder.append("", hasAuthentication"");
    }
    return builder.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The changes include the addition of `mFieldContent`, `mFieldInlineTooltipPresentations`, and `mInlineTooltipPresentation`, as well as the modification of the respective sections of the StringBuilder where they are appended. This is reflected in the variable names and the structure of the appended text. These changes are reflected in the building of the `builder` object's contents and are of the type 4 (Other statement changed).","The change will affect the output of the `toString()` method when `sDebug` is true, because the string returned will contain different content in the late version (with the additions of `fieldContent`, `fieldInlineTooltipInlinePresentations`, and `hasInlineTooltipPresentation`). Therefore, this can potentially lead to a different return value and is categorized as type 1 (Compatibility Issue caused by potential different return values or types)."
1095,<android.content.res.Configuration: String toString()>,30,31,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_HDR_MASK)) {
        // most likely not HDR
        case COLOR_MODE_HDR_UNDEFINED:
            sb.append("" ?ldr"");
            break;
        case COLOR_MODE_HDR_NO:
            /* ldr is not interesting to print */
            break;
        case COLOR_MODE_HDR_YES:
            sb.append("" hdr"");
            break;
        default:
            sb.append("" dynamicRange="");
            sb.append(colorMode & COLOR_MODE_HDR_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        case COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED:
            sb.append("" ?wideColorGamut"");
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_NO:
            /* not wide is not interesting to print */
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_YES:
            sb.append("" widecg"");
            break;
        default:
            sb.append("" wideColorGamut="");
            sb.append(colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        case UI_MODE_TYPE_VR_HEADSET:
            sb.append("" vrheadset"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    sb.append("" winConfig="");
    sb.append(windowConfiguration);
    if (assetsSeq != 0) {
        sb.append("" as."").append(assetsSeq);
    }
    if (seq != 0) {
        sb.append("" s."").append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    fixUpLocaleList();
    if (!mLocaleList.isEmpty()) {
        sb.append("" "");
        sb.append(mLocaleList);
    } else {
        sb.append("" ?localeList"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_HDR_MASK)) {
        // most likely not HDR
        case COLOR_MODE_HDR_UNDEFINED:
            sb.append("" ?ldr"");
            break;
        case COLOR_MODE_HDR_NO:
            /* ldr is not interesting to print */
            break;
        case COLOR_MODE_HDR_YES:
            sb.append("" hdr"");
            break;
        default:
            sb.append("" dynamicRange="");
            sb.append(colorMode & COLOR_MODE_HDR_MASK);
            break;
    }
    switch((colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK)) {
        case COLOR_MODE_WIDE_COLOR_GAMUT_UNDEFINED:
            sb.append("" ?wideColorGamut"");
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_NO:
            /* not wide is not interesting to print */
            break;
        case COLOR_MODE_WIDE_COLOR_GAMUT_YES:
            sb.append("" widecg"");
            break;
        default:
            sb.append("" wideColorGamut="");
            sb.append(colorMode & COLOR_MODE_WIDE_COLOR_GAMUT_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        case UI_MODE_TYPE_WATCH:
            sb.append("" watch"");
            break;
        case UI_MODE_TYPE_VR_HEADSET:
            sb.append("" vrheadset"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    sb.append("" winConfig="");
    sb.append(windowConfiguration);
    if (assetsSeq != 0) {
        sb.append("" as."").append(assetsSeq);
    }
    if (seq != 0) {
        sb.append("" s."").append(seq);
    }
    if (fontWeightAdjustment != FONT_WEIGHT_ADJUSTMENT_UNDEFINED) {
        sb.append("" fontWeightAdjustment="");
        sb.append(fontWeightAdjustment);
    } else {
        sb.append("" ?fontWeightAdjustment"");
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
1096,"<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>",30,31,"<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>","<android.view.WindowInsets: WindowInsets inset(int,int,int,int)>",0,"{
    Preconditions.checkArgumentNonnegative(left);
    Preconditions.checkArgumentNonnegative(top);
    Preconditions.checkArgumentNonnegative(right);
    Preconditions.checkArgumentNonnegative(bottom);
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : insetInsets(mTypeInsetsMap, left, top, right, bottom), mStableInsetsConsumed ? null : insetInsets(mTypeMaxInsetsMap, left, top, right, bottom), mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutoutConsumed ? null : mDisplayCutout == null ? DisplayCutout.NO_CUTOUT : mDisplayCutout.inset(left, top, right, bottom), mCompatInsetsTypes, mCompatIgnoreVisibility);
}","{
    Preconditions.checkArgumentNonnegative(left);
    Preconditions.checkArgumentNonnegative(top);
    Preconditions.checkArgumentNonnegative(right);
    Preconditions.checkArgumentNonnegative(bottom);
    return insetUnchecked(left, top, right, bottom);
}",1,"/**
 * Returns a copy of this instance inset in the given directions.
 *
 * This is intended for dispatching insets to areas of the window that are smaller than the
 * current area.
 *
 * <p>Example:
 * <pre>
 * childView.dispatchApplyWindowInsets(insets.inset(
 * childMarginLeft, childMarginTop, childMarginBottom, childMarginRight));
 * </pre>
 *
 * @param left the amount of insets to remove from the left. Must be non-negative.
 * @param top the amount of insets to remove from the top. Must be non-negative.
 * @param right the amount of insets to remove from the right. Must be non-negative.
 * @param bottom the amount of insets to remove from the bottom. Must be non-negative.
 *
 * @return the inset insets
 *
 * @see #inset(Insets)
 */
","/**
 * Returns a copy of this instance inset in the given directions.
 *
 * This is intended for dispatching insets to areas of the window that are smaller than the
 * current area.
 *
 * <p>Example:
 * <pre>
 * childView.dispatchApplyWindowInsets(insets.inset(
 * childMarginLeft, childMarginTop, childMarginBottom, childMarginRight));
 * </pre>
 *
 * @param left the amount of insets to remove from the left. Must be non-negative.
 * @param top the amount of insets to remove from the top. Must be non-negative.
 * @param right the amount of insets to remove from the right. Must be non-negative.
 * @param bottom the amount of insets to remove from the bottom. Must be non-negative.
 *
 * @return the inset insets
 *
 * @see #inset(Insets)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method changed to call `insetUnchecked(left, top, right, bottom)` instead of directly creating a `new WindowInsets` object. The changes indicate potential alterations in the ""inset"" mechanism which would be a dependent API change, so the code change type is 5.","Since we do not have the implementation details of the newly used method `insetUnchecked`, we cannot conclude for certain that there is a change in the behavior of the API or the type or values it returns. The annotations are unchanged, and there is no direct evidence of any change that can cause a compatibility issue. Assuming `insetUnchecked` is properly implementing the logic that previously was inline within the method, there would be no compatibility issue. Thus, without additional information, the CI type is considered to be 0."
1097,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",30,31,"<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateCursor(View,int,int,int,int)>",0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursor(view, left, top, right, bottom);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""CURSOR CHANGE: "" + mCurMethod);
                mCurMethod.updateCursor(mTmpCursorRect);
                mCursorRect.set(mTmpCursorRect);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.updateCursor(view, left, top, right, bottom);
        return;
    }
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        mTmpCursorRect.set(left, top, right, bottom);
        if (!mCursorRect.equals(mTmpCursorRect)) {
            if (DEBUG)
                Log.d(TAG, ""updateCursor: "" + mCurrentInputMethodSession);
            mCurrentInputMethodSession.updateCursor(mTmpCursorRect);
            mCursorRect.set(mTmpCursorRect);
        }
    }
}",1,"/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
","/**
 * Report the current cursor location in its window.
 *
 * @deprecated Use {@link #updateCursorAnchorInfo(View, CursorAnchorInfo)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"4,5",0,"The only change in the code is replacing `mCurMethod` with `mCurrentInputMethodSession` and the associated comment logs within the synchronized block. Therefore, the change type is 4, which is ""Other statement changed."" Since the method `updateCursor` on different objects is called but there's no indication that the behavior of these methods is different, and the context log change should not affect the functional behavior of this method, this can also be classified as a ""Dependent API changed"" situation (type 5).","There is no Compatibility Issue detected by the changes because the replacement of `mCurMethod` with `mCurrentInputMethodSession` is presumably the renaming of a field holding the same or equivalent functional contract, and the rest of the code remains unchanged. The modification in logging is not a functional change that affects the behavior of the API from an external point of view. Therefore, the API should behave the same way in terms of its external contract, and the return values and exception handling remain unaffected."
1099,<android.app.Notification.Action.Builder: Action build()>,30,31,<android.app.Notification.Action.Builder: Action build()>,<android.app.Notification.Action.Builder: Action build()>,0,"{
    checkContextualActionNullFields();
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = getParcelableArrayFromBundle(mExtras, EXTRA_DATA_ONLY_INPUTS, RemoteInput.class);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction, mIsContextual);
}","{
    checkContextualActionNullFields();
    ArrayList<RemoteInput> dataOnlyInputs = new ArrayList<>();
    RemoteInput[] previousDataInputs = getParcelableArrayFromBundle(mExtras, EXTRA_DATA_ONLY_INPUTS, RemoteInput.class);
    if (previousDataInputs != null) {
        for (RemoteInput input : previousDataInputs) {
            dataOnlyInputs.add(input);
        }
    }
    List<RemoteInput> textInputs = new ArrayList<>();
    if (mRemoteInputs != null) {
        for (RemoteInput input : mRemoteInputs) {
            if (input.isDataOnly()) {
                dataOnlyInputs.add(input);
            } else {
                textInputs.add(input);
            }
        }
    }
    if (!dataOnlyInputs.isEmpty()) {
        RemoteInput[] dataInputsArr = dataOnlyInputs.toArray(new RemoteInput[dataOnlyInputs.size()]);
        mExtras.putParcelableArray(EXTRA_DATA_ONLY_INPUTS, dataInputsArr);
    }
    RemoteInput[] textInputsArr = textInputs.isEmpty() ? null : textInputs.toArray(new RemoteInput[textInputs.size()]);
    return new Action(mIcon, mTitle, mIntent, mExtras, textInputsArr, mAllowGeneratedReplies, mSemanticAction, mIsContextual, mAuthenticationRequired);
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
","/**
 * Combine all of the options that have been set and return a new {@link Action}
 * object.
 * @return the built action
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The construction of the new `Action` object has been modified by adding an additional parameter `mAuthenticationRequired` at the end. This parameter did not exist in the early version. This change is an addition in the code but itâ€™s not related to any return statement, control dependency, exception handling, or dependent API. Thus it is categorized as an 'Other statement changed.'",There is no Compatibility Issue because the new parameter (`mAuthenticationRequired`) has been added to the constructor without altering the behavior of existing parameters or the overall method's behavior from the caller's perspective. The return type remains the same and the method still returns a newly constructed `Action` object.
1100,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,30,31,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,<android.hardware.camera2.impl.CameraCaptureSessionImpl.IdleDrainListener: void onDrained()>,0,"{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
        if (DEBUG)
            Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        // everything is idle.
        try {
            // begin transition to unconfigured
            mDeviceImpl.configureStreamsChecked(/*inputConfig*/
            null, /*outputs*/
            null, /*operatingMode*/
            ICameraDeviceUser.NORMAL_MODE, /*sessionParams*/
            null);
        } catch (CameraAccessException e) {
            // OK: do not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
        // TODO: call onError instead of onClosed if this happens
        } catch (IllegalStateException e) {
            // Camera is already closed, so nothing left to do
            if (DEBUG)
                Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, mIdString + ""onIdleDrained"");
    // without causing a deadlock
    synchronized (mDeviceImpl.mInterfaceLock) {
        /*
                 * The device is now IDLE, and has settled. It will not transition to
                 * ACTIVE or BUSY again by itself.
                 *
                 * It's now safe to unconfigure the outputs.
                 *
                 * This operation is idempotent; a session will not be closed twice.
                 */
        if (DEBUG)
            Log.v(TAG, mIdString + ""Session drain complete, skip unconfigure: "" + mSkipUnconfigure);
        // as we won't get state updates any more anyway.
        if (mSkipUnconfigure) {
            return;
        }
        // everything is idle.
        try {
            // begin transition to unconfigured
            mDeviceImpl.configureStreamsChecked(/*inputConfig*/
            null, /*outputs*/
            null, /*operatingMode*/
            ICameraDeviceUser.NORMAL_MODE, /*sessionParams*/
            null, SystemClock.uptimeMillis());
        } catch (CameraAccessException e) {
            // OK: do not throw checked exceptions.
            Log.e(TAG, mIdString + ""Exception while unconfiguring outputs: "", e);
        // TODO: call onError instead of onClosed if this happens
        } catch (IllegalStateException e) {
            // Camera is already closed, so nothing left to do
            if (DEBUG)
                Log.v(TAG, mIdString + ""Camera was already closed or busy, skipping unconfigure"");
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The dependent API `mDeviceImpl.configureStreamsChecked` is now called with an additional parameter (`SystemClock.uptimeMillis()`) in the late version, which indicates that the signature or the behavior of the API it depends on could have changed. Therefore, the code change type is 5.","As there is no change in the existing control flow or exception handling, and assuming that the addition of the parameter does not affect the return value or exception throwing of `configureStreamsChecked` method (as we don't have information on changes to `configureStreamsChecked` itself), there is no direct Compatibility Issue evidenced within the code for this API. Thus, the CI type is 0."
1101,<android.view.InputDevice: Vibrator getVibrator()>,30,31,<android.view.InputDevice: Vibrator getVibrator()>,<android.view.InputDevice: Vibrator getVibrator()>,0,"{
    synchronized (mMotionRanges) {
        if (mVibrator == null) {
            if (mHasVibrator) {
                mVibrator = InputManager.getInstance().getInputDeviceVibrator(mId);
            } else {
                mVibrator = NullVibrator.getInstance();
            }
        }
        return mVibrator;
    }
}","{
    synchronized (mMotionRanges) {
        if (mVibrator == null) {
            if (mHasVibrator) {
                mVibrator = InputManager.getInstance().getInputDeviceVibrator(mId, VIBRATOR_ID_ALL);
            } else {
                mVibrator = NullVibrator.getInstance();
            }
        }
        return mVibrator;
    }
}",1,"/**
 * Gets the vibrator service associated with the device, if there is one.
 * Even if the device does not have a vibrator, the result is never null.
 * Use {@link Vibrator#hasVibrator} to determine whether a vibrator is
 * present.
 *
 * Note that the vibrator associated with the device may be different from
 * the system vibrator.  To obtain an instance of the system vibrator instead, call
 * {@link Context#getSystemService} with {@link Context#VIBRATOR_SERVICE} as argument.
 *
 * @return The vibrator service associated with the device, never null.
 */
","/**
 * Gets the vibrator service associated with the device, if there is one.
 * Even if the device does not have a vibrator, the result is never null.
 * Use {@link Vibrator#hasVibrator} to determine whether a vibrator is
 * present.
 *
 * Note that the vibrator associated with the device may be different from
 * the system vibrator.  To obtain an instance of the system vibrator instead, call
 * {@link Context#getSystemService} with {@link Context#VIBRATOR_SERVICE} as argument.
 *
 * @return The vibrator service associated with the device, never null.
 * @deprecated Use {@link #getVibratorManager()} to retrieve the default device vibrator.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,5,0,"The change in late implementation involves a modification to the parameter list of the method getInputDeviceVibrator by adding VIBRATOR_ID_ALL. Therefore, only the dependent API has changed, which is indicated by the code change type 5.","There is no compatibility issue because the behavior and return type of the method are not altered. It still returns the same mVibrator object, irrespective of the modified parameters. The method getInputDeviceVibrator is assumed to handle the additional parameter without altering the output returned to the caller of getVibrator(). Thus, the CI type is 0."
1102,<android.content.ContentResolver: Uri canonicalize(Uri)>,30,31,<android.content.ContentResolver: Uri canonicalize(Uri)>,<android.content.ContentResolver: Uri canonicalize(Uri)>,0,"{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.canonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        final UriResultListener resultListener = new UriResultListener();
        provider.canonicalizeAsync(mPackageName, mAttributionTag, url, new RemoteCallback(resultListener));
        resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);
        if (resultListener.exception != null) {
            throw resultListener.exception;
        }
        return resultListener.result;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    Objects.requireNonNull(url, ""url"");
    try {
        if (mWrapped != null)
            return mWrapped.canonicalize(url);
    } catch (RemoteException e) {
        return null;
    }
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        final UriResultListener resultListener = new UriResultListener();
        provider.canonicalizeAsync(mContext.getAttributionSource(), url, new RemoteCallback(resultListener));
        resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);
        if (resultListener.exception != null) {
            throw resultListener.exception;
        }
        return resultListener.result;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}",1,"/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
","/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */
",-1,"[@Override, @Nullable]","[@Override, @Nullable]",-1,-1,-1,-1,-1,-1,5,0,"The method canonicalizeAsync is called with different parameters; in the early version, it's called with mPackageName and mAttributionTag, while in the late version, it's called with mContext.getAttributionSource(). This indicates a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue since the dependent API change is internal to the method and the behavior, from the API user's perspective, should remain the same. The method still handles all exceptions identically and returns the same types of values (either null or the result of the canonicalize operation). The change in parameters is related to how the method internally obtains the attribution source but should not affect the return type or exception handling visible to the caller."
1103,"<android.speech.SpeechRecognizer: SpeechRecognizer createSpeechRecognizer(Context,ComponentName)>",30,31,"<android.speech.SpeechRecognizer: SpeechRecognizer createSpeechRecognizer(Context,ComponentName)>","<android.speech.SpeechRecognizer: SpeechRecognizer createSpeechRecognizer(Context,ComponentName)>",0,"{
    if (context == null) {
        throw new IllegalArgumentException(""Context cannot be null)"");
    }
    checkIsCalledFromMainThread();
    return new SpeechRecognizer(context, serviceComponent);
}","{
    if (context == null) {
        throw new IllegalArgumentException(""Context cannot be null"");
    }
    checkIsCalledFromMainThread();
    return new SpeechRecognizer(context, serviceComponent);
}",1,"/**
 * Factory method to create a new {@code SpeechRecognizer}. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called before dispatching any
 * command to the created {@code SpeechRecognizer}, otherwise no notifications will be
 * received.
 *
 * Use this version of the method to specify a specific service to direct this
 * {@link SpeechRecognizer} to. Normally you would not use this; use
 * {@link #createSpeechRecognizer(Context)} instead to use the system default recognition
 * service.
 *
 * @param context in which to create {@code SpeechRecognizer}
 * @param serviceComponent the {@link ComponentName} of a specific service to direct this
 * {@code SpeechRecognizer} to
 * @return a new {@code SpeechRecognizer}
 */
","/**
 * Factory method to create a new {@code SpeechRecognizer}. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called before dispatching any
 * command to the created {@code SpeechRecognizer}, otherwise no notifications will be
 * received.
 * Use this version of the method to specify a specific service to direct this
 * {@link SpeechRecognizer} to.
 *
 * <p><strong>Important</strong>: before calling this method, please check via
 * {@link android.content.pm.PackageManager#queryIntentServices(Intent, int)} that {@code
 * serviceComponent} actually exists and provides
 * {@link RecognitionService#SERVICE_INTERFACE}. Normally you would not use this; call
 * {@link #createSpeechRecognizer(Context)} to use the system default recognition
 * service instead or {@link #createOnDeviceSpeechRecognizer(Context)} to use on-device
 * recognition.</p>
 *
 * <p>For apps targeting Android 11 (API level 30) interaction with a speech recognition
 * service requires <queries> element to be added to the manifest file:
 * <pre>{@code
 * <queries>
 * <intent>
 * <action
 * android:name=""android.speech.RecognitionService"" />
 * </intent>
 * </queries>
 * }</pre>
 *
 * @param context in which to create {@code SpeechRecognizer}
 * @param serviceComponent the {@link ComponentName} of a specific service to direct this
 * {@code SpeechRecognizer} to
 * @return a new {@code SpeechRecognizer}
 */
",-1,,[@MainThread],-1,-1,-1,-1,-1,-1,0,0,There is no code difference that changes the behavior between the early and late versions of the API. The only difference is a typo fix in message string of the IllegalArgumentException which doesn't affect the execution.,No Compatibility Issue could arise from this change because the fixed typo in the exception message does not alter the method's behavior.
1106,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",30,31,"<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>","<android.app.Activity: void dumpInner(String,FileDescriptor,PrintWriter,String[])>",0,"{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mIsInMultiWindowMode="");
    writer.print(mIsInMultiWindowMode);
    writer.print("" mIsInPictureInPictureMode="");
    writer.println(mIsInPictureInPictureMode);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    if (getResources().hasOverrideDisplayAdjustments()) {
        writer.print(innerPrefix);
        writer.print(""FixedRotationAdjustments="");
        writer.println(getResources().getDisplayAdjustments().getFixedRotationAdjustments());
    }
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}","{
    if (args != null && args.length > 0) {
        // Handle special cases
        switch(args[0]) {
            case ""--autofill"":
                dumpAutofillManager(prefix, writer);
                return;
            case ""--contentcapture"":
                dumpContentCaptureManager(prefix, writer);
                return;
            case ""--translation"":
                dumpUiTranslation(prefix, writer);
                return;
        }
    }
    writer.print(prefix);
    writer.print(""Local Activity "");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println("" State:"");
    String innerPrefix = prefix + ""  "";
    writer.print(innerPrefix);
    writer.print(""mResumed="");
    writer.print(mResumed);
    writer.print("" mStopped="");
    writer.print(mStopped);
    writer.print("" mFinished="");
    writer.println(mFinished);
    writer.print(innerPrefix);
    writer.print(""mIsInMultiWindowMode="");
    writer.print(mIsInMultiWindowMode);
    writer.print("" mIsInPictureInPictureMode="");
    writer.println(mIsInPictureInPictureMode);
    writer.print(innerPrefix);
    writer.print(""mChangingConfigurations="");
    writer.println(mChangingConfigurations);
    writer.print(innerPrefix);
    writer.print(""mCurrentConfig="");
    writer.println(mCurrentConfig);
    if (getResources().hasOverrideDisplayAdjustments()) {
        writer.print(innerPrefix);
        writer.print(""FixedRotationAdjustments="");
        writer.println(getResources().getDisplayAdjustments().getFixedRotationAdjustments());
    }
    mFragments.dumpLoaders(innerPrefix, fd, writer, args);
    mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.dump(innerPrefix, fd, writer, args);
    }
    if (getWindow() != null && getWindow().peekDecorView() != null && getWindow().peekDecorView().getViewRootImpl() != null) {
        getWindow().peekDecorView().getViewRootImpl().dump(prefix, writer);
    }
    mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
    dumpAutofillManager(prefix, writer);
    dumpContentCaptureManager(prefix, writer);
    dumpUiTranslation(prefix, writer);
    ResourcesManager.getInstance().dump(prefix, writer);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The switch-case statement is modified with an additional case ""--translation"", and a new method call `dumpUiTranslation(prefix, writer)` is also added at the end of the method, but no alteration to the return value or thrown exceptions, the change type is 3,4.","There is no Compatibility Issue since the existing behavior of the method is not altered in a way that would affect previous consumers. The added case and method call do not affect the return type or exception handling of the method; they merely add new functionality that is invoked with a specific new argument and act as additional information when the specific argument is passed. The default behavior and handling of other arguments remain unchanged, meaning no CI is introduced for existing users of the method."
1107,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setSubtitle(CharSequence)>,30,31,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setSubtitle(CharSequence)>,<android.hardware.biometrics.BiometricPrompt.Builder: Builder setSubtitle(CharSequence)>,0,"{
    mBundle.putCharSequence(KEY_SUBTITLE, subtitle);
    return this;
}","{
    mPromptInfo.setSubtitle(subtitle);
    return this;
}",1,"/**
 * Optional: Sets a subtitle that will be shown on the prompt.
 * @param subtitle The subtitle to display.
 * @return This builder.
 */
","/**
 * Optional: Sets a subtitle that will be shown on the prompt.
 * @param subtitle The subtitle to display.
 * @return This builder.
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,5,0,"The implementation now calls a different method (mPromptInfo.setSubtitle(subtitle)) instead of putting the value into a bundle. This implies that the functionality of setting the subtitle has been changed, but still assigns the subtitle. The change impacts a dependent API, so the code change type is 5.","As both methods are setter methods that affect the subtitle, and there is no change in exception handling or return type (both return 'this'), a different technique is used for the same end effect. There's no indication that these changes would lead to a different API behavior regarding return values or exceptions thrown; therefore, there's no Compatibility Issue."
1108,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",30,31,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    return buildServicePendingIntent(context, requestCode, intent, flags, ActivityManager.INTENT_SENDER_SERVICE);
}","{
    return buildServicePendingIntent(context, requestCode, intent, flags, INTENT_SENDER_SERVICE);
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * <p class=""note"">For security reasons, the {@link android.content.Intent}
 * you supply here should almost always be an <em>explicit intent</em>,
 * that is specify an explicit component to be delivered to through
 * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}</p>
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * {@link #FLAG_IMMUTABLE} or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The change is simply from ActivityManager.INTENT_SENDER_SERVICE to INTENT_SENDER_SERVICE which indicates that the constant may have been moved or no longer needs the ActivityManager class qualifier due to a static import. This is a code change of type 4.,There is no Compatibility Issue because this change does not affect the behavior of the method - it still calls the same buildServicePendingIntent method with the same parameters. The change is internal to the code structure and would not be visible or impactful to the API consumer.
1109,"<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",30,31,"<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>","<android.hardware.camera2.impl.CameraOfflineSessionImpl.CameraDeviceCallbacks: void onDeviceError(int,CaptureResultExtras)>",0,"{
    synchronized (mInterfaceLock) {
        switch(errorCode) {
            case CameraDeviceCallbacks.ERROR_CAMERA_REQUEST:
            case CameraDeviceCallbacks.ERROR_CAMERA_RESULT:
            case CameraDeviceCallbacks.ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            default:
                Runnable errorDispatch = new Runnable() {

                    @Override
                    public void run() {
                        if (!isClosed()) {
                            mOfflineCallback.onError(CameraOfflineSessionImpl.this, CameraOfflineSessionCallback.STATUS_INTERNAL_ERROR);
                        }
                    }
                };
                final long ident = Binder.clearCallingIdentity();
                try {
                    mOfflineExecutor.execute(errorDispatch);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
        }
    }
}","{
    synchronized (mInterfaceLock) {
        switch(errorCode) {
            case CameraDeviceCallbacks.ERROR_CAMERA_REQUEST:
            case CameraDeviceCallbacks.ERROR_CAMERA_RESULT:
            case CameraDeviceCallbacks.ERROR_CAMERA_BUFFER:
                onCaptureErrorLocked(errorCode, resultExtras);
                break;
            default:
                {
                    Runnable errorDispatch = new Runnable() {

                        @Override
                        public void run() {
                            if (!isClosed()) {
                                mOfflineCallback.onError(CameraOfflineSessionImpl.this, CameraOfflineSessionCallback.STATUS_INTERNAL_ERROR);
                            }
                        }
                    };
                    final long ident = Binder.clearCallingIdentity();
                    try {
                        mOfflineExecutor.execute(errorDispatch);
                    } finally {
                        Binder.restoreCallingIdentity(ident);
                    }
                }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no actual code change between the early and late versions. The only difference is an added block scope `{}` which does not alter the logic or flow of the code.,"Since there are no functional changes in the code, there is no potential for a compatibility issue."
1110,<android.app.Instrumentation: UiAutomation getUiAutomation(int)>,30,31,<android.app.Instrumentation: UiAutomation getUiAutomation(int)>,<android.app.Instrumentation: UiAutomation getUiAutomation(int)>,0,"{
    boolean mustCreateNewAutomation = (mUiAutomation == null) || (mUiAutomation.isDestroyed());
    if (mUiAutomationConnection != null) {
        if (!mustCreateNewAutomation && (mUiAutomation.getFlags() == flags)) {
            return mUiAutomation;
        }
        if (mustCreateNewAutomation) {
            mUiAutomation = new UiAutomation(getTargetContext().getMainLooper(), mUiAutomationConnection);
        } else {
            mUiAutomation.disconnect();
        }
        mUiAutomation.connect(flags);
        return mUiAutomation;
    }
    return null;
}","{
    boolean mustCreateNewAutomation = (mUiAutomation == null) || (mUiAutomation.isDestroyed());
    if (mUiAutomationConnection != null) {
        if (!mustCreateNewAutomation && (mUiAutomation.getFlags() == flags)) {
            return mUiAutomation;
        }
        if (mustCreateNewAutomation) {
            mUiAutomation = new UiAutomation(getTargetContext().getMainLooper(), mUiAutomationConnection);
        } else {
            mUiAutomation.disconnect();
        }
        if (getTargetContext().getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.R) {
            mUiAutomation.connect(flags);
            return mUiAutomation;
        }
        try {
            mUiAutomation.connectWithTimeout(flags, CONNECT_TIMEOUT_MILLIS);
            return mUiAutomation;
        } catch (TimeoutException e) {
            mUiAutomation.destroy();
            mUiAutomation = null;
        }
    }
    return null;
}",1,"/**
 * Gets the {@link UiAutomation} instance with flags set.
 * <p>
 * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}
 * work across application boundaries while the APIs exposed by the instrumentation
 * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will
 * not allow you to inject the event in an app different from the instrumentation
 * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}
 * will work regardless of the current application.
 * </p>
 * <p>
 * A typical test case should be using either the {@link UiAutomation} or
 * {@link Instrumentation} APIs. Using both APIs at the same time is not
 * a mistake by itself but a client has to be aware of the APIs limitations.
 * </p>
 * <p>
 * If a {@link UiAutomation} exists with different flags, the flags on that instance will be
 * changed, and then it will be returned.
 * </p>
 *
 * @param flags The flags to be passed to the UiAutomation, for example
 * {@link UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES}.
 *
 * @return The UI automation instance.
 *
 * @see UiAutomation
 */
","/**
 * Gets the {@link UiAutomation} instance with flags set.
 * <p>
 * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}
 * work across application boundaries while the APIs exposed by the instrumentation
 * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will
 * not allow you to inject the event in an app different from the instrumentation
 * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}
 * will work regardless of the current application.
 * </p>
 * <p>
 * A typical test case should be using either the {@link UiAutomation} or
 * {@link Instrumentation} APIs. Using both APIs at the same time is not
 * a mistake by itself but a client has to be aware of the APIs limitations.
 * </p>
 * <p>
 * If a {@link UiAutomation} exists with different flags, the flags on that instance will be
 * changed, and then it will be returned.
 * </p>
 * <p>
 * Compatibility mode: This method is infallible for apps targeted for
 * {@link Build.VERSION_CODES#R} and earlier versions; for apps targeted for later versions, it
 * will return null if {@link UiAutomation} fails to connect. The caller can check the return
 * value and retry on error.
 * </p>
 *
 * @param flags The flags to be passed to the UiAutomation, for example
 * {@link UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES},
 * {@link UiAutomation#FLAG_DONT_USE_ACCESSIBILITY}.
 *
 * @return The UI automation instance.
 *
 * @see UiAutomation
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,5","1,2","An extended condition checking for targetSdkVersion is added to control whether 'connect(flags)' or 'connectWithTimeout(flags, CONNECT_TIMEOUT_MILLIS)' will be called, and a new exception handling block for TimeoutException has been introduced. Moreover, the 'mUiAutomation.connect()' method call is changed to 'mUiAutomation.connectWithTimeout()', which indicates a change in a dependent API. Hence, the changes involve exception handling statement, control dependency change, and dependent API change, leading to code change type 2,3,5.","Because of the additional control check ('if (getTargetContext().getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.R)'), applications targeting a version greater than R will now potentially encounter a TimeoutException, which was not possible in the early version. Additionally, the late version introduces 'mUiAutomation.connectWithTimeout(flags, CONNECT_TIMEOUT_MILLIS)' call which might throw a TimeoutException, not present in the early version. Thus, the API behavior changes, causing possible different return values or types, and the potential different exception handlings, leading to CI types 1 and 2."
1112,<android.net.Uri.Part: Part fromEncoded(String)>,30,31,<android.net.Uri.Part: Part fromEncoded(String)>,<android.net.Uri.Part: Part fromEncoded(String)>,0,"{
    return from(encoded, NOT_CACHED);
}","{
    return from(encoded, NotCachedHolder.NOT_CACHED);
}",1,"/**
 * Creates a part from the encoded string.
 *
 * @param encoded part string
 */
","/**
 * Creates a part from the encoded string.
 *
 * @param encoded part string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change from `NOT_CACHED` to `NotCachedHolder.NOT_CACHED` indicates a change in the way the constant is accessed, likely to have moved from a direct constant to an encapsulated constant within a holder class. This is considered an ""Other statement changed"" because it is not a change to control structure, exception handling, or method return value itself, but rather a reference to a constant. Also, this could involve access to a static field of another class which may be considered a ""Dependent API changed"", hence the change codes are 4,5.","Given that the value referred to by `NotCachedHolder.NOT_CACHED` is intended to be the same as the previously directly accessed `NOT_CACHED`, the behavior of the method should remain unchanged. Therefore, there is no compatibility issue as far as the information provided indicates, the return value should stay constant, and there are no changes to exception handling or control structures that affect this outcome. The CI type is 0."
1113,"<android.view.View: void setFlags(int,int)>",30,31,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    boolean shouldNotifyFocusableAvailable = false;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    shouldNotifyFocusableAvailable = canTakeFocus();
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // a view becoming visible is worth notifying the parent about in case nothing has
            // focus. Even if this specific view isn't focusable, it may contain something that
            // is, so let the root view try to give this focus if nothing else does.
            shouldNotifyFocusableAvailable = hasSize();
        }
    }
    if ((changed & ENABLED_MASK) != 0) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED) {
            // a view becoming enabled should notify the parent as long as the view is also
            // visible and the parent wasn't already notified by becoming visible during this
            // setFlags invocation.
            shouldNotifyFocusableAvailable = canTakeFocus();
        } else {
            if (isFocused())
                clearFocus();
        }
    }
    if (shouldNotifyFocusableAvailable && mParent != null) {
        mParent.focusableViewAvailable(this);
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ViewGroup parent = (ViewGroup) mParent;
            parent.onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            parent.invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        // a state change, so we really don't need to report other changes.
        if (isAccessibilityPane()) {
            changed &= ~VISIBILITY_MASK;
        }
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    boolean shouldNotifyFocusableAvailable = false;
    // If focusable is auto, update the FOCUSABLE bit.
    int focusableChangedByAuto = 0;
    if (((mViewFlags & FOCUSABLE_AUTO) != 0) && (changed & (FOCUSABLE_MASK | CLICKABLE)) != 0) {
        // Heuristic only takes into account whether view is clickable.
        final int newFocus;
        if ((mViewFlags & CLICKABLE) != 0) {
            newFocus = FOCUSABLE;
        } else {
            newFocus = NOT_FOCUSABLE;
        }
        mViewFlags = (mViewFlags & ~FOCUSABLE) | newFocus;
        focusableChangedByAuto = (old & FOCUSABLE) ^ (newFocus & FOCUSABLE);
        changed = (changed & ~FOCUSABLE) | focusableChangedByAuto;
    }
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
            if (mParent instanceof ViewGroup) {
                ((ViewGroup) mParent).clearFocusedInCluster();
            }
        } else if (((old & FOCUSABLE) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null) {
                ViewRootImpl viewRootImpl = getViewRootImpl();
                if (!sAutoFocusableOffUIThreadWontNotifyParents || focusableChangedByAuto == 0 || viewRootImpl == null || viewRootImpl.mThread == Thread.currentThread()) {
                    shouldNotifyFocusableAvailable = canTakeFocus();
                }
            }
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // a view becoming visible is worth notifying the parent about in case nothing has
            // focus. Even if this specific view isn't focusable, it may contain something that
            // is, so let the root view try to give this focus if nothing else does.
            shouldNotifyFocusableAvailable = hasSize();
        }
    }
    if ((changed & ENABLED_MASK) != 0) {
        if ((mViewFlags & ENABLED_MASK) == ENABLED) {
            // a view becoming enabled should notify the parent as long as the view is also
            // visible and the parent wasn't already notified by becoming visible during this
            // setFlags invocation.
            shouldNotifyFocusableAvailable = canTakeFocus();
        } else {
            if (isFocused())
                clearFocus();
        }
    }
    if (shouldNotifyFocusableAvailable && mParent != null) {
        mParent.focusableViewAvailable(this);
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus()) {
                clearFocus();
                if (mParent instanceof ViewGroup) {
                    ((ViewGroup) mParent).clearFocusedInCluster();
                }
            }
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus()) {
                    clearFocus();
                    if (mParent instanceof ViewGroup) {
                        ((ViewGroup) mParent).clearFocusedInCluster();
                    }
                }
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE && mAttachInfo != null) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ViewGroup parent = (ViewGroup) mParent;
            parent.onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            parent.invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        if (mAttachInfo != null) {
            dispatchVisibilityChanged(this, newVisibility);
            // to change animation states.
            if (mParent != null && getWindowVisibility() == VISIBLE && ((!(mParent instanceof ViewGroup)) || ((ViewGroup) mParent).isShown())) {
                dispatchVisibilityAggregated(newVisibility == VISIBLE);
            }
            // parent which is shown and has the accessibility important.
            if ((old & VISIBILITY_MASK) == VISIBLE) {
                notifySubtreeAccessibilityStateChangedByParentIfNeeded();
            } else {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            }
        }
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null || mDefaultFocusHighlight != null || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        // a state change, so we really don't need to report other changes.
        if (isAccessibilityPane()) {
            changed &= ~VISIBILITY_MASK;
        }
        if ((changed & FOCUSABLE) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & CONTEXT_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,"[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)]","[@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)]",-1,-1,-1,-1,-1,-1,,,,
1115,<android.view.autofill.AutofillValue: int getListValue()>,30,31,<android.view.autofill.AutofillValue: int getListValue()>,<android.view.autofill.AutofillValue: int getListValue()>,0,"{
    Preconditions.checkState(isList(), ""value must be a list value, not type="" + mType);
    return (Integer) mValue;
}","{
    Preconditions.checkState(isList(), ""value must be a list value, not type=%d"", mType);
    return (Integer) mValue;
}",1,"/**
 * Gets the value to autofill a selection list field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_LIST} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a list value
 */
","/**
 * Gets the value to autofill a selection list field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_LIST} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a list value
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"The implementation has not changed in terms of logic or functionality, only the error message format in the exception has been modified (from concatenation to a formatted string), so there's no code change that affects behavior.","There is no Compatibility Issue because the logic and return value of the method are unaffected by this change. This is strictly a change in how the exception message is constructed, which does not affect the API contract."
1116,<android.speech.SpeechRecognizer: boolean isRecognitionAvailable(Context)>,30,31,<android.speech.SpeechRecognizer: boolean isRecognitionAvailable(Context)>,<android.speech.SpeechRecognizer: boolean isRecognitionAvailable(Context)>,0,"{
    final List<ResolveInfo> list = context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE), 0);
    return list != null && list.size() != 0;
}","{
    // TODO(b/176578753): make sure this works well with system speech recognizers.
    final List<ResolveInfo> list = context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE), 0);
    return list != null && list.size() != 0;
}",1,"/**
 * Checks whether a speech recognition service is available on the system. If this method
 * returns {@code false}, {@link SpeechRecognizer#createSpeechRecognizer(Context)} will
 * fail.
 *
 * @param context with which {@code SpeechRecognizer} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
","/**
 * Checks whether a speech recognition service is available on the system. If this method
 * returns {@code false}, {@link SpeechRecognizer#createSpeechRecognizer(Context)} will
 * fail.
 *
 * @param context with which {@code SpeechRecognizer} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in the actual code; the TODO comment doesn't affect the behaviour or output of the method, so there is no change in terms of functionality.","Since there has been no change in the code that affects the behavior or output, there is no compatibility issue."
1117,<android.hardware.biometrics.BiometricPrompt: boolean isConfirmationRequired()>,30,31,<android.hardware.biometrics.BiometricPrompt: boolean isConfirmationRequired()>,<android.hardware.biometrics.BiometricPrompt: boolean isConfirmationRequired()>,0,"{
    return mBundle.getBoolean(KEY_REQUIRE_CONFIRMATION, true);
}","{
    return mPromptInfo.isConfirmationRequested();
}",1,"/**
 * Determines if explicit user confirmation is required by the prompt, as set by
 * {@link Builder#setConfirmationRequired(boolean)}.
 *
 * @return true if explicit user confirmation is required, or false otherwise.
 */
","/**
 * Determines if explicit user confirmation is required by the prompt, as set by
 * {@link Builder#setConfirmationRequired(boolean)}.
 *
 * @return true if explicit user confirmation is required, or false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The implementation of the method has changed to call a different method 'mPromptInfo.isConfirmationRequested()' instead of 'mBundle.getBoolean(KEY_REQUIRE_CONFIRMATION, true)', which indicates that this code change is a Dependent API change; therefore, the code change type is 5.","Despite the change in the implementation, there is no indication of a change in the behavior that leads to a different output or requires different handling of exceptions. The method still returns a boolean indicating whether confirmation is required or not, and there is no alteration in the return statement that affects return type or value, nor is there any new exception handling introduced. Hence, there's no Compatibility Issue detected; therefore, the CI type is 0."
1118,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,30,31,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,<android.accessibilityservice.AccessibilityService: AccessibilityNodeInfo findFocus(int)>,0,"{
    return AccessibilityInteractionClient.getInstance().findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}","{
    return AccessibilityInteractionClient.getInstance(this).findFocus(mConnectionId, AccessibilityWindowInfo.ANY_WINDOW_ID, AccessibilityNodeInfo.ROOT_NODE_ID, focus);
}",1,"/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag. Otherwise, the search will be performed only in the active window.
 * </p>
 * <p>
 * <strong>Note:</strong> If the view with {@link AccessibilityNodeInfo#FOCUS_INPUT}
 * is on an embedded view hierarchy which is embedded in a {@link SurfaceView} via
 * {@link SurfaceView#setChildSurfacePackage}, there is a limitation that this API
 * won't be able to find the node for the view. It's because views don't know about
 * the embedded hierarchies. Instead, you could traverse all the nodes to find the
 * focus.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
","/**
 * Find the view that has the specified focus type. The search is performed
 * across all windows.
 * <p>
 * <strong>Note:</strong> In order to access the windows your service has
 * to declare the capability to retrieve window content by setting the
 * {@link android.R.styleable#AccessibilityService_canRetrieveWindowContent}
 * property in its meta-data. For details refer to {@link #SERVICE_META_DATA}.
 * Also the service has to opt-in to retrieve the interactive windows by
 * setting the {@link AccessibilityServiceInfo#FLAG_RETRIEVE_INTERACTIVE_WINDOWS}
 * flag. Otherwise, the search will be performed only in the active window.
 * </p>
 * <p>
 * <strong>Note:</strong> If the view with {@link AccessibilityNodeInfo#FOCUS_INPUT}
 * is on an embedded view hierarchy which is embedded in a {@link SurfaceView} via
 * {@link SurfaceView#setChildSurfacePackage}, there is a limitation that this API
 * won't be able to find the node for the view. It's because views don't know about
 * the embedded hierarchies. Instead, you could traverse all the nodes to find the
 * focus.
 * </p>
 *
 * @param focus The focus to find. One of {@link AccessibilityNodeInfo#FOCUS_INPUT} or
 * {@link AccessibilityNodeInfo#FOCUS_ACCESSIBILITY}.
 * @return The node info of the focused view or null.
 *
 * @see AccessibilityNodeInfo#FOCUS_INPUT
 * @see AccessibilityNodeInfo#FOCUS_ACCESSIBILITY
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"An additional argument 'this' has been added to the method call 'AccessibilityInteractionClient.getInstance()', so code change type is 4 for the change in method argument and 5 because it's related to a dependent API changed.","There is no difference in exception handling or return statement that will lead to a Compatibility Issue. However, the additional 'this' argument does not change the contract of the 'findFocus' method nor its intended return type; it might simply pass the current service instance for context or similar purposes within the 'getInstance' method, thus the Compatibility Issue is 0."
1119,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,30,31,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,<android.content.pm.ShortcutManager: List<ShortcutInfo> getManifestShortcuts()>,0,"{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}","{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}",1,"/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
","/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */
",-1,[@NonNull],"[@WorkerThread, @NonNull]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API, specifically the method called in the try block, has changed from `mService.getShortcuts(...)` to `getFutureOrThrow(mService.getShortcuts(...))`. This indicates that there has been a change in the function being used to retrieve shortcuts. The modification appears to be in wrapping the original service call with another method (`getFutureOrThrow`). Therefore, the change type is 5 (Dependent API changed).","Despite the change in the dependent API, it does not inherently indicate a behavior change that would cause a compatibility issue with existing client code, assuming `getFutureOrThrow` ultimately provides the same list of shortcuts that `mService.getShortcuts` would. Based on the information provided, we have no evidence that the method's contract has changed; it could simply be an internal change to how the data is fetched, without affecting the returned data or how it handles exceptions. The original and updated code both throw the unchecked `RemoteException` wrapped as a system server exception. Therefore, the CI situation is 0 (No Compatibility Issue)."
1120,<android.hardware.biometrics.BiometricPrompt: CharSequence getNegativeButtonText()>,30,31,<android.hardware.biometrics.BiometricPrompt: CharSequence getNegativeButtonText()>,<android.hardware.biometrics.BiometricPrompt: CharSequence getNegativeButtonText()>,0,"{
    return mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
}","{
    return mPromptInfo.getNegativeButtonText();
}",1,"/**
 * Gets the negative button text for the prompt, as set by
 * {@link Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 * @return The negative button text for the prompt, or null if no negative button text was set.
 */
","/**
 * Gets the negative button text for the prompt, as set by
 * {@link Builder#setNegativeButton(CharSequence, Executor, DialogInterface.OnClickListener)}.
 * @return The negative button text for the prompt, or null if no negative button text was set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,5,0,"The implementation has changed from accessing a value from a Bundle (mBundle.getCharSequence(KEY_NEGATIVE_TEXT)) to calling a method on another object (mPromptInfo.getNegativeButtonText()), which suggests that the dependent API has changed. Therefore, the code change type is 5.","Despite the change in the underlying implementation, since both methods return a CharSequence and the annotation [@Nullable] has not changed, it is assumed that the behavior of the method in terms of what it returns remains consistent with the previous implementation. Consequently, this should not pose a Compatibility Issue, and the CI type is 0."
1121,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,30,31,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,<android.hardware.camera2.params.StreamConfigurationMap: int imageFormatToDataspace(int)>,0,"{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        case ImageFormat.DEPTH_JPEG:
            return HAL_DATASPACE_DYNAMIC_DEPTH;
        case ImageFormat.HEIC:
            return HAL_DATASPACE_HEIF;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}","{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_DEPTH10:
            return HAL_DATASPACE_DEPTH;
        case ImageFormat.DEPTH_JPEG:
            return HAL_DATASPACE_DYNAMIC_DEPTH;
        case ImageFormat.HEIC:
            return HAL_DATASPACE_HEIF;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}",1,"/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH_JPEG => HAL_DATASPACE_DYNAMIC_DEPTH
 * <li>ImageFormat.HEIC => HAL_DATASPACE_HEIF
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
","/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH_JPEG => HAL_DATASPACE_DYNAMIC_DEPTH
 * <li>ImageFormat.HEIC => HAL_DATASPACE_HEIF
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The switch case blocks have been modified with the introduction of a new case (ImageFormat.RAW_DEPTH10) which now returns HAL_DATASPACE_DEPTH, and this is a code change type 3. Additionally, the return value for that specific image format has been defined, which is a change in the code that determines the output based on the input parameter, thus change type 5.","With the introduction of a new case (ImageFormat.RAW_DEPTH10), there is now a potential return of a different value (HAL_DATASPACE_DEPTH) for inputs that would have previously defaulted to HAL_DATASPACE_UNKNOWN, indicating a CI type 1 due to the potential different return values."
1122,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,30,31,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,<com.android.server.backup.AccountSyncSettingsBackupHelper: void restoreEntity(BackupDataInputStream)>,0,"{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomaticallyAsUser(mUserId);
        if (currentMasterSyncEnabled) {
            // Disable master sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomaticallyAsUser(false, mUserId);
        }
        try {
            restoreFromJsonArray(accountJSONArray, mUserId);
        } finally {
            // Set the master sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomaticallyAsUser(masterSyncEnabled, mUserId);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}","{
    byte[] dataBytes = new byte[data.size()];
    try {
        // Read the data and convert it to a String.
        data.read(dataBytes);
        String dataString = new String(dataBytes, JSON_FORMAT_ENCODING);
        // Convert data to a JSON object.
        JSONObject dataJSON = new JSONObject(dataString);
        boolean masterSyncEnabled = dataJSON.getBoolean(KEY_MASTER_SYNC_ENABLED);
        JSONArray accountJSONArray = dataJSON.getJSONArray(KEY_ACCOUNTS);
        boolean currentMasterSyncEnabled = ContentResolver.getMasterSyncAutomaticallyAsUser(mUserId);
        if (currentMasterSyncEnabled) {
            // Disable global sync to prevent any syncs from running.
            ContentResolver.setMasterSyncAutomaticallyAsUser(false, mUserId);
        }
        try {
            restoreFromJsonArray(accountJSONArray, mUserId);
        } finally {
            // Set the global sync preference to the value from the backup set.
            ContentResolver.setMasterSyncAutomaticallyAsUser(masterSyncEnabled, mUserId);
        }
        Log.i(TAG, ""Restore successful."");
    } catch (IOException | JSONException e) {
        Log.e(TAG, ""Couldn't restore account sync settings\n"" + e);
    }
}",1,"/**
 * Restore account sync settings from the given data input stream.
 */
","/**
 * Restore account sync settings from the given data input stream.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The implementations are identical in functionality, with only a comment being changed, so there is no code change that affects behavior.",There is no compatibility issue since there are no changes in the actual code execution paths or logic.
1123,<android.net.Ikev2VpnProfile.Builder: Builder setMaxMtu(int)>,30,31,<android.net.Ikev2VpnProfile.Builder: Builder setMaxMtu(int)>,<android.net.Ikev2VpnProfile.Builder: Builder setMaxMtu(int)>,0,"{
    // (at least that of the IPv6 MTU).
    if (mtu < LinkProperties.MIN_MTU_V6) {
        throw new IllegalArgumentException(""Max MTU must be at least "" + LinkProperties.MIN_MTU_V6);
    }
    mMaxMtu = mtu;
    return this;
}","{
    // (at least that of the IPv6 MTU).
    if (mtu < IPV6_MIN_MTU) {
        throw new IllegalArgumentException(""Max MTU must be at least "" + IPV6_MIN_MTU);
    }
    mMaxMtu = mtu;
    return this;
}",1,"/**
 * Set the upper bound of the maximum transmission unit (MTU) of the VPN interface.
 *
 * <p>If it is not set, a safe value will be used. Additionally, the actual link MTU will be
 * dynamically calculated/updated based on the underlying link's mtu.
 *
 * @param mtu the MTU (in bytes) of the VPN interface
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if the value is not at least the minimum IPv6 MTU (1280)
 */
","/**
 * Set the upper bound of the maximum transmission unit (MTU) of the VPN interface.
 *
 * <p>If it is not set, a safe value will be used. Additionally, the actual link MTU will be
 * dynamically calculated/updated based on the underlying link's mtu.
 *
 * @param mtu the MTU (in bytes) of the VPN interface
 * @return this {@link Builder} object to facilitate chaining of method calls
 * @throws IllegalArgumentException if the value is not at least the minimum IPv6 MTU (1280)
 */
",-1,"[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]","[@NonNull, @RequiresFeature(PackageManager.FEATURE_IPSEC_TUNNELS)]",-1,-1,-1,-1,-1,-1,"4,5",0,"The constant used to check the minimum MTU value has changed from LinkProperties.MIN_MTU_V6 to IPV6_MIN_MTU. This change is related to an internal constant and not to the method signature, parameters, or need to be handled differently, so the change type is 4. Additionally, the dependency on a constant outside of this method's body constitutes a change type of 5.","Despite the change of the constant value, as long as IPV6_MIN_MTU has the same value as LinkProperties.MIN_MTU_V6, then the behavior of the method does not change. The method throws the same exception for invalid input, and if the input is valid, it sets the same field and returns the same object. Therefore, there's no Compatibility Issue in terms of the method's behavior."
1124,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,30,31,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,0,"{
    if (DEBUG)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, ""Method"");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, ""Sample"");
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (DEBUG)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, ""Method"");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, ""Sample"");
    } else {
        throw new RuntimeException(""Unknown packet "" + name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change between the early and late versions of the implementation. The code is identical in both versions.,"Since there is no change in the code, there are no Compatibility Issues between these two versions."
1125,"<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews,InlinePresentation)>",30,31,"<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews,InlinePresentation)>","<android.service.autofill.FillResponse.Builder: Builder setAuthentication(AutofillId[],IntentSender,RemoteViews,InlinePresentation)>",0,"{
    throwIfDestroyed();
    throwIfDisableAutofillCalled();
    if (mHeader != null || mFooter != null) {
        throw new IllegalStateException(""Already called #setHeader() or #setFooter()"");
    }
    if (authentication == null ^ (presentation == null && inlinePresentation == null)) {
        throw new IllegalArgumentException(""authentication and presentation "" + ""(dropdown or inline), must be both non-null or null"");
    }
    mAuthentication = authentication;
    mPresentation = presentation;
    mInlinePresentation = inlinePresentation;
    mAuthenticationIds = assertValid(ids);
    return this;
}","{
    return setAuthentication(ids, authentication, presentation, inlinePresentation, null);
}",1,"/**
 * Triggers a custom UI before before autofilling the screen with any data set in this
 * response.
 *
 * <p><b>Note:</b> Although the name of this method suggests that it should be used just for
 * authentication flow, it can be used for other advanced flows; see {@link AutofillService}
 * for examples.
 *
 * <p>This method is similar to
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)}, but also accepts
 * an {@link InlinePresentation} presentation which is required for authenticating through
 * the inline autofill flow.
 *
 * <p><b>Note:</b> {@link #setHeader(RemoteViews)} or {@link #setFooter(RemoteViews)} does
 * not work with {@link InlinePresentation}.</p>
 *
 * @param authentication Intent to an activity with your authentication flow.
 * @param presentation The presentation to visualize the response.
 * @param inlinePresentation The inlinePresentation to visualize the response inline.
 * @param ids id of Views that when focused will display the authentication UI.
 *
 * @return This builder.
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code ids} is {@code null}</li>
 * <li>{@code ids} is empty</li>
 * <li>{@code ids} contains a {@code null} element</li>
 * <li>both {@code authentication} and {@code presentation} are {@code null}</li>
 * <li>both {@code authentication} and {@code presentation} are non-{@code null}</li>
 * <li>both {@code authentication} and {@code inlinePresentation} are {@code null}</li>
 * <li>both {@code authentication} and {@code inlinePresentation} are
 * non-{@code null}</li>
 * </ul>
 *
 * @throws IllegalStateException if a {@link #setHeader(RemoteViews) header} or a
 * {@link #setFooter(RemoteViews) footer} are already set for this builder.
 *
 * @see android.app.PendingIntent#getIntentSender()
 */
","/**
 * Triggers a custom UI before before autofilling the screen with any data set in this
 * response.
 *
 * <p><b>Note:</b> Although the name of this method suggests that it should be used just for
 * authentication flow, it can be used for other advanced flows; see {@link AutofillService}
 * for examples.
 *
 * <p>This method is similar to
 * {@link #setAuthentication(AutofillId[], IntentSender, RemoteViews)}, but also accepts
 * an {@link InlinePresentation} presentation which is required for authenticating through
 * the inline autofill flow.
 *
 * <p><b>Note:</b> {@link #setHeader(RemoteViews)} or {@link #setFooter(RemoteViews)} does
 * not work with {@link InlinePresentation}.</p>
 *
 * @param authentication Intent to an activity with your authentication flow.
 * @param presentation The presentation to visualize the response.
 * @param inlinePresentation The inlinePresentation to visualize the response inline.
 * @param ids id of Views that when focused will display the authentication UI.
 *
 * @return This builder.
 *
 * @throws IllegalArgumentException if any of the following occurs:
 * <ul>
 * <li>{@code ids} is {@code null}</li>
 * <li>{@code ids} is empty</li>
 * <li>{@code ids} contains a {@code null} element</li>
 * <li>both {@code authentication} and {@code presentation} are {@code null}</li>
 * <li>both {@code authentication} and {@code presentation} are non-{@code null}</li>
 * <li>both {@code authentication} and {@code inlinePresentation} are {@code null}</li>
 * <li>both {@code authentication} and {@code inlinePresentation} are
 * non-{@code null}</li>
 * </ul>
 *
 * @throws IllegalStateException if a {@link #setHeader(RemoteViews) header} or a
 * {@link #setFooter(RemoteViews) footer} are already set for this builder.
 *
 * @see android.app.PendingIntent#getIntentSender()
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,5",1,"The late implementation of the method redirects the call to another overload of the setAuthentication method, passing an additional null argument. Therefore, this change falls under both Return statement changed (1) and Dependent API changed (5).",The change could potentially cause a Compatibility Issue by returning a different value or type for various reasons:
1126,<android.app.ContextImpl: Display getDisplay()>,30,31,<android.app.ContextImpl: Display getDisplay()>,<android.app.ContextImpl: Display getDisplay()>,0,"{
    if (!mIsSystemOrSystemUiContext && !mIsAssociatedWithDisplay) {
        throw new UnsupportedOperationException(""Tried to obtain display from a Context not "" + ""associated with  one. Only visual Contexts (such as Activity or one created "" + ""with Context#createWindowContext) or ones created with "" + ""Context#createDisplayContext are associated with displays. Other types of "" + ""Contexts are typically related to background entities and may return an "" + ""arbitrary display."");
    }
    return getDisplayNoVerify();
}","{
    if (!isAssociatedWithDisplay()) {
        throw new UnsupportedOperationException(""Tried to obtain display from a Context not "" + ""associated with one. Only visual Contexts (such as Activity or one created "" + ""with Context#createWindowContext) or ones created with "" + ""Context#createDisplayContext are associated with displays. Other types of "" + ""Contexts are typically related to background entities and may return an "" + ""arbitrary display."");
    }
    return getDisplayNoVerify();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",0,"The condition in the if statement has changed from directly checking the variables to calling a new method isAssociatedWithDisplay(). Additionally, a dependent API, which is isAssociatedWithDisplay(), seems to have been introduced, which implies a change in the method that is being called to check the association with the display. Hence, the changes fall into categories 3 and 5.","Despite the internal changes, the behavior of the API remains the same in terms of potential outcomes. It still throws the same exception under the same conceptual condition (context not associated with a display) and returns the result of getDisplayNoVerify(). Therefore, there is no Compatibility Issue in this change."
1127,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>",30,31,"<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>","<android.app.ContextImpl: ContextImpl createAppContext(ActivityThread,LoadedApk,String)>",0,"{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mIsSystemOrSystemUiContext = isSystemOrSystemUI(context);
    return context;
}","{
    if (packageInfo == null)
        throw new IllegalArgumentException(""packageInfo"");
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName);
    context.setResources(packageInfo.getResources());
    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI : CONTEXT_TYPE_NON_UI;
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The construction of ContextImpl has more parameters in the late version, a constant `ContextParams.EMPTY` is introduced, and there is an addition of a ternary assignment to `context.mContextType` instead of setting `context.mIsSystemOrSystemUiContext`. Additionally, there is a change in the number of nulls passed to the constructor as parameters, making the change type 1,3,4,5.","Because the constructor of ContextImpl has changed by including an additional parameter of ContextParams and modification of context properties after creation (`mContextType` replacing `mIsSystemOrSystemUiContext`), it means that `createAppContext` may return a context with different configurations and different properties set, which could lead to a different behavior. Thus the CI type is 1."
1128,<android.os.PatternMatcher: String toString()>,30,31,<android.os.PatternMatcher: String toString()>,<android.os.PatternMatcher: String toString()>,0,"{
    String type = ""? "";
    switch(mType) {
        case PATTERN_LITERAL:
            type = ""LITERAL: "";
            break;
        case PATTERN_PREFIX:
            type = ""PREFIX: "";
            break;
        case PATTERN_SIMPLE_GLOB:
            type = ""GLOB: "";
            break;
        case PATTERN_ADVANCED_GLOB:
            type = ""ADVANCED: "";
            break;
    }
    return ""PatternMatcher{"" + type + mPattern + ""}"";
}","{
    String type = ""? "";
    switch(mType) {
        case PATTERN_LITERAL:
            type = ""LITERAL: "";
            break;
        case PATTERN_PREFIX:
            type = ""PREFIX: "";
            break;
        case PATTERN_SIMPLE_GLOB:
            type = ""GLOB: "";
            break;
        case PATTERN_ADVANCED_GLOB:
            type = ""ADVANCED: "";
            break;
        case PATTERN_SUFFIX:
            type = ""SUFFIX: "";
            break;
    }
    return ""PatternMatcher{"" + type + mPattern + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change involves adding a new case statement (PATTERN_SUFFIX) to the switch statement that sets the 'type' variable, so the change types are 3 and 4.","The change does not lead to any Compatibility Issues because it is just extending the switch statement to handle an additional case. The method's behavior and the returned value remain consistent for the existing cases (PATTERN_LITERAL, PATTERN_PREFIX, PATTERN_SIMPLE_GLOB, PATTERN_ADVANCED_GLOB). The introduction of a new case (PATTERN_SUFFIX) would not affect existing users of the API but simply provide a proper string representation for the new pattern type if it is used. Thus, no CI is detected."
1129,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,30,31,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,<android.view.inputmethod.InputMethodManager: boolean isAcceptingText()>,0,"{
    checkFocus();
    return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.getInputConnection() != null;
}","{
    checkFocus();
    synchronized (mH) {
        return mServedInputConnectionWrapper != null && mServedInputConnectionWrapper.getInputConnection() != null;
    }
}",1,"/**
 * Return true if the currently served view is accepting full text edits.
 * If false, it has no input connection, so can only handle raw key events.
 */
","/**
 * Return {@code true} if the currently served view is accepting full text edits.
 * If {@code false}, it has no input connection, so it can only handle raw key events.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The addition of the synchronized block is the only change in the code, it does not change the return value or the exceptions thrown, only the way the existing code is executed in a multithreaded environment. This is a control dependency change, thus the change type is 3.","Although a synchronization block has been added to the late version of the implementation, this does not affect the output of the method nor does it introduce the possibility of new exceptions. The behavior when the function is called remains consistent in terms of the return value and exception handling, so there is no compatibility issue; hence, the CI type is 0."
1130,<android.bluetooth.le.AdvertiseData.Builder: AdvertiseData build()>,30,31,<android.bluetooth.le.AdvertiseData.Builder: AdvertiseData build()>,<android.bluetooth.le.AdvertiseData.Builder: AdvertiseData build()>,0,"{
    return new AdvertiseData(mServiceUuids, mManufacturerSpecificData, mServiceData, mIncludeTxPowerLevel, mIncludeDeviceName);
}","{
    return new AdvertiseData(mServiceUuids, mServiceSolicitationUuids, mManufacturerSpecificData, mServiceData, mIncludeTxPowerLevel, mIncludeDeviceName);
}",1,"/**
 * Build the {@link AdvertiseData}.
 */
","/**
 * Build the {@link AdvertiseData}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor for AdvertiseData in the return statement has been changed by adding an additional parameter (mServiceSolicitationUuids), which also implies a change in the dependent API being used (constructor of AdvertiseData class), so the code change type is 1,5.","The change in the constructor call means that a different AdvertiseData object will be returned, which includes an extra piece of data (service solicitation UUIDs). This is a change that could lead to different return values, and therefore it's a Compatibility Issue of type 1."
1131,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,30,31,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,<android.view.inputmethod.InputMethodManager: void viewClicked(View)>,0,"{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.viewClicked(view);
        return;
    }
    final View servedView;
    final View nextServedView;
    synchronized (mH) {
        servedView = getServedViewLocked();
        nextServedView = getNextServedViewLocked();
    }
    final boolean focusChanged = servedView != nextServedView;
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        try {
            if (DEBUG)
                Log.v(TAG, ""onViewClicked: "" + focusChanged);
            mCurMethod.viewClicked(focusChanged);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    // Re-dispatch if there is a context mismatch.
    final InputMethodManager fallbackImm = getFallbackInputMethodManagerIfNecessary(view);
    if (fallbackImm != null) {
        fallbackImm.viewClicked(view);
        return;
    }
    final View servedView;
    final View nextServedView;
    synchronized (mH) {
        servedView = getServedViewLocked();
        nextServedView = getNextServedViewLocked();
    }
    final boolean focusChanged = servedView != nextServedView;
    checkFocus();
    synchronized (mH) {
        if (!hasServedByInputMethodLocked(view) || mCurrentTextBoxAttribute == null || mCurrentInputMethodSession == null) {
            return;
        }
        if (DEBUG)
            Log.v(TAG, ""onViewClicked: "" + focusChanged);
        mCurrentInputMethodSession.viewClicked(focusChanged);
    }
}",1,"/**
 * Notify the event when the user tapped or clicked the text view.
 *
 * @param view {@link View} which is being clicked.
 * @see InputMethodService#onViewClicked(boolean)
 * @deprecated The semantics of this method can never be defined well for composite {@link View}
 * that works as a giant ""Canvas"", which can host its own UI hierarchy and sub focus
 * state. {@link android.webkit.WebView} is a good example. Application / IME
 * developers should not rely on this method.
 */
","/**
 * Notify the event when the user tapped or clicked the text view.
 *
 * @param view {@link View} which is being clicked.
 * @see InputMethodService#onViewClicked(boolean)
 * @deprecated The semantics of this method can never be defined well for composite {@link View}
 * that works as a giant ""Canvas"", which can host its own UI hierarchy and sub focus
 * state. {@link android.webkit.WebView} is a good example. Application / IME
 * developers should not rely on this method.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method within the synchronized block has been updated from 'mCurMethod.viewClicked(focusChanged)' to 'mCurrentInputMethodSession.viewClicked(focusChanged)' and the condition checking 'mCurMethod == null' is changed to 'mCurrentInputMethodSession == null'. Also, the DEBUG logging statement has been moved outside of the 'try' block which no longer exists in the late version.",
