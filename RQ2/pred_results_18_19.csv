Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
2,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",18,19,"<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>","<android.view.GLES20Canvas: boolean quickReject(Path,EdgeType)>",0,"{
    path.computeBounds(mPathBounds, true);
    return nQuickReject(mRenderer, mPathBounds.left, mPathBounds.top, mPathBounds.right, mPathBounds.bottom);
}","{
    RectF pathBounds = getPathBounds();
    path.computeBounds(pathBounds, true);
    return nQuickReject(mRenderer, pathBounds.left, pathBounds.top, pathBounds.right, pathBounds.bottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The way that 'mPathBounds' is retrieved has been changed, but the return statement doesn't change, so the code change type is 4.","The changes in the code don't affect the behaviour of the API; 'mPathBounds' is replaced with 'getPathBounds()', but they get the same result. Therefore, no CI exists, and the CI type is 0."
3,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,18,19,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += event.getX(i);
        sumY += event.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    if (!mInProgress && span >= mMinSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}",1,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
","/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,The code added new condition 'mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS' and some related statements. It also introduced a new call 'mGestureDetector.onTouchEvent(event)'. The control dependency (3) has changed with the introduction of additional control flow about mDoubleTabMode and a new 'Other' type of statement  (4) has been introduced.,"The new condition and the new call to 'mGestureDetector.onTouchEvent(event)' can possibly change the result that the method returns. As a consequence, the type of CI is 1 as value of return could potentially be different."
4,"<android.app.ActivityManagerProxy: boolean clearApplicationUserData(String,IPackageDataObserver,int)>",18,19,"<android.app.ActivityManagerProxy: boolean clearApplicationUserData(String,IPackageDataObserver,int)>","<android.app.ActivityManagerProxy: boolean clearApplicationUserData(String,IPackageDataObserver,int)>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(packageName);
    data.writeStrongBinder(observer.asBinder());
    data.writeInt(userId);
    mRemote.transact(CLEAR_APP_DATA_TRANSACTION, data, reply, 0);
    reply.readException();
    boolean res = reply.readInt() != 0;
    data.recycle();
    reply.recycle();
    return res;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeString(packageName);
    data.writeStrongBinder((observer != null) ? observer.asBinder() : null);
    data.writeInt(userId);
    mRemote.transact(CLEAR_APP_DATA_TRANSACTION, data, reply, 0);
    reply.readException();
    boolean res = reply.readInt() != 0;
    data.recycle();
    reply.recycle();
    return res;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The statement 'data.writeStrongBinder(observer.asBinder());' has been changed to 'data.writeStrongBinder((observer != null) ? observer.asBinder() : null);', so the classification of change is 3 (Control dependency changed).","The return value is influenced by the behavior of observer. Given that the 'data.writeStrongBinder((observer != null) ? observer.asBinder() : null);' now includes a null check on observer, it could possibly change the subsequent behaviour of the method and finally influence the return value. Thus, a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types) is detected."
6,<android.net.VpnService.Builder: ParcelFileDescriptor establish()>,18,19,<android.net.VpnService.Builder: ParcelFileDescriptor establish()>,<android.net.VpnService.Builder: ParcelFileDescriptor establish()>,0,"{
    mConfig.addresses = mAddresses.toString();
    mConfig.routes = mRoutes.toString();
    try {
        return getService().establishVpn(mConfig);
    } catch (RemoteException e) {
        throw new IllegalStateException(e);
    }
}","{
    mConfig.addresses = mAddresses;
    mConfig.routes = mRoutes;
    try {
        return getService().establishVpn(mConfig);
    } catch (RemoteException e) {
        throw new IllegalStateException(e);
    }
}",1,"/**
 * Create a VPN interface using the parameters supplied to this
 * builder. The interface works on IP packets, and a file descriptor
 * is returned for the application to access them. Each read
 * retrieves an outgoing packet which was routed to the interface.
 * Each write injects an incoming packet just like it was received
 * from the interface. The file descriptor is put into non-blocking
 * mode by default to avoid blocking Java threads. To use the file
 * descriptor completely in native space, see
 * {@link ParcelFileDescriptor#detachFd()}. The application MUST
 * close the file descriptor when the VPN connection is terminated.
 * The VPN interface will be removed and the network will be
 * restored by the system automatically.
 *
 * <p>To avoid conflicts, there can be only one active VPN interface
 * at the same time. Usually network parameters are never changed
 * during the lifetime of a VPN connection. It is also common for an
 * application to create a new file descriptor after closing the
 * previous one. However, it is rare but not impossible to have two
 * interfaces while performing a seamless handover. In this case, the
 * old interface will be deactivated when the new one is created
 * successfully. Both file descriptors are valid but now outgoing
 * packets will be routed to the new interface. Therefore, after
 * draining the old file descriptor, the application MUST close it
 * and start using the new file descriptor. If the new interface
 * cannot be created, the existing interface and its file descriptor
 * remain untouched.
 *
 * <p>An exception will be thrown if the interface cannot be created
 * for any reason. However, this method returns {@code null} if the
 * application is not prepared or is revoked. This helps solve
 * possible race conditions between other VPN applications.
 *
 * @return {@link ParcelFileDescriptor} of the VPN interface, or
 * {@code null} if the application is not prepared.
 * @throws IllegalArgumentException if a parameter is not accepted
 * by the operating system.
 * @throws IllegalStateException if a parameter cannot be applied
 * by the operating system.
 * @throws SecurityException if the service is not properly declared
 * in {@code AndroidManifest.xml}.
 * @see VpnService
 */
","/**
 * Create a VPN interface using the parameters supplied to this
 * builder. The interface works on IP packets, and a file descriptor
 * is returned for the application to access them. Each read
 * retrieves an outgoing packet which was routed to the interface.
 * Each write injects an incoming packet just like it was received
 * from the interface. The file descriptor is put into non-blocking
 * mode by default to avoid blocking Java threads. To use the file
 * descriptor completely in native space, see
 * {@link ParcelFileDescriptor#detachFd()}. The application MUST
 * close the file descriptor when the VPN connection is terminated.
 * The VPN interface will be removed and the network will be
 * restored by the system automatically.
 *
 * <p>To avoid conflicts, there can be only one active VPN interface
 * at the same time. Usually network parameters are never changed
 * during the lifetime of a VPN connection. It is also common for an
 * application to create a new file descriptor after closing the
 * previous one. However, it is rare but not impossible to have two
 * interfaces while performing a seamless handover. In this case, the
 * old interface will be deactivated when the new one is created
 * successfully. Both file descriptors are valid but now outgoing
 * packets will be routed to the new interface. Therefore, after
 * draining the old file descriptor, the application MUST close it
 * and start using the new file descriptor. If the new interface
 * cannot be created, the existing interface and its file descriptor
 * remain untouched.
 *
 * <p>An exception will be thrown if the interface cannot be created
 * for any reason. However, this method returns {@code null} if the
 * application is not prepared or is revoked. This helps solve
 * possible race conditions between other VPN applications.
 *
 * @return {@link ParcelFileDescriptor} of the VPN interface, or
 * {@code null} if the application is not prepared.
 * @throws IllegalArgumentException if a parameter is not accepted
 * by the operating system.
 * @throws IllegalStateException if a parameter cannot be applied
 * by the operating system.
 * @throws SecurityException if the service is not properly declared
 * in {@code AndroidManifest.xml}.
 * @see VpnService
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The processing of mAddresses and mRoutes changed, from toString() method invocation to direct assignment which is classified as Other statement change (4). In addition, the methods toString() from mAddresses and mRoutes have been removed, indicating that the dependent APIs have changed resulting in classification 5.","The changes in processing of mAddresses and mRoutes might result in the method getService().establishVpn(mConfig) returning different values, resulting in a potential compatibility issue due to potential different return values or types (1)."
7,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",18,19,"<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>","<android.content.ContentProviderClient: Uri insert(Uri,ContentValues)>",0,"{
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
","/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"New statements 'beforeRemote()' and 'afterRemote()' have been added in the late version which don't change the control dependency, return statements or exception handlings, hence, the change type is 4.","These newly added statements 'beforeRemote()' and 'afterRemote()' do not alter the API's return values or exception handlings. Therefore, no Compatibility Issue exists, and the CI type is 0."
9,<android.os.Parcel: void writeException(Exception)>,18,19,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}","{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,"1,2","An additional condition statement 'else if (e instanceof NetworkOnMainThreadException)' has been added to the code block, which classifies the code change as type 3.","Due to the additional condition branch added in the late version, the method now potentially throws a different exception and returns a different value when the passed exception is an `NetworkOnMainThreadException` instance. Hence, the compatibility issues can be classified into both type 1 and 2."
10,"<android.content.IntentFilter: int matchData(String,String,Uri)>",18,19,"<android.content.IntentFilter: int matchData(String,String,Uri)>","<android.content.IntentFilter: int matchData(String,String,Uri)>",0,"{
    final ArrayList<String> types = mDataTypes;
    final ArrayList<String> schemes = mDataSchemes;
    final ArrayList<AuthorityEntry> authorities = mDataAuthorities;
    final ArrayList<PatternMatcher> paths = mDataPaths;
    int match = MATCH_CATEGORY_EMPTY;
    if (types == null && schemes == null) {
        return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
    }
    if (schemes != null) {
        if (schemes.contains(scheme != null ? scheme : """")) {
            match = MATCH_CATEGORY_SCHEME;
        } else {
            return NO_MATCH_DATA;
        }
        if (authorities != null) {
            int authMatch = matchDataAuthority(data);
            if (authMatch >= 0) {
                if (paths == null) {
                    match = authMatch;
                } else if (hasDataPath(data.getPath())) {
                    match = MATCH_CATEGORY_PATH;
                } else {
                    return NO_MATCH_DATA;
                }
            } else {
                return NO_MATCH_DATA;
            }
        }
    } else {
        // to force everyone to say they handle content: or file: URIs.
        if (scheme != null && !"""".equals(scheme) && !""content"".equals(scheme) && !""file"".equals(scheme)) {
            return NO_MATCH_DATA;
        }
    }
    if (types != null) {
        if (findMimeType(type)) {
            match = MATCH_CATEGORY_TYPE;
        } else {
            return NO_MATCH_TYPE;
        }
    } else {
        // an Intent that does not have a MIME type.
        if (type != null) {
            return NO_MATCH_TYPE;
        }
    }
    return match + MATCH_ADJUSTMENT_NORMAL;
}","{
    final ArrayList<String> types = mDataTypes;
    final ArrayList<String> schemes = mDataSchemes;
    int match = MATCH_CATEGORY_EMPTY;
    if (types == null && schemes == null) {
        return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
    }
    if (schemes != null) {
        if (schemes.contains(scheme != null ? scheme : """")) {
            match = MATCH_CATEGORY_SCHEME;
        } else {
            return NO_MATCH_DATA;
        }
        final ArrayList<PatternMatcher> schemeSpecificParts = mDataSchemeSpecificParts;
        if (schemeSpecificParts != null) {
            match = hasDataSchemeSpecificPart(data.getSchemeSpecificPart()) ? MATCH_CATEGORY_SCHEME_SPECIFIC_PART : NO_MATCH_DATA;
        }
        if (match != MATCH_CATEGORY_SCHEME_SPECIFIC_PART) {
            // If there isn't any matching ssp, we need to match an authority.
            final ArrayList<AuthorityEntry> authorities = mDataAuthorities;
            if (authorities != null) {
                int authMatch = matchDataAuthority(data);
                if (authMatch >= 0) {
                    final ArrayList<PatternMatcher> paths = mDataPaths;
                    if (paths == null) {
                        match = authMatch;
                    } else if (hasDataPath(data.getPath())) {
                        match = MATCH_CATEGORY_PATH;
                    } else {
                        return NO_MATCH_DATA;
                    }
                } else {
                    return NO_MATCH_DATA;
                }
            }
        }
        // If neither an ssp nor an authority matched, we're done.
        if (match == NO_MATCH_DATA) {
            return NO_MATCH_DATA;
        }
    } else {
        // to force everyone to say they handle content: or file: URIs.
        if (scheme != null && !"""".equals(scheme) && !""content"".equals(scheme) && !""file"".equals(scheme)) {
            return NO_MATCH_DATA;
        }
    }
    if (types != null) {
        if (findMimeType(type)) {
            match = MATCH_CATEGORY_TYPE;
        } else {
            return NO_MATCH_TYPE;
        }
    } else {
        // an Intent that does not have a MIME type.
        if (type != null) {
            return NO_MATCH_TYPE;
        }
    }
    return match + MATCH_ADJUSTMENT_NORMAL;
}",1,"/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
","/**
 * Match this filter against an Intent's data (type, scheme and path). If
 * the filter does not specify any types and does not specify any
 * schemes/paths, the match will only succeed if the intent does not
 * also specify a type or data.  If the filter does not specify any schemes,
 * it will implicitly match intents with no scheme, or the schemes ""content:""
 * or ""file:"" (basically performing a MIME-type only match).  If the filter
 * does not specify any MIME types, the Intent also must not specify a MIME
 * type.
 *
 * <p>Be aware that to match against an authority, you must also specify a base
 * scheme the authority is in.  To match against a data path, both a scheme
 * and authority must be specified.  If the filter does not specify any
 * types or schemes that it matches against, it is considered to be empty
 * (any authority or data path given is ignored, as if it were empty as
 * well).
 *
 * <p><em>Note: MIME type, Uri scheme, and host name matching in the
 * Android framework is case-sensitive, unlike the formal RFC definitions.
 * As a result, you should always write these elements with lower case letters,
 * and normalize any MIME types or Uris you receive from
 * outside of Android to ensure these elements are lower case before
 * supplying them here.</em></p>
 *
 * @param type The desired data type to look for, as returned by
 * Intent.resolveType().
 * @param scheme The desired data scheme to look for, as returned by
 * Intent.getScheme().
 * @param data The full data string to match against, as supplied in
 * Intent.data.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match
 * or {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 *
 * @see #match
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Some variables and their related control structures (authorities, paths) are removed, and a new variable (schemeSpecificParts) with its related control structures is introduced. Therefore, the code change type is 1,3.","The change of variable and control structures will make the API potentially return different values, so the CI type is 1."
13,<android.net.CaptivePortalTracker.DefaultState: boolean processMessage(Message)>,18,19,<android.net.CaptivePortalTracker.DefaultState: boolean processMessage(Message)>,<android.net.CaptivePortalTracker.DefaultState: boolean processMessage(Message)>,0,"{
    if (DBG)
        log(getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_DETECT_PORTAL:
            NetworkInfo info = (NetworkInfo) message.obj;
            // Checking on a secondary connection is not supported
            // yet
            notifyPortalCheckComplete(info);
            break;
        case CMD_CONNECTIVITY_CHANGE:
        case CMD_DELAYED_CAPTIVE_CHECK:
            break;
        default:
            loge(""Ignoring "" + message);
            break;
    }
    return HANDLED;
}","{
    if (DBG)
        log(getName() + message.toString());
    switch(message.what) {
        case CMD_DETECT_PORTAL:
            NetworkInfo info = (NetworkInfo) message.obj;
            // Checking on a secondary connection is not supported
            // yet
            notifyPortalCheckComplete(info);
            break;
        case CMD_CONNECTIVITY_CHANGE:
        case CMD_DELAYED_CAPTIVE_CHECK:
            break;
        default:
            loge(""Ignoring "" + message);
            break;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is about the log output statement, the '\n' is removed. So the code change type is 4.","There is no Compatibility Issue. Even though the code has changed, this modification does not change the behavior, returned values, or exceptions of the API, thus will not introduce compatibility issues."
14,"<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>",18,19,"<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>","<android.widget.TextView: boolean performAccessibilityAction(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        notifyAccessibilityStateChanged();
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        notifyAccessibilityStateChanged();
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        notifyAccessibilityStateChanged();
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                if (isFocused() && canSelectText()) {
                    CharSequence text = getIterableTextForAccessibility();
                    if (text == null) {
                        return false;
                    }
                    final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                    final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                    if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                        // No arguments clears the selection.
                        if (start == end && end == -1) {
                            Selection.removeSelection((Spannable) text);
                            notifyAccessibilityStateChanged();
                            return true;
                        }
                        if (start >= 0 && start <= end && end <= text.length()) {
                            Selection.setSelection((Spannable) text, start, end);
                            // Make sure selection mode is engaged.
                            if (mEditor != null) {
                                mEditor.startSelectionActionMode();
                            }
                            notifyAccessibilityStateChanged();
                            return true;
                        }
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityAction(action, arguments);
            }
    }
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                if (isFocused() && canSelectText()) {
                    CharSequence text = getIterableTextForAccessibility();
                    if (text == null) {
                        return false;
                    }
                    final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                    final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                    if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                        // No arguments clears the selection.
                        if (start == end && end == -1) {
                            Selection.removeSelection((Spannable) text);
                            return true;
                        }
                        if (start >= 0 && start <= end && end <= text.length()) {
                            Selection.setSelection((Spannable) text, start, end);
                            // Make sure selection mode is engaged.
                            if (mEditor != null) {
                                mEditor.startSelectionActionMode();
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityAction(action, arguments);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The change in the code occurs in the body of all four switch cases. notifyAccessibilityStateChanged() statement is removed, so the code change type is 4 (Other statement changed).","Removing the notifyAccessibilityStateChanged() method can change the behaviour of the application. Depending on the implementation, the removal of this method could lead to different return values, because the API method may not be triggered appropriately, so the CI_type is 1."
15,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",18,19,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,RectF,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        float left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        float left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,5",2,"The initial 'if' statement has been changed to a new method 'throwIfCannotDraw(bitmap)', so the type of code change is 2 (exception handling statement changed) and 5 (dependent API changed).","Now in late version it will throw a different exception through method 'throwIfCannotDraw(bitmap)', so the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
16,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,18,19,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,<android.content.ContentProviderClient: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,0,"{
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
","/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is the introduction of additional method calls (beforeRemote() and afterRemote()) before and after the try-catch block, which are not directly related to the control dependency, return value or exception handling of the original code. Therefore, the change type is classified as 4.","Although extra method calls (beforeRemote() and afterRemote()) are added in the late version, it does not influence the exception handling or the return value of the API, which means the behavior of this API remains identical in both versions. Thus, no Compatibility Issue exists (type 0)."
18,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,18,19,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,0,"{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary());
    }
    return false;
}","{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary()) && (subtype.isAsciiCapable() == isAsciiCapable());
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"There is a new condition added in the 'return' statement, 'subtype.isAsciiCapable() == isAsciiCapable()', which is a control dependency change and return statement change.","The new condition added to the return statement can make the method return a different boolean value, which is categorized as a Compatibility Issue due to potentially different return values."
19,<android.content.Intent: String normalizeMimeType(String)>,18,19,<android.content.Intent: String normalizeMimeType(String)>,<android.content.Intent: String normalizeMimeType(String)>,0,"{
    if (type == null) {
        return null;
    }
    type = type.trim().toLowerCase(Locale.US);
    final int semicolonIndex = type.indexOf(';');
    if (semicolonIndex != -1) {
        type = type.substring(0, semicolonIndex);
    }
    return type;
}","{
    if (type == null) {
        return null;
    }
    type = type.trim().toLowerCase(Locale.ROOT);
    final int semicolonIndex = type.indexOf(';');
    if (semicolonIndex != -1) {
        type = type.substring(0, semicolonIndex);
    }
    return type;
}",1,"/**
 * Normalize a MIME data type.
 *
 * <p>A normalized MIME type has white-space trimmed,
 * content-type parameters removed, and is lower-case.
 * This aligns the type with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""text/plain; charset=utf-8"" becomes ""text/plain"".
 * ""text/x-vCard"" becomes ""text/x-vcard"".
 *
 * <p>All MIME types received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * @param type MIME data type to normalize
 * @return normalized MIME data type, or null if the input was null
 * @see {@link #setType}
 * @see {@link #setTypeAndNormalize}
 */
","/**
 * Normalize a MIME data type.
 *
 * <p>A normalized MIME type has white-space trimmed,
 * content-type parameters removed, and is lower-case.
 * This aligns the type with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""text/plain; charset=utf-8"" becomes ""text/plain"".
 * ""text/x-vCard"" becomes ""text/x-vcard"".
 *
 * <p>All MIME types received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * @param type MIME data type to normalize
 * @return normalized MIME data type, or null if the input was null
 * @see {@link #setType}
 * @see {@link #setTypeAndNormalize}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The function toLowerCase parameter has changed from Locale.US to Locale.ROOT, which belongs to other statement change.","The 'toLowerCase' method has changed its parameter. This change could cause returning different results when dealing with certain characters in different locales, hence the CI type is 1."
20,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",18,19,"<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>","<android.content.ContentProviderClient: int update(Uri,ContentValues,String,String[])>",0,"{
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
","/**
 * See {@link ContentProvider#update ContentProvider.update}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method calls beforeRemote() and afterRemote() have been added in late version, so the type of code change is 4 (Other statement changed).","The added methods beforeRemote() and afterRemote() are used for managing remote invocation which doesn't affect the return type/value or the exceptions that the update method throws. Thus, no compatibility issue exists. The CI value is 0."
21,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,18,19,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                if (mDataChanged) {
                    // Re-sync everything if data has been changed
                    // since the scroll operation can query the adapter.
                    layoutChildren();
                }
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchModeReset = null;
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int actionMasked = ev.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                onTouchDown(ev);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                onTouchMove(ev);
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                onTouchUp(ev);
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                onTouchCancel();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    final View child = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = child.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
22,<android.content.ComponentName: String flattenToShortString()>,18,19,<android.content.ComponentName: String flattenToShortString()>,<android.content.ComponentName: String flattenToShortString()>,0,"{
    return mPackage + ""/"" + getShortClassName();
}","{
    StringBuilder sb = new StringBuilder(mPackage.length() + mClass.length());
    appendShortString(sb, mPackage, mClass);
    return sb.toString();
}",1,"/**
 * The same as {@link #flattenToString()}, but abbreviates the class
 * name if it is a suffix of the package.  The result can still be used
 * with {@link #unflattenFromString(String)}.
 *
 * @return Returns a new String holding the package and class names.  This
 * is represented as the package name, concatenated with a '/' and then the
 * class name.
 *
 * @see #unflattenFromString(String)
 */
","/**
 * The same as {@link #flattenToString()}, but abbreviates the class
 * name if it is a suffix of the package.  The result can still be used
 * with {@link #unflattenFromString(String)}.
 *
 * @return Returns a new String holding the package and class names.  This
 * is represented as the package name, concatenated with a '/' and then the
 * class name.
 *
 * @see #unflattenFromString(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been modified from a direct string formation to using StringBuilder to append strings. Also, the method `appendShortString()` which is the dependent API has changed compared to the early version. So the change type is 1,5.","The return value is not guaranteed to be the same due to both the constructor change and the dependent API change, thus the CI type is 1."
25,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,18,19,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,<android.view.ViewRootImpl.SyntheticTouchNavigationHandler: void process(MotionEvent)>,0,"{
    // Update the current device information.
    final long time = event.getEventTime();
    final int deviceId = event.getDeviceId();
    final int source = event.getSource();
    if (mCurrentDeviceId != deviceId || mCurrentSource != source) {
        finishKeys(time);
        finishTracking(time);
        mCurrentDeviceId = deviceId;
        mCurrentSource = source;
        mCurrentDeviceSupported = false;
        InputDevice device = event.getDevice();
        if (device != null) {
            // In order to support an input device, we must know certain
            // characteristics about it, such as its size and resolution.
            InputDevice.MotionRange xRange = device.getMotionRange(MotionEvent.AXIS_X);
            InputDevice.MotionRange yRange = device.getMotionRange(MotionEvent.AXIS_Y);
            if (xRange != null && yRange != null) {
                mCurrentDeviceSupported = true;
                // Infer the resolution if it not actually known.
                float xRes = xRange.getResolution();
                if (xRes <= 0) {
                    xRes = xRange.getRange() / DEFAULT_WIDTH_MILLIMETERS;
                }
                float yRes = yRange.getResolution();
                if (yRes <= 0) {
                    yRes = yRange.getRange() / DEFAULT_HEIGHT_MILLIMETERS;
                }
                float nominalRes = (xRes + yRes) * 0.5f;
                // Precompute all of the configuration thresholds we will need.
                mConfigTapTimeout = TAP_TIMEOUT;
                mConfigTapSlop = TAP_SLOP_MILLIMETERS * nominalRes;
                mConfigTickDistance = TICK_DISTANCE_MILLIMETERS * nominalRes;
                mConfigMinFlingVelocity = MIN_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                mConfigMaxFlingVelocity = MAX_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                if (LOCAL_DEBUG) {
                    Log.d(LOCAL_TAG, ""Configured device "" + mCurrentDeviceId + "" ("" + Integer.toHexString(mCurrentSource) + ""): "" + ""mConfigTapTimeout="" + mConfigTapTimeout + "", mConfigTapSlop="" + mConfigTapSlop + "", mConfigTickDistance="" + mConfigTickDistance + "", mConfigMinFlingVelocity="" + mConfigMinFlingVelocity + "", mConfigMaxFlingVelocity="" + mConfigMaxFlingVelocity);
                }
            }
        }
    }
    if (!mCurrentDeviceSupported) {
        return;
    }
    // Handle the event.
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                boolean caughtFling = mFlinging;
                finishKeys(time);
                finishTracking(time);
                mActivePointerId = event.getPointerId(0);
                mVelocityTracker = VelocityTracker.obtain();
                mVelocityTracker.addMovement(event);
                mStartTime = time;
                mStartX = event.getX();
                mStartY = event.getY();
                mLastX = mStartX;
                mLastY = mStartY;
                mAccumulatedX = 0;
                mAccumulatedY = 0;
                // If we caught a fling, then pretend that the tap slop has already
                // been exceeded to suppress taps whose only purpose is to stop the fling.
                mConsumedMovement = caughtFling;
                break;
            }
        case MotionEvent.ACTION_MOVE:
        case MotionEvent.ACTION_UP:
            {
                if (mActivePointerId < 0) {
                    break;
                }
                final int index = event.findPointerIndex(mActivePointerId);
                if (index < 0) {
                    finishKeys(time);
                    finishTracking(time);
                    break;
                }
                mVelocityTracker.addMovement(event);
                final float x = event.getX(index);
                final float y = event.getY(index);
                mAccumulatedX += x - mLastX;
                mAccumulatedY += y - mLastY;
                mLastX = x;
                mLastY = y;
                // Consume any accumulated movement so far.
                final int metaState = event.getMetaState();
                consumeAccumulatedMovement(time, metaState);
                // Detect taps and flings.
                if (action == MotionEvent.ACTION_UP) {
                    if (!mConsumedMovement && Math.hypot(mLastX - mStartX, mLastY - mStartY) < mConfigTapSlop && time <= mStartTime + mConfigTapTimeout) {
                        // It's a tap!
                        finishKeys(time);
                        sendKeyDownOrRepeat(time, KeyEvent.KEYCODE_DPAD_CENTER, metaState);
                        sendKeyUp(time);
                    } else if (mConsumedMovement && mPendingKeyCode != KeyEvent.KEYCODE_UNKNOWN) {
                        // It might be a fling.
                        mVelocityTracker.computeCurrentVelocity(1000, mConfigMaxFlingVelocity);
                        final float vx = mVelocityTracker.getXVelocity(mActivePointerId);
                        final float vy = mVelocityTracker.getYVelocity(mActivePointerId);
                        if (!startFling(time, vx, vy)) {
                            finishKeys(time);
                        }
                    }
                    finishTracking(time);
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                finishKeys(time);
                finishTracking(time);
                break;
            }
    }
}","{
    // Update the current device information.
    final long time = event.getEventTime();
    final int deviceId = event.getDeviceId();
    final int source = event.getSource();
    if (mCurrentDeviceId != deviceId || mCurrentSource != source) {
        finishKeys(time);
        finishTracking(time);
        mCurrentDeviceId = deviceId;
        mCurrentSource = source;
        mCurrentDeviceSupported = false;
        InputDevice device = event.getDevice();
        if (device != null) {
            // In order to support an input device, we must know certain
            // characteristics about it, such as its size and resolution.
            InputDevice.MotionRange xRange = device.getMotionRange(MotionEvent.AXIS_X);
            InputDevice.MotionRange yRange = device.getMotionRange(MotionEvent.AXIS_Y);
            if (xRange != null && yRange != null) {
                mCurrentDeviceSupported = true;
                // Infer the resolution if it not actually known.
                float xRes = xRange.getResolution();
                if (xRes <= 0) {
                    xRes = xRange.getRange() / DEFAULT_WIDTH_MILLIMETERS;
                }
                float yRes = yRange.getResolution();
                if (yRes <= 0) {
                    yRes = yRange.getRange() / DEFAULT_HEIGHT_MILLIMETERS;
                }
                float nominalRes = (xRes + yRes) * 0.5f;
                // Precompute all of the configuration thresholds we will need.
                mConfigTickDistance = TICK_DISTANCE_MILLIMETERS * nominalRes;
                mConfigMinFlingVelocity = MIN_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                mConfigMaxFlingVelocity = MAX_FLING_VELOCITY_TICKS_PER_SECOND * mConfigTickDistance;
                if (LOCAL_DEBUG) {
                    Log.d(LOCAL_TAG, ""Configured device "" + mCurrentDeviceId + "" ("" + Integer.toHexString(mCurrentSource) + ""): "" + "", mConfigTickDistance="" + mConfigTickDistance + "", mConfigMinFlingVelocity="" + mConfigMinFlingVelocity + "", mConfigMaxFlingVelocity="" + mConfigMaxFlingVelocity);
                }
            }
        }
    }
    if (!mCurrentDeviceSupported) {
        return;
    }
    // Handle the event.
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                boolean caughtFling = mFlinging;
                finishKeys(time);
                finishTracking(time);
                mActivePointerId = event.getPointerId(0);
                mVelocityTracker = VelocityTracker.obtain();
                mVelocityTracker.addMovement(event);
                mStartTime = time;
                mStartX = event.getX();
                mStartY = event.getY();
                mLastX = mStartX;
                mLastY = mStartY;
                mAccumulatedX = 0;
                mAccumulatedY = 0;
                // If we caught a fling, then pretend that the tap slop has already
                // been exceeded to suppress taps whose only purpose is to stop the fling.
                mConsumedMovement = caughtFling;
                break;
            }
        case MotionEvent.ACTION_MOVE:
        case MotionEvent.ACTION_UP:
            {
                if (mActivePointerId < 0) {
                    break;
                }
                final int index = event.findPointerIndex(mActivePointerId);
                if (index < 0) {
                    finishKeys(time);
                    finishTracking(time);
                    break;
                }
                mVelocityTracker.addMovement(event);
                final float x = event.getX(index);
                final float y = event.getY(index);
                mAccumulatedX += x - mLastX;
                mAccumulatedY += y - mLastY;
                mLastX = x;
                mLastY = y;
                // Consume any accumulated movement so far.
                final int metaState = event.getMetaState();
                consumeAccumulatedMovement(time, metaState);
                // Detect taps and flings.
                if (action == MotionEvent.ACTION_UP) {
                    if (mConsumedMovement && mPendingKeyCode != KeyEvent.KEYCODE_UNKNOWN) {
                        // It might be a fling.
                        mVelocityTracker.computeCurrentVelocity(1000, mConfigMaxFlingVelocity);
                        final float vx = mVelocityTracker.getXVelocity(mActivePointerId);
                        final float vy = mVelocityTracker.getYVelocity(mActivePointerId);
                        if (!startFling(time, vx, vy)) {
                            finishKeys(time);
                        }
                    }
                    finishTracking(time);
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                finishKeys(time);
                finishTracking(time);
                break;
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some assign/add expression statements related to mConfigTapTimeout and mConfigTapSlop have been removed in the late version while the rest remain unchanged, so the code change type is 4.","Though the mentioned code has been removed, these changes do not cause the API to return different variable types or values. It also does not cause it to throw different exceptions. Hence, no compatibility issue is detected in this situation."
26,"<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void startSync(ISyncContext,String,Account,Bundle)>",18,19,"<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void startSync(ISyncContext,String,Account,Bundle)>","<android.content.AbstractThreadedSyncAdapter.ISyncAdapterImpl: void startSync(ISyncContext,String,Account,Bundle)>",0,"{
    final SyncContext syncContextClient = new SyncContext(syncContext);
    boolean alreadyInProgress;
    // synchronize to make sure that mSyncThreads doesn't change between when we
    // check it and when we use it
    final Account threadsKey = toSyncKey(account);
    synchronized (mSyncThreadLock) {
        if (!mSyncThreads.containsKey(threadsKey)) {
            if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                if (ContentResolver.getIsSyncable(account, authority) < 0) {
                    ContentResolver.setIsSyncable(account, authority, 1);
                }
                syncContextClient.onFinished(new SyncResult());
                return;
            }
            SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
            mSyncThreads.put(threadsKey, syncThread);
            syncThread.start();
            alreadyInProgress = false;
        } else {
            alreadyInProgress = true;
        }
    }
    // holding the synchronization lock
    if (alreadyInProgress) {
        syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
    }
}","{
    final SyncContext syncContextClient = new SyncContext(syncContext);
    boolean alreadyInProgress;
    // synchronize to make sure that mSyncThreads doesn't change between when we
    // check it and when we use it
    final Account threadsKey = toSyncKey(account);
    synchronized (mSyncThreadLock) {
        if (!mSyncThreads.containsKey(threadsKey)) {
            if (mAutoInitialize && extras != null && extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE, false)) {
                try {
                    if (ContentResolver.getIsSyncable(account, authority) < 0) {
                        ContentResolver.setIsSyncable(account, authority, 1);
                    }
                } finally {
                    syncContextClient.onFinished(new SyncResult());
                }
                return;
            }
            SyncThread syncThread = new SyncThread(""SyncAdapterThread-"" + mNumSyncStarts.incrementAndGet(), syncContextClient, authority, account, extras);
            mSyncThreads.put(threadsKey, syncThread);
            syncThread.start();
            alreadyInProgress = false;
        } else {
            alreadyInProgress = true;
        }
    }
    // holding the synchronization lock
    if (alreadyInProgress) {
        syncContextClient.onFinished(SyncResult.ALREADY_IN_PROGRESS);
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,3,0,"The code change is about adding a `try` block for conditions checking and setting in the `if` statement under the first `synchronized(mSyncThreadLock)`. Hence, the change type is 3, representing control dependency change.","This code change is merely adding a `try` block for error protection and doesn't alter the behavior of the API. Since neither the returned values nor exceptions are affected by this change, no compatibility issues are detected. Therefore, the CI type is 0."
27,"<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>",18,19,"<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>","<android.view.inputmethod.BaseInputConnection: boolean setComposingRegion(int,int)>",0,"{
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        int a = start;
        int b = end;
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        // Clip the end points to be within the content bounds.
        final int length = content.length();
        if (a < 0)
            a = 0;
        if (b < 0)
            b = 0;
        if (a > length)
            a = length;
        if (b > length)
            b = length;
        ensureDefaultComposingSpans();
        if (mDefaultComposingSpans != null) {
            for (int i = 0; i < mDefaultComposingSpans.length; ++i) {
                content.setSpan(mDefaultComposingSpans[i], a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
            }
        }
        content.setSpan(COMPOSING, a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
        endBatchEdit();
        sendCurrentText();
    }
    return true;
}","{
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        int a = start;
        int b = end;
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        // Clip the end points to be within the content bounds.
        final int length = content.length();
        if (a < 0)
            a = 0;
        if (b < 0)
            b = 0;
        if (a > length)
            a = length;
        if (b > length)
            b = length;
        ensureDefaultComposingSpans();
        if (mDefaultComposingSpans != null) {
            for (int i = 0; i < mDefaultComposingSpans.length; ++i) {
                content.setSpan(mDefaultComposingSpans[i], a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
            }
        }
        content.setSpan(COMPOSING, a, b, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
        // Note: sendCurrentText does nothing unless mDummyMode is set
        sendCurrentText();
        endBatchEdit();
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional statement ""// Note: sendCurrentText does nothing unless mDummyMode is set"" has been added, so the code change type is 4. However, this is a comment and does not affect the program's execution.","As this change type is a comment, it does not change the normal behavior of the method, causing no potential different return types, values, or different exceptions. Thus, the type of CI is 0."
28,<android.os.ParcelFileDescriptor: String toString()>,18,19,<android.os.ParcelFileDescriptor: String toString()>,<android.os.ParcelFileDescriptor: String toString()>,0,"{
    return ""{ParcelFileDescriptor: "" + mFileDescriptor + ""}"";
}","{
    if (mWrapped != null) {
        return mWrapped.toString();
    } else {
        return ""{ParcelFileDescriptor: "" + mFd + ""}"";
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has been included in an if-else control dependency and the variable used in return statement has also been altered. Thus, the change types are 1 and 3.","The introduction of the control statement that affects the return value change could lead to different outputs when the same input is fed into different versions of the same API. Therefore, the CI type here is 1."
29,"<android.text.method.BaseMovementMethod: int getMovementMetaState(Spannable,KeyEvent)>",18,19,"<android.text.method.BaseMovementMethod: int getMovementMetaState(Spannable,KeyEvent)>","<android.text.method.BaseMovementMethod: int getMovementMetaState(Spannable,KeyEvent)>",0,"{
    // We ignore locked modifiers and SHIFT.
    int metaState = (event.getMetaState() | MetaKeyKeyListener.getMetaState(buffer)) & ~(MetaKeyKeyListener.META_ALT_LOCKED | MetaKeyKeyListener.META_SYM_LOCKED);
    return KeyEvent.normalizeMetaState(metaState) & ~KeyEvent.META_SHIFT_MASK;
}","{
    // We ignore locked modifiers and SHIFT.
    int metaState = MetaKeyKeyListener.getMetaState(buffer, event) & ~(MetaKeyKeyListener.META_ALT_LOCKED | MetaKeyKeyListener.META_SYM_LOCKED);
    return KeyEvent.normalizeMetaState(metaState) & ~KeyEvent.META_SHIFT_MASK;
}",1,"/**
 * Gets the meta state used for movement using the modifiers tracked by the text
 * buffer as well as those present in the key event.
 *
 * The movement meta state excludes the state of locked modifiers or the SHIFT key
 * since they are not used by movement actions (but they may be used for selection).
 *
 * @param buffer The text buffer.
 * @param event The key event.
 * @return The keyboard meta states used for movement.
 */
","/**
 * Gets the meta state used for movement using the modifiers tracked by the text
 * buffer as well as those present in the key event.
 *
 * The movement meta state excludes the state of locked modifiers or the SHIFT key
 * since they are not used by movement actions (but they may be used for selection).
 *
 * @param buffer The text buffer.
 * @param event The key event.
 * @return The keyboard meta states used for movement.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the initial expression of 'metaState', the parameter of 'MetaKeyKeyListener.getMetaState()' method has been changed and the 'event.getMetaState()' method is not called anymore, leading to a dependent API change. As a result, the code change types are 1 and 5.","As the execution order of method 'MetaKeyKeyListener.getMetaState()' is changed, and the method 'event.getMetaState()' is removed, this will potentially cause the API return different variables. Hence, there is a potential Compatibility Issue of type 1."
31,<android.os.ParcelFileDescriptor: int detachFd()>,18,19,<android.os.ParcelFileDescriptor: int detachFd()>,<android.os.ParcelFileDescriptor: int detachFd()>,0,"{
    if (mClosed) {
        throw new IllegalStateException(""Already closed"");
    }
    if (mWrapped != null) {
        int fd = mWrapped.detachFd();
        mClosed = true;
        mGuard.close();
        return fd;
    }
    int fd = getFd();
    mClosed = true;
    mGuard.close();
    Parcel.clearFileDescriptor(mFileDescriptor);
    return fd;
}","{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        return fd;
    }
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor and detach it
 * from the object here.  You are now responsible for closing the fd in
 * native code.
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","The overall logic of the code has been rearranged - the checking of 'mClosed' and 'mWrapped' variables has changed places, a new exception handling statement ""writeCommStatusAndClose(Status.DETACHED, null);"" has been introduced, and return statements have been changed as well - so each of return statement, exception handling, and control dependency has been altered. This makes the code change types 1,2,3.","Considering that the return values and the exception handling of this function are possibly different in two versions due to the change on the exception throwing point and 'return' statements, the CI type is 1,2."
33,<android.widget.TimePicker: void setCurrentHour(Integer)>,18,19,<android.widget.TimePicker: void setCurrentHour(Integer)>,<android.widget.TimePicker: void setCurrentHour(Integer)>,0,"{
    // why was Integer used in the first place?
    if (currentHour == null || currentHour == getCurrentHour()) {
        return;
    }
    if (!is24HourView()) {
        // convert [0,23] ordinal to wall clock display
        if (currentHour >= HOURS_IN_HALF_DAY) {
            mIsAm = false;
            if (currentHour > HOURS_IN_HALF_DAY) {
                currentHour = currentHour - HOURS_IN_HALF_DAY;
            }
        } else {
            mIsAm = true;
            if (currentHour == 0) {
                currentHour = HOURS_IN_HALF_DAY;
            }
        }
        updateAmPmControl();
    }
    mHourSpinner.setValue(currentHour);
    onTimeChanged();
}","{
    setCurrentHour(currentHour, true);
}",1,"/**
 * Set the current hour.
 */
","/**
 * Set the current hour.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire body of the method has changed. The early version contained a whole detailed implementation, while the late version replaced it with a newly called method setCurrentHour(currentHour, true), so the change type is 1,5.","The method ""setCurrentHour(currentHour, true)"" could potentially return different types or values compared to the original version, thus leading to the CI type 1."
35,<android.view.View: boolean isOpaque()>,18,19,<android.view.View: boolean isOpaque()>,<android.view.View: boolean isOpaque()>,0,"{
    return (mPrivateFlags & PFLAG_OPAQUE_MASK) == PFLAG_OPAQUE_MASK && ((mTransformationInfo != null ? mTransformationInfo.mAlpha : 1.0f) >= 1.0f);
}","{
    return (mPrivateFlags & PFLAG_OPAQUE_MASK) == PFLAG_OPAQUE_MASK && getFinalAlpha() >= 1.0f;
}",1,"/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
","/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement and the dependent API (mTransformationInfo and getFinalAlpha()) have changed, so the code change type is 1,5.","The change in return statement makes the API potentially return different values, hence the CI type is 1."
36,"<android.widget.AbsListView.ListItemAccessibilityDelegate: void onInitializeAccessibilityNodeInfo(View,AccessibilityNodeInfo)>",18,19,"<android.widget.AbsListView.ListItemAccessibilityDelegate: void onInitializeAccessibilityNodeInfo(View,AccessibilityNodeInfo)>","<android.widget.AbsListView.ListItemAccessibilityDelegate: void onInitializeAccessibilityNodeInfo(View,AccessibilityNodeInfo)>",0,"{
    super.onInitializeAccessibilityNodeInfo(host, info);
    final int position = getPositionForView(host);
    final ListAdapter adapter = getAdapter();
    if ((position == INVALID_POSITION) || (adapter == null)) {
        return;
    }
    if (!isEnabled() || !adapter.isEnabled(position)) {
        return;
    }
    if (position == getSelectedItemPosition()) {
        info.setSelected(true);
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    }
    if (isClickable()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
        info.setClickable(true);
    }
    if (isLongClickable()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
        info.setLongClickable(true);
    }
}","{
    super.onInitializeAccessibilityNodeInfo(host, info);
    final int position = getPositionForView(host);
    onInitializeAccessibilityNodeInfoForItem(host, position, info);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The statements within the method have been replaced by a call to ""onInitializeAccessibilityNodeInfoForItem(host, position, info);"" which is a dependent API. Consequently the change type is 1,5.","Due to the change to the dependent API, the returned info object can potentially have different properties than the previous version depending on the implementation of ""onInitializeAccessibilityNodeInfoForItem"" method. Therefore, the CI type is 1."
38,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,18,19,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,<android.os.ParcelFileDescriptor.AutoCloseOutputStream: void close()>,0,"{
    try {
        mFd.close();
    } finally {
        super.close();
    }
}","{
    try {
        mPfd.close();
    } finally {
        super.close();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The variable referencing the file descriptor field has been changed (from mFd to mPfd) in the try block of the close() method, so the code change type is 4.","The close() method could behave differently based on which field (mFd or mPfd) is closed. Thus, behaving differently can cause a Compatibility Issue and hence the CI type is 1."
39,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>",18,19,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>","<android.os.PowerManager: WakeLock newWakeLock(int,String)>",0,"{
    validateWakeLockParameters(levelAndFlags, tag);
    return new WakeLock(levelAndFlags, tag);
}","{
    validateWakeLockParameters(levelAndFlags, tag);
    return new WakeLock(levelAndFlags, tag, mContext.getOpPackageName());
}",1,"/**
 * Creates a new wake lock with the specified level and flags.
 * <p>
 * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
 * combined using the logical OR operator.
 * </p><p>
 * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
 * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
 * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
 * specified as part of the {@code levelAndFlags} parameter.
 * </p><p>
 * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
 * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
 * {@code levelAndFlags} parameters.
 * </p><p>
 * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 * </p><p>
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ... do work...
 * wl.release();
 * }
 * </p><p>
 * Although a wake lock can be created without special permissions,
 * the {@link android.Manifest.permission#WAKE_LOCK} permission is
 * required to actually acquire or release the wake lock that is returned.
 * </p><p class=""note"">
 * If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.
 * </p>
 *
 * @param levelAndFlags Combination of wake lock level and flag values defining
 * the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
","/**
 * Creates a new wake lock with the specified level and flags.
 * <p>
 * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
 * combined using the logical OR operator.
 * </p><p>
 * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
 * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
 * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
 * specified as part of the {@code levelAndFlags} parameter.
 * </p><p>
 * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
 * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
 * {@code levelAndFlags} parameters.
 * </p><p>
 * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 * </p><p>
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ... do work...
 * wl.release();
 * }
 * </p><p>
 * Although a wake lock can be created without special permissions,
 * the {@link android.Manifest.permission#WAKE_LOCK} permission is
 * required to actually acquire or release the wake lock that is returned.
 * </p><p class=""note"">
 * If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.
 * </p>
 *
 * @param levelAndFlags Combination of wake lock level and flag values defining
 * the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The return statement has changed, also the parameter list of API 'new WakeLock()' in the 'return' statement has been changed so the code change type is 1,5.","The parameters of the constructor 'new WakeLock()' have been changed, which will potentially make the API return a different type of WakeLock object, so the CI type is 1."
42,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",18,19,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>","<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        checkRange(colors.length, colorOffset, count);
    }
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5",2,"The first check statement has changed from ""throw new IllegalArgumentException()"" to the function ""throwIfCannotDraw()"". This change includes an exception handling statement change and an other statement change since a new method is called, so the code change type is 2,4,5.","Due to the change from a specific exception thrown (IllegalArgumentException) to different exceptions potentially thrown by the ""throwIfCannotDraw()"" method, the API could behave differently in terms of exception handling. Thus, a compatibility issue arises with type 2."
43,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",18,19,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, ""BadTokenException: IME is done."");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}",1,"/**
 * Handle a request by the system to show the soft input area.
 */
","/**
 * Handle a request by the system to show the soft input area.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method called in the condition statement 'boolean showing = onEvaluateInputViewShown();' in the Early Version is changed to 'boolean showing = isInputViewShown();' in Late Version. This type of change is classified as 4, an 'Other statement change' as it is neither about a return statement nor exception handling and control dependency statements.","This alteration could potentially make the API return a different value - the result of 'resultReceiver.send(…)', which depends on the result of 'wasVis != isInputViewShown()'. As a consequence, a Compatibility Issue is detected due to the potential different return values, thus CI_type is 1."
47,"<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>",18,19,"<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>","<android.content.pm.ResolveInfo.DisplayNameComparator: int compare(ResolveInfo,ResolveInfo)>",0,"{
    CharSequence sa = a.loadLabel(mPM);
    if (sa == null)
        sa = a.activityInfo.name;
    CharSequence sb = b.loadLabel(mPM);
    if (sb == null)
        sb = b.activityInfo.name;
    return sCollator.compare(sa.toString(), sb.toString());
}","{
    CharSequence sa = a.loadLabel(mPM);
    if (sa == null)
        sa = a.activityInfo.name;
    CharSequence sb = b.loadLabel(mPM);
    if (sb == null)
        sb = b.activityInfo.name;
    return mCollator.compare(sa.toString(), sb.toString());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The implementation of compare operation changes from utilizing `sCollator.compare` to `mCollator.compare`, so it is classified as type 4.","The replaced variable `sCollator` by `mCollator` may result in different comparison results between two `ResolveInfo` objects, leading to compatibility issue type 1."
50,<android.view.View: boolean dispatchDragEvent(DragEvent)>,18,19,<android.view.View: boolean dispatchDragEvent(DragEvent)>,<android.view.View: boolean dispatchDragEvent(DragEvent)>,0,"{
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        return true;
    }
    return onDragEvent(event);
}","{
    ListenerInfo li = mListenerInfo;
    // noinspection SimplifiableIfStatement
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        return true;
    }
    return onDragEvent(event);
}",1,"/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
","/**
 * Detects if this View is enabled and has a drag event listener.
 * If both are true, then it calls the drag event listener with the
 * {@link android.view.DragEvent} it received. If the drag event listener returns
 * {@code true}, then dispatchDragEvent() returns {@code true}.
 * <p>
 * For all other cases, the method calls the
 * {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} drag event handler
 * method and returns its result.
 * </p>
 * <p>
 * This ensures that a drag event is always consumed, even if the View does not have a drag
 * event listener. However, if the View has a listener and the listener returns true, then
 * onDragEvent() is not called.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code change between these two versions, only the annotation has moved which does not affect the function or behavior of the code.","Since there is no code change, compatibility issue does not exist."
51,<android.widget.ListView: boolean pageScroll(int)>,18,19,<android.widget.ListView: boolean pageScroll(int)>,<android.widget.ListView: boolean pageScroll(int)>,0,"{
    int nextPage = -1;
    boolean down = false;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
        down = true;
    }
    if (nextPage >= 0) {
        int position = lookForSelectablePosition(nextPage, down);
        if (position >= 0) {
            mLayoutMode = LAYOUT_SPECIFIC;
            mSpecificTop = mPaddingTop + getVerticalFadingEdgeLength();
            if (down && position > mItemCount - getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
            }
            if (!down && position < getChildCount()) {
                mLayoutMode = LAYOUT_FORCE_TOP;
            }
            setSelectionInt(position);
            invokeOnItemScrollListener();
            if (!awakenScrollBars()) {
                invalidate();
            }
            return true;
        }
    }
    return false;
}","{
    final int nextPage;
    final boolean down;
    if (direction == FOCUS_UP) {
        nextPage = Math.max(0, mSelectedPosition - getChildCount() - 1);
        down = false;
    } else if (direction == FOCUS_DOWN) {
        nextPage = Math.min(mItemCount - 1, mSelectedPosition + getChildCount() - 1);
        down = true;
    } else {
        return false;
    }
    if (nextPage >= 0) {
        final int position = lookForSelectablePositionAfter(mSelectedPosition, nextPage, down);
        if (position >= 0) {
            mLayoutMode = LAYOUT_SPECIFIC;
            mSpecificTop = mPaddingTop + getVerticalFadingEdgeLength();
            if (down && (position > (mItemCount - getChildCount()))) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
            }
            if (!down && (position < getChildCount())) {
                mLayoutMode = LAYOUT_FORCE_TOP;
            }
            setSelectionInt(position);
            invokeOnItemScrollListener();
            if (!awakenScrollBars()) {
                invalidate();
            }
            return true;
        }
    }
    return false;
}",1,"/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
","/**
 * Scrolls up or down by the number of items currently present on screen.
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The whole implementation is restructured. The initialization of variables 'int nextPage' and 'boolean down' was moved inside the condition checking. A new return statement 'return false' was added when the direction is not FOCUS_UP and not FOCUS_DOWN. Also, the method lookForSelectablePosition() was changed to lookForSelectablePositionAfter(). Therefore, the change types are 1 (Return statement changed), 3 (Control dependency changed), 4 (Other statement change), and 5 (Dependent API changed).","The change to the control structure, return statements, and the dependent API alteration may cause the late version function to return a different result compared to the early version when the same input is given. Therefore, there is a compatibility issue type 1 (CI caused by potential different return values or types)."
52,"<android.widget.PopupWindow: void showAsDropDown(View,int,int)>",18,19,"<android.widget.PopupWindow: void showAsDropDown(View,int,int)>","<android.widget.PopupWindow: void showAsDropDown(View,int,int)>",0,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    registerForScrollChanged(anchor, xoff, yoff);
    mIsShowing = true;
    mIsDropdown = true;
    WindowManager.LayoutParams p = createPopupLayout(anchor.getWindowToken());
    preparePopup(p);
    updateAboveAnchor(findDropDownPosition(anchor, p, xoff, yoff));
    if (mHeightMode < 0)
        p.height = mLastHeight = mHeightMode;
    if (mWidthMode < 0)
        p.width = mLastWidth = mWidthMode;
    p.windowAnimations = computeAnimationResource();
    invokePopup(p);
}","{
    showAsDropDown(anchor, xoff, yoff, DEFAULT_ANCHORED_GRAVITY);
}",1,"/**
 * <p>Display the content view in a popup window anchored to the bottom-left
 * corner of the anchor view offset by the specified x and y coordinates.
 * If there is not enough room on screen to show
 * the popup in its entirety, this method tries to find a parent scroll
 * view to scroll. If no parent scroll view can be scrolled, the bottom-left
 * corner of the popup is pinned at the top left corner of the anchor view.</p>
 * <p>If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.</p>
 *
 * @param anchor the view on which to pin the popup window
 *
 * @see #dismiss()
 */
","/**
 * <p>Display the content view in a popup window anchored to the bottom-left
 * corner of the anchor view offset by the specified x and y coordinates.
 * If there is not enough room on screen to show
 * the popup in its entirety, this method tries to find a parent scroll
 * view to scroll. If no parent scroll view can be scrolled, the bottom-left
 * corner of the popup is pinned at the top left corner of the anchor view.</p>
 * <p>If the view later scrolls to move <code>anchor</code> to a different
 * location, the popup will be moved correspondingly.</p>
 *
 * @param anchor the view on which to pin the popup window
 * @param xoff A horizontal offset from the anchor in pixels
 * @param yoff A vertical offset from the anchor in pixels
 *
 * @see #dismiss()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method implementation has been significantly simplified from a detailed implementation to a simple method call, showAsDropDown(anchor, xoff, yoff, DEFAULT_ANCHORED_GRAVITY). This change corresponds to return statement changed (change in method behavior) and dependent API changed (change in method used).","The change in the function implementation means that the function could now behave differently, possibly returning different results based on the new implementation which now has an extra gravity parameter, indicating a compatibility issue caused by potential different return values or exceptions. Thus, based on rule 3, that any code change potentially leading to a compatibility issue (CI), should be regarded as CI, the CI type is 1."
54,"<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String)>",18,19,"<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String)>","<android.content.ContentResolver: ParcelFileDescriptor openFileDescriptor(Uri,String)>",0,"{
    AssetFileDescriptor afd = openAssetFileDescriptor(uri, mode);
    if (afd == null) {
        return null;
    }
    if (afd.getDeclaredLength() < 0) {
        // This is a full file!
        return afd.getParcelFileDescriptor();
    }
    // we got and bail with an exception.
    try {
        afd.close();
    } catch (IOException e) {
    }
    throw new FileNotFoundException(""Not a whole file"");
}","{
    return openFileDescriptor(uri, mode, null);
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the
 * underlying {@link ContentProvider#openFile}
 * ContentProvider.openFile()} method, so will <em>not</em> work with
 * providers that return sub-sections of files.  If at all possible,
 * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You
 * will receive a FileNotFoundException exception if the provider returns a
 * sub-section of a file.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openFile
 * ContentProvider.openFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException if no
 * file exists under the URI or the mode is invalid.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * is like {@link #openAssetFileDescriptor(Uri, String)}, but uses the
 * underlying {@link ContentProvider#openFile}
 * ContentProvider.openFile()} method, so will <em>not</em> work with
 * providers that return sub-sections of files.  If at all possible,
 * you should use {@link #openAssetFileDescriptor(Uri, String)}.  You
 * will receive a FileNotFoundException exception if the provider returns a
 * sub-section of a file.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 * <p>
 * If opening with the exclusive ""r"" or ""w"" modes, the returned
 * ParcelFileDescriptor could be a pipe or socket pair to enable streaming
 * of data. Opening with the ""rw"" mode implies a file on disk that supports
 * seeking. If possible, always use an exclusive mode to give the underlying
 * {@link ContentProvider} the most flexibility.
 * <p>
 * If you are writing a file, and need to communicate an error to the
 * provider, use {@link ParcelFileDescriptor#closeWithError(String)}.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openFile
 * ContentProvider.openFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException if no
 * file exists under the URI or the mode is invalid.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The complete implementation of the method has been changed, the returned variables in early and late implementations are completely different, so there are both change type 1 and type 5.","In the early version, this method might throw an FileNotFoundException while in the late version it won't throw any exception. At the same time, it may return different variables in two versions depending on the input parameter, so there are both CI type 1 and type 2."
56,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",18,19,"<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentProviderClient: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    try {
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    return openTypedAssetFileDescriptor(uri, mimeType, opts, null);
}",1,"/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
","/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the early version has been changed in the late version. Instead of calling mContentProvider.openTypedAssetFile within the try block, the late version calls openTypedAssetFileDescriptor with an additional null argument. DeadObjectException handling code has been removed. Therefore, it involves change type 1 and 5.","The changes could potentially lead to different return values between two versions because the error handling logic for DeadObjectException has been removed and an additional null parameter is provided in the new function invocation, so the API is potentially returning different values. Hence, the CI type is 1."
57,<android.content.ClipboardManager: boolean hasPrimaryClip()>,18,19,<android.content.ClipboardManager: boolean hasPrimaryClip()>,<android.content.ClipboardManager: boolean hasPrimaryClip()>,0,"{
    try {
        return getService().hasPrimaryClip(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
","/**
 * Returns true if there is currently a primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is changed with different method invoking as parameter (changed from mContext.getBasePackageName() to mContext.getOpPackageName()), so the code change type is 1,5.",The change of return statement will cause the API to potentially return a different value as the value returned by hasPrimaryClip() method depends on the parameter passed to it (Either mContext.getBasePackageName() or mContext.getOpPackageName()) and thus the CI type is 1.
58,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,18,19,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,<android.widget.CalendarView: void setFirstDayOfWeek(int)>,0,"{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}","{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    setUpHeader();
}",1,"/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
","/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement ""mAdapter.notifyDataSetChanged();"" has been removed in the late version of the code. This change falls under the category of ""Other statement changed"" so the code change type is 4.","The removal of the ""mAdapter.notifyDataSetChanged();"" statement could potentially cause a different behavior when invoking this method, as it omits the notification of any data set changes. Despite there being no return result from the method, the internal states after performing this method could potentially change. Thus, the CI type is 1."
59,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",18,19,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",0,"{
    if (listener == null || sensor == null) {
        return false;
    }
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 66667;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    return registerListenerImpl(listener, sensor, delay, handler);
}","{
    int delay = getDelay(rateUs);
    return registerListenerImpl(listener, sensor, delay, handler, 0, 0);
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 *
 * @throws IllegalArgumentException when sensor is null or a trigger sensor
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
 * sensor. Events are delivered in continuous mode as soon as they are available. To reduce the
 * battery usage, use {@link #registerListener(SensorEventListener, Sensor, int, int)} which
 * enables batch mode for the sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rateUs
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return <code>true</code> if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The switch-case statement in the early version is replaced with the method call getDelay(rateUs) in later version (control dependency change - type 4). In addition, the return statement of both versions invokes different method signatures of registerListenerImpl (Return statement change - type 1 and Dependent API change - type 5).","The change of the return statement could make the API potentially return a different value, so the CI type is 1."
60,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,18,19,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabelFor()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
","/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement of the method has been modified, because the dependent method `findAccessibilityNodeInfoByAccessibilityId` has a new parameter added, so the code change type is 1,5.","Since a new parameter was added to the dependent method call in the return statement which could lead to a different behavior from the previous version, the CI type is 1."
61,<android.app.Activity: void performStart()>,18,19,<android.app.Activity: void performStart()>,<android.app.Activity: void performStart()>,0,"{
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[mAllLoaderManagers.size()];
        mAllLoaderManagers.values().toArray(loaders);
        if (loaders != null) {
            for (int i = 0; i < loaders.length; i++) {
                LoaderManagerImpl lm = loaders[i];
                lm.finishRetain();
                lm.doReportStart();
            }
        }
    }
}","{
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            lm.finishRetain();
            lm.doReportStart();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The way in which the 'loaders' array is being initialized and populated has been changed, leading to change types 3 and 4.","There should be no Compatibility Issue here. All changes are just related to how the 'loaders' array is populated, but those changes do not affect the final outcome. There should be no difference in return value or exception handling in these situations."
62,<android.app.ActivityThread.H: String codeToString(int)>,18,19,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ACTIVITY_EXTRAS:
                return ""REQUEST_ACTIVITY_EXTRAS"";
        }
    }
    return Integer.toString(code);
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
            case DUMP_PROVIDER:
                return ""DUMP_PROVIDER"";
            case UNSTABLE_PROVIDER_DIED:
                return ""UNSTABLE_PROVIDER_DIED"";
            case REQUEST_ASSIST_CONTEXT_EXTRAS:
                return ""REQUEST_ASSIST_CONTEXT_EXTRAS"";
            case TRANSLUCENT_CONVERSION_COMPLETE:
                return ""TRANSLUCENT_CONVERSION_COMPLETE"";
            case INSTALL_PROVIDER:
                return ""INSTALL_PROVIDER"";
        }
    }
    return Integer.toString(code);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Switch cases ""REQUEST_ASSIST_CONTEXT_EXTRAS"", ""TRANSLUCENT_CONVERSION_COMPLETE"", and ""INSTALL_PROVIDER"" have been added in the Late Implementation. This is a change of control dependency (type 3), and also the return statement has changed (type 1).","The new switch cases in the switch statement cause the method to potentially return different string values depending on the input code. Therefore, the compatibility issue type is 1."
63,"<android.nfc.NdefRecord: NdefRecord createExternal(String,String,byte[])>",18,19,"<android.nfc.NdefRecord: NdefRecord createExternal(String,String,byte[])>","<android.nfc.NdefRecord: NdefRecord createExternal(String,String,byte[])>",0,"{
    if (domain == null)
        throw new NullPointerException(""domain is null"");
    if (type == null)
        throw new NullPointerException(""type is null"");
    domain = domain.trim().toLowerCase(Locale.US);
    type = type.trim().toLowerCase(Locale.US);
    if (domain.length() == 0)
        throw new IllegalArgumentException(""domain is empty"");
    if (type.length() == 0)
        throw new IllegalArgumentException(""type is empty"");
    byte[] byteDomain = domain.getBytes(Charsets.UTF_8);
    byte[] byteType = type.getBytes(Charsets.UTF_8);
    byte[] b = new byte[byteDomain.length + 1 + byteType.length];
    System.arraycopy(byteDomain, 0, b, 0, byteDomain.length);
    b[byteDomain.length] = ':';
    System.arraycopy(byteType, 0, b, byteDomain.length + 1, byteType.length);
    return new NdefRecord(TNF_EXTERNAL_TYPE, b, null, data);
}","{
    if (domain == null)
        throw new NullPointerException(""domain is null"");
    if (type == null)
        throw new NullPointerException(""type is null"");
    domain = domain.trim().toLowerCase(Locale.ROOT);
    type = type.trim().toLowerCase(Locale.ROOT);
    if (domain.length() == 0)
        throw new IllegalArgumentException(""domain is empty"");
    if (type.length() == 0)
        throw new IllegalArgumentException(""type is empty"");
    byte[] byteDomain = domain.getBytes(StandardCharsets.UTF_8);
    byte[] byteType = type.getBytes(StandardCharsets.UTF_8);
    byte[] b = new byte[byteDomain.length + 1 + byteType.length];
    System.arraycopy(byteDomain, 0, b, 0, byteDomain.length);
    b[byteDomain.length] = ':';
    System.arraycopy(byteType, 0, b, byteDomain.length + 1, byteType.length);
    return new NdefRecord(TNF_EXTERNAL_TYPE, b, null, data);
}",1,"/**
 * Create a new NDEF Record containing external (application-specific) data.<p>
 * Use this method to encode application specific data into an NDEF Record.
 * The data is typed by a domain name (usually your Android package name) and
 * a domain-specific type. This data is packaged into a ""NFC Forum External
 * Type"" NDEF Record.<p>
 * NFC Forum requires that the domain and type used in an external record
 * are treated as case insensitive, however Android intent filtering is
 * always case sensitive. So this method will force the domain and type to
 * lower-case before creating the NDEF Record.<p>
 * The unchecked exception {@link IllegalArgumentException} will be thrown
 * if the domain and type have serious problems, for example if either field
 * is empty, so always catch this
 * exception if you are passing user-generated data into this method.<p>
 * There are no such restrictions on the payload data.<p>
 * For efficiency, This method might not make an internal copy of the
 * data byte array, so take care not
 * to modify the data byte array while still using the returned
 * NdefRecord.
 *
 * Reference specification: NFCForum-TS-RTD_1.0
 * @param domain domain-name of issuing organization
 * @param type domain-specific type of data
 * @param data payload as bytes
 * @throws IllegalArugmentException if either domain or type are empty or invalid
 */
","/**
 * Create a new NDEF Record containing external (application-specific) data.<p>
 * Use this method to encode application specific data into an NDEF Record.
 * The data is typed by a domain name (usually your Android package name) and
 * a domain-specific type. This data is packaged into a ""NFC Forum External
 * Type"" NDEF Record.<p>
 * NFC Forum requires that the domain and type used in an external record
 * are treated as case insensitive, however Android intent filtering is
 * always case sensitive. So this method will force the domain and type to
 * lower-case before creating the NDEF Record.<p>
 * The unchecked exception {@link IllegalArgumentException} will be thrown
 * if the domain and type have serious problems, for example if either field
 * is empty, so always catch this
 * exception if you are passing user-generated data into this method.<p>
 * There are no such restrictions on the payload data.<p>
 * For efficiency, This method might not make an internal copy of the
 * data byte array, so take care not
 * to modify the data byte array while still using the returned
 * NdefRecord.
 *
 * Reference specification: NFCForum-TS-RTD_1.0
 * @param domain domain-name of issuing organization
 * @param type domain-specific type of data
 * @param data payload as bytes
 * @throws IllegalArugmentException if either domain or type are empty or invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the function, 'toLowerCase(Locale.US)' has been changed into 'toLowerCase(Locale.ROOT)' and 'getBytes(Charsets.UTF_8)' has been changed into 'getBytes(StandardCharsets.UTF_8)'. This indicates that the type and method of the dependent API have been changed.","The modified dependent APIs ('toLowerCase' and 'getBytes') may return different values from previous version, which may in turn affect the return value of the function 'createExternal'. Thus, a compatibility issue might occur."
65,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,18,19,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromFd(int)>,0,"{
    FileDescriptor fdesc = getFileDescriptorFromFd(fd);
    return new ParcelFileDescriptor(fdesc);
}","{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Libcore.os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
","/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","The method fromFd(int) has had changes to its internal return statement and its internal handling of exceptions. It has also introduced a new block of code that uses the variable 'dup' and the method Libcore.os.dup(original), which didn't exist in the earlier version. ","The change in the return statement means that the method now returns a new instance of ParcelFileDescriptor with a potentially different argument, thereby potentially returning a different value. An exception is also now being thrown in the newer version of the method, which was not present in the earlier version, thereby changing how exceptions are handled."
66,"<android.text.method.ArrowKeyMovementMethod: boolean handleMovementKey(TextView,Spannable,int,int,KeyEvent)>",18,19,"<android.text.method.ArrowKeyMovementMethod: boolean handleMovementKey(TextView,Spannable,int,int,KeyEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean handleMovementKey(TextView,Spannable,int,int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0 && MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0) {
                    return widget.showContextMenu();
                }
            }
            break;
    }
    return super.handleMovementKey(widget, buffer, keyCode, movementMetaState, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0 && MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING, event) != 0) {
                    return widget.showContextMenu();
                }
            }
            break;
    }
    return super.handleMovementKey(widget, buffer, keyCode, movementMetaState, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API MetaKeyKeyListener.getMetaState's input parameters has changed. It is now additionally taking 'event' as a parameter. Also, it directly leads to return statement change as the return of this API is used as an expression in an 'if' statement so the code change type is 1,5.","The same block of 'if' statement can now be reached by different conditions because of the dependent API change. As a result, a different boolean may be returned as a consequence which leads to the CI type 1."
67,<android.net.Uri: Uri normalizeScheme()>,18,19,<android.net.Uri: Uri normalizeScheme()>,<android.net.Uri: Uri normalizeScheme()>,0,"{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.US);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}","{
    String scheme = getScheme();
    // give up
    if (scheme == null)
        return this;
    String lowerScheme = scheme.toLowerCase(Locale.ROOT);
    // no change
    if (scheme.equals(lowerScheme))
        return this;
    return buildUpon().scheme(lowerScheme).build();
}",1,"/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link #setNormalizedData}
 */
","/**
 * Return an equivalent URI with a lowercase scheme component.
 * This aligns the Uri with Android best practices for
 * intent filtering.
 *
 * <p>For example, ""HTTP://www.android.com"" becomes
 * ""http://www.android.com""
 *
 * <p>All URIs received from outside Android (such as user input,
 * or external sources like Bluetooth, NFC, or the Internet) should
 * be normalized before they are used to create an Intent.
 *
 * <p class=""note"">This method does <em>not</em> validate bad URI's,
 * or 'fix' poorly formatted URI's - so do not use it for input validation.
 * A Uri will always be returned, even if the Uri is badly formatted to
 * begin with and a scheme component cannot be found.
 *
 * @return normalized Uri (never null)
 * @see {@link android.content.Intent#setData}
 * @see {@link #setNormalizedData}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The parameter of the function toLowerCase has been changed from Locale.US to Locale.ROOT, so the code change type is 4.","The change to function toLowerCase's parameter may cause a different return value for the API, hence the CI type is 1."
68,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",18,19,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>","<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",0,"{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().draw(canvas);
        }
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new drawing statement ""mOverlay.getOverlayView().draw(canvas);"" was added under a condition, therefore the code change type is 3.","The addition of a drawing operation under the given condition could potentially result in the API returning a bitmap with layouts drawn differently in the late version from the early version, leading to a compatibility issue of type 1."
71,"<android.app.AlarmManager: void set(int,long,PendingIntent)>",18,19,"<android.app.AlarmManager: void set(int,long,PendingIntent)>","<android.app.AlarmManager: void set(int,long,PendingIntent)>",0,"{
    try {
        mService.set(type, triggerAtMillis, operation);
    } catch (RemoteException ex) {
    }
}","{
    setImpl(type, triggerAtMillis, legacyExactLength(), 0, operation, null);
}",1,"/**
 * Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,
 * etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>If the time occurs in the past, the alarm will be triggered
 * immediately.  If there is already an alarm for this Intent
 * scheduled (with the equality of two intents being defined by
 * {@link Intent#filterEquals}), then it will be removed and replaced by
 * this one.
 *
 * <p>
 * The alarm is an intent broadcast that goes to a broadcast receiver that
 * you registered with {@link android.content.Context#registerReceiver}
 * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
 *
 * <p>
 * Alarm intents are delivered with a data extra of type int called
 * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates
 * how many past alarm events have been accumulated into this intent
 * broadcast.  Recurring alarms that have gone undelivered because the
 * phone was asleep may have a count greater than one when delivered.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #setRepeating
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
","/**
 * TBW: discussion of fuzzy nature of alarms in KLP+.
 *
 * <p>Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,
 * etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>If the time occurs in the past, the alarm will be triggered
 * immediately.  If there is already an alarm for this Intent
 * scheduled (with the equality of two intents being defined by
 * {@link Intent#filterEquals}), then it will be removed and replaced by
 * this one.
 *
 * <p>
 * The alarm is an intent broadcast that goes to a broadcast receiver that
 * you registered with {@link android.content.Context#registerReceiver}
 * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.
 *
 * <p>
 * Alarm intents are delivered with a data extra of type int called
 * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates
 * how many past alarm events have been accumulated into this intent
 * broadcast.  Recurring alarms that have gone undelivered because the
 * phone was asleep may have a count greater than one when delivered.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #setExact
 * @see #setRepeating
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, the API calls 'mService.set()', while in the late version, it calls 'setImpl()'. The return statement and dependent API have both changed, so the change type is 1,5.","Since the late version API uses a different method to execute the function, which potentially leads the return value to be different even though it's a void type here (as the executor method is changed), the CI type is 1."
73,"<android.text.method.DialerKeyListener: int lookup(KeyEvent,Spannable)>",18,19,"<android.text.method.DialerKeyListener: int lookup(KeyEvent,Spannable)>","<android.text.method.DialerKeyListener: int lookup(KeyEvent,Spannable)>",0,"{
    int meta = event.getMetaState() | getMetaState(content);
    int number = event.getNumber();
    /*
         * Prefer number if no meta key is active, or if it produces something
         * valid and the meta lookup does not.
         */
    if ((meta & (MetaKeyKeyListener.META_ALT_ON | MetaKeyKeyListener.META_SHIFT_ON)) == 0) {
        if (number != 0) {
            return number;
        }
    }
    int match = super.lookup(event, content);
    if (match != 0) {
        return match;
    } else {
        if (meta != 0) {
            KeyData kd = new KeyData();
            char[] accepted = getAcceptedChars();
            if (event.getKeyData(kd)) {
                for (int i = 1; i < kd.meta.length; i++) {
                    if (ok(accepted, kd.meta[i])) {
                        return kd.meta[i];
                    }
                }
            }
        }
        return number;
    }
}","{
    int meta = getMetaState(content, event);
    int number = event.getNumber();
    /*
         * Prefer number if no meta key is active, or if it produces something
         * valid and the meta lookup does not.
         */
    if ((meta & (MetaKeyKeyListener.META_ALT_ON | MetaKeyKeyListener.META_SHIFT_ON)) == 0) {
        if (number != 0) {
            return number;
        }
    }
    int match = super.lookup(event, content);
    if (match != 0) {
        return match;
    } else {
        if (meta != 0) {
            KeyData kd = new KeyData();
            char[] accepted = getAcceptedChars();
            if (event.getKeyData(kd)) {
                for (int i = 1; i < kd.meta.length; i++) {
                    if (ok(accepted, kd.meta[i])) {
                        return kd.meta[i];
                    }
                }
            }
        }
        return number;
    }
}",1,"/**
 * Overrides the superclass's lookup method to prefer the number field
 * from the KeyEvent.
 */
","/**
 * Overrides the superclass's lookup method to prefer the number field
 * from the KeyEvent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The method of calculating 'meta' has changed from 'event.getMetaState() | getMetaState(content)' to 'getMetaState(content, event)', indicating a change in the return statement and the API this method depends on. Thus, the code change type is 1, 5.","Since the method of computing 'meta' has been altered, there's a possibility that this API will return a different value, indicating a compatibility issue caused by potential different return values, thus the CI type is 1."
74,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",18,19,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Don't put header or footer views or views that should be ignored
    // into the scrap heap
    int viewType = lp.viewType;
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (!shouldRecycleViewType(viewType) || scrapHasTransientState) {
        if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
        if (scrapHasTransientState) {
            scrap.dispatchStartTemporaryDetach();
            if (mAdapter != null && mAdapterHasStableIds) {
                if (mTransientStateViewsById == null) {
                    mTransientStateViewsById = new LongSparseArray<View>();
                }
                mTransientStateViewsById.put(lp.itemId, scrap);
            } else if (!mDataChanged) {
                // the layout positions may be out of sync with the adapter positions
                if (mTransientStateViews == null) {
                    mTransientStateViews = new SparseArray<View>();
                }
                mTransientStateViews.put(position, scrap);
            }
        }
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    if (mViewTypeCount == 1) {
        mCurrentScrap.add(scrap);
    } else {
        mScrapViews[viewType].add(scrap);
    }
    scrap.setAccessibilityDelegate(null);
    if (mRecyclerListener != null) {
        mRecyclerListener.onMovedToScrapHeap(scrap);
    }
}","{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}",1,"/**
 * Put a view into the ScrapViews list. These views are unordered.
 *
 * @param scrap The view to add
 */
","/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The order and condition of many statements in the API have been changed in the late version. Thus, category is 3: Control dependency change.","As the control dependencies, including conditions for ""return"" and assignment/manipulation of shared variables like ""lp"", are changed, the behaviour of this method might have changed. For example, different cases might scrape views depending on their transient state. Thus, potential Compatibility Issue is of type 1, caused by potentially different return values or control flow."
75,"<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>",18,19,"<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>","<android.view.inputmethod.InputMethodManager: List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo,boolean)>",0,"{
    try {
        return mService.getEnabledInputMethodSubtypeList(imi, allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}","{
    try {
        return mService.getEnabledInputMethodSubtypeList(imi == null ? null : imi.getId(), allowsImplicitlySelectedSubtypes);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}",1,"/**
 * Returns a list of enabled input method subtypes for the specified input method info.
 * @param imi An input method info whose subtypes list will be returned.
 * @param allowsImplicitlySelectedSubtypes A boolean flag to allow to return the implicitly
 * selected subtypes. If an input method info doesn't have enabled subtypes, the framework
 * will implicitly enable subtypes according to the current system language.
 */
","/**
 * Returns a list of enabled input method subtypes for the specified input method info.
 * @param imi An input method info whose subtypes list will be returned.
 * @param allowsImplicitlySelectedSubtypes A boolean flag to allow to return the implicitly
 * selected subtypes. If an input method info doesn't have enabled subtypes, the framework
 * will implicitly enable subtypes according to the current system language.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter of the method mService.getEnabledInputMethodSubtypeList() has changed from imi to imi == null ? null : imi.getId(), which is a change in the return statement and dependent API, so the code change type is 1,5.","The change of the dependent API might cause the return result different compared to the early version, so the CI type is 1."
76,<android.view.Surface: void readFromParcel(Parcel)>,18,19,<android.view.Surface: void readFromParcel(Parcel)>,<android.view.Surface: void readFromParcel(Parcel)>,0,"{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    synchronized (mLock) {
        mName = source.readString();
        setNativeObjectLocked(nativeReadFromParcel(mNativeSurface, source));
    }
}","{
    if (source == null) {
        throw new IllegalArgumentException(""source must not be null"");
    }
    synchronized (mLock) {
        // nativeReadFromParcel() will either return mNativeObject, or
        // create a new native Surface and return it after reducing
        // the reference count on mNativeObject.  Either way, it is
        // not necessary to call nativeRelease() here.
        mName = source.readString();
        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is only a comment added to the code, so the code change type is 4.","As the addition of comment will not impact the behaviour of the API, there isn't a compatibility issue, so the CI type is 0."
77,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",18,19,"<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>","<android.content.ContentResolver: List<PeriodicSync> getPeriodicSyncs(Account,String)>",0,"{
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    try {
        return getContentService().getPeriodicSyncs(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    try {
        return getContentService().getPeriodicSyncs(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,"/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
","/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The deletion of throwing IllegalArgumentException means the removal of exception handling statements and control dependency statements, so the code change type is 2,3.","As exception statements were removed, different parameters (null) that originally lead to exceptions now no longer do, meaning the method might return a different value or throw an unexpected exception, making the CI type 1,2."
78,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickPendingIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(LOG_TAG, ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    if (target != null) {
        // If the pendingIntent is null, we clear the onClickListener
        OnClickListener listener = null;
        if (pendingIntent != null) {
            listener = new OnClickListener() {

                public void onClick(View v) {
                    // Find target view location in screen coordinates and
                    // fill into PendingIntent before sending.
                    final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    v.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(v, pendingIntent, intent);
                }
            };
        }
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // sense, do they mean to set a PendingIntent template for the AdapterView's children?
    if (mIsWidgetCollectionChild) {
        Log.w(LOG_TAG, ""Cannot setOnClickPendingIntent for collection item "" + ""(id: "" + viewId + "")"");
        ApplicationInfo appInfo = root.getContext().getApplicationInfo();
        // been disabled from the outset, but was left open by accident.
        if (appInfo != null && appInfo.targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            return;
        }
    }
    // If the pendingIntent is null, we clear the onClickListener
    OnClickListener listener = null;
    if (pendingIntent != null) {
        listener = new OnClickListener() {

            public void onClick(View v) {
                // Find target view location in screen coordinates and
                // fill into PendingIntent before sending.
                final Rect rect = getSourceBounds(v);
                final Intent intent = new Intent();
                intent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, intent);
            }
        };
    }
    target.setOnClickListener(listener);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The way of getting sourceBounds in the onClick function has changed from calling multiple functions to instead calling a single new function, getSourceBounds(v), so the code change type is 4,5.","The change of getSourceBounds could lead to different rects which is used as a parameter for intent.setSourceBounds(rect), and thus could potentially change the behaviours of the API which can be considered as a Compatibility Issue. Therefore, the CI type is 1."
79,"<android.content.ContentProvider: ParcelFileDescriptor openFileHelper(Uri,String)>",18,19,"<android.content.ContentProvider: ParcelFileDescriptor openFileHelper(Uri,String)>","<android.content.ContentProvider: ParcelFileDescriptor openFileHelper(Uri,String)>",0,"{
    Cursor c = query(uri, new String[] { ""_data"" }, null, null, null);
    int count = (c != null) ? c.getCount() : 0;
    if (count != 1) {
        // exception.
        if (c != null) {
            c.close();
        }
        if (count == 0) {
            throw new FileNotFoundException(""No entry for "" + uri);
        }
        throw new FileNotFoundException(""Multiple items at "" + uri);
    }
    c.moveToFirst();
    int i = c.getColumnIndex(""_data"");
    String path = (i >= 0 ? c.getString(i) : null);
    c.close();
    if (path == null) {
        throw new FileNotFoundException(""Column _data not found."");
    }
    int modeBits = ContentResolver.modeToMode(uri, mode);
    return ParcelFileDescriptor.open(new File(path), modeBits);
}","{
    Cursor c = query(uri, new String[] { ""_data"" }, null, null, null);
    int count = (c != null) ? c.getCount() : 0;
    if (count != 1) {
        // exception.
        if (c != null) {
            c.close();
        }
        if (count == 0) {
            throw new FileNotFoundException(""No entry for "" + uri);
        }
        throw new FileNotFoundException(""Multiple items at "" + uri);
    }
    c.moveToFirst();
    int i = c.getColumnIndex(""_data"");
    String path = (i >= 0 ? c.getString(i) : null);
    c.close();
    if (path == null) {
        throw new FileNotFoundException(""Column _data not found."");
    }
    int modeBits = ParcelFileDescriptor.parseMode(mode);
    return ParcelFileDescriptor.open(new File(path), modeBits);
}",1,"/**
 * Convenience for subclasses that wish to implement {@link #openFile}
 * by looking up a column named ""_data"" at the given URI.
 *
 * @param uri The URI to be opened.
 * @param mode The file mode.  May be ""r"" for read-only access,
 * ""w"" for write-only access (erasing whatever data is currently in
 * the file), ""wa"" for write-only access to append to any existing data,
 * ""rw"" for read and write access on any existing data, and ""rwt"" for read
 * and write access that truncates any existing file.
 *
 * @return Returns a new ParcelFileDescriptor that can be used by the
 * client to access the file.
 */
","/**
 * Convenience for subclasses that wish to implement {@link #openFile}
 * by looking up a column named ""_data"" at the given URI.
 *
 * @param uri The URI to be opened.
 * @param mode The file mode.  May be ""r"" for read-only access,
 * ""w"" for write-only access (erasing whatever data is currently in
 * the file), ""wa"" for write-only access to append to any existing data,
 * ""rw"" for read and write access on any existing data, and ""rwt"" for read
 * and write access that truncates any existing file.
 *
 * @return Returns a new ParcelFileDescriptor that can be used by the
 * client to access the file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API ContentResolver.modeToMode(uri, mode) was changed to ParcelFileDescriptor.parseMode(mode), a change within the return statement. Therefore, the code change is classified under categories 4 and 5.","The change in the dependent API could potentially affect the returned variable from the method openFileHelper(), leading to a potential difference in return value or type. Therefore, the compatibility issue type is 1."
81,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,18,19,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    lastHoverTarget = hoverTarget;
                    mFirstHoverTarget = hoverTarget;
                }
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}","{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@SuppressWarnings({ ""ConstantConditions"" }), @Override]","[@SuppressWarnings({ ""ConstantConditions"" }), @Override]",-1,-1,-1,-1,-1,-1,,,,
82,"<android.util.Log: int wtf(String,String,Throwable)>",18,19,"<android.util.Log: int wtf(String,String,Throwable)>","<android.util.Log: int wtf(String,String,Throwable)>",0,"{
    TerribleFailure what = new TerribleFailure(msg, tr);
    int bytes = println_native(LOG_ID_MAIN, ASSERT, tag, msg + '\n' + getStackTraceString(tr));
    sWtfHandler.onTerribleFailure(tag, what);
    return bytes;
}","{
    return wtf(LOG_ID_MAIN, tag, msg, tr, false);
}",1,"/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
","/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation has specific codes and explicit return statement which has changed entirely in the late version to call a different function/method with different parameters and return its value. The change type is 1,5.","As the implementation and return statement have changed so much, thus the runtime behaviour, return values, of the API could be different. The CI type is 1."
84,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,18,19,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,<android.widget.HeaderViewListAdapter: boolean isEnabled(int)>,0,"{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).isSelectable;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.isEnabled(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
}","{
    // Header (negative positions will throw an IndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).isSelectable;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.isEnabled(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an IndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the two versions, only the comments have changed.",There is no compatibility issue as there has been no changed in the code that would lead to different behaviours of the API between the two versions.
85,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,18,19,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,0,"{
    checkThread();
    return mProvider.saveState(outState);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""saveState"");
    return mProvider.saveState(outState);
}",1,"/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
","/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The DebugFlags.TRACE_API and Log.d(LOGTAG, ""saveState"") are added, resulting in Other statement change.","The logging statement that's been added does not impact the functional behavior of the API, thus no compatibility issues have been introduced."
86,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",18,19,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int)>",0,"{
    String path = file.getPath();
    if ((mode & MODE_READ_WRITE) == 0) {
        throw new IllegalArgumentException(""Must specify MODE_READ_ONLY, MODE_WRITE_ONLY, or MODE_READ_WRITE"");
    }
    FileDescriptor fd = Parcel.openFileDescriptor(path, mode);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    return new ParcelFileDescriptor(fd);
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and {@link #MODE_WORLD_WRITEABLE}.
 *
 * @return Returns a new ParcelFileDescriptor pointing to the given
 * file.
 *
 * @throws FileNotFoundException Throws FileNotFoundException if the given
 * file does not exist or can not be opened with the requested mode.
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The method openFileDescriptor has been replaced by openInternal, which indicates that there is a change in a dependent API, leading to type 5. Moreover, the control dependency has changed due to the removal of the 'if' condition, which leads to type 3. The implementation details within the 'if' condition are removed as well, which falls under type 4. Lastly, the way the method returns ParcelFileDescriptor has changed, leading to type 1.","The new return statement could potentially change the behavior of the API, causing it to return a different ParcelFileDescriptor, which leads to the compatibility issue type 1."
87,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,18,19,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,<android.net.http.HttpResponseCache: HttpResponseCache getInstalled()>,0,"{
    ResponseCache installed = ResponseCache.getDefault();
    return installed instanceof HttpResponseCache ? (HttpResponseCache) installed : null;
}","{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof com.android.okhttp.HttpResponseCache) {
        return new HttpResponseCache((com.android.okhttp.HttpResponseCache) installed);
    }
    return null;
}",1,"/**
 * Returns the currently-installed {@code HttpResponseCache}, or null if
 * there is no cache installed or it is not a {@code HttpResponseCache}.
 */
","/**
 * Returns the currently-installed {@code HttpResponseCache}, or null if
 * there is no cache installed or it is not a {@code HttpResponseCache}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been changed. Instead of the ternary operator, it's now using an if condition returning a new object of HttpResponseCache or null. Moreover, the dependent API ResponseCache has changed to com.android.okhttp.HttpResponseCache which also reflects a change in the dependent API.","The change in return statement and the dependent API could potentially cause the method to return a different object type of null. Therefore, there is a Compatibility Issue caused by potential different return values or types."
90,<android.view.HardwareRenderer.Gl20Renderer: boolean safelyRun(Runnable)>,18,19,<android.view.HardwareRenderer.Gl20Renderer: boolean safelyRun(Runnable)>,<android.view.HardwareRenderer.Gl20Renderer: boolean safelyRun(Runnable)>,0,"{
    boolean needsContext = true;
    if (isEnabled() && checkCurrent() != SURFACE_STATE_ERROR)
        needsContext = false;
    if (needsContext) {
        Gl20RendererEglContext managedContext = (Gl20RendererEglContext) sEglContextStorage.get();
        if (managedContext == null)
            return false;
        usePbufferSurface(managedContext.getContext());
    }
    try {
        action.run();
    } finally {
        if (needsContext) {
            sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
        }
    }
    return true;
}","{
    boolean needsContext = !isEnabled() || checkRenderContext() == SURFACE_STATE_ERROR;
    if (needsContext) {
        Gl20RendererEglContext managedContext = (Gl20RendererEglContext) sEglContextStorage.get();
        if (managedContext == null)
            return false;
        usePbufferSurface(managedContext.getContext());
    }
    try {
        action.run();
    } finally {
        if (needsContext) {
            sEgl.eglMakeCurrent(sEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
        }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5","1,2","The if condition in the early version has been replaced with a new condition to determine the value of 'needsContext' in the late version. This signifies a control dependency change. Also, the API 'checkCurrent()' used in the early version's if condition has been replaced with 'checkRenderContext()', this signifies a dependent API change. Furthermore, the return statement 'return false' might be executed under different condition due to the changed if condition, making this a return statement change. Therefore, the code change is classified under categories 1,3,5.","With the changed condition, the reutrn statement within the 'if (needsContext)' block could possibly be reached under different circumstances between the two versions, thus potentially leading to a difference in return values. Furthermore, the change of dependent API 'checkCurrent()' to 'checkRenderContext()' might affect the exception handling behaviors of the function (as we do not have information what type of exception these APIs may throw). Therefore, the potential compatibility issue consists of categories 1 and 2."
91,"<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>",18,19,"<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>","<android.app.Fragment: Fragment instantiate(Context,String,Bundle)>",0,"{
    try {
        Class<?> clazz = sClassMap.get(fname);
        if (clazz == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = context.getClassLoader().loadClass(fname);
            sClassMap.put(fname, clazz);
        }
        Fragment f = (Fragment) clazz.newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.mArguments = args;
        }
        return f;
    } catch (ClassNotFoundException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    }
}","{
    try {
        Class<?> clazz = sClassMap.get(fname);
        if (clazz == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = context.getClassLoader().loadClass(fname);
            if (!Fragment.class.isAssignableFrom(clazz)) {
                throw new InstantiationException(""Trying to instantiate a class "" + fname + "" that is not a Fragment"", new ClassCastException());
            }
            sClassMap.put(fname, clazz);
        }
        Fragment f = (Fragment) clazz.newInstance();
        if (args != null) {
            args.setClassLoader(f.getClass().getClassLoader());
            f.mArguments = args;
        }
        return f;
    } catch (ClassNotFoundException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (java.lang.InstantiationException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    } catch (IllegalAccessException e) {
        throw new InstantiationException(""Unable to instantiate fragment "" + fname + "": make sure class name exists, is public, and has an"" + "" empty constructor that is public"", e);
    }
}",1,"/**
 * Create a new instance of a Fragment with the given class name.  This is
 * the same as calling its empty constructor.
 *
 * @param context The calling context being used to instantiate the fragment.
 * This is currently just used to get its ClassLoader.
 * @param fname The class name of the fragment to instantiate.
 * @param args Bundle of arguments to supply to the fragment, which it
 * can retrieve with {@link #getArguments()}.  May be null.
 * @return Returns a new fragment instance.
 * @throws InstantiationException If there is a failure in instantiating
 * the given fragment class.  This is a runtime exception; it is not
 * normally expected to happen.
 */
","/**
 * Create a new instance of a Fragment with the given class name.  This is
 * the same as calling its empty constructor.
 *
 * @param context The calling context being used to instantiate the fragment.
 * This is currently just used to get its ClassLoader.
 * @param fname The class name of the fragment to instantiate.
 * @param args Bundle of arguments to supply to the fragment, which it
 * can retrieve with {@link #getArguments()}.  May be null.
 * @return Returns a new fragment instance.
 * @throws InstantiationException If there is a failure in instantiating
 * the given fragment class.  This is a runtime exception; it is not
 * normally expected to happen.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","In the later version, a new 'if' condition is added with a new exception throw statement, making it a control dependency change (type 3). Also, a new exception handling statement has been introduced, so the code change is of type 2 as well.","The addition of the new 'if' condition and exception could potentially lead to a different behavior and different exception handling (throwing a new exception) of the API between two versions, thus potentially leading to different return results or different exceptions. Therefore, the CI type is 1,2."
94,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",18,19,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>","<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",0,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 1",1,"A new if statement was added to cover a new profile type, BluetoothProfile.MAP, in the condition check, this constitutes a change in control dependency. Also a new return statement (""return true"") was introduced, so the code change type is 3,1.","The introduction of a new if statement may cause the method to return different values since a previously unrecognized profile is now recognized and would return true in this new condition. Thus, this change potentially leads to a compatibility issue (CI) of type 1, due to potential different return values."
95,"<android.content.ContentResolver: OutputStream openOutputStream(Uri,String)>",18,19,"<android.content.ContentResolver: OutputStream openOutputStream(Uri,String)>","<android.content.ContentResolver: OutputStream openOutputStream(Uri,String)>",0,"{
    AssetFileDescriptor fd = openAssetFileDescriptor(uri, mode);
    try {
        return fd != null ? fd.createOutputStream() : null;
    } catch (IOException e) {
        throw new FileNotFoundException(""Unable to create stream"");
    }
}","{
    AssetFileDescriptor fd = openAssetFileDescriptor(uri, mode, null);
    try {
        return fd != null ? fd.createOutputStream() : null;
    } catch (IOException e) {
        throw new FileNotFoundException(""Unable to create stream"");
    }
}",1,"/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @param mode May be ""w"", ""wa"", ""rw"", or ""rwt"".
 * @return OutputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @param mode May be ""w"", ""wa"", ""rw"", or ""rwt"".
 * @return OutputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API 'openAssetFileDescriptor' has undergone changes with the addition of a 'null' parameter. Therefore, the code change type is 5.","The change in the dependent API 'openAssetFileDescriptor' may cause the method to return a different value, due to changes in 'fd'. Therefore, the CI type is 1."
99,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",18,19,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(PhoneConstants.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}","{
    if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_CONNECTED_TO_PROVISIONING_APN)) {
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(mApnType, apnType)) {
            return;
        }
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType + "" apnName="" + apnName);
        }
        // Make us in the connecting state until we make a new TYPE_MOBILE_PROVISIONING
        mMobileDataState = PhoneConstants.DataState.CONNECTING;
        updateLinkProperitesAndCapatilities(intent);
        mNetworkInfo.setIsConnectedToProvisioningNetwork(true);
        // Change state to SUSPENDED so setDetailedState
        // sends EVENT_STATE_CHANGED to connectivityService
        setDetailedState(DetailedState.SUSPENDED, """", apnName);
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" apnType="" + apnType);
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    updateLinkProperitesAndCapatilities(intent);
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
            if (VDBG) {
                Slog.d(TAG, ""TelephonyMgr.DataConnectionStateChanged"");
                if (mNetworkInfo != null) {
                    Slog.d(TAG, ""NetworkInfo = "" + mNetworkInfo.toString());
                    Slog.d(TAG, ""subType = "" + String.valueOf(mNetworkInfo.getSubtype()));
                    Slog.d(TAG, ""subType = "" + mNetworkInfo.getSubtypeName());
                }
                if (mLinkProperties != null) {
                    Slog.d(TAG, ""LinkProperties = "" + mLinkProperties.toString());
                } else {
                    Slog.d(TAG, ""LinkProperties = "");
                }
                if (mLinkCapabilities != null) {
                    Slog.d(TAG, ""LinkCapabilities = "" + mLinkCapabilities.toString());
                } else {
                    Slog.d(TAG, ""LinkCapabilities = "");
                }
            }
            /* lets not sample traffic data across state changes */
            mSamplingDataTracker.resetSamplingData();
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        // Assume this isn't a provisioning network.
        mNetworkInfo.setIsConnectedToProvisioningNetwork(false);
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Broadcast received: "" + intent.getAction() + "" reason="" + reason == null ? ""null"" : reason);
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The code change contains control dependency changes (If conditions and switch case modifications) and other statement changes (variable assignments, add new method 'updateLinkProperitesAndCapatilities(intent)', etc.). Therefore, the code change types are 3 and 4.","The changes in the control statements and the introduction of the new method 'updateLinkProperitesAndCapatilities(intent)' could lead to different return values or behaviors when calling this API in different versions. Thus, there is a potential compatibility issue of type 1."
102,<android.util.SparseArray: int indexOfKey(int)>,18,19,<android.util.SparseArray: int indexOfKey(int)>,<android.util.SparseArray: int indexOfKey(int)>,0,"{
    if (mGarbage) {
        gc();
    }
    return binarySearch(mKeys, 0, mSize, key);
}","{
    if (mGarbage) {
        gc();
    }
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been modified from 'return binarySearch(mKeys, 0, mSize, key);' to 'return ContainerHelpers.binarySearch(mKeys, mSize, key);'. Also, the dependent API 'binarySearch()' has been changed to 'ContainerHelpers.binarySearch()', so the code change type is 1,5.","The API 'binarySearch()' has been modified, which will make this method potentially return different values. Thus, the CI type is 1."
104,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,18,19,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,<android.bluetooth.BluetoothAdapter: BluetoothDevice getRemoteDevice(byte[])>,0,"{
    if (address == null || address.length != 6) {
        throw new IllegalArgumentException(""Bluetooth address must have 6 bytes"");
    }
    return new BluetoothDevice(String.format(""%02X:%02X:%02X:%02X:%02X:%02X"", address[0], address[1], address[2], address[3], address[4], address[5]));
}","{
    if (address == null || address.length != 6) {
        throw new IllegalArgumentException(""Bluetooth address must have 6 bytes"");
    }
    return new BluetoothDevice(String.format(Locale.US, ""%02X:%02X:%02X:%02X:%02X:%02X"", address[0], address[1], address[2], address[3], address[4], address[5]));
}",1,"/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method
 * expects the address in network byte order (MSB first).
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address Bluetooth MAC address (6 bytes)
 * @throws IllegalArgumentException if address is invalid
 */
","/**
 * Get a {@link BluetoothDevice} object for the given Bluetooth hardware
 * address.
 * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method
 * expects the address in network byte order (MSB first).
 * <p>A {@link BluetoothDevice} will always be returned for a valid
 * hardware address, even if this adapter has never seen that device.
 *
 * @param address Bluetooth MAC address (6 bytes)
 * @throws IllegalArgumentException if address is invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent function String.format has an additional parameter ""Locale.US"" in the later version, so the change type is 5.","The change in the dependent function could potentially affect its return value, thus leading to different return values of the getRemoteDevice API, the CI type is 1."
107,<android.inputmethodservice.IInputMethodWrapper: void revokeSession(IInputMethodSession)>,18,19,<android.inputmethodservice.IInputMethodWrapper: void revokeSession(IInputMethodSession)>,<android.inputmethodservice.IInputMethodWrapper: void revokeSession(IInputMethodSession)>,0,"{
    try {
        InputMethodSession ls = ((IInputMethodSessionWrapper) session).getInternalInputMethodSession();
        mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_REVOKE_SESSION, ls));
    } catch (ClassCastException e) {
        Log.w(TAG, ""Incoming session not of correct type: "" + session, e);
    }
}","{
    try {
        InputMethodSession ls = ((IInputMethodSessionWrapper) session).getInternalInputMethodSession();
        if (ls == null) {
            Log.w(TAG, ""Session is already finished: "" + session);
            return;
        }
        mCaller.executeOrSendMessage(mCaller.obtainMessageO(DO_REVOKE_SESSION, ls));
    } catch (ClassCastException e) {
        Log.w(TAG, ""Incoming session not of correct type: "" + session, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The change here involves introduction of new control dependency (if condition) and a return statement inside that block, so code change type is 1,3.","The new return statement under the if condition can potentially make the late version of API return earlier than the early version, which means that it might send a different variable to the caller under some situations. Thus, this could cause a compatibility issue type 1."
108,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,18,19,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,<android.view.HardwareRenderer.GlRenderer: boolean initialize(Surface)>,0,"{
    if (isRequested() && !isEnabled()) {
        initializeEgl();
        mGl = createEglSurface(surface);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                    mCanvas.setName(mName);
                }
                setEnabled(true);
            }
            return mCanvas != null;
        }
    }
    return false;
}","{
    if (isRequested() && !isEnabled()) {
        boolean contextCreated = initializeEgl();
        mGl = createEglSurface(surface);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                    mCanvas.setName(mName);
                }
                setEnabled(true);
                if (contextCreated) {
                    initAtlas();
                }
            }
            return mCanvas != null;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation has an additional invocation of initAtlas() method in a new condition block 'if (contextCreated)', and also has added a boolean contextCreated to capture the value returned from initializeEgl(). So, three types of changes occurred here - changes in return statement (1), changes in control dependency (3), and other statement changes (4).","A new condition block 'if (contextCreated)' has been introduced which leads to a new function call initAtlas(). This could potentially cause the function to return a different value (since initAtlas() could affect mCanvas which is our return value), leading to a potential Compatibility Issue of type 1."
109,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",18,19,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.mChildTransformation.clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.mChildTransformation;
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final boolean hasTransform = parent.getChildStaticTransformation(this, parent.mChildTransformation);
            if (hasTransform) {
                final int transformType = parent.mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? parent.mChildTransformation : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : getAlpha();
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties && cache == null) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        parent.invalidate(true);
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties && cache == null) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
111,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",18,19,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mkdirs:
            {
                data.enforceInterface(DESCRIPTOR);
                String callingPkg = data.readString();
                String path = data.readString();
                int result = mkdirs(callingPkg, path);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
114,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,18,19,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,<android.webkit.CookieSyncManager: CookieSyncManager getInstance()>,0,"{
    checkInstanceIsCreated();
    return sRef;
}","{
    checkInstanceIsAllowed();
    if (sRef == null) {
        sRef = new CookieSyncManager();
    }
    return sRef;
}",1,"/**
 * Singleton access to a {@link CookieSyncManager}. An
 * IllegalStateException will be thrown if
 * {@link CookieSyncManager#createInstance(Context)} is not called before.
 *
 * @return CookieSyncManager
 */
","/**
 * Singleton access to a {@link CookieSyncManager}. An
 * IllegalStateException will be thrown if
 * {@link CookieSyncManager#createInstance(Context)} is not called before.
 *
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late implementation, a new control dependency is added (if null check on sRef). Also, the method called before returning sRef changed from checkInstanceIsCreated() to checkInstanceIsAllowed(). Hence, the code change type is 1,3.","The return value of the function is potentially different due to the added null check and the change in methods that are called (from checkInstanceIsCreated() to checkInstanceIsAllowed()). Hence, it is classified as a compatibility issue of type 1."
115,"<android.util.SparseLongArray: long get(int,long)>",18,19,"<android.util.SparseLongArray: long get(int,long)>","<android.util.SparseLongArray: long get(int,long)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}",1,"/**
 * Gets the long mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
","/**
 * Gets the long mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method 'binarySearch()' that the current API relies on has changed from 'binarySearch(mKeys, 0, mSize, key)' to 'ContainerHelpers.binarySearch(mKeys, mSize, key)'. Therefore, the code change type is 5.","Because the 'binarySearch()' method has changed, this could potentially lead to a different 'i' value, and therefore the result of return mValues[i] could be different in the late version compared to the early version. Thus, the CI type is 1."
116,<android.net.LocalServerSocket: LocalSocket accept()>,18,19,<android.net.LocalServerSocket: LocalSocket accept()>,<android.net.LocalServerSocket: LocalSocket accept()>,0,"{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return new LocalSocket(acceptedImpl);
}","{
    LocalSocketImpl acceptedImpl = new LocalSocketImpl();
    impl.accept(acceptedImpl);
    return new LocalSocket(acceptedImpl, LocalSocket.SOCKET_UNKNOWN);
}",1,"/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @return a socket representing the new connection.
 * @throws IOException
 */
","/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @return a socket representing the new connection.
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from new LocalSocket(acceptedImpl) to new LocalSocket(acceptedImpl, LocalSocket.SOCKET_UNKNOWN) and the method signature of LocalSocket() has also changed. So the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
118,"<android.text.AndroidBidi: Directions directions(int,byte[],int,char[],int,int)>",18,19,"<android.text.AndroidBidi: Directions directions(int,byte[],int,char[],int,int)>","<android.text.AndroidBidi: Directions directions(int,byte[],int,char[],int,int)>",0,"{
    int baseLevel = dir == Layout.DIR_LEFT_TO_RIGHT ? 0 : 1;
    int curLevel = levels[lstart];
    int minLevel = curLevel;
    int runCount = 1;
    for (int i = lstart + 1, e = lstart + len; i < e; ++i) {
        int level = levels[i];
        if (level != curLevel) {
            curLevel = level;
            ++runCount;
        }
    }
    // add final run for trailing counter-directional whitespace
    int visLen = len;
    if ((curLevel & 1) != (baseLevel & 1)) {
        // look for visible end
        while (--visLen >= 0) {
            char ch = chars[cstart + visLen];
            if (ch == '\n') {
                --visLen;
                break;
            }
            if (ch != ' ' && ch != '\t') {
                break;
            }
        }
        ++visLen;
        if (visLen != len) {
            ++runCount;
        }
    }
    if (runCount == 1 && minLevel == baseLevel) {
        // we're done, only one run on this line
        if ((minLevel & 1) != 0) {
            return Layout.DIRS_ALL_RIGHT_TO_LEFT;
        }
        return Layout.DIRS_ALL_LEFT_TO_RIGHT;
    }
    int[] ld = new int[runCount * 2];
    int maxLevel = minLevel;
    int levelBits = minLevel << Layout.RUN_LEVEL_SHIFT;
    {
        // Start of first pair is always 0, we write
        // length then start at each new run, and the
        // last run length after we're done.
        int n = 1;
        int prev = lstart;
        curLevel = minLevel;
        for (int i = lstart, e = lstart + visLen; i < e; ++i) {
            int level = levels[i];
            if (level != curLevel) {
                curLevel = level;
                if (level > maxLevel) {
                    maxLevel = level;
                } else if (level < minLevel) {
                    minLevel = level;
                }
                // XXX ignore run length limit of 2^RUN_LEVEL_SHIFT
                ld[n++] = (i - prev) | levelBits;
                ld[n++] = i - lstart;
                levelBits = curLevel << Layout.RUN_LEVEL_SHIFT;
                prev = i;
            }
        }
        ld[n] = (lstart + visLen - prev) | levelBits;
        if (visLen < len) {
            ld[++n] = visLen;
            ld[++n] = (len - visLen) | (baseLevel << Layout.RUN_LEVEL_SHIFT);
        }
    }
    // See if we need to swap any runs.
    // If the min level run direction doesn't match the base
    // direction, we always need to swap (at this point
    // we have more than one run).
    // Otherwise, we don't need to swap the lowest level.
    // Since there are no logically adjacent runs at the same
    // level, if the max level is the same as the (new) min
    // level, we have a series of alternating levels that
    // is already in order, so there's no more to do.
    // 
    boolean swap;
    if ((minLevel & 1) == baseLevel) {
        minLevel += 1;
        swap = maxLevel > minLevel;
    } else {
        swap = runCount > 1;
    }
    if (swap) {
        for (int level = maxLevel - 1; level >= minLevel; --level) {
            for (int i = 0; i < ld.length; i += 2) {
                if (levels[ld[i]] >= level) {
                    int e = i + 2;
                    while (e < ld.length && levels[ld[e]] >= level) {
                        e += 2;
                    }
                    for (int low = i, hi = e - 2; low < hi; low += 2, hi -= 2) {
                        int x = ld[low];
                        ld[low] = ld[hi];
                        ld[hi] = x;
                        x = ld[low + 1];
                        ld[low + 1] = ld[hi + 1];
                        ld[hi + 1] = x;
                    }
                    i = e + 2;
                }
            }
        }
    }
    return new Directions(ld);
}","{
    if (len == 0) {
        return Layout.DIRS_ALL_LEFT_TO_RIGHT;
    }
    int baseLevel = dir == Layout.DIR_LEFT_TO_RIGHT ? 0 : 1;
    int curLevel = levels[lstart];
    int minLevel = curLevel;
    int runCount = 1;
    for (int i = lstart + 1, e = lstart + len; i < e; ++i) {
        int level = levels[i];
        if (level != curLevel) {
            curLevel = level;
            ++runCount;
        }
    }
    // add final run for trailing counter-directional whitespace
    int visLen = len;
    if ((curLevel & 1) != (baseLevel & 1)) {
        // look for visible end
        while (--visLen >= 0) {
            char ch = chars[cstart + visLen];
            if (ch == '\n') {
                --visLen;
                break;
            }
            if (ch != ' ' && ch != '\t') {
                break;
            }
        }
        ++visLen;
        if (visLen != len) {
            ++runCount;
        }
    }
    if (runCount == 1 && minLevel == baseLevel) {
        // we're done, only one run on this line
        if ((minLevel & 1) != 0) {
            return Layout.DIRS_ALL_RIGHT_TO_LEFT;
        }
        return Layout.DIRS_ALL_LEFT_TO_RIGHT;
    }
    int[] ld = new int[runCount * 2];
    int maxLevel = minLevel;
    int levelBits = minLevel << Layout.RUN_LEVEL_SHIFT;
    {
        // Start of first pair is always 0, we write
        // length then start at each new run, and the
        // last run length after we're done.
        int n = 1;
        int prev = lstart;
        curLevel = minLevel;
        for (int i = lstart, e = lstart + visLen; i < e; ++i) {
            int level = levels[i];
            if (level != curLevel) {
                curLevel = level;
                if (level > maxLevel) {
                    maxLevel = level;
                } else if (level < minLevel) {
                    minLevel = level;
                }
                // XXX ignore run length limit of 2^RUN_LEVEL_SHIFT
                ld[n++] = (i - prev) | levelBits;
                ld[n++] = i - lstart;
                levelBits = curLevel << Layout.RUN_LEVEL_SHIFT;
                prev = i;
            }
        }
        ld[n] = (lstart + visLen - prev) | levelBits;
        if (visLen < len) {
            ld[++n] = visLen;
            ld[++n] = (len - visLen) | (baseLevel << Layout.RUN_LEVEL_SHIFT);
        }
    }
    // See if we need to swap any runs.
    // If the min level run direction doesn't match the base
    // direction, we always need to swap (at this point
    // we have more than one run).
    // Otherwise, we don't need to swap the lowest level.
    // Since there are no logically adjacent runs at the same
    // level, if the max level is the same as the (new) min
    // level, we have a series of alternating levels that
    // is already in order, so there's no more to do.
    // 
    boolean swap;
    if ((minLevel & 1) == baseLevel) {
        minLevel += 1;
        swap = maxLevel > minLevel;
    } else {
        swap = runCount > 1;
    }
    if (swap) {
        for (int level = maxLevel - 1; level >= minLevel; --level) {
            for (int i = 0; i < ld.length; i += 2) {
                if (levels[ld[i]] >= level) {
                    int e = i + 2;
                    while (e < ld.length && levels[ld[e]] >= level) {
                        e += 2;
                    }
                    for (int low = i, hi = e - 2; low < hi; low += 2, hi -= 2) {
                        int x = ld[low];
                        ld[low] = ld[hi];
                        ld[hi] = x;
                        x = ld[low + 1];
                        ld[low + 1] = ld[hi + 1];
                        ld[hi + 1] = x;
                    }
                    i = e + 2;
                }
            }
        }
    }
    return new Directions(ld);
}",1,"/**
 * Returns run direction information for a line within a paragraph.
 *
 * @param dir base line direction, either Layout.DIR_LEFT_TO_RIGHT or
 * Layout.DIR_RIGHT_TO_LEFT
 * @param levels levels as returned from {@link #bidi}
 * @param lstart start of the line in the levels array
 * @param chars the character array (used to determine whitespace)
 * @param cstart the start of the line in the chars array
 * @param len the length of the line
 * @return the directions
 */
","/**
 * Returns run direction information for a line within a paragraph.
 *
 * @param dir base line direction, either Layout.DIR_LEFT_TO_RIGHT or
 * Layout.DIR_RIGHT_TO_LEFT
 * @param levels levels as returned from {@link #bidi}
 * @param lstart start of the line in the levels array
 * @param chars the character array (used to determine whitespace)
 * @param cstart the start of the line in the chars array
 * @param len the length of the line
 * @return the directions
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new if statement 'if (len == 0)' is introduced at the beginning of the late version and a new return statement 'return Layout.DIRS_ALL_LEFT_TO_RIGHT;' is brought in within it, so the code change type is 1,3.","The new 'if' statement introduces a new return point at the beginning of the method. This means if 'len = 0' the method output could potentially be different in the late version comparing to the early one, given the same input. This introduced a Compatibility Issue and the CI type is 1."
119,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",18,19,"<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>","<android.content.ContentProviderClient: AssetFileDescriptor openAssetFile(Uri,String)>",0,"{
    try {
        return mContentProvider.openAssetFile(mPackageName, url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    return openAssetFile(url, mode, null);
}",1,"/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The whole method body has been replaced with a call to a different overloaded version of the same method. The return statement was changed, the exception handling was removed, and a new method call was introduced, so the code change type is 1,4,5.","The original exception handling behavior was removed and a new method was called which is not handling the exception that was previously being handled, so the method will behave differently in the case of an exception; thus the CI type is 2. Furthermore, it's not clear what the new method does, so it might return a different value or even type, which would cause CI type 1."
120,<android.view.View: Handler getHandler()>,18,19,<android.view.View: Handler getHandler()>,<android.view.View: Handler getHandler()>,0,"{
    if (mAttachInfo != null) {
        return mAttachInfo.mHandler;
    }
    return null;
}","{
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler;
    }
    return null;
}",1,"/**
 * @return A handler associated with the thread running the View. This
 * handler can be used to pump events in the UI events queue.
 */
","/**
 * @return A handler associated with the thread running the View. This
 * handler can be used to pump events in the UI events queue.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The API's early implementation directly uses the mAttachInfo variable, whereas in the late implementation a local variable attachInfo is introduced and used. This represents a re-factoring of the method, thus the change type is 4. ","The change is a benign refactoring without essentially changing the behavior or return value of the method, therefore there is no compatibility issue - CI type 0."
121,"<android.os.Binder: void dumpAsync(FileDescriptor,String[])>",18,19,"<android.os.Binder: void dumpAsync(FileDescriptor,String[])>","<android.os.Binder: void dumpAsync(FileDescriptor,String[])>",0,"{
    final FileOutputStream fout = new FileOutputStream(fd);
    final PrintWriter pw = new PrintWriter(fout);
    Thread thr = new Thread(""Binder.dumpAsync"") {

        public void run() {
            try {
                dump(fd, pw, args);
            } finally {
                pw.flush();
            }
        }
    };
    thr.start();
}","{
    final FileOutputStream fout = new FileOutputStream(fd);
    final PrintWriter pw = new FastPrintWriter(fout);
    Thread thr = new Thread(""Binder.dumpAsync"") {

        public void run() {
            try {
                dump(fd, pw, args);
            } finally {
                pw.flush();
            }
        }
    };
    thr.start();
}",1,"/**
 * Like {@link #dump(FileDescriptor, String[])}, but ensures the target
 * executes asynchronously.
 */
","/**
 * Like {@link #dump(FileDescriptor, String[])}, but ensures the target
 * executes asynchronously.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The PrintWriter has been replaced by the FastPrintWriter. Since changing the PrintWriter to FastPrintWriter doesn't affect the flow of the program, the code change type is 4.","Although the PrintWriter is changed into FastPrintWriter, the overall behaviour of the method remains undifferentiated, no potential different return values or exceptions are introduced. Therefore, no Compatibility Issue exists."
124,"<android.widget.ListPopupWindow: boolean onKeyUp(int,KeyEvent)>",18,19,"<android.widget.ListPopupWindow: boolean onKeyUp(int,KeyEvent)>","<android.widget.ListPopupWindow: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (isShowing() && mDropDownList.getSelectedItemPosition() >= 0) {
        boolean consumed = mDropDownList.onKeyUp(keyCode, event);
        if (consumed) {
            switch(keyCode) {
                // from the drop down as its content
                case KeyEvent.KEYCODE_ENTER:
                case KeyEvent.KEYCODE_DPAD_CENTER:
                    dismiss();
                    break;
            }
        }
        return consumed;
    }
    return false;
}","{
    if (isShowing() && mDropDownList.getSelectedItemPosition() >= 0) {
        boolean consumed = mDropDownList.onKeyUp(keyCode, event);
        if (consumed && KeyEvent.isConfirmKey(keyCode)) {
            // if the list accepts the key events and the key event was a click, the text view
            // gets the selected item from the drop down as its content
            dismiss();
        }
        return consumed;
    }
    return false;
}",1,"/**
 * Filter key down events. By forwarding key up events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyUp
 * @param event event param passed to the host view's onKeyUp
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
","/**
 * Filter key down events. By forwarding key up events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyUp
 * @param event event param passed to the host view's onKeyUp
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The 'if' condition and 'switch' statement in the early version have changed to a single 'if' statement in the late version, so the code change type is 3.","Because of the change in control structure, the condition for executing the 'dismiss' function has changed, thus potentially altering the return value of the function. So, the CI type is 1."
128,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",18,19,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,float,float,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,5",2,"The exception handling changed from a direct 'IllegalArgumentException' throw to a method call 'throwIfCannotDraw()' which might throw an unknown exception. Also, the dependent API 'bitmap.isRecycled()' is replaced by a new method 'throwIfCannotDraw()'. Therefore, the change type is 2,5.","As the way of exception handling has changed, it might cause different exceptions being thrown from version 18 to 19; and we cannot guarantee the new method 'throwIfCannotDraw()' throws the same exception as before. Therefore, the CI type is 2."
129,<android.net.Uri: String decode(String)>,18,19,<android.net.Uri: String decode(String)>,<android.net.Uri: String decode(String)>,0,"{
    if (s == null) {
        return null;
    }
    return UriCodec.decode(s, false, Charsets.UTF_8, false);
}","{
    if (s == null) {
        return null;
    }
    return UriCodec.decode(s, false, StandardCharsets.UTF_8, false);
}",1,"/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
","/**
 * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.
 * Replaces invalid octets with the unicode replacement character
 * (""\\uFFFD"").
 *
 * @param s encoded string to decode
 * @return the given string with escaped octets decoded, or null if
 * s is null
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The dependent API has been changed from Charsets.UTF_8 to StandardCharsets.UTF_8 and the return statement that called it also has been changed. So, the change type is 1,5.","Even though the dependent API has been changed, both Charsets.UTF_8 and StandardCharsets.UTF_8 are constants that represent the UTF_8 Charset. Therefore, they have the same value and using one instead of the other will not change the application's behavior or result. The API is still compatible despite this change and it would not cause any incompatibility issue. So, the CI type is 0; hence, no compatibility issue exist."
130,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",18,19,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The dependent API setNpnProtocols(mNpnProtocols) has been replaced to setAlpnProtocols(mAlpnProtocols), so the change type is 4.","Due to the replacement of the function call, the socket 's' may have a different configuration, thus when 's' is returned, the returned socket may behave differently than before. Therefore, the CI type is 1."
132,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,18,19,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getChild(int)>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, FLAG_PREFETCH_DESCENDANTS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}",1,"/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
","/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as a new parameter 'false' has been added to the method call findAccessibilityNodeInfoByAccessibilityId(), also the dependent API 'findAccessibilityNodeInfoByAccessibilityId()' has been changed, so the code change type is 1,5.","The change in the return statement could potentially make the API return a different value, so the CI type is 1."
134,<android.view.Surface: Canvas lockCanvas(Rect)>,18,19,<android.view.Surface: Canvas lockCanvas(Rect)>,<android.view.Surface: Canvas lockCanvas(Rect)>,0,"{
    synchronized (mLock) {
        checkNotReleasedLocked();
        nativeLockCanvas(mNativeSurface, mCanvas, inOutDirty);
        return mCanvas;
    }
}","{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalStateException(""Surface was already locked"");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}",1,"/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 */
","/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","The late version introduced a new control flow for throwing an IllegalStateException and used a different parameter (mNativeObject instead of mNativeSurface) in the call to nativeLockCanvas(). So, the code change types are 2,3.","The change of control flow might cause a different exception to be thrown in comparison to the early version, and the change of parameter in the method nativeLockCanvas() might lead to returning a different canvas, so the CI types are 1,2."
135,"<android.widget.RemoteViews.ViewPaddingAction: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.ViewPaddingAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ViewPaddingAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final Context context = root.getContext();
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    target.setPadding(left, top, right, bottom);
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    target.setPadding(left, top, right, bottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The line ""final Context context = root.getContext();"" in the early version is deleted in the late version. Hence, the code change type is 4.","The removal of the line ""final Context context = root.getContext();"" does not affect the overall behavior of the method. There is no return value change or exception handling change. Therefore, the CI type is 0, meaning no Compatibility Issue exists."
136,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",18,19,"<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>","<android.text.method.QwertyKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",0,"{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(event.getMetaState() | getMetaState(content));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if (c == i || c == Character.toUpperCase(i) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                    dead = false;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}","{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
        if (selStart < 0 || selEnd < 0) {
            selStart = selEnd = 0;
            Selection.setSelection(content, 0, 0);
        }
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // QWERTY keyboard normal case
    int i = event.getUnicodeChar(getMetaState(content, event));
    if (!mFullKeyboard) {
        int count = event.getRepeatCount();
        if (count > 0 && selStart == selEnd && selStart > 0) {
            char c = content.charAt(selStart - 1);
            if (c == i || c == Character.toUpperCase(i) && view != null) {
                if (showCharacterPicker(view, content, c, false, count)) {
                    resetMetaState(content);
                    return true;
                }
            }
        }
    }
    if (i == KeyCharacterMap.PICKER_DIALOG_INPUT) {
        if (view != null) {
            showCharacterPicker(view, content, KeyCharacterMap.PICKER_DIALOG_INPUT, true, 1);
        }
        resetMetaState(content);
        return true;
    }
    if (i == KeyCharacterMap.HEX_INPUT) {
        int start;
        if (selStart == selEnd) {
            start = selEnd;
            while (start > 0 && selEnd - start < 4 && Character.digit(content.charAt(start - 1), 16) >= 0) {
                start--;
            }
        } else {
            start = selStart;
        }
        int ch = -1;
        try {
            String hex = TextUtils.substring(content, start, selEnd);
            ch = Integer.parseInt(hex, 16);
        } catch (NumberFormatException nfe) {
        }
        if (ch >= 0) {
            selStart = start;
            Selection.setSelection(content, selStart, selEnd);
            i = ch;
        } else {
            i = 0;
        }
    }
    if (i != 0) {
        boolean dead = false;
        if ((i & KeyCharacterMap.COMBINING_ACCENT) != 0) {
            dead = true;
            i = i & KeyCharacterMap.COMBINING_ACCENT_MASK;
        }
        if (activeStart == selStart && activeEnd == selEnd) {
            boolean replace = false;
            if (selEnd - selStart - 1 == 0) {
                char accent = content.charAt(selStart);
                int composed = event.getDeadChar(accent, i);
                if (composed != 0) {
                    i = composed;
                    replace = true;
                    dead = false;
                }
            }
            if (!replace) {
                Selection.setSelection(content, selEnd);
                content.removeSpan(TextKeyListener.ACTIVE);
                selStart = selEnd;
            }
        }
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && Character.isLowerCase(i) && TextKeyListener.shouldCap(mAutoCap, content, selStart)) {
            int where = content.getSpanEnd(TextKeyListener.CAPPED);
            int flags = content.getSpanFlags(TextKeyListener.CAPPED);
            if (where == selStart && (((flags >> 16) & 0xFFFF) == i)) {
                content.removeSpan(TextKeyListener.CAPPED);
            } else {
                flags = i << 16;
                i = Character.toUpperCase(i);
                if (selStart == 0)
                    content.setSpan(TextKeyListener.CAPPED, 0, 0, Spannable.SPAN_MARK_MARK | flags);
                else
                    content.setSpan(TextKeyListener.CAPPED, selStart - 1, selStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | flags);
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, String.valueOf((char) i));
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (oldStart < selEnd) {
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            if (dead) {
                Selection.setSelection(content, oldStart, selEnd);
                content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        adjustMetaAfterKeypress(content);
        if ((pref & TextKeyListener.AUTO_TEXT) != 0 && mAutoText && (i == ' ' || i == '\t' || i == '\n' || i == ',' || i == '.' || i == '!' || i == '?' || i == '""' || Character.getType(i) == Character.END_PUNCTUATION) && content.getSpanEnd(TextKeyListener.INHIBIT_REPLACEMENT) != oldStart) {
            int x;
            for (x = oldStart; x > 0; x--) {
                char c = content.charAt(x - 1);
                if (c != '\'' && !Character.isLetter(c)) {
                    break;
                }
            }
            String rep = getReplacement(content, x, oldStart, view);
            if (rep != null) {
                Replaced[] repl = content.getSpans(0, content.length(), Replaced.class);
                for (int a = 0; a < repl.length; a++) content.removeSpan(repl[a]);
                char[] orig = new char[oldStart - x];
                TextUtils.getChars(content, x, oldStart, orig, 0);
                content.setSpan(new Replaced(orig), x, oldStart, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                content.replace(x, oldStart, rep);
            }
        }
        if ((pref & TextKeyListener.AUTO_PERIOD) != 0 && mAutoText) {
            selEnd = Selection.getSelectionEnd(content);
            if (selEnd - 3 >= 0) {
                if (content.charAt(selEnd - 1) == ' ' && content.charAt(selEnd - 2) == ' ') {
                    char c = content.charAt(selEnd - 3);
                    for (int j = selEnd - 3; j > 0; j--) {
                        if (c == '""' || Character.getType(c) == Character.END_PUNCTUATION) {
                            c = content.charAt(j - 1);
                        } else {
                            break;
                        }
                    }
                    if (Character.isLetter(c) || Character.isDigit(c)) {
                        content.replace(selEnd - 2, selEnd - 1, ""."");
                    }
                }
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_DEL && (event.hasNoModifiers() || event.hasModifiers(KeyEvent.META_ALT_ON)) && selStart == selEnd) {
        // special backspace case for undoing autotext
        int consider = 1;
        if (content.getSpanEnd(TextKeyListener.LAST_TYPED) == selStart) {
            if (content.charAt(selStart - 1) != '\n')
                consider = 2;
        }
        Replaced[] repl = content.getSpans(selStart - consider, selStart, Replaced.class);
        if (repl.length > 0) {
            int st = content.getSpanStart(repl[0]);
            int en = content.getSpanEnd(repl[0]);
            String old = new String(repl[0].mText);
            content.removeSpan(repl[0]);
            // itself).
            if (selStart >= en) {
                content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en, en, Spannable.SPAN_POINT_POINT);
                content.replace(st, en, old);
                en = content.getSpanStart(TextKeyListener.INHIBIT_REPLACEMENT);
                if (en - 1 >= 0) {
                    content.setSpan(TextKeyListener.INHIBIT_REPLACEMENT, en - 1, en, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                } else {
                    content.removeSpan(TextKeyListener.INHIBIT_REPLACEMENT);
                }
                adjustMetaAfterKeypress(content);
            } else {
                adjustMetaAfterKeypress(content);
                return super.onKeyDown(view, content, keyCode, event);
            }
            return true;
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
138,<android.app.Notification.Builder: Notification build()>,18,19,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    final Notification n;
    if (mStyle != null) {
        n = mStyle.build();
    } else {
        n = buildUnstyled();
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}","{
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"There is a change in the control dependency in this code. In the early version, a condition checks if 'mStyle' is not null and then assigns either mStyle.build() or buildUnstyled() to 'n'. However, in the later version, 'n' is directly assigned buildUnstyled() and if 'mStyle' is not null, the buildStyled(n) of mStyle is assigned to 'n'. This changes the way the object 'n' is created and thus can be classified as a Control Dependency change (3) and Return Statement change (1).",The change in the creation of 'n' between the versions can lead to potential changes in the returned value of the function and thus a compatibility issue could exist due to different return values or types (1).
140,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,18,19,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getLabeledBy()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
","/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"In the `findAccessibilityNodeInfoByAccessibilityId` function, a new false parameter is added, which means the dependent API has been changed. Therefore, the code change type is 5.","According to the introduced new false parameter in the `findAccessibilityNodeInfoByAccessibilityId` function, it is possible that this method may return different value or object causing a compatibility issue. So, the CI type is 1."
144,<android.view.HardwareRenderer.GlRenderer: boolean loadSystemProperties(Surface)>,18,19,<android.view.HardwareRenderer.GlRenderer: boolean loadSystemProperties(Surface)>,<android.view.HardwareRenderer.GlRenderer: boolean loadSystemProperties(Surface)>,0,"{
    boolean value;
    boolean changed = false;
    String profiling = SystemProperties.get(PROFILE_PROPERTY);
    int graphType = Arrays.binarySearch(VISUALIZERS, profiling);
    value = graphType >= 0;
    if (graphType != mProfileVisualizerType) {
        changed = true;
        mProfileVisualizerType = graphType;
        mProfileShapes = null;
        mProfilePaint = null;
        if (value) {
            mDebugDataProvider = new DrawPerformanceDataProvider(graphType);
        } else {
            mDebugDataProvider = null;
        }
    }
    // console profiling only is enabled
    if (!value) {
        value = Boolean.parseBoolean(profiling);
    }
    if (value != mProfileEnabled) {
        changed = true;
        mProfileEnabled = value;
        if (mProfileEnabled) {
            Log.d(LOG_TAG, ""Profiling hardware renderer"");
            int maxProfileFrames = SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY, PROFILE_MAX_FRAMES);
            mProfileData = new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
            for (int i = 0; i < mProfileData.length; i += PROFILE_FRAME_DATA_COUNT) {
                mProfileData[i] = mProfileData[i + 1] = mProfileData[i + 2] = -1;
            }
            mProfileLock = new ReentrantLock();
        } else {
            mProfileData = null;
            mProfileLock = null;
            mProfileVisualizerType = -1;
        }
        mProfileCurrentFrame = -PROFILE_FRAME_DATA_COUNT;
    }
    value = SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY, false);
    if (value != mDebugDirtyRegions) {
        changed = true;
        mDebugDirtyRegions = value;
        if (mDebugDirtyRegions) {
            Log.d(LOG_TAG, ""Debugging dirty regions"");
        }
    }
    value = SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY, false);
    if (value != mShowOverdraw) {
        changed = true;
        mShowOverdraw = value;
    }
    if (nLoadProperties()) {
        changed = true;
    }
    return changed;
}","{
    boolean value;
    boolean changed = false;
    String profiling = SystemProperties.get(PROFILE_PROPERTY);
    int graphType = search(VISUALIZERS, profiling);
    value = graphType >= 0;
    if (graphType != mProfileVisualizerType) {
        changed = true;
        mProfileVisualizerType = graphType;
        mProfileShapes = null;
        mProfilePaint = null;
        if (value) {
            mDebugDataProvider = new DrawPerformanceDataProvider(graphType);
        } else {
            mDebugDataProvider = null;
        }
    }
    // console profiling only is enabled
    if (!value) {
        value = Boolean.parseBoolean(profiling);
    }
    if (value != mProfileEnabled) {
        changed = true;
        mProfileEnabled = value;
        if (mProfileEnabled) {
            Log.d(LOG_TAG, ""Profiling hardware renderer"");
            int maxProfileFrames = SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY, PROFILE_MAX_FRAMES);
            mProfileData = new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
            for (int i = 0; i < mProfileData.length; i += PROFILE_FRAME_DATA_COUNT) {
                mProfileData[i] = mProfileData[i + 1] = mProfileData[i + 2] = -1;
            }
            mProfileLock = new ReentrantLock();
        } else {
            mProfileData = null;
            mProfileLock = null;
            mProfileVisualizerType = -1;
        }
        mProfileCurrentFrame = -PROFILE_FRAME_DATA_COUNT;
    }
    value = SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY, false);
    if (value != mDebugDirtyRegions) {
        changed = true;
        mDebugDirtyRegions = value;
        if (mDebugDirtyRegions) {
            Log.d(LOG_TAG, ""Debugging dirty regions"");
        }
    }
    String overdraw = SystemProperties.get(HardwareRenderer.DEBUG_OVERDRAW_PROPERTY);
    int debugOverdraw = search(OVERDRAW, overdraw);
    if (debugOverdraw != mDebugOverdraw) {
        changed = true;
        mDebugOverdraw = debugOverdraw;
        if (mDebugOverdraw != OVERDRAW_TYPE_COUNT) {
            if (mDebugOverdrawLayer != null) {
                mDebugOverdrawLayer.destroy();
                mDebugOverdrawLayer = null;
                mDebugOverdrawPaint = null;
            }
        }
    }
    if (nLoadProperties()) {
        changed = true;
    }
    return changed;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method ""Arrays.binarySearch()"" is changed to ""search()"", and additional check and control for debugOverdraw is introduced in the late version implementation. Therefore, the change type is 1,4,5.","As the return value of the method essentially depends on the result of value assignment to ""change"", the modification in method implementation in the form of different method calls and the addition of a new process can lead to different return values. Therefore, the CI type is 1."
145,<android.view.ViewPropertyAnimator: ViewPropertyAnimator withLayer()>,18,19,<android.view.ViewPropertyAnimator: ViewPropertyAnimator withLayer()>,<android.view.ViewPropertyAnimator: ViewPropertyAnimator withLayer()>,0,"{
    mPendingSetupAction = new Runnable() {

        @Override
        public void run() {
            mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
        }
    };
    final int currentLayerType = mView.getLayerType();
    mPendingCleanupAction = new Runnable() {

        @Override
        public void run() {
            mView.setLayerType(currentLayerType, null);
        }
    };
    if (mAnimatorSetupMap == null) {
        mAnimatorSetupMap = new HashMap<Animator, Runnable>();
    }
    if (mAnimatorCleanupMap == null) {
        mAnimatorCleanupMap = new HashMap<Animator, Runnable>();
    }
    return this;
}","{
    mPendingSetupAction = new Runnable() {

        @Override
        public void run() {
            mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
            if (mView.isAttachedToWindow()) {
                mView.buildLayer();
            }
        }
    };
    final int currentLayerType = mView.getLayerType();
    mPendingCleanupAction = new Runnable() {

        @Override
        public void run() {
            mView.setLayerType(currentLayerType, null);
        }
    };
    if (mAnimatorSetupMap == null) {
        mAnimatorSetupMap = new HashMap<Animator, Runnable>();
    }
    if (mAnimatorCleanupMap == null) {
        mAnimatorCleanupMap = new HashMap<Animator, Runnable>();
    }
    return this;
}",1,"/**
 * The View associated with this ViewPropertyAnimator will have its
 * {@link View#setLayerType(int, android.graphics.Paint) layer type} set to
 * {@link View#LAYER_TYPE_HARDWARE} for the duration of the next animation.
 * As stated in the documentation for {@link View#LAYER_TYPE_HARDWARE},
 * the actual type of layer used internally depends on the runtime situation of the
 * view. If the activity and this view are hardware-accelerated, then the layer will be
 * accelerated as well. If the activity or the view is not accelerated, then the layer will
 * effectively be the same as {@link View#LAYER_TYPE_SOFTWARE}.
 *
 * <p>This state is not persistent, either on the View or on this ViewPropertyAnimator: the
 * layer type of the View will be restored when the animation ends to what it was when this
 * method was called, and this setting on ViewPropertyAnimator is only valid for the next
 * animation. Note that calling this method and then independently setting the layer type of
 * the View (by a direct call to {@link View#setLayerType(int, android.graphics.Paint)}) will
 * result in some inconsistency, including having the layer type restored to its pre-withLayer()
 * value when the animation ends.</p>
 *
 * @see View#setLayerType(int, android.graphics.Paint)
 * @return This object, allowing calls to methods in this class to be chained.
 */
","/**
 * The View associated with this ViewPropertyAnimator will have its
 * {@link View#setLayerType(int, android.graphics.Paint) layer type} set to
 * {@link View#LAYER_TYPE_HARDWARE} for the duration of the next animation.
 * As stated in the documentation for {@link View#LAYER_TYPE_HARDWARE},
 * the actual type of layer used internally depends on the runtime situation of the
 * view. If the activity and this view are hardware-accelerated, then the layer will be
 * accelerated as well. If the activity or the view is not accelerated, then the layer will
 * effectively be the same as {@link View#LAYER_TYPE_SOFTWARE}.
 *
 * <p>This state is not persistent, either on the View or on this ViewPropertyAnimator: the
 * layer type of the View will be restored when the animation ends to what it was when this
 * method was called, and this setting on ViewPropertyAnimator is only valid for the next
 * animation. Note that calling this method and then independently setting the layer type of
 * the View (by a direct call to {@link View#setLayerType(int, android.graphics.Paint)}) will
 * result in some inconsistency, including having the layer type restored to its pre-withLayer()
 * value when the animation ends.</p>
 *
 * @see View#setLayerType(int, android.graphics.Paint)
 * @return This object, allowing calls to methods in this class to be chained.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,The code change is about the addition of an if-statement and an additional statement in one anonymous Runnable class within the 'withLayer()' method. This change belongs to 'Control dependency change' category.,"Despite the code change, it's unlikely to cause a compatibility issue. All the method still returns the same 'this' object as before and throws no new exceptions. So, no Compatibility Issue exists."
146,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readFullLongArray(DataInputStream)>,18,19,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readFullLongArray(DataInputStream)>,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readFullLongArray(DataInputStream)>,0,"{
    final int size = in.readInt();
    final long[] values = new long[size];
    for (int i = 0; i < values.length; i++) {
        values[i] = in.readLong();
    }
    return values;
}","{
    final int size = in.readInt();
    if (size < 0)
        throw new ProtocolException(""negative array size"");
    final long[] values = new long[size];
    for (int i = 0; i < values.length; i++) {
        values[i] = in.readLong();
    }
    return values;
}",1,,,-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"2,3",2,"A new 'if' statement that checks whether size is less than 0 and throws a `ProtocolException` has been added in the late version, thus the code change type should be 2,3.","Given that a new exception is added in the late version which could potentially cause the API to throw different exceptions, thus the Compatibility Issue type is 2."
147,<android.widget.TextView: float getLeftFadingEdgeStrength()>,18,19,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    final int textDirection = mLayout.getParagraphDirection(0);
                    if (textDirection == Layout.DIR_LEFT_TO_RIGHT) {
                        return 0.0f;
                    } else {
                        return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                    }
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control structure in the 'switch case' segment has changed. The condition for part ""case Gravity.FILL_HORIZONTAL"" is newly added along with the return statement inside it. Hence, the code change falls under Type 3 'Control dependency' change.","Though the overall structure of the code remains the same, the introduction of a new 'case' clause changes the flow of the program and potentially leads to a different return value when the 'getLeftFadingEdgeStrength()' method is invoked. This falls under Type 1 Compatibility Issue caused by potential different return values changed."
148,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",18,19,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,'setNpnProtocols(mNpnProtocols)' did not change but 's.setAlpnProtocols(mAlpnProtocols)' was added. So the type of code change is 4 (other statement changed).,"The change does not impact the functionality or behavior of the method. Therefore, no Compatibility Issue (CI) exists."
149,<android.view.ViewTreeObserver.CopyOnWriteArray: void end()>,18,19,<android.view.ViewTreeObserver.CopyOnWriteArray: void end()>,<android.view.ViewTreeObserver.CopyOnWriteArray: void end()>,0,"{
    if (!mStart)
        throw new IllegalStateException(""Iteration not started"");
    mStart = false;
    if (mDataCopy != null) {
        mData = mDataCopy;
    }
    mDataCopy = null;
}","{
    if (!mStart)
        throw new IllegalStateException(""Iteration not started"");
    mStart = false;
    if (mDataCopy != null) {
        mData = mDataCopy;
        mAccess.mData.clear();
        mAccess.mSize = 0;
    }
    mDataCopy = null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only two statements related to the 'mAccess' are added in the late version implementation, so the change type is 4.","These newly added statements won't affect the return value or the exception of this method, since this method doesn't return any value and the potential exceptions thrown by this method didn't change. So the CI type is 0."
151,<android.widget.GridLayout: boolean getUseDefaultMargins()>,18,19,<android.widget.GridLayout: boolean getUseDefaultMargins()>,<android.widget.GridLayout: boolean getUseDefaultMargins()>,0,"{
    return useDefaultMargins;
}","{
    return mUseDefaultMargins;
}",1,"/**
 * Returns whether or not this GridLayout will allocate default margins when no
 * corresponding layout parameters are defined.
 *
 * @return {@code true} if default margins should be allocated
 *
 * @see #setUseDefaultMargins(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_useDefaultMargins
 */
","/**
 * Returns whether or not this GridLayout will allocate default margins when no
 * corresponding layout parameters are defined.
 *
 * @return {@code true} if default margins should be allocated
 *
 * @see #setUseDefaultMargins(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_useDefaultMargins
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed, because the variable that the function returns has been renamed. So, the change type is 1.","The change in the returned variable might cause the API to potentially return a different value. Therefore, the CI type is 1."
153,<android.view.View: void setContentDescription(CharSequence)>,18,19,<android.view.View: void setContentDescription(CharSequence)>,<android.view.View: void setContentDescription(CharSequence)>,0,"{
    if (mContentDescription == null) {
        if (contentDescription == null) {
            return;
        }
    } else if (mContentDescription.equals(contentDescription)) {
        return;
    }
    mContentDescription = contentDescription;
    final boolean nonEmptyDesc = contentDescription != null && contentDescription.length() > 0;
    if (nonEmptyDesc && getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    notifyAccessibilityStateChanged();
}","{
    if (mContentDescription == null) {
        if (contentDescription == null) {
            return;
        }
    } else if (mContentDescription.equals(contentDescription)) {
        return;
    }
    mContentDescription = contentDescription;
    final boolean nonEmptyDesc = contentDescription != null && contentDescription.length() > 0;
    if (nonEmptyDesc && getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        notifySubtreeAccessibilityStateChangedIfNeeded();
    } else {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION);
    }
}",1,"/**
 * Sets the {@link View} description. It briefly describes the view and is
 * primarily used for accessibility support. Set this property to enable
 * better accessibility support for your application. This is especially
 * true for views that do not have textual representation (For example,
 * ImageButton).
 *
 * @param contentDescription The content description.
 *
 * @attr ref android.R.styleable#View_contentDescription
 */
","/**
 * Sets the {@link View} description. It briefly describes the view and is
 * primarily used for accessibility support. Set this property to enable
 * better accessibility support for your application. This is especially
 * true for views that do not have textual representation (For example,
 * ImageButton).
 *
 * @param contentDescription The content description.
 *
 * @attr ref android.R.styleable#View_contentDescription
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed between the early and the late version. Specifically, the location of the 'notifyViewAccessibilityStateChangedIfNeeded' method call and the arguments passed to it have been altered within an 'if - else' control structure. Thus, the code change type is 3.","Despite the shift of where 'notifyViewAccessibilityStateChangedIfNeeded' is triggered, the overall behavior of the method 'setContentDescription' remains unchanged. The variable being returned ('void') remains constant. As for exceptions, there were no relevant changes or additions to throw new exceptions. Hence, there is no Compatibility Issue, and the CI type is 0."
154,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",18,19,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>","<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException(""No content provider: "" + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException(""Failed opening content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}","{
    return openAssetFileDescriptor(uri, mode, null);
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2",The whole function body with lots of method callings changed to a single method call return statement. So code change type is classified into 1 (Return statement changed) and 5 (Dependent API changed).,"This change could potentially lead Compatibility Issue in two ways: First, as function body change, the return type and value might be different, depending on the implementation of the new invoked method openAssetFileDescriptor. Second, the new version of the API throws exceptions that the old version of the API didn't and vice versa. Therefore, the CI type is 1,2."
156,"<android.os.Binder: void dump(FileDescriptor,String[])>",18,19,"<android.os.Binder: void dump(FileDescriptor,String[])>","<android.os.Binder: void dump(FileDescriptor,String[])>",0,"{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new PrintWriter(fout);
    try {
        final String disabled;
        synchronized (Binder.class) {
            disabled = sDumpDisabled;
        }
        if (disabled == null) {
            dump(fd, pw, args);
        } else {
            pw.println(sDumpDisabled);
        }
    } finally {
        pw.flush();
    }
}","{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    try {
        final String disabled;
        synchronized (Binder.class) {
            disabled = sDumpDisabled;
        }
        if (disabled == null) {
            try {
                dump(fd, pw, args);
            } catch (SecurityException e) {
                pw.println(""Security exception: "" + e.getMessage());
                throw e;
            } catch (Throwable e) {
                // Unlike usual calls, in this case if an exception gets thrown
                // back to us we want to print it back in to the dump data, since
                // that is where the caller expects all interesting information to
                // go.
                pw.println();
                pw.println(""Exception occurred while dumping:"");
                e.printStackTrace(pw);
            }
        } else {
            pw.println(sDumpDisabled);
        }
    } finally {
        pw.flush();
    }
}",1,"/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
","/**
 * Implemented to call the more convenient version
 * {@link #dump(FileDescriptor, PrintWriter, String[])}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the late version, a `try-catch` block containing exception handling statements was added around the `dump(fd, pw, args);` function call which originally only present in the early version. Concurrently, in the late version the `PrintWriter` object `pw` is now instance of the `FastPrintWriter` class. Thus, the code change type is 1,2,4.","Firstly, the additional `try-catch` block added around the `dump(fd, pw, args);` function call in the late version potentially causing the method `dump(FileDescriptor,String[])` throwing different exceptions or returning different values if there are exception being thrown by the `dump(fd, pw, args);` function call. Secondly, the change of `pw` instance to `FastPrintWriter` could also lead to different behaviours, depending of the execution of the `FastPrintWriter` class and its overridden methods. Thus, the type of Compatibility issue is 1,2."
158,<android.view.ViewGroup: int getLayoutMode()>,18,19,<android.view.ViewGroup: int getLayoutMode()>,<android.view.ViewGroup: int getLayoutMode()>,0,"{
    return mLayoutMode;
}","{
    if (mLayoutMode == LAYOUT_MODE_UNDEFINED) {
        int inheritedLayoutMode = (mParent instanceof ViewGroup) ? ((ViewGroup) mParent).getLayoutMode() : LAYOUT_MODE_DEFAULT;
        setLayoutMode(inheritedLayoutMode, false);
    }
    return mLayoutMode;
}",1,"/**
 * Returns the basis of alignment during layout operations on this view group:
 * either {@link #LAYOUT_MODE_CLIP_BOUNDS} or {@link #LAYOUT_MODE_OPTICAL_BOUNDS}.
 *
 * @return the layout mode to use during layout operations
 *
 * @see #setLayoutMode(int)
 */
","/**
 * Returns the basis of alignment during layout operations on this ViewGroup:
 * either {@link #LAYOUT_MODE_CLIP_BOUNDS} or {@link #LAYOUT_MODE_OPTICAL_BOUNDS}.
 * <p>
 * If no layoutMode was explicitly set, either programmatically or in an XML resource,
 * the method returns the layoutMode of the view's parent ViewGroup if such a parent exists,
 * otherwise the method returns a default value of {@link #LAYOUT_MODE_CLIP_BOUNDS}.
 *
 * @return the layout mode to use during layout operations
 *
 * @see #setLayoutMode(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the early version, the method simply returns the 'mLayoutMode' variable whereas in the late version, it first checks if 'mLayoutMode' is equal to 'LAYOUT_MODE_UNDEFINED'. If true, it calculates 'inheritedLayoutMode' and calls the method 'setLayoutMode'. Thus, the code change type is 1,3.","Due to these changes, the variable 'mLayoutMode' can potentially take different values in the late version, which eventually leads to a different return value of this method. Therefore, the CI type is 1."
159,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>",18,19,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int)>",0,"{
    return registerListener(listener, sensor, rate, null);
}","{
    return registerListener(listener, sensor, rateUs, null);
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @return <code>true</code> if the sensor is supported and successfully
 * enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int, Handler)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 *
 * @throws IllegalArgumentException when sensor is null or a trigger sensor
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * <p class=""note""></p>
 * Note: Don't use this method with a one shot trigger sensor such as
 * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.
 * Use {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead.
 * </p>
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rateUs
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}
 * or, the desired delay between events in microseconds.
 * Specifying the delay in microseconds only works from Android
 * 2.3 (API level 9) onwards. For earlier releases, you must use
 * one of the {@code SENSOR_DELAY_*} constants.
 *
 * @return <code>true</code> if the sensor is supported and successfully
 * enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int, Handler)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from registerListener(listener, sensor, rate, null) to registerListener(listener, sensor, rateUs, null) and the parameter name in the method registerListener also changed, so the code change type is 1,5.","As the return statement has changed, it will potentially make the API return a different value. Thus, a compatibility issue may exist and the CI type is 1."
161,"<android.util.SparseIntArray: int get(int,int)>",18,19,"<android.util.SparseIntArray: int get(int,int)>","<android.util.SparseIntArray: int get(int,int)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}",1,"/**
 * Gets the int mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
","/**
 * Gets the int mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API binarySearch() method has changed from using a local implementation (binarySearch(mKeys, 0, mSize, key)) to using the implementation in ContainerHelpers (ContainerHelpers.binarySearch(mKeys, mSize, key)), So the code change type is 5.","The function binarySearch() still returns the same result, just the source of the function has been changed. So, there is no Compatibility Issue, hence CI type is 0."
162,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",18,19,"<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>","<android.os.ParcelFileDescriptor: void writeToParcel(Parcel,int)>",0,"{
    out.writeFileDescriptor(mFileDescriptor);
    if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
        try {
            close();
        } catch (IOException e) {
        // Empty
        }
    }
}","{
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        out.writeFileDescriptor(mFd);
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}",1,"/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
","/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2",Multiple changes have occurred between the versions:,3) Control dependency changes: New condition 'if (mWrapped != null)' and 'if (mCommFd != null)' have been added in the late version.
163,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,18,19,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,<android.view.accessibility.AccessibilityNodeInfo: boolean refresh()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return false;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    AccessibilityNodeInfo refreshedInfo = client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mSourceNodeId, 0);
    if (refreshedInfo == null) {
        return false;
    }
    init(refreshedInfo);
    refreshedInfo.recycle();
    return true;
}","{
    return refresh(false);
}",1,"/**
 * Refreshes this info with the latest state of the view it represents.
 * <p>
 * <strong>Note:</strong> If this method returns false this info is obsolete
 * since it represents a view that is no longer in the view tree and should
 * be recycled.
 * </p>
 * @return Whether the refresh succeeded.
 */
","/**
 * Refreshes this info with the latest state of the view it represents.
 * <p>
 * <strong>Note:</strong> If this method returns false this info is obsolete
 * since it represents a view that is no longer in the view tree and should
 * be recycled.
 * </p>
 * @return Whether the refresh succeeded.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"In the early version, the implementation involves multiple statements and conditions. However, all the early version of implementation has been deleted and a new statement 'return refresh(false)' is added in the late version. Therefore, the code change type is 1,4,5.","As the newly added statement 'return refresh(false)' can change the return value of the API, the CI type is 1."
164,<android.content.pm.PackageParser.Provider: String toString()>,18,19,<android.content.pm.PackageParser.Provider: String toString()>,<android.content.pm.PackageParser.Provider: String toString()>,0,"{
    return ""Provider{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + info.name + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""Provider{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1, 4",1,"The previous sole return statement is split into multiple lines with use of StringBuilder and another function 'appendComponentShortName()', so the code change type is 1,4. ","The 'appendComponentShortName()' is used to build the string in the later version, which can lead to a different return, so the CI type is 1."
165,<android.app.ContextImpl: File getFilesDir()>,18,19,<android.app.ContextImpl: File getFilesDir()>,<android.app.ContextImpl: File getFilesDir()>,0,"{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDirFile(), ""files"");
        }
        if (!mFilesDir.exists()) {
            if (!mFilesDir.mkdirs()) {
                Log.w(TAG, ""Unable to create files directory "" + mFilesDir.getPath());
                return null;
            }
            FileUtils.setPermissions(mFilesDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
        return mFilesDir;
    }
}","{
    synchronized (mSync) {
        if (mFilesDir == null) {
            mFilesDir = new File(getDataDirFile(), ""files"");
        }
        if (!mFilesDir.exists()) {
            if (!mFilesDir.mkdirs()) {
                if (mFilesDir.exists()) {
                    // spurious failure; probably racing with another process for this app
                    return mFilesDir;
                }
                Log.w(TAG, ""Unable to create files directory "" + mFilesDir.getPath());
                return null;
            }
            FileUtils.setPermissions(mFilesDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
        return mFilesDir;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"An if statement has been added into the code, hence, the change type is 3.","The new added if statement allows a return statement to skip code that previously had to be executed. This could potentially lead to different return values in some cases, hence the CI type is 1."
169,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,18,19,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,<android.content.ClipboardManager: ClipDescription getPrimaryClipDescription()>,0,"{
    try {
        return getService().getPrimaryClipDescription(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
","/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getService().getPrimaryClipDescription(mContext.getBasePackageName()) to getService().getPrimaryClipDescription(mContext.getOpPackageName()) and the parameter type of getPrimaryClipDescription() also changed, so the code change type is 1,5.","The change of return statement and the dependent API may make the API potentially return a different value, so the CI type is 1."
170,<android.net.http.HttpResponseCache: long size()>,18,19,<android.net.http.HttpResponseCache: long size()>,<android.net.http.HttpResponseCache: long size()>,0,"{
    return delegate.getCache().size();
}","{
    return delegate.getSize();
}",1,"/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending.
 */
","/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API 'delegate.getCache().size()' has been replaced by 'delegate.getSize()'. Therefore, the code change categories are Return statement changed (1) and Dependent API changed (5).","Given that the return value of size() is determined by the return value of a different underlying API in each version, the return values could potentially be different between the two versions. Thus, there exists a Compatibility Issue caused by potential different return values (1)."
171,<android.os.Bundle: boolean hasFileDescriptors()>,18,19,<android.os.Bundle: boolean hasFileDescriptors()>,<android.os.Bundle: boolean hasFileDescriptors()>,0,"{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            Iterator<Map.Entry<String, Object>> iter = mMap.entrySet().iterator();
            while (!fdFound && iter.hasNext()) {
                Object obj = iter.next().getValue();
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}","{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}",1,"/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
","/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The way elements are retrieved from TreeMap (mMap) in a while loop is changed to directly getting values from mMap at index in a for loop. Therefore, the code change type is 3.","Although there's a code change in the retrieval method from the map, it doesn't change the return value or the exception handling. Hence, no compatibility issue."
172,"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>",18,19,"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>","<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>",0,"{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        try {
            mFragmentBreadCrumbs = (FragmentBreadCrumbs) crumbs;
        } catch (ClassCastException e) {
            return;
        }
        if (mFragmentBreadCrumbs == null) {
            if (title != null) {
                setTitle(title);
            }
            return;
        }
        if (mSinglePane) {
            mFragmentBreadCrumbs.setVisibility(View.GONE);
            // Hide the breadcrumb section completely for single-pane
            View bcSection = findViewById(com.android.internal.R.id.breadcrumb_section);
            if (bcSection != null)
                bcSection.setVisibility(View.GONE);
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    mFragmentBreadCrumbs.setTitle(title, shortTitle);
    mFragmentBreadCrumbs.setParentTitle(null, null, null);
}","{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        try {
            mFragmentBreadCrumbs = (FragmentBreadCrumbs) crumbs;
        } catch (ClassCastException e) {
            setTitle(title);
            return;
        }
        if (mFragmentBreadCrumbs == null) {
            if (title != null) {
                setTitle(title);
            }
            return;
        }
        if (mSinglePane) {
            mFragmentBreadCrumbs.setVisibility(View.GONE);
            // Hide the breadcrumb section completely for single-pane
            View bcSection = findViewById(com.android.internal.R.id.breadcrumb_section);
            if (bcSection != null)
                bcSection.setVisibility(View.GONE);
            setTitle(title);
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    if (mFragmentBreadCrumbs.getVisibility() != View.VISIBLE) {
        setTitle(title);
    } else {
        mFragmentBreadCrumbs.setTitle(title, shortTitle);
        mFragmentBreadCrumbs.setParentTitle(null, null, null);
    }
}",1,"/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
","/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the catch block, the API has a new statement setTitle(title) and similarly after the if condition check for mSinglePane, there is a new statement setTitle(title). There is also a new condition check for mFragmentBreadCrumbs.getVisibility() != View.VISIBLE preceding the setTitle(title) and mFragmentBreadCrumbs.setTitle(title, shortTitle) statements. Hence the code change type is 3,4.","The changes in the exception handling, addition of setTitle method calls and introduction of new conditional check could potentially change the behavior of the function in terms of the title that could be set. Hence the CI type is 1."
173,<android.util.SparseLongArray: int indexOfKey(int)>,18,19,<android.util.SparseLongArray: int indexOfKey(int)>,<android.util.SparseLongArray: int indexOfKey(int)>,0,"{
    return binarySearch(mKeys, 0, mSize, key);
}","{
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API has changed from 'binarySearch(mKeys, 0, mSize, key)' to 'ContainerHelpers.binarySearch(mKeys, mSize, key)'. The method name and the parameters used to call binarySearch've been modified. So the code change type is 5.","Because of the change in the dependent API, there is a chance that the API returns a different value. Therefore, the CI type is 1."
175,<android.net.MailTo: MailTo parse(String)>,18,19,<android.net.MailTo: MailTo parse(String)>,<android.net.MailTo: MailTo parse(String)>,0,"{
    if (url == null) {
        throw new NullPointerException();
    }
    if (!isMailTo(url)) {
        throw new ParseException(""Not a mailto scheme"");
    }
    // Strip the scheme as the Uri parser can't cope with it.
    String noScheme = url.substring(MAILTO_SCHEME.length());
    Uri email = Uri.parse(noScheme);
    MailTo m = new MailTo();
    // Parse out the query parameters
    String query = email.getQuery();
    if (query != null) {
        String[] queries = query.split(""&"");
        for (String q : queries) {
            String[] nameval = q.split(""="");
            if (nameval.length == 0) {
                continue;
            }
            // insert the headers with the name in lowercase so that
            // we can easily find common headers
            m.mHeaders.put(Uri.decode(nameval[0]).toLowerCase(), nameval.length > 1 ? Uri.decode(nameval[1]) : null);
        }
    }
    // Address can be specified in both the headers and just after the
    // mailto line. Join the two together.
    String address = email.getPath();
    if (address != null) {
        String addr = m.getTo();
        if (addr != null) {
            address += "", "" + addr;
        }
        m.mHeaders.put(TO, address);
    }
    return m;
}","{
    if (url == null) {
        throw new NullPointerException();
    }
    if (!isMailTo(url)) {
        throw new ParseException(""Not a mailto scheme"");
    }
    // Strip the scheme as the Uri parser can't cope with it.
    String noScheme = url.substring(MAILTO_SCHEME.length());
    Uri email = Uri.parse(noScheme);
    MailTo m = new MailTo();
    // Parse out the query parameters
    String query = email.getQuery();
    if (query != null) {
        String[] queries = query.split(""&"");
        for (String q : queries) {
            String[] nameval = q.split(""="");
            if (nameval.length == 0) {
                continue;
            }
            // insert the headers with the name in lowercase so that
            // we can easily find common headers
            m.mHeaders.put(Uri.decode(nameval[0]).toLowerCase(Locale.ROOT), nameval.length > 1 ? Uri.decode(nameval[1]) : null);
        }
    }
    // Address can be specified in both the headers and just after the
    // mailto line. Join the two together.
    String address = email.getPath();
    if (address != null) {
        String addr = m.getTo();
        if (addr != null) {
            address += "", "" + addr;
        }
        m.mHeaders.put(TO, address);
    }
    return m;
}",1,"/**
 * Parse and decode a mailto scheme string. This parser implements
 * RFC 2368. The returned object can be queried for the parsed parameters.
 * @param url String containing a mailto URL
 * @return MailTo object
 * @exception ParseException if the scheme is not a mailto URL
 */
","/**
 * Parse and decode a mailto scheme string. This parser implements
 * RFC 2368. The returned object can be queried for the parsed parameters.
 * @param url String containing a mailto URL
 * @return MailTo object
 * @exception ParseException if the scheme is not a mailto URL
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the line where it puts the headers into the map m.mHeaders, the first argument of the method toLowerCase() has changed from none to Locale.ROOT, so the change type is 4.","Since the lowercasing behaviour could be changed due to the different locale, the map m.mHeaders would be potentially different, which leads to a different return object. So the CI type is 1."
176,"<android.text.Layout: int getOffsetForHorizontal(int,float)>",18,19,"<android.text.Layout: int getOffsetForHorizontal(int,float)>","<android.text.Layout: int getOffsetForHorizontal(int,float)>",0,"{
    int max = getLineEnd(line) - 1;
    int min = getLineStart(line);
    Directions dirs = getLineDirections(line);
    if (line == getLineCount() - 1)
        max++;
    int best = min;
    float bestdist = Math.abs(getPrimaryHorizontal(best) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = min + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        int swap = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0 ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                high = guess;
            else
                low = guess;
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            low = getOffsetAtStartOf(low);
            float dist = Math.abs(getPrimaryHorizontal(low) - horiz);
            int aft = TextUtils.getOffsetAfter(mText, low);
            if (aft < there) {
                float other = Math.abs(getPrimaryHorizontal(aft) - horiz);
                if (other < dist) {
                    dist = other;
                    low = aft;
                }
            }
            if (dist < bestdist) {
                bestdist = dist;
                best = low;
            }
        }
        float dist = Math.abs(getPrimaryHorizontal(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(getPrimaryHorizontal(max) - horiz);
    if (dist < bestdist) {
        bestdist = dist;
        best = max;
    }
    return best;
}","{
    int max = getLineEnd(line) - 1;
    int min = getLineStart(line);
    Directions dirs = getLineDirections(line);
    if (line == getLineCount() - 1)
        max++;
    int best = min;
    float bestdist = Math.abs(getPrimaryHorizontal(best) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = min + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        int swap = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0 ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                high = guess;
            else
                low = guess;
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            low = getOffsetAtStartOf(low);
            float dist = Math.abs(getPrimaryHorizontal(low) - horiz);
            int aft = TextUtils.getOffsetAfter(mText, low);
            if (aft < there) {
                float other = Math.abs(getPrimaryHorizontal(aft) - horiz);
                if (other < dist) {
                    dist = other;
                    low = aft;
                }
            }
            if (dist < bestdist) {
                bestdist = dist;
                best = low;
            }
        }
        float dist = Math.abs(getPrimaryHorizontal(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(getPrimaryHorizontal(max) - horiz);
    if (dist <= bestdist) {
        bestdist = dist;
        best = max;
    }
    return best;
}",1,"/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
","/**
 * Get the character offset on the specified line whose position is
 * closest to the specified horizontal position.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The change made is to the condition of one 'if' statement, changing the comparison criteria from 'dist < bestdist' to 'dist <= bestdist' i.e. the condition would also be met if both values are equal. Hence, this is a 'Return statement changed'.","This introduction of the equality condition might lead to possibly different return values compared to the early version. Though the absolute difference might be low, the returned variable can still be different so it falls under 'Compatibility Issue caused by potential different return values or types'."
177,"<android.view.View: void measure(int,int)>",18,19,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}","{
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int oWidth = insets.left + insets.right;
        int oHeight = insets.top + insets.bottom;
        widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth);
        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
    }
    // Suppress sign extension for the low bytes
    long key = (long) widthMeasureSpec << 32 | (long) heightMeasureSpec & 0xffffffffL;
    if (mMeasureCache == null)
        mMeasureCache = new LongSparseLongArray(2);
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        int cacheIndex = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key);
        if (cacheIndex < 0 || sIgnoreMeasureCache) {
            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        } else {
            long value = mMeasureCache.valueAt(cacheIndex);
            // Casting a long to int drops the high 32 bits, no mask needed
            setMeasuredDimension((int) (value >> 32), (int) value);
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
    mMeasureCache.put(key, ((long) mMeasuredWidth) << 32 | // suppress sign extension
    (long) mMeasuredHeight & 0xffffffffL);
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are several ""if"" condition modifications and new additions in the late version. Additionally, new variables and computation assignments are also introduced (e.g., 'long key' and 'mMeasureCache.put'), so the code change type is 3,4.","Though there are several modifications and additions, they do not effect the potential values returned by the method or the possible exceptions thrown by it. As a result, there are no Compatibility Issues exist in this code change, so the CI type is 0."
178,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",18,19,"<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>","<android.hardware.Sensor: int getMaxLengthValuesArray(Sensor,int)>",0,"{
    // mType starts from offset 1.
    int len = sMaxLengthValuesArray[sensor.mType - 1];
    // Set it to 3 for backward compatibility.
    if (sensor.getType() == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        len = 3;
    }
    return len;
}","{
    int type = sensor.mType;
    // Set it to 3 for backward compatibility.
    if (type == Sensor.TYPE_ROTATION_VECTOR && sdkLevel <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        return 3;
    }
    int offset = type * 2 + 1;
    if (offset >= sSensorReportingModes.length) {
        // sensor
        return 16;
    }
    return sSensorReportingModes[offset];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The return statement of the method has changed. From returning the length 'len' which obtains its value from 'sMaxLengthValuesArray[sensor.mType - 1]' to returning either '3', '16', or 'sSensorReportingModes[offset]'. There is also a control dependency change, the condition and the structure of the IF statement has changed as well. Further, the method no longer uses variable len and instead uses a new variable 'offset'. The method 'sMaxLengthValuesArray' was also replaced with 'sSensorReportingModes'. Therefore the code change types are 1, 3, and 5.","The conditional and return statement changes will cause the method to potentially return a different value. For example, in the late version, the method may return '16' or 'sSensorReportingModes[offset]', which cannot occur in the early version. Therefore, the compatibility issue is of type 1."
179,<android.widget.AbsListView.WindowRunnnable: boolean sameWindow()>,18,19,<android.widget.AbsListView.WindowRunnnable: boolean sameWindow()>,<android.widget.AbsListView.WindowRunnnable: boolean sameWindow()>,0,"{
    return hasWindowFocus() && getWindowAttachCount() == mOriginalAttachCount;
}","{
    return getWindowAttachCount() == mOriginalAttachCount;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The 'hasWindowFocus()' from the return statement has been removed, therefore the change type is 3 (Control dependency change) because the boolean condition has been changed.","The removal of 'hasWindowFocus()' might lead to different return values between the two versions of the method, thus the CI type is 1 (potential different return values)."
180,<android.os.ParcelFileDescriptor: FileDescriptor getFileDescriptor()>,18,19,<android.os.ParcelFileDescriptor: FileDescriptor getFileDescriptor()>,<android.os.ParcelFileDescriptor: FileDescriptor getFileDescriptor()>,0,"{
    return mFileDescriptor;
}","{
    if (mWrapped != null) {
        return mWrapped.getFileDescriptor();
    } else {
        return mFd;
    }
}",1,"/**
 * Retrieve the actual FileDescriptor associated with this object.
 *
 * @return Returns the FileDescriptor associated with this object.
 */
","/**
 * Retrieve the actual FileDescriptor associated with this object.
 *
 * @return Returns the FileDescriptor associated with this object.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new control dependency 'if-else' has been introduced and return statement is changed, so the change type compatibility change is 1 and 3.","Due to the changes in the return statement, it could possibly return a different value in late version, so the CI type is 1."
181,<android.hardware.Camera: void setParameters(Parameters)>,18,19,<android.hardware.Camera: void setParameters(Parameters)>,<android.hardware.Camera: void setParameters(Parameters)>,0,"{
    native_setParameters(params.flatten());
}","{
    // If using preview allocations, don't allow preview size changes
    if (mUsingPreviewAllocation) {
        Size newPreviewSize = params.getPreviewSize();
        Size currentPreviewSize = getParameters().getPreviewSize();
        if (newPreviewSize.width != currentPreviewSize.width || newPreviewSize.height != currentPreviewSize.height) {
            throw new IllegalStateException(""Cannot change preview size"" + "" while a preview allocation is configured."");
        }
    }
    native_setParameters(params.flatten());
}",1,"/**
 * Changes the settings for this Camera service.
 *
 * @param params the Parameters to use for this Camera service
 * @throws RuntimeException if any parameter is invalid or not supported.
 * @see #getParameters()
 */
","/**
 * Changes the settings for this Camera service.
 *
 * @param params the Parameters to use for this Camera service
 * @throws RuntimeException if any parameter is invalid or not supported.
 * @see #getParameters()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The introduction of new if statements with a throw keyword under some condition and subsequent calls represents a change in control dependencies, hence the change types 2 and 3.","Considering the addition of the new throw statements, the an IllegalStateException can be thrown under a new condition in the later version. This changes the exception handling of the API, indicating a Compatibility Issue of type 2."
183,<android.content.pm.PackageParser.ServiceIntentInfo: String toString()>,18,19,<android.content.pm.PackageParser.ServiceIntentInfo: String toString()>,<android.content.pm.PackageParser.ServiceIntentInfo: String toString()>,0,"{
    return ""ServiceIntentInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + service.info.name + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""ServiceIntentInfo{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    service.appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In this transition, no control, return, or exception handling statements have been modified. Instead, the code sequences and variable assignments have been revised. This code modification is referred as `Other statement change`.","Although the implementation has changed, both versions produce the exact same output. Thus, the type of compatibility issue (CI) here is `No Compatibility Issue Exist`."
186,<android.os.ParcelFileDescriptor: ParcelFileDescriptor adoptFd(int)>,18,19,<android.os.ParcelFileDescriptor: ParcelFileDescriptor adoptFd(int)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor adoptFd(int)>,0,"{
    FileDescriptor fdesc = getFileDescriptorFromFdNoDup(fd);
    return new ParcelFileDescriptor(fdesc);
}","{
    final FileDescriptor fdesc = new FileDescriptor();
    fdesc.setInt$(fd);
    return new ParcelFileDescriptor(fdesc);
}",1,"/**
 * Take ownership of a raw native fd in to a new ParcelFileDescriptor.
 * The returned ParcelFileDescriptor now owns the given fd, and will be
 * responsible for closing it.  You must not close the fd yourself.
 *
 * @param fd The native fd that the ParcelFileDescriptor should adopt.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for the given fd.
 */
","/**
 * Take ownership of a raw native fd in to a new ParcelFileDescriptor.
 * The returned ParcelFileDescriptor now owns the given fd, and will be
 * responsible for closing it.  You must not close the fd yourself.
 *
 * @param fd The native fd that the ParcelFileDescriptor should adopt.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for the given fd.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The process to get FileDescriptor from fd in the return statement has changed from getFileDescriptorFromFdNoDup(fd) to a new FileDescriptor().setInt$(fd), so the code change type is 1,5.","The change of the way FileDescriptor is obtained from fd might lead the API to return a different ParcelFileDescriptor, so the CI type is 1."
190,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,18,19,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,0,"{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    if (sRef == null) {
        sRef = new CookieSyncManager(context);
    }
    return sRef;
}","{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    setGetInstanceIsAllowed();
    return getInstance();
}",1,"/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
","/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4, 5",1,"The 'if' statement 'if (sRef == null)' and the return statement 'return sRef;' have been removed, a new method call 'setGetInstanceIsAllowed();' has been introduced, and the creation of 'new CookieSyncManager(context)' has been replaced with 'getInstance()'. Therefore, this classifies as types 1, 4, and 5 changes.","As the return statement has been changed and the method creation has been replaced, the potential return value of the method can differ between versions. Therefore this can cause a compatibility issue of type 1."
193,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,18,19,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,<android.content.ClipboardManager: void setPrimaryClip(ClipData)>,0,"{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess();
        }
        getService().setPrimaryClip(clip, mContext.getBasePackageName());
    } catch (RemoteException e) {
    }
}","{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess();
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
","/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The function called on mContext object has changed from getBasePackageName() to getOpPackageName(). So, the code change types are 1,5.","Though there is a change in the function called on mContext object, it wouldn't change the behavior of the API because no matter what package name is returned, it doesn't affect the setPrimaryClip() method, as the implementation is not checking or making any decision based on what package name is returned. Therefore, no compatibility issue is expected."
195,"<android.view.GLES20RecordingCanvas: int drawDisplayList(DisplayList,Rect,int)>",18,19,"<android.view.GLES20RecordingCanvas: int drawDisplayList(DisplayList,Rect,int)>","<android.view.GLES20RecordingCanvas: int drawDisplayList(DisplayList,Rect,int)>",0,"{
    int status = super.drawDisplayList(displayList, dirty, flags);
    mDisplayList.mChildDisplayLists.add(displayList);
    return status;
}","{
    int status = super.drawDisplayList(displayList, dirty, flags);
    mDisplayList.getChildDisplayLists().add(displayList);
    return status;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The statement 'mDisplayList.mChildDisplayLists.add(displayList)' has been changed to 'mDisplayList.getChildDisplayLists().add(displayList)', and part of the dependent API (Field mChildDisplayLists) has been changed to a method call (getChildDisplayLists()), which does not change the behavior of the function. Therefore, the change type is 4,5.","The changes in the implementation of the method don't affect the return value or the exceptions handling, so there is no CI issue in this case, hence the CI type is 0."
197,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",18,19,"<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentResolver: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}","{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        return null;
    }
    IContentProvider stableProvider = null;
    Cursor qCursor = null;
    try {
        long startTime = SystemClock.uptimeMillis();
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = unstableProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        try {
            qCursor = unstableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                return null;
            }
            qCursor = stableProvider.query(mPackageName, uri, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
        }
        if (qCursor == null) {
            return null;
        }
        // Force query execution.  Might fail and throw a runtime exception here.
        qCursor.getCount();
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);
        // Wrap the cursor object into CursorWrapperInner object.
        CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, stableProvider != null ? stableProvider : acquireProvider(uri));
        stableProvider = null;
        qCursor = null;
        return wrapper;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        if (qCursor != null) {
            qCursor.close();
        }
        if (cancellationSignal != null) {
            cancellationSignal.setRemote(null);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
    }
}",1,"/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
","/**
 * <p>
 * Query the given URI, returning a {@link Cursor} over the result set.
 * </p>
 * <p>
 * For best performance, the caller should follow these guidelines:
 * <ul>
 * <li>Provide an explicit projection, to prevent
 * reading data from storage that aren't going to be used.</li>
 * <li>Use question mark parameter markers such as 'phone=?' instead of
 * explicit values in the {@code selection} parameter, so that queries
 * that differ only by those values will be recognized as the same
 * for caching purposes.</li>
 * </ul>
 * </p>
 *
 * @param uri The URI, using the content:// scheme, for the content to
 * retrieve.
 * @param projection A list of which columns to return. Passing null will
 * return all columns, which is inefficient.
 * @param selection A filter declaring which rows to return, formatted as an
 * SQL WHERE clause (excluding the WHERE itself). Passing null will
 * return all rows for the given URI.
 * @param selectionArgs You may include ?s in selection, which will be
 * replaced by the values from selectionArgs, in the order that they
 * appear in the selection. The values will be bound as Strings.
 * @param sortOrder How to order the rows, formatted as an SQL ORDER BY
 * clause (excluding the ORDER BY itself). Passing null will use the
 * default sort order, which may be unordered.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * If the operation is canceled, then {@link OperationCanceledException} will be thrown
 * when the query is executed.
 * @return A Cursor object, which is positioned before the first entry, or null
 * @see Cursor
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The code change occurred in the 'finally' block where a statement operates on the 'cancellationSignal' which is not found in the early implementation. ,"Even though with the introduction of the new statement in the late implementation, this change does not lead to a compatibility issue as the change does not affect the possible return outcomes or exception handling of the method."
198,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",18,19,"<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.Editor.SuggestionsPopupWindow: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    Editable editable = (Editable) mTextView.getText();
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = editable.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", mTextView.getTextServicesLocale().toString());
        // Put a listener to replace the original text with a word which the user
        // modified in a user dictionary dialog.
        mUserDictionaryListener.waitForUserDictionaryAdded(mTextView, originalText, spanStart, spanEnd);
        intent.putExtra(""listener"", new Messenger(mUserDictionaryListener));
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        mTextView.getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        Selection.setSelection(editable, spanEnd);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        mTextView.replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before
        // swaping texts.
        suggestionInfo.suggestionSpan.notifySelection(mTextView.getContext(), originalText, suggestionInfo.suggestionIndex);
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                mTextView.setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        mTextView.setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}","{
    Editable editable = (Editable) mTextView.getText();
    SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        final int spanUnionStart = editable.getSpanStart(mSuggestionRangeSpan);
        int spanUnionEnd = editable.getSpanEnd(mSuggestionRangeSpan);
        if (spanUnionStart >= 0 && spanUnionEnd > spanUnionStart) {
            // Do not leave two adjacent spaces after deletion, or one at beginning of text
            if (spanUnionEnd < editable.length() && Character.isSpaceChar(editable.charAt(spanUnionEnd)) && (spanUnionStart == 0 || Character.isSpaceChar(editable.charAt(spanUnionStart - 1)))) {
                spanUnionEnd = spanUnionEnd + 1;
            }
            mTextView.deleteText_internal(spanUnionStart, spanUnionEnd);
        }
        hide();
        return;
    }
    final int spanStart = editable.getSpanStart(suggestionInfo.suggestionSpan);
    final int spanEnd = editable.getSpanEnd(suggestionInfo.suggestionSpan);
    if (spanStart < 0 || spanEnd <= spanStart) {
        // Span has been removed
        hide();
        return;
    }
    final String originalText = editable.toString().substring(spanStart, spanEnd);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_INSERT);
        intent.putExtra(""word"", originalText);
        intent.putExtra(""locale"", mTextView.getTextServicesLocale().toString());
        // Put a listener to replace the original text with a word which the user
        // modified in a user dictionary dialog.
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        mTextView.getContext().startActivity(intent);
        // There is no way to know if the word was indeed added. Re-check.
        // TODO The ExtractEditText should remove the span in the original text instead
        editable.removeSpan(suggestionInfo.suggestionSpan);
        Selection.setSelection(editable, spanEnd);
        updateSpellCheckSpans(spanStart, spanEnd, false);
    } else {
        // SuggestionSpans are removed by replace: save them before
        SuggestionSpan[] suggestionSpans = editable.getSpans(spanStart, spanEnd, SuggestionSpan.class);
        final int length = suggestionSpans.length;
        int[] suggestionSpansStarts = new int[length];
        int[] suggestionSpansEnds = new int[length];
        int[] suggestionSpansFlags = new int[length];
        for (int i = 0; i < length; i++) {
            final SuggestionSpan suggestionSpan = suggestionSpans[i];
            suggestionSpansStarts[i] = editable.getSpanStart(suggestionSpan);
            suggestionSpansEnds[i] = editable.getSpanEnd(suggestionSpan);
            suggestionSpansFlags[i] = editable.getSpanFlags(suggestionSpan);
            // Remove potential misspelled flags
            int suggestionSpanFlags = suggestionSpan.getFlags();
            if ((suggestionSpanFlags & SuggestionSpan.FLAG_MISSPELLED) > 0) {
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_MISSPELLED;
                suggestionSpanFlags &= ~SuggestionSpan.FLAG_EASY_CORRECT;
                suggestionSpan.setFlags(suggestionSpanFlags);
            }
        }
        final int suggestionStart = suggestionInfo.suggestionStart;
        final int suggestionEnd = suggestionInfo.suggestionEnd;
        final String suggestion = suggestionInfo.text.subSequence(suggestionStart, suggestionEnd).toString();
        mTextView.replaceText_internal(spanStart, spanEnd, suggestion);
        // Notify source IME of the suggestion pick. Do this before
        // swaping texts.
        suggestionInfo.suggestionSpan.notifySelection(mTextView.getContext(), originalText, suggestionInfo.suggestionIndex);
        // Swap text content between actual text and Suggestion span
        String[] suggestions = suggestionInfo.suggestionSpan.getSuggestions();
        suggestions[suggestionInfo.suggestionIndex] = originalText;
        // Restore previous SuggestionSpans
        final int lengthDifference = suggestion.length() - (spanEnd - spanStart);
        for (int i = 0; i < length; i++) {
            // way to assign them a valid range after replacement
            if (suggestionSpansStarts[i] <= spanStart && suggestionSpansEnds[i] >= spanEnd) {
                mTextView.setSpan_internal(suggestionSpans[i], suggestionSpansStarts[i], suggestionSpansEnds[i] + lengthDifference, suggestionSpansFlags[i]);
            }
        }
        // Move cursor at the end of the replaced word
        final int newCursorPosition = spanEnd + lengthDifference;
        mTextView.setCursorPosition_internal(newCursorPosition, newCursorPosition);
    }
    hide();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A section of code, specifically for setting a listener to replace the original text with a word which the user modified in a user dictionary dialog, was deleted from the early version to late version, which makes the change type is 4.","There is no Compatibility Issue in this code change despite the removal of a routine, because this operation was not changing the returning values or exceptions. The routine itself was not directly related to how the system perceived the output of the operation."
202,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",18,19,"<android.content.ContentResolver: void requestSync(Account,String,Bundle)>","<android.content.ContentResolver: void requestSync(Account,String,Bundle)>",0,"{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().requestSync(account, authority, extras);
    } catch (RemoteException e) {
    }
}","{
    if (extras == null) {
        throw new IllegalArgumentException(""Must specify extras."");
    }
    SyncRequest request = new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build();
    requestSync(request);
}",1,"/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
","/**
 * Start an asynchronous sync operation. If you want to monitor the progress
 * of the sync you may register a SyncObserver. Only values of the following
 * types may be used in the extras bundle:
 * <ul>
 * <li>Integer</li>
 * <li>Long</li>
 * <li>Boolean</li>
 * <li>Float</li>
 * <li>Double</li>
 * <li>String</li>
 * <li>Account</li>
 * <li>null</li>
 * </ul>
 *
 * @param account which account should be synced
 * @param authority which authority should be synced
 * @param extras any extras to pass to the SyncAdapter.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5","1,2","The old implementation of this API has been replaced entirely in the late version. New logic was introduced (with new exception and control flows, and the dependent method is changed), hence the code change types are 1,3,4,5. ","Due to the changes in API implementation, this could potentially lead to the API throwing different exceptions (through IllegalArgumentException) and the API could return a different value, thus the Compatibility Issue types are 1 and 2."
204,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",18,19,"<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>","<android.os.RecoverySystem: void verifyPackage(File,ProgressListener,File)>",0,"{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery *only* handles SHA1withRSA
        // signatures.  SignApk.java always uses SHA1withRSA, no
        // matter what the cert says to use.  Ignore
        // cert.getSigAlgName(), and instead use whatever
        // algorithm is used by the signature (which should be
        // SHA1withRSA).
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}","{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, ""r"");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException(""no signature in file (no footer)"");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException(""no signature in file (bad footer)"");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException(""EOCD marker found after start of EOCD"");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException(""signedData is null"");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException(""encCerts is empty"");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException(""signature contains no certificates"");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException(""no signer infos!"");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException(""signature doesn't match any trusted key"");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // ""SHA256withRSA"" cert -> ""SHA256withRSA"" signature
        // ""SHA1withRSA"" cert   -> ""SHA1withRSA"" signature
        // ""MD5withRSA"" cert    -> ""SHA1withRSA"" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + ""with"" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException(""verification was interrupted"");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException(""signature digest verification failed"");
        }
    } finally {
        raf.close();
    }
}",1,"/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
","/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently ""/system/etc/security/otacerts.zip"").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
205,<android.app.Activity: void performStop()>,18,19,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"{
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement has been added - 'mDoReportFullyDrawn = false;' - in the late version implementation which is not part of a control statement, return statement, exception handling statement, or a dependent API. Therefore, the code change type is 4.","The added statement - 'mDoReportFullyDrawn = false;' - is altering the value of 'mDoReportFullyDrawn' but it does not affect the return type/value or exception handling of the API. Thus, there is no compatibility issue arising due to this change, hence the CI type is 0."
207,"<android.widget.Gallery: boolean onKeyUp(int,KeyEvent)>",18,19,"<android.widget.Gallery: boolean onKeyUp(int,KeyEvent)>","<android.widget.Gallery: boolean onKeyUp(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if (mReceivedInvokeKeyDown) {
                    if (mItemCount > 0) {
                        dispatchPress(mSelectedChild);
                        postDelayed(new Runnable() {

                            @Override
                            public void run() {
                                dispatchUnpress();
                            }
                        }, ViewConfiguration.getPressedStateDuration());
                        int selectedIndex = mSelectedPosition - mFirstPosition;
                        performItemClick(getChildAt(selectedIndex), mSelectedPosition, mAdapter.getItemId(mSelectedPosition));
                    }
                }
                // Clear the flag
                mReceivedInvokeKeyDown = false;
                return true;
            }
    }
    return super.onKeyUp(keyCode, event);
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if (mReceivedInvokeKeyDown) {
            if (mItemCount > 0) {
                dispatchPress(mSelectedChild);
                postDelayed(new Runnable() {

                    @Override
                    public void run() {
                        dispatchUnpress();
                    }
                }, ViewConfiguration.getPressedStateDuration());
                int selectedIndex = mSelectedPosition - mFirstPosition;
                performItemClick(getChildAt(selectedIndex), mSelectedPosition, mAdapter.getItemId(mSelectedPosition));
            }
        }
        // Clear the flag
        mReceivedInvokeKeyDown = false;
        return true;
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition for triggering the code within {...} has changed from checking whether keyCode equals to 'KeyEvent.KEYCODE_DPAD_CENTER' or 'KeyEvent.KEYCODE_ENTER' to checking whether the keyCode is a confirmation key. Moreover, the dependent API KeyEvent.isConfirmKey replaces the previous comparison of specific key codes; thus the code change type is 3,5.","The condition has changed and can lead to different behaviors because different keys may now trigger the execution of the block within {...}, thereby changing the returned values. This results in a potential Compatibility Issue type 1."
208,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",18,19,"<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>","<android.net.VpnService.Builder: Builder addRoute(InetAddress,int)>",0,"{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.append(String.format("" %s/%d"", address.getHostAddress(), prefixLength));
    return this;
}","{
    check(address, prefixLength);
    int offset = prefixLength / 8;
    byte[] bytes = address.getAddress();
    if (offset < bytes.length) {
        for (bytes[offset] <<= prefixLength % 8; offset < bytes.length; ++offset) {
            if (bytes[offset] != 0) {
                throw new IllegalArgumentException(""Bad address"");
            }
        }
    }
    mRoutes.add(new RouteInfo(new LinkAddress(address, prefixLength), null));
    return this;
}",1,"/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
","/**
 * Add a network route to the VPN interface. Both IPv4 and IPv6
 * routes are supported.
 *
 * @throws IllegalArgumentException if the route is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The changed portion of the code is where the mRoutes object is being allocated. In the early version the mRoutes is allocated using a string output from the 'String.format()' method, while in the late version the mRoutes takes input from a new object, 'RouteInfo' whose constructor takes two parameters including one newly introduced local object 'LinkAddress'. Therefore the change types are 1,5.","Although there's a change in the implementation of mRoutes allocation, it doesn't impact the final output value of the method or the exception handling process, hence there is no compatibility issue (type 0). The function always returns the instance of the class itself(""return this""). Therefore, the modifications within the function do not affect the return value."
210,<android.app.ActivityThread.H: void handleMessage(Message)>,18,19,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ACTIVITY_EXTRAS:
            handleRequestActivityExtras((RequestActivityExtras) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
213,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(StatusBarNotification)>,18,19,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(StatusBarNotification)>,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationPosted(StatusBarNotification)>,0,"{
    NotificationListenerService.this.onNotificationPosted(sbn);
}","{
    try {
        NotificationListenerService.this.onNotificationPosted(sbn);
    } catch (Throwable t) {
        Log.w(TAG, ""Error running onNotificationPosted"", t);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"The late version has introduced a try-catch block to handle any Throwable, so the change type is 2.","As the late version has potential to handle more exceptions that could lead to different bahaviour when invoking the API, so the CI type is 2."
214,<android.widget.RemoteViews.Action: void updateMemoryUsageEstimate(MemoryUsageCounter)>,18,19,<android.widget.RemoteViews.Action: void updateMemoryUsageEstimate(MemoryUsageCounter)>,<android.widget.RemoteViews.Action: void updateMemoryUsageEstimate(MemoryUsageCounter)>,0,"{
    // here
    return;
}","{
// We currently only calculate Bitmap memory usage, so by default,
// don't do anything here
}",1,"/**
 * Overridden by each class to report on it's own memory usage
 */
","/**
 * Overridden by each class to report on it's own memory usage
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the early and the late version is the removal of the 'return' statement which is superfluous in a void method. Hence, the code change type is 4: other statement changed.","Since the functionality of the method remains the same between both versions, no CI should arise from this change. Thus, the CI type is classified as 0: No Compatibility Issue exist."
216,<android.database.AbstractCursor: Uri getNotificationUri()>,18,19,<android.database.AbstractCursor: Uri getNotificationUri()>,<android.database.AbstractCursor: Uri getNotificationUri()>,0,"{
    return mNotifyUri;
}","{
    synchronized (mSelfObserverLock) {
        return mNotifyUri;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The new 'synchronized' statement has been introduced after the 'return' statement in the late version, so the code change type is 3.","Although there is a 'synchronized' statement introduced in the late version, it won't affect the return value or introduces a new exception, so there are no Compatibility Issues. The type is 0."
217,"<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>",18,19,"<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>","<android.bluetooth.BluetoothGattService: BluetoothGattCharacteristic getCharacteristic(UUID,int)>",0,"{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid()) && mInstanceId == instanceId)
            return characteristic;
    }
    return null;
}","{
    for (BluetoothGattCharacteristic characteristic : mCharacteristics) {
        if (uuid.equals(characteristic.getUuid()) && characteristic.getInstanceId() == instanceId)
            return characteristic;
    }
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Statement 'mInstanceId == instanceId' in early version was changed to 'characteristic.getInstanceId() == instanceId' in the late version, so the change type is 4.","The change in logic may alter the result of the condition check within the if block, which could affect the returned BluetoothGattCharacteristic, and causing possibility of getting different return values, so the CI type is 1."
219,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,18,19,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,0,"{
    checkThread();
    return mProvider.restoreState(inState);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""restoreState"");
    return mProvider.restoreState(inState);
}",1,"/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
","/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,An extra debugging log statement is added in the late version code. So the code change type is 4.,"The addition of a logging statement doesn't affect the behaviour of the API potentially return a different value or throw a different exception, so there is no Compatibility Issue - CI type 0."
220,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,18,19,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the ""if"" condition check for ""flags != o.flags"", new operations have been added in the late version, which updates the variable ""changes"" differently. Therefore, the code change type is 4, directly relative to variable assignment changes.","With the new operations added in the flag's check, it results in a potential different value being assigned to the ""changes"" variable, which eventually gets returned by the method, causing a potential different return value. The CI type is therefore 1."
221,<android.widget.GridLayout: int getColumnCount()>,18,19,<android.widget.GridLayout: int getColumnCount()>,<android.widget.GridLayout: int getColumnCount()>,0,"{
    return horizontalAxis.getCount();
}","{
    return mHorizontalAxis.getCount();
}",1,"/**
 * Returns the current number of columns. This is either the last value that was set
 * with {@link #setColumnCount(int)} or, if no such value was set, the maximum
 * value of each the upper bounds defined in {@link LayoutParams#columnSpec}.
 *
 * @return the current number of columns
 *
 * @see #setColumnCount(int)
 * @see LayoutParams#columnSpec
 *
 * @attr ref android.R.styleable#GridLayout_columnCount
 */
","/**
 * Returns the current number of columns. This is either the last value that was set
 * with {@link #setColumnCount(int)} or, if no such value was set, the maximum
 * value of each the upper bounds defined in {@link LayoutParams#columnSpec}.
 *
 * @return the current number of columns
 *
 * @see #setColumnCount(int)
 * @see LayoutParams#columnSpec
 *
 * @attr ref android.R.styleable#GridLayout_columnCount
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from calling the getCount() method on 'horizontalAxis' to calling it on 'mHorizontalAxis'. The name of the object that the method getCount() is invoked on changed. so the code change type is 1,5.",The returned value may change because it is now obtained from a different object ('mHorizontalAxis' instead of 'horizontalAxis'). Therefore potentially causing a compatibility issue of type 1.
222,<android.view.WindowManager.LayoutParams: String toString()>,18,19,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        if ((privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW) != 0) {
            sb.append("" compatible=true"");
        }
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if (rotationAnimation != ROTATION_ANIMATION_ROTATE) {
        sb.append("" rotAnim="");
        sb.append(rotationAnimation);
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"Other statements have changed, specifically related to how the 'compatible' flag is added to the StringBuilder. In the earlier version, it was dependent on flags (flags & FLAG_COMPATIBLE_WINDOW != 0), in the later version, it's dependent on privateFlags (privateFlags & PRIVATE_FLAG_COMPATIBLE_WINDOW != 0). ","This change can lead to a different output string generated by the toString() method, therefore the return variable can be potentially different, resulting a CI type of 1."
223,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,18,19,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,<android.text.TextUtils: int getLayoutDirectionFromLocale(Locale)>,0,"{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    return View.LAYOUT_DIRECTION_LTR;
}","{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}",1,"/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
","/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement inside ""return View.LAYOUT_DIRECTION_LTR;"" has changed to ""return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;"" so the code change type is 1.","The return value could be different due to the change in how it is computed in ""return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;"". Therefore, the CI type is 1."
226,<android.content.pm.ResolveInfo: int getIconResource()>,18,19,<android.content.pm.ResolveInfo: int getIconResource()>,<android.content.pm.ResolveInfo: int getIconResource()>,0,"{
    if (icon != 0)
        return icon;
    if (activityInfo != null)
        return activityInfo.getIconResource();
    if (serviceInfo != null)
        return serviceInfo.getIconResource();
    return 0;
}","{
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null)
        return ci.getIconResource();
    return 0;
}",1,"/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
","/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"There are changes at the return statements and the control dependencies. The conditional expression has changed from checking the activities and services to checking a ComponentInfo object. A new dependent API `getComponentInfo()` is used to get the component info prior to checking the icon resource. Hence, the change type is 1,3,4,5.","The return variable from `getIconResource` may be different in the later version due to the different dependencies which are either `activityInfo` or `serviceInfo` in the early version and `ComponentInfo` in the late version. Therefore, the CI type is 1."
227,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",18,19,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.isInUse()) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null) {
        throw new AndroidRuntimeException(""Message must have a target."");
    }
    boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        }
        msg.when = when;
        Message p = mMessages;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}","{
    if (msg.isInUse()) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null) {
        throw new AndroidRuntimeException(""Message must have a target."");
    }
    synchronized (this) {
        if (mQuitting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        }
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (; ; ) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        }
        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's only one change in the code, the variable name 'mQuiting' is corrected to 'mQuitting' in the 'if' condition. Which is not a significant change. Therefore, the change type is 4.","The change of the variable name from 'mQuiting' to 'mQuitting' does not affect the behaviour of the API, it will neither return a different value nor throw a different exception. Hence there is no Compatibility Issue (CI). The CI type is 0."
228,<android.app.Activity: void performPause()>,18,19,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    mResumed = false;
}","{
    mDoReportFullyDrawn = false;
    mFragments.dispatchPause();
    mCalled = false;
    onPause();
    mResumed = false;
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional parameter initialization, mDoReportFullyDrawn = false, has been added to the start of the implementation in the late version. Other than this, there are no changes in the implementation of this method between the two versions. The code change type is 4.","The added parameter initialization doesn't result in any difference in the returned values, nor does it introduce a new exception or change existing ones. Consequently, there are no compatibility issues (CI type 0)."
229,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,18,19,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean readDescriptor(BluetoothGattDescriptor)>,0,"{
    if (DBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""readDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
","/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method invocation 'mService.readDescriptor(..)' has been changed with an additional parameter 'descriptor.getInstanceId()', so the code change type is 4,5.","As the dependent API 'mService.readDescriptor(...)' has changed which might give different outcomes, thereby leading to change in return value. Thus, the CI type is 1."
230,<android.os.ParcelFileDescriptor: void close()>,18,19,<android.os.ParcelFileDescriptor: void close()>,<android.os.ParcelFileDescriptor: void close()>,0,"{
    if (mClosed)
        return;
    mClosed = true;
    mGuard.close();
    if (mWrapped != null) {
        // If this is a proxy to another file descriptor, just call through to its
        // close method.
        mWrapped.close();
    } else {
        Parcel.closeFileDescriptor(mFileDescriptor);
    }
}","{
    if (mWrapped != null) {
        try {
            mWrapped.close();
        } finally {
            releaseResources();
        }
    } else {
        closeWithStatus(Status.OK, null);
    }
}",1,"/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
","/**
 * Close the ParcelFileDescriptor. This implementation closes the underlying
 * OS resources allocated to represent this stream.
 *
 * @throws IOException
 * If an error occurs attempting to close this ParcelFileDescriptor.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","The early version of this method only checks if `mClosed` is true and if so, returns. If `mClosed` is false, it will set `mClosed` to true, close `mGuard` and either close `mWrapped` or `mFileDescriptor`. But in the late version, first, it checks if `mWrapped` is null. If `mWrapped` is not null, it tries to close `mWrapped` and then releases resources. If `mWrapped` is null, it will call the `closeWithStatus` method. So, the code change type is 3,4.","The change in the control flow and other statements can lead to different returned values (e.g., method returns directly in early version when `mClosed` is true, but no such condition in the late version) and exceptions thrown (e.g., potential exception thrown by `mWrapped.close()` in the late version). Therefore, the CI type is 1,2."
231,"<android.widget.AbsListView: View obtainView(int,boolean[])>",18,19,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView != null) {
        return scrapView;
    }
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView == null) {
        scrapView = mRecycler.getScrapView(position);
    }
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are a series of changes happened between two versions, including rearrangement and combinations of conditions, additional child.clearAccessibilityFocus() when child.isAccessibilityFocused(), introduction of Trace method, etc. Therefore, it falls under code change types 1,3,4.","The most notable compatibility issue is the addition of child.clearAccessibilityFocus() which may cause the function to return different results depending on whether 'child' is focused or not. Hence, the CI type is 1."
233,"<android.widget.ListView: int lookForSelectablePosition(int,boolean)>",18,19,"<android.widget.ListView: int lookForSelectablePosition(int,boolean)>","<android.widget.ListView: int lookForSelectablePosition(int,boolean)>",0,"{
    final ListAdapter adapter = mAdapter;
    if (adapter == null || isInTouchMode()) {
        return INVALID_POSITION;
    }
    final int count = adapter.getCount();
    if (!mAreAllItemsSelectable) {
        if (lookDown) {
            position = Math.max(0, position);
            while (position < count && !adapter.isEnabled(position)) {
                position++;
            }
        } else {
            position = Math.min(position, count - 1);
            while (position >= 0 && !adapter.isEnabled(position)) {
                position--;
            }
        }
        if (position < 0 || position >= count) {
            return INVALID_POSITION;
        }
        return position;
    } else {
        if (position < 0 || position >= count) {
            return INVALID_POSITION;
        }
        return position;
    }
}","{
    final ListAdapter adapter = mAdapter;
    if (adapter == null || isInTouchMode()) {
        return INVALID_POSITION;
    }
    final int count = adapter.getCount();
    if (!mAreAllItemsSelectable) {
        if (lookDown) {
            position = Math.max(0, position);
            while (position < count && !adapter.isEnabled(position)) {
                position++;
            }
        } else {
            position = Math.min(position, count - 1);
            while (position >= 0 && !adapter.isEnabled(position)) {
                position--;
            }
        }
    }
    if (position < 0 || position >= count) {
        return INVALID_POSITION;
    }
    return position;
}",1,"/**
 * Find a position that can be selected (i.e., is not a separator).
 *
 * @param position The starting position to look at.
 * @param lookDown Whether to look down for other positions.
 * @return The next selectable position starting at position and then searching either up or
 * down. Returns {@link #INVALID_POSITION} if nothing can be found.
 */
","/**
 * Find a position that can be selected (i.e., is not a separator).
 *
 * @param position The starting position to look at.
 * @param lookDown Whether to look down for other positions.
 * @return The next selectable position starting at position and then searching either up or
 * down. Returns {@link #INVALID_POSITION} if nothing can be found.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The internal control dependency of the 'if' statement has been changed, which results in a block of code being deleted in the later version. Therefore, the code change type is 4.","Due to the code block removal, the API could potentially return a different value in the late version compared to the early one. Therefore, the CI type is 1."
234,<android.view.HardwareRenderer.GlRenderer.FunctorsRunnable: void run()>,18,19,<android.view.HardwareRenderer.GlRenderer.FunctorsRunnable: void run()>,<android.view.HardwareRenderer.GlRenderer.FunctorsRunnable: void run()>,0,"{
    final HardwareRenderer renderer = attachInfo.mHardwareRenderer;
    if (renderer == null || !renderer.isEnabled() || renderer != GlRenderer.this) {
        return;
    }
    final int surfaceState = checkCurrent();
    if (surfaceState != SURFACE_STATE_ERROR) {
        int status = mCanvas.invokeFunctors(mRedrawClip);
        handleFunctorStatus(attachInfo, status);
    }
}","{
    final HardwareRenderer renderer = attachInfo.mHardwareRenderer;
    if (renderer == null || !renderer.isEnabled() || renderer != GlRenderer.this) {
        return;
    }
    if (checkRenderContext() != SURFACE_STATE_ERROR) {
        int status = mCanvas.invokeFunctors(mRedrawClip);
        handleFunctorStatus(attachInfo, status);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"There is a replacement of method 'checkCurrent()' with 'checkRenderContext()' in the control statement, so the change type is 4,5.","The running of the API is not affected by the change of the dependent method name in the control statement, as the function of both methods look similar and no additional return statement or exception handling is added. Therefore, no CI type is detected."
235,<android.widget.ListView: void layoutChildren()>,18,19,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Remember which child, if any, had accessibility focus. This must
        // occur before recycling any views, since that will clear
        // accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View accessFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (accessFocusedView != null) {
                final View accessFocusedChild = findAccessibilityFocusedChild(accessFocusedView);
                if (accessFocusedChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(accessFocusedChild)) {
                        // If the views won't be changing, try to maintain
                        // focus on the current view host and (if
                        // applicable) its virtual view.
                        accessibilityFocusLayoutRestoreView = accessFocusedView;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    } else {
                        // Otherwise, try to maintain focus at the same
                        // position.
                        accessibilityFocusPosition = getPositionForView(accessFocusedChild);
                    }
                }
            }
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus.
        if (accessibilityFocusLayoutRestoreView != null) {
            final AccessibilityNodeProvider provider = accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();
            if ((accessibilityFocusLayoutRestoreNode != null) && (provider != null)) {
                final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(accessibilityFocusLayoutRestoreNode.getSourceNodeId());
                provider.performAction(virtualViewId, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
            } else {
                accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
            }
        } else if (accessibilityFocusPosition != INVALID_POSITION) {
            // Bound the position within the visible children.
            final int position = MathUtils.constrain((accessibilityFocusPosition - mFirstPosition), 0, (getChildCount() - 1));
            final View restoreView = getChildAt(position);
            if (restoreView != null) {
                restoreView.requestAccessibilityFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (blockLayoutRequests) {
        return;
    }
    mBlockLayoutRequests = true;
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only from "" + ""the UI thread. Make sure your adapter calls notifyDataSetChanged() "" + ""when its content changes. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Remember which child, if any, had accessibility focus.
        final int accessibilityFocusPosition;
        final View accessFocusedChild = getAccessibilityFocusedChild();
        if (accessFocusedChild != null) {
            accessibilityFocusPosition = getPositionForView(accessFocusedChild);
            accessFocusedChild.setHasTransientState(true);
        } else {
            accessibilityFocusPosition = INVALID_POSITION;
        }
        // Ensure the child containing focus, if any, has transient state.
        // If the list data hasn't changed, or if the adapter has stable
        // IDs, this will maintain focus.
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            focusedChild.setHasTransientState(true);
        }
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            final boolean shouldPlaceFocus = mItemsCanFocus && hasFocus();
            final boolean maintainedFocus = focusedChild != null && focusedChild.hasFocus();
            if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
                if (sel.requestFocus()) {
                    // Successfully placed focus, clear selection.
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                } else {
                    // Failed to place focus, clear current (invalid) focus.
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            // Otherwise, clear selection.
            if (mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING) {
                final View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null) {
                    positionSelector(mMotionPosition, child);
                }
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
        }
        if (accessFocusedChild != null) {
            accessFocusedChild.setHasTransientState(false);
            // view, attempt to restore it to the previous position.
            if (!accessFocusedChild.isAccessibilityFocused() && accessibilityFocusPosition != INVALID_POSITION) {
                // Bound the position within the visible children.
                final int position = MathUtils.constrain(accessibilityFocusPosition - mFirstPosition, 0, getChildCount() - 1);
                final View restoreView = getChildAt(position);
                if (restoreView != null) {
                    restoreView.requestAccessibilityFocus();
                }
            }
        }
        if (focusedChild != null) {
            focusedChild.setHasTransientState(false);
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
236,"<android.util.SparseBooleanArray: boolean get(int,boolean)>",18,19,"<android.util.SparseBooleanArray: boolean get(int,boolean)>","<android.util.SparseBooleanArray: boolean get(int,boolean)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0) {
        return valueIfKeyNotFound;
    } else {
        return mValues[i];
    }
}",1,"/**
 * Gets the boolean mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
","/**
 * Gets the boolean mapped from the specified key, or the specified value
 * if no such mapping has been made.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The code has changed from using an inbuilt binary search function, to using a binary search function from the 'ContainerHelpers' class. Hence the change type is 5.","Despite the change in the function being called for binary search, the return behaviour of the API hasn't changed. It still returns 'valueIfKeyNotFound' when the key is not found, and returns the value at index 'i' in 'mValues' when the key is found. Therefore, this change doesn't lead to any Compatibility Issue, hence the CI type is 0."
239,<android.os.MessageQueue: Message next()>,18,19,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuiting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        // We can assume mPtr != 0 because the loop is obviously still running.
        // The looper will not call this method after the loop quits.
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount <= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no substantial code change from early version to late version except the added comment, so the code change type is 0.","Since there is no code change, there is no compatibility issue, so the CI type is 0."
240,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,18,19,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_KEY:
            return ""MSG_DISPATCH_KEY"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_INPUT_EVENT:
            return ""MSG_DISPATCH_INPUT_EVENT"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
        case MSG_FLUSH_LAYER_UPDATES:
            return ""MSG_FLUSH_LAYER_UPDATES"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The case ""MSG_DISPATCH_KEY"" is replaced by ""MSG_DISPATCH_INPUT_EVENT"" and ""MSG_FLUSH_LAYER_UPDATES"" is added in the switch block, so the code change type is 1,3.","Due to the changes in the control dependency (switch-case) and return statements, the method may return different string values in the late version. This leads to the Compatibility Issue type 1."
241,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>",18,19,"<android.content.ContentProviderClient: int delete(Uri,String,String[])>","<android.content.ContentProviderClient: int delete(Uri,String,String[])>",0,"{
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
","/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The added 'beforeRemote()' and 'afterRemote()' statements in late implementation are other non-special statements, hence the change type is 4.","These new added statements do not change the behavior of API in terms of changing return value or throwing a new exception. Therefore, no compatibility issue (CI type 0) exists."
242,<android.os.Environment: String getExternalStorageState()>,18,19,<android.os.Environment: String getExternalStorageState()>,<android.os.Environment: String getExternalStorageState()>,0,"{
    try {
        IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        final StorageVolume primary = getPrimaryVolume();
        return mountService.getVolumeState(primary.getPath());
    } catch (RemoteException rex) {
        Log.w(TAG, ""Failed to read external storage state; assuming REMOVED: "" + rex);
        return Environment.MEDIA_REMOVED;
    }
}","{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getStorageState(externalDir);
}",1,"/**
 * Gets the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 */
","/**
 * Returns the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire body of the implementation has been replaced with a single return statement which produces the external storage state in a different manner. The method called as well as the parameter were changed, so the code change type is 1,4,5.","The method for getting the external storage state has been completely changed, and this results in potentially different return values thus the CI type is 1."
245,<android.util.LongSparseArray: int indexOfKey(long)>,18,19,<android.util.LongSparseArray: int indexOfKey(long)>,<android.util.LongSparseArray: int indexOfKey(long)>,0,"{
    if (mGarbage) {
        gc();
    }
    return binarySearch(mKeys, 0, mSize, key);
}","{
    if (mGarbage) {
        gc();
    }
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed and one API that the function depends on has changed. The change from using 'binarySearch' to 'ContainerHelpers.binarySearch' suggests that the API this function depends on has changed, thus pred_change should be 1,5.","With the change of the return statement, it's possible that the function may return different values in different versions under the same conditions, hence the CI type is 1."
246,"<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>",18,19,"<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>","<android.widget.HeaderViewListAdapter: View getView(int,View,ViewGroup)>",0,"{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).view;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getView(adjPosition, convertView, parent);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).view;
}","{
    // Header (negative positions will throw an IndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).view;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getView(adjPosition, convertView, parent);
        }
    }
    // Footer (off-limits positions will throw an IndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).view;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change but only comment change between the early version and the late version.,"Since there is no code change, so there is no Compatibility Issue between the two versions."
247,<android.widget.TextView: float getRightFadingEdgeStrength()>,18,19,<android.widget.TextView: float getRightFadingEdgeStrength()>,<android.widget.TextView: float getRightFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            final float maxFadeScroll = marquee.getMaxFadeScroll();
            final float scroll = marquee.getScroll();
            return (maxFadeScroll - scroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            final float maxFadeScroll = marquee.getMaxFadeScroll();
            final float scroll = marquee.getScroll();
            return (maxFadeScroll - scroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    final int textDirection = mLayout.getParagraphDirection(0);
                    if (textDirection == Layout.DIR_RIGHT_TO_LEFT) {
                        return 0.0f;
                    } else {
                        return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
                    }
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement (switch-case) has been modified, and a new statement has been introduced to determine the value of variable 'textDirection', so the code change type is 3,4.","This modification potentially changes the return value of 'getRightFadingEdgeStrength()', so the CI type is 1."
251,<android.app.NativeActivity: void onCreate(Bundle)>,18,19,<android.app.NativeActivity: void onCreate(Bundle)>,<android.app.NativeActivity: void onCreate(Bundle)>,0,"{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    String path = null;
    File libraryFile = new File(ai.applicationInfo.nativeLibraryDir, System.mapLibraryName(libname));
    if (libraryFile.exists()) {
        path = libraryFile.getPath();
    }
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library: "" + libname);
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getFilesDir().toString(), getObbDir().toString(), Environment.getExternalStorageAppFilesDirectory(ai.packageName).toString(), Build.VERSION.SDK_INT, getAssets(), nativeSavedState);
    if (mNativeHandle == 0) {
        throw new IllegalArgumentException(""Unable to load native library: "" + path);
    }
    super.onCreate(savedInstanceState);
}","{
    String libname = ""main"";
    String funcname = ""ANativeActivity_onCreate"";
    ActivityInfo ai;
    mIMM = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    getWindow().takeSurface(this);
    getWindow().takeInputQueue(this);
    getWindow().setFormat(PixelFormat.RGB_565);
    getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
    mNativeContentView = new NativeContentView(this);
    mNativeContentView.mActivity = this;
    setContentView(mNativeContentView);
    mNativeContentView.requestFocus();
    mNativeContentView.getViewTreeObserver().addOnGlobalLayoutListener(this);
    try {
        ai = getPackageManager().getActivityInfo(getIntent().getComponent(), PackageManager.GET_META_DATA);
        if (ai.metaData != null) {
            String ln = ai.metaData.getString(META_DATA_LIB_NAME);
            if (ln != null)
                libname = ln;
            ln = ai.metaData.getString(META_DATA_FUNC_NAME);
            if (ln != null)
                funcname = ln;
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException(""Error getting activity info"", e);
    }
    String path = null;
    File libraryFile = new File(ai.applicationInfo.nativeLibraryDir, System.mapLibraryName(libname));
    if (libraryFile.exists()) {
        path = libraryFile.getPath();
    }
    if (path == null) {
        throw new IllegalArgumentException(""Unable to find native library: "" + libname);
    }
    byte[] nativeSavedState = savedInstanceState != null ? savedInstanceState.getByteArray(KEY_NATIVE_SAVED_STATE) : null;
    mNativeHandle = loadNativeCode(path, funcname, Looper.myQueue(), getAbsolutePath(getFilesDir()), getAbsolutePath(getObbDir()), getAbsolutePath(getExternalFilesDir(null)), Build.VERSION.SDK_INT, getAssets(), nativeSavedState);
    if (mNativeHandle == 0) {
        throw new IllegalArgumentException(""Unable to load native library: "" + path);
    }
    super.onCreate(savedInstanceState);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","In the late version, methods such as getAbsolutePath(getFilesDir()), getAbsolutePath(getObbDir()), getAbsolutePath(getExternalFilesDir(null)) have been introduced, so the change type is 4,5.","Potential behaviors of the API may differ because of these method changes. Different return values (even different exceptions) may be produced because of these modifications, hence CI types are 1 and 2."
253,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,18,19,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,<android.content.IntentFilter: void writeToXml(XmlSerializer)>,0,"{
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}","{
    int N = countActions();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, ACTION_STR);
        serializer.attribute(null, NAME_STR, mActions.get(i));
        serializer.endTag(null, ACTION_STR);
    }
    N = countCategories();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, CAT_STR);
        serializer.attribute(null, NAME_STR, mCategories.get(i));
        serializer.endTag(null, CAT_STR);
    }
    N = countDataTypes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, TYPE_STR);
        String type = mDataTypes.get(i);
        if (type.indexOf('/') < 0)
            type = type + ""/*"";
        serializer.attribute(null, NAME_STR, type);
        serializer.endTag(null, TYPE_STR);
    }
    N = countDataSchemes();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SCHEME_STR);
        serializer.attribute(null, NAME_STR, mDataSchemes.get(i));
        serializer.endTag(null, SCHEME_STR);
    }
    N = countDataSchemeSpecificParts();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, SSP_STR);
        PatternMatcher pe = mDataSchemeSpecificParts.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, SSP_STR);
    }
    N = countDataAuthorities();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, AUTH_STR);
        AuthorityEntry ae = mDataAuthorities.get(i);
        serializer.attribute(null, HOST_STR, ae.getHost());
        if (ae.getPort() >= 0) {
            serializer.attribute(null, PORT_STR, Integer.toString(ae.getPort()));
        }
        serializer.endTag(null, AUTH_STR);
    }
    N = countDataPaths();
    for (int i = 0; i < N; i++) {
        serializer.startTag(null, PATH_STR);
        PatternMatcher pe = mDataPaths.get(i);
        switch(pe.getType()) {
            case PatternMatcher.PATTERN_LITERAL:
                serializer.attribute(null, LITERAL_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_PREFIX:
                serializer.attribute(null, PREFIX_STR, pe.getPath());
                break;
            case PatternMatcher.PATTERN_SIMPLE_GLOB:
                serializer.attribute(null, SGLOB_STR, pe.getPath());
                break;
        }
        serializer.endTag(null, PATH_STR);
    }
}",1,"/**
 * Write the contents of the IntentFilter as an XML stream.
 */
","/**
 * Write the contents of the IntentFilter as an XML stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation block that deals with ""countDataAuthorities()"" disappeared and a new block dealing with ""countDataSchemeSpecificParts()"" emerged in the late version. This involves return statement changes, control dependency changes (loop), and other statements changes (within the loop) which implies change types 1, 3 and 4.","The removal of a control structure that yields certain return values (as part of the XML) and addition of a new control structure that yields a different set of return values is bound to cause a different output of the function when called. Hence, this change can potentially cause a compatibility issue of type 1 (return values or types)."
254,"<android.view.Surface: void writeToParcel(Parcel,int)>",18,19,"<android.view.Surface: void writeToParcel(Parcel,int)>","<android.view.Surface: void writeToParcel(Parcel,int)>",0,"{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    synchronized (mLock) {
        dest.writeString(mName);
        nativeWriteToParcel(mNativeSurface, dest);
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}","{
    if (dest == null) {
        throw new IllegalArgumentException(""dest must not be null"");
    }
    synchronized (mLock) {
        dest.writeString(mName);
        nativeWriteToParcel(mNativeObject, dest);
    }
    if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
        release();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API (nativeWriteToParcel)'s second parameter has changed from mNativeSurface to mNativeObject, so the code change type is 4,5.","The change of dependent API (nativeWriteToParcel) could make the function behave differently and potentially return different values. So, the CI type is 1."
255,<android.webkit.WebView: HitTestResult getHitTestResult()>,18,19,<android.webkit.WebView: HitTestResult getHitTestResult()>,<android.webkit.WebView: HitTestResult getHitTestResult()>,0,"{
    checkThread();
    return mProvider.getHitTestResult();
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""getHitTestResult"");
    return mProvider.getHitTestResult();
}",1,"/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Gets a HitTestResult based on the current cursor node. If a HTML::a
 * tag is found and the anchor has a non-JavaScript URL, the HitTestResult
 * type is set to SRC_ANCHOR_TYPE and the URL is set in the ""extra"" field.
 * If the anchor does not have a URL or if it is a JavaScript URL, the type
 * will be UNKNOWN_TYPE and the URL has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the URL is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a URL that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional debugging statement, 'Log.d(LOGTAG, ""getHitTestResult"")', has been added, which will produce debugging output if the DebugFlags.TRACE_API is true. Thus, the code change type is 4.","The newly added statement is a debugging statement and does not alter the return value or exception handling of the method, so there is no compatibility issue, and the CI type is 0."
256,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",18,19,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>","<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",0,"{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, mContext.getUserId(), mContext.getBasePackageName());
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, mContext.getUserId(), mContext.getOpPackageName());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",No Compatibility Issue exist,"There's a change in the method called in the try block from `mContext.getBasePackageName()` to `mContext.getOpPackageName()`, hence corresponding to the classes 1 (return statement changed) and 5 (dependent API changed).","However, despite these changes, they do not lead to potentially different return values, types or exception handling, hence causing no Compatibility Issue."
257,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationRemoved(StatusBarNotification)>,18,19,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationRemoved(StatusBarNotification)>,<android.service.notification.NotificationListenerService.INotificationListenerWrapper: void onNotificationRemoved(StatusBarNotification)>,0,"{
    NotificationListenerService.this.onNotificationRemoved(sbn);
}","{
    try {
        NotificationListenerService.this.onNotificationRemoved(sbn);
    } catch (Throwable t) {
        Log.w(TAG, ""Error running onNotificationRemoved"", t);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3",0,"Exception handling statement and a control dependency (try-catch block) is introduced in the late version. So the code change type is 2,3.","This change is a CI prevention measure. It does not cause different behavior between the two versions, as even though an exception handling block is added, the API is not throwing any new exception. So the CI type is 0."
259,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",18,19,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Rect,Rect,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int left, top, right, bottom;
        if (src == null) {
            left = top = 0;
            right = bitmap.getWidth();
            bottom = bitmap.getHeight();
        } else {
            left = src.left;
            right = src.right;
            top = src.top;
            bottom = src.bottom;
        }
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, left, top, right, bottom, dst.left, dst.top, dst.right, dst.bottom, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5",2,"The exception handling with `throw new IllegalArgumentException(""Cannot draw recycled bitmaps"")` statement in the early version has been replaced by `throwIfCannotDraw(bitmap)` statement in the late version. Additionally, the dependent API `bitmap.isRecycled()` used inside the exception block is replaced by `throwIfCannotDraw(bitmap)` in the late version. Therefore, the code change types are 2, 4, and 5.","The exception thrown by the method has potentially changed due to the removal of the `IllegalArgumentException` and inclusion of a call to another method that we infer might throw an exception (`throwIfCannotDraw(bitmap)`). Therefore, the CI type is 2."
260,<android.app.Activity: LoaderManager getLoaderManager()>,18,19,<android.app.Activity: LoaderManager getLoaderManager()>,<android.app.Activity: LoaderManager getLoaderManager()>,0,"{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = getLoaderManager(null, mLoadersStarted, true);
    return mLoaderManager;
}","{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = getLoaderManager(""(root)"", mLoadersStarted, true);
    return mLoaderManager;
}",1,"/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
","/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter of getLoaderManager() has been modified from null to ""(root)"", so the code change type is 1,5.","The change of getLoaderManager() will make the API potentially return a different value, so the CI type is 1."
261,<android.content.ClipboardManager: boolean hasText()>,18,19,<android.content.ClipboardManager: boolean hasText()>,<android.content.ClipboardManager: boolean hasText()>,0,"{
    try {
        return getService().hasClipboardText(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}",1,"/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
","/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API getService().hasClipboardText() has changed from calling mContext.getBasePackageName() to mContext.getOpPackageName(). Thus, the code change type is both return statement change (1)  and dependent API changed (5).","The output of the function can directly influence the returned boolean value when the 'hasClipboardText' method is called, leading to different behaviours. Thus, the CI type is potential different return values or types (1)."
262,<android.content.ContentResolver: InputStream openInputStream(Uri)>,18,19,<android.content.ContentResolver: InputStream openInputStream(Uri)>,<android.content.ContentResolver: InputStream openInputStream(Uri)>,0,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"");
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}","{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, ""r"", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException(""Unable to create stream"");
        }
    }
}",1,"/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
","/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent method call openAssetFileDescriptor(uri, ""r"") has changed to openAssetFileDescriptor(uri, ""r"", null), where the parameter list is changed. Therefore, the change type is 5.","Because of the change, the value of 'fd' and consequently the return value could be different in different versions. Therefore, the CI type is 1."
264,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,18,19,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,0,"{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[mAllLoaderManagers.size()];
        mAllLoaderManagers.values().toArray(loaders);
        if (loaders != null) {
            for (int i = 0; i < loaders.length; i++) {
                LoaderManagerImpl lm = loaders[i];
                if (lm.mRetaining) {
                    retainLoaders = true;
                } else {
                    lm.doDestroy();
                    mAllLoaderManagers.remove(lm.mWho);
                }
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    return nci;
}","{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        final int N = mAllLoaderManagers.size();
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[N];
        for (int i = N - 1; i >= 0; i--) {
            loaders[i] = mAllLoaderManagers.valueAt(i);
        }
        for (int i = 0; i < N; i++) {
            LoaderManagerImpl lm = loaders[i];
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.remove(lm.mWho);
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    return nci;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The way of getting the loader manager's values has been changed from using 'mAllLoaderManagers.values().toArray(loaders)' to manually getting values by index in loop. This belongs to both 'control dependency change' and 'other statement change', so the code change type is 3,4.","While the processing sequence of loader managers has changed, the overall behavior of the API implementation remains the same with respect to the returned value and exceptions thrown. Therefore, no compatibility issue (CI) exists. Thus the CI type is 0."
267,<android.util.SparseIntArray: int indexOfKey(int)>,18,19,<android.util.SparseIntArray: int indexOfKey(int)>,<android.util.SparseIntArray: int indexOfKey(int)>,0,"{
    return binarySearch(mKeys, 0, mSize, key);
}","{
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent method called has changed from binarySearch(mKeys, 0, mSize, key) to ContainerHelpers.binarySearch(mKeys, mSize, key), so the code change type is 5.","As the dependent method called has changed, it can potentially lead to a different return value, so the CI type is 1."
268,"<android.util.LongSparseArray: void put(long,E)>",18,19,"<android.util.LongSparseArray: void put(long,E)>","<android.util.LongSparseArray: void put(long,E)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~binarySearch(mKeys, 0, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealLongArraySize(mSize + 1);
            long[] nkeys = new long[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealLongArraySize(mSize + 1);
            long[] nkeys = new long[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}",1,"/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
","/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method binarySearch is changed from mKeys, 0, mSize, key to ContainerHelpers.binarySearch(mKeys, mSize, key), therefore the change type is: 5 (Dependent API changed).","There's no Compatibility Issue detected because the behavior of the binarySearch() function is not changed despite the change of underlying API, and consequently it does not affect the returned value or exception handling of the method itself. Hence, the CI type is 0 (No Compatibility Issue exists)."
270,"<android.content.IntentFilter: void dump(Printer,String)>",18,19,"<android.content.IntentFilter: void dump(Printer,String)>","<android.content.IntentFilter: void dump(Printer,String)>",0,"{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
}","{
    StringBuilder sb = new StringBuilder(256);
    if (mActions.size() > 0) {
        Iterator<String> it = mActions.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Action: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mCategories != null) {
        Iterator<String> it = mCategories.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Category: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemes != null) {
        Iterator<String> it = mDataSchemes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Scheme: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataSchemeSpecificParts != null) {
        Iterator<PatternMatcher> it = mDataSchemeSpecificParts.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Ssp: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataAuthorities != null) {
        Iterator<AuthorityEntry> it = mDataAuthorities.iterator();
        while (it.hasNext()) {
            AuthorityEntry ae = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Authority: \"""");
            sb.append(ae.mHost);
            sb.append(""\"": "");
            sb.append(ae.mPort);
            if (ae.mWild)
                sb.append("" WILD"");
            du.println(sb.toString());
        }
    }
    if (mDataPaths != null) {
        Iterator<PatternMatcher> it = mDataPaths.iterator();
        while (it.hasNext()) {
            PatternMatcher pe = it.next();
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Path: \"""");
            sb.append(pe);
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mDataTypes != null) {
        Iterator<String> it = mDataTypes.iterator();
        while (it.hasNext()) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append(""Type: \"""");
            sb.append(it.next());
            sb.append(""\"""");
            du.println(sb.toString());
        }
    }
    if (mPriority != 0 || mHasPartialTypes) {
        sb.setLength(0);
        sb.append(prefix);
        sb.append(""mPriority="");
        sb.append(mPriority);
        sb.append("", mHasPartialTypes="");
        sb.append(mHasPartialTypes);
        du.println(sb.toString());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The if statement related to ""mDataSchemeSpecificParts"" has been added, which is another kind of statement other than return, throw and control dependent, so the code change type is 4.","Although an additional check on ""mDataSchemeSpecificParts"" has been introduced in the late version, this does not cause any incompatibility issues because it only affects the output of the dump process and has no effect on the actual behavior or result of the function. So, there is no Compatibility Issue according to the provided rules."
271,<android.content.pm.PackageParser.Service: String toString()>,18,19,<android.content.pm.PackageParser.Service: String toString()>,<android.content.pm.PackageParser.Service: String toString()>,0,"{
    return ""Service{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""Service{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,0,"The original method concatenates strings directly, and in the new version, it uses the StringBuilder to append strings. However, the same information gets eventually returned in both versions, so the code change type is 1.","Even if the implementation has changed, both versions return the same information in same format and type, therefore there's no impact on the behaviors of the API and the CI type is 0."
272,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",18,19,"<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>","<android.view.inputmethod.InputMethodManager: void updateSelection(View,int,int,int,int)>",0,"{
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                mCurMethod.updateSelection(mCursorSelStart, mCursorSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}","{
    checkFocus();
    synchronized (mH) {
        if ((mServedView != view && (mServedView == null || !mServedView.checkInputConnectionProxy(view))) || mCurrentTextBoxAttribute == null || mCurMethod == null) {
            return;
        }
        if (mCursorSelStart != selStart || mCursorSelEnd != selEnd || mCursorCandStart != candidatesStart || mCursorCandEnd != candidatesEnd) {
            if (DEBUG)
                Log.d(TAG, ""updateSelection"");
            try {
                if (DEBUG)
                    Log.v(TAG, ""SELECTION CHANGE: "" + mCurMethod);
                final int oldSelStart = mCursorSelStart;
                final int oldSelEnd = mCursorSelEnd;
                // Update internal values before sending updateSelection to the IME, because
                // if it changes the text within its onUpdateSelection handler in a way that
                // does not move the cursor we don't want to call it again with the same values.
                mCursorSelStart = selStart;
                mCursorSelEnd = selEnd;
                mCursorCandStart = candidatesStart;
                mCursorCandEnd = candidatesEnd;
                mCurMethod.updateSelection(oldSelStart, oldSelEnd, selStart, selEnd, candidatesStart, candidatesEnd);
            } catch (RemoteException e) {
                Log.w(TAG, ""IME died: "" + mCurId, e);
            }
        }
    }
}",1,"/**
 * Report the current selection range.
 */
","/**
 * Report the current selection range.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The change lies in the variable update order inside the second 'if' statement and the variables passed to the `mCurMethod.updateSelection` method - now, they have used the old values before update. Therefore, the change type is 4 since it's neither return change, exception handling change, nor control dependency change, but other intermediate steps.","The change in the order of the update can potentially lead to different return behaviour. Therefore, the Compatibility Issue exists due to potential different return values or methods, so the CI type is 1."
274,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,18,19,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,0,"{
    char[] order = new char[] { DATE, MONTH, YEAR };
    String value = getDateFormatString(context);
    int index = 0;
    boolean foundDate = false;
    boolean foundMonth = false;
    boolean foundYear = false;
    for (char c : value.toCharArray()) {
        if (!foundDate && (c == DATE)) {
            foundDate = true;
            order[index] = DATE;
            index++;
        }
        if (!foundMonth && (c == MONTH || c == STANDALONE_MONTH)) {
            foundMonth = true;
            order[index] = MONTH;
            index++;
        }
        if (!foundYear && (c == YEAR)) {
            foundYear = true;
            order[index] = YEAR;
            index++;
        }
    }
    return order;
}","{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}",1,"/**
 * Gets the current date format stored as a char array. The array will contain
 * 3 elements ({@link #DATE}, {@link #MONTH}, and {@link #YEAR}) in the order
 * specified by the user's format preference.  Note that this order is
 * only appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
","/**
 * Gets the current date format stored as a char array. The array will contain
 * 3 elements ({@link #DATE}, {@link #MONTH}, and {@link #YEAR}) in the order
 * specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The initial implementation of computing order has been removed and replaced with a call to ICU.getDateFormatOrder, indicating both a change in return statement and a change in dependent API.","Since the return statement has been altered and a different API is used to determine the order, this could potentially return a different value for the char array."
275,<android.animation.ObjectAnimator: String getPropertyName()>,18,19,<android.animation.ObjectAnimator: String getPropertyName()>,<android.animation.ObjectAnimator: String getPropertyName()>,0,"{
    return mPropertyName;
}","{
    String propertyName = null;
    if (mPropertyName != null) {
        propertyName = mPropertyName;
    } else if (mProperty != null) {
        propertyName = mProperty.getName();
    } else if (mValues != null && mValues.length > 0) {
        for (int i = 0; i < mValues.length; ++i) {
            if (i == 0) {
                propertyName = """";
            } else {
                propertyName += "","";
            }
            propertyName += mValues[i].getPropertyName();
        }
    }
    return propertyName;
}",1,"/**
 * Gets the name of the property that will be animated. This name will be used to derive
 * a setter function that will be called to set animated values.
 * For example, a property name of <code>foo</code> will result
 * in a call to the function <code>setFoo()</code> on the target object. If either
 * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
 * also be derived and called.
 */
","/**
 * Gets the name of the property that will be animated. This name will be used to derive
 * a setter function that will be called to set animated values.
 * For example, a property name of <code>foo</code> will result
 * in a call to the function <code>setFoo()</code> on the target object. If either
 * <code>valueFrom</code> or <code>valueTo</code> is null, then a getter function will
 * also be derived and called.
 *
 * <p>If this animator was created with a {@link Property} object instead of the
 * string name of a property, then this method will return the {@link
 * Property#getName() name} of that Property object instead. If this animator was
 * created with one or more {@link PropertyValuesHolder} objects, then this method
 * will return the {@link PropertyValuesHolder#getPropertyName() name} of that
 * object (if there was just one) or a comma-separated list of all of the
 * names (if there are more than one).</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed from returning just mPropertyName to computing propertyName in a more complex way, involving conditional statements and a loop. Therefore, the code change type is 1 and 3. ","The change in the return statement and the addition of conditional and control statements could potentially lead to this API returning a different value. Therefore, the compatibility issue type is 1."
276,"<android.widget.ListView: void addHeaderView(View,Object,boolean)>",18,19,"<android.widget.ListView: void addHeaderView(View,Object,boolean)>","<android.widget.ListView: void addHeaderView(View,Object,boolean)>",0,"{
    if (mAdapter != null && !(mAdapter instanceof HeaderViewListAdapter)) {
        throw new IllegalStateException(""Cannot add header view to list -- setAdapter has already been called."");
    }
    FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mHeaderViewInfos.add(info);
    // we need to notify the observer
    if (mAdapter != null && mDataSetObserver != null) {
        mDataSetObserver.onChanged();
    }
}","{
    final FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mHeaderViewInfos.add(info);
    // Wrap the adapter if it wasn't already wrapped.
    if (mAdapter != null) {
        if (!(mAdapter instanceof HeaderViewListAdapter)) {
            mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, mAdapter);
        }
        // we need to notify the observer.
        if (mDataSetObserver != null) {
            mDataSetObserver.onChanged();
        }
    }
}",1,"/**
 * Add a fixed view to appear at the top of the list. If addHeaderView is
 * called more than once, the views will appear in the order they were
 * added. Views added using this call can take focus if they want.
 * <p>
 * NOTE: Call this before calling setAdapter. This is so ListView can wrap
 * the supplied cursor with one that will also account for header and footer
 * views.
 *
 * @param v The view to add.
 * @param data Data to associate with this view
 * @param isSelectable whether the item is selectable
 */
","/**
 * Add a fixed view to appear at the top of the list. If this method is
 * called more than once, the views will appear in the order they were
 * added. Views added using this call can take focus if they want.
 * <p>
 * Note: When first introduced, this method could only be called before
 * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with
 * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be
 * called at any time. If the ListView's adapter does not extend
 * {@link HeaderViewListAdapter}, it will be wrapped with a supporting
 * instance of {@link WrapperListAdapter}.
 *
 * @param v The view to add.
 * @param data Data to associate with this view
 * @param isSelectable whether the item is selectable
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","There is a removal of the throw statement and addition of new statements(mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, mAdapter)), so the change type is 3,4.","The removal of the exception 'throw new IllegalStateException' and introduction of a new value of mAdapter can make the API either return a different value or throw a different exception when invoked. Hence, the CI type is 1,2."
279,<android.view.HardwareRenderer.GlRenderer: boolean validate()>,18,19,<android.view.HardwareRenderer.GlRenderer: boolean validate()>,<android.view.HardwareRenderer.GlRenderer: boolean validate()>,0,"{
    return checkCurrent() != SURFACE_STATE_ERROR;
}","{
    return checkRenderContext() != SURFACE_STATE_ERROR;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"Here, the function call in the return statement of the code has been changed from ""checkCurrent()"" to ""checkRenderContext(),"" indicating both a change in the return statement and a change in dependent API. So, the code change is of type 1 and 5.","Due to the mentioned change, this could potentially cause the method to return a different value. Thus, there is a Compatibility Issue of type 1."
280,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,18,19,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (mState > STATE_NONE && isPointInside(ev.getX(), ev.getY())) {
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (isPointInside(ev.getX(), ev.getY())) {
                // event.
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (!isPointInside(ev.getX(), ev.getY())) {
                cancelPendingDrag();
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The codes are significantly rearranged, and new statements are added while certain old statements are removed from the method. Specifically, the condition ""mState > STATE_NONE"" in the 'if' clause is removed, a new condition ""isEnabled()"" is added at the beginning of the method and a new 'case' for ""ACTION_MOVE"" is added but without a return statement. Therefore, the change types are 3 and 4. ","Due to the changes in control dependency and other statements, the return values could potentially be different under specific conditions. For example, when the instance is not enabled or when 'ACTION_DOWN' is activated without 'mState > STATE_NONE'. Therefore, the compatibility issue type is 1."
283,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,18,19,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,<android.hardware.display.DisplayManager: Display[] getDisplays(String)>,0,"{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addMatchingDisplaysLocked(mTempDisplays, displayIds, -1);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addMatchingDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addMatchingDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_HDMI);
                addMatchingDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}","{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_HDMI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}",1,"/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
","/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The API calls different methods in the if and else if blocks, going from `addMatchingDisplaysLocked()` to `addAllDisplaysLocked()` and `addPresentationDisplaysLocked()`. Also, in the late version, an extra method call `addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL)` is introduced. So, the code change type is 1 and 5.","The change in the methods called and the extra method called can potentially affect what displays are added to `mTempDisplays`, hence changing the value returned by the `getDisplays` method. Therefore, the API could return different values, causing a Compatibility Issue of type 1."
284,<android.os.MessageQueue: void removeSyncBarrier(int)>,18,19,<android.os.MessageQueue: void removeSyncBarrier(int)>,<android.os.MessageQueue: void removeSyncBarrier(int)>,0,"{
    // Remove a sync barrier token from the queue.
    // If the queue is no longer stalled by a barrier then wake it.
    final boolean needWake;
    synchronized (this) {
        Message prev = null;
        Message p = mMessages;
        while (p != null && (p.target != null || p.arg1 != token)) {
            prev = p;
            p = p.next;
        }
        if (p == null) {
            throw new IllegalStateException(""The specified message queue synchronization "" + "" barrier token has not been posted or has already been removed."");
        }
        if (prev != null) {
            prev.next = p.next;
            needWake = false;
        } else {
            mMessages = p.next;
            needWake = mMessages == null || mMessages.target != null;
        }
        p.recycle();
    }
    if (needWake) {
        nativeWake(mPtr);
    }
}","{
    // If the queue is no longer stalled by a barrier then wake it.
    synchronized (this) {
        Message prev = null;
        Message p = mMessages;
        while (p != null && (p.target != null || p.arg1 != token)) {
            prev = p;
            p = p.next;
        }
        if (p == null) {
            throw new IllegalStateException(""The specified message queue synchronization "" + "" barrier token has not been posted or has already been removed."");
        }
        final boolean needWake;
        if (prev != null) {
            prev.next = p.next;
            needWake = false;
        } else {
            mMessages = p.next;
            needWake = mMessages == null || mMessages.target != null;
        }
        p.recycle();
        // We can assume mPtr != 0 when mQuitting is false.
        if (needWake && !mQuitting) {
            nativeWake(mPtr);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,2,The only change in the implementation is the addition of an extra condition (!mQuitting) for invoking the nativeWake(mPtr) function. This is an example of change in control dependency (change type 3).,"In the previous version calling removeSyncBarrier(int) could always potentially result in nativeWake(mPtr) being executed, whereas in the new version, nativeWake(mPtr) will not be called when mQuitting is true. This change in exception handling could potentially lead to different behaviours of the API, so it's identified as a CI of type 2."
285,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,18,19,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,<android.view.View: void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo)>,0,"{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
        if ((mAttachInfo.mAccessibilityFetchFlags & AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS) != 0 && Resources.resourceHasPackage(mID)) {
            try {
                String viewId = getResources().getResourceName(mID);
                info.setViewIdResourceName(viewId);
            } catch (Resources.NotFoundException nfe) {
            /* ignore */
            }
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    CharSequence text = getIterableTextForAccessibility();
    if (text != null && text.length() > 0) {
        info.setTextSelection(getAccessibilitySelectionStart(), getAccessibilitySelectionEnd());
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}","{
    Rect bounds = mAttachInfo.mTmpInvalRect;
    getDrawingRect(bounds);
    info.setBoundsInParent(bounds);
    getBoundsOnScreen(bounds);
    info.setBoundsInScreen(bounds);
    ViewParent parent = getParentForAccessibility();
    if (parent instanceof View) {
        info.setParent((View) parent);
    }
    if (mID != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View label = rootView.findLabelForView(this, mID);
        if (label != null) {
            info.setLabeledBy(label);
        }
        if ((mAttachInfo.mAccessibilityFetchFlags & AccessibilityNodeInfo.FLAG_REPORT_VIEW_IDS) != 0 && Resources.resourceHasPackage(mID)) {
            try {
                String viewId = getResources().getResourceName(mID);
                info.setViewIdResourceName(viewId);
            } catch (Resources.NotFoundException nfe) {
            /* ignore */
            }
        }
    }
    if (mLabelForId != View.NO_ID) {
        View rootView = getRootView();
        if (rootView == null) {
            rootView = this;
        }
        View labeled = rootView.findViewInsideOutShouldExist(this, mLabelForId);
        if (labeled != null) {
            info.setLabelFor(labeled);
        }
    }
    info.setVisibleToUser(isVisibleToUser());
    info.setPackageName(mContext.getPackageName());
    info.setClassName(View.class.getName());
    info.setContentDescription(getContentDescription());
    info.setEnabled(isEnabled());
    info.setClickable(isClickable());
    info.setFocusable(isFocusable());
    info.setFocused(isFocused());
    info.setAccessibilityFocused(isAccessibilityFocused());
    info.setSelected(isSelected());
    info.setLongClickable(isLongClickable());
    info.setLiveRegion(getAccessibilityLiveRegion());
    // TODO: These make sense only if we are in an AdapterView but all
    // views can be selected. Maybe from accessibility perspective
    // we should report as selectable view in an AdapterView.
    info.addAction(AccessibilityNodeInfo.ACTION_SELECT);
    info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_SELECTION);
    if (isFocusable()) {
        if (isFocused()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);
        } else {
            info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);
        }
    }
    if (!isAccessibilityFocused()) {
        info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
    } else {
        info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
    }
    if (isClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
    }
    if (isLongClickable() && isEnabled()) {
        info.addAction(AccessibilityNodeInfo.ACTION_LONG_CLICK);
    }
    CharSequence text = getIterableTextForAccessibility();
    if (text != null && text.length() > 0) {
        info.setTextSelection(getAccessibilitySelectionStart(), getAccessibilitySelectionEnd());
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH);
    }
}",1,"/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"A new statement 'info.setLiveRegion(getAccessibilityLiveRegion());' has been introduced in the late version, so the code change type is 4.","Because of the new added statement, the later version of the API might behave differently from the earlier one. Hence, it might potentially return a different value or type, therefore, the CI type is 1."
286,<android.os.Bundle: boolean getBoolean(String)>,18,19,<android.os.Bundle: boolean getBoolean(String)>,<android.os.Bundle: boolean getBoolean(String)>,0,"{
    unparcel();
    return getBoolean(key, false);
}","{
    unparcel();
    if (DEBUG)
        Log.d(TAG, ""Getting boolean in "" + Integer.toHexString(System.identityHashCode(this)));
    return getBoolean(key, false);
}",1,"/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */
","/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,An additional debugging logging statement has been added in the Late Version. This change does not affect the underlying logic or functionality of the method and hence is classified as code change type 4.,"Despite the change in implementation, the return type and exception handling haven't been changed between versions, so no Compatibility Issue arises. The output of the method remains the same as before, therefore there is no change in the behavior of the API. Hence, the CI type is 0."
287,<android.webkit.WebView: boolean pageUp(boolean)>,18,19,<android.webkit.WebView: boolean pageUp(boolean)>,<android.webkit.WebView: boolean pageUp(boolean)>,0,"{
    checkThread();
    return mProvider.pageUp(top);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""pageUp"");
    return mProvider.pageUp(top);
}",1,"/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView up by half the view size.
 *
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the debugging log statement has been added, not affecting the functionality of the code. Thus, the code change type is 4 considering the addition of the other type of statement.","Though there is a change in the implementation, it doesn't affect the output or behaviour of the application as it is just a log message for debugging. Hence, there is no Compatibility Issue - CI type 0."
289,<android.widget.AbsListView: float getTopFadingEdgeStrength()>,18,19,<android.widget.AbsListView: float getTopFadingEdgeStrength()>,<android.widget.AbsListView: float getTopFadingEdgeStrength()>,0,"{
    final int count = getChildCount();
    final float fadeEdge = super.getTopFadingEdgeStrength();
    if (count == 0) {
        return fadeEdge;
    } else {
        if (mFirstPosition > 0) {
            return 1.0f;
        }
        final int top = getChildAt(0).getTop();
        final float fadeLength = (float) getVerticalFadingEdgeLength();
        return top < mPaddingTop ? (float) -(top - mPaddingTop) / fadeLength : fadeEdge;
    }
}","{
    final int count = getChildCount();
    final float fadeEdge = super.getTopFadingEdgeStrength();
    if (count == 0) {
        return fadeEdge;
    } else {
        if (mFirstPosition > 0) {
            return 1.0f;
        }
        final int top = getChildAt(0).getTop();
        final float fadeLength = getVerticalFadingEdgeLength();
        return top < mPaddingTop ? -(top - mPaddingTop) / fadeLength : fadeEdge;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"There are no significant changes between the two versions of the method. Only a redundant cast to float has been removed in the late version, but it doesn't change the overall behavior of the method or its return value.","Since no substantial code changes have been made between the early and late versions of this function, there are no compatibility issues here."
291,"<android.text.method.MetaKeyKeyListener: int getMetaState(long,int)>",18,19,"<android.text.method.MetaKeyKeyListener: int getMetaState(long,int)>","<android.text.method.MetaKeyKeyListener: int getMetaState(long,int)>",0,"{
    switch(meta) {
        case META_SHIFT_ON:
            if ((state & META_CAP_LOCKED) != 0)
                return 2;
            if ((state & META_SHIFT_ON) != 0)
                return 1;
            return 0;
        case META_ALT_ON:
            if ((state & META_ALT_LOCKED) != 0)
                return 2;
            if ((state & META_ALT_ON) != 0)
                return 1;
            return 0;
        case META_SYM_ON:
            if ((state & META_SYM_LOCKED) != 0)
                return 2;
            if ((state & META_SYM_ON) != 0)
                return 1;
            return 0;
        default:
            return 0;
    }
}","{
    switch(meta) {
        case META_SHIFT_ON:
            if ((state & META_CAP_LOCKED) != 0)
                return LOCKED_RETURN_VALUE;
            if ((state & META_SHIFT_ON) != 0)
                return PRESSED_RETURN_VALUE;
            return 0;
        case META_ALT_ON:
            if ((state & META_ALT_LOCKED) != 0)
                return LOCKED_RETURN_VALUE;
            if ((state & META_ALT_ON) != 0)
                return PRESSED_RETURN_VALUE;
            return 0;
        case META_SYM_ON:
            if ((state & META_SYM_LOCKED) != 0)
                return LOCKED_RETURN_VALUE;
            if ((state & META_SYM_ON) != 0)
                return PRESSED_RETURN_VALUE;
            return 0;
        default:
            return 0;
    }
}",1,"/**
 * Gets the state of a particular meta key.
 *
 * @param state the current state bits.
 * @param meta META_SHIFT_ON, META_ALT_ON, or META_SYM_ON
 *
 * @return 0 if inactive, 1 if active, 2 if locked.
 */
","/**
 * Gets the state of a particular meta key.
 *
 * @param state the current state bits.
 * @param meta META_SHIFT_ON, META_ALT_ON, or META_SYM_ON
 *
 * @return 0 if inactive, 1 if active, 2 if locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The values returned in the switch case statements have been changed from 2,1 to LOCKED_RETURN_VALUE and PRESSED_RETURN_VALUE respectively. Therefore, the code change type includes both Return statement changed (1) and Other statement changed (4).","The change in return values can lead the API to return different values for the same input scenarios, causing potential functional modifications in application code that relying on this method. Hence, the CI type is Compatibility Issue caused by potential different return values or types (1)."
292,<android.widget.TimePicker: void setIs24HourView(Boolean)>,18,19,<android.widget.TimePicker: void setIs24HourView(Boolean)>,<android.widget.TimePicker: void setIs24HourView(Boolean)>,0,"{
    if (mIs24HourView == is24HourView) {
        return;
    }
    mIs24HourView = is24HourView;
    // cache the current hour since spinner range changes
    int currentHour = getCurrentHour();
    updateHourControl();
    // set value after spinner range is updated
    setCurrentHour(currentHour);
    updateAmPmControl();
}","{
    if (mIs24HourView == is24HourView) {
        return;
    }
    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
    int currentHour = getCurrentHour();
    // Order is important here.
    mIs24HourView = is24HourView;
    getHourFormatData();
    updateHourControl();
    // set value after spinner range is updated - be aware that because mIs24HourView has
    // changed then getCurrentHour() is not equal to the currentHour we cached before so
    // explicitly ask for *not* propagating any onTimeChanged()
    setCurrentHour(currentHour, false);
    updateMinuteControl();
    updateAmPmControl();
}",1,"/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
","/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",0,"The 'return' is unchanged, but the following statements are rearranged and a new 'getHourFormatData();' method is added, along with an update to 'setCurrentHour' method and inclusion of 'updateMinuteControl()'. Thus, the change seizes in type 1,3,4.","Despite rearrangements and introduction of new methods, these changes do not necessarily affect the output or exception handling of the API since the purpose of this API is only to set the status of 'mIs24HourView', regardless of the internal operations. Therefore, no Compatiblity Issue exists in this scenario."
293,<android.view.Surface: String toString()>,18,19,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    synchronized (mLock) {
        return ""Surface(name="" + mName + "")"";
    }
}","{
    synchronized (mLock) {
        return ""Surface(name="" + mName + "")/@0x"" + Integer.toHexString(System.identityHashCode(this));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement in the code has been changed from ""Surface(name="" + mName + "")"" to ""Surface(name="" + mName + "")/@0x"" + Integer.toHexString(System.identityHashCode(this)), so the code change type is 1.","As the return statement has been altered, this API will return a different value, thus the CI type is 1."
295,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",18,19,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void bind(Context,int,Intent)>",0,"{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if (Process.myUid() == Process.SYSTEM_UID && (adapter = mAdapter.get()) != null) {
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), new UserHandle(adapter.mUserId));
            } else {
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), Process.myUserHandle());
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}","{
    if (!mIsConnecting) {
        try {
            RemoteViewsAdapter adapter;
            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
            if ((adapter = mAdapter.get()) != null) {
                checkInteractAcrossUsersPermission(context, adapter.mUserId);
                mgr.bindRemoteViewsService(appWidgetId, intent, asBinder(), new UserHandle(adapter.mUserId));
            } else {
                Slog.w(TAG, ""bind: adapter was null"");
            }
            mIsConnecting = true;
        } catch (Exception e) {
            Log.e(""RemoteViewsAdapterServiceConnection"", ""bind(): "" + e.getMessage());
            mIsConnecting = false;
            mIsConnected = false;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The condition statement in the 'if' block has partially changed and a new Log warning statement has been introduced in the 'else' block, hence the type of code change is 3 (Control dependency) and 4 (Other statement changes).","Despite the changes in statements and control dependencies, these changes do not impact the return type/value and exception handling of the function, thus no Compatibility Issue exists (type 0)."
297,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,18,19,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,<android.content.pm.ResolveInfo: Drawable loadIcon(PackageManager)>,0,"{
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}","{
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    ComponentInfo ci = getComponentInfo();
    ApplicationInfo ai = ci.applicationInfo;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}",1,"/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
","/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement 'ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;' has changed to 'ComponentInfo ci = getComponentInfo();', so the code change type is 4.","The change of getting 'ci' value will possibly lead to different 'Drawable dr' returned, so the CI type is 1."
298,"<android.net.Uri: boolean getBooleanQueryParameter(String,boolean)>",18,19,"<android.net.Uri: boolean getBooleanQueryParameter(String,boolean)>","<android.net.Uri: boolean getBooleanQueryParameter(String,boolean)>",0,"{
    String flag = getQueryParameter(key);
    if (flag == null) {
        return defaultValue;
    }
    flag = flag.toLowerCase();
    return (!""false"".equals(flag) && !""0"".equals(flag));
}","{
    String flag = getQueryParameter(key);
    if (flag == null) {
        return defaultValue;
    }
    flag = flag.toLowerCase(Locale.ROOT);
    return (!""false"".equals(flag) && !""0"".equals(flag));
}",1,"/**
 * Searches the query string for the first value with the given key and interprets it
 * as a boolean value. ""false"" and ""0"" are interpreted as <code>false</code>, everything
 * else is interpreted as <code>true</code>.
 *
 * @param key which will be decoded
 * @param defaultValue the default value to return if there is no query parameter for key
 * @return the boolean interpretation of the query parameter key
 */
","/**
 * Searches the query string for the first value with the given key and interprets it
 * as a boolean value. ""false"" and ""0"" are interpreted as <code>false</code>, everything
 * else is interpreted as <code>true</code>.
 *
 * @param key which will be decoded
 * @param defaultValue the default value to return if there is no query parameter for key
 * @return the boolean interpretation of the query parameter key
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The only difference is that in the late version, flag.toLowerCase(Locale.ROOT) is called instead of flag.toLowerCase(). Hence, 'Other statement changed' and 'Dependent API changed' are applicable. So the code change types are 4,5.","Despite the change in the method called on the flag variable, both versions will return the same results as long as the input is the same. Therefore, no compatibility issues exist, and the CI type is 0."
300,"<android.util.SparseArray: E get(int,E)>",18,19,"<android.util.SparseArray: E get(int,E)>","<android.util.SparseArray: E get(int,E)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i < 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
    }
}",1,"/**
 * Gets the Object mapped from the specified key, or the specified Object
 * if no such mapping has been made.
 */
","/**
 * Gets the Object mapped from the specified key, or the specified Object
 * if no such mapping has been made.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,5,0,"The dependent API 'binarySearch' in 'ContainerHelpers' class has been used instead of a simple 'binarySearch', so the change type is 5.","There is no compatibility issue here since the updated dependent API 'binarySearch' is functionally similar to the previous one and doesn't cause any difference in return values or exceptions handling. Therefore, the CI type is 0."
301,<android.content.ContentProviderClient: String getType(Uri)>,18,19,<android.content.ContentProviderClient: String getType(Uri)>,<android.content.ContentProviderClient: String getType(Uri)>,0,"{
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
","/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes include other types of statements - specifically, the introduction of 'beforeRemote()' before the try block and 'afterRemote()' in a 'finally' section after the try-catch block. These changes do not fall under any of the other categories and therefore classify as an 'Other statement changed' (4).","Changes in the method introduce 'beforeRemote()' and 'afterRemote()' statements which probably control some states before and after the remote operations in the 'try' block. However, the return of the API and exception it might throw remain the same in both versions, so these changes do not cause Compatibility Issues (0)."
303,<android.os.ParcelFileDescriptor: int describeContents()>,18,19,<android.os.ParcelFileDescriptor: int describeContents()>,<android.os.ParcelFileDescriptor: int describeContents()>,0,"{
    return Parcelable.CONTENTS_FILE_DESCRIPTOR;
}","{
    if (mWrapped != null) {
        return mWrapped.describeContents();
    } else {
        return Parcelable.CONTENTS_FILE_DESCRIPTOR;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"An 'if' condition has been introduced changing the return statement, so the code change type is 1,3.","The added condition checking 'if (mWrapped != null)' alters the return value of the function, so the Compatibility Issue is of type 1 (return value changed)."
307,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",18,19,"<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>","<android.view.GLES20Canvas: void drawBitmap(Bitmap,Matrix,Paint)>",0,"{
    if (bitmap.isRecycled())
        throw new IllegalArgumentException(""Cannot draw recycled bitmaps"");
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}","{
    throwIfCannotDraw(bitmap);
    // Shaders are ignored when drawing bitmaps
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawBitmap(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, matrix.native_instance, nativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4,5",2,"The early implementation throws an IllegalArgumentException directly, while the later version calls the method throwIfCannotDraw() to throw the exception. The content inside the exception handling has not been changed. Therefore, the change type is considered as 2,4,5. ","Since there is a difference in how the exceptions are executed, it can directly result in a difference in behavior, therefore the CI_type is 2."
310,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,18,19,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,<android.view.inputmethod.BaseInputConnection: boolean finishComposingText()>,0,"{
    if (DEBUG)
        Log.v(TAG, ""finishComposingText"");
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        endBatchEdit();
        sendCurrentText();
    }
    return true;
}","{
    if (DEBUG)
        Log.v(TAG, ""finishComposingText"");
    final Editable content = getEditable();
    if (content != null) {
        beginBatchEdit();
        removeComposingSpans(content);
        // Note: sendCurrentText does nothing unless mDummyMode is set
        sendCurrentText();
        endBatchEdit();
    }
    return true;
}",1,"/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
","/**
 * The default implementation removes the composing state from the
 * current editable text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,Only the order of method invocations has changed (endBatchEdit() and sendCurrentText() have changed their places) so the code change type is 4.,"Though the order of method invocations changed, neither of the method return any value nor throw any exception, and the final return value of finishComposingText() stays unchanged (true). Thus, this change will not lead to any Compatibility Issue, so the CI type is 0."
311,<android.webkit.WebView: boolean pageDown(boolean)>,18,19,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    checkThread();
    return mProvider.pageDown(bottom);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""pageDown"");
    return mProvider.pageDown(bottom);
}",1,"/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scrolls the contents of this WebView down by half the page size.
 *
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,A new debugging log statement is added in the late version. This is considered as an 'Other statement changed'.,"The change does not affect the return statement or exception handling in the method, so it would not yield different behaviors of the API. No Compatibility Issue exists."
313,<android.content.AsyncTaskLoader: void executePendingTask()>,18,19,<android.content.AsyncTaskLoader: void executePendingTask()>,<android.content.AsyncTaskLoader: void executePendingTask()>,0,"{
    if (mCancellingTask == null && mTask != null) {
        if (mTask.waiting) {
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
        }
        if (mUpdateThrottle > 0) {
            long now = SystemClock.uptimeMillis();
            if (now < (mLastLoadCompleteTime + mUpdateThrottle)) {
                // Not yet time to do another load.
                if (DEBUG)
                    Slog.v(TAG, ""Waiting until "" + (mLastLoadCompleteTime + mUpdateThrottle) + "" to execute: "" + mTask);
                mTask.waiting = true;
                mHandler.postAtTime(mTask, mLastLoadCompleteTime + mUpdateThrottle);
                return;
            }
        }
        if (DEBUG)
            Slog.v(TAG, ""Executing: "" + mTask);
        mTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void[]) null);
    }
}","{
    if (mCancellingTask == null && mTask != null) {
        if (mTask.waiting) {
            mTask.waiting = false;
            mHandler.removeCallbacks(mTask);
        }
        if (mUpdateThrottle > 0) {
            long now = SystemClock.uptimeMillis();
            if (now < (mLastLoadCompleteTime + mUpdateThrottle)) {
                // Not yet time to do another load.
                if (DEBUG)
                    Slog.v(TAG, ""Waiting until "" + (mLastLoadCompleteTime + mUpdateThrottle) + "" to execute: "" + mTask);
                mTask.waiting = true;
                mHandler.postAtTime(mTask, mLastLoadCompleteTime + mUpdateThrottle);
                return;
            }
        }
        if (DEBUG)
            Slog.v(TAG, ""Executing: "" + mTask);
        mTask.executeOnExecutor(mExecutor, (Void[]) null);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API has changed from AsyncTask.THREAD_POOL_EXECUTOR to mExecutor, so the code change type is 5.","As the executor of mTask has been changed, the task might be handled by a different executor which may potentially returns different execution results, and thus the CI type is 1."
316,<android.net.Uri: String getQueryParameter(String)>,18,19,<android.net.Uri: String getQueryParameter(String)>,<android.net.Uri: String getQueryParameter(String)>,0,"{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    final String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    final String encodedKey = encode(key, null);
    final int length = query.length();
    int start = 0;
    do {
        int nextAmpersand = query.indexOf('&', start);
        int end = nextAmpersand != -1 ? nextAmpersand : length;
        int separator = query.indexOf('=', start);
        if (separator > end || separator == -1) {
            separator = end;
        }
        if (separator - start == encodedKey.length() && query.regionMatches(start, encodedKey, 0, encodedKey.length())) {
            if (separator == end) {
                return """";
            } else {
                String encodedValue = query.substring(separator + 1, end);
                return UriCodec.decode(encodedValue, true, Charsets.UTF_8, false);
            }
        }
        // Move start to end of name.
        if (nextAmpersand != -1) {
            start = nextAmpersand + 1;
        } else {
            break;
        }
    } while (true);
    return null;
}","{
    if (isOpaque()) {
        throw new UnsupportedOperationException(NOT_HIERARCHICAL);
    }
    if (key == null) {
        throw new NullPointerException(""key"");
    }
    final String query = getEncodedQuery();
    if (query == null) {
        return null;
    }
    final String encodedKey = encode(key, null);
    final int length = query.length();
    int start = 0;
    do {
        int nextAmpersand = query.indexOf('&', start);
        int end = nextAmpersand != -1 ? nextAmpersand : length;
        int separator = query.indexOf('=', start);
        if (separator > end || separator == -1) {
            separator = end;
        }
        if (separator - start == encodedKey.length() && query.regionMatches(start, encodedKey, 0, encodedKey.length())) {
            if (separator == end) {
                return """";
            } else {
                String encodedValue = query.substring(separator + 1, end);
                return UriCodec.decode(encodedValue, true, StandardCharsets.UTF_8, false);
            }
        }
        // Move start to end of name.
        if (nextAmpersand != -1) {
            start = nextAmpersand + 1;
        } else {
            break;
        }
    } while (true);
    return null;
}",1,"/**
 * Searches the query string for the first value with the given key.
 *
 * <p><strong>Warning:</strong> Prior to Ice Cream Sandwich, this decoded
 * the '+' character as '+' rather than ' '.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
","/**
 * Searches the query string for the first value with the given key.
 *
 * <p><strong>Warning:</strong> Prior to Ice Cream Sandwich, this decoded
 * the '+' character as '+' rather than ' '.
 *
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"Only the parameter value passed to the UriCodec.decode() method has changed, from Charsets.UTF_8 to StandardCharsets.UTF_8. Thus, the code change type is labeled as 5 (Dependent API changed).","This change leads to using a different charset which however does not alter the API's essential behavior as the used UTF_8 encoding is essentially the same in Charsets and StandardCharsets. Therefore, it does not lead to any compatibility issues (CI type 0)."
317,<android.util.SparseBooleanArray: int indexOfKey(int)>,18,19,<android.util.SparseBooleanArray: int indexOfKey(int)>,<android.util.SparseBooleanArray: int indexOfKey(int)>,0,"{
    return binarySearch(mKeys, 0, mSize, key);
}","{
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}",1,"/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
","/**
 * Returns the index for which {@link #keyAt} would return the
 * specified key, or a negative number if the specified
 * key is not mapped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method called in the return statement changed from binarySearch() to ContainerHelpers.binarySearch(), so the code change type is 5.","The current API relies on another method call which has changed. This could potentially result in the API returning a different value, so the CI type is 1."
319,"<android.webkit.URLUtil: String guessFileName(String,String,String)>",18,19,"<android.webkit.URLUtil: String guessFileName(String,String,String)>","<android.webkit.URLUtil: String guessFileName(String,String,String)>",0,"{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (filename == null && contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith(""/"")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = ""downloadfile"";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = ""."" + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase().startsWith(""text/"")) {
                if (mimeType.equalsIgnoreCase(""text/html"")) {
                    extension = "".html"";
                } else {
                    extension = "".txt"";
                }
            } else {
                extension = "".bin"";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = ""."" + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}","{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (filename == null && contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith(""/"")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = ""downloadfile"";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = ""."" + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase(Locale.ROOT).startsWith(""text/"")) {
                if (mimeType.equalsIgnoreCase(""text/html"")) {
                    extension = "".html"";
                } else {
                    extension = "".txt"";
                }
            } else {
                extension = "".bin"";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = ""."" + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}",1,"/**
 * Guesses canonical filename that a download would have, using
 * the URL and contentDisposition. File extension, if not defined,
 * is added based on the mimetype
 * @param url Url to the content
 * @param contentDisposition Content-Disposition HTTP header or null
 * @param mimeType Mime-type of the content or null
 *
 * @return suggested filename
 */
","/**
 * Guesses canonical filename that a download would have, using
 * the URL and contentDisposition. File extension, if not defined,
 * is added based on the mimetype
 * @param url Url to the content
 * @param contentDisposition Content-Disposition HTTP header or null
 * @param mimeType Mime-type of the content or null
 *
 * @return suggested filename
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,The code change type is 4 beacause the string method toLowerCase() in the late version has a new parameter Locale.ROOT compared to the early version.,"The change to the Locale.ROOT parameter might lead to different behavior of the toLowerCase() method, resulting in a different extension, and thereby a different return value. Thus, the potential CI type is 1."
320,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,18,19,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,<android.widget.AbsListView: int getVerticalScrollbarWidth()>,0,"{
    if (isFastScrollAlwaysVisible()) {
        return Math.max(super.getVerticalScrollbarWidth(), mFastScroller.getWidth());
    }
    return super.getVerticalScrollbarWidth();
}","{
    if (mFastScroller != null && mFastScroller.isEnabled()) {
        return Math.max(super.getVerticalScrollbarWidth(), mFastScroller.getWidth());
    }
    return super.getVerticalScrollbarWidth();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition statement for the 'if' clause has changed from ""isFastScrollAlwaysVisible()"" to ""mFastScroller != null && mFastScroller.isEnabled()"". Therefore, the code change type is 3 (Control dependency changed).","Because the condition for the 'if' clause has changed, the result of the method could potentially vary based on the new condition. Consequently, it could make the API return different values. This represents a compatibility issue of type 1 (Compatibility Issue caused by potential different return values or types)."
322,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",18,19,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // ""effective padding"" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation only changed where an existing statement is. Specifically, two new condition check are introduced: ""if (child.isAccessibilityFocused())"". This change does not involve return statements, exception statements, or control dependencies. So, the change type is 4.","This change doesn't lead to any compatibility issues, because it does not change how the function behaves in terms of their return values/ types or the exceptions they throw. So, the CI type is 0."
323,<android.net.CaptivePortalTracker.NoActiveNetworkState: boolean processMessage(Message)>,18,19,<android.net.CaptivePortalTracker.NoActiveNetworkState: boolean processMessage(Message)>,<android.net.CaptivePortalTracker.NoActiveNetworkState: boolean processMessage(Message)>,0,"{
    if (DBG)
        log(getName() + message.toString() + ""\n"");
    InetAddress server;
    NetworkInfo info;
    switch(message.what) {
        case CMD_CONNECTIVITY_CHANGE:
            info = (NetworkInfo) message.obj;
            if (info.isConnected() && isActiveNetwork(info)) {
                mNetworkInfo = info;
                transitionTo(mDelayedCaptiveCheckState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    if (DBG)
        log(getName() + message.toString());
    InetAddress server;
    NetworkInfo info;
    switch(message.what) {
        case CMD_CONNECTIVITY_CHANGE:
            info = (NetworkInfo) message.obj;
            if (info.getType() == ConnectivityManager.TYPE_WIFI) {
                if (info.isConnected() && isActiveNetwork(info)) {
                    mNetworkInfo = info;
                    transitionTo(mDelayedCaptiveCheckState);
                }
            } else {
                log(getName() + "" not a wifi connectivity change, ignore"");
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the switch case CMD_CONNECTIVITY_CHANGE, a new condition 'info.getType() == ConnectivityManager.TYPE_WIFI' was added and a new log statement was added, which indicates changes in control dependency and in other statements. So, the code change type is 3,4.","Adding a new condition 'info.getType() == ConnectivityManager.TYPE_WIFI', increases the complexity of the condition and changes the circumstances under which certain actions are performed. This could potentially lead the API to return a different result than before, so the CI type is 1."
325,"<android.view.View: boolean onKeyUp(int,KeyEvent)>",18,19,"<android.view.View: boolean onKeyUp(int,KeyEvent)>","<android.view.View: boolean onKeyUp(int,KeyEvent)>",0,"{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
                    setPressed(false);
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        result = performClick();
                    }
                }
                break;
            }
    }
    return result;
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
            setPressed(false);
            if (!mHasPerformedLongPress) {
                // This is a tap, so remove the longpress check
                removeLongPressCallback();
                return performClick();
            }
        }
    }
    return false;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or
 * {@link KeyEvent#KEYCODE_ENTER} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyUp(int, KeyEvent)
 * KeyEvent.Callback.onKeyUp()}: perform clicking of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or
 * {@link KeyEvent#KEYCODE_ENTER} is released.
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control logic from a switch-case statement has been changed to an if statement. Moreover, the returned value responsed in the later implementation has also changed from variable 'result' to a fixed boolean 'false', so the code change is classified as 1,3.","The changed control logic and returned values definitely could lead to different behaviors of the API, hence the CI is classified as type 1."
327,<android.view.View: void setEnabled(boolean)>,18,19,<android.view.View: void setEnabled(boolean)>,<android.view.View: void setEnabled(boolean)>,0,"{
    if (enabled == isEnabled())
        return;
    setFlags(enabled ? ENABLED : DISABLED, ENABLED_MASK);
    /*
         * The View most likely has to change its appearance, so refresh
         * the drawable state.
         */
    refreshDrawableState();
    // Invalidate too, since the default behavior for views is to be
    // be drawn at 50% alpha rather than to change the drawable.
    invalidate(true);
}","{
    if (enabled == isEnabled())
        return;
    setFlags(enabled ? ENABLED : DISABLED, ENABLED_MASK);
    /*
         * The View most likely has to change its appearance, so refresh
         * the drawable state.
         */
    refreshDrawableState();
    // Invalidate too, since the default behavior for views is to be
    // be drawn at 50% alpha rather than to change the drawable.
    invalidate(true);
    if (!enabled) {
        cancelPendingInputEvents();
    }
}",1,"/**
 * Set the enabled state of this view. The interpretation of the enabled
 * state varies by subclass.
 *
 * @param enabled True if this view is enabled, false otherwise.
 */
","/**
 * Set the enabled state of this view. The interpretation of the enabled
 * state varies by subclass.
 *
 * @param enabled True if this view is enabled, false otherwise.
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,4,0,"The late version added a new if statement 'if (!enabled)' and a new method 'cancelPendingInputEvents()' is called when 'enabled' is false, the change type is 4.","The newly added method will change the state of View, but it does not affect the output (return value, exception) of the method 'setEnabled', so there is no Compatibility Issue, hence the CI Type is 0."
328,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",18,19,"<android.view.View: boolean onKeyDown(int,KeyEvent)>","<android.view.View: boolean onKeyDown(int,KeyEvent)>",0,"{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                // Long clickable items don't necessarily have to be clickable
                if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
                    setPressed(true);
                    checkForLongClick(0);
                    return true;
                }
                break;
            }
    }
    return result;
}","{
    boolean result = false;
    if (KeyEvent.isConfirmKey(keyCode)) {
        if ((mViewFlags & ENABLED_MASK) == DISABLED) {
            return true;
        }
        // Long clickable items don't necessarily have to be clickable
        if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
            setPressed(true);
            checkForLongClick(0);
            return true;
        }
    }
    return result;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * <p>Key presses in software keyboards will generally NOT trigger this listener,
 * although some may elect to do so in some situations. Do not rely on this to
 * catch software key presses.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",1,"The switch-case control structure in the early version changes to an if statement in the late version. The method KeyCode.KEYCODE_DPAD_CENTER and KeyCode.KEYCODE_ENTER is replaced by KeyEvent.isConfirmKey(keyCode) in the late version, thus the type of changes are 3 (control dependency change) and 5 (dependent API change).","The change of using a new method isConfirmKey() instead of explicitly checking the keyCode could cause a difference in return values, leading to a compatibility Issue which is due to the potential different return values (Type 1 CI)."
329,"<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>",18,19,"<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>","<android.app.AlarmManager: void setInexactRepeating(int,long,long,PendingIntent)>",0,"{
    try {
        mService.setInexactRepeating(type, triggerAtMillis, intervalMillis, operation);
    } catch (RemoteException ex) {
    }
}","{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, operation, null);
}",1,"/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences supplied by {@link #setRepeating}, since the
 * system can adjust alarms' phase to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * {@link #setRepeating} instead.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time, but there may be a
 * delay of almost an entire alarm interval before the first invocation of
 * the alarm.
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.  If this is one of INTERVAL_FIFTEEN_MINUTES,
 * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
 * then the alarm will be phase-aligned with other alarms to reduce the
 * number of wakeups.  Otherwise, the alarm will be set as though the
 * application had called {@link #setRepeating}.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */
","/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences supplied by {@link #setRepeating}, since the
 * system can adjust alarms' phase to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * {@link #setRepeating} instead.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time, but there may be a
 * delay of almost an entire alarm interval before the first invocation of
 * the alarm.
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.  If this is one of INTERVAL_FIFTEEN_MINUTES,
 * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
 * then the alarm will be phase-aligned with other alarms to reduce the
 * number of wakeups.  Otherwise, the alarm will be set as though the
 * application had called {@link #setRepeating}.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @deprecated As of API 19, all repeating alarms are inexact.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API mService.setInexactRepeating() has been replaced by setImpl(), and also the parameters passed into the function have been changed. Thus, the code change type is 1,5.","Since the function setImpl() is different from mService.setInexactRepeating(), there's a possibility it causes the API to return a different value. Thus, it's a compatibility issue of type 1."
330,<android.database.MatrixCursor: RowBuilder newRow()>,18,19,<android.database.MatrixCursor: RowBuilder newRow()>,<android.database.MatrixCursor: RowBuilder newRow()>,0,"{
    rowCount++;
    int endIndex = rowCount * columnCount;
    ensureCapacity(endIndex);
    int start = endIndex - columnCount;
    return new RowBuilder(start, endIndex);
}","{
    final int row = rowCount++;
    final int endIndex = rowCount * columnCount;
    ensureCapacity(endIndex);
    return new RowBuilder(row);
}",1,"/**
 * Adds a new row to the end and returns a builder for that row. Not safe
 * for concurrent use.
 *
 * @return builder which can be used to set the column values for the new
 * row
 */
","/**
 * Adds a new row to the end and returns a builder for that row. Not safe
 * for concurrent use.
 *
 * @return builder which can be used to set the column values for the new
 * row
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API RowBuilder() has undergone changes with a different number of parameters in the late version compared to the early version. Plus, we have a change in return statement since the parameters of returned object RowBuilder varies in two versions. Therefore, the code change type is 1,5.","Since the parameters of the RowBuilder() method have been changed in the late version, it can potentially lead the newRow() to return a different RowBuilder and hence, a different object. Therefore, the Compatibility Issue type is 1."
331,<android.nfc.NdefRecord: String toMimeType()>,18,19,<android.nfc.NdefRecord: String toMimeType()>,<android.nfc.NdefRecord: String toMimeType()>,0,"{
    switch(mTnf) {
        case NdefRecord.TNF_WELL_KNOWN:
            if (Arrays.equals(mType, NdefRecord.RTD_TEXT)) {
                return ""text/plain"";
            }
            break;
        case NdefRecord.TNF_MIME_MEDIA:
            String mimeType = new String(mType, Charsets.US_ASCII);
            return Intent.normalizeMimeType(mimeType);
    }
    return null;
}","{
    switch(mTnf) {
        case NdefRecord.TNF_WELL_KNOWN:
            if (Arrays.equals(mType, NdefRecord.RTD_TEXT)) {
                return ""text/plain"";
            }
            break;
        case NdefRecord.TNF_MIME_MEDIA:
            String mimeType = new String(mType, StandardCharsets.US_ASCII);
            return Intent.normalizeMimeType(mimeType);
    }
    return null;
}",1,"/**
 * Map this record to a MIME type, or return null if it cannot be mapped.<p>
 * Currently this method considers all {@link #TNF_MIME_MEDIA} records to
 * be MIME records, as well as some {@link #TNF_WELL_KNOWN} records such as
 * {@link #RTD_TEXT}. If this is a MIME record then the MIME type as string
 * is returned, otherwise null is returned.<p>
 * This method does not perform validation that the MIME type is
 * actually valid. It always attempts to
 * return a string containing the type if this is a MIME record.<p>
 * The returned MIME type will by normalized to lower-case using
 * {@link Intent#normalizeMimeType}.<p>
 * The MIME payload can be obtained using {@link #getPayload}.
 *
 * @return MIME type as a string, or null if this is not a MIME record
 */
","/**
 * Map this record to a MIME type, or return null if it cannot be mapped.<p>
 * Currently this method considers all {@link #TNF_MIME_MEDIA} records to
 * be MIME records, as well as some {@link #TNF_WELL_KNOWN} records such as
 * {@link #RTD_TEXT}. If this is a MIME record then the MIME type as string
 * is returned, otherwise null is returned.<p>
 * This method does not perform validation that the MIME type is
 * actually valid. It always attempts to
 * return a string containing the type if this is a MIME record.<p>
 * The returned MIME type will by normalized to lower-case using
 * {@link Intent#normalizeMimeType}.<p>
 * The MIME payload can be obtained using {@link #getPayload}.
 *
 * @return MIME type as a string, or null if this is not a MIME record
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"Only the parameter of 'new String' method has changed from 'Charsets.US_ASCII' to 'StandardCharsets.US_ASCII', so the change type is 5.","Even though there is a change in the dependent API, it does not introduce different behaviours as the new parameter has the same functionality as the old parameter. Hence, no change in return value or exception handling, and the CI type is 0."
332,<android.widget.TextView: boolean hasOverlappingRendering()>,18,19,<android.widget.TextView: boolean hasOverlappingRendering()>,<android.widget.TextView: boolean hasOverlappingRendering()>,0,"{
    return ((getBackground() != null && getBackground().getCurrent() != null) || mText instanceof Spannable || hasSelection());
}","{
    // horizontal fading edge causes SaveLayerAlpha, which doesn't support alpha modulation
    return ((getBackground() != null && getBackground().getCurrent() != null) || mText instanceof Spannable || hasSelection() || isHorizontalFadingEdgeEnabled());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new condition has been added into return statement (isHorizontalFadingEdgeEnabled()) and a condition statement has been added, so Change type is 1,3.",The introduction of the new condition could potentially lead to different return values and thus a compatibility issue of type 1.
333,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName, getParameterType());
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""("" + param.getName() + "")"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(LOG_TAG, ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""("" + param.getName() + "") with "" + (this.value == null ? ""null"" : this.value.getClass().getName()));
        }
        method.invoke(view, this.value);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class<?> param = getParameterType();
    if (param == null) {
        throw new ActionException(""bad type: "" + this.type);
    }
    try {
        getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value));
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",2,"There are changes in which method is called to get the method object and how parameters are passed into method invocation. These changes can't directly lead to differences in return values, but may cause different exceptions to be thrown. Therefore, the code change types are 1,4.","Even though the return statement didn't change, the changes in how to get the method object and how to pass parameters in the method invocation might throw different exceptions. Therefore, the compatibility issue type is 2."
334,<android.webkit.WebView: int findAll(String)>,18,19,<android.webkit.WebView: int findAll(String)>,<android.webkit.WebView: int findAll(String)>,0,"{
    checkThread();
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""findAll"");
    StrictMode.noteSlowCall(""findAll blocks UI: prefer findAllAsync"");
    return mProvider.findAll(find);
}",1,"/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
","/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String ""find"" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"A debug log has been added into the method in the late version, this change does not affect the logic and behavior of the method, so the change type is 4.","The change of code does not affect the return variable and exception handling of the method, so there is no Compatibility Issue (type 0)."
335,"<android.view.HardwareRenderer.GlRenderer: void draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",18,19,"<android.view.HardwareRenderer.GlRenderer: void draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>","<android.view.HardwareRenderer.GlRenderer: void draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",0,"{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.PFLAG_DRAWN;
        final int surfaceState = checkCurrent();
        if (surfaceState != SURFACE_STATE_ERROR) {
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            if (mProfileEnabled) {
                mProfileLock.lock();
            }
            dirty = beginFrame(canvas, dirty, surfaceState);
            DisplayList displayList = buildDisplayList(view, canvas);
            int saveCount = 0;
            int status = DisplayList.STATUS_DONE;
            try {
                status = prepareFrame(dirty);
                saveCount = canvas.save();
                callbacks.onHardwarePreDraw(canvas);
                if (displayList != null) {
                    status |= drawDisplayList(attachInfo, canvas, displayList, status);
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
            } catch (Exception e) {
                Log.e(LOG_TAG, ""An error has occurred while drawing:"", e);
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
                mFrameCount++;
                debugDirtyRegions(dirty, canvas);
                drawProfileData(attachInfo);
            }
            onPostDraw();
            swapBuffers(status);
            if (mProfileEnabled) {
                mProfileLock.unlock();
            }
            attachInfo.mIgnoreDirtyState = false;
        }
    }
}","{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.PFLAG_DRAWN;
        // We are already on the correct thread
        final int surfaceState = checkRenderContextUnsafe();
        if (surfaceState != SURFACE_STATE_ERROR) {
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            if (mProfileEnabled) {
                mProfileLock.lock();
            }
            dirty = beginFrame(canvas, dirty, surfaceState);
            DisplayList displayList = buildDisplayList(view, canvas);
            // We must therefore check again here.
            if (checkRenderContextUnsafe() == SURFACE_STATE_ERROR) {
                return;
            }
            int saveCount = 0;
            int status = DisplayList.STATUS_DONE;
            long start = getSystemTime();
            try {
                status = prepareFrame(dirty);
                saveCount = canvas.save();
                callbacks.onHardwarePreDraw(canvas);
                if (displayList != null) {
                    status |= drawDisplayList(attachInfo, canvas, displayList, status);
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
            } catch (Exception e) {
                Log.e(LOG_TAG, ""An error has occurred while drawing:"", e);
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
                mDrawDelta = getSystemTime() - start;
                if (mDrawDelta > 0) {
                    mFrameCount++;
                    debugOverdraw(attachInfo, dirty, canvas, displayList);
                    debugDirtyRegions(dirty, canvas);
                    drawProfileData(attachInfo);
                }
            }
            onPostDraw();
            swapBuffers(status);
            if (mProfileEnabled) {
                mProfileLock.unlock();
            }
            attachInfo.mIgnoreDirtyState = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The checkCurrent() method is replaced by checkRenderContextUnsafe(). A condition check statement is added, if checkRenderContextUnsafe() == SURFACE_STATE_ERROR returns true, the method will return. Additionally, a new timing measurement statement (start = getSystemTime()) is introduced, and more statements are added under the if(mDrawDelta > 0) condition. These fall under categories 1, 3, and 4.","The introduction of an early return statement, based on a new condition check, could potentially change the behavior or output of the API method. As it could potentially return different values, the CI type is 1."
336,<android.content.ContentProviderClient: boolean release()>,18,19,<android.content.ContentProviderClient: boolean release()>,<android.content.ContentProviderClient: boolean release()>,0,"{
    synchronized (this) {
        if (mReleased) {
            throw new IllegalStateException(""Already released"");
        }
        mReleased = true;
        if (mStable) {
            return mContentResolver.releaseProvider(mContentProvider);
        } else {
            return mContentResolver.releaseUnstableProvider(mContentProvider);
        }
    }
}","{
    synchronized (this) {
        if (mReleased) {
            throw new IllegalStateException(""Already released"");
        }
        mReleased = true;
        mGuard.close();
        if (mStable) {
            return mContentResolver.releaseProvider(mContentProvider);
        } else {
            return mContentResolver.releaseUnstableProvider(mContentProvider);
        }
    }
}",1,"/**
 * Call this to indicate to the system that the associated {@link ContentProvider} is no
 * longer needed by this {@link ContentProviderClient}.
 * @return true if this was release, false if it was already released
 */
","/**
 * Call this to indicate to the system that the associated {@link ContentProvider} is no
 * longer needed by this {@link ContentProviderClient}.
 * @return true if this was release, false if it was already released
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new expression has been introduced (""mGuard.close()"") that does not affect the program control flow, parameters or return types and values. Therefore, the change type is 4.","The new statement (mGuard.close()) won't affect the return value or the possibility of an exception being thrown, meaning that the behavior of the API does not change from the client's perspective. Thus, no compatibility issue arises."
337,"<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>",18,19,"<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>","<android.app.FragmentManagerImpl: void enqueueAction(Runnable,boolean)>",0,"{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mActivity == null) {
            throw new IllegalStateException(""Activity has been destroyed"");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mActivity.mHandler.removeCallbacks(mExecCommit);
            mActivity.mHandler.post(mExecCommit);
        }
    }
}","{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mActivity == null) {
            throw new IllegalStateException(""Activity has been destroyed"");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mActivity.mHandler.removeCallbacks(mExecCommit);
            mActivity.mHandler.post(mExecCommit);
        }
    }
}",1,,"/**
 * Adds an action to the queue of pending actions.
 *
 * @param action the action to add
 * @param allowStateLoss whether to allow loss of state information
 * @throws IllegalStateException if the activity has been destroyed
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,2,"In the condition of the 'if' statement, another condition 'mDestroyed' is added in the later version. This implies that the code change type is 3, as the control dependency has changed.","The addition of the condition 'mDestroyed' will potentially cause the method to throw an IllegalStateException that it wouldn't have in the early version. This results in a CI, specifically type 2, as the way exceptions are handled has changed."
338,"<android.os.BinderProxy: void dumpAsync(FileDescriptor,String[])>",18,19,"<android.os.BinderProxy: void dumpAsync(FileDescriptor,String[])>","<android.os.BinderProxy: void dumpAsync(FileDescriptor,String[])>",0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeFileDescriptor(fd);
    data.writeStringArray(args);
    try {
        transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);
        reply.readException();
    } finally {
        data.recycle();
        reply.recycle();
    }
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeFileDescriptor(fd);
    data.writeStringArray(args);
    try {
        transact(DUMP_TRANSACTION, data, reply, FLAG_ONEWAY);
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no difference between the early implementation and the late implementation, so no change type applies here.","As there is no change in the code, no Compatibility Issue appears."
339,<android.widget.RemoteViews.ViewGroupAction: String getActionName()>,18,19,<android.widget.RemoteViews.ViewGroupAction: String getActionName()>,<android.widget.RemoteViews.ViewGroupAction: String getActionName()>,0,"{
    return ""ViewGroupAction"" + this.nestedViews == null ? ""Remove"" : ""Add"";
}","{
    return ""ViewGroupAction"" + (nestedViews == null ? ""Remove"" : ""Add"");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The structure of the return statement has changed slightly - the parentheses have been added around `(nestedViews == null ? ""Remove"" : ""Add"")`, which can potentially influence the execution order of the code statement, so the code change can be classified as type 4.","The change in the return statement's structure might lead to a different string being returned, especially considering the execution order of the expressions involved. This potential difference in return values makes it a compatibility issue of type 1."
340,<android.view.View: void requestLayout()>,18,19,<android.view.View: void requestLayout()>,<android.view.View: void requestLayout()>,0,"{
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
        // Only trigger request-during-layout logic if this is the view requesting it,
        // not the views in its parent hierarchy
        ViewRootImpl viewRoot = getViewRootImpl();
        if (viewRoot != null && viewRoot.isInLayout()) {
            if (!viewRoot.requestLayoutDuringLayout(this)) {
                return;
            }
        }
        mAttachInfo.mViewRequestingLayout = this;
    }
    mPrivateFlags |= PFLAG_FORCE_LAYOUT;
    mPrivateFlags |= PFLAG_INVALIDATED;
    if (mParent != null && !mParent.isLayoutRequested()) {
        mParent.requestLayout();
    }
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
        mAttachInfo.mViewRequestingLayout = null;
    }
}","{
    if (mMeasureCache != null)
        mMeasureCache.clear();
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
        // Only trigger request-during-layout logic if this is the view requesting it,
        // not the views in its parent hierarchy
        ViewRootImpl viewRoot = getViewRootImpl();
        if (viewRoot != null && viewRoot.isInLayout()) {
            if (!viewRoot.requestLayoutDuringLayout(this)) {
                return;
            }
        }
        mAttachInfo.mViewRequestingLayout = this;
    }
    mPrivateFlags |= PFLAG_FORCE_LAYOUT;
    mPrivateFlags |= PFLAG_INVALIDATED;
    if (mParent != null && !mParent.isLayoutRequested()) {
        mParent.requestLayout();
    }
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
        mAttachInfo.mViewRequestingLayout = null;
    }
}",1,"/**
 * Call this when something has changed which has invalidated the
 * layout of this view. This will schedule a layout pass of the view
 * tree. This should not be called while the view hierarchy is currently in a layout
 * pass ({@link #isInLayout()}. If layout is happening, the request may be honored at the
 * end of the current layout pass (and then layout will run again) or after the current
 * frame is drawn and the next layout occurs.
 *
 * <p>Subclasses which override this method should call the superclass method to
 * handle possible request-during-layout errors correctly.</p>
 */
","/**
 * Call this when something has changed which has invalidated the
 * layout of this view. This will schedule a layout pass of the view
 * tree. This should not be called while the view hierarchy is currently in a layout
 * pass ({@link #isInLayout()}. If layout is happening, the request may be honored at the
 * end of the current layout pass (and then layout will run again) or after the current
 * frame is drawn and the next layout occurs.
 *
 * <p>Subclasses which override this method should call the superclass method to
 * handle possible request-during-layout errors correctly.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code has added a new condition in the beginning ('if (mMeasureCache != null) mMeasureCache.clear();'), which is a clear method invocation on mMeasureCache if it is not null. This change is classified as 'Other statement changed'.","The chore added in the beginning of the method clears the 'mMeasureCache' if it exists, this does not alter the function's returned result and also does not alter the exception the function throws. Therefore, no compatibility issue exists."
342,<android.hardware.Sensor: int getReportingMode(Sensor)>,18,19,<android.hardware.Sensor: int getReportingMode(Sensor)>,<android.hardware.Sensor: int getReportingMode(Sensor)>,0,"{
    // mType starts from offset 1.
    return sSensorReportingModes[sensor.mType - 1];
}","{
    int offset = sensor.mType * 2;
    if (offset >= sSensorReportingModes.length) {
        // we don't know about this sensor, so this is probably a
        // vendor-defined sensor, in that case, we figure out the reporting
        // mode from the sensor meta-data.
        int minDelay = sensor.mMinDelay;
        if (minDelay == 0) {
            return REPORTING_MODE_ON_CHANGE;
        } else if (minDelay < 0) {
            return REPORTING_MODE_ONE_SHOT;
        } else {
            return REPORTING_MODE_CONTINUOUS;
        }
    }
    return sSensorReportingModes[offset];
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The calculation method of the variable 'offset' has been changed from subtracting 1 to multiplying 2. And new control dependency including checking whether 'offset' is larger than length of 'sSensorReportingModes', and return different values based on the condition of 'sensor.mMinDelay' have been introduced. Therefore, the change type is 1,3.","The 'sSensorReportingModes[offset]' and the values immediately returned in conditional branches of sensor.mMinDelay are different in the two versions, potentially leading to different return values of this API, so the CI type is 1."
344,<android.app.ContextImpl: boolean stopService(Intent)>,18,19,<android.app.ContextImpl: boolean stopService(Intent)>,<android.app.ContextImpl: boolean stopService(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    return stopServiceAsUser(service, mUser);
}","{
    warnIfCallingFromSystemProcess();
    return stopServiceCommon(service, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ""return stopServiceAsUser(service, mUser);"" to ""return stopServiceCommon(service, mUser);"", the Dependent API has also changed, so the code change type is 1,5.","The change in return statement from stopServiceAsUser to stopServiceCommon will potentially lead to different return values. So, the Compatibility Issue (CI) type is 1."
345,<android.speech.srec.Recognizer: String getConfigDir(Locale)>,18,19,<android.speech.srec.Recognizer: String getConfigDir(Locale)>,<android.speech.srec.Recognizer: String getConfigDir(Locale)>,0,"{
    if (locale == null)
        locale = Locale.US;
    String dir = ""/system/usr/srec/config/"" + locale.toString().replace('_', '.').toLowerCase();
    if ((new File(dir)).isDirectory())
        return dir;
    return null;
}","{
    if (locale == null)
        locale = Locale.US;
    String dir = ""/system/usr/srec/config/"" + locale.toString().replace('_', '.').toLowerCase(Locale.ROOT);
    if ((new File(dir)).isDirectory())
        return dir;
    return null;
}",1,"/**
 * Get the pathname of the SREC configuration directory corresponding to the
 * language indicated by the Locale.
 * This directory contains dictionaries, speech models,
 * configuration files, and other data needed by the Recognizer.
 * @param locale <code>Locale</code> corresponding to the desired language,
 * or null for default, currently <code>Locale.US</code>.
 * @return Pathname of the configuration directory.
 */
","/**
 * Get the pathname of the SREC configuration directory corresponding to the
 * language indicated by the Locale.
 * This directory contains dictionaries, speech models,
 * configuration files, and other data needed by the Recognizer.
 * @param locale <code>Locale</code> corresponding to the desired language,
 * or null for default, currently <code>Locale.US</code>.
 * @return Pathname of the configuration directory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The function call to toLowerCase() on locale.toString() has been changed to toLowerCase(Locale.ROOT). This function change will not affect the control flow of the API but could potentially give a different result for 'dir' in some edge cases where the default Locale is not the same as Locale.ROOT.,"No Compatibility Issue exists. Although the function toLowerCase() has been replaced by toLowerCase(Locale.ROOT), the behavior of the API would not change in most cases since Locale.ROOT is used for locale-insensitive operations. This change is enacted to make the API's behavior consistent across all locales, which by definition doesn't cause a compatibility issue. Thus, CI type is 0."
346,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",18,19,"<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>","<android.bluetooth.BluetoothAdapter: void closeProfileProxy(int,BluetoothProfile)>",0,"{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
    }
}","{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
    }
}",1,"/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
","/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the late version, a new case statement (for BluetoothProfile.MAP) has been added in the 'switch' statement, so the code change type is 3 (Control dependency changed).","The newly added case for BluetoothProfile.MAP could change the behavior of the method because different actions (calling map.close()) will be taken when profile is 'BluetoothProfile.MAP', which may lead to different return values or states. Therefore, the Compatibility Issue type is 1."
347,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,18,19,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,<android.net.SSLCertificateSocketFactory: Socket createSocket()>,0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket();
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * Creates a new socket which is not connected to any remote host.
 * You must use {@link Socket#connect} to connect the socket.
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,The method call s.setNpnProtocols(mNpnProtocols); was replaced with s.setAlpnProtocols(mAlpnProtocols); so the code change type is 4.,"The change in method call could potentially cause the return Socket object to be different between the two versions, so it causes a compatibility issue of type 1."
351,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,18,19,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,<android.nfc.NdefRecord: NdefRecord createUri(Uri)>,0,"{
    if (uri == null)
        throw new NullPointerException(""uri is null"");
    uri = uri.normalizeScheme();
    String uriString = uri.toString();
    if (uriString.length() == 0)
        throw new IllegalArgumentException(""uri is empty"");
    byte prefix = 0;
    for (int i = 1; i < URI_PREFIX_MAP.length; i++) {
        if (uriString.startsWith(URI_PREFIX_MAP[i])) {
            prefix = (byte) i;
            uriString = uriString.substring(URI_PREFIX_MAP[i].length());
            break;
        }
    }
    byte[] uriBytes = uriString.getBytes(Charsets.UTF_8);
    byte[] recordBytes = new byte[uriBytes.length + 1];
    recordBytes[0] = prefix;
    System.arraycopy(uriBytes, 0, recordBytes, 1, uriBytes.length);
    return new NdefRecord(TNF_WELL_KNOWN, RTD_URI, null, recordBytes);
}","{
    if (uri == null)
        throw new NullPointerException(""uri is null"");
    uri = uri.normalizeScheme();
    String uriString = uri.toString();
    if (uriString.length() == 0)
        throw new IllegalArgumentException(""uri is empty"");
    byte prefix = 0;
    for (int i = 1; i < URI_PREFIX_MAP.length; i++) {
        if (uriString.startsWith(URI_PREFIX_MAP[i])) {
            prefix = (byte) i;
            uriString = uriString.substring(URI_PREFIX_MAP[i].length());
            break;
        }
    }
    byte[] uriBytes = uriString.getBytes(StandardCharsets.UTF_8);
    byte[] recordBytes = new byte[uriBytes.length + 1];
    recordBytes[0] = prefix;
    System.arraycopy(uriBytes, 0, recordBytes, 1, uriBytes.length);
    return new NdefRecord(TNF_WELL_KNOWN, RTD_URI, null, recordBytes);
}",1,"/**
 * Create a new NDEF Record containing a URI.<p>
 * Use this method to encode a URI (or URL) into an NDEF Record.<p>
 * Uses the well known URI type representation: {@link #TNF_WELL_KNOWN}
 * and {@link #RTD_URI}. This is the most efficient encoding
 * of a URI into NDEF.<p>
 * The uri parameter will be normalized with
 * {@link Uri#normalizeScheme} to set the scheme to lower case to
 * follow Android best practices for intent filtering.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown if the uri
 * parameter has serious problems, for example if it is empty, so always
 * catch this exception if you are passing user-generated data into this
 * method.<p>
 *
 * Reference specification: NFCForum-TS-RTD_URI_1.0
 *
 * @param uri URI to encode.
 * @return an NDEF Record containing the URI
 * @throws IllegalArugmentException if the uri is empty or invalid
 */
","/**
 * Create a new NDEF Record containing a URI.<p>
 * Use this method to encode a URI (or URL) into an NDEF Record.<p>
 * Uses the well known URI type representation: {@link #TNF_WELL_KNOWN}
 * and {@link #RTD_URI}. This is the most efficient encoding
 * of a URI into NDEF.<p>
 * The uri parameter will be normalized with
 * {@link Uri#normalizeScheme} to set the scheme to lower case to
 * follow Android best practices for intent filtering.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown if the uri
 * parameter has serious problems, for example if it is empty, so always
 * catch this exception if you are passing user-generated data into this
 * method.<p>
 *
 * Reference specification: NFCForum-TS-RTD_URI_1.0
 *
 * @param uri URI to encode.
 * @return an NDEF Record containing the URI
 * @throws IllegalArugmentException if the uri is empty or invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The Charset.UTF_8 in 'uriString.getBytes(Charsets.UTF_8)' has been modified to StandardCharsets.UTF_8 in 'uriString.getBytes(StandardCharsets.UTF_8)', so the code change type is 4.","The replacement of Charset.UTF_8 to StandardCharsets.UTF_8 doesn't affect the behaviour of the API. The API still performs the same operation and returns the same type of results as before in the same scenarios. Thus, no Compatibility Issue exists, so it's 0."
352,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,18,19,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (mLastWasImTarget) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                return FINISH_NOT_HANDLED;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}","{
    if (mLastWasImTarget && !isInLocalFocusMode()) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            final InputEvent event = q.mEvent;
            if (DEBUG_IMF)
                Log.v(TAG, ""Sending input event to IME: "" + event);
            int result = imm.dispatchInputEvent(event, q, this, mHandler);
            if (result == InputMethodManager.DISPATCH_HANDLED) {
                return FINISH_HANDLED;
            } else if (result == InputMethodManager.DISPATCH_NOT_HANDLED) {
                return FINISH_NOT_HANDLED;
            } else {
                // callback will be invoked later
                return DEFER;
            }
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new control dependency statement, '!isInLocalFocusMode()', has been added to 'if' in the late version, so the code change type is 3.","Due to the new control dependency statement, '!isInLocalFocusMode()', the return value could be different when the condition of the 'if' statement is not met. Therefore, the CI type is 1."
353,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readVarLongArray(DataInputStream)>,18,19,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readVarLongArray(DataInputStream)>,<android.net.NetworkStatsHistory.DataStreamUtils: long[] readVarLongArray(DataInputStream)>,0,"{
    final int size = in.readInt();
    if (size == -1)
        return null;
    final long[] values = new long[size];
    for (int i = 0; i < values.length; i++) {
        values[i] = readVarLong(in);
    }
    return values;
}","{
    final int size = in.readInt();
    if (size == -1)
        return null;
    if (size < 0)
        throw new ProtocolException(""negative array size"");
    final long[] values = new long[size];
    for (int i = 0; i < values.length; i++) {
        values[i] = readVarLong(in);
    }
    return values;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2","An additional condition (size < 0) and exception handling (throw new ProtocolException(""negative array size"")) are introduced to the method in the late version, so the code change type is 2,3.","The introduction of the new throwing exception can potentially lead to different behaviours when exceptions occur and the additional control statement (size < 0) could also lead the method to return a different result. Hence, the CI type is 1,2."
354,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,18,19,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.ViewPostImeInputStage: int onProcess(QueuedInputEvent)>,0,"{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}","{
    if (q.mEvent instanceof KeyEvent) {
        return processKeyEvent(q);
    } else {
        // If delivering a new non-key event, make sure the window is
        // now allowed to start updating.
        handleDispatchDoneAnimating();
        final int source = q.mEvent.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            return processPointerEvent(q);
        } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement, handleDispatchDoneAnimating(), is added, so the change type is 4.","The added statement has no effect on the output (return types/values) or any thrown exceptions. Therefore, no compatibility issue (type 0) arises in this case."
355,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,18,19,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,<android.net.CaptivePortalTracker.DelayedCaptiveCheckState: boolean processMessage(Message)>,0,"{
    if (DBG)
        log(getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_DELAYED_CAPTIVE_CHECK:
            if (message.arg1 == mDelayedCheckToken) {
                InetAddress server = lookupHost(mServer);
                boolean captive = server != null && isCaptivePortal(server);
                if (captive) {
                    if (DBG)
                        log(""Captive network "" + mNetworkInfo);
                } else {
                    if (DBG)
                        log(""Not captive network "" + mNetworkInfo);
                }
                if (mDeviceProvisioned) {
                    if (captive) {
                        // Setup Wizard will assist the user in connecting to a captive
                        // portal, so make the notification visible unless during setup
                        setNotificationVisible(true);
                    }
                } else {
                    Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_TEST_COMPLETED);
                    intent.putExtra(ConnectivityManager.EXTRA_IS_CAPTIVE_PORTAL, captive);
                    intent.setPackage(SETUP_WIZARD_PACKAGE);
                    mContext.sendBroadcast(intent);
                }
                transitionTo(mActiveNetworkState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    if (DBG)
        log(getName() + message.toString());
    switch(message.what) {
        case CMD_DELAYED_CAPTIVE_CHECK:
            setNotificationOff();
            if (message.arg1 == mDelayedCheckToken) {
                InetAddress server = lookupHost(mServer);
                boolean captive = server != null && isCaptivePortal(server);
                if (captive) {
                    if (DBG)
                        log(""Captive network "" + mNetworkInfo);
                } else {
                    if (DBG)
                        log(""Not captive network "" + mNetworkInfo);
                }
                notifyPortalCheckCompleted(mNetworkInfo, captive);
                if (mDeviceProvisioned) {
                    if (captive) {
                        // portal, so make the notification visible unless during setup
                        try {
                            mConnService.setProvisioningNotificationVisible(true, mNetworkInfo.getType(), mNetworkInfo.getExtraInfo(), mUrl);
                        } catch (RemoteException e) {
                            e.printStackTrace();
                        }
                    }
                } else {
                    Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_TEST_COMPLETED);
                    intent.putExtra(ConnectivityManager.EXTRA_IS_CAPTIVE_PORTAL, captive);
                    intent.setPackage(SETUP_WIZARD_PACKAGE);
                    mContext.sendBroadcast(intent);
                }
                transitionTo(mActiveNetworkState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The code change consists of removal of argument (""\n"") in log() function, introduction of new method setNotificationOff(), the replacement of setNotificationVisible() with mConnService.setProvisioningNotificationVisible() and introduction of new exception handling statement (catch RemoteException e). Therefore, the classes of code change are 1,2,3,5.","The introduction of new method setNotificationOff() and removal of argument (""\n"") in log() function might cause the 'return HANDLED' to hold different meaning. And the newly introduced exception statement (catch RemoteException e) has caused the change to potentially able to throw different exceptions. Therefore, the CI type is 1,2."
356,<android.widget.GridLayout: boolean isColumnOrderPreserved()>,18,19,<android.widget.GridLayout: boolean isColumnOrderPreserved()>,<android.widget.GridLayout: boolean isColumnOrderPreserved()>,0,"{
    return horizontalAxis.isOrderPreserved();
}","{
    return mHorizontalAxis.isOrderPreserved();
}",1,"/**
 * Returns whether or not column boundaries are ordered by their grid indices.
 *
 * @return {@code true} if column boundaries must appear in the order of their indices,
 * {@code false} otherwise
 *
 * @see #setColumnOrderPreserved(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_columnOrderPreserved
 */
","/**
 * Returns whether or not column boundaries are ordered by their grid indices.
 *
 * @return {@code true} if column boundaries must appear in the order of their indices,
 * {@code false} otherwise
 *
 * @see #setColumnOrderPreserved(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_columnOrderPreserved
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The variable horizontalAxis is changed to mHorizontalAxis, so the code change type is 4.","As the variable in the return statement has changed, it can make the API potentially return a different value, so the CI type is 1."
357,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,18,19,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,0,"{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    }
    return FORWARD;
}","{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    } else if (q.mEvent instanceof KeyEvent) {
        if (mKeys.process((KeyEvent) q.mEvent)) {
            return FINISH_HANDLED;
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"The addition of a new 'else if' control statement which checks if the input event is an instance of KeyEvent and returns a value based on this is a control dependency change, thus it is a class 3 change. Moreover, this new control statement also includes a new return statement which returns FINISH_HANDLED if mKeys.process((KeyEvent) q.mEvent)), which is a class 1 change.","The new return statement could potentially cause the method to return a different value between the two versions, hence it falls under class 1 of Compatibility Issue caused by potential different return values."
361,<android.view.View: boolean rootViewRequestFocus()>,18,19,<android.view.View: boolean rootViewRequestFocus()>,<android.view.View: boolean rootViewRequestFocus()>,0,"{
    View root = getRootView();
    if (root != null) {
        return root.requestFocus();
    }
    return false;
}","{
    final View root = getRootView();
    return root != null && root.requestFocus();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1, 3",1,"In the early version, the method first checks if the root is null and then requests focus. If the root is null, it explicitly returns false. In the late version, the same operation is performed in one single statement. Therefore, the code change type is 1, 3.","The change in implementation can potentially lead to different return types or values. Therefore, the compatibility issue type is 1."
362,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",18,19,"<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>","<android.widget.AbsListView: boolean onKeyUp(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            if (!isEnabled()) {
                return true;
            }
            if (isClickable() && isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
                final View view = getChildAt(mSelectedPosition - mFirstPosition);
                if (view != null) {
                    performItemClick(view, mSelectedPosition, mSelectedRowId);
                    view.setPressed(false);
                }
                setPressed(false);
                return true;
            }
            break;
    }
    return super.onKeyUp(keyCode, event);
}","{
    if (KeyEvent.isConfirmKey(keyCode)) {
        if (!isEnabled()) {
            return true;
        }
        if (isClickable() && isPressed() && mSelectedPosition >= 0 && mAdapter != null && mSelectedPosition < mAdapter.getCount()) {
            final View view = getChildAt(mSelectedPosition - mFirstPosition);
            if (view != null) {
                performItemClick(view, mSelectedPosition, mSelectedRowId);
                view.setPressed(false);
            }
            setPressed(false);
            return true;
        }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The control statement ""switch(keyCode)"" was replaced with ""if (KeyEvent.isConfirmKey(keyCode))"", and ""KeyEvent.isConfirmKey(keyCode)"" is a dependent API that's introduced in the late version. So the change type is 3,5.","As per the changes, the control flow of returning true has changed and could possibly lead to different boolean output between the two versions when invoked. Thus, the Compatibility Issue type is 1."
363,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,18,19,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    int action = ev.getAction();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!mIsAttached) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    int action = ev.getAction();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (!isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroller != null && mFastScroller.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The condition in the if statements has changed from !mIsAttached to !isAttachedToWindow() and the invoked function 'isAttachedToWindow' is not found in early version, so the code change type is 3,5.","With the change in control statement in 19 version, the return value might differ from the previous 18 version APIs. If isAttachedToWindow() returns a different value than the previous version, the return statement 'return false;' may be executed unexpectedly. Hence, the Compatibility Issue exists and its type is 1."
365,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,18,19,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,<android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer: String sanitize(String)>,0,"{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) != 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase();
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return """";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}","{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) != 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase(Locale.ROOT);
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return """";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}",1,"/**
 * Sanitize a value.
 * <ol>
 * <li>If script URLs are not OK, the will be removed.
 * <li>If neither spaces nor other white space is OK, then
 * white space will be trimmed from the beginning and end of
 * the URL. (Just the actual white space characters are trimmed, not
 * other control codes.)
 * <li> Illegal characters will be replaced with
 * either ' ' or '_', depending on whether a space is itself a
 * legal character.
 * </ol>
 * @param value
 * @return the sanitized value
 */
","/**
 * Sanitize a value.
 * <ol>
 * <li>If script URLs are not OK, the will be removed.
 * <li>If neither spaces nor other white space is OK, then
 * white space will be trimmed from the beginning and end of
 * the URL. (Just the actual white space characters are trimmed, not
 * other control codes.)
 * <li> Illegal characters will be replaced with
 * either ' ' or '_', depending on whether a space is itself a
 * legal character.
 * </ol>
 * @param value
 * @return the sanitized value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method toLowerCase() has added a new parameter Locale.ROOT in the late version, this can be classified as an other statement change, hence classification is 4.","In spite of the change, the value returned by the function remains the same. Invoking toLowerCase() with or without parameter Locale.ROOT produces the same output, therefore, there's no compatibility issue, thus classification is 0."
369,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",18,19,"<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>","<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void unbind(Context,int,Intent)>",0,"{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if (Process.myUid() == Process.SYSTEM_UID && (adapter = mAdapter.get()) != null) {
            mgr.unbindRemoteViewsService(appWidgetId, intent, new UserHandle(adapter.mUserId));
        } else {
            mgr.unbindRemoteViewsService(appWidgetId, intent, Process.myUserHandle());
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}","{
    try {
        RemoteViewsAdapter adapter;
        final AppWidgetManager mgr = AppWidgetManager.getInstance(context);
        if ((adapter = mAdapter.get()) != null) {
            checkInteractAcrossUsersPermission(context, adapter.mUserId);
            mgr.unbindRemoteViewsService(appWidgetId, intent, new UserHandle(adapter.mUserId));
        } else {
            Slog.w(TAG, ""unbind: adapter was null"");
        }
        mIsConnecting = false;
    } catch (Exception e) {
        Log.e(""RemoteViewsAdapterServiceConnection"", ""unbind(): "" + e.getMessage());
        mIsConnecting = false;
        mIsConnected = false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4","1, 2","In the 'if' condition, the statement 'Process.myUid() == Process.SYSTEM_UID' is removed and a new statement 'checkInteractAcrossUsersPermission(context, adapter.mUserId)' is added. Also, when adapter is null, a new warning log is added. So the change type is 3,4.","The condition and execution of 'if' statement change, which could potentially lead to different behaviours (return value and exception handling). Hence, the CI type is 1,2."
370,<android.widget.GridLayout: boolean isRowOrderPreserved()>,18,19,<android.widget.GridLayout: boolean isRowOrderPreserved()>,<android.widget.GridLayout: boolean isRowOrderPreserved()>,0,"{
    return verticalAxis.isOrderPreserved();
}","{
    return mVerticalAxis.isOrderPreserved();
}",1,"/**
 * Returns whether or not row boundaries are ordered by their grid indices.
 *
 * @return {@code true} if row boundaries must appear in the order of their indices,
 * {@code false} otherwise
 *
 * @see #setRowOrderPreserved(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_rowOrderPreserved
 */
","/**
 * Returns whether or not row boundaries are ordered by their grid indices.
 *
 * @return {@code true} if row boundaries must appear in the order of their indices,
 * {@code false} otherwise
 *
 * @see #setRowOrderPreserved(boolean)
 *
 * @attr ref android.R.styleable#GridLayout_rowOrderPreserved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed as the name of the object on which the called function isOrderPreserved() has been modified from verticalAxis to mVerticalAxis. Hence, the code change type is 1 and 5.","The change of return statement will make the API potentially return a different value due to the change in the name of the object, hence the Compatibility Issue (CI) type is 1."
371,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,18,19,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,"The early and late version of the method have no changes, so the change type is 0.","As there's no changes between the two versions, no Compatibility Issues arise, so the CI type is 0."
372,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,18,19,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,<android.widget.AbsListView: boolean isFastScrollAlwaysVisible()>,0,"{
    return mFastScrollEnabled && mFastScroller.isAlwaysShowEnabled();
}","{
    if (mFastScroller == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroller.isEnabled() && mFastScroller.isAlwaysShowEnabled();
    }
}",1,"/**
 * Returns true if the fast scroller is set to always show on this view rather than
 * fade out when not in use.
 *
 * @return true if the fast scroller will always show.
 * @see #setFastScrollAlwaysVisible(boolean)
 */
","/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the later version, an 'if' control statement has been added and the return statement has been modified, so the change type falls under 3 (Control dependency changed) and 4 (Other statement changed).","The change in the control flow and return statement means that the API may return a different value in its later version under certain conditions, this makes the potential Compatibility Issue of Type 1 (The method could potentially return a different value)."
374,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,18,19,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,<android.content.IntentFilter: void readFromXml(XmlPullParser)>,0,"{
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}","{
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals(ACTION_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addAction(name);
            }
        } else if (tagName.equals(CAT_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addCategory(name);
            }
        } else if (tagName.equals(TYPE_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                try {
                    addDataType(name);
                } catch (MalformedMimeTypeException e) {
                }
            }
        } else if (tagName.equals(SCHEME_STR)) {
            String name = parser.getAttributeValue(null, NAME_STR);
            if (name != null) {
                addDataScheme(name);
            }
        } else if (tagName.equals(SSP_STR)) {
            String ssp = parser.getAttributeValue(null, LITERAL_STR);
            if (ssp != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_LITERAL);
            } else if ((ssp = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_PREFIX);
            } else if ((ssp = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataSchemeSpecificPart(ssp, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else if (tagName.equals(AUTH_STR)) {
            String host = parser.getAttributeValue(null, HOST_STR);
            String port = parser.getAttributeValue(null, PORT_STR);
            if (host != null) {
                addDataAuthority(host, port);
            }
        } else if (tagName.equals(PATH_STR)) {
            String path = parser.getAttributeValue(null, LITERAL_STR);
            if (path != null) {
                addDataPath(path, PatternMatcher.PATTERN_LITERAL);
            } else if ((path = parser.getAttributeValue(null, PREFIX_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_PREFIX);
            } else if ((path = parser.getAttributeValue(null, SGLOB_STR)) != null) {
                addDataPath(path, PatternMatcher.PATTERN_SIMPLE_GLOB);
            }
        } else {
            Log.w(""IntentFilter"", ""Unknown tag parsing IntentFilter: "" + tagName);
        }
        XmlUtils.skipCurrentTag(parser);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The code that handles the ""PATH_STR"" tag hasn't changed, while the handling of the ""SSP_STR"" tag is newly introduced in the late version, so the code change types are 3 (control dependency changed) and 5 (dependent API changed). ","Although there has been a change in the implementation (introduction of handling the ""SSP_STR"" tag), there is no Compatibility Issue (CI) here. The newly introduced ""SSP_STR"" tag will not affect existing users who don't use this tag. Even for new users who use this tag, the behavior should be as expected (parse the SSP_STR tag and add the data), not a Compatibility Issue. Hence, the CI type is 0 - no Compatibility Issue exist."
376,<android.net.NetworkInfo: String toString()>,18,19,<android.net.NetworkInfo: String toString()>,<android.net.NetworkInfo: String toString()>,0,"{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""NetworkInfo: "");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable);
        return builder.toString();
    }
}","{
    synchronized (this) {
        StringBuilder builder = new StringBuilder(""NetworkInfo: "");
        builder.append(""type: "").append(getTypeName()).append(""["").append(getSubtypeName()).append(""], state: "").append(mState).append(""/"").append(mDetailedState).append("", reason: "").append(mReason == null ? ""(unspecified)"" : mReason).append("", extra: "").append(mExtraInfo == null ? ""(none)"" : mExtraInfo).append("", roaming: "").append(mIsRoaming).append("", failover: "").append(mIsFailover).append("", isAvailable: "").append(mIsAvailable).append("", isConnectedToProvisioningNetwork: "").append(mIsConnectedToProvisioningNetwork);
        return builder.toString();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,The return statement of the method has changed by appending new information to the returned string.,"The returned value of the method in Late_Version could be different from the Early_Version due to the additional appended string in the StringBuilder, thus potentially leading to Compatibility Issue type 1."
377,<android.widget.TextView: boolean onPreDraw()>,18,19,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mLayout == null) {
        assumeLayout();
    }
    boolean changed = false;
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            changed = bringPointIntoView(curs);
        }
    } else {
        changed = bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return !changed;
}","{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return true;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The change is in the return statement of the method, from !changed to true. The variable changed, which was set and manipulated in the early version, was removed in the late method version. Thus, the code change type is 1.","This change will affect the return value of the API. The early API version can return false or true based on the variable changed. However, the late version will always return true regardless of the actual scenario or context, which may cause different behaviours. So, the CI type is 1."
378,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",18,19,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>","<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",0,"{
    IContentProvider unstableProvider = acquireUnstableProvider(uri);
    if (unstableProvider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    IContentProvider stableProvider = null;
    AssetFileDescriptor fd = null;
    try {
        try {
            fd = unstableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        } catch (DeadObjectException e) {
            // The remote process has died...  but we only hold an unstable
            // reference though, so we might recover!!!  Let's try!!!!
            // This is exciting!!1!!1!!!!1
            unstableProviderDied(unstableProvider);
            stableProvider = acquireProvider(uri);
            if (stableProvider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            fd = stableProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts);
            if (fd == null) {
                // The provider will be released by the finally{} clause
                return null;
            }
        }
        if (stableProvider == null) {
            stableProvider = acquireProvider(uri);
        }
        releaseUnstableProvider(unstableProvider);
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        stableProvider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        // Whatever, whatever, we'll go away.
        throw new FileNotFoundException(""Failed opening content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (stableProvider != null) {
            releaseProvider(stableProvider);
        }
        if (unstableProvider != null) {
            releaseUnstableProvider(unstableProvider);
        }
    }
}","{
    return openTypedAssetFileDescriptor(uri, mimeType, opts, null);
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The late version completely changes the implementation, including return statements and the dependent APIs that the method calls. This makes the code change type 1,5.","Due to the change in the dependent APIs that are called and the different return statements, it is expected that the late version of the method would potentially return different values or types, which makes the CI type 1."
379,<android.view.View: void buildDrawingCache(boolean)>,18,19,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                    case DRAWING_CACHE_QUALITY_LOW:
                    case DRAWING_CACHE_QUALITY_HIGH:
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
            if (mOverlay != null && !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().draw(canvas);
            }
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some conditions in switch case statements related to the `quality` variable assignment have been removed. Thus, the change type is 4 (Other statement change).","These changes won't alter the return value or exceptions thrown by the API, and so there's no Compatibility Issue."
384,"<android.widget.Spinner.DialogPopup: void show(int,int)>",18,19,"<android.widget.Spinner.DialogPopup: void show(int,int)>","<android.widget.Spinner.DialogPopup: void show(int,int)>",0,"{
    AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
    if (mPrompt != null) {
        builder.setTitle(mPrompt);
    }
    mPopup = builder.setSingleChoiceItems(mListAdapter, getSelectedItemPosition(), this).create();
    final ListView listView = mPopup.getListView();
    listView.setTextDirection(textDirection);
    listView.setTextAlignment(textAlignment);
    mPopup.show();
}","{
    if (mListAdapter == null) {
        return;
    }
    AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
    if (mPrompt != null) {
        builder.setTitle(mPrompt);
    }
    mPopup = builder.setSingleChoiceItems(mListAdapter, getSelectedItemPosition(), this).create();
    final ListView listView = mPopup.getListView();
    listView.setTextDirection(textDirection);
    listView.setTextAlignment(textAlignment);
    mPopup.show();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement has been introduced inside the newly added 'if' condition, resulting in both return statement change and control dependency change. Therefore, the code change type is 3,1.","The newly introduced condition block and return statement could potentially lead to the function returning differently when 'mListAdapter == null' is true. This would ultimately result in different behavior of the API, hence the CI type is 1."
385,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",18,19,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Calendar startCalendar, endCalendar;
    Time startDate = new Time();
    if (timeZone != null) {
        startCalendar = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
    } else if (useUTC) {
        startCalendar = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
    } else {
        startCalendar = Calendar.getInstance();
    }
    startCalendar.setTimeInMillis(startMillis);
    setTimeFromCalendar(startDate, startCalendar);
    Time endDate = new Time();
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endCalendar = Calendar.getInstance(TimeZone.getTimeZone(timeZone));
        } else if (useUTC) {
            endCalendar = Calendar.getInstance(TimeZone.getTimeZone(""UTC""));
        } else {
            endCalendar = Calendar.getInstance();
        }
        endCalendar.setTimeInMillis(endMillis);
        setTimeFromCalendar(endDate, endCalendar);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    String startStandaloneMonthString = startMonthString;
    String endStandaloneMonthString = endMonthString;
    // We need standalone months for these strings in Persian (fa): http://b/6811327
    if (!numericDate && !abbrevMonth && Locale.getDefault().getLanguage().equals(""fa"")) {
        startStandaloneMonthString = startDate.format(""%-B"");
        endStandaloneMonthString = endDate.format(""%-B"");
    }
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    // but we want to fall back to the user's preference.
    if ((flags & (FORMAT_SHOW_TIME | FORMAT_12HOUR | FORMAT_24HOUR)) == FORMAT_SHOW_TIME) {
        flags |= DateFormat.is24HourFormat(context) ? FORMAT_24HOUR : FORMAT_12HOUR;
    }
    String range = DateIntervalFormat.formatDateRange(startMillis, endMillis, flags, timeZone);
    try {
        formatter.out().append(range);
    } catch (IOException impossible) {
        throw new AssertionError(impossible);
    }
    return formatter;
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_SHOW_YEAR is not set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
387,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,18,19,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,<android.content.pm.ResolveInfo: CharSequence loadLabel(PackageManager)>,0,"{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    CharSequence label;
    if (resolvePackageName != null && labelRes != 0) {
        label = pm.getText(resolvePackageName, labelRes, null);
        if (label != null) {
            return label.toString().trim();
        }
    }
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    ApplicationInfo ai = ci.applicationInfo;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label.toString().trim();
        }
    }
    CharSequence data = ci.loadLabel(pm);
    // Make the data safe
    if (data != null)
        data = data.toString().trim();
    return data;
}","{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    CharSequence label;
    if (resolvePackageName != null && labelRes != 0) {
        label = pm.getText(resolvePackageName, labelRes, null);
        if (label != null) {
            return label.toString().trim();
        }
    }
    ComponentInfo ci = getComponentInfo();
    ApplicationInfo ai = ci.applicationInfo;
    if (labelRes != 0) {
        label = pm.getText(ci.packageName, labelRes, ai);
        if (label != null) {
            return label.toString().trim();
        }
    }
    CharSequence data = ci.loadLabel(pm);
    // Make the data safe
    if (data != null)
        data = data.toString().trim();
    return data;
}",1,"/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
","/**
 * Retrieve the current textual label associated with this resolution.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the resolutions's label.  If the
 * item does not have a label, its name is returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the late implementation, the method call activityInfo is replaced by a call to getComponentInfo(). Therefore this code change should be categorised under class 4 and class 5.","The CI arises because the change in method call could potentially lead to a difference in the return value of loadLabel(PackageManager) method. Thus, the CI is caused due to a change in return value or type."
389,<android.net.http.HttpResponseCache: long maxSize()>,18,19,<android.net.http.HttpResponseCache: long maxSize()>,<android.net.http.HttpResponseCache: long maxSize()>,0,"{
    return delegate.getCache().maxSize();
}","{
    return delegate.getMaxSize();
}",1,"/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
","/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from delegate.getCache().maxSize() to delegate.getMaxSize() and the called methods are different in two API versions which means that the dependent API has been changed. That's why the code change type is 1,5.","The change of the return statement potentially leads to different return values. As the method called in the return statement has changed, hence, the CI type is 1."
390,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",18,19,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String,CancellationSignal)>",0,"{
    ICancellationSignal remoteCancellationSignal = null;
    if (cancellationSignal != null) {
        remoteCancellationSignal = mContentProvider.createCancellationSignal();
        cancellationSignal.setRemote(remoteCancellationSignal);
    }
    try {
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.query(mPackageName, url, projection, selection, selectionArgs, sortOrder, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The introduction of 'beforeRemote()' at the beginning and 'afterRemote()' at the very end becomes the new control dependencies, which is categorized in type 3. Additionally, a new 'throwIfCanceled()' method has been called inside the 'if (cancellationSignal != null)', which falls into the type 4 change.","The new conditional method 'throwIfCanceled()' can now cause an exception when the 'cancellationSignal' is cancelled, resulting in a different behavior, and hence the CI is type 2. Also, the method 'query()' used inside the 'try' block might potentially return different values due to the process changes caused by the newly introduced 'beforeRemote()' and 'afterRemote()', which might resume or stop the operation differently, leading to another CI which is of type 1."
391,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,18,19,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,<android.nfc.NdefRecord: NdefRecord createApplicationRecord(String)>,0,"{
    if (packageName == null)
        throw new NullPointerException(""packageName is null"");
    if (packageName.length() == 0)
        throw new IllegalArgumentException(""packageName is empty"");
    return new NdefRecord(TNF_EXTERNAL_TYPE, RTD_ANDROID_APP, null, packageName.getBytes(Charsets.UTF_8));
}","{
    if (packageName == null)
        throw new NullPointerException(""packageName is null"");
    if (packageName.length() == 0)
        throw new IllegalArgumentException(""packageName is empty"");
    return new NdefRecord(TNF_EXTERNAL_TYPE, RTD_ANDROID_APP, null, packageName.getBytes(StandardCharsets.UTF_8));
}",1,"/**
 * Create a new Android Application Record (AAR).
 * <p>
 * This record indicates to other Android devices the package
 * that should be used to handle the entire NDEF message.
 * You can embed this record anywhere into your message
 * to ensure that the intended package receives the message.
 * <p>
 * When an Android device dispatches an {@link NdefMessage}
 * containing one or more Android application records,
 * the applications contained in those records will be the
 * preferred target for the {@link NfcAdapter#ACTION_NDEF_DISCOVERED}
 * intent, in the order in which they appear in the message.
 * This dispatch behavior was first added to Android in
 * Ice Cream Sandwich.
 * <p>
 * If none of the applications have a are installed on the device,
 * a Market link will be opened to the first application.
 * <p>
 * Note that Android application records do not overrule
 * applications that have called
 * {@link NfcAdapter#enableForegroundDispatch}.
 *
 * @param packageName Android package name
 * @return Android application NDEF record
 */
","/**
 * Create a new Android Application Record (AAR).
 * <p>
 * This record indicates to other Android devices the package
 * that should be used to handle the entire NDEF message.
 * You can embed this record anywhere into your message
 * to ensure that the intended package receives the message.
 * <p>
 * When an Android device dispatches an {@link NdefMessage}
 * containing one or more Android application records,
 * the applications contained in those records will be the
 * preferred target for the {@link NfcAdapter#ACTION_NDEF_DISCOVERED}
 * intent, in the order in which they appear in the message.
 * This dispatch behavior was first added to Android in
 * Ice Cream Sandwich.
 * <p>
 * If none of the applications have a are installed on the device,
 * a Market link will be opened to the first application.
 * <p>
 * Note that Android application records do not overrule
 * applications that have called
 * {@link NfcAdapter#enableForegroundDispatch}.
 *
 * @param packageName Android package name
 * @return Android application NDEF record
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The piece of the code that has been altered is the dependant API being called by the method. The getBytes method was called by Charsets.UTF_8 in the initial version while it was replaced with StandardCharsets.UTF_8 in the updated version, thus the change type is 5.","The updated version is encoding the packageName string to UTF-8 using a new method, but it still provides the same output as the old method. Thus, there's no compatibility issue, which means CI type is 0."
392,"<android.os.Parcel: void readException(int,String)>",18,19,"<android.os.Parcel: void readException(int,String)>","<android.os.Parcel: void readException(int,String)>",0,"{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}","{
    switch(code) {
        case EX_SECURITY:
            throw new SecurityException(msg);
        case EX_BAD_PARCELABLE:
            throw new BadParcelableException(msg);
        case EX_ILLEGAL_ARGUMENT:
            throw new IllegalArgumentException(msg);
        case EX_NULL_POINTER:
            throw new NullPointerException(msg);
        case EX_ILLEGAL_STATE:
            throw new IllegalStateException(msg);
        case EX_NETWORK_MAIN_THREAD:
            throw new NetworkOnMainThreadException();
    }
    throw new RuntimeException(""Unknown exception code: "" + code + "" msg "" + msg);
}",1,"/**
 * Use this function for customized exception handling.
 * customized method call this method for all unknown case
 * @param code exception code
 * @param msg exception message
 */
","/**
 * Use this function for customized exception handling.
 * customized method call this method for all unknown case
 * @param code exception code
 * @param msg exception message
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"A new case has been added to the 'switch' statement, thus 'throws new NetworkOnMainThreadException()' was introduced, suggesting that the type of change is 2.","A new exception, 'NetworkOnMainThreadException()', is thrown, which could lead to different exception handling between the early version of the API and the late version. This indicates a compatibility issue of type 2."
393,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",18,19,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The method called on the instance 's' has changed from 'setNpnProtocols' to 'setAlpnProtocols', which can be classified as Other statement changed, so the code change type is 4.","Since the 's.setAlpnProtocols(mAlpnProtocols);' may configure the socket differently compared to 's.setNpnProtocols(mNpnProtocols);', it could possibly cause the API to return a differently configured socket. Thus, the Compatibility Issue type is 1, indicating a potential difference in return values or types."
394,<android.app.Dialog: void dismissDialog()>,18,19,<android.app.Dialog: void dismissDialog()>,<android.app.Dialog: void dismissDialog()>,0,"{
    if (mDecor == null || !mShowing) {
        return;
    }
    if (mWindow.isDestroyed()) {
        Log.e(TAG, ""Tried to dismissDialog() but the Dialog's window was already destroyed!"");
        return;
    }
    try {
        mWindowManager.removeView(mDecor);
    } finally {
        if (mActionMode != null) {
            mActionMode.finish();
        }
        mDecor = null;
        mWindow.closeAllPanels();
        onStop();
        mShowing = false;
        sendDismissMessage();
    }
}","{
    if (mDecor == null || !mShowing) {
        return;
    }
    if (mWindow.isDestroyed()) {
        Log.e(TAG, ""Tried to dismissDialog() but the Dialog's window was already destroyed!"");
        return;
    }
    try {
        mWindowManager.removeViewImmediate(mDecor);
    } finally {
        if (mActionMode != null) {
            mActionMode.finish();
        }
        mDecor = null;
        mWindow.closeAllPanels();
        onStop();
        mShowing = false;
        sendDismissMessage();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'mWindowManager.removeView(mDecor)' has changed to 'mWindowManager.removeViewImmediate(mDecor)', which brings up an Other Statement Change along with being a Dependent API change(the called API is changed), hence classifying the change as 4,5.","This change in the implementation of 'removeView' to 'removeViewImmediate' can potentially lead to a different behavior when dismissing the dialog. This is particularly true if the 'removeViewImmediate' method behaves differently than 'removeView'. Thus, we would classify this as a potential Compatibility Issue caused by different return values (1)."
398,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,18,19,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,<android.preference.PreferenceGroupAdapter: int getItemViewType(int)>,0,"{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    final Preference preference = this.getItem(position);
    if (preference.hasSpecifiedLayout()) {
        return IGNORE_ITEM_VIEW_TYPE;
    }
    mTempPreferenceLayout = createPreferenceLayout(preference, mTempPreferenceLayout);
    int viewType = Collections.binarySearch(mPreferenceLayouts, mTempPreferenceLayout);
    if (viewType < 0) {
        // don't recycle it.
        return IGNORE_ITEM_VIEW_TYPE;
    } else {
        return viewType;
    }
}","{
    if (!mHasReturnedViewTypeCount) {
        mHasReturnedViewTypeCount = true;
    }
    final Preference preference = this.getItem(position);
    if (!preference.canRecycleLayout()) {
        return IGNORE_ITEM_VIEW_TYPE;
    }
    mTempPreferenceLayout = createPreferenceLayout(preference, mTempPreferenceLayout);
    int viewType = Collections.binarySearch(mPreferenceLayouts, mTempPreferenceLayout);
    if (viewType < 0) {
        // don't recycle it.
        return IGNORE_ITEM_VIEW_TYPE;
    } else {
        return viewType;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The condition statement in the 'if' statement has changed from 'preference.hasSpecifiedLayout()' to 'preference.canRecycleLayout()' and the function that the condition relies on has also changed, so the code change type should be 1,4,5.","The change of 'if' condition will alter the execution flow in the late version, which means the program will execute different 'return' under different conditions in two versions, leading to potentially different returned values. Therefore, the CI type should be 1."
399,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,18,19,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mState == STATE_NONE) {
        return false;
    }
    final int action = me.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        if (isPointInside(me.getX(), me.getY())) {
            if (!mList.isInScrollingContainer()) {
                beginDrag();
                return true;
            }
            mInitialTouchY = me.getY();
            startPendingDrag();
        }
    } else if (action == MotionEvent.ACTION_UP) {
        // don't add ACTION_CANCEL here
        if (mPendingDrag) {
            // Allow a tap to scroll.
            beginDrag();
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            mThumbY = newThumbY;
            scrollTo((float) mThumbY / (viewHeight - mThumbH));
            cancelPendingDrag();
        // Will hit the STATE_DRAGGING check below
        }
        if (mState == STATE_DRAGGING) {
            if (mList != null) {
                // ViewGroup does the right thing already, but there might
                // be other classes that don't properly reset on touch-up,
                // so do this explicitly just in case.
                mList.requestDisallowInterceptTouchEvent(false);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
            }
            setState(STATE_VISIBLE);
            final Handler handler = mHandler;
            handler.removeCallbacks(mScrollFade);
            if (!mAlwaysShow) {
                handler.postDelayed(mScrollFade, 1000);
            }
            mList.invalidate();
            return true;
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (mPendingDrag) {
            final float y = me.getY();
            if (Math.abs(y - mInitialTouchY) > mScaledTouchSlop) {
                setState(STATE_DRAGGING);
                if (mListAdapter == null && mList != null) {
                    getSectionsFromIndexer();
                }
                if (mList != null) {
                    mList.requestDisallowInterceptTouchEvent(true);
                    mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                }
                cancelFling();
                cancelPendingDrag();
            // Will hit the STATE_DRAGGING check below
            }
        }
        if (mState == STATE_DRAGGING) {
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            if (Math.abs(mThumbY - newThumbY) < 2) {
                return true;
            }
            mThumbY = newThumbY;
            // If the previous scrollTo is still pending
            if (mScrollCompleted) {
                scrollTo((float) mThumbY / (viewHeight - mThumbH));
            }
            return true;
        }
    } else if (action == MotionEvent.ACTION_CANCEL) {
        cancelPendingDrag();
    }
    return false;
}","{
    if (!isEnabled()) {
        return false;
    }
    switch(me.getActionMasked()) {
        case MotionEvent.ACTION_UP:
            {
                if (mHasPendingDrag) {
                    // Allow a tap to scroll.
                    beginDrag();
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    scrollTo(pos);
                    cancelPendingDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    if (mList != null) {
                        // ViewGroup does the right thing already, but there might
                        // be other classes that don't properly reset on touch-up,
                        // so do this explicitly just in case.
                        mList.requestDisallowInterceptTouchEvent(false);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                    setState(STATE_VISIBLE);
                    postAutoHide();
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_MOVE:
            {
                if (mHasPendingDrag && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
                    setState(STATE_DRAGGING);
                    if (mListAdapter == null && mList != null) {
                        getSectionsFromIndexer();
                    }
                    if (mList != null) {
                        mList.requestDisallowInterceptTouchEvent(true);
                        mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    }
                    cancelFling();
                    cancelPendingDrag();
                // Will hit the STATE_DRAGGING check below
                }
                if (mState == STATE_DRAGGING) {
                    // TODO: Ignore jitter.
                    final float pos = getPosFromMotionEvent(me.getY());
                    setThumbPos(pos);
                    // If the previous scrollTo is still pending
                    if (mScrollCompleted) {
                        scrollTo(pos);
                    }
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            {
                cancelPendingDrag();
            }
            break;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early implementation of the code and the late implementation are very different. The initial condition statement has changed, multiple return statements have been introduced and deleted, and the control flow structure has also been altered. So the code change type is 1,3,4.","The method 'getPosFromMotionEvent' replaces the previous operations in computing the new scroll position, and 'postAutoHide' substitutes several statements in the previous version. So this method will potentially return different values across two versions, therefore the CI type is 1."
400,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",18,19,"<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>","<android.widget.ListPopupWindow: boolean onKeyDown(int,KeyEvent)>",0,"{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.mListSelectionHidden = false;
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.mListSelectionHidden = false;
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, ""Key down: code="" + keyCode + "" list consumed="" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,"/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
","/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The condition check in the if statement has changed from (keyCode != KeyEvent.KEYCODE_ENTER && keyCode != KeyEvent.KEYCODE_DPAD_CENTER) to !KeyEvent.isConfirmKey(keyCode). The dependent API KeyEvent.isConfirmKey is newly used to check whether the keyCode is a Confirm Key which is a different implementation as compared to the early version. This specifies a change in code implementation and usage of a different dependent API.,"The change in the condition will potentially impact the execution of the subsequent code and can lead to the method returning a different boolean value. Therefore, there exists a Compatibility Issue due to the possible different return value."
403,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,18,19,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new condition branch 'if (mUpdateListener != null)' and the corresponding statement 'mUpdateListener.onAnimationUpdate(animation)' have been introduced in the late version implementation, which categorized as 3. A new return statement 'mUpdateListener.onAnimationUpdate(animation)' has also been added at a condition, so the code change type is 1,3.","The introduction of new condition and return statement will change the execution flow of this method and potentially cause this method to return a different value (from 'mUpdateListener.onAnimationUpdate(animation)'). Hence, the Compatibility Issue type is 1."
404,<android.os.Debug: void startNativeTracing()>,18,19,<android.os.Debug: void startNativeTracing()>,<android.os.Debug: void startNativeTracing()>,0,"{
    // Open the sysfs file for writing and write ""1"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new PrintWriter(new OutputStreamWriter(fos));
        outStream.println(""1"");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
    VMDebug.startEmulatorTracing();
}","{
    // Open the sysfs file for writing and write ""1"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""1"");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
    VMDebug.startEmulatorTracing();
}",1,"/**
 * Enable qemu tracing. For this to work requires running everything inside
 * the qemu emulator; otherwise, this method will have no effect. The trace
 * file is specified on the command line when the emulator is started. For
 * example, the following command line <br />
 * <code>emulator -trace foo</code><br />
 * will start running the emulator and create a trace file named ""foo"". This
 * method simply enables writing the trace records to the trace file.
 *
 * <p>
 * The main differences between this and {@link #startMethodTracing()} are
 * that tracing in the qemu emulator traces every cpu instruction of every
 * process, including kernel code, so we have more complete information,
 * including all context switches. We can also get more detailed information
 * such as cache misses. The sequence of calls is determined by
 * post-processing the instruction trace. The qemu tracing is also done
 * without modifying the application or perturbing the timing of calls
 * because no instrumentation is added to the application being traced.
 * </p>
 *
 * <p>
 * One limitation of using this method compared to using
 * {@link #startMethodTracing()} on the real device is that the emulator
 * does not model all of the real hardware effects such as memory and
 * bus contention.  The emulator also has a simple cache model and cannot
 * capture all the complexities of a real cache.
 * </p>
 */
","/**
 * Enable qemu tracing. For this to work requires running everything inside
 * the qemu emulator; otherwise, this method will have no effect. The trace
 * file is specified on the command line when the emulator is started. For
 * example, the following command line <br />
 * <code>emulator -trace foo</code><br />
 * will start running the emulator and create a trace file named ""foo"". This
 * method simply enables writing the trace records to the trace file.
 *
 * <p>
 * The main differences between this and {@link #startMethodTracing()} are
 * that tracing in the qemu emulator traces every cpu instruction of every
 * process, including kernel code, so we have more complete information,
 * including all context switches. We can also get more detailed information
 * such as cache misses. The sequence of calls is determined by
 * post-processing the instruction trace. The qemu tracing is also done
 * without modifying the application or perturbing the timing of calls
 * because no instrumentation is added to the application being traced.
 * </p>
 *
 * <p>
 * One limitation of using this method compared to using
 * {@link #startMethodTracing()} on the real device is that the emulator
 * does not model all of the real hardware effects such as memory and
 * bus contention.  The emulator also has a simple cache model and cannot
 * capture all the complexities of a real cache.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constructor of the PrintWriter changed from PrintWriter(new OutputStreamWriter(fos)) to FastPrintWriter(fos), so the code change type is 4.","The change doesn't influence the return values or exceptions that the function could throw, so no compatibility issue exists, and the CI type is 0."
405,<android.widget.ListView: boolean fullScroll(int)>,18,19,<android.widget.ListView: boolean fullScroll(int)>,<android.widget.ListView: boolean fullScroll(int)>,0,"{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        if (mSelectedPosition != 0) {
            int position = lookForSelectablePosition(0, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_TOP;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    } else if (direction == FOCUS_DOWN) {
        if (mSelectedPosition < mItemCount - 1) {
            int position = lookForSelectablePosition(mItemCount - 1, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    }
    if (moved && !awakenScrollBars()) {
        awakenScrollBars();
        invalidate();
    }
    return moved;
}","{
    boolean moved = false;
    if (direction == FOCUS_UP) {
        if (mSelectedPosition != 0) {
            final int position = lookForSelectablePositionAfter(mSelectedPosition, 0, true);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_TOP;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    } else if (direction == FOCUS_DOWN) {
        final int lastItem = (mItemCount - 1);
        if (mSelectedPosition < lastItem) {
            final int position = lookForSelectablePositionAfter(mSelectedPosition, lastItem, false);
            if (position >= 0) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                setSelectionInt(position);
                invokeOnItemScrollListener();
            }
            moved = true;
        }
    }
    if (moved && !awakenScrollBars()) {
        awakenScrollBars();
        invalidate();
    }
    return moved;
}",1,"/**
 * Go to the last or first item if possible (not worrying about panning across or navigating
 * within the internal focus of the currently selected item.)
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */
","/**
 * Go to the last or first item if possible (not worrying about panning
 * across or navigating within the internal focus of the currently selected
 * item.)
 *
 * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 * @return whether selection was moved
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The API's implementation called method 'lookForSelectablePosition' with different parameters in the early version. In the late version, the method 'lookForSelectablePositionAfter' has been called with new different parameters. Also, a new variable 'lastItem' has been introduced. So the code change can be classified as Return statement change (1), Control dependency change (3), Other statement change (4), and Dependent API change (5).","The late version change on 'lookForSelectablePosition' to 'lookForSelectablePositionAfter' and different method parameters usage in the function potentially return different results. This leads to a different return value, which causes a compatibility issue, specifically, Compatibility Issue caused by potential different return values or types (1)."
406,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",18,19,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    warnIfCallingFromSystemProcess();
    return bindServiceAsUser(service, conn, flags, Process.myUserHandle());
}","{
    warnIfCallingFromSystemProcess();
    return bindServiceCommon(service, conn, flags, Process.myUserHandle());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API bindServiceAsUser() in the early version has been changed to bindServiceCommon() in the late version. The change is about return statement and dependent API, so the code change type is 1,5.","As the dependent API has been changed, it possibly leads to a different return statement value. Consequently, the CI type is 1."
407,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",18,19,"<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>","<android.content.ContentProviderClient: String[] getStreamTypes(Uri,String)>",0,"{
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
","/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only a new method call beforeRemote() and finally block (invoking afterRemote()) have been added to the late version API but no other statements have changed, so the class of code change is 4.","No CI exists for this API as these new statements would not cause the API to return a different value or throw a different exception, so the CI type is 0."
408,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",18,19,"<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>","<android.net.http.HttpResponseCache: HttpResponseCache install(File,long)>",0,"{
    HttpResponseCache installed = getInstalled();
    if (installed != null) {
        // don't close and reopen if an equivalent cache is already installed
        DiskLruCache installedCache = installed.delegate.getCache();
        if (installedCache.getDirectory().equals(directory) && installedCache.maxSize() == maxSize && !installedCache.isClosed()) {
            return installed;
        } else {
            IoUtils.closeQuietly(installed);
        }
    }
    HttpResponseCache result = new HttpResponseCache(directory, maxSize);
    ResponseCache.setDefault(result);
    return result;
}","{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof com.android.okhttp.HttpResponseCache) {
        com.android.okhttp.HttpResponseCache installedCache = (com.android.okhttp.HttpResponseCache) installed;
        // don't close and reopen if an equivalent cache is already installed
        if (installedCache.getDirectory().equals(directory) && installedCache.getMaxSize() == maxSize && !installedCache.isClosed()) {
            return new HttpResponseCache(installedCache);
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            installedCache.close();
        }
    }
    com.android.okhttp.HttpResponseCache responseCache = new com.android.okhttp.HttpResponseCache(directory, maxSize);
    ResponseCache.setDefault(responseCache);
    return new HttpResponseCache(responseCache);
}",1,"/**
 * Creates a new HTTP response cache and {@link ResponseCache#setDefault
 * sets it} as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
","/**
 * Creates a new HTTP response cache and {@link ResponseCache#setDefault
 * sets it} as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","In the 'return' statements and general statements, the dependent API has changed from HttpResponseCache to com.android.okhttp.HttpResponseCache, and some methods called by 'installed' and 'installedCache' also changed. The original 'IoUtils.closeQuietly(installed);' has been replaced with 'installedCache.close();'. These changes involve return statement, other statement, and dependent API, so the change type is 1,4,5.","The dependent API changes may potentially alter the returned value of the API. Moreover, the removal of 'IoUtils.closeQuietly(installed);' and introduction of 'installedCache.close();', could potentially alter the exception handling. Hence, the CI type is 1,2."
411,<android.content.pm.ResolveInfo: String toString()>,18,19,<android.content.pm.ResolveInfo: String toString()>,<android.content.pm.ResolveInfo: String toString()>,0,"{
    ComponentInfo ci = activityInfo != null ? activityInfo : serviceInfo;
    return ""ResolveInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + ci.name + "" p="" + priority + "" o="" + preferredOrder + "" m=0x"" + Integer.toHexString(match) + ""}"";
}","{
    final ComponentInfo ci = getComponentInfo();
    StringBuilder sb = new StringBuilder(128);
    sb.append(""ResolveInfo{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    ComponentName.appendShortString(sb, ci.packageName, ci.name);
    if (priority != 0) {
        sb.append("" p="");
        sb.append(priority);
    }
    if (preferredOrder != 0) {
        sb.append("" o="");
        sb.append(preferredOrder);
    }
    sb.append("" m=0x"");
    sb.append(Integer.toHexString(match));
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the toString() method has been changed for formatting the string. The use of directly returning the formatting string in the earlier version is changed to the use of StringBuilder in the late version. The change in calling getComponentInfo() instead of activityInfo or serviceInfo is also considered as a statement change. Hence the code change type is 1,4.","The introduction of conditions if (priority != 0) and if (preferredOrder != 0) can potentially change the return value of the function depending on the values of `priority` and `preferredOrder`. If any one of these values is 0, the corresponding attribute will be skipped in the return string in the late version, which is different from the early version. So, the CI type is 1."
412,<android.content.res.Configuration: int diff(Configuration)>,18,19,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition and related statement about 'deltaScreenLayoutDir' are added in the late version, so the change type is 3.","Because of the new condition and corresponding statement, the value of variable 'changed' can be different in the late version, Thus, the return statement can have a potentially different value in the late version of the API. Therefore, the CI type is 1."
413,<android.database.DatabaseUtils: int getSqlStatementType(String)>,18,19,<android.database.DatabaseUtils: int getSqlStatementType(String)>,<android.database.DatabaseUtils: int getSqlStatementType(String)>,0,"{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.US);
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}","{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);
    if (prefixSql.equals(""SEL"")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals(""INS"") || prefixSql.equals(""UPD"") || prefixSql.equals(""REP"") || prefixSql.equals(""DEL"")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals(""ATT"")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals(""COM"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""END"")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals(""ROL"")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals(""BEG"")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals(""PRA"")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals(""CRE"") || prefixSql.equals(""DRO"") || prefixSql.equals(""ALT"")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals(""ANA"") || prefixSql.equals(""DET"")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}",1,"/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
","/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method parameter of toUpperCase() has changed from Locale.US to Locale.ROOT, therefore the code change type is 1,5.","Because the method toUpperCase() is changed, it could potentially lead to different string results and thus different return values, so the CI type is 1."
414,<android.os.Environment: File getExternalStorageDirectory()>,18,19,<android.os.Environment: File getExternalStorageDirectory()>,<android.os.Environment: File getExternalStorageDirectory()>,0,"{
    throwIfUserRequired();
    return sCurrentUser.getExternalStorageDirectory();
}","{
    throwIfUserRequired();
    return sCurrentUser.getExternalDirsForApp()[0];
}",1,"/**
 * Gets the Android external storage directory.  This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened.  You can determine its current state with
 * {@link #getExternalStorageState()}.
 *
 * <p><em>Note: don't be confused by the word ""external"" here.  This
 * directory can better be thought as media/shared storage.  It is a
 * filesystem that can hold a relatively large amount of data and that
 * is shared across all applications (does not enforce permissions).
 * Traditionally this is an SD card, but it may also be implemented as
 * built-in storage in a device that is distinct from the protected
 * internal storage and can be mounted as a filesystem on a computer.</em></p>
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>In devices with multiple ""external"" storage directories (such as
 * both secure app storage and mountable shared storage), this directory
 * represents the ""primary"" external storage that the user will interact
 * with.</p>
 *
 * <p>Applications should not directly use this top-level directory, in
 * order to avoid polluting the user's root namespace.  Any files that are
 * private to the application should be placed in a directory returned
 * by {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled.  Other shared files should be placed
 * in one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.</p>
 *
 * <p>Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission. In
 * a future platform release, access to this path will require the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.</p>
 *
 * <p>This path may change between platform versions, so applications
 * should only persist relative paths.</p>
 *
 * <p>Here is an example of typical code to monitor the state of
 * external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
","/**
 * Return the primary external storage directory. This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened. You can determine its current state with
 * {@link #getExternalStorageState()}.
 * <p>
 * <em>Note: don't be confused by the word ""external"" here. This directory
 * can better be thought as media/shared storage. It is a filesystem that
 * can hold a relatively large amount of data and that is shared across all
 * applications (does not enforce permissions). Traditionally this is an SD
 * card, but it may also be implemented as built-in storage in a device that
 * is distinct from the protected internal storage and can be mounted as a
 * filesystem on a computer.</em>
 * <p>
 * On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only have
 * access to the external storage for the user they're running as.
 * <p>
 * In devices with multiple ""external"" storage directories, this directory
 * represents the ""primary"" external storage that the user will interact
 * with. Access to secondary storage is available through
 * <p>
 * Applications should not directly use this top-level directory, in order
 * to avoid polluting the user's root namespace. Any files that are private
 * to the application should be placed in a directory returned by
 * {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled. Other shared files should be placed in
 * one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.
 * <p>
 * Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission,
 * and starting in read access requires the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, if your
 * application only needs to store internal data, consider using
 * {@link Context#getExternalFilesDir(String)} or
 * {@link Context#getExternalCacheDir()}, which require no permissions to
 * read or write.
 * <p>
 * This path may change between platform versions, so applications should
 * only persist relative paths.
 * <p>
 * Here is an example of typical code to monitor the state of external
 * storage:
 * <p>
 * {@sample
 * development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called by the return statement has changed from 'getExternalStorageDirectory()' to 'getExternalDirsForApp()[0]'. Therefore, the change type is 1,5.","The change in the return statement value from calling 'getExternalStorageDirectory()' to 'getExternalDirsForApp()[0]' potentially causes the API to return a different value, so the CI type is 1."
416,"<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.ReflectionActionWithoutParams: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    Class klass = view.getClass();
    Method method;
    try {
        method = klass.getMethod(this.methodName);
    } catch (NoSuchMethodException ex) {
        throw new ActionException(""view: "" + klass.getName() + "" doesn't have method: "" + this.methodName + ""()"");
    }
    if (!method.isAnnotationPresent(RemotableViewMethod.class)) {
        throw new ActionException(""view: "" + klass.getName() + "" can't use method with RemoteViews: "" + this.methodName + ""()"");
    }
    try {
        // noinspection ConstantIfStatement
        if (false) {
            Log.d(LOG_TAG, ""view: "" + klass.getName() + "" calling method: "" + this.methodName + ""()"");
        }
        method.invoke(view);
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}","{
    final View view = root.findViewById(viewId);
    if (view == null)
        return;
    try {
        getMethod(view, this.methodName, null).invoke(view);
    } catch (ActionException e) {
        throw e;
    } catch (Exception ex) {
        throw new ActionException(ex);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","The change occurs in the implementation of the method call. The implementation has transitioned from 'getMethod' function to directly retrieving the method and invoking it. In addition, the exception handling has also changed to account for 'ActionException'. This corresponds to categories 4 (Other statement changed) and 5 (Dependent API changed).","This changes in the implementing method call could potentially return a different value. Moreover, the change in exception handling makes it possible to throw a different exception. This corresponds to categories 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handling). Thus, the CI type is 1,2."
417,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",18,19,"<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>","<android.widget.TextView: boolean onKeyDown(int,KeyEvent)>",0,"{
    int which = doKeyDown(keyCode, event, null);
    if (which == 0) {
        // Go through default dispatching.
        return super.onKeyDown(keyCode, event);
    }
    return true;
}","{
    int which = doKeyDown(keyCode, event, null);
    if (which == 0) {
        return super.onKeyDown(keyCode, event);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,No code change can be detected from the given two versions.,"Since there's no code change, no Compatibility Issue exists in this case."
418,"<android.widget.Spinner: void layout(int,boolean)>",18,19,"<android.widget.Spinner: void layout(int,boolean)>","<android.widget.Spinner: void layout(int,boolean)>",0,"{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    if (mAdapter != null) {
        View sel = makeAndAddView(mSelectedPosition);
        int width = sel.getMeasuredWidth();
        int selectedOffset = childrenLeft;
        final int layoutDirection = getLayoutDirection();
        final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
        switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
            case Gravity.CENTER_HORIZONTAL:
                selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
                break;
            case Gravity.RIGHT:
                selectedOffset = childrenLeft + childrenWidth - width;
                break;
        }
        sel.offsetLeftAndRight(selectedOffset);
    }
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}","{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    if (mAdapter != null) {
        View sel = makeView(mSelectedPosition, true);
        int width = sel.getMeasuredWidth();
        int selectedOffset = childrenLeft;
        final int layoutDirection = getLayoutDirection();
        final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
        switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
            case Gravity.CENTER_HORIZONTAL:
                selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
                break;
            case Gravity.RIGHT:
                selectedOffset = childrenLeft + childrenWidth - width;
                break;
        }
        sel.offsetLeftAndRight(selectedOffset);
    }
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}",1,"/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 means selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 means selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API for creating View has changed from makeAndAddView(mSelectedPosition) to makeView(mSelectedPosition, true). This can be classified as both non-control statement change (4) and dependent API change (5).","The change of the API used to create the View (makeAndAddView -> makeView) might potentially lead to the creation of a different View, which would eventually be returned by getSelectedView() method. So there is a Compatibility Issue of type 1 which is caused by potential different return values."
422,"<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewSizeAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final Context context = root.getContext();
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    target.setTextSize(units, size);
}","{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    target.setTextSize(units, size);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A statement (final Context context = root.getContext();) is removed in the late version of the API, but it doesn't impact return statements, exception handling statements, control dependency statements or dependent APIs, hence the change type is 4.","Even though the statement removed, it does not affects the behavior of the API, because this variable 'context' is not used in any remaining part of the code, it doesn't make the method to return a different value, nor need to handle the different exceptions. Hence, no compatibility issues exist."
423,<android.net.http.HttpResponseCache: void flush()>,18,19,<android.net.http.HttpResponseCache: void flush()>,<android.net.http.HttpResponseCache: void flush()>,0,"{
    try {
        delegate.getCache().flush();
    } catch (IOException ignored) {
    }
}","{
    try {
        delegate.flush();
    } catch (IOException ignored) {
    }
}",1,"/**
 * Force buffered operations to the filesystem. This ensures that responses
 * written to the cache will be available the next time the cache is opened,
 * even if this process is killed.
 */
","/**
 * Force buffered operations to the filesystem. This ensures that responses
 * written to the cache will be available the next time the cache is opened,
 * even if this process is killed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method invoked on `delegate` object is changed from `getCache().flush()` to `flush()`, this is considered as both a dependent API change and other statement change leading to change types 4 and 5.",The change of the method that is being used on the `delegate` object ( from `getCache()` to directly `flush()` ) could potentially cause different return values or behaviors thus contributing to the CI type 1.
424,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,18,19,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,<android.view.Surface: void unlockCanvasAndPost(Canvas)>,0,"{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        nativeUnlockCanvasAndPost(mNativeSurface, canvas);
    }
}","{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException(""canvas object must be the same instance that "" + ""was previously returned by lockCanvas"");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, ""WARNING: Surface's mNativeObject (0x"" + Integer.toHexString(mNativeObject) + "") != mLockedObject (0x"" + Integer.toHexString(mLockedObject) + "")"");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException(""Surface was not locked"");
        }
        nativeUnlockCanvasAndPost(mLockedObject, canvas);
        nativeRelease(mLockedObject);
        mLockedObject = 0;
    }
}",1,"/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
","/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","There are new conditional statements introduced and the control dependency has changed (if (mNativeObject != mLockedObject)), and new statement is introduced (nativeRelease(mLockedObject)), so the code change type is 3,4.","The new control dependency (if (mNativeObject != mLockedObject)) and introduced `throw` statement may lead to different exception handling, and these changes can potentially make the API have different return values when invoked. Therefore, the CI type is 1,2."
427,<android.widget.AbsListView: boolean shouldShowSelector()>,18,19,<android.widget.AbsListView: boolean shouldShowSelector()>,<android.widget.AbsListView: boolean shouldShowSelector()>,0,"{
    return (hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState();
}","{
    return (!isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}",1,"/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */
","/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The logic involving different method invocations in the returned expression changes from Early Implementation to Late Implementation. changes fall under ""Other statement changed"" category, thus the change type is 4.","The changed logic in the return expression may cause the method to potentially return a different boolean value, so the Compatibility Issue type is 1."
428,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,18,19,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,<android.view.GLES20RenderLayer: HardwareCanvas start(Canvas)>,0,"{
    if (currentCanvas instanceof GLES20Canvas) {
        ((GLES20Canvas) currentCanvas).interrupt();
    }
    HardwareCanvas canvas = getCanvas();
    canvas.setViewport(mWidth, mHeight);
    canvas.onPreDraw(null);
    return canvas;
}","{
    return start(currentCanvas, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the method changed similarily to a refactoring, where multiple code lines in the original version are replaced by a single call of another method. This leads to a change type of 1 (return statement changed) and 5 (dependent API changed).","The original implementation had several operations (interrupt, setting of viewport, call to onPreDraw) on the canvas before it was returned, but this new implementation calls another method which might not conduct the same operations. This inevitably can result in different return values of the function, leading to a compatibility issue of type 1 (potential different return values)."
430,<android.app.ContextImpl: File getObbDir()>,18,19,<android.app.ContextImpl: File getObbDir()>,<android.app.ContextImpl: File getObbDir()>,0,"{
    synchronized (mSync) {
        if (mObbDir == null) {
            mObbDir = Environment.getExternalStorageAppObbDirectory(getPackageName());
        }
        return mObbDir;
    }
}","{
    // Operates on primary external storage
    return getObbDirs()[0];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The whole code block has been replaced in the late version and a new return statement ""return getObbDirs()[0]"" is introduced, so the change type is 1,4.","The return statement in the late version is new and changed. As per the new implementation, it would return a different value. Therefore, the API could potentially return different values and the CI type is 1."
431,<android.view.TextureView: Canvas lockCanvas(Rect)>,18,19,<android.view.TextureView: Canvas lockCanvas(Rect)>,<android.view.TextureView: Canvas lockCanvas(Rect)>,0,"{
    if (!isAvailable())
        return null;
    if (mCanvas == null) {
        mCanvas = new Canvas();
    }
    synchronized (mNativeWindowLock) {
        nLockCanvas(mNativeWindow, mCanvas, dirty);
    }
    mSaveCount = mCanvas.save();
    return mCanvas;
}","{
    if (!isAvailable())
        return null;
    if (mCanvas == null) {
        mCanvas = new Canvas();
    }
    synchronized (mNativeWindowLock) {
        if (!nLockCanvas(mNativeWindow, mCanvas, dirty)) {
            return null;
        }
    }
    mSaveCount = mCanvas.save();
    return mCanvas;
}",1,"/**
 * Just like {@link #lockCanvas()} but allows specification of a dirty
 * rectangle. Every pixel within that rectangle must be written; however
 * pixels outside the dirty rectangle will be preserved by the next call
 * to lockCanvas().
 *
 * @param dirty Area of the surface that will be modified.
 *
 * @return A Canvas used to draw into the surface.
 *
 * @see #lockCanvas()
 * @see #unlockCanvasAndPost(android.graphics.Canvas)
 */
","/**
 * Just like {@link #lockCanvas()} but allows specification of a dirty
 * rectangle. Every pixel within that rectangle must be written; however
 * pixels outside the dirty rectangle will be preserved by the next call
 * to lockCanvas().
 *
 * This method can return null if the underlying surface texture is not
 * available (see {@link #isAvailable()} or if the surface texture is
 * already connected to an image producer (for instance: the camera,
 * OpenGL, a media player, etc.)
 *
 * @param dirty Area of the surface that will be modified.
 *
 * @return A Canvas used to draw into the surface.
 *
 * @see #lockCanvas()
 * @see #unlockCanvasAndPost(android.graphics.Canvas)
 * @see #isAvailable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the new implementation, an 'if' control dependency and a 'return' statement have been added in the synchronized block. Thus, the types of code changes are 'Return statement changed' (1) and 'Control dependency changed' (3).","With the newly introduced 'return' statement, it's possible that the method will return earlier with a 'null' when 'nLockCanvas' returns false. This could lead to the method potentially returning different values between the two versions. Hence, a compatibility issue caused by potential different return values exists (Type 1)."
434,<android.content.pm.PackageParser.Activity: String toString()>,18,19,<android.content.pm.PackageParser.Activity: String toString()>,<android.content.pm.PackageParser.Activity: String toString()>,0,"{
    return ""Activity{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""Activity{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way to construct return value is changed from direct string concantenation to using StringBuilder in the late version, hence the code change type is 4.","This change does not cause Compatibility Issues since both implementations are returning the same constructed string as output, thus the CI type is 0."
436,<android.bluetooth.BluetoothGatt: void abortReliableWrite(BluetoothDevice)>,18,19,<android.bluetooth.BluetoothGatt: void abortReliableWrite(BluetoothDevice)>,<android.bluetooth.BluetoothGatt: void abortReliableWrite(BluetoothDevice)>,0,"{
    if (DBG)
        Log.d(TAG, ""abortReliableWrite() - device: "" + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), false);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
}","{
    abortReliableWrite();
}",1,"/**
 * Cancels a reliable write transaction for a given device.
 *
 * <p>Calling this function will discard all queued characteristic write
 * operations for a given remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 */
","/**
 * @deprecated Use {@link #abortReliableWrite()}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The change is that internal code functionality is shifted to a single line by calling abortReliableWrite(), which changes the return statement. Therefore, it is both type 1 and type 5 change.",The overall functionality has changed as it shifted to make use of abortReliableWrite(). This could result in a return of different values which aligns with the type 1 change.
437,"<android.text.method.NumberKeyListener: int lookup(KeyEvent,Spannable)>",18,19,"<android.text.method.NumberKeyListener: int lookup(KeyEvent,Spannable)>","<android.text.method.NumberKeyListener: int lookup(KeyEvent,Spannable)>",0,"{
    return event.getMatch(getAcceptedChars(), event.getMetaState() | getMetaState(content));
}","{
    return event.getMatch(getAcceptedChars(), getMetaState(content, event));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,The second parameter passed to the 'event.getMatch()' method has changed. So the code change type is 5 (Dependent API changed).,"The result of the 'getMatch()' method may vary according to the changed parameter in the later version, thus it implies that the API returns a different variable value. Therefore, the type of CI is 1 (Compatibility Issue caused by potential different return values or types)."
438,"<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>",18,19,"<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>","<android.widget.RelativeLayout.DependencyGraph: void getSortedViews(View[],int)>",0,"{
    final ArrayDeque<Node> roots = findRoots(rules);
    int index = 0;
    Node node;
    while ((node = roots.pollLast()) != null) {
        final View view = node.view;
        final int key = view.getId();
        sorted[index++] = view;
        final HashMap<Node, DependencyGraph> dependents = node.dependents;
        for (Node dependent : dependents.keySet()) {
            final SparseArray<Node> dependencies = dependent.dependencies;
            dependencies.remove(key);
            if (dependencies.size() == 0) {
                roots.add(dependent);
            }
        }
    }
    if (index < sorted.length) {
        throw new IllegalStateException(""Circular dependencies cannot exist"" + "" in RelativeLayout"");
    }
}","{
    final ArrayDeque<Node> roots = findRoots(rules);
    int index = 0;
    Node node;
    while ((node = roots.pollLast()) != null) {
        final View view = node.view;
        final int key = view.getId();
        sorted[index++] = view;
        final ArrayMap<Node, DependencyGraph> dependents = node.dependents;
        final int count = dependents.size();
        for (int i = 0; i < count; i++) {
            final Node dependent = dependents.keyAt(i);
            final SparseArray<Node> dependencies = dependent.dependencies;
            dependencies.remove(key);
            if (dependencies.size() == 0) {
                roots.add(dependent);
            }
        }
    }
    if (index < sorted.length) {
        throw new IllegalStateException(""Circular dependencies cannot exist"" + "" in RelativeLayout"");
    }
}",1,"/**
 * Builds a sorted list of views. The sorting order depends on the dependencies
 * between the view. For instance, if view C needs view A to be processed first
 * and view A needs view B to be processed first, the dependency graph
 * is: B -> A -> C. The sorted array will contain views B, A and C in this order.
 *
 * @param sorted The sorted list of views. The length of this array must
 * be equal to getChildCount().
 * @param rules The list of rules to take into account.
 */
","/**
 * Builds a sorted list of views. The sorting order depends on the dependencies
 * between the view. For instance, if view C needs view A to be processed first
 * and view A needs view B to be processed first, the dependency graph
 * is: B -> A -> C. The sorted array will contain views B, A and C in this order.
 *
 * @param sorted The sorted list of views. The length of this array must
 * be equal to getChildCount().
 * @param rules The list of rules to take into account.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",2,"The iteration process of node-dependents has been transformed from 'for-each' loop into a 'for' loop, certainly because of the change in the type of 'node.dependents' from HashMap to ArrayMap. Thus, the code change types are 4,5.","The implementation modification itself doesn't incur a change in the exception being thrown nor in the value returned by the method. However, being the ArrayMap and HashMap implementations quite different in their internal handling logic, this could potentially cause a difference in the exception handling process, therefore, it's safer to classify this change as the CI type is 2."
439,<android.app.ContextImpl: Context createDisplayContext(Display)>,18,19,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    int displayId = display.getDisplayId();
    CompatibilityInfo ci = CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;
    CompatibilityInfoHolder cih = getCompatibilityInfo(displayId);
    if (cih != null) {
        ci = cih.get();
    }
    ContextImpl context = new ContextImpl();
    context.init(mPackageInfo, null, mMainThread);
    context.mDisplay = display;
    context.mResources = mMainThread.getTopLevelResources(mPackageInfo.getResDir(), displayId, null, ci);
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    int displayId = display.getDisplayId();
    ContextImpl context = new ContextImpl();
    context.init(mPackageInfo, null, mMainThread);
    context.mDisplay = display;
    DisplayAdjustments daj = getDisplayAdjustments(displayId);
    context.mResources = mResourcesManager.getTopLevelResources(mPackageInfo.getResDir(), displayId, null, daj.getCompatibilityInfo(), null);
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The change is characterized by the actual variable assignments and function's internal dependent API calls. This includes changes made to CompatibilityInfo, CompatibilityInfoHolder, DisplayAdjustments, and ResourcesManager. The return statement construct of ContextImpl is also changed, so the code change type is 1,4,5.","The change on the instantiation of ContextImpl could potentially impact the value returned by the function, causing it to return a different object of type ContextImpl between versions. Therefore, the compatibility issue type is 1."
440,<android.os.Debug: void stopNativeTracing()>,18,19,<android.os.Debug: void stopNativeTracing()>,<android.os.Debug: void stopNativeTracing()>,0,"{
    VMDebug.stopEmulatorTracing();
    // Open the sysfs file for writing and write ""0"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new PrintWriter(new OutputStreamWriter(fos));
        outStream.println(""0"");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}","{
    VMDebug.stopEmulatorTracing();
    // Open the sysfs file for writing and write ""0"" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println(""0"");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}",1,"/**
 * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.
 *
 * <p>Tracing can be started and stopped as many times as desired.  When
 * the qemu emulator itself is stopped then the buffered trace records
 * are flushed and written to the trace file.  In fact, it is not necessary
 * to call this method at all; simply killing qemu is sufficient.  But
 * starting and stopping a trace is useful for examining a specific
 * region of code.</p>
 */
","/**
 * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.
 *
 * <p>Tracing can be started and stopped as many times as desired.  When
 * the qemu emulator itself is stopped then the buffered trace records
 * are flushed and written to the trace file.  In fact, it is not necessary
 * to call this method at all; simply killing qemu is sufficient.  But
 * starting and stopping a trace is useful for examining a specific
 * region of code.</p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The change is around the instantiation of 'outStream'. Instead of using `PrintWriter`, `FastPrintWriter` is used in the late version. Hence, the Change Type would be 4 (Other statement change) and 5 (Dependent API change).","Although there is a change in instantiation, it wouldn't alter the functional behavior of the API nor produce different returns or throw different exceptions, as both PrintWriter and FastPrintWriter have the same behavior and both are used to print formatted data. Thus, there is no compatibility issue. So the CI is 0 (No Compatibility Issue exist)."
441,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",18,19,"<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>","<android.content.ContentProviderClient: int bulkInsert(Uri,ContentValues[])>",0,"{
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
","/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new method call `beforeRemote()` is added at the beginning of the implementation, and a final clause with a method call `afterRemote()` is added after the try-catch block in the later version. Hence, the code change type belongs to 4 (Other statement changed).","Although there are method calls added, these changes do not alter the return types, values, or potential exceptions being thrown, nor change the control dependencies, or the dependent APIs. Thus, there is no Compatibility Issue (CI) present."
442,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,18,19,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,0,"{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyAccessibilityStateChanged();
    }
}","{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
}",1,"/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method called in the last 'if' statement has changed from notifyAccessibilityStateChanged() to notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED). Therefore, the code change type is 4.","The return type of both methods is void, and they only affect the internal state of the object. Hence, they don't cause the API to return a different value or throw a different exception. As a result, there is no CI."
443,<android.app.ContextImpl: File getCacheDir()>,18,19,<android.app.ContextImpl: File getCacheDir()>,<android.app.ContextImpl: File getCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        if (!mCacheDir.exists()) {
            if (!mCacheDir.mkdirs()) {
                Log.w(TAG, ""Unable to create cache directory "" + mCacheDir.getAbsolutePath());
                return null;
            }
            FileUtils.setPermissions(mCacheDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    }
    return mCacheDir;
}","{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        if (!mCacheDir.exists()) {
            if (!mCacheDir.mkdirs()) {
                if (mCacheDir.exists()) {
                    // spurious failure; probably racing with another process for this app
                    return mCacheDir;
                }
                Log.w(TAG, ""Unable to create cache directory "" + mCacheDir.getAbsolutePath());
                return null;
            }
            FileUtils.setPermissions(mCacheDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    }
    return mCacheDir;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new condition statement was added to check if the mCacheDir exists and return mCacheDir if it does. Also, a new return statement was added inside the condition. Thus, the change types are 1 and 3.","The addition of a new return statement in the if condition could cause the method to return different results when mCacheDir.exists() is true, leading to a compatibility issue of type 1."
444,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>",18,19,"<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>","<android.content.ContentProviderClient: Cursor query(Uri,String[],String,String[],String)>",0,"{
    try {
        return query(url, projection, selection, selectionArgs, sortOrder, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    return query(url, projection, selection, selectionArgs, sortOrder, null);
}",1,"/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
","/**
 * See {@link ContentProvider#query ContentProvider.query}
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,The exception handling statement from the early version has been removed in the late version which is a change type of 2.,"Since the exception handling statement was deleted, the API will no longer throw the exception in the late version when a DeadObjectException occurs. This could lead to a different behavior of the API, thus the CI type is 2."
445,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",18,19,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null)
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    if (!KeyEvent.isModifierKey(keyCode)) {
        mPreventDefaultMovement = false;
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (!hasOnClickListeners()) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null && getShowSoftInputOnFocus()) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (event.hasNoModifiers()) {
                if (mEditor != null && mEditor.mInputContentType != null && mEditor.mInputContentType.onEditorActionListener != null && mEditor.mInputContentType.enterDown) {
                    mEditor.mInputContentType.enterDown = false;
                    if (mEditor.mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (!hasOnClickListeners()) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mEditor != null && mEditor.mKeyListener != null)
        if (mEditor.mKeyListener.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new line (mPreventDefaultMovement = false;) is introduced in the later version while the rest of the lines remained the same. This indicates that 'other statements' were changed, hence the code change type is 4.","The new line (mPreventDefaultMovement = false;) indicates a change in the behavior of the View after the key goes up. This might potentially affect the return value of onKeyUp() method in certain scenarios. So, the CI type is 1."
446,<android.app.ContextImpl: File getExternalCacheDir()>,18,19,<android.app.ContextImpl: File getExternalCacheDir()>,<android.app.ContextImpl: File getExternalCacheDir()>,0,"{
    synchronized (mSync) {
        if (mExternalCacheDir == null) {
            mExternalCacheDir = Environment.getExternalStorageAppCacheDirectory(getPackageName());
        }
        if (!mExternalCacheDir.exists()) {
            try {
                (new File(Environment.getExternalStorageAndroidDataDir(), "".nomedia"")).createNewFile();
            } catch (IOException e) {
            }
            if (!mExternalCacheDir.mkdirs()) {
                Log.w(TAG, ""Unable to create external cache directory"");
                return null;
            }
        }
        return mExternalCacheDir;
    }
}","{
    // Operates on primary external storage
    return getExternalCacheDirs()[0];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method of obtaining the external cache directory has been completely replaced, including the return statement. Therefore, the code change type is 1,4,5.","The method for obtaining the external cache directory has been completely changed, which means the return value may be different. Therefore, the CI type is 1."
448,"<android.text.method.MetaKeyKeyListener: int getMetaState(CharSequence,int)>",18,19,"<android.text.method.MetaKeyKeyListener: int getMetaState(CharSequence,int)>","<android.text.method.MetaKeyKeyListener: int getMetaState(CharSequence,int)>",0,"{
    switch(meta) {
        case META_SHIFT_ON:
            return getActive(text, CAP, 1, 2);
        case META_ALT_ON:
            return getActive(text, ALT, 1, 2);
        case META_SYM_ON:
            return getActive(text, SYM, 1, 2);
        case META_SELECTING:
            return getActive(text, SELECTING, 1, 2);
        default:
            return 0;
    }
}","{
    switch(meta) {
        case META_SHIFT_ON:
            return getActive(text, CAP, PRESSED_RETURN_VALUE, LOCKED_RETURN_VALUE);
        case META_ALT_ON:
            return getActive(text, ALT, PRESSED_RETURN_VALUE, LOCKED_RETURN_VALUE);
        case META_SYM_ON:
            return getActive(text, SYM, PRESSED_RETURN_VALUE, LOCKED_RETURN_VALUE);
        case META_SELECTING:
            return getActive(text, SELECTING, PRESSED_RETURN_VALUE, LOCKED_RETURN_VALUE);
        default:
            return 0;
    }
}",1,"/**
 * Gets the state of a particular meta key.
 *
 * @param meta META_SHIFT_ON, META_ALT_ON, META_SYM_ON, or META_SELECTING
 * @param text the buffer in which the meta key would have been pressed.
 *
 * @return 0 if inactive, 1 if active, 2 if locked.
 */
","/**
 * Gets the state of a particular meta key.
 *
 * @param meta META_SHIFT_ON, META_ALT_ON, META_SYM_ON
 * @param text the buffer in which the meta key would have been pressed.
 *
 * @return 0 if inactive, 1 if active, 2 if locked.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements, which are calling the 'getActive' method, have changed. Specifically, the last two parameters for 'getActive' method in early version code were 1,2. Instead, the new parameters are represented with the symbols (PRESSED_RETURN_VALUE, LOCKED_RETURN_VALUE) in the late version code, which is linkage to the dependent APIs change. So the code change type is 1,5.","The 'getActive' method may return different values due to the parameter changes, so the CI type is 1."
449,"<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>",18,19,"<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>","<android.content.ContentResolver: void addPeriodicSync(Account,String,Bundle,long)>",0,"{
    validateSyncExtrasBundle(extras);
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    if (extras.getBoolean(SYNC_EXTRAS_MANUAL, false) || extras.getBoolean(SYNC_EXTRAS_DO_NOT_RETRY, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_BACKOFF, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_SETTINGS, false) || extras.getBoolean(SYNC_EXTRAS_INITIALIZE, false) || extras.getBoolean(SYNC_EXTRAS_FORCE, false) || extras.getBoolean(SYNC_EXTRAS_EXPEDITED, false)) {
        throw new IllegalArgumentException(""illegal extras were set"");
    }
    try {
        getContentService().addPeriodicSync(account, authority, extras, pollFrequency);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}","{
    validateSyncExtrasBundle(extras);
    if (extras.getBoolean(SYNC_EXTRAS_MANUAL, false) || extras.getBoolean(SYNC_EXTRAS_DO_NOT_RETRY, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_BACKOFF, false) || extras.getBoolean(SYNC_EXTRAS_IGNORE_SETTINGS, false) || extras.getBoolean(SYNC_EXTRAS_INITIALIZE, false) || extras.getBoolean(SYNC_EXTRAS_FORCE, false) || extras.getBoolean(SYNC_EXTRAS_EXPEDITED, false)) {
        throw new IllegalArgumentException(""illegal extras were set"");
    }
    try {
        getContentService().addPeriodicSync(account, authority, extras, pollFrequency);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}",1,"/**
 * Specifies that a sync should be requested with the specified the account, authority,
 * and extras at the given frequency. If there is already another periodic sync scheduled
 * with the account, authority and extras then a new periodic sync won't be added, instead
 * the frequency of the previous one will be updated.
 * <p>
 * These periodic syncs honor the ""syncAutomatically"" and ""masterSyncAutomatically"" settings.
 * Although these sync are scheduled at the specified frequency, it may take longer for it to
 * actually be started if other syncs are ahead of it in the sync operation queue. This means
 * that the actual start time may drift.
 * <p>
 * Periodic syncs are not allowed to have any of {@link #SYNC_EXTRAS_DO_NOT_RETRY},
 * {@link #SYNC_EXTRAS_IGNORE_BACKOFF}, {@link #SYNC_EXTRAS_IGNORE_SETTINGS},
 * {@link #SYNC_EXTRAS_INITIALIZE}, {@link #SYNC_EXTRAS_FORCE},
 * {@link #SYNC_EXTRAS_EXPEDITED}, {@link #SYNC_EXTRAS_MANUAL} set to true.
 * If any are supplied then an {@link IllegalArgumentException} will be thrown.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account to specify in the sync
 * @param authority the provider to specify in the sync request
 * @param extras extra parameters to go along with the sync request
 * @param pollFrequency how frequently the sync should be performed, in seconds.
 * @throws IllegalArgumentException if an illegal extra was set or if any of the parameters
 * are null.
 */
","/**
 * Specifies that a sync should be requested with the specified the account, authority,
 * and extras at the given frequency. If there is already another periodic sync scheduled
 * with the account, authority and extras then a new periodic sync won't be added, instead
 * the frequency of the previous one will be updated.
 * <p>
 * These periodic syncs honor the ""syncAutomatically"" and ""masterSyncAutomatically"" settings.
 * Although these sync are scheduled at the specified frequency, it may take longer for it to
 * actually be started if other syncs are ahead of it in the sync operation queue. This means
 * that the actual start time may drift.
 * <p>
 * Periodic syncs are not allowed to have any of {@link #SYNC_EXTRAS_DO_NOT_RETRY},
 * {@link #SYNC_EXTRAS_IGNORE_BACKOFF}, {@link #SYNC_EXTRAS_IGNORE_SETTINGS},
 * {@link #SYNC_EXTRAS_INITIALIZE}, {@link #SYNC_EXTRAS_FORCE},
 * {@link #SYNC_EXTRAS_EXPEDITED}, {@link #SYNC_EXTRAS_MANUAL} set to true.
 * If any are supplied then an {@link IllegalArgumentException} will be thrown.
 * <p>As of API level 19 this function introduces a default flexibility of ~4% (up to a maximum
 * of one hour in the day) into the requested period. Use
 * {@link SyncRequest.Builder#syncPeriodic(long, long)} to set this flexibility manually.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account to specify in the sync
 * @param authority the provider to specify in the sync request
 * @param extras extra parameters to go along with the sync request
 * @param pollFrequency how frequently the sync should be performed, in seconds.
 * @throws IllegalArgumentException if an illegal extra was set or if any of the parameters
 * are null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,2,"The condition statements 'if (account == null)' and 'if (authority == null)' that throw IllegalArgumentExceptions when conditions are met have been removed, so the code change type is 3.","The removal of the condition and the corresponding exceptions potentially causes the API to handle the exceptions differently between the two versions when 'account' or 'authority' is null, hence, the CI is of type 2."
450,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>",18,19,"<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>","<android.text.util.Linkify: boolean addLinks(Spannable,Pattern,String,MatchFilter,TransformFilter)>",0,"{
    boolean hasMatches = false;
    String prefix = (scheme == null) ? """" : scheme.toLowerCase();
    Matcher m = p.matcher(s);
    while (m.find()) {
        int start = m.start();
        int end = m.end();
        boolean allowed = true;
        if (matchFilter != null) {
            allowed = matchFilter.acceptMatch(s, start, end);
        }
        if (allowed) {
            String url = makeUrl(m.group(0), new String[] { prefix }, m, transformFilter);
            applyLink(url, start, end, s);
            hasMatches = true;
        }
    }
    return hasMatches;
}","{
    boolean hasMatches = false;
    String prefix = (scheme == null) ? """" : scheme.toLowerCase(Locale.ROOT);
    Matcher m = p.matcher(s);
    while (m.find()) {
        int start = m.start();
        int end = m.end();
        boolean allowed = true;
        if (matchFilter != null) {
            allowed = matchFilter.acceptMatch(s, start, end);
        }
        if (allowed) {
            String url = makeUrl(m.group(0), new String[] { prefix }, m, transformFilter);
            applyLink(url, start, end, s);
            hasMatches = true;
        }
    }
    return hasMatches;
}",1,"/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param s            Spannable whose text is to be marked-up with
 * links
 * @param p            Regex pattern to be used for finding links
 * @param scheme       Url scheme string (eg <code>http://</code> to be
 * prepended to the url of links that do not have
 * a scheme specified in the link text
 * @param matchFilter  The filter that is used to allow the client code
 * additional control over which pattern matches are
 * to be converted into links.
 */
","/**
 * Applies a regex to a Spannable turning the matches into
 * links.
 *
 * @param s            Spannable whose text is to be marked-up with
 * links
 * @param p            Regex pattern to be used for finding links
 * @param scheme       Url scheme string (eg <code>http://</code> to be
 * prepended to the url of links that do not have
 * a scheme specified in the link text
 * @param matchFilter  The filter that is used to allow the client code
 * additional control over which pattern matches are
 * to be converted into links.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The code toLower() method is changed to toLowerCase(Locale.ROOT) in late version. Locale.ROOT is a constant that used when we need to make our code Locale independent.,#CI_description
452,"<android.util.LongSparseArray: E get(long,E)>",18,19,"<android.util.LongSparseArray: E get(long,E)>","<android.util.LongSparseArray: E get(long,E)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i < 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i < 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
    }
}",1,"/**
 * Gets the Object mapped from the specified key, or the specified Object
 * if no such mapping has been made.
 */
","/**
 * Gets the Object mapped from the specified key, or the specified Object
 * if no such mapping has been made.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,5,0,"The dependent function of the binarySearch method is changed from mKeys to ContainerHelpers, so the code change type is 5.","The dependent function change does not alter the return value or the exception it throws, therefore, there is no compatibility issue, so CI type is 0."
454,"<android.app.NotificationManager: void notify(String,int,Notification)>",18,19,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getBasePackageName(), tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed(""Notification.sound"");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The function call in the line `service.enqueueNotificationWithTag` has changed the parameter from `mContext.getBasePackageName()` to `mContext.getOpPackageName()`. Hence, the change type is 4,5.","This change in the function call parameter potentially changes the behavior of the function, which could cause the API to return a different value in the new version. Hence, the CI type is 1."
455,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,18,19,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup(FileDescriptor)>,0,"{
    FileDescriptor fd = Parcel.dupFileDescriptor(orig);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    try {
        final FileDescriptor fd = Libcore.os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
","/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,5","1,2","In the late version, the invoked dependency API changes from Parcel.dupFileDescriptor(orig) to Libcore.os.dup(orig). The return statement also changed from checking conditions based on the resulting file descriptor to always return a new instance of ParcelFileDescriptor. In addition, It added a try-catch structure to handle possible exceptions, so the change type is 1,2,5.","The change in method invoked to duplicate a file descriptor and the introduction of exception handling can potentially alter the behaviour of the API, and the different return statement can result in different values. This, thus, leads to Compatibility Issues, specifically the types 1 and 2."
456,"<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>",18,19,"<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>","<android.content.ContentResolver: void removePeriodicSync(Account,String,Bundle)>",0,"{
    validateSyncExtrasBundle(extras);
    if (account == null) {
        throw new IllegalArgumentException(""account must not be null"");
    }
    if (authority == null) {
        throw new IllegalArgumentException(""authority must not be null"");
    }
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}","{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw new RuntimeException(""the ContentService should always be reachable"", e);
    }
}",1,"/**
 * Remove a periodic sync. Has no affect if account, authority and extras don't match
 * an existing periodic sync.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account of the periodic sync to remove
 * @param authority the provider of the periodic sync to remove
 * @param extras the extras of the periodic sync to remove
 */
","/**
 * Remove a periodic sync. Has no affect if account, authority and extras don't match
 * an existing periodic sync.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account of the periodic sync to remove
 * @param authority the provider of the periodic sync to remove
 * @param extras the extras of the periodic sync to remove
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The validation checks for the 'account' and 'authority' variables, which included throwing exceptions, were removed in the Late version, resulting in a 3rd code change type, and a type 4 change as two exception throwing statements are removed. ","The removal of validation and associated exceptions potentially alters the behaviour of the API, causing it to handle invalid 'account' and 'authority' inputs differently. As a result, clients using these APIs after the update may encounter unexpected runtime errors. Hence, this is a type 2 Compatibility issue."
457,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",18,19,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>","<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",0,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity, mParent);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new PrintWriter(logw);
                bse.dump(""  "", pw, false);
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity, mParent);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new FastPrintWriter(logw, false, 1024);
                bse.dump(""  "", pw, false);
                pw.flush();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The creation of the PrintWriter instance has been changed, where the constructor of FastPrintWriter() is used instead of PrintWriter(), so the code change type is 4.","This change doesn't involve any potential modifications to the return statement or exception handling of the method, and hence there is no compatibility issue according to the definitions."
458,<android.widget.AbsListView: InputConnection onCreateInputConnection(EditorInfo)>,18,19,<android.widget.AbsListView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.AbsListView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (isTextFilterEnabled()) {
        // XXX we need to have the text filter created, so we can get an
        // InputConnection to proxy to.  Unfortunately this means we pretty
        // much need to make it as soon as a list view gets focus.
        createTextFilter(false);
        if (mPublicInputConnection == null) {
            mDefInputConnection = new BaseInputConnection(this, false);
            mPublicInputConnection = new InputConnectionWrapper(mTextFilter.onCreateInputConnection(outAttrs), true) {

                @Override
                public boolean reportFullscreenMode(boolean enabled) {
                    // the ""real"" one the IME is talking with.
                    return mDefInputConnection.reportFullscreenMode(enabled);
                }

                @Override
                public boolean performEditorAction(int editorAction) {
                    // the one that does this.
                    if (editorAction == EditorInfo.IME_ACTION_DONE) {
                        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                        if (imm != null) {
                            imm.hideSoftInputFromWindow(getWindowToken(), 0);
                        }
                        return true;
                    }
                    return false;
                }

                @Override
                public boolean sendKeyEvent(KeyEvent event) {
                    // no ViewAncestor to dispatch events with.
                    return mDefInputConnection.sendKeyEvent(event);
                }
            };
        }
        outAttrs.inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_FILTER;
        outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE;
        return mPublicInputConnection;
    }
    return null;
}","{
    if (isTextFilterEnabled()) {
        if (mPublicInputConnection == null) {
            mDefInputConnection = new BaseInputConnection(this, false);
            mPublicInputConnection = new InputConnectionWrapper(outAttrs);
        }
        outAttrs.inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_FILTER;
        outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE;
        return mPublicInputConnection;
    }
    return null;
}",1,"/**
 * Return an InputConnection for editing of the filter text.
 */
","/**
 * Return an InputConnection for editing of the filter text.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Several statements involving the creation of mPublicInputConnection gets removed and the method InputConnectionWrapper gets simplified, leading to both control dependency change and other statements change, and hence, the code change classification is 3,4.","The logic change in constructing mPublicInputConnection and InputConnectionWrapper could lead to return a different instance of InputConnection, which contributes to a Compatibility Issue, and hence, the CI type is 1."
459,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",18,19,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>","<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",0,"{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.append(' ' + address.getHostAddress() + '/' + prefixLength);
    return this;
}","{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.add(new LinkAddress(address, prefixLength));
    return this;
}",1,"/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
","/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The return statement remains same but the implementation of 'mAddresses' has now changed from 'append' method to 'add' method. Also, the parameter for these two implementations is different, giving us code change types of 1,4,5.","This change in 'mAddresses' assignment could lead to different return values and exceptions, hence the CI type is 1,2."
460,<android.os.Bundle: void unparcel()>,18,19,<android.os.Bundle: void unparcel()>,<android.os.Bundle: void unparcel()>,0,"{
    if (mParcelledData == null) {
        return;
    }
    int N = mParcelledData.readInt();
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new HashMap<String, Object>(N);
    }
    mParcelledData.readMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}","{
    if (mParcelledData == null) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
        return;
    }
    int N = mParcelledData.readInt();
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new ArrayMap<String, Object>(N);
    } else {
        mMap.erase();
        mMap.ensureCapacity(N);
    }
    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"First, there are a few additional debug-related statements in the late-version, such as ""Log.d"" statements. Second, the ""if"" condition check and the body under the check are the same in both versions, but extra steps have been added in the late-version, which leads to control dependency change. Third, the initialization mechanism of the ""mMap"" variable (from HashMap to ArrayMap) and the method used to read from ""mParcelledData"" (from readMapInternal to readArrayMapInternal) has been changed, which indicates an dependent API change. Therefore, the change types are 1,3,4,5.","The different initialization of ""mMap"" variable and the different method to read from ""mParcelledData"" may potentially lead to different return behavior, therefore, the CI type is 1."
461,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(LOG_TAG, ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (target != null && fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(LOG_TAG, ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(LOG_TAG, ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(LOG_TAG, ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(LOG_TAG, ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(LOG_TAG, ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final Rect rect = getSourceBounds(v);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"In the late version, 'final Rect rect = getSourceBounds(v);' has been introduced replacing the block which was computing 'rect' based on 'v'. It must be using the method 'getSourceBounds()' which is a dependent API. Thus it represents code change type 5.","The change made here can potentially give different results than intended earlier as a different calculation method for 'rect' is being used in the late version. If the method 'getSourceBounds(v)' does not provide the same output as the previous calculations, it can impact the return values or types of this API which can cause a compatibility issue of type 1."
462,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",18,19,"<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(addr, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p class=""caution""><b>Warning:</b> Hostname verification is not performed
 * with this method.  You MUST verify the server's identity after connecting
 * the socket to avoid man-in-the-middle attacks.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The statement s.setNpnProtocols(mNpnProtocols); has been replaced with s.setAlpnProtocols(mAlpnProtocols); and the parameter type of setAlpnProtocols() also changed, so the code change type is 1,5.","The change of the statement will make the API potentially return a different value, so the CI type is 1."
463,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",18,19,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>","<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",0,"{
    SharedPreferencesImpl sp;
    synchronized (sSharedPrefs) {
        sp = sSharedPrefs.get(name);
        if (sp == null) {
            File prefsFile = getSharedPrefsFile(name);
            sp = new SharedPreferencesImpl(prefsFile, mode);
            sSharedPrefs.put(name, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}","{
    SharedPreferencesImpl sp;
    synchronized (ContextImpl.class) {
        if (sSharedPrefs == null) {
            sSharedPrefs = new ArrayMap<String, ArrayMap<String, SharedPreferencesImpl>>();
        }
        final String packageName = getPackageName();
        ArrayMap<String, SharedPreferencesImpl> packagePrefs = sSharedPrefs.get(packageName);
        if (packagePrefs == null) {
            packagePrefs = new ArrayMap<String, SharedPreferencesImpl>();
            sSharedPrefs.put(packageName, packagePrefs);
        }
        // we would stringify it to ""null.xml"".  Nice.
        if (mPackageInfo.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.KITKAT) {
            if (name == null) {
                name = ""null"";
            }
        }
        sp = packagePrefs.get(name);
        if (sp == null) {
            File prefsFile = getSharedPrefsFile(name);
            sp = new SharedPreferencesImpl(prefsFile, mode);
            packagePrefs.put(name, sp);
            return sp;
        }
    }
    if ((mode & Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
        // If somebody else (some other process) changed the prefs
        // file behind our back, we reload it.  This has been the
        // historical (if undocumented) behavior.
        sp.startReloadIfChangedUnexpectedly();
    }
    return sp;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control structure in the beginning of the code has been changed, it now checks whether `sSharedPrefs` is null and initializes it if true, which wasn't the case in the early version. The line `final String packageName = getPackageName();` and a few following lines were added in the late version as well. Therefore, the code change type is 3,4.","Due to the new initialization of `sSharedPrefs` and the addition of package name related code, the `return` statement within the synchronization block and the last `return` statement may result in different variable values in the late version compared to the early version. So, the CI type is 1."
464,<android.widget.GridLayout: int getRowCount()>,18,19,<android.widget.GridLayout: int getRowCount()>,<android.widget.GridLayout: int getRowCount()>,0,"{
    return verticalAxis.getCount();
}","{
    return mVerticalAxis.getCount();
}",1,"/**
 * Returns the current number of rows. This is either the last value that was set
 * with {@link #setRowCount(int)} or, if no such value was set, the maximum
 * value of each the upper bounds defined in {@link LayoutParams#rowSpec}.
 *
 * @return the current number of rows
 *
 * @see #setRowCount(int)
 * @see LayoutParams#rowSpec
 *
 * @attr ref android.R.styleable#GridLayout_rowCount
 */
","/**
 * Returns the current number of rows. This is either the last value that was set
 * with {@link #setRowCount(int)} or, if no such value was set, the maximum
 * value of each the upper bounds defined in {@link LayoutParams#rowSpec}.
 *
 * @return the current number of rows
 *
 * @see #setRowCount(int)
 * @see LayoutParams#rowSpec
 *
 * @attr ref android.R.styleable#GridLayout_rowCount
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling getCount() on verticalAxis object to calling getCount() on mVerticalAxis object. Furthermore, the object on which the getCount() method is invoked has changed from 'verticalAxis' to 'mVerticalAxis'. Therefore, both return statement and dependent API have changed making the change type 1,5.","Since the object on which the getCount() method is invoked has changed, it may potentially produce a different return value, hence a potential compatibility issue exists of type 1."
465,<android.view.View: boolean destroyLayer(boolean)>,18,19,<android.view.View: boolean destroyLayer(boolean)>,<android.view.View: boolean destroyLayer(boolean)>,0,"{
    if (mHardwareLayer != null) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
            mHardwareLayer.destroy();
            mHardwareLayer = null;
            if (mDisplayList != null) {
                mDisplayList.reset();
            }
            invalidate(true);
            invalidateParentCaches();
        }
        return true;
    }
    return false;
}","{
    if (mHardwareLayer != null) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
            info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer);
            mHardwareLayer.destroy();
            mHardwareLayer = null;
            invalidate(true);
            invalidateParentCaches();
        }
        return true;
    }
    return false;
}",1,"/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
","/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new function info.mHardwareRenderer.cancelLayerUpdate(mHardwareLayer) is added in the late version, so the code change type is 4.","This change doesn't affect the return value or the exceptions thrown by this method, so there is no compatibility issue, hence the CI type is 0."
467,<android.app.ContextImpl: ComponentName startService(Intent)>,18,19,<android.app.ContextImpl: ComponentName startService(Intent)>,<android.app.ContextImpl: ComponentName startService(Intent)>,0,"{
    warnIfCallingFromSystemProcess();
    return startServiceAsUser(service, mUser);
}","{
    warnIfCallingFromSystemProcess();
    return startServiceCommon(service, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from startServiceAsUser(service, mUser) to startServiceCommon(service, mUser) and the method it relies on also changed, so the code change type is 1,5.","The change of return statement and the dependent API changes might make the API potentially return a different value, so the CI type is 1."
468,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,18,19,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,<android.content.ClipboardManager: void addPrimaryClipChangedListener(OnPrimaryClipChangedListener)>,0,"{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getBasePackageName());
            } catch (RemoteException e) {
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}","{
    synchronized (mPrimaryClipChangedListeners) {
        if (mPrimaryClipChangedListeners.size() == 0) {
            try {
                getService().addPrimaryClipChangedListener(mPrimaryClipChangedServiceListener, mContext.getOpPackageName());
            } catch (RemoteException e) {
            }
        }
        mPrimaryClipChangedListeners.add(what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method call changes from mContext.getBasePackageName() to mContext.getOpPackageName() inside the try block, so the code change type is 4,5.","No Compatibility Issue exists. The change in method call does not alter the return value nor the exception being thrown by the API. Therefore, the CI type is 0."
469,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,18,19,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,0,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    if (mCurrentDrag != null) {
                        mCurrentDrag.recycle();
                        mCurrentDrag = null;
                    }
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    final PointF localPoint = getLocalPoint();
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    if (mCurrentDrag != null) {
                        mCurrentDrag.recycle();
                        mCurrentDrag = null;
                    }
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, localPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = localPoint.x;
                    event.mY = localPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}",1,"// TODO: Write real docs
","// TODO: Write real docs
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The method mLocalPoint() was replaced with getLocalPoint() method which results in a dependent API change (type 4).,"Despite this code change, it doesn't lead to any Compatibility Issues because this method (getLocalPoint()) is likely to return a result that is consistent with the earlier version. Thus, API behavior remains the same so no CI detected here."
471,"<android.util.Log: int wtf(String,Throwable)>",18,19,"<android.util.Log: int wtf(String,Throwable)>","<android.util.Log: int wtf(String,Throwable)>",0,"{
    return wtf(tag, tr.getMessage(), tr);
}","{
    return wtf(LOG_ID_MAIN, tag, tr.getMessage(), tr, false);
}",1,"/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, String)}, with an exception to log.
 * @param tag Used to identify the source of a log message.
 * @param tr An exception to log.
 */
","/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, String)}, with an exception to log.
 * @param tag Used to identify the source of a log message.
 * @param tr An exception to log.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from wtf(tag, tr.getMessage(), tr) to wtf(LOG_ID_MAIN, tag, tr.getMessage(), tr, false), the signiture of wtf( ) has also changed due to the change of parameters. Therefore, the code change type is 1 and 5.","Different parameters passed into wtf( ) may lead to a different return, thus the CI type is 1."
472,<android.util.DebugUtils: boolean isObjectSelected(Object)>,18,19,<android.util.DebugUtils: boolean isObjectSelected(Object)>,<android.util.DebugUtils: boolean isObjectSelected(Object)>,0,"{
    boolean match = false;
    String s = System.getenv(""ANDROID_OBJECT_FILTER"");
    if (s != null && s.length() > 0) {
        String[] selectors = s.split(""@"");
        // first selector == class name
        if (object.getClass().getSimpleName().matches(selectors[0])) {
            // check potential attributes
            for (int i = 1; i < selectors.length; i++) {
                String[] pair = selectors[i].split(""="");
                Class<?> klass = object.getClass();
                try {
                    Method declaredMethod = null;
                    Class<?> parent = klass;
                    do {
                        declaredMethod = parent.getDeclaredMethod(""get"" + pair[0].substring(0, 1).toUpperCase() + pair[0].substring(1), (Class[]) null);
                    } while ((parent = klass.getSuperclass()) != null && declaredMethod == null);
                    if (declaredMethod != null) {
                        Object value = declaredMethod.invoke(object, (Object[]) null);
                        match |= (value != null ? value.toString() : ""null"").matches(pair[1]);
                    }
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    return match;
}","{
    boolean match = false;
    String s = System.getenv(""ANDROID_OBJECT_FILTER"");
    if (s != null && s.length() > 0) {
        String[] selectors = s.split(""@"");
        // first selector == class name
        if (object.getClass().getSimpleName().matches(selectors[0])) {
            // check potential attributes
            for (int i = 1; i < selectors.length; i++) {
                String[] pair = selectors[i].split(""="");
                Class<?> klass = object.getClass();
                try {
                    Method declaredMethod = null;
                    Class<?> parent = klass;
                    do {
                        declaredMethod = parent.getDeclaredMethod(""get"" + pair[0].substring(0, 1).toUpperCase(Locale.ROOT) + pair[0].substring(1), (Class[]) null);
                    } while ((parent = klass.getSuperclass()) != null && declaredMethod == null);
                    if (declaredMethod != null) {
                        Object value = declaredMethod.invoke(object, (Object[]) null);
                        match |= (value != null ? value.toString() : ""null"").matches(pair[1]);
                    }
                } catch (NoSuchMethodException e) {
                    e.printStackTrace();
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                } catch (InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    return match;
}",1,"/**
 * <p>Filters objects against the <code>ANDROID_OBJECT_FILTER</code>
 * environment variable. This environment variable can filter objects
 * based on their class name and attribute values.</p>
 *
 * <p>Here is the syntax for <code>ANDROID_OBJECT_FILTER</code>:</p>
 *
 * <p><code>ClassName@attribute1=value1@attribute2=value2...</code></p>
 *
 * <p>Examples:</p>
 * <ul>
 * <li>Select TextView instances: <code>TextView</code></li>
 * <li>Select TextView instances of text ""Loading"" and bottom offset of 22:
 * <code>TextView@text=Loading.*@bottom=22</code></li>
 * </ul>
 *
 * <p>The class name and the values are regular expressions.</p>
 *
 * <p>This class is useful for debugging and logging purpose:</p>
 * <pre>
 * if (DEBUG) {
 * if (DebugUtils.isObjectSelected(childView) && LOGV_ENABLED) {
 * Log.v(TAG, ""Object "" + childView + "" logged!"");
 * }
 * }
 * </pre>
 *
 * <p><strong>NOTE</strong>: This method is very expensive as it relies
 * heavily on regular expressions and reflection. Calls to this method
 * should always be stripped out of the release binaries and avoided
 * as much as possible in debug mode.</p>
 *
 * @param object any object to match against the ANDROID_OBJECT_FILTER
 * environement variable
 * @return true if object is selected by the ANDROID_OBJECT_FILTER
 * environment variable, false otherwise
 */
","/**
 * <p>Filters objects against the <code>ANDROID_OBJECT_FILTER</code>
 * environment variable. This environment variable can filter objects
 * based on their class name and attribute values.</p>
 *
 * <p>Here is the syntax for <code>ANDROID_OBJECT_FILTER</code>:</p>
 *
 * <p><code>ClassName@attribute1=value1@attribute2=value2...</code></p>
 *
 * <p>Examples:</p>
 * <ul>
 * <li>Select TextView instances: <code>TextView</code></li>
 * <li>Select TextView instances of text ""Loading"" and bottom offset of 22:
 * <code>TextView@text=Loading.*@bottom=22</code></li>
 * </ul>
 *
 * <p>The class name and the values are regular expressions.</p>
 *
 * <p>This class is useful for debugging and logging purpose:</p>
 * <pre>
 * if (DEBUG) {
 * if (DebugUtils.isObjectSelected(childView) && LOGV_ENABLED) {
 * Log.v(TAG, ""Object "" + childView + "" logged!"");
 * }
 * }
 * </pre>
 *
 * <p><strong>NOTE</strong>: This method is very expensive as it relies
 * heavily on regular expressions and reflection. Calls to this method
 * should always be stripped out of the release binaries and avoided
 * as much as possible in debug mode.</p>
 *
 * @param object any object to match against the ANDROID_OBJECT_FILTER
 * environement variable
 * @return true if object is selected by the ANDROID_OBJECT_FILTER
 * environment variable, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the method 'toUpperCase()', a new parameter, 'Locale.ROOT', is added. This change refers to other statement change. Therefore, the code change type is 4.","All exceptions and return values are unchanged from the early version, so there is no compatibility issue. Thus, the CI type is 0."
473,<android.view.View: boolean setAlphaNoInvalidation(float)>,18,19,<android.view.View: boolean setAlphaNoInvalidation(float)>,<android.view.View: boolean setAlphaNoInvalidation(float)>,0,"{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(alpha);
            }
        }
    }
    return false;
}","{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(getFinalAlpha());
            }
        }
    }
    return false;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The parameter in the mDisplayList.setAlpha() method has been changed from alpha to getFinalAlpha(). This means the return statement changed because of this change in the method call. Thus, the code change type is 1 and 4.",The change in the parameter of the mDisplayList.setAlpha() call can lead to a different return value. This signifies compatibility issue type 1 because the change can cause a different return value.
475,<android.preference.Preference: int compareTo(Preference)>,18,19,<android.preference.Preference: int compareTo(Preference)>,<android.preference.Preference: int compareTo(Preference)>,0,"{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}","{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}",1,"/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
","/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The checking condition of the 'if' statement has changed (comparing the 'mTitle' value to the another.mTitle), which indicates a Control Dependency change. In addition, an extra return statement (return 0) has been added inside the new else if branch, so a Return Statement has also been changed. Therefore, the change type is classified as ""1,3"".","Since a new condition on 'mTitle's equality is introduced, the new version of the method can return 0 where the old one could not (when titles are null or share the same object). Hence, different versions of this method might yield different results when invoked with the same value, leading to a potential Compatibility Issue related to return values or types, defined as type ""1""."
476,<android.widget.AdapterView: void handleDataChanged()>,18,19,<android.widget.AdapterView: void handleDataChanged()>,<android.widget.AdapterView: void handleDataChanged()>,0,"{
    final int count = mItemCount;
    boolean found = false;
    if (count > 0) {
        int newPos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects
            // it
            mNeedSync = false;
            // See if we can find a position in the new data with the same
            // id as the old selection
            newPos = findSyncPosition();
            if (newPos >= 0) {
                // Verify that new selection is selectable
                int selectablePos = lookForSelectablePosition(newPos, true);
                if (selectablePos == newPos) {
                    // Same row id is selected
                    setNextSelectedPositionInt(newPos);
                    found = true;
                }
            }
        }
        if (!found) {
            // Try to use the same position if we can't find matching data
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            int selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos < 0) {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
            }
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                checkSelectionChanged();
                found = true;
            }
        }
    }
    if (!found) {
        // Nothing is selected
        mSelectedPosition = INVALID_POSITION;
        mSelectedRowId = INVALID_ROW_ID;
        mNextSelectedPosition = INVALID_POSITION;
        mNextSelectedRowId = INVALID_ROW_ID;
        mNeedSync = false;
        checkSelectionChanged();
    }
    // TODO: Hmm, we do not know the old state so this is sub-optimal
    notifyAccessibilityStateChanged();
}","{
    final int count = mItemCount;
    boolean found = false;
    if (count > 0) {
        int newPos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects
            // it
            mNeedSync = false;
            // See if we can find a position in the new data with the same
            // id as the old selection
            newPos = findSyncPosition();
            if (newPos >= 0) {
                // Verify that new selection is selectable
                int selectablePos = lookForSelectablePosition(newPos, true);
                if (selectablePos == newPos) {
                    // Same row id is selected
                    setNextSelectedPositionInt(newPos);
                    found = true;
                }
            }
        }
        if (!found) {
            // Try to use the same position if we can't find matching data
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            int selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos < 0) {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
            }
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                checkSelectionChanged();
                found = true;
            }
        }
    }
    if (!found) {
        // Nothing is selected
        mSelectedPosition = INVALID_POSITION;
        mSelectedRowId = INVALID_ROW_ID;
        mNextSelectedPosition = INVALID_POSITION;
        mNextSelectedRowId = INVALID_ROW_ID;
        mNeedSync = false;
        checkSelectionChanged();
    }
    notifySubtreeAccessibilityStateChangedIfNeeded();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The function notifyAccessibilityStateChanged() changed to notifySubtreeAccessibilityStateChangedIfNeeded() which indicates a different function is called in the late version. Other parts remain the same.,"The change from notifyAccessibilityStateChanged() to notifySubtreeAccessibilityStateChangedIfNeeded() doesn't result in the method returning different values, so no Compatibility Issue exists here."
477,<android.content.Intent: Intent addCategory(String)>,18,19,<android.content.Intent: Intent addCategory(String)>,<android.content.Intent: Intent addCategory(String)>,0,"{
    if (mCategories == null) {
        mCategories = new HashSet<String>();
    }
    mCategories.add(category.intern());
    return this;
}","{
    if (mCategories == null) {
        mCategories = new ArraySet<String>();
    }
    mCategories.add(category.intern());
    return this;
}",1,"/**
 * Add a new category to the intent.  Categories provide additional detail
 * about the action the intent performs.  When resolving an intent, only
 * activities that provide <em>all</em> of the requested categories will be
 * used.
 *
 * @param category The desired category.  This can be either one of the
 * predefined Intent categories, or a custom category in your own
 * namespace.
 *
 * @return Returns the same Intent object, for chaining multiple calls
 * into a single statement.
 *
 * @see #hasCategory
 * @see #removeCategory
 */
","/**
 * Add a new category to the intent.  Categories provide additional detail
 * about the action the intent performs.  When resolving an intent, only
 * activities that provide <em>all</em> of the requested categories will be
 * used.
 *
 * @param category The desired category.  This can be either one of the
 * predefined Intent categories, or a custom category in your own
 * namespace.
 *
 * @return Returns the same Intent object, for chaining multiple calls
 * into a single statement.
 *
 * @see #hasCategory
 * @see #removeCategory
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object creation statement for mCategories has changed from HashSet to ArraySet, which is an other type statement change, thus the code change type is 4.","The change of HashSet to ArraySet does not affect the behavior of the method, thus no Compatibility Issues exist. The return type and exceptions this API might throw have not changed."
478,<android.os.ParcelFileDescriptor: void finalize()>,18,19,<android.os.ParcelFileDescriptor: void finalize()>,<android.os.ParcelFileDescriptor: void finalize()>,0,"{
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
    try {
        if (!mClosed) {
            close();
        }
    } finally {
        super.finalize();
    }
}","{
    if (mWrapped != null) {
        releaseResources();
    }
    if (mGuard != null) {
        mGuard.warnIfOpen();
    }
    try {
        if (!mClosed) {
            closeWithStatus(Status.LEAKED, null);
        }
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"New statements have been introduced (if mWrapped != null and releaseResources()) and the close() method is replaced with closeWithStatus(Status.LEAKED, null). Also, a new condition 'if(mWrapped!=null)' is introduced and an existing method's parameter values has been changed. Therefore, the change type is 1, 3, 4, 5. ","The newly introduced statement and the change in the calling method with new parameter can possibly result in the API returning a different variable or value, therefore, the CI type is 1."
479,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,18,19,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,<android.animation.ValueAnimator: boolean doAnimationFrame(long)>,0,"{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = frameTime;
        } else {
            mStartTime = frameTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}","{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = frameTime;
        } else {
            mStartTime = frameTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The ""current time"" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}",1,"/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
","/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"New if conditions (mPaused and mResumed) have been inserted. In the late version, return statements are added in the mPaused condition and the mResumed condition alter the assignment of mStartTime, so the changes are related with control dependencies and return statements. Thus the code change type is 3,1.","As the new condition statement introduces a new return value (return false in mPaused condition), it will potentially affect the return values of the method. Therefore, the CI type is 1."
481,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",18,19,"<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>","<android.app.ContextImpl: ComponentName startServiceAsUser(Intent,UserHandle)>",0,"{
    try {
        service.prepareToLeaveProcess();
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (cn != null) {
            if (cn.getPackageName().equals(""!"")) {
                throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
            } else if (cn.getPackageName().equals(""!!"")) {
                throw new SecurityException(""Unable to start service "" + service + "": "" + cn.getClassName());
            }
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}","{
    return startServiceCommon(service, user);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"In the late_version, the implementation has been completely replaced by calling startServiceCommon(service, user), so the code change type includes 1,5.","As the function 'startServiceCommon' implementation may not be the same as the early version without knowing the detail of this function and assuming it could potentially result in different behavior. Therefore, the CI type is 1."
482,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,18,19,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,<android.os.ParcelFileDescriptor.AutoCloseInputStream: void close()>,0,"{
    try {
        mFd.close();
    } finally {
        super.close();
    }
}","{
    try {
        mPfd.close();
    } finally {
        super.close();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The variable within the try block statement has changed from mFd to mPfd, so the code change type is 4.","The call to the close() method is now on a different variable, so the potential behavior and return value could be different, hence the CI is 1."
483,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,18,19,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,<android.os.StrictMode.AndroidBlockGuardPolicy: void handleViolation(ViolationInfo)>,0,"{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime.containsKey(crashFingerprint)) {
        lastViolationTime = mLastViolationTime.get(crashFingerprint);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}","{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, ""unexpected null stacktrace"");
        return;
    }
    if (LOG_V)
        Log.d(TAG, ""handleViolation; policy="" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, ""StrictMode policy violation; ~duration="" + info.durationMillis + "" ms: "" + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, ""StrictMode policy violation: "" + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            Log.e(TAG, ""RemoteException trying to handle StrictMode violation"", e);
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}",1,"// hence the policy being passed around.
","// hence the policy being passed around.
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the late version, an 'if' control structure has been added to check if 'mLastViolationTime' is not null before getting values from it, and an else block has been introduced to initialize the 'mLastViolationTime' with a new ArrayMap when it's null, which belongs to the type 3.",#CI_description
484,<android.content.pm.PackageParser.Instrumentation: String toString()>,18,19,<android.content.pm.PackageParser.Instrumentation: String toString()>,<android.content.pm.PackageParser.Instrumentation: String toString()>,0,"{
    return ""Instrumentation{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + getComponentShortName() + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""Instrumentation{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way to form a string has changed from directly concatenating strings to using StringBuilder, so the code change type is 4.","Even though the way of forming the string has changed, but the content of the returned string from the API is still same, so there is no compatibility issue."
486,"<android.os.Bundle: void writeToParcel(Parcel,int)>",18,19,"<android.os.Bundle: void writeToParcel(Parcel,int)>","<android.os.Bundle: void writeToParcel(Parcel,int)>",0,"{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            // 'B' 'N' 'D' 'L'
            parcel.writeInt(0x4C444E42);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            // dummy, will hold length
            parcel.writeInt(-1);
            // 'B' 'N' 'D' 'L'
            parcel.writeInt(0x4C444E42);
            int oldPos = parcel.dataPosition();
            parcel.writeMapInternal(mMap);
            int newPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(oldPos - 8);
            int length = newPos - oldPos;
            parcel.writeInt(length);
            parcel.setDataPosition(newPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The map type which needs to be written into parcel has changed from writeMapInternal to writeArrayMapInternal, besides, the way it handles length has also been modified which makes the return value different. Therefore, the change includes return statement, control dependency, other statements and dependent method change so the code change type is 1,3,4,5.","Because the way it writes data and calculates length has been transformed, this might result in a different return value. So the compatibility issue lies in the potential different return value, the CI type is 1."
490,<android.webkit.WebView: Picture capturePicture()>,18,19,<android.webkit.WebView: Picture capturePicture()>,<android.webkit.WebView: Picture capturePicture()>,0,"{
    checkThread();
    return mProvider.capturePicture();
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""capturePicture"");
    return mProvider.capturePicture();
}",1,"/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 *
 * @return a picture that captures the current contents of this WebView
 */
","/**
 * Gets a new picture that captures the current contents of this WebView.
 * The picture is of the entire document being displayed, and is not
 * limited to the area currently displayed by this WebView. Also, the
 * picture is a static copy and is unaffected by later changes to the
 * content being displayed.
 * <p>
 * Note that due to internal changes, for API levels between
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
 * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
 * picture does not include fixed position elements or scrollable divs.
 * <p>
 * Note that from {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} the returned picture
 * should only be drawn into bitmap-backed Canvas - using any other type of Canvas will involve
 * additional conversion at a cost in memory and performance. Also the
 * {@link android.graphics.Picture#createFromStream} and
 * {@link android.graphics.Picture#writeToStream} methods are not supported on the
 * returned object.
 *
 * @deprecated Use {@link #onDraw} to obtain a bitmap snapshot of the WebView, or
 * {@link #saveWebArchive} to save the content to a file.
 *
 * @return a picture that captures the current contents of this WebView
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"A new debug logging statement has been added. This change falls under ""Other statement changed"".","The introduction of a debug logging statement doesn't affect the behavior of the method or result in different return values/types or exception handling. Hence, it doesn't create a Compatibility Issue."
492,<android.content.pm.PackageParser.ActivityIntentInfo: String toString()>,18,19,<android.content.pm.PackageParser.ActivityIntentInfo: String toString()>,<android.content.pm.PackageParser.ActivityIntentInfo: String toString()>,0,"{
    return ""ActivityIntentInfo{"" + Integer.toHexString(System.identityHashCode(this)) + "" "" + activity.info.name + ""}"";
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""ActivityIntentInfo{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append(' ');
    activity.appendComponentShortName(sb);
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The return statement has changed from concatenating Strings to using StringBuilder to construct the String, so the code change type is 4.","Though both versions are constructing a string, the actual method calls have changed. Previously, it uses activity.info.name and now uses activity.appendComponentShortName(sb). Hence this introduces a possibility of the method return a different string, which is why the type of CI is 1."
495,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetPendingIntentTemplate: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    Intent fillInIntent = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof Intent) {
                            fillInIntent = (Intent) tag;
                            break;
                        }
                    }
                    if (fillInIntent == null)
                        return;
                    final float appScale = view.getContext().getResources().getCompatibilityInfo().applicationScale;
                    final int[] pos = new int[2];
                    view.getLocationOnScreen(pos);
                    final Rect rect = new Rect();
                    rect.left = (int) (pos[0] * appScale + 0.5f);
                    rect.top = (int) (pos[1] * appScale + 0.5f);
                    rect.right = (int) ((pos[0] + view.getWidth()) * appScale + 0.5f);
                    rect.bottom = (int) ((pos[1] + view.getHeight()) * appScale + 0.5f);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(view, pendingIntentTemplate, fillInIntent);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(LOG_TAG, ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // If the view isn't an AdapterView, setting a PendingIntent template doesn't make sense
    if (target instanceof AdapterView<?>) {
        AdapterView<?> av = (AdapterView<?>) target;
        // The PendingIntent template is stored in the view's tag.
        OnItemClickListener listener = new OnItemClickListener() {

            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                // The view should be a frame layout
                if (view instanceof ViewGroup) {
                    ViewGroup vg = (ViewGroup) view;
                    // so we need to go one layer deeper here.
                    if (parent instanceof AdapterViewAnimator) {
                        vg = (ViewGroup) vg.getChildAt(0);
                    }
                    if (vg == null)
                        return;
                    Intent fillInIntent = null;
                    int childCount = vg.getChildCount();
                    for (int i = 0; i < childCount; i++) {
                        Object tag = vg.getChildAt(i).getTag(com.android.internal.R.id.fillInIntent);
                        if (tag instanceof Intent) {
                            fillInIntent = (Intent) tag;
                            break;
                        }
                    }
                    if (fillInIntent == null)
                        return;
                    final Rect rect = getSourceBounds(view);
                    final Intent intent = new Intent();
                    intent.setSourceBounds(rect);
                    handler.onClickHandler(view, pendingIntentTemplate, fillInIntent);
                }
            }
        };
        av.setOnItemClickListener(listener);
        av.setTag(pendingIntentTemplate);
    } else {
        Log.e(LOG_TAG, ""Cannot setPendingIntentTemplate on a view which is not"" + ""an AdapterView (id: "" + viewId + "")"");
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method of getting source bounds has been abstracted out, changing from direct calculation to calling the method `getSourceBounds(view)`. This is a type 4 change since other statements changed in the implementation, not involving the return, exception, and control dependency.","Though the method of getting source bounds changed, the overall API behavior remains the same, as both early and late implementation get the source bounds and then set it into the `intent`. Therefore, there is no Compatibility Issue (CI) introduced as per the change."
497,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,18,19,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                // calls onScrollChanged if applicable.
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,0,0,There is no changes on the early and late implementation of the given method.,"Since there is no code change, there is no compatibility issue between these two versions."
498,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup()>,18,19,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor dup()>,0,"{
    return dup(getFileDescriptor());
}","{
    if (mWrapped != null) {
        return mWrapped.dup();
    } else {
        return dup(getFileDescriptor());
    }
}",1,"/**
 * Create a new ParcelFileDescriptor that is a dup of the existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
","/**
 * Create a new ParcelFileDescriptor that is a dup of the existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new if condition is introduced and also the return statement under this new condition. So, the code change type is 1,3.","As a new return statement is introduced, the API in late version could potentially return a different value when 'mWrapped' is not null. Therefore, the CI type is 1."
500,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,18,19,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl c = new ContextImpl();
    c.init(mPackageInfo, null, mMainThread);
    c.mResources = mMainThread.getTopLevelResources(mPackageInfo.getResDir(), getDisplayId(), overrideConfiguration, mResources.getCompatibilityInfo());
    return c;
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl c = new ContextImpl();
    c.init(mPackageInfo, null, mMainThread);
    c.mResources = mResourcesManager.getTopLevelResources(mPackageInfo.getResDir(), getDisplayId(), overrideConfiguration, mResources.getCompatibilityInfo(), mActivityToken);
    return c;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"There's a change in the statement where 'mResources' value is assigned. In the earlier version, the value was assigned from 'mMainThread.getTopLevelResources(...)' and in the later version, the value was assigned from 'mResourcesManager.getTopLevelResources(...)'. Also, an extra parameter 'mActivityToken' was introduced in the method call. So, the code change is 1,5.","Due to the different assignment of 'mResources' and addition of extra argument 'mActivityToken' in the following line, the return object 'c' could potentially hold different values in the two versions. Therefore, the CI type is 1."
502,<android.widget.Spinner: int getBaseline()>,18,19,<android.widget.Spinner: int getBaseline()>,<android.widget.Spinner: int getBaseline()>,0,"{
    View child = null;
    if (getChildCount() > 0) {
        child = getChildAt(0);
    } else if (mAdapter != null && mAdapter.getCount() > 0) {
        child = makeAndAddView(0);
        mRecycler.put(0, child);
        removeAllViewsInLayout();
    }
    if (child != null) {
        final int childBaseline = child.getBaseline();
        return childBaseline >= 0 ? child.getTop() + childBaseline : -1;
    } else {
        return -1;
    }
}","{
    View child = null;
    if (getChildCount() > 0) {
        child = getChildAt(0);
    } else if (mAdapter != null && mAdapter.getCount() > 0) {
        child = makeView(0, false);
        mRecycler.put(0, child);
    }
    if (child != null) {
        final int childBaseline = child.getBaseline();
        return childBaseline >= 0 ? child.getTop() + childBaseline : -1;
    } else {
        return -1;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"While the 'makeAndAddView(0)' method in the early version has been replaced with 'makeView(0, false)' in the late version, the statements are different, but not return, exception handling, and control dependency. Therefore, the change types are 4 and 5.","The change in the dependent API (from 'makeAndAddView(0)' to 'makeView(0, false)') might lead to a different instance of the child, which potentially causes the API to return a different baseline. Therefore, the CI type is 1."
505,<android.view.ViewPropertyAnimator: long getDuration()>,18,19,<android.view.ViewPropertyAnimator: long getDuration()>,<android.view.ViewPropertyAnimator: long getDuration()>,0,"{
    if (mDurationSet) {
        return mDuration;
    } else {
        // the value has not been set otherwise
        return new ValueAnimator().getDuration();
    }
}","{
    if (mDurationSet) {
        return mDuration;
    } else {
        // the value has not been set otherwise
        if (mTempValueAnimator == null) {
            mTempValueAnimator = new ValueAnimator();
        }
        return mTempValueAnimator.getDuration();
    }
}",1,"/**
 * Returns the current duration of property animations. If the duration was set on this
 * object, that value is returned. Otherwise, the default value of the underlying Animator
 * is returned.
 *
 * @see #setDuration(long)
 * @return The duration of animations, in milliseconds.
 */
","/**
 * Returns the current duration of property animations. If the duration was set on this
 * object, that value is returned. Otherwise, the default value of the underlying Animator
 * is returned.
 *
 * @see #setDuration(long)
 * @return The duration of animations, in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, a new condition statement 'if (mTempValueAnimator == null)' was introduced and the return statement of the 'else' block has changed. Additionally, the variable 'mTempValueAnimator' was assigned a new value making the change type 1,3,4.",The change in the return statement in the 'else' block could contribute to the method potentially returning a different value between versions. Therefore the CI type is 1.
507,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,18,19,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface());
                            } catch (Surface.OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_KEY:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingOverscanInsets.equals(args.arg5) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingOverscanInsets.set((Rect) args.arg5);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface());
                            } catch (OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                        mAttachInfo.mTreeObserver.dispatchOnWindowFocusChange(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget && !isInLocalFocusMode()) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_INPUT_EVENT:
            {
                InputEvent event = (InputEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
        case MSG_FLUSH_LAYER_UPDATES:
            {
                flushHardwareLayerUpdates();
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
508,<android.content.res.Configuration: int updateFrom(Configuration)>,18,19,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        // If locale has changed, then layout direction is also changed ...
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
        // ... and we need to update the layout direction (represented by the first
        // 2 most significant bits in screenLayout).
        setLayoutDirection(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        // If locale has changed, then layout direction is also changed ...
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
        // ... and we need to update the layout direction (represented by the first
        // 2 most significant bits in screenLayout).
        setLayoutDirection(locale);
    }
    final int deltaScreenLayoutDir = delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    if (deltaScreenLayoutDir != SCREENLAYOUT_LAYOUTDIR_UNDEFINED && deltaScreenLayoutDir != (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        screenLayout = (screenLayout & ~SCREENLAYOUT_LAYOUTDIR_MASK) | deltaScreenLayoutDir;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        userSetLocale = true;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a new code introduced to compute deltaScreenLayoutDir and some assignments statements changed including screenLayout, which results in control dependency changes and other statement changes, hence the code change type is 3,4.",The changes in code have potential to affect the control flow of the function and leads to potentially different assignments to variables such as screenLayout affecting the return value hence the CI type is 1.
509,<android.os.Parcel: Bundle readBundle(ClassLoader)>,18,19,<android.os.Parcel: Bundle readBundle(ClassLoader)>,<android.os.Parcel: Bundle readBundle(ClassLoader)>,0,"{
    int length = readInt();
    if (length < 0) {
        return null;
    }
    final Bundle bundle = new Bundle(this, length);
    if (loader != null) {
        bundle.setClassLoader(loader);
    }
    return bundle;
}","{
    int length = readInt();
    if (length < 0) {
        if (Bundle.DEBUG)
            Log.d(TAG, ""null bundle: length="" + length);
        return null;
    }
    final Bundle bundle = new Bundle(this, length);
    if (loader != null) {
        bundle.setClassLoader(loader);
    }
    return bundle;
}",1,"/**
 * Read and return a new Bundle object from the parcel at the current
 * dataPosition(), using the given class loader to initialize the class
 * loader of the Bundle for later retrieval of Parcelable objects.
 * Returns null if the previously written Bundle object was null.
 */
","/**
 * Read and return a new Bundle object from the parcel at the current
 * dataPosition(), using the given class loader to initialize the class
 * loader of the Bundle for later retrieval of Parcelable objects.
 * Returns null if the previously written Bundle object was null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In this case, there has been an addition of a logging statement if Bundle.DEBUG is true. So the change can be classified as other statements changed (type 4).","The addition of the logging statement doesn't impact the behaviour or output of the API, hence there is no Compatibility Issue (type 0). The return variables and exceptions remain the same for both versions."
510,"<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>",18,19,"<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>","<android.app.ContextImpl: boolean stopServiceAsUser(Intent,UserHandle)>",0,"{
    try {
        service.prepareToLeaveProcess();
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    return stopServiceCommon(service, user);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5","1,2","The return statement and the exception handling statement have been replaced by the return of stopServiceCommon(service, user), and also the dependent API ""stopServiceCommon"" has been introduced, so the change type is 1,5.","The replaced return and exception handling statement within the new method ""stopServiceCommon"" could lead to different behaviors, thus the CI type is 1,2."
511,<android.view.ViewPropertyAnimator: TimeInterpolator getInterpolator()>,18,19,<android.view.ViewPropertyAnimator: TimeInterpolator getInterpolator()>,<android.view.ViewPropertyAnimator: TimeInterpolator getInterpolator()>,0,"{
    return null;
}","{
    if (mInterpolatorSet) {
        return mInterpolator;
    } else {
        // the value has not been set otherwise
        if (mTempValueAnimator == null) {
            mTempValueAnimator = new ValueAnimator();
        }
        return mTempValueAnimator.getInterpolator();
    }
}",1,"/**
 * Returns the timing interpolator that this animation uses.
 *
 * @return The timing interpolator for this animation.
 */
","/**
 * Returns the timing interpolator that this animation uses.
 *
 * @return The timing interpolator for this animation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement changed from 'return null' to a conditional return based on value of 'mInterpolatorSet' and there is a new 'if' control statement, so the code change types are 1,3.","In the Late version of the implementation, the method no longer always returns 'null'. The change in the return statement can potentially cause the method to return different values in different versions. Therefore, it has a CI type of 1."
512,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",18,19,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>","<android.webkit.WebView: boolean showFindDialog(String,boolean)>",0,"{
    checkThread();
    return mProvider.showFindDialog(text, showIme);
}","{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, ""showFindDialog"");
    return mProvider.showFindDialog(text, showIme);
}",1,"/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
","/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"Only the debug log statement has been introduced in the late version, which comes under Other statement change type. Therefore, the code change type is 4.","This introduced debug log will not affect the behaviour of the API as it has no influence on return values or exception handling. Hence, no Compatibility Issue exists, so the CI type is 0."
514,<android.view.Display: String toString()>,18,19,<android.view.Display: String toString()>,<android.view.Display: String toString()>,0,"{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mCompatibilityInfo);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getAppMetrics(mTempMetrics, mDisplayAdjustments);
        return ""Display id "" + mDisplayId + "": "" + mDisplayInfo + "", "" + mTempMetrics + "", isValid="" + mIsValid;
    }
}",1,"// For debugging purposes
","// For debugging purposes
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter for the method mDisplayInfo.getAppMetrics has been changed from mCompatibilityInfo to mDisplayAdjustments, so the code change types are 1 and 5.","Due to the replacement of the method parameter, the output string being returned by the toString() method may vary, thus resulting in a potential Compatibility Issue of type 1."
515,"<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>",18,19,"<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>","<android.app.AlarmManager: void setRepeating(int,long,long,PendingIntent)>",0,"{
    try {
        mService.setRepeating(type, triggerAtMillis, intervalMillis, operation);
    } catch (RemoteException ex) {
    }
}","{
    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, operation, null);
}",1,"/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also
 * supply a rate at which the alarm will repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the time
 * occurs in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
","/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also
 * supply a rate at which the alarm will repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the time
 * occurs in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * @param type One of ELAPSED_REALTIME, ELAPSED_REALTIME_WAKEUP}, RTC or
 * RTC_WAKEUP.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #setExact
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The operations inside the method have changed from mService.setRepeating() to setImpl(). As the dependent API has changed, the code change type is 4,5.","As the different operations could result in different behaviors of the API, the CI type is 1."
517,<android.preference.Preference: boolean isEnabled()>,18,19,<android.preference.Preference: boolean isEnabled()>,<android.preference.Preference: boolean isEnabled()>,0,"{
    return mEnabled && mDependencyMet;
}","{
    return mEnabled && mDependencyMet && mParentDependencyMet;
}",1,"/**
 * Checks whether this Preference should be enabled in the list.
 *
 * @return True if this Preference is enabled, false otherwise.
 */
","/**
 * Checks whether this Preference should be enabled in the list.
 *
 * @return True if this Preference is enabled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mEnabled && mDependencyMet' to 'return mEnabled && mDependencyMet && mParentDependencyMet', so the code change type is 1.","The change of the return statement will result in this API potentially returning a different value, so the CI type is 1."
520,<android.app.Dialog: void show()>,18,19,<android.app.Dialog: void show()>,<android.app.Dialog: void show()>,0,"{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        mActionBar = new ActionBarImpl(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}","{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new ActionBarImpl(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}",1,"/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
","/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Additional statement has been added under the if condition - mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR), where the application info is obtained and used to set default icons and logos for the window. This can be categorized under ""Other statement changed"".","Despite the modifications, these changes won't lead to the API returning a different value or throwing a different exception, so there is no Compatibility Issue."
522,<android.app.ContextImpl: File getExternalFilesDir(String)>,18,19,<android.app.ContextImpl: File getExternalFilesDir(String)>,<android.app.ContextImpl: File getExternalFilesDir(String)>,0,"{
    synchronized (mSync) {
        if (mExternalFilesDir == null) {
            mExternalFilesDir = Environment.getExternalStorageAppFilesDirectory(getPackageName());
        }
        if (!mExternalFilesDir.exists()) {
            try {
                (new File(Environment.getExternalStorageAndroidDataDir(), "".nomedia"")).createNewFile();
            } catch (IOException e) {
            }
            if (!mExternalFilesDir.mkdirs()) {
                Log.w(TAG, ""Unable to create external files directory"");
                return null;
            }
        }
        if (type == null) {
            return mExternalFilesDir;
        }
        File dir = new File(mExternalFilesDir, type);
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                Log.w(TAG, ""Unable to create external media directory "" + dir);
                return null;
            }
        }
        return dir;
    }
}","{
    // Operates on primary external storage
    return getExternalFilesDirs(type)[0];
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from returning mExternalFilesDir for null type and dir for others to returning the first element of getExternalFilesDirs(type). The control structures (synchronized, if) and their contained codes have been deleted. The API getExternalFilesDirs() has been introduced in the later version. So, the code change type is 1,4,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
525,"<android.os.Bundle: void readFromParcelInner(Parcel,int)>",18,19,"<android.os.Bundle: void readFromParcelInner(Parcel,int)>","<android.os.Bundle: void readFromParcelInner(Parcel,int)>",0,"{
    int magic = parcel.readInt();
    if (magic != 0x4C444E42) {
        // noinspection ThrowableInstanceNeverThrown
        String st = Log.getStackTraceString(new RuntimeException());
        Log.e(""Bundle"", ""readBundle: bad magic number"");
        Log.e(""Bundle"", ""readBundle: trace = "" + st);
    }
    // Advance within this Parcel
    int offset = parcel.dataPosition();
    parcel.setDataPosition(offset + length);
    Parcel p = Parcel.obtain();
    p.setDataPosition(0);
    p.appendFrom(parcel, offset, length);
    p.setDataPosition(0);
    mParcelledData = p;
    mHasFds = p.hasFileDescriptors();
    mFdsKnown = true;
}","{
    int magic = parcel.readInt();
    if (magic != BUNDLE_MAGIC) {
        // noinspection ThrowableInstanceNeverThrown
        throw new IllegalStateException(""Bad magic number for Bundle: 0x"" + Integer.toHexString(magic));
    }
    // Advance within this Parcel
    int offset = parcel.dataPosition();
    parcel.setDataPosition(offset + length);
    Parcel p = Parcel.obtain();
    p.setDataPosition(0);
    p.appendFrom(parcel, offset, length);
    if (DEBUG)
        Log.d(TAG, ""Retrieving "" + Integer.toHexString(System.identityHashCode(this)) + "": "" + length + "" bundle bytes starting at "" + offset);
    p.setDataPosition(0);
    mParcelledData = p;
    mHasFds = p.hasFileDescriptors();
    mFdsKnown = true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2, 3, 4",2,"The way of handling the magic number put in the Parcel structure has been changed. The magic number constant and control structures are changed (from 'if' to 'throw'). An extra debug logging statement has been added. Therefore, the changes are: control dependency changed (3), exception handling statement changed (2), and other statements are changed (4).","The API now potentially throws a different exception ('IllegalStateException') if the magic number is not as expected. Therefore, the CI type is 2."
526,<android.view.View: void buildLayer()>,18,19,<android.view.View: void buildLayer()>,<android.view.View: void buildLayer()>,0,"{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    if (mAttachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate()) {
                getHardwareLayer();
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}","{
    if (mLayerType == LAYER_TYPE_NONE)
        return;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo == null) {
        throw new IllegalStateException(""This view must be attached to a window first"");
    }
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            if (attachInfo.mHardwareRenderer != null && attachInfo.mHardwareRenderer.isEnabled() && attachInfo.mHardwareRenderer.validate()) {
                getHardwareLayer();
                // current frame
                if (!attachInfo.mTreeObserver.hasOnPreDrawListeners()) {
                    attachInfo.mViewRootImpl.dispatchFlushHardwareLayerUpdates();
                }
            }
            break;
        case LAYER_TYPE_SOFTWARE:
            buildDrawingCache(true);
            break;
    }
}",1,"/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
","/**
 * Forces this view's layer to be created and this view to be rendered
 * into its layer. If this view's layer type is set to {@link #LAYER_TYPE_NONE},
 * invoking this method will have no effect.
 *
 * This method can for instance be used to render a view into its layer before
 * starting an animation. If this view is complex, rendering into the layer
 * before starting the animation will avoid skipping frames.
 *
 * @throws IllegalStateException If this view is not attached to a window
 *
 * @see #setLayerType(int, android.graphics.Paint)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An initialization is replaced by an assignment, the condition statement after 'if' has changed, and a new API (dispatchFlushHardwareLayerUpdates) was called, so the code change type is 1,3.","As there are additional functionality(actions) added in the LAYER_TYPE_HARDWARE case, this could potentially lead to a different behavior when function 'void buildLayer()' is invoked in this case, and CI type is 1."
527,<android.widget.GridLayout: int getAlignmentMode()>,18,19,<android.widget.GridLayout: int getAlignmentMode()>,<android.widget.GridLayout: int getAlignmentMode()>,0,"{
    return alignmentMode;
}","{
    return mAlignmentMode;
}",1,"/**
 * Returns the alignment mode.
 *
 * @return the alignment mode; either {@link #ALIGN_BOUNDS} or {@link #ALIGN_MARGINS}
 *
 * @see #ALIGN_BOUNDS
 * @see #ALIGN_MARGINS
 *
 * @see #setAlignmentMode(int)
 *
 * @attr ref android.R.styleable#GridLayout_alignmentMode
 */
","/**
 * Returns the alignment mode.
 *
 * @return the alignment mode; either {@link #ALIGN_BOUNDS} or {@link #ALIGN_MARGINS}
 *
 * @see #ALIGN_BOUNDS
 * @see #ALIGN_MARGINS
 *
 * @see #setAlignmentMode(int)
 *
 * @attr ref android.R.styleable#GridLayout_alignmentMode
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,The return statement has changed from returning alignmentMode to mAlignmentMode. So the code change type is 1.,"Since the returned variable has changed from alignmentMode to mAlignmentMode. This could potentially lead to return a different value in the late version, so the Compatibility Issue type is 1."
528,"<android.app.Activity: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>",18,19,"<android.app.Activity: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>","<android.app.Activity: LoaderManagerImpl getLoaderManager(String,boolean,boolean)>",0,"{
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new HashMap<String, LoaderManagerImpl>();
    }
    LoaderManagerImpl lm = mAllLoaderManagers.get(who);
    if (lm == null) {
        if (create) {
            lm = new LoaderManagerImpl(who, this, started);
            mAllLoaderManagers.put(who, lm);
        }
    } else {
        lm.updateActivity(this);
    }
    return lm;
}","{
    if (mAllLoaderManagers == null) {
        mAllLoaderManagers = new ArrayMap<String, LoaderManagerImpl>();
    }
    LoaderManagerImpl lm = mAllLoaderManagers.get(who);
    if (lm == null) {
        if (create) {
            lm = new LoaderManagerImpl(who, this, started);
            mAllLoaderManagers.put(who, lm);
        }
    } else {
        lm.updateActivity(this);
    }
    return lm;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The object type of mAllLoaderManagers has been changed from 'HashMap' to 'ArrayMap'. Except for the type of the container for storing LoaderManagerImpl, the rest of the code remained the same. Therefore, the code change type is 4.","Even though the type of mAllLoaderManagers has been changed, it doesn't affect the variable that the method returns nor the exceptions that could be thrown. Hence, there's no Compatibility Issue exist."
529,<android.animation.Animator: Animator clone()>,18,19,<android.animation.Animator: Animator clone()>,<android.animation.Animator: Animator clone()>,0,"{
    try {
        final Animator anim = (Animator) super.clone();
        if (mListeners != null) {
            ArrayList<AnimatorListener> oldListeners = mListeners;
            anim.mListeners = new ArrayList<AnimatorListener>();
            int numListeners = oldListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                anim.mListeners.add(oldListeners.get(i));
            }
        }
        return anim;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}","{
    try {
        final Animator anim = (Animator) super.clone();
        if (mListeners != null) {
            ArrayList<AnimatorListener> oldListeners = mListeners;
            anim.mListeners = new ArrayList<AnimatorListener>();
            int numListeners = oldListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                anim.mListeners.add(oldListeners.get(i));
            }
        }
        if (mPauseListeners != null) {
            ArrayList<AnimatorPauseListener> oldListeners = mPauseListeners;
            anim.mPauseListeners = new ArrayList<AnimatorPauseListener>();
            int numListeners = oldListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                anim.mPauseListeners.add(oldListeners.get(i));
            }
        }
        return anim;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version implementation includes an additional set of operations when 'mPauseListeners' is not null. This modification introduces new clone operations for 'mPauseListeners', which falls under the category 1 and 4.","Because of the new clone operation added in the late version for mPauseListeners, the returned Animator object from the clone() method can potentially be different between the early and late versions, leading to a CI of type 1."
531,<android.content.ClipboardManager: ClipData getPrimaryClip()>,18,19,<android.content.ClipboardManager: ClipData getPrimaryClip()>,<android.content.ClipboardManager: ClipData getPrimaryClip()>,0,"{
    try {
        return getService().getPrimaryClip(mContext.getBasePackageName());
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Returns the current primary clip on the clipboard.
 */
","/**
 * Returns the current primary clip on the clipboard.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement inside the try block has changed from mContext.getBasePackageName() to mContext.getOpPackageName(), and the called function in return statement has also changed from getBasePackageName() to getOpPackageName(), so the code change type is 1,5.","The change of return statement will make the API potentially return a different object, so the CI type is 1."
534,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",18,19,"<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.TextViewDrawableAction: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final Context context = root.getContext();
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (isRelative) {
        target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
    } else {
        target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
    }
}","{
    final TextView target = (TextView) root.findViewById(viewId);
    if (target == null)
        return;
    if (isRelative) {
        target.setCompoundDrawablesRelativeWithIntrinsicBounds(d1, d2, d3, d4);
    } else {
        target.setCompoundDrawablesWithIntrinsicBounds(d1, d2, d3, d4);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A statement (final Context context = root.getContext();) is removed in the late version. Therefore, the code change type is 4.","The removed statement is irrelevant to the returned values or exception handlings of the API. Therefore, the CI type is 0."
535,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",18,19,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>","<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    performClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    performLongClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                if (!isAccessibilityFocused()) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, true, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, false, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                // Only cursor position can be specified (selection length == 0)
                if ((getAccessibilitySelectionStart() != start || getAccessibilitySelectionEnd() != end) && (start == end)) {
                    setAccessibilitySelection(start, end);
                    notifyAccessibilityStateChanged();
                    return true;
                }
            }
            break;
    }
    return false;
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    performClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    performLongClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                if (!isAccessibilityFocused()) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, true, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    final boolean extendSelection = arguments.getBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN);
                    return traverseAtGranularity(granularity, false, extendSelection);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                // Only cursor position can be specified (selection length == 0)
                if ((getAccessibilitySelectionStart() != start || getAccessibilitySelectionEnd() != end) && (start == end)) {
                    setAccessibilitySelection(start, end);
                    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
                    return true;
                }
            }
            break;
    }
    return false;
}",1,"/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method notifyAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED) has replaced notifyAccessibilityStateChanged() inside ACTION_SET_SELECTION case, which is categorized as Other statement changed (case 4).","No Compatibility Issue exists here because the replaced method only modifies the behavior of notifying the accessibility state change, which does not produce different return values or exception handlings (case 0)."
536,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",18,19,"<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>","<android.content.ContentProviderClient: ParcelFileDescriptor openFile(Uri,String)>",0,"{
    try {
        return mContentProvider.openFile(mPackageName, url, mode);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    return openFile(url, mode, null);
}",1,"/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
","/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5","1,2","There is a change in the return statement, from a method call to another method. Also, the handling for DeadObjectException, the 'try-catch' block has been entirely removed. In addition, the dependent API, mContentProvider.openFile() has been replaced by a diffrent API, openFile(). Therefore, the change types are 1,4,5.","The openFile() implementation in early and late versions will potentially return different results because they call different methods. Moreover, the new version could behave differently when an exception occurs since the exception handling mechanism has been changed. Consequently, the CI types are 1,2."
538,<android.widget.AbsListView: float getBottomFadingEdgeStrength()>,18,19,<android.widget.AbsListView: float getBottomFadingEdgeStrength()>,<android.widget.AbsListView: float getBottomFadingEdgeStrength()>,0,"{
    final int count = getChildCount();
    final float fadeEdge = super.getBottomFadingEdgeStrength();
    if (count == 0) {
        return fadeEdge;
    } else {
        if (mFirstPosition + count - 1 < mItemCount - 1) {
            return 1.0f;
        }
        final int bottom = getChildAt(count - 1).getBottom();
        final int height = getHeight();
        final float fadeLength = (float) getVerticalFadingEdgeLength();
        return bottom > height - mPaddingBottom ? (float) (bottom - height + mPaddingBottom) / fadeLength : fadeEdge;
    }
}","{
    final int count = getChildCount();
    final float fadeEdge = super.getBottomFadingEdgeStrength();
    if (count == 0) {
        return fadeEdge;
    } else {
        if (mFirstPosition + count - 1 < mItemCount - 1) {
            return 1.0f;
        }
        final int bottom = getChildAt(count - 1).getBottom();
        final int height = getHeight();
        final float fadeLength = getVerticalFadingEdgeLength();
        return bottom > height - mPaddingBottom ? (bottom - height + mPaddingBottom) / fadeLength : fadeEdge;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The change is located at the line where float 'fadeLength' is initialized. In the early version, the getVerticalFadingEdgeLength() method is explicitly cast to float, but in the late version, the explicit cast has been removed. Hence, the code change type is 4.","This change could potentially lead to different behavior when the 'fadeLength' is used in calculations, thus changing the return value. Therefore, the CI type is 1."
539,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,18,19,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createPipe()>,0,"{
    FileDescriptor[] fds = new FileDescriptor[2];
    createPipeNative(fds);
    ParcelFileDescriptor[] pfds = new ParcelFileDescriptor[2];
    pfds[0] = new ParcelFileDescriptor(fds[0]);
    pfds[1] = new ParcelFileDescriptor(fds[1]);
    return pfds;
}","{
    try {
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the late version, the early implementation of creating the pipe has been replaced with a try-catch block where the pipe is created using Libcore.os.pipe(). Also, a new exception handling statement ""throw e.rethrowAsIOException();"" has been added. So the change types are 1,2,4.","The changes in the return statement (i.e., pipe creation mechanism) might cause the API to return a different value or type which results in a Compatibility Issue caused by potential different return values or types (1). Additionally, the added exception handling mechanism has induced another Compatibility Issue caused by potential different exception handlings (2). So the CI types are 1,2."
540,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,18,19,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,<android.bluetooth.BluetoothGatt: boolean writeDescriptor(BluetoothGattDescriptor)>,0,"{
    if (DBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""writeDescriptor() - uuid: "" + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
","/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The dependent API ""mService.writeDescriptor"" has been modified, so the code change type is 4.","As the dependent API “mService.writeDescriptor” has been modified, it may cause a potential return of a different value, hence the compatibility issue of type 1 exists."
541,"<android.preference.PreferenceActivity: void onListItemClick(ListView,View,int,long)>",18,19,"<android.preference.PreferenceActivity: void onListItemClick(ListView,View,int,long)>","<android.preference.PreferenceActivity: void onListItemClick(ListView,View,int,long)>",0,"{
    super.onListItemClick(l, v, position, id);
    if (mAdapter != null) {
        Object item = mAdapter.getItem(position);
        if (item instanceof Header)
            onHeaderClick((Header) item, position);
    }
}","{
    if (!isResumed()) {
        return;
    }
    super.onListItemClick(l, v, position, id);
    if (mAdapter != null) {
        Object item = mAdapter.getItem(position);
        if (item instanceof Header)
            onHeaderClick((Header) item, position);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement `return;` is introduced after a new conditional check `!isResumed()`, so the code change type is 1,3.","As the new conditional check and return statement is added, it might lead to the situation where the method returns before executing the remaining instructions (which was not the case in the earlier version). Consequently, the functionality will be different, hence the CI type 1 (potential different return values)."
543,<android.view.ScaleGestureDetector: float getScaleFactor()>,18,19,<android.view.ScaleGestureDetector: float getScaleFactor()>,<android.view.ScaleGestureDetector: float getScaleFactor()>,0,"{
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}","{
    if (inDoubleTapMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}",1,"/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
","/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"There is a new if condition that includes some return statements, and the original return statement has been moved inside the 'else' scope without changes, so we have both Control dependency and Return statement changed, hence the change type is 1,3.","The newly introduced if condition and its return statements may lead to the function returning a different value than before, thus leading to the potential compatibility issue type 1. The function will respond differently during the double tap mode leading to different return value."
544,<android.widget.AbsListView: boolean isFastScrollEnabled()>,18,19,<android.widget.AbsListView: boolean isFastScrollEnabled()>,<android.widget.AbsListView: boolean isFastScrollEnabled()>,0,"{
    return mFastScrollEnabled;
}","{
    if (mFastScroller == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroller.isEnabled();
    }
}",1,"/**
 * Returns the current state of the fast scroll feature.
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */
","/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */
",-1,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],-1,-1,-1,-1,-1,-1,"1,3",1,"The implementation added a conditional 'if-else' block to check `mFastScroller` before returning `mFastScrollEnabled`. If `mFastScroller` is null, it returns `mFastScrollEnabled`, else it returns the `isEnabled()` method of `mFastScroller`. This represents a change in control dependency (changing the execution flow) and return statement.","The introduction of the control statement impacts the output return of the function. In the previous version, the function always returns `mFastScrollEnabled`. However, in the later version, the function may return the result of `isEnabled()` method of `mFastScroller` instead. Hence this change can lead to different returned values or types, causing a Compatibility Issue type 1."
545,<android.widget.CompoundButton: void setChecked(boolean)>,18,19,<android.widget.CompoundButton: void setChecked(boolean)>,<android.widget.CompoundButton: void setChecked(boolean)>,0,"{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        notifyAccessibilityStateChanged();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}","{
    if (mChecked != checked) {
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        mBroadcasting = false;
    }
}",1,"/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
","/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,No Compatibility Issue exist,"Only the notifyAccessibilityStateChanged() method call in the if condition changed to notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED) in the late version, so the change type is 4.","The change of method call is not related to the return statement or the exception handling, thus there is no Compatibility Issue."
546,<android.preference.PreferenceGroup: boolean onPrepareAddPreference(Preference)>,18,19,<android.preference.PreferenceGroup: boolean onPrepareAddPreference(Preference)>,<android.preference.PreferenceGroup: boolean onPrepareAddPreference(Preference)>,0,"{
    if (!super.isEnabled()) {
        preference.setEnabled(false);
    }
    return true;
}","{
    preference.onParentChanged(this, shouldDisableDependents());
    return true;
}",1,"/**
 * Prepares a {@link Preference} to be added to the group.
 *
 * @param preference The preference to add.
 * @return Whether to allow adding the preference (true), or not (false).
 */
","/**
 * Prepares a {@link Preference} to be added to the group.
 *
 * @param preference The preference to add.
 * @return Whether to allow adding the preference (true), or not (false).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the early version, the method checks if 'super' is not enabled, then disable 'preference'. In the late version, however, the method changes the preference's parent and checks if the parent should be disabled. Therefore, the changes in the methods involves the calling of another method, onParentChanged, with different arguments comparing to the early version method isEnabled. The change type here is 4,5.","Since different methods are invoked in different versions, the potential behavior of two versions might differ, which could lead to the return of different variables and consequently arises CI. The CI type here is 1."
547,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",18,19,"<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>","<android.app.DownloadManager: long addCompletedDownload(String,String,boolean,String,String,long,boolean)>",0,"{
    // make sure the input args are non-null/non-zero
    validateArgumentIsNonEmpty(""title"", title);
    validateArgumentIsNonEmpty(""description"", description);
    validateArgumentIsNonEmpty(""path"", path);
    validateArgumentIsNonEmpty(""mimeType"", mimeType);
    if (length < 0) {
        throw new IllegalArgumentException("" invalid value for param: totalBytes"");
    }
    // if there is already an entry with the given path name in downloads.db, return its id
    Request request = new Request(NON_DOWNLOADMANAGER_DOWNLOAD).setTitle(title).setDescription(description).setMimeType(mimeType);
    ContentValues values = request.toContentValues(null);
    values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);
    values.put(Downloads.Impl._DATA, path);
    values.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);
    values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, length);
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (isMediaScannerScannable) ? Request.SCANNABLE_VALUE_YES : Request.SCANNABLE_VALUE_NO);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, (showNotification) ? Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION : Request.VISIBILITY_HIDDEN);
    Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
    if (downloadUri == null) {
        return -1;
    }
    return Long.parseLong(downloadUri.getLastPathSegment());
}","{
    return addCompletedDownload(title, description, isMediaScannerScannable, mimeType, path, length, showNotification, false);
}",1,"/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
","/**
 * Adds a file to the downloads database system, so it could appear in Downloads App
 * (and thus become eligible for management by the Downloads App).
 * <p>
 * It is helpful to make the file scannable by MediaScanner by setting the param
 * isMediaScannerScannable to true. It makes the file visible in media managing
 * applications such as Gallery App, which could be a useful purpose of using this API.
 *
 * @param title the title that would appear for this file in Downloads App.
 * @param description the description that would appear for this file in Downloads App.
 * @param isMediaScannerScannable true if the file is to be scanned by MediaScanner. Files
 * scanned by MediaScanner appear in the applications used to view media (for example,
 * Gallery app).
 * @param mimeType mimetype of the file.
 * @param path absolute pathname to the file. The file should be world-readable, so that it can
 * be managed by the Downloads App and any other app that is used to read it (for example,
 * Gallery app to display the file, if the file contents represent a video/image).
 * @param length length of the downloaded file
 * @param showNotification true if a notification is to be sent, false otherwise
 * @return  an ID for the download entry added to the downloads app, unique across the system
 * This ID is used to make future calls related to this download.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation includes an elaborate code for validating inputs and assigning variables. In contrast, late implementation uses the method addCompletedDownload() which is a dependent API. The behavior of the API depends on the implementation of addCompletedDownload(). Hence, the change types are 1 and 5.","Given the implementation of the later version is based on the implementation of dependent API addCompletedDownload(), if the result of the dependent API changes, the return value of the current one can also change. Therefore, this change can possibly bring compatibility issues, and the type is 1."
548,<android.view.GLES20TextureLayer: SurfaceTexture getSurfaceTexture()>,18,19,<android.view.GLES20TextureLayer: SurfaceTexture getSurfaceTexture()>,<android.view.GLES20TextureLayer: SurfaceTexture getSurfaceTexture()>,0,"{
    if (mSurface == null) {
        mSurface = new SurfaceTexture(mTexture, false);
    }
    return mSurface;
}","{
    if (mSurface == null) {
        mSurface = new SurfaceTexture(mTexture);
    }
    return mSurface;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API SurfaceTexture() has its parameters changed, which used to take two arguments (mTexture and 'false') and now only takes one argument (mTexture). So, the code change type is 5.","This change in the dependent API SurfaceTexture() could potentially cause the API to return a different value, since the new instance of SurfaceTexture created could behave differently due to the missing 'false' argument. Therefore, the CI type is 1."
549,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,18,19,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,<android.view.View: boolean dispatchHoverEvent(MotionEvent)>,0,"{
    // noinspection SimplifiableIfStatement
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}","{
    ListenerInfo li = mListenerInfo;
    // noinspection SimplifiableIfStatement
    if (li != null && li.mOnHoverListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnHoverListener.onHover(this, event)) {
        return true;
    }
    return onHoverEvent(event);
}",1,"/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a hover event.
 * <p>
 * Do not call this method directly.
 * Call {@link #dispatchGenericMotionEvent(MotionEvent)} instead.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no actual code changes in the implementation, it's just the location of comment line has been moved, so the code change type is 0.","Since the API implementation has not been changed, the version updates do not cause any compatibility issues. So the CI type is 0."
550,<android.os.RemoteCallbackList: int beginBroadcast()>,18,19,<android.os.RemoteCallbackList: int beginBroadcast()>,<android.os.RemoteCallbackList: int beginBroadcast()>,0,"{
    synchronized (mCallbacks) {
        if (mBroadcastCount > 0) {
            throw new IllegalStateException(""beginBroadcast() called while already in a broadcast"");
        }
        final int N = mBroadcastCount = mCallbacks.size();
        if (N <= 0) {
            return 0;
        }
        Object[] active = mActiveBroadcast;
        if (active == null || active.length < N) {
            mActiveBroadcast = active = new Object[N];
        }
        int i = 0;
        for (Callback cb : mCallbacks.values()) {
            active[i++] = cb;
        }
        return i;
    }
}","{
    synchronized (mCallbacks) {
        if (mBroadcastCount > 0) {
            throw new IllegalStateException(""beginBroadcast() called while already in a broadcast"");
        }
        final int N = mBroadcastCount = mCallbacks.size();
        if (N <= 0) {
            return 0;
        }
        Object[] active = mActiveBroadcast;
        if (active == null || active.length < N) {
            mActiveBroadcast = active = new Object[N];
        }
        for (int i = 0; i < N; i++) {
            active[i] = mCallbacks.valueAt(i);
        }
        return N;
    }
}",1,"/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
","/**
 * Prepare to start making calls to the currently registered callbacks.
 * This creates a copy of the callback list, which you can retrieve items
 * from using {@link #getBroadcastItem}.  Note that only one broadcast can
 * be active at a time, so you must be sure to always call this from the
 * same thread (usually by scheduling with {@link Handler}) or
 * do your own synchronization.  You must call {@link #finishBroadcast}
 * when done.
 *
 * <p>A typical loop delivering a broadcast looks like this:
 *
 * <pre>
 * int i = callbacks.beginBroadcast();
 * while (i &gt; 0) {
 * i--;
 * try {
 * callbacks.getBroadcastItem(i).somethingHappened();
 * } catch (RemoteException e) {
 * // The RemoteCallbackList will take care of removing
 * // the dead object for us.
 * }
 * }
 * callbacks.finishBroadcast();</pre>
 *
 * @return Returns the number of callbacks in the broadcast, to be used
 * with {@link #getBroadcastItem} to determine the range of indices you
 * can supply.
 *
 * @see #getBroadcastItem
 * @see #finishBroadcast
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The assignments of active array elements and the return statement have changed in the late version. A for-each loop is replaced by a for-loop, so the change type is 1,3,4.","As the assignments of active array elements and the return statement have changed, the API potentially returns different values in the two versions. Therefore, the CI type is 1."
551,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,18,19,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,<android.util.TimeUtils: String getTimeZoneDatabaseVersion()>,0,"{
    return ZoneInfoDB.getVersion();
}","{
    return ZoneInfoDB.getInstance().getVersion();
}",1,"/**
 * Returns a String indicating the version of the time zone database currently
 * in use.  The format of the string is dependent on the underlying time zone
 * database implementation, but will typically contain the year in which the database
 * was updated plus a letter from a to z indicating changes made within that year.
 *
 * <p>Time zone database updates should be expected to occur periodically due to
 * political and legal changes that cannot be anticipated in advance.  Therefore,
 * when computing the UTC time for a future event, applications should be aware that
 * the results may differ following a time zone database update.  This method allows
 * applications to detect that a database change has occurred, and to recalculate any
 * cached times accordingly.
 *
 * <p>The time zone database may be assumed to change only when the device runtime
 * is restarted.  Therefore, it is not necessary to re-query the database version
 * during the lifetime of an activity.
 */
","/**
 * Returns a String indicating the version of the time zone database currently
 * in use.  The format of the string is dependent on the underlying time zone
 * database implementation, but will typically contain the year in which the database
 * was updated plus a letter from a to z indicating changes made within that year.
 *
 * <p>Time zone database updates should be expected to occur periodically due to
 * political and legal changes that cannot be anticipated in advance.  Therefore,
 * when computing the UTC time for a future event, applications should be aware that
 * the results may differ following a time zone database update.  This method allows
 * applications to detect that a database change has occurred, and to recalculate any
 * cached times accordingly.
 *
 * <p>The time zone database may be assumed to change only when the device runtime
 * is restarted.  Therefore, it is not necessary to re-query the database version
 * during the lifetime of an activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent method call ZoneInfoDB.getVersion() has been changed to ZoneInfoDB.getInstance().getVersion(), so the code change type is 1,5.","The dependent method, which is called by this method, has changed. This may cause differences in the returned value. Thus, this change belongs to CI type 1."
552,<android.os.MessageQueue: void quit(boolean)>,18,19,<android.os.MessageQueue: void quit(boolean)>,<android.os.MessageQueue: void quit(boolean)>,0,"{
    if (!mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit."");
    }
    synchronized (this) {
        if (mQuiting) {
            return;
        }
        mQuiting = true;
        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }
    }
    nativeWake(mPtr);
}","{
    if (!mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit."");
    }
    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;
        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }
        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code changes are the spelling change of variable 'mQuiting' to 'mQuitting', and relocation of the nativeWake(mPtr) command within the synchronized statement. That falls under type 3 and 4 changes.","Since these changes do not alter the API's behavior, return value, or exception handling, no compatibility issue (CI) exists. Thus, the CI type is 0."
553,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",18,19,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
","/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method s.setNpnProtocols(mNpnProtocols) has been replaced with s.setAlpnProtocols(mAlpnProtocols) which means one method has been removed and a new one has been added. The return statement hasn't changed but the properties of the returned object are altered. Thus, the change type is 1,4.","The change caused the behavior of the created Socket 's' to potentially behave differently since the method that sets the protocols has been replaced, thus potentially causing the API method to return a different object (even though the object's type is the same). Therefore, the CI type is 1."
554,<android.util.Log: String getStackTraceString(Throwable)>,18,19,<android.util.Log: String getStackTraceString(Throwable)>,<android.util.Log: String getStackTraceString(Throwable)>,0,"{
    if (tr == null) {
        return """";
    }
    // This is to reduce the amount of log spew that apps do in the non-error
    // condition of the network being unavailable.
    Throwable t = tr;
    while (t != null) {
        if (t instanceof UnknownHostException) {
            return """";
        }
        t = t.getCause();
    }
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    tr.printStackTrace(pw);
    return sw.toString();
}","{
    if (tr == null) {
        return """";
    }
    // This is to reduce the amount of log spew that apps do in the non-error
    // condition of the network being unavailable.
    Throwable t = tr;
    while (t != null) {
        if (t instanceof UnknownHostException) {
            return """";
        }
        t = t.getCause();
    }
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    tr.printStackTrace(pw);
    pw.flush();
    return sw.toString();
}",1,"/**
 * Handy function to get a loggable stack trace from a Throwable
 * @param tr An exception to log
 */
","/**
 * Handy function to get a loggable stack trace from a Throwable
 * @param tr An exception to log
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,The PrintWriter object is created differently in the Late_Implementation by passing more parameters to the FastPrintWriter constructor. This is considered as dependent API changed.,"This code change potentially leads to the API returning a different value as PrintWriter behavior might have changed with different parameters used for its creation. Hence, Compatibility Issue caused by potential different return values."
555,<android.os.ParcelFileDescriptor: int getFd()>,18,19,<android.os.ParcelFileDescriptor: int getFd()>,<android.os.ParcelFileDescriptor: int getFd()>,0,"{
    if (mClosed) {
        throw new IllegalStateException(""Already closed"");
    }
    return getFdNative();
}","{
    if (mWrapped != null) {
        return mWrapped.getFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException(""Already closed"");
        }
        return mFd.getInt$();
    }
}",1,"/**
 * Return the native fd int for this ParcelFileDescriptor.  The
 * ParcelFileDescriptor still owns the fd, and it still must be closed
 * through this API.
 */
","/**
 * Return the native fd int for this ParcelFileDescriptor.  The
 * ParcelFileDescriptor still owns the fd, and it still must be closed
 * through this API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3","1,2","The addition of a new control dependency (if statement) that now considers the mWrapped instance. A new method 'mWrapped.getFd()' is added, as well as a new return statement 'return mFd.getInt$()' instead of 'return getFdNative();'. So the code change type is 1,3.","The changes could potentially cause a different return value or type because the 'getFd()' method could now return from mWrapped instance or through the mFd.getInt$(). Moreover, the initial if statement, which checks the close status and throws an exception, has been nested inside another condition block. This can change the exception handling behaviour. Therefore, the CI type is 1,2."
556,"<android.inputmethodservice.IInputMethodWrapper: void setSessionEnabled(IInputMethodSession,boolean)>",18,19,"<android.inputmethodservice.IInputMethodWrapper: void setSessionEnabled(IInputMethodSession,boolean)>","<android.inputmethodservice.IInputMethodWrapper: void setSessionEnabled(IInputMethodSession,boolean)>",0,"{
    try {
        InputMethodSession ls = ((IInputMethodSessionWrapper) session).getInternalInputMethodSession();
        mCaller.executeOrSendMessage(mCaller.obtainMessageIO(DO_SET_SESSION_ENABLED, enabled ? 1 : 0, ls));
    } catch (ClassCastException e) {
        Log.w(TAG, ""Incoming session not of correct type: "" + session, e);
    }
}","{
    try {
        InputMethodSession ls = ((IInputMethodSessionWrapper) session).getInternalInputMethodSession();
        if (ls == null) {
            Log.w(TAG, ""Session is already finished: "" + session);
            return;
        }
        mCaller.executeOrSendMessage(mCaller.obtainMessageIO(DO_SET_SESSION_ENABLED, enabled ? 1 : 0, ls));
    } catch (ClassCastException e) {
        Log.w(TAG, ""Incoming session not of correct type: "" + session, e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 3",1,"A new control statement (if) and an extra return statement have been introduced in the late version of the API, the code change type is 1,3.","The late version introduces a condition where the function could return earlier, potentially changing the behaviour of the API, hence the CI type is 1."
558,"<android.content.IntentFilter: void addDataAuthority(String,String)>",18,19,"<android.content.IntentFilter: void addDataAuthority(String,String)>","<android.content.IntentFilter: void addDataAuthority(String,String)>",0,"{
    if (mDataAuthorities == null)
        mDataAuthorities = new ArrayList<AuthorityEntry>();
    if (port != null)
        port = port.intern();
    mDataAuthorities.add(new AuthorityEntry(host.intern(), port));
}","{
    if (port != null)
        port = port.intern();
    addDataAuthority(new AuthorityEntry(host.intern(), port));
}",1,"/**
 * Add a new Intent data authority to match against.  The filter must
 * include one or more schemes (via {@link #addDataScheme}) for the
 * authority to be considered.  If any authorities are
 * included in the filter, then an Intent's data must match one of
 * them.  If no authorities are included, then only the scheme must match.
 *
 * <p><em>Note: host name in the Android framework is
 * case-sensitive, unlike formal RFC host names.  As a result,
 * you should always write your host names with lower case letters,
 * and any host names you receive from outside of Android should be
 * converted to lower case before supplying them here.</em></p>
 *
 * @param host The host part of the authority to match.  May start with a
 * single '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, any
 * port is allowed.
 *
 * @see #matchData
 * @see #addDataScheme
 */
","/**
 * Add a new Intent data authority to match against.  The filter must
 * include one or more schemes (via {@link #addDataScheme}) for the
 * authority to be considered.  If any authorities are
 * included in the filter, then an Intent's data must match one of
 * them.  If no authorities are included, then only the scheme must match.
 *
 * <p><em>Note: host name in the Android framework is
 * case-sensitive, unlike formal RFC host names.  As a result,
 * you should always write your host names with lower case letters,
 * and any host names you receive from outside of Android should be
 * converted to lower case before supplying them here.</em></p>
 *
 * @param host The host part of the authority to match.  May start with a
 * single '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, any
 * port is allowed.
 *
 * @see #matchData
 * @see #addDataScheme
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The early version has an additional initialisation sequence for `mDataAuthorities` if it is null, which is removed in the later version. Instead, the later version calls `addDataAuthority()` which is a different method usage in comparison to the early version's `mDataAuthorities.add()`. Hence, the change types are 1 (Return statement changed) and 4 (Other statement changed).","There is no Compatibility Issue (CI) since there is no change that could result in a different behaviour. Both versions are adding an AuthorityEntry to mDataAuthorities. The way of adding is different, but it does not change the behaviour, therefore there should be no Compatibility Issue."
559,"<android.view.View: void setFlags(int,int)>",18,19,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            notifyAccessibilityStateChanged();
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled() && ((changed & FOCUSABLE) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & ENABLED) != 0)) {
        notifyAccessibilityStateChanged();
    }
}","{
    final boolean accessibilityEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    final boolean oldIncludeForAccessibility = accessibilityEnabled && includeForAccessibility();
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    final int newVisibility = flags & VISIBILITY_MASK;
    if (newVisibility == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE)) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                if (hasFocus())
                    clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        // If the view is invisible, cleanup its display list to free up resources
        if (newVisibility != VISIBLE) {
            cleanupDraw();
        }
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), newVisibility);
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, newVisibility);
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (accessibilityEnabled) {
        if ((changed & FOCUSABLE_MASK) != 0 || (changed & VISIBILITY_MASK) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0) {
            if (oldIncludeForAccessibility != includeForAccessibility()) {
                notifySubtreeAccessibilityStateChangedIfNeeded();
            } else {
                notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
            }
        } else if ((changed & ENABLED_MASK) != 0) {
            notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        }
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The functionality of the method is not changed, but there are changes inside if clauses, for example, 'final int newVisibility = flags & VISIBILITY_MASK;'. So the code change type is 3,4.","Although the implementation has been optimized, the public behavior is not affected, as the same output is guaranteed for the same input, so there's no Compatibility Issue (CI type 0)."
560,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,18,19,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,<android.view.accessibility.AccessibilityRecord: AccessibilityNodeInfo getSource()>,0,"{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, GET_SOURCE_PREFETCH_FLAGS);
}","{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS);
}",1,"/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
","/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The last return statement has changed, where an extra argument 'false' has been added to the invoke of findAccessibilityNodeInfoByAccessibilityId() method, thus, the code change type is 1,5.","The change in dependent API method 'findAccessibilityNodeInfoByAccessibilityId()' could return a different value because of the introduction of new parameter 'false', thus, leading to a compatibility issue of type 1."
561,"<android.content.Intent: int fillIn(Intent,int)>",18,19,"<android.content.Intent: int fillIn(Intent,int)>","<android.content.Intent: int fillIn(Intent,int)>",0,"{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new HashSet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}","{
    int changes = 0;
    if (other.mAction != null && (mAction == null || (flags & FILL_IN_ACTION) != 0)) {
        mAction = other.mAction;
        changes |= FILL_IN_ACTION;
    }
    if ((other.mData != null || other.mType != null) && ((mData == null && mType == null) || (flags & FILL_IN_DATA) != 0)) {
        mData = other.mData;
        mType = other.mType;
        changes |= FILL_IN_DATA;
    }
    if (other.mCategories != null && (mCategories == null || (flags & FILL_IN_CATEGORIES) != 0)) {
        if (other.mCategories != null) {
            mCategories = new ArraySet<String>(other.mCategories);
        }
        changes |= FILL_IN_CATEGORIES;
    }
    if (other.mPackage != null && (mPackage == null || (flags & FILL_IN_PACKAGE) != 0)) {
        // Only do this if mSelector is not set.
        if (mSelector == null) {
            mPackage = other.mPackage;
            changes |= FILL_IN_PACKAGE;
        }
    }
    // for the same reason as the component name.
    if (other.mSelector != null && (flags & FILL_IN_SELECTOR) != 0) {
        if (mPackage == null) {
            mSelector = new Intent(other.mSelector);
            mPackage = null;
            changes |= FILL_IN_SELECTOR;
        }
    }
    if (other.mClipData != null && (mClipData == null || (flags & FILL_IN_CLIP_DATA) != 0)) {
        mClipData = other.mClipData;
        changes |= FILL_IN_CLIP_DATA;
    }
    // originator didn't intend.
    if (other.mComponent != null && (flags & FILL_IN_COMPONENT) != 0) {
        mComponent = other.mComponent;
        changes |= FILL_IN_COMPONENT;
    }
    mFlags |= other.mFlags;
    if (other.mSourceBounds != null && (mSourceBounds == null || (flags & FILL_IN_SOURCE_BOUNDS) != 0)) {
        mSourceBounds = new Rect(other.mSourceBounds);
        changes |= FILL_IN_SOURCE_BOUNDS;
    }
    if (mExtras == null) {
        if (other.mExtras != null) {
            mExtras = new Bundle(other.mExtras);
        }
    } else if (other.mExtras != null) {
        try {
            Bundle newb = new Bundle(other.mExtras);
            newb.putAll(mExtras);
            mExtras = newb;
        } catch (RuntimeException e) {
            // Modifying the extras can cause us to unparcel the contents
            // of the bundle, and if we do this in the system process that
            // may fail.  We really should handle this (i.e., the Bundle
            // impl shouldn't be on top of a plain map), but for now just
            // ignore it and keep the original contents. :(
            Log.w(""Intent"", ""Failure filling in extras"", e);
        }
    }
    return changes;
}",1,"/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
","/**
 * Copy the contents of <var>other</var> in to this object, but only
 * where fields are not defined by this object.  For purposes of a field
 * being defined, the following pieces of data in the Intent are
 * considered to be separate fields:
 *
 * <ul>
 * <li> action, as set by {@link #setAction}.
 * <li> data Uri and MIME type, as set by {@link #setData(Uri)},
 * {@link #setType(String)}, or {@link #setDataAndType(Uri, String)}.
 * <li> categories, as set by {@link #addCategory}.
 * <li> package, as set by {@link #setPackage}.
 * <li> component, as set by {@link #setComponent(ComponentName)} or
 * related methods.
 * <li> source bounds, as set by {@link #setSourceBounds}.
 * <li> selector, as set by {@link #setSelector(Intent)}.
 * <li> clip data, as set by {@link #setClipData(ClipData)}.
 * <li> each top-level name in the associated extras.
 * </ul>
 *
 * <p>In addition, you can use the {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS},
 * {@link #FILL_IN_SELECTOR}, and {@link #FILL_IN_CLIP_DATA} to override
 * the restriction where the corresponding field will not be replaced if
 * it is already set.
 *
 * <p>Note: The component field will only be copied if {@link #FILL_IN_COMPONENT}
 * is explicitly specified.  The selector will only be copied if
 * {@link #FILL_IN_SELECTOR} is explicitly specified.
 *
 * <p>For example, consider Intent A with {data=""foo"", categories=""bar""}
 * and Intent B with {action=""gotit"", data-type=""some/thing"",
 * categories=""one"",""two""}.
 *
 * <p>Calling A.fillIn(B, Intent.FILL_IN_DATA) will result in A now
 * containing: {action=""gotit"", data-type=""some/thing"",
 * categories=""bar""}.
 *
 * @param other Another Intent whose values are to be used to fill in
 * the current one.
 * @param flags Options to control which fields can be filled in.
 *
 * @return Returns a bit mask of {@link #FILL_IN_ACTION},
 * {@link #FILL_IN_DATA}, {@link #FILL_IN_CATEGORIES}, {@link #FILL_IN_PACKAGE},
 * {@link #FILL_IN_COMPONENT}, {@link #FILL_IN_SOURCE_BOUNDS}, and
 * {@link #FILL_IN_SELECTOR} indicating which fields were changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The data structure used to contain the mCategories set has changed from HashSet<String> to ArraySet<String>, so the code change type is 4.","No compatibility issues exist as the return value on both implementations remains the same, neither do they change the nature of any exceptions being thrown, so the CI type is 0."
562,<android.view.Surface: boolean isValid()>,18,19,<android.view.Surface: boolean isValid()>,<android.view.Surface: boolean isValid()>,0,"{
    synchronized (mLock) {
        if (mNativeSurface == 0)
            return false;
        return nativeIsValid(mNativeSurface);
    }
}","{
    synchronized (mLock) {
        if (mNativeObject == 0)
            return false;
        return nativeIsValid(mNativeObject);
    }
}",1,"/**
 * Returns true if this object holds a valid surface.
 *
 * @return True if it holds a physical surface, so lockCanvas() will succeed.
 * Otherwise returns false.
 */
","/**
 * Returns true if this object holds a valid surface.
 *
 * @return True if it holds a physical surface, so lockCanvas() will succeed.
 * Otherwise returns false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name has been changed from mNativeSurface to mNativeObject, but it does not affect the function and return execution of the API, so the code change type is 4. ","Although the variable name has been changed, there is no change in the functional behaviour of the API under the same input conditions, so no Compatibility Issue exists."
563,"<android.util.SparseArray: void put(int,E)>",18,19,"<android.util.SparseArray: void put(int,E)>","<android.util.SparseArray: void put(int,E)>",0,"{
    int i = binarySearch(mKeys, 0, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~binarySearch(mKeys, 0, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}","{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            Object[] nvalues = new Object[n];
            // Log.e(""SparseArray"", ""grow "" + mKeys.length + "" to "" + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e(""SparseArray"", ""move "" + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}",1,"/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
","/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API binarySearch() has called from different classes ('ContainerHelpers' in the late version instead of being directly called in early version), so the change type is 4,5.","Although the called class of the API binarySearch has changed, it doesn't lead to a different return value or exception, so there is no CI issue."
566,"<android.util.Log: int wtf(String,String)>",18,19,"<android.util.Log: int wtf(String,String)>","<android.util.Log: int wtf(String,String)>",0,"{
    return wtf(tag, msg, null);
}","{
    return wtf(LOG_ID_MAIN, tag, msg, null, false);
}",1,"/**
 * What a Terrible Failure: Report a condition that should never happen.
 * The error will always be logged at level ASSERT with the call stack.
 * Depending on system configuration, a report may be added to the
 * {@link android.os.DropBoxManager} and/or the process may be terminated
 * immediately with an error dialog.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 */
","/**
 * What a Terrible Failure: Report a condition that should never happen.
 * The error will always be logged at level ASSERT with the call stack.
 * Depending on system configuration, a report may be added to the
 * {@link android.os.DropBoxManager} and/or the process may be terminated
 * immediately with an error dialog.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, and the dependent method ""wtf"" implementation also seems to have undergone a change as the parameter list has increased, so the code change type is 1,5.","The change in return statement and the change in parameter list of ""wtf"" method could potentially return different values in different situations, so the CI type is 1."
567,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,18,19,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,0,"{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleSPSE(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the Late Version, two new conditions are added, so the code change type is 1,3.","As new conditions 'type == CHUNK_SPSS' and 'type == CHUNK_SPSE' have been added, this could return different results than the Early Version (potentially calling handleSPSS(request) or handleSPSE(request)), thus the CI type is 1."
568,"<android.nfc.NdefRecord: NdefRecord createMime(String,byte[])>",18,19,"<android.nfc.NdefRecord: NdefRecord createMime(String,byte[])>","<android.nfc.NdefRecord: NdefRecord createMime(String,byte[])>",0,"{
    if (mimeType == null)
        throw new NullPointerException(""mimeType is null"");
    // We only do basic MIME type validation: trying to follow the
    // RFCs strictly only ends in tears, since there are lots of MIME
    // types in common use that are not strictly valid as per RFC rules
    mimeType = Intent.normalizeMimeType(mimeType);
    if (mimeType.length() == 0)
        throw new IllegalArgumentException(""mimeType is empty"");
    int slashIndex = mimeType.indexOf('/');
    if (slashIndex == 0)
        throw new IllegalArgumentException(""mimeType must have major type"");
    if (slashIndex == mimeType.length() - 1) {
        throw new IllegalArgumentException(""mimeType must have minor type"");
    }
    // missing '/' is allowed
    // MIME RFCs suggest ASCII encoding for content-type
    byte[] typeBytes = mimeType.getBytes(Charsets.US_ASCII);
    return new NdefRecord(TNF_MIME_MEDIA, typeBytes, null, mimeData);
}","{
    if (mimeType == null)
        throw new NullPointerException(""mimeType is null"");
    // We only do basic MIME type validation: trying to follow the
    // RFCs strictly only ends in tears, since there are lots of MIME
    // types in common use that are not strictly valid as per RFC rules
    mimeType = Intent.normalizeMimeType(mimeType);
    if (mimeType.length() == 0)
        throw new IllegalArgumentException(""mimeType is empty"");
    int slashIndex = mimeType.indexOf('/');
    if (slashIndex == 0)
        throw new IllegalArgumentException(""mimeType must have major type"");
    if (slashIndex == mimeType.length() - 1) {
        throw new IllegalArgumentException(""mimeType must have minor type"");
    }
    // missing '/' is allowed
    // MIME RFCs suggest ASCII encoding for content-type
    byte[] typeBytes = mimeType.getBytes(StandardCharsets.US_ASCII);
    return new NdefRecord(TNF_MIME_MEDIA, typeBytes, null, mimeData);
}",1,"/**
 * Create a new NDEF Record containing MIME data.<p>
 * Use this method to encode MIME-typed data into an NDEF Record,
 * such as ""text/plain"", or ""image/jpeg"".<p>
 * The mimeType parameter will be normalized with
 * {@link Intent#normalizeMimeType} to follow Android best
 * practices for intent filtering, for example to force lower-case.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown
 * if the mimeType parameter has serious problems,
 * for example if it is empty, so always catch this
 * exception if you are passing user-generated data into this method.
 * <p>
 * For efficiency, This method might not make an internal copy of the
 * mimeData byte array, so take care not
 * to modify the mimeData byte array while still using the returned
 * NdefRecord.
 *
 * @param mimeType a valid MIME type
 * @param mimeData MIME data as bytes
 * @return an NDEF Record containing the MIME-typed data
 * @throws IllegalArugmentException if the mimeType is empty or invalid
 */
","/**
 * Create a new NDEF Record containing MIME data.<p>
 * Use this method to encode MIME-typed data into an NDEF Record,
 * such as ""text/plain"", or ""image/jpeg"".<p>
 * The mimeType parameter will be normalized with
 * {@link Intent#normalizeMimeType} to follow Android best
 * practices for intent filtering, for example to force lower-case.
 * However the unchecked exception
 * {@link IllegalArgumentException} may be thrown
 * if the mimeType parameter has serious problems,
 * for example if it is empty, so always catch this
 * exception if you are passing user-generated data into this method.
 * <p>
 * For efficiency, This method might not make an internal copy of the
 * mimeData byte array, so take care not
 * to modify the mimeData byte array while still using the returned
 * NdefRecord.
 *
 * @param mimeType a valid MIME type
 * @param mimeData MIME data as bytes
 * @return an NDEF Record containing the MIME-typed data
 * @throws IllegalArugmentException if the mimeType is empty or invalid
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0 ,The dependent API Charsets.US_ASCII changed to StandardCharsets.US_ASCII in late version. So the code change type is 5.,"Despite the change in the dependent API, the functionality of the method and what it returns remains the same, hence there is no compatibility issue. The CI type is 0."
569,<android.widget.HeaderViewListAdapter: Object getItem(int)>,18,19,<android.widget.HeaderViewListAdapter: Object getItem(int)>,<android.widget.HeaderViewListAdapter: Object getItem(int)>,0,"{
    // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).data;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getItem(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an ArrayIndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).data;
}","{
    // Header (negative positions will throw an IndexOutOfBoundsException)
    int numHeaders = getHeadersCount();
    if (position < numHeaders) {
        return mHeaderViewInfos.get(position).data;
    }
    // Adapter
    final int adjPosition = position - numHeaders;
    int adapterCount = 0;
    if (mAdapter != null) {
        adapterCount = mAdapter.getCount();
        if (adjPosition < adapterCount) {
            return mAdapter.getItem(adjPosition);
        }
    }
    // Footer (off-limits positions will throw an IndexOutOfBoundsException)
    return mFooterViewInfos.get(adjPosition - adapterCount).data;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The sole change between the two versions is in the comments, and this does not affect the actual code or its functionality. Therefore, the code has not really changed.","There is no change in the behaviour of the API; it does not return a different value or throw an exception differently in the two versions. Hence, there is no Compatibility Issue."
570,<android.view.accessibility.AccessibilityEvent: String toString()>,18,19,<android.view.accessibility.AccessibilityEvent: String toString()>,<android.view.accessibility.AccessibilityEvent: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(""; MovementGranularity: "").append(mMovementGranularity);
    builder.append(""; Action: "").append(mAction);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; mSourceNodeId: "").append(mSourceNodeId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The late implementation introduced a new statement `builder.append(""; ContentChangeTypes: "").append(mContentChangeTypes);`, so the code change type is 1.","The return statement of toString() method has potentially changed due to a new appended string, influencing the outcome of the `toString()` method, thus the type of compatibility issue is 1."
571,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,18,19,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,0,"{
    throwIfUserRequired();
    return sCurrentUser.getExternalStoragePublicDirectory(type);
}","{
    throwIfUserRequired();
    return sCurrentUser.buildExternalStoragePublicDirs(type)[0];
}",1,"/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
","/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method name of the dependent API has been changed, and the return statement also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
572,<android.net.LocalSocketImpl: void close()>,18,19,<android.net.LocalSocketImpl: void close()>,<android.net.LocalSocketImpl: void close()>,0,"{
    synchronized (LocalSocketImpl.this) {
        if (fd == null)
            return;
        close_native(fd);
        fd = null;
    }
}","{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Libcore.os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}",1,"/**
 * Closes the socket.
 *
 * @throws IOException
 */
","/**
 * Closes the socket.
 *
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The close_native(fd) from early version is replaced by Libcore.os.close(fd) in late version which is a dependent API change. There is also a change in control dependency as an extra condition mFdCreatedInternally == false is added in If statement. Moreover a new exception handling is introduced and the close_native(fd) function is replaced with Libcore.os.close(fd) which caused the return statement change. Hence, the change type is 1,2,3,5.","Replacing close_native(fd) with Libcore.os.close(fd) could potentially cause the API to return a different value, leading to a CI of type 1. Additionally, introducing a new exception handling mechanism e.rethrowAsIOException() could lead the API to throw a different exception, leading to a CI of type 2."
575,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",18,19,"<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>","<android.content.ContentProviderClient: Bundle call(String,String,Bundle)>",0,"{
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    }
}","{
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}",1,"/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
","/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,A new method beforeRemote() is called at the beginning of the implementation and a new method afterRemote() is added in the finally block. Hence the change falls into category 4 (Other statement changed).,"There is no Compatibility Issue introduced by this change, as inferring from the function names, beforeRemote() and afterRemote() are probably used for setup and teardown and they are not changing the behaviour of the API or the returned values or exceptions, hence CI type = 0 (No Compatibility Issue exist)."
576,<android.view.View: void sendAccessibilityEvent(int)>,18,19,<android.view.View: void sendAccessibilityEvent(int)>,<android.view.View: void sendAccessibilityEvent(int)>,0,"{
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);
    } else {
        sendAccessibilityEventInternal(eventType);
    }
}","{
    // Excluded views do not send accessibility events.
    if (!includeForAccessibility()) {
        return;
    }
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.sendAccessibilityEvent(this, eventType);
    } else {
        sendAccessibilityEventInternal(eventType);
    }
}",1,"/**
 * Sends an accessibility event of the given type. If accessibility is
 * not enabled this method has no effect. The default implementation calls
 * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)} first
 * to populate information about the event source (this View), then calls
 * {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)} to
 * populate the text content of the event source including its descendants,
 * and last calls
 * {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * on its parent to resuest sending of the event to interested parties.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#sendAccessibilityEvent(View, int)} is
 * responsible for handling this call.
 * </p>
 *
 * @param eventType The type of the event to send, as defined by several types from
 * {@link android.view.accessibility.AccessibilityEvent}, such as
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}.
 *
 * @see #onInitializeAccessibilityEvent(AccessibilityEvent)
 * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
 * @see ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)
 * @see AccessibilityDelegate
 */
","/**
 * Sends an accessibility event of the given type. If accessibility is
 * not enabled this method has no effect. The default implementation calls
 * {@link #onInitializeAccessibilityEvent(AccessibilityEvent)} first
 * to populate information about the event source (this View), then calls
 * {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)} to
 * populate the text content of the event source including its descendants,
 * and last calls
 * {@link ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * on its parent to resuest sending of the event to interested parties.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#sendAccessibilityEvent(View, int)} is
 * responsible for handling this call.
 * </p>
 *
 * @param eventType The type of the event to send, as defined by several types from
 * {@link android.view.accessibility.AccessibilityEvent}, such as
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_CLICKED} or
 * {@link android.view.accessibility.AccessibilityEvent#TYPE_VIEW_HOVER_ENTER}.
 *
 * @see #onInitializeAccessibilityEvent(AccessibilityEvent)
 * @see #dispatchPopulateAccessibilityEvent(AccessibilityEvent)
 * @see ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)
 * @see AccessibilityDelegate
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement has been introduced inside a new if condition (if (!includeForAccessibility())). Thus, it is classified into Return statement change (1) and Control dependency change (3). ","The introduced return statement can terminate the execution of the function earlier under certain circumstances, thus potentially leading to different behaviours when the late version API is invoked. Therefore, it is classified as CI caused by potential different return values (1)."
577,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,18,19,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,<android.view.accessibility.AccessibilityNodeInfo: AccessibilityNodeInfo getParent()>,0,"{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}","{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}",1,"/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
","/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement 'return client.findAccessibilityNodeInfoByAccessibilityId(...)' has changed and the parameters within the function call has changed which is a Dependent API changed. So the change type is 1,5.","The change in the return statement from one version to another may cause the API to potentially return a different result. Therefore, the Compatibility Issue type is 1."
579,<android.view.TextureView: HardwareLayer getHardwareLayer()>,18,19,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // Per SurfaceTexture's documentation, the callback may be invoked
                // from an arbitrary thread
                updateLayer();
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // Per SurfaceTexture's documentation, the callback may be invoked
                // from an arbitrary thread
                updateLayer();
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        mSurface.setDefaultBufferSize(getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The code has been changed from 'nSetDefaultBufferSize(mSurface, getWidth(), getHeight());' to 'mSurface.setDefaultBufferSize(getWidth(), getHeight());' and a similar change has been implemented elsewhere too. This involves a change in the method of a class, therefore, both categories 4 (Other statement changed) and 5 (Dependent API changed) are applicable.","The changing of methods 'nSetDefaultBufferSize' to 'setDefaultBufferSize' potentially leads the API return a different value, as these two methods may have different implementations, therefore the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
580,"<android.widget.AbsListView: void onTextChanged(CharSequence,int,int,int)>",18,19,"<android.widget.AbsListView: void onTextChanged(CharSequence,int,int,int)>","<android.widget.AbsListView: void onTextChanged(CharSequence,int,int,int)>",0,"{
    if (mPopup != null && isTextFilterEnabled()) {
        int length = s.length();
        boolean showing = mPopup.isShowing();
        if (!showing && length > 0) {
            // Show the filter popup if necessary
            showPopup();
            mFiltered = true;
        } else if (showing && length == 0) {
            // Remove the filter popup if the user has cleared all text
            dismissPopup();
            mFiltered = false;
        }
        if (mAdapter instanceof Filterable) {
            Filter f = ((Filterable) mAdapter).getFilter();
            // Filter should not be null when we reach this part
            if (f != null) {
                f.filter(s, this);
            } else {
                throw new IllegalStateException(""You cannot call onTextChanged with a non "" + ""filterable adapter"");
            }
        }
    }
}","{
    if (isTextFilterEnabled()) {
        createTextFilter(true);
        int length = s.length();
        boolean showing = mPopup.isShowing();
        if (!showing && length > 0) {
            // Show the filter popup if necessary
            showPopup();
            mFiltered = true;
        } else if (showing && length == 0) {
            // Remove the filter popup if the user has cleared all text
            dismissPopup();
            mFiltered = false;
        }
        if (mAdapter instanceof Filterable) {
            Filter f = ((Filterable) mAdapter).getFilter();
            // Filter should not be null when we reach this part
            if (f != null) {
                f.filter(s, this);
            } else {
                throw new IllegalStateException(""You cannot call onTextChanged with a non "" + ""filterable adapter"");
            }
        }
    }
}",1,"/**
 * For our text watcher that is associated with the text filter. Performs
 * the actual filtering as the text changes, and takes care of hiding and
 * showing the popup displaying the currently entered filter text.
 */
","/**
 * For our text watcher that is associated with the text filter. Performs
 * the actual filtering as the text changes, and takes care of hiding and
 * showing the popup displaying the currently entered filter text.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the updated code, the condition ""if (mPopup != null && isTextFilterEnabled())"" was changed to ""if (isTextFilterEnabled())"". Additionally, the method createTextFilter(true) was added, indicating that both control dependency (type 3 change) and other changes (type 4 change) occurred.","The removal of the ""mPopup"" null check means that the condition of the 'if' statement has changed, which can change the execution path of the code. This can potentially lead to the API returning different values due to different behaviors (CI type 1). Moreover, the behavior of ""showPopup()"" or ""dismissPopup()"" also depends on the state of ""mPopup"", and as this check is removed, exceptions that were formerly handled might now cause a crash, leading to a different exception handling in the late version (CI type 2). However, without knowledge about the implementation of ""createTextFilter(true)"" and detailed behaviour of ""mPopup"", we cannot definitively determine whether a type 2 CI exists. Hence, we are classifying this as a type 1 CI."
