Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
1,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",16,17,"<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setMaximumTimeToLock(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumTimeToLock(admin, timeMs, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * maximum time for user activity until the device will lock.  This limits
 * the length that the user can set.  It takes effect immediately.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds.
 * A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * maximum time for user activity until the device will lock.  This limits
 * the length that the user can set.  It takes effect immediately.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_FORCE_LOCK} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeMs The new desired maximum time to lock in milliseconds.
 * A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"In the later version, an extra parameter (UserHandle.myUserId()) is introduced in the dependent method mService.setMaximumTimeToLock(), therefore the change is in the Returned statement and the Dependent API","Despite the different call to the mService.setMaximumTimeToLock() method, it does not affect the API behaviour in terms of return type/value or thrown exception, therefore no compatibility issues are detected."
3,<android.bluetooth.BluetoothAdapter: String getAddress()>,16,17,<android.bluetooth.BluetoothAdapter: String getAddress()>,<android.bluetooth.BluetoothAdapter: String getAddress()>,0,"{
    try {
        return mService.getAddress();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    try {
        return mManagerService.getAddress();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the hardware address of the local Bluetooth adapter.
 * <p>For example, ""00:11:22:AA:BB:CC"".
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return Bluetooth hardware address as string
 */
","/**
 * Returns the hardware address of the local Bluetooth adapter.
 * <p>For example, ""00:11:22:AA:BB:CC"".
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return Bluetooth hardware address as string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling mService.getAddress() to mManagerService.getAddress(). Therefore, this change belongs to categories 1 and 5.","Since the return statement changed, it is possible that the returned values could differ between two versions resulting in a compatibility issue. Thus, the CI type is 1."
4,<android.server.search.SearchManagerService: List<ResolveInfo> getGlobalSearchActivities()>,16,17,<android.server.search.SearchManagerService: List<ResolveInfo> getGlobalSearchActivities()>,<android.server.search.SearchManagerService: List<ResolveInfo> getGlobalSearchActivities()>,0,"{
    return getSearchables().getGlobalSearchActivities();
}","{
    return getSearchables(UserHandle.getCallingUserId()).getGlobalSearchActivities();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getSearchables().getGlobalSearchActivities() to getSearchables(UserHandle.getCallingUserId()).getGlobalSearchActivities(). Therefore, this is a code change within categories 1 and 5.","The API potentially returns a different value because of the change in the method call of getSearchables(), so the CI type is 1."
5,"<android.provider.Settings.Secure: long getLong(ContentResolver,String)>",16,17,"<android.provider.Settings.Secure: long getLong(ContentResolver,String)>","<android.provider.Settings.Secure: long getLong(ContentResolver,String)>",0,"{
    String valString = getString(cr, name);
    try {
        return Long.parseLong(valString);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getLongForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been altered from return Long.parseLong(valString) and return getLongForUser(cr, name, UserHandle.myUserId()). Additionally, the API that this method depends on has changed from getString() to getLongForUser(), resulting in code change types 1 and 5.","Since the method now calls a different API and returns a different value, this could potentially lead to the API returning a different value or type compared to the previous version, making the CI type 1."
6,<android.view.View: boolean hasTransientState()>,16,17,<android.view.View: boolean hasTransientState()>,<android.view.View: boolean hasTransientState()>,0,"{
    return (mPrivateFlags2 & HAS_TRANSIENT_STATE) == HAS_TRANSIENT_STATE;
}","{
    return (mPrivateFlags2 & PFLAG2_HAS_TRANSIENT_STATE) == PFLAG2_HAS_TRANSIENT_STATE;
}",1,"/**
 * Indicates whether the view is currently tracking transient state that the
 * app should not need to concern itself with saving and restoring, but that
 * the framework should take special note to preserve when possible.
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @return true if the view has transient state
 */
","/**
 * Indicates whether the view is currently tracking transient state that the
 * app should not need to concern itself with saving and restoring, but that
 * the framework should take special note to preserve when possible.
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @return true if the view has transient state
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""layout"")]","[@ViewDebug.ExportedProperty(category = ""layout"")]",-1,-1,-1,-1,-1,-1,"4,5",1,"The boolean comparison has changed within the return statement, implying a shift in logic, making it a type 4 change. Also, the comparison operands HAS_TRANSIENT_STATE and PFLAG2_HAS_TRANSIENT_STATE are constants, which can be considered as a dependent API. Hence, the change is also a type 5.","Since the value of PFLAG2_HAS_TRANSIENT_STATE might not be equal to the HAS_TRANSIENT_STATE, the boolean value returned by this method may differ between the two versions, thereby causing a type 1 CI."
7,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,16,17,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        // Start fresh
        reset();
    }
    boolean handled = true;
    if (mInvalidGesture) {
        handled = false;
    } else if (!mGestureInProgress) {
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                {
                    mActiveId0 = event.getPointerId(0);
                    mActive0MostRecent = true;
                }
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // We have a new multi-finger gesture
                    if (mPrevEvent != null)
                        mPrevEvent.recycle();
                    mPrevEvent = MotionEvent.obtain(event);
                    mTimeDelta = 0;
                    int index1 = event.getActionIndex();
                    int index0 = event.findPointerIndex(mActiveId0);
                    mActiveId1 = event.getPointerId(index1);
                    if (index0 < 0 || index0 == index1) {
                        // Probably someone sending us a broken event stream.
                        index0 = findNewActiveIndex(event, mActiveId1, -1);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    mActive0MostRecent = false;
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                    break;
                }
        }
    } else {
        // Transform gesture in progress - attempt to handle it
        switch(action) {
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // End the old gesture and begin a new one with the most recent two fingers.
                    mListener.onScaleEnd(this);
                    final int oldActive0 = mActiveId0;
                    final int oldActive1 = mActiveId1;
                    reset();
                    mPrevEvent = MotionEvent.obtain(event);
                    mActiveId0 = mActive0MostRecent ? oldActive0 : oldActive1;
                    mActiveId1 = event.getPointerId(event.getActionIndex());
                    mActive0MostRecent = false;
                    int index0 = event.findPointerIndex(mActiveId0);
                    if (index0 < 0 || mActiveId0 == mActiveId1) {
                        // Probably someone sending us a broken event stream.
                        Log.e(TAG, ""Got "" + MotionEvent.actionToString(action) + "" with bad state while a gesture was in progress. "" + ""Did you forget to pass an event to "" + ""ScaleGestureDetector#onTouchEvent?"");
                        index0 = findNewActiveIndex(event, mActiveId1, -1);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    boolean gestureEnded = false;
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId0 = event.getPointerId(newIndex);
                                mActive0MostRecent = true;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId1 = event.getPointerId(newIndex);
                                mActive0MostRecent = false;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        }
                        mPrevEvent.recycle();
                        mPrevEvent = MotionEvent.obtain(event);
                        setContext(event);
                    } else {
                        gestureEnded = true;
                    }
                    if (gestureEnded) {
                        // Gesture ended
                        setContext(event);
                        // Set focus point to the remaining finger
                        final int activeId = actionId == mActiveId0 ? mActiveId1 : mActiveId0;
                        final int index = event.findPointerIndex(activeId);
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                        mListener.onScaleEnd(this);
                        reset();
                        mActiveId0 = activeId;
                        mActive0MostRecent = true;
                    }
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mListener.onScaleEnd(this);
                reset();
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_MOVE:
                {
                    setContext(event);
                    // finger is lifted.
                    if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
                        final boolean updatePrevious = mListener.onScale(this);
                        if (updatePrevious) {
                            mPrevEvent.recycle();
                            mPrevEvent = MotionEvent.obtain(event);
                        }
                    }
                }
                break;
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += event.getX(i);
        sumY += event.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    if (!mInProgress && span >= mMinSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
        }
    }
    return true;
}",1,,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,The change type is 3 and 4. Most of the previous control flow statements and logical structure have been removed and rebuilt with new control statements and logicals.,"This total refactor could leads to the change of returned boolean-type result, even if the function name remains ""onTouchEvent"", the resulting values could be completely different in new version. So the CI type is 1."
8,<android.app.ActivityManagerProxy: UserInfo getCurrentUser()>,16,17,<android.app.ActivityManagerProxy: UserInfo getCurrentUser()>,<android.app.ActivityManagerProxy: UserInfo getCurrentUser()>,0,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    mRemote.transact(SWITCH_USER_TRANSACTION, data, reply, 0);
    reply.readException();
    UserInfo userInfo = UserInfo.CREATOR.createFromParcel(reply);
    reply.recycle();
    data.recycle();
    return userInfo;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    mRemote.transact(GET_CURRENT_USER_TRANSACTION, data, reply, 0);
    reply.readException();
    UserInfo userInfo = UserInfo.CREATOR.createFromParcel(reply);
    reply.recycle();
    data.recycle();
    return userInfo;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The argument of 'mRemote.transact' method changed from SWITCH_USER_TRANSACTION to GET_CURRENT_USER_TRANSACTION, and the API could indeed return a different value due to this difference, so the code change type is 1,5.","Due to the change in the argument 'mRemote.transact', this API could return a different UserInfo. Consequently, the CI type is 1."
9,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLowerCase(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLowerCase(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumLowerCase(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of lower case letters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumLowerCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of lower case letters required in the
 * password.
 */
","/**
 * Retrieve the current number of lower case letters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumLowerCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of lower case letters required in the
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the function has changed. Firstly, there is a direct change in the return statement from 'return mService.getPasswordMinimumLowerCase(admin);' in the early version to 'return getPasswordMinimumLowerCase(admin, UserHandle.myUserId());' in the late version. Secondly, the entire try-catch block has been removed, and as a result, the invocation of dependent API `mService.getPasswordMinimumLowerCase(admin);` has been replaced by `getPasswordMinimumLowerCase(admin, UserHandle.myUserId());`. Therefore, the change can be classified under types 1 and 5.","The change in the return statement and dependent API means that the program may return different results or variables when the same admin is passed in. Consequently, there exists a compatibility issue of type 1 which suggests that there might be different return values or types between these two versions."
10,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean isAdminActive(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.isAdminActive(who);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.isAdminActive(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
","/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the late version implementation, an additional parameter `UserHandle.myUserId()` has been added in the `mService.isAdminActive(who)` call. This is classified as 4,5 - other statement change and dependent API change.",The change in dependent API causes the function to potentially return a different boolean value. Thus there is potential Compatibility Issue which can be caused by different return values. This is classified as 1.
11,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",16,17,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>","<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",0,"{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onCreateOptionsMenu(menu, inflater);
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}","{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performCreateOptionsMenu(menu, inflater)) {
                    show = true;
                    if (newMenus == null) {
                        newMenus = new ArrayList<Fragment>();
                    }
                    newMenus.add(f);
                }
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The condition of if statement and the invoked API f.onCreateOptionsMenu(menu, inflater) have been changed to f.performCreateOptionsMenu(menu, inflater). So, the code change type is 1,3,5.","The changes made to the condition statement and the switching of dependent API may potentially affect the execution flow, return values and thus behaviours of the API, hence it is classified as CI type 1."
12,"<android.content.ContentResolver: void notifyChange(Uri,ContentObserver,boolean)>",16,17,"<android.content.ContentResolver: void notifyChange(Uri,ContentObserver,boolean)>","<android.content.ContentResolver: void notifyChange(Uri,ContentObserver,boolean)>",0,"{
    try {
        getContentService().notifyChange(uri, observer == null ? null : observer.getContentObserver(), observer != null && observer.deliverSelfNotifications(), syncToNetwork);
    } catch (RemoteException e) {
    }
}","{
    notifyChange(uri, observer, syncToNetwork, UserHandle.getCallingUserId());
}",1,"/**
 * Notify registered observers that a row was updated.
 * To register, call {@link #registerContentObserver(android.net.Uri , boolean, android.database.ContentObserver) registerContentObserver()}.
 * By default, CursorAdapter objects will get this notification.
 * If syncToNetwork is true, this will attempt to schedule a local sync using the sync
 * adapter that's registered for the authority of the provided uri. No account will be
 * passed to the sync adapter, so all matching accounts will be synchronized.
 *
 * @param uri The uri of the content that was changed.
 * @param observer The observer that originated the change, may be <code>null</null>.
 * The observer that originated the change will only receive the notification if it
 * has requested to receive self-change notifications by implementing
 * {@link ContentObserver#deliverSelfNotifications()} to return true.
 * @param syncToNetwork If true, attempt to sync the change to the network.
 * @see #requestSync(android.accounts.Account, String, android.os.Bundle)
 */
","/**
 * Notify registered observers that a row was updated.
 * To register, call {@link #registerContentObserver(android.net.Uri , boolean, android.database.ContentObserver) registerContentObserver()}.
 * By default, CursorAdapter objects will get this notification.
 * If syncToNetwork is true, this will attempt to schedule a local sync using the sync
 * adapter that's registered for the authority of the provided uri. No account will be
 * passed to the sync adapter, so all matching accounts will be synchronized.
 *
 * @param uri The uri of the content that was changed.
 * @param observer The observer that originated the change, may be <code>null</null>.
 * The observer that originated the change will only receive the notification if it
 * has requested to receive self-change notifications by implementing
 * {@link ContentObserver#deliverSelfNotifications()} to return true.
 * @param syncToNetwork If true, attempt to sync the change to the network.
 * @see #requestSync(android.accounts.Account, String, android.os.Bundle)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The implementation of the method has been totally changed in the late version, and the information using which method will be called has also been changed. Thus, the code change type is 1,5.","The different implementations could make the API return different exceptions or none when the input does not satisfy some conditions, and the change in the dependent API might also influence the returned results, so the CI type is 1,2."
14,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,16,17,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,<android.app.FragmentManagerImpl: Parcelable saveAllState()>,0,"{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();
    mStateSaved = true;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            if (f.mIndex < 0) {
                String msg = ""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex;
                Slog.e(TAG, msg);
                dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                throw new IllegalStateException(msg);
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        String msg = ""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget;
                        Slog.e(TAG, msg);
                        dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                        throw new IllegalStateException(msg);
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    String msg = ""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i];
                    Slog.e(TAG, msg);
                    dump(""  "", null, new PrintWriter(new LogWriter(Log.ERROR, TAG, Log.LOG_ID_SYSTEM)), new String[] {});
                    throw new IllegalStateException(msg);
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    return fms;
}","{
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();
    mStateSaved = true;
    if (mActive == null || mActive.size() <= 0) {
        return null;
    }
    // First collect all active fragments.
    int N = mActive.size();
    FragmentState[] active = new FragmentState[N];
    boolean haveFragments = false;
    for (int i = 0; i < N; i++) {
        Fragment f = mActive.get(i);
        if (f != null) {
            if (f.mIndex < 0) {
                throwException(new IllegalStateException(""Failure saving state: active "" + f + "" has cleared index: "" + f.mIndex));
            }
            haveFragments = true;
            FragmentState fs = new FragmentState(f);
            active[i] = fs;
            if (f.mState > Fragment.INITIALIZING && fs.mSavedFragmentState == null) {
                fs.mSavedFragmentState = saveFragmentBasicState(f);
                if (f.mTarget != null) {
                    if (f.mTarget.mIndex < 0) {
                        throwException(new IllegalStateException(""Failure saving state: "" + f + "" has target not in fragment manager: "" + f.mTarget));
                    }
                    if (fs.mSavedFragmentState == null) {
                        fs.mSavedFragmentState = new Bundle();
                    }
                    putFragment(fs.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG, f.mTarget);
                    if (f.mTargetRequestCode != 0) {
                        fs.mSavedFragmentState.putInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, f.mTargetRequestCode);
                    }
                }
            } else {
                fs.mSavedFragmentState = f.mSavedFragmentState;
            }
            if (DEBUG)
                Log.v(TAG, ""Saved state of "" + f + "": "" + fs.mSavedFragmentState);
        }
    }
    if (!haveFragments) {
        if (DEBUG)
            Log.v(TAG, ""saveAllState: no fragments!"");
        return null;
    }
    int[] added = null;
    BackStackState[] backStack = null;
    // Build list of currently added fragments.
    if (mAdded != null) {
        N = mAdded.size();
        if (N > 0) {
            added = new int[N];
            for (int i = 0; i < N; i++) {
                added[i] = mAdded.get(i).mIndex;
                if (added[i] < 0) {
                    throwException(new IllegalStateException(""Failure saving state: active "" + mAdded.get(i) + "" has cleared index: "" + added[i]));
                }
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding fragment #"" + i + "": "" + mAdded.get(i));
            }
        }
    }
    // Now save back stack.
    if (mBackStack != null) {
        N = mBackStack.size();
        if (N > 0) {
            backStack = new BackStackState[N];
            for (int i = 0; i < N; i++) {
                backStack[i] = new BackStackState(this, mBackStack.get(i));
                if (DEBUG)
                    Log.v(TAG, ""saveAllState: adding back stack #"" + i + "": "" + mBackStack.get(i));
            }
        }
    }
    FragmentManagerState fms = new FragmentManagerState();
    fms.mActive = active;
    fms.mAdded = added;
    fms.mBackStack = backStack;
    return fms;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"Some 'throw' statements previously used are now encapsulated as 'throwException()' method calls. Besides this, no other change has taken place. So, the change type is 2,3 - Exception Handling Statement Changed and Control Dependency Changed.","In the latter version, exceptions are thrown differently due to the overhaul in the exception handling architecture ('throw' statements are replaced with 'throwException()'). Although the type of exception remains the same, the manner in which it is thrown has changed, which may potentially cause the function to behave differently. Hence, the Compatibility Issue type is 2 - CI caused by potential different exception handlings."
15,"<android.webkit.WebViewClassic: boolean onSavePassword(String,String,String,Message)>",16,17,"<android.webkit.WebViewClassic: boolean onSavePassword(String,String,String,Message)>","<android.webkit.WebViewClassic: boolean onSavePassword(String,String,String,Message)>",0,"{
    boolean rVal = false;
    if (resumeMsg == null) {
        // null resumeMsg implies saving password silently
        mDatabase.setUsernamePassword(schemePlusHost, username, password);
    } else {
        if (mResumeMsg != null) {
            Log.w(LOGTAG, ""onSavePassword should not be called while dialog is up"");
            resumeMsg.sendToTarget();
            return true;
        }
        mResumeMsg = resumeMsg;
        final Message remember = mPrivateHandler.obtainMessage(REMEMBER_PASSWORD);
        remember.getData().putString(""host"", schemePlusHost);
        remember.getData().putString(""username"", username);
        remember.getData().putString(""password"", password);
        remember.obj = resumeMsg;
        final Message neverRemember = mPrivateHandler.obtainMessage(NEVER_REMEMBER_PASSWORD);
        neverRemember.getData().putString(""host"", schemePlusHost);
        neverRemember.getData().putString(""username"", username);
        neverRemember.getData().putString(""password"", password);
        neverRemember.obj = resumeMsg;
        new AlertDialog.Builder(mContext).setTitle(com.android.internal.R.string.save_password_label).setMessage(com.android.internal.R.string.save_password_message).setPositiveButton(com.android.internal.R.string.save_password_notnow, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    resumeMsg.sendToTarget();
                    mResumeMsg = null;
                }
            }
        }).setNeutralButton(com.android.internal.R.string.save_password_remember, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    remember.sendToTarget();
                    mResumeMsg = null;
                }
            }
        }).setNegativeButton(com.android.internal.R.string.save_password_never, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    neverRemember.sendToTarget();
                    mResumeMsg = null;
                }
            }
        }).setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                if (mResumeMsg != null) {
                    resumeMsg.sendToTarget();
                    mResumeMsg = null;
                }
            }
        }).show();
        // Return true so that WebViewCore will pause while the dialog is
        // up.
        rVal = true;
    }
    return rVal;
}","{
    boolean rVal = false;
    if (resumeMsg == null) {
        // null resumeMsg implies saving password silently
        mDatabase.setUsernamePassword(schemePlusHost, username, password);
    } else {
        if (mResumeMsg != null) {
            Log.w(LOGTAG, ""onSavePassword should not be called while dialog is up"");
            resumeMsg.sendToTarget();
            return true;
        }
        mResumeMsg = resumeMsg;
        final Message remember = mPrivateHandler.obtainMessage(REMEMBER_PASSWORD);
        remember.getData().putString(""host"", schemePlusHost);
        remember.getData().putString(""username"", username);
        remember.getData().putString(""password"", password);
        remember.obj = resumeMsg;
        final Message neverRemember = mPrivateHandler.obtainMessage(NEVER_REMEMBER_PASSWORD);
        neverRemember.getData().putString(""host"", schemePlusHost);
        neverRemember.getData().putString(""username"", username);
        neverRemember.getData().putString(""password"", password);
        neverRemember.obj = resumeMsg;
        mSavePasswordDialog = new AlertDialog.Builder(mContext).setTitle(com.android.internal.R.string.save_password_label).setMessage(com.android.internal.R.string.save_password_message).setPositiveButton(com.android.internal.R.string.save_password_notnow, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    resumeMsg.sendToTarget();
                    mResumeMsg = null;
                }
                mSavePasswordDialog = null;
            }
        }).setNeutralButton(com.android.internal.R.string.save_password_remember, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    remember.sendToTarget();
                    mResumeMsg = null;
                }
                mSavePasswordDialog = null;
            }
        }).setNegativeButton(com.android.internal.R.string.save_password_never, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (mResumeMsg != null) {
                    neverRemember.sendToTarget();
                    mResumeMsg = null;
                }
                mSavePasswordDialog = null;
            }
        }).setOnDismissListener(new DialogInterface.OnDismissListener() {

            @Override
            public void onDismiss(DialogInterface dialog) {
                if (mResumeMsg != null) {
                    resumeMsg.sendToTarget();
                    mResumeMsg = null;
                }
                mSavePasswordDialog = null;
            }
        }).show();
        // Return true so that WebViewCore will pause while the dialog is
        // up.
        rVal = true;
    }
    return rVal;
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are some changes in the onClick() methods and an OnDismissListener is added instead of an OnCancelListener in the AlertDialog.Builder, so the code change type is 3,4.","Even though the code changes in the AlertDialog.Builder, these changes don't affect the return type and do not introduce a potential different exception, so there's no Compatibility Issue, CI type is 0."
17,<android.speech.tts.BlockingAudioTrack: void waitAndRelease()>,16,17,<android.speech.tts.BlockingAudioTrack: void waitAndRelease()>,<android.speech.tts.BlockingAudioTrack: void waitAndRelease()>,0,"{
    // much point not doing that again.
    if (mBytesWritten < mAudioBufferSize && !mStopped) {
        if (DBG) {
            Log.d(TAG, ""Stopping audio track to flush audio, state was : "" + mAudioTrack.getPlayState() + "",stopped= "" + mStopped);
        }
        mIsShortUtterance = true;
        mAudioTrack.stop();
    }
    // Block until the audio track is done only if we haven't stopped yet.
    if (!mStopped) {
        if (DBG)
            Log.d(TAG, ""Waiting for audio track to complete : "" + mAudioTrack.hashCode());
        blockUntilDone(mAudioTrack);
    }
    // it's safe to release at this point.
    if (DBG)
        Log.d(TAG, ""Releasing audio track ["" + mAudioTrack.hashCode() + ""]"");
    synchronized (mAudioTrackLock) {
        mAudioTrack.release();
        mAudioTrack = null;
    }
}","{
    AudioTrack track = null;
    synchronized (mAudioTrackLock) {
        track = mAudioTrack;
    }
    if (track == null) {
        if (DBG)
            Log.d(TAG, ""Audio track null [duplicate call to waitAndRelease ?]"");
        return;
    }
    // much point not doing that again.
    if (mBytesWritten < mAudioBufferSize && !mStopped) {
        if (DBG) {
            Log.d(TAG, ""Stopping audio track to flush audio, state was : "" + track.getPlayState() + "",stopped= "" + mStopped);
        }
        mIsShortUtterance = true;
        track.stop();
    }
    // Block until the audio track is done only if we haven't stopped yet.
    if (!mStopped) {
        if (DBG)
            Log.d(TAG, ""Waiting for audio track to complete : "" + mAudioTrack.hashCode());
        blockUntilDone(mAudioTrack);
    }
    // it's safe to release at this point.
    if (DBG)
        Log.d(TAG, ""Releasing audio track ["" + track.hashCode() + ""]"");
    synchronized (mAudioTrackLock) {
        mAudioTrack = null;
    }
    track.release();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code change includes introduction of a new variable 'track' and a condition statement, and replacement of 'mAudioTrack' with 'track' in several places. The control in the method has altered, hence code change type is 3. Furthermore, there is a newly added return statement, leading to type 1 change.","The newly introduced return statement potentially causes the method to exit before it normally would in the case where 'track' is null. This leads to a compatibility issue of type 1, due to the possibility of returning different values between the two versions."
19,<android.bluetooth.BluetoothAdapter: int getScanMode()>,16,17,<android.bluetooth.BluetoothAdapter: int getScanMode()>,<android.bluetooth.BluetoothAdapter: int getScanMode()>,0,"{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return SCAN_MODE_NONE;
}","{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return SCAN_MODE_NONE;
}",1,"/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
","/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the late version, a synchronized block is added to encapsulate the return statement ""return mService.getScanMode();"", which means the control dependencies have changed, hence the change type will be 3 (Control dependency change).","The addition of synchronization can potentially change the execution flow of the method since it forces thread safety which might change the timing at which the call to ""getScanMode()"" in service is made which can potentially lead to returning different values under multi-threading scenarios, therefore a CI type 1 should exist (CI caused by potential different return values)."
22,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>",16,17,"<android.provider.Settings.Secure: String getString(ContentResolver,String)>","<android.provider.Settings.Secure: String getString(ContentResolver,String)>",0,"{
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SECURE);
    }
    if (sLockSettings == null) {
        sLockSettings = ILockSettings.Stub.asInterface((IBinder) ServiceManager.getService(""lock_settings""));
        sIsSystemProcess = Process.myUid() == Process.SYSTEM_UID;
    }
    if (sLockSettings != null && !sIsSystemProcess && MOVED_TO_LOCK_SETTINGS.contains(name)) {
        try {
            return sLockSettings.getString(name, ""0"", UserId.getCallingUserId());
        } catch (RemoteException re) {
        // Fall through
        }
    }
    return sNameValueCache.getString(resolver, name);
}","{
    return getStringForUser(resolver, name, UserHandle.myUserId());
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the method has been changed in the later version and the method ""getStringForUser"" is now being called in the return statement (this method wasn't present in the earlier version). Therefore, the classes of change are 1 (Return statement changed) and 5 (Dependent API changed).","Since the return statement has been completely changed (from calling multiple statements and methods to just one dependent method), we can expect the returned value to be potentially different. Therefore, the type of compatibility issue is 1 (Compatibility Issue caused by potential different return values or types)."
23,<android.inputmethodservice.InputMethodService: boolean onTrackballEvent(MotionEvent)>,16,17,<android.inputmethodservice.InputMethodService: boolean onTrackballEvent(MotionEvent)>,<android.inputmethodservice.InputMethodService: boolean onTrackballEvent(MotionEvent)>,0,"{
    return false;
}","{
    if (DEBUG)
        Log.v(TAG, ""onTrackballEvent: "" + event);
    return false;
}",1,,"/**
 * Override this to intercept trackball motion events before they are
 * processed by the application.
 * If you return true, the application will not itself process the event.
 * If you return false, the normal application processing will occur as if
 * the IME had not seen the event at all.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The added log statement is not essential to the method operation, hence the code change type is 4 (Other statement changed).","As the change doesn't affect the return value or exception of this method, there's no Compatibility Issue, hence the CI type is 0."
24,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",16,17,"<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetRemoteViewsAdapterIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(""RemoteViews"", ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(""RemoteViews"", ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    // Ensure that we are applying to an AppWidget root
    if (!(rootParent instanceof AppWidgetHostView)) {
        Log.e(""RemoteViews"", ""SetRemoteViewsAdapterIntent action can only be used for "" + ""AppWidgets (root id: "" + viewId + "")"");
        return;
    }
    // Ensure that we are calling setRemoteAdapter on an AdapterView that supports it
    if (!(target instanceof AbsListView) && !(target instanceof AdapterViewAnimator)) {
        Log.e(""RemoteViews"", ""Cannot setRemoteViewsAdapter on a view which is not "" + ""an AbsListView or AdapterViewAnimator (id: "" + viewId + "")"");
        return;
    }
    // Embed the AppWidget Id for use in RemoteViewsAdapter when connecting to the intent
    // RemoteViewsService
    AppWidgetHostView host = (AppWidgetHostView) rootParent;
    intent.putExtra(EXTRA_REMOTEADAPTER_APPWIDGET_ID, host.getAppWidgetId());
    if (target instanceof AbsListView) {
        AbsListView v = (AbsListView) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    } else if (target instanceof AdapterViewAnimator) {
        AdapterViewAnimator v = (AdapterViewAnimator) target;
        v.setRemoteViewsAdapter(intent);
        v.setRemoteViewsOnClickHandler(handler);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an extra statement v.setRemoteViewsOnClickHandler(handler); appearing twice in the late version API. This statement affects the behaviour of objects v of type AdapterViewAnimator and AbsListView, therefore, it is classified as change type 1.","The CI is caused by the potential different return values or types. In the late version API, the added statement v.setRemoteViewsOnClickHandler(handler); changes the behaviour of two different views, AdapterViewAnimator and AbsListView. For instance, the click handling behaviour of these views didn't exist in the early version but now exist in the late version - which is a significant change in behaviour. Therefore, it is classifed as CI type 1."
25,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,16,17,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"A new method `warnIfCallingFromSystemProcess()` is added at the beginning and the parameter of `Binder.getOrigCallingUser()` of method `ActivityManagerNative.getDefault().broadcastIntent()` has been changed to `getUserId()`. Therefore, the code change type is 4,5.","The changed behavior which calling a new method `warnIfCallingFromSystemProcess()` only aimed to warn developers while they are calling the method from system process, and changing of parameters of method `ActivityManagerNative.getDefault().broadcastIntent()` doesn't shift the original functionality. Thus, the CI type is 0 as no Compatibility Issue exists."
26,"<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>",16,17,"<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>","<android.app.ApplicationPackageManager: ResolveInfo resolveService(Intent,int)>",0,"{
    try {
        return mPM.resolveService(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.resolveService(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method called to get the user ID has changed from UserId.myUserId() to mContext.getUserId(). This reflects in the return statement as well, therefore the code change belongs to type 1,5.","As the change in the method to get the user ID could potentially lead to the API returning different value, the Compatibility Issue type is 1."
27,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,16,17,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,<android.app.BackStackState: BackStackRecord instantiate(FragmentManagerImpl)>,0,"{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set base fragment #"" + mOps[pos]);
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG)
                    Log.v(FragmentManagerImpl.TAG, ""BSE "" + bse + "" set remove fragment #"" + mOps[pos]);
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.bumpBackStackNesting(1);
    return bse;
}","{
    BackStackRecord bse = new BackStackRecord(fm);
    int pos = 0;
    int num = 0;
    while (pos < mOps.length) {
        BackStackRecord.Op op = new BackStackRecord.Op();
        op.cmd = mOps[pos++];
        if (FragmentManagerImpl.DEBUG)
            Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" op #"" + num + "" base fragment #"" + mOps[pos]);
        int findex = mOps[pos++];
        if (findex >= 0) {
            Fragment f = fm.mActive.get(findex);
            op.fragment = f;
        } else {
            op.fragment = null;
        }
        op.enterAnim = mOps[pos++];
        op.exitAnim = mOps[pos++];
        op.popEnterAnim = mOps[pos++];
        op.popExitAnim = mOps[pos++];
        final int N = mOps[pos++];
        if (N > 0) {
            op.removed = new ArrayList<Fragment>(N);
            for (int i = 0; i < N; i++) {
                if (FragmentManagerImpl.DEBUG)
                    Log.v(FragmentManagerImpl.TAG, ""Instantiate "" + bse + "" set remove fragment #"" + mOps[pos]);
                Fragment r = fm.mActive.get(mOps[pos++]);
                op.removed.add(r);
            }
        }
        bse.addOp(op);
        num++;
    }
    bse.mTransition = mTransition;
    bse.mTransitionStyle = mTransitionStyle;
    bse.mName = mName;
    bse.mIndex = mIndex;
    bse.mAddToBackStack = true;
    bse.mBreadCrumbTitleRes = mBreadCrumbTitleRes;
    bse.mBreadCrumbTitleText = mBreadCrumbTitleText;
    bse.mBreadCrumbShortTitleRes = mBreadCrumbShortTitleRes;
    bse.mBreadCrumbShortTitleText = mBreadCrumbShortTitleText;
    bse.bumpBackStackNesting(1);
    return bse;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional variable 'num' is introduced in the later version and the logging statement has changed a bit. There is no other control or return statement changes. So, the change type is 4.","The introduced 'num' variable and the slightly changed logging statement won't affect the method's returned result or thrown exceptions, so there is no compatibility issue between the two versions. Therefore, the CI type is 0."
28,"<android.provider.Settings.Secure: int getInt(ContentResolver,String)>",16,17,"<android.provider.Settings.Secure: int getInt(ContentResolver,String)>","<android.provider.Settings.Secure: int getInt(ContentResolver,String)>",0,"{
    String v = getString(cr, name);
    try {
        return Integer.parseInt(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getIntForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","In the early version, the method throws a SettingNotFoundException when a NumberFormatException arises. However, in the late version, the method calls another API 'getIntForUser', so the code change type is 1,5.","The method potentially returns different values or types in the two versions and throws a different exception as the 'getIntForUser' API maybe has its own exception handling, thus the CI type is 1,2."
29,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,<android.app.admin.DevicePolicyManager: long getPasswordExpiration(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordExpiration(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    if (mService != null) {
        try {
            return mService.getPasswordExpiration(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}",1,"/**
 * Get the current password expiration time for the given admin or an aggregate of
 * all admins if admin is null. If the password is expired, this will return the time since
 * the password expired as a negative number.  If admin is null, then a composite of all
 * expiration timeouts is returned - which will be the minimum of all timeouts.
 *
 * @param admin The name of the admin component to check, or null to aggregate all admins.
 * @return The password expiration time, in ms.
 */
","/**
 * Get the current password expiration time for the given admin or an aggregate of
 * all admins if admin is null. If the password is expired, this will return the time since
 * the password expired as a negative number.  If admin is null, then a composite of all
 * expiration timeouts is returned - which will be the minimum of all timeouts.
 *
 * @param admin The name of the admin component to check, or null to aggregate all admins.
 * @return The password expiration time, in ms.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 5",1,"The code changed in the return statement by adding a new parameter (UserHandle.myUserId()) to the mService.getPasswordExpiration method. Thus, the code change type is 1, 5.","Considering that the return statement has been modified and the API might return different values in the late version due to the slightly different parameters, classify the CI type as 1."
30,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,16,17,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,0,"{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary());
    }
    return false;
}","{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        if (subtype.mSubtypeId != 0 || mSubtypeId != 0) {
            return (subtype.hashCode() == hashCode());
        }
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary());
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,The code change is of type 4 considering the introduction of new value conditions (subtype.mSubtypeId != 0 and mSubtypeId != 0) and the change in return conditions. The control dependency changed due to the addition of an 'if' condition making the change type 3 as well.,The newly added conditions (subtype.mSubtypeId != 0 || mSubtypeId != 0) and subsequent different return values can potentially alter the behavior of the method causing the type of the compatibility issue to be 1.
31,<android.app.ContextImpl: void unbindService(ServiceConnection)>,16,17,<android.app.ContextImpl: void unbindService(ServiceConnection)>,<android.app.ContextImpl: void unbindService(ServiceConnection)>,0,"{
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManagerNative.getDefault().unbindService(sd);
        } catch (RemoteException e) {
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}","{
    if (conn == null) {
        throw new IllegalArgumentException(""connection is null"");
    }
    if (mPackageInfo != null) {
        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(getOuterContext(), conn);
        try {
            ActivityManagerNative.getDefault().unbindService(sd);
        } catch (RemoteException e) {
        }
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,2",2,"A new conditional statement has been introduced at the start of the API, making a control dependency change. Also, a new exception handling statement has been added in terms of throwing a new IllegalArgumentException if 'conn' is null, causing a change in how exceptions are handled. Therefore, the code change types are 3,2.","The added exception handling statement can cause a different behavior, specifically, in the case where 'conn' is null, the method will throw an IllegalArgumentException rather than executing the remaining part of the method, and this can be regarded as a compatibility issue caused by potentially different exception handling, thus the CI type is 2."
32,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,16,17,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,<android.os.PowerManager.WakeLock: void setWorkSource(WorkSource)>,0,"{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        boolean changed = true;
        if (ws == null) {
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = mWorkSource != null;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource);
            } catch (RemoteException e) {
            }
        }
    }
}","{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource);
            } catch (RemoteException e) {
            }
        }
    }
}",1,,"/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"Only the way to initialize 'changed' variable is different between the two versions. The 'change' initialization is moved from inside an 'if' statement to the place before 'if' statement, so the code change type is 3.","Given the change in the initialization of 'changed' variable does not affect API behavior in terms of return value or exception handling, the CI type is 0."
33,"<android.app.NotificationManager: void cancel(String,int)>",16,17,"<android.app.NotificationManager: void cancel(String,int)>","<android.app.NotificationManager: void cancel(String,int)>",0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancel("" + id + "")"");
    try {
        service.cancelNotificationWithTag(pkg, tag, id);
    } catch (RemoteException e) {
    }
}","{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancel("" + id + "")"");
    try {
        service.cancelNotificationWithTag(pkg, tag, id, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
","/**
 * Cancel a previously shown notification.  If it's transient, the view
 * will be hidden.  If it's persistent, it will be removed from the status
 * bar.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The call to the method service.cancelNotificationWithTag() has changed from four arguments to five. Specifically, UserHandle.myUserId() is added to the calling of this method in the late version. So the code change type is 5.","The added UserHandle.myUserId() as an argument to service.cancelNotificationWithTag() may cause the function to behave differently and return variable outcomes when compared to the earlier version. Therefore, the CI type is 1."
36,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,16,17,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,<android.app.ApplicationPackageManager: int getApplicationEnabledSetting(String)>,0,"{
    try {
        return mPM.getApplicationEnabledSetting(packageName, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}","{
    try {
        return mPM.getApplicationEnabledSetting(packageName, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The change is in the return statement where the method of getting the user id has changed from UserId.myUserId() to mContext.getUserId(), thus the code change type is 5.","The potential change in getting user id may lead the API to return a different result therefore, the CI type is 1."
37,"<android.view.HardwareRenderer.GlRenderer: EGLContext createContext(EGL10,EGLDisplay,EGLConfig)>",16,17,"<android.view.HardwareRenderer.GlRenderer: EGLContext createContext(EGL10,EGLDisplay,EGLConfig)>","<android.view.HardwareRenderer.GlRenderer: EGLContext createContext(EGL10,EGLDisplay,EGLConfig)>",0,"{
    int[] attribs = { EGL_CONTEXT_CLIENT_VERSION, mGlVersion, EGL_NONE };
    return egl.eglCreateContext(eglDisplay, eglConfig, EGL_NO_CONTEXT, mGlVersion != 0 ? attribs : null);
}","{
    int[] attribs = { EGL14.EGL_CONTEXT_CLIENT_VERSION, mGlVersion, EGL_NONE };
    EGLContext context = egl.eglCreateContext(eglDisplay, eglConfig, EGL_NO_CONTEXT, mGlVersion != 0 ? attribs : null);
    if (context == null || context == EGL_NO_CONTEXT) {
        // noinspection ConstantConditions
        throw new IllegalStateException(""Could not create an EGL context. eglCreateContext failed with error: "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the late version of the implementation, a new local variable 'context' has been declared and a new return statement 'return context;' has been introduced, and the parameter in the array 'attribs' has changed. Also, a new exception statement has been introduced (throw new IllegalStateException(). Therefore, the code change type is 1,2,4.","The newly introduced 'context' variable and the corresponding return statement can potentially lead to different return values. And also, a new exception has been introduced which could change the exception handling behavior of the application. Thus, the resulting CI type classification is 1,2."
38,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,16,17,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,<android.animation.Keyframe.FloatKeyframe: FloatKeyframe clone()>,0,"{
    FloatKeyframe kfClone = new FloatKeyframe(getFraction(), mValue);
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,A new condition (mHasValue) is added in the instantiation of 'FloatKeyframe' object in the late version which leads to a control dependency change (type 3). And this affects the return statement which may now return different values (type 1).,"The change in conditon and instantiation of 'FloatKeyframe' object could potentially make the late version API return a different value. Therefore, the type of Compatibility Issue is 1."
42,<android.view.View: boolean isOpaque()>,16,17,<android.view.View: boolean isOpaque()>,<android.view.View: boolean isOpaque()>,0,"{
    return (mPrivateFlags & OPAQUE_MASK) == OPAQUE_MASK && ((mTransformationInfo != null ? mTransformationInfo.mAlpha : 1) >= 1.0f - ViewConfiguration.ALPHA_THRESHOLD);
}","{
    return (mPrivateFlags & PFLAG_OPAQUE_MASK) == PFLAG_OPAQUE_MASK && ((mTransformationInfo != null ? mTransformationInfo.mAlpha : 1.0f) >= 1.0f);
}",1,"/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
","/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has been modified and the condition in the return statement has changed. Also, the mask used on mPrivateFlags has changed from OPAQUE_MASK to PFLAG_OPAQUE_MASK which affects the masking operation. Hence, the change applies to categories: 1 (Return statement changed), 4 (Other statement changed) and 5 (Dependent API changed).","The Boolean value returned by the method could potentially differ between versions, due to changes in both the condition statement and in the mask applied to mPrivateFlags, leading to a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
44,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>",16,17,"<android.os.PowerManager: WakeLock newWakeLock(int,String)>","<android.os.PowerManager: WakeLock newWakeLock(int,String)>",0,"{
    if (tag == null) {
        throw new NullPointerException(""tag is null in PowerManager.newWakeLock"");
    }
    return new WakeLock(flags, tag);
}","{
    validateWakeLockParameters(levelAndFlags, tag);
    return new WakeLock(levelAndFlags, tag);
}",1,"/**
 * Get a wake lock at the level of the flags parameter.  Call
 * {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 *
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ...
 * wl.release();
 * }
 *
 * <p class=""note"">If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.</p>
 *
 * @param flags Combination of flag values defining the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 */
","/**
 * Creates a new wake lock with the specified level and flags.
 * <p>
 * The {@code levelAndFlags} parameter specifies a wake lock level and optional flags
 * combined using the logical OR operator.
 * </p><p>
 * The wake lock levels are: {@link #PARTIAL_WAKE_LOCK},
 * {@link #FULL_WAKE_LOCK}, {@link #SCREEN_DIM_WAKE_LOCK}
 * and {@link #SCREEN_BRIGHT_WAKE_LOCK}.  Exactly one wake lock level must be
 * specified as part of the {@code levelAndFlags} parameter.
 * </p><p>
 * The wake lock flags are: {@link #ACQUIRE_CAUSES_WAKEUP}
 * and {@link #ON_AFTER_RELEASE}.  Multiple flags can be combined as part of the
 * {@code levelAndFlags} parameters.
 * </p><p>
 * Call {@link WakeLock#acquire() acquire()} on the object to acquire the
 * wake lock, and {@link WakeLock#release release()} when you are done.
 * </p><p>
 * {@samplecode
 * PowerManager pm = (PowerManager)mContext.getSystemService(
 * Context.POWER_SERVICE);
 * PowerManager.WakeLock wl = pm.newWakeLock(
 * PowerManager.SCREEN_DIM_WAKE_LOCK
 * | PowerManager.ON_AFTER_RELEASE,
 * TAG);
 * wl.acquire();
 * // ... do work...
 * wl.release();
 * }
 * </p><p>
 * Although a wake lock can be created without special permissions,
 * the {@link android.Manifest.permission#WAKE_LOCK} permission is
 * required to actually acquire or release the wake lock that is returned.
 * </p><p class=""note"">
 * If using this to keep the screen on, you should strongly consider using
 * {@link android.view.WindowManager.LayoutParams#FLAG_KEEP_SCREEN_ON} instead.
 * This window flag will be correctly managed by the platform
 * as the user moves between applications and doesn't require a special permission.
 * </p>
 *
 * @param levelAndFlags Combination of wake lock level and flag values defining
 * the requested behavior of the WakeLock.
 * @param tag Your class name (or other tag) for debugging purposes.
 *
 * @see WakeLock#acquire()
 * @see WakeLock#release()
 * @see #PARTIAL_WAKE_LOCK
 * @see #FULL_WAKE_LOCK
 * @see #SCREEN_DIM_WAKE_LOCK
 * @see #SCREEN_BRIGHT_WAKE_LOCK
 * @see #ACQUIRE_CAUSES_WAKEUP
 * @see #ON_AFTER_RELEASE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,5","2,1","The condition of throwing NullPointerException has been modified to validateWakeLockParameters() function and the parameter of WakeLock() has changed from 'flags' to 'levelAndFlags'. Thus, the change type is 2,5.","Since the validation function validateWakeLockParameters() can potentially throw different exceptions and the parameter of WakeLock() has changed, the API can potentially return different types or values. Thus, the CI type is 2,1."
46,<android.app.Fragment: void performStart()>,16,17,<android.app.Fragment: void performStart()>,<android.app.Fragment: void performStart()>,0,"{
    onStart();
    if (mLoaderManager != null) {
        mLoaderManager.doReportStart();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.noteStateNotSaved();
        mChildFragmentManager.execPendingActions();
    }
    mCalled = false;
    onStart();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStart()"");
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStart();
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","There are changes present in return and exception handling statements. New exception statements have been introduced (throw new SuperNotCalledException). Also, the APIs onStart() and if (mChildFragmentManager != null) mChildFragmentManager.dispatchStart() have been added. Moreover, control flow dependency has changed with the added if-checks. So, the change type is 1,2,3,4.","The presence of new exception throwing statements may lead to new exceptions that were not present in the early version. Moreover, the new method calls may potentially lead to different return values in the late version. As a result, both types of compatibility issues (1 and 2) may exist."
47,<android.view.View: void dispatchSaveInstanceState(SparseArray<Parcelable>)>,16,17,<android.view.View: void dispatchSaveInstanceState(SparseArray<Parcelable>)>,<android.view.View: void dispatchSaveInstanceState(SparseArray<Parcelable>)>,0,"{
    if (mID != NO_ID && (mViewFlags & SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &= ~SAVE_STATE_CALLED;
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags & SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(""Derived class did not call super.onSaveInstanceState()"");
        }
        if (state != null) {
            // Log.i(""View"", ""Freezing #"" + Integer.toHexString(mID)
            // + "": "" + state);
            container.put(mID, state);
        }
    }
}","{
    if (mID != NO_ID && (mViewFlags & SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &= ~PFLAG_SAVE_STATE_CALLED;
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags & PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(""Derived class did not call super.onSaveInstanceState()"");
        }
        if (state != null) {
            // Log.i(""View"", ""Freezing #"" + Integer.toHexString(mID)
            // + "": "" + state);
            container.put(mID, state);
        }
    }
}",1,"/**
 * Called by {@link #saveHierarchyState(android.util.SparseArray)} to store the state for
 * this view and its children. May be overridden to modify how freezing happens to a
 * view's children; for example, some views may want to not store state for their children.
 *
 * @param container The SparseArray in which to save the view's state.
 *
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #onSaveInstanceState()
 */
","/**
 * Called by {@link #saveHierarchyState(android.util.SparseArray)} to store the state for
 * this view and its children. May be overridden to modify how freezing happens to a
 * view's children; for example, some views may want to not store state for their children.
 *
 * @param container The SparseArray in which to save the view's state.
 *
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #onSaveInstanceState()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the early version implementation, the constant `SAVE_STATE_CALLED` is used to clear the flag from `mPrivateFlags`. In the late version implementation, it was changed to `PFLAG_SAVE_STATE_CALLED`. So the code change type is 4.","Despite this change, it does not affect the function's control flow, return type, or exception handling. It simply changes an internal variable used in a bitwise operation, and will not result in any compatibility issue. Hence, the CI type is 0."
48,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(ComponentName)>,16,17,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(ComponentName)>,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(ComponentName)>,0,"{
    final int insertAt = mIntents.size();
    PackageManager pm = mSourceContext.getPackageManager();
    try {
        ActivityInfo info = pm.getActivityInfo(sourceActivityName, 0);
        String parentActivity = info.parentActivityName;
        while (parentActivity != null) {
            Intent parent = new Intent().setComponent(new ComponentName(info.packageName, parentActivity));
            mIntents.add(insertAt, parent);
            info = pm.getActivityInfo(parent.getComponent(), 0);
            parentActivity = info.parentActivityName;
        }
    } catch (NameNotFoundException e) {
        Log.e(TAG, ""Bad ComponentName while traversing activity parent metadata"");
        throw new IllegalArgumentException(e);
    }
    return this;
}","{
    final int insertAt = mIntents.size();
    PackageManager pm = mSourceContext.getPackageManager();
    try {
        ActivityInfo info = pm.getActivityInfo(sourceActivityName, 0);
        String parentActivity = info.parentActivityName;
        while (parentActivity != null) {
            final ComponentName target = new ComponentName(info.packageName, parentActivity);
            info = pm.getActivityInfo(target, 0);
            parentActivity = info.parentActivityName;
            final Intent parent = parentActivity == null && insertAt == 0 ? Intent.makeMainActivity(target) : new Intent().setComponent(target);
            mIntents.add(insertAt, parent);
        }
    } catch (NameNotFoundException e) {
        Log.e(TAG, ""Bad ComponentName while traversing activity parent metadata"");
        throw new IllegalArgumentException(e);
    }
    return this;
}",1,"/**
 * Add the activity parent chain as specified by the
 * {@link android.R.attr#parentActivityName parentActivityName} attribute of the activity
 * (or activity-alias) element in the application's manifest to the task stack builder.
 *
 * @param sourceActivityName Must specify an Activity component. All parents of
 * this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
","/**
 * Add the activity parent chain as specified by the
 * {@link android.R.attr#parentActivityName parentActivityName} attribute of the activity
 * (or activity-alias) element in the application's manifest to the task stack builder.
 *
 * @param sourceActivityName Must specify an Activity component. All parents of
 * this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The body of the while loop, specifically the initialization of the Intent object and how it is added to mIntents, has changed, thereby categorizing the code change as type 1.","Since the Intent object is created differently and added to the mIntents differently, the possible return value of the method (return this) could behave differently between the earlier and later versions. Therefore, the CI type is 1."
49,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,16,17,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,<android.app.admin.DevicePolicyManager: int getCurrentFailedPasswordAttempts()>,0,"{
    if (mService != null) {
        try {
            return mService.getCurrentFailedPasswordAttempts();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return -1;
}","{
    if (mService != null) {
        try {
            return mService.getCurrentFailedPasswordAttempts(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return -1;
}",1,"/**
 * Retrieve the number of times the user has failed at entering a
 * password since that last successful password entry.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call
 * this method; if it has not, a security exception will be thrown.
 */
","/**
 * Retrieve the number of times the user has failed at entering a
 * password since that last successful password entry.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} to be able to call
 * this method; if it has not, a security exception will be thrown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of this method has changed its return statement from returning mService.getCurrentFailedPasswordAttempts() to mService.getCurrentFailedPasswordAttempts(UserHandle.myUserId()). Besides, the dependent API getCurrentFailedPasswordAttempts in mService changed its parameter number and type. Therefore, the code change is classified as 1,5.","The return of this method depends on the invocation of the method getCurrentFailedPasswordAttempts of mService. Since the parameters of this method have changed, it may lead to different return values of the getCurrentFailedPasswordAttempts method, then affect the return of this method itself. Thus causing the compatibility issue(type 1)."
53,"<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>",16,17,"<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ProviderInfo getProviderInfo(ComponentName,int)>",0,"{
    try {
        ProviderInfo pi = mPM.getProviderInfo(className, flags, UserId.myUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ProviderInfo pi = mPM.getProviderInfo(className, flags, mContext.getUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The way to get the user id has changed from UserId.myUserId() to mContext.getUserId(), which isn't just a simple control dependency modification but also changes the implementation of how user id is fetched. Therefore, the change belongs to categories 4 (other statement changed) and 5 (dependent API changed).","This change of function call to get user id could lead to possibly different return values (as the ProviderInfo depends on the user id). Therefore, there is a potential Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
55,<android.view.View: boolean isPressed()>,16,17,<android.view.View: boolean isPressed()>,<android.view.View: boolean isPressed()>,0,"{
    return (mPrivateFlags & PRESSED) == PRESSED;
}","{
    return (mPrivateFlags & PFLAG_PRESSED) == PFLAG_PRESSED;
}",1,"/**
 * Indicates whether the view is currently in pressed state. Unless
 * {@link #setPressed(boolean)} is explicitly called, only clickable views can enter
 * the pressed state.
 *
 * @see #setPressed(boolean)
 * @see #isClickable()
 * @see #setClickable(boolean)
 *
 * @return true if the view is currently pressed, false otherwise
 */
","/**
 * Indicates whether the view is currently in pressed state. Unless
 * {@link #setPressed(boolean)} is explicitly called, only clickable views can enter
 * the pressed state.
 *
 * @see #setPressed(boolean)
 * @see #isClickable()
 * @see #setClickable(boolean)
 *
 * @return true if the view is currently pressed, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the late version is changed, from (mPrivateFlags & PRESSED) == PRESSED to (mPrivateFlags & PFLAG_PRESSED) == PFLAG_PRESSED. This shows the potential changes in variable types or values, implying both Return statement changed and Dependent API changed.","The function return has been altered with a different statement in the late version. Therefore, it has a compatibility issue as it may potentially return different values or types, resulting in Compatibility Issue caused by potential different return values or types."
56,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>",16,17,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivityOptions(ComponentName,Intent[],Intent,int)>",0,"{
    final ContentResolver resolver = mContext.getContentResolver();
    String[] specificTypes = null;
    if (specifics != null) {
        final int N = specifics.length;
        for (int i = 0; i < N; i++) {
            Intent sp = specifics[i];
            if (sp != null) {
                String t = sp.resolveTypeIfNeeded(resolver);
                if (t != null) {
                    if (specificTypes == null) {
                        specificTypes = new String[N];
                    }
                    specificTypes[i] = t;
                }
            }
        }
    }
    try {
        return mPM.queryIntentActivityOptions(caller, specifics, specificTypes, intent, intent.resolveTypeIfNeeded(resolver), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    final ContentResolver resolver = mContext.getContentResolver();
    String[] specificTypes = null;
    if (specifics != null) {
        final int N = specifics.length;
        for (int i = 0; i < N; i++) {
            Intent sp = specifics[i];
            if (sp != null) {
                String t = sp.resolveTypeIfNeeded(resolver);
                if (t != null) {
                    if (specificTypes == null) {
                        specificTypes = new String[N];
                    }
                    specificTypes[i] = t;
                }
            }
        }
    }
    try {
        return mPM.queryIntentActivityOptions(caller, specifics, specificTypes, intent, intent.resolveTypeIfNeeded(resolver), flags, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API mPM.queryIntentActivityOptions() has changed, with the last parameter changing from UserId.myUserId() to mContext.getUserId(). Hence, the code change type is 1,5.","The change in the parameters of the dependent API mPM.queryIntentActivityOptions() may lead to potential different return values in the late version, thus the CI type is 1."
58,"<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>",16,17,"<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>","<android.app.ApplicationPackageManager: PackageInfo getPackageInfo(String,int)>",0,"{
    try {
        PackageInfo pi = mPM.getPackageInfo(packageName, flags, UserId.myUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        PackageInfo pi = mPM.getPackageInfo(packageName, flags, mContext.getUserId());
        if (pi != null) {
            return pi;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"There is a change in the method from UserId.myUserId() to mContext.getUserId() which is a dependent API change, and also change within statement where variable 'pi' gets its value, so change type is 4 and 5.","The use of a different method to obtain user id can potentially return different result for 'pi', which can lead to the return of a different value by the getPackageInfo method. Hence, the CI type is 1."
59,"<android.view.ViewRootImpl.W: void dispatchWallpaperOffsets(float,float,float,float,boolean)>",16,17,"<android.view.ViewRootImpl.W: void dispatchWallpaperOffsets(float,float,float,float,boolean)>","<android.view.ViewRootImpl.W: void dispatchWallpaperOffsets(float,float,float,float,boolean)>",0,"{
    if (sync) {
        try {
            sWindowSession.wallpaperOffsetsComplete(asBinder());
        } catch (RemoteException e) {
        }
    }
}","{
    if (sync) {
        try {
            mWindowSession.wallpaperOffsetsComplete(asBinder());
        } catch (RemoteException e) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,The dependent API call in the 'try' statement has changed from sWindowSession.wallpaperOffsetsComplete(asBinder()) to mWindowSession.wallpaperOffsetsComplete(asBinder()). This implies an 'Other statement changed.',There is no Compatibility Issue as this change of calling wallpapaerOffsetsComplete() on different objects doesn't affect the potential return value/type or exception handling of the method. Class 0 indicates no Compatibility Issue.
60,<android.widget.AbsListView: void handleDataChanged()>,16,17,<android.widget.AbsListView: void handleDataChanged()>,<android.widget.AbsListView: void handleDataChanged()>,0,"{
    int count = mItemCount;
    int lastHandledItemCount = mLastHandledItemCount;
    mLastHandledItemCount = mItemCount;
    if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
        confirmCheckedPositionsById();
    }
    // TODO: In the future we can recycle these views based on stable ID instead.
    mRecycler.clearTransientStateViews();
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getHeight() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}","{
    int count = mItemCount;
    int lastHandledItemCount = mLastHandledItemCount;
    mLastHandledItemCount = mItemCount;
    if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
        confirmCheckedPositionsById();
    }
    // TODO: In the future we can recycle these views based on stable ID instead.
    mRecycler.clearTransientStateViews();
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            mPendingSync = null;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getHeight() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mPendingSync = null;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The statement mPendingSync = null; has been added but doesn't change the behaviour of the method nor any return statements, therefore, this is classified as code change type 4 (other statement change).","The addition of the mPendingSync = null; statement does not affect the method's return value or its exception handling, therefore it does not induce a Compatibility Issue."
61,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLowerCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLowerCase(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of lower case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of lower case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of lower case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of lower case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API ( setPasswordMinimumLowerCase) in the implementation changes its parameters from (admin, length) to (admin, length, UserHandle.myUserId()) and becomes a different method. Thus, the change type is 1 (return statement changed) and 5 (Dependent API changed).","The change in the dependent API could potentially return a different result when the late version is invoked, hence the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
62,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Class<?>)>,16,17,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Class<?>)>,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Class<?>)>,0,"{
    final int insertAt = mIntents.size();
    PackageManager pm = mSourceContext.getPackageManager();
    try {
        ActivityInfo info = pm.getActivityInfo(new ComponentName(mSourceContext, sourceActivityClass), 0);
        String parentActivity = info.parentActivityName;
        while (parentActivity != null) {
            Intent parent = new Intent().setComponent(new ComponentName(mSourceContext, parentActivity));
            mIntents.add(insertAt, parent);
            info = pm.getActivityInfo(parent.getComponent(), 0);
            parentActivity = info.parentActivityName;
        }
    } catch (NameNotFoundException e) {
        Log.e(TAG, ""Bad ComponentName while traversing activity parent metadata"");
        throw new IllegalArgumentException(e);
    }
    return this;
}","{
    return addParentStack(new ComponentName(mSourceContext, sourceActivityClass));
}",1,"/**
 * Add the activity parent chain as specified by the
 * {@link android.R.attr#parentActivityName parentActivityName} attribute of the activity
 * (or activity-alias) element in the application's manifest to the task stack builder.
 *
 * @param sourceActivityClass All parents of this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
","/**
 * Add the activity parent chain as specified by the
 * {@link android.R.attr#parentActivityName parentActivityName} attribute of the activity
 * (or activity-alias) element in the application's manifest to the task stack builder.
 *
 * @param sourceActivityClass All parents of this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4","1,2","The method implementation has been changed completely. The late version directly calls another function addParentStack() with ComponentName as its parameter instead of the traversal logic of parent activities used in the early version. This indicates a change in both return statement and other statements in the method body, therefore the change types are 1,4.","With the change of the function body, the method may return a different result when given the same input, indicating a compatibility issue of type 1. The try-catch exception handling has also been removed in the new implementation, potentially leads to different exception thrown when encountering the same error, which is a compatibility issue of type 2."
63,<android.app.Activity: void performStart()>,16,17,<android.app.Activity: void performStart()>,<android.app.Activity: void performStart()>,0,"{
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        for (int i = mAllLoaderManagers.size() - 1; i >= 0; i--) {
            LoaderManagerImpl lm = mAllLoaderManagers.valueAt(i);
            lm.finishRetain();
            lm.doReportStart();
        }
    }
}","{
    mFragments.noteStateNotSaved();
    mCalled = false;
    mFragments.execPendingActions();
    mInstrumentation.callActivityOnStart(this);
    if (!mCalled) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStart()"");
    }
    mFragments.dispatchStart();
    if (mAllLoaderManagers != null) {
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[mAllLoaderManagers.size()];
        mAllLoaderManagers.values().toArray(loaders);
        if (loaders != null) {
            for (int i = 0; i < loaders.length; i++) {
                LoaderManagerImpl lm = loaders[i];
                lm.finishRetain();
                lm.doReportStart();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control structure has been modified from a decremental for loop to an incremental for loop, both have similar functionality but use different approaches to loop through the LoaderManagerImpl elements. Therefore, the code change type is 3.","There's no change to the return values or exceptions raised by the method. The change in the loop structure doesn't affect the behavior of the API, because the loop ends up executing the same command on all elements of the 'mAllLoaderManagers' regardless of the order in which they're accessed. Therefore, no Compatibility Issue (CI) exists. The CI type is 0."
64,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",16,17,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>","<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",0,"{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The dependent API method Bitmap.createBitmap() parameters changed from (width > 0 ? width : 1, height > 0 ? height : 1, quality) in early version to (mResources.getDisplayMetrics(), width > 0 ? width : 1, height > 0 ? height : 1, quality) in late version, and variable DIRTY_MASK changed to PFLAG_DIRTY_MASK and SKIP_DRAW changed to PFLAG_SKIP_DRAW as well, so the code change type is 1,4,5.","The change in how the Bitmap is created in addition to the change in condition checks could potentially lead to a different return value in 'return bitmap'. Thus, the API may return a different value or type, resulting in a CI of type 1."
66,<android.view.View: boolean isAccessibilityFocused()>,16,17,<android.view.View: boolean isAccessibilityFocused()>,<android.view.View: boolean isAccessibilityFocused()>,0,"{
    return (mPrivateFlags2 & ACCESSIBILITY_FOCUSED) != 0;
}","{
    return (mPrivateFlags2 & PFLAG2_ACCESSIBILITY_FOCUSED) != 0;
}",1,"/**
 * Returns whether this View is accessibility focused.
 *
 * @return True if this View is accessibility focused.
 */
","/**
 * Returns whether this View is accessibility focused.
 *
 * @return True if this View is accessibility focused.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from (mPrivateFlags2 & ACCESSIBILITY_FOCUSED) to (mPrivateFlags2 & PFLAG2_ACCESSIBILITY_FOCUSED). It implies it relies on another statement which has been changed, hence the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
67,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setMaximumFailedPasswordsForWipe(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setMaximumFailedPasswordsForWipe(admin, num, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Setting this to a value greater than zero enables a built-in policy
 * that will perform a device wipe after too many incorrect
 * device-unlock passwords have been entered.  This built-in policy combines
 * watching for failed passwords and wiping the device, and requires
 * that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 *
 * <p>To implement any other policy (e.g. wiping data for a particular
 * application only, erasing or revoking credentials, or reporting the
 * failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
 * instead.  Do not use this API, because if the maximum count is reached,
 * the device will be wiped immediately, and your callback will not be invoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the
 * device will wipe its data.
 */
","/**
 * Setting this to a value greater than zero enables a built-in policy
 * that will perform a device wipe after too many incorrect
 * device-unlock passwords have been entered.  This built-in policy combines
 * watching for failed passwords and wiping the device, and requires
 * that you request both {@link DeviceAdminInfo#USES_POLICY_WATCH_LOGIN} and
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA}}.
 *
 * <p>To implement any other policy (e.g. wiping data for a particular
 * application only, erasing or revoking credentials, or reporting the
 * failure to a server), you should implement
 * {@link DeviceAdminReceiver#onPasswordFailed(Context, android.content.Intent)}
 * instead.  Do not use this API, because if the maximum count is reached,
 * the device will be wiped immediately, and your callback will not be invoked.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param num The number of failed password attempts at which point the
 * device will wipe its data.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method call in the try block has changed from mService.setMaximumFailedPasswordsForWipe(admin, num) to mService.setMaximumFailedPasswordsForWipe(admin, num, UserHandle.myUserId()). This implies a change in the method called, altering the parameters passed in that method. Thus indicating a change in return statements and the change in a dependent API.","There is no Change Impact (CI) as such because the method doesn't return any value, it's a void type. Thus, no return type/value has been changed. Any error during the execution will still be logged as before. So, it is safe to say that the behavioural change between both versions is very minimal and won't affect backward compatibility."
69,<android.webkit.WebView: String findAddress(String)>,16,17,<android.webkit.WebView: String findAddress(String)>,<android.webkit.WebView: String findAddress(String)>,0,"{
    checkThread();
    return getFactory().getStatics().findAddress(addr);
}","{
    return getFactory().getStatics().findAddress(addr);
}",1,"/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
","/**
 * Gets the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * <ul>
 * <li>a house number</li>
 * <li>a street name</li>
 * <li>a street type (Road, Circle, etc), either spelled out or
 * abbreviated</li>
 * <li>a city name</li>
 * <li>a state or territory, either spelled out or two-letter abbr</li>
 * <li>an optional 5 digit or 9 digit zip code</li>
 * </ul>
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 *
 * @param addr the string to search for addresses
 * @return the address, or if no address is found, null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'checkThread()' function call has been removed, categorizing this as an ""other statement changed"" class 4. ","The removal of the 'checkThread()' statement, which is likely used for controlling multithreading, doesn't change the return value or exception handling of the API, and hence, no compatibility issue (class 0) is detected."
70,<android.widget.TextView: boolean bringPointIntoView(int)>,16,17,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}","{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late implementation, a new 'if' statement is introduced at the top, this can affect the control flow and potentially lead to different return values because of the new 'return' statement inside it. Thus, the code change type is 1,3.","As the first 'if' condition in the late implementation can lead to an early return of false, this potentially changes the behaviour of API, leading to different return values. Therefore, the CI type is 1."
71,<android.view.View: boolean isFocused()>,16,17,<android.view.View: boolean isFocused()>,<android.view.View: boolean isFocused()>,0,"{
    return (mPrivateFlags & FOCUSED) != 0;
}","{
    return (mPrivateFlags & PFLAG_FOCUSED) != 0;
}",1,"/**
 * Returns true if this view has focus
 *
 * @return True if this view has focus, false otherwise.
 */
","/**
 * Returns true if this view has focus
 *
 * @return True if this view has focus, false otherwise.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""focus"")]","[@ViewDebug.ExportedProperty(category = ""focus"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return (mPrivateFlags & FOCUSED) != 0' to 'return (mPrivateFlags & PFLAG_FOCUSED) != 0', so the change type is 1. Also, it appears that a dependent API (FOCUSED vs PFLAG_FOCUSED) has been changed in the return statement, making the change type a 5 as well.","Changing the dependent API in the return statement could potentially make the function return different values. Therefore, the CI type is 1."
73,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",16,17,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is an introduced invocation of the method warnIfCallingFromSystemProcess() in the late version, and the parameter of ActivityManagerNative.getDefault().broadcastIntent() has changed from Binder.getOrigCallingUser() to getUserId(), hence the change type is 4 - Other statement changed.","Despite the aforementioned changes in other statements, they do not introduce a Compatibility Issue based on provided definitions. Both versions do not have the variations in how they return values or handle exceptions. Thus the CI is type 0 - No Compatibility Issue exist."
75,"<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>",16,17,"<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>","<android.provider.Settings.System: boolean putInt(ContentResolver,String,int)>",0,"{
    return putString(cr, name, Integer.toString(value));
}","{
    return putIntForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has changed, especially the return statement from putString() to putIntForUser(). Additionally, the dependent API has changed as well, so the code change type is 1,5.","The change in the return statement and the dependent API could potentially make the API return a different value. Hence, the CI type is 1."
77,<android.webkit.ZoomManager: boolean onNewPicture(DrawData)>,16,17,<android.webkit.ZoomManager: boolean onNewPicture(DrawData)>,<android.webkit.ZoomManager: boolean onNewPicture(DrawData)>,0,"{
    final int viewWidth = mWebView.getViewWidth();
    final boolean zoomOverviewWidthChanged = setupZoomOverviewWidth(drawData, viewWidth);
    final float newZoomOverviewScale = getZoomOverviewScale();
    WebSettingsClassic settings = mWebView.getSettings();
    if (zoomOverviewWidthChanged && settings.isNarrowColumnLayout() && settings.getUseFixedViewport() && (mInitialZoomOverview || mInZoomOverview)) {
        // the text wrap scale is the same as zoom overview scale.
        if (exceedsMinScaleIncrement(mTextWrapScale, mDefaultScale) || exceedsMinScaleIncrement(newZoomOverviewScale, mDefaultScale)) {
            mTextWrapScale = getReadingLevelScale();
        } else {
            mTextWrapScale = newZoomOverviewScale;
        }
    }
    if (!mMinZoomScaleFixed || settings.getUseWideViewPort()) {
        mMinZoomScale = newZoomOverviewScale;
        mMaxZoomScale = Math.max(mMaxZoomScale, mMinZoomScale);
    }
    // fit the content width to the current view for the first new picture
    // after first layout.
    boolean scaleHasDiff = exceedsMinScaleIncrement(newZoomOverviewScale, mActualScale);
    // Make sure the actual scale is no less than zoom overview scale.
    boolean scaleLessThanOverview = (newZoomOverviewScale - mActualScale) >= MINIMUM_SCALE_INCREMENT;
    // Make sure mobile sites are correctly handled since mobile site will
    // change content width after rotating.
    boolean mobileSiteInOverview = mInZoomOverview && !exceedsMinScaleIncrement(newZoomOverviewScale, mDefaultScale);
    if (!mWebView.drawHistory() && ((scaleLessThanOverview && settings.getUseWideViewPort()) || ((mInitialZoomOverview || mobileSiteInOverview) && scaleHasDiff && zoomOverviewWidthChanged))) {
        mInitialZoomOverview = false;
        setZoomScale(newZoomOverviewScale, !willScaleTriggerZoom(mTextWrapScale) && !mWebView.getSettings().getUseFixedViewport());
    } else {
        mInZoomOverview = !scaleHasDiff;
    }
    if (drawData.mFirstLayoutForNonStandardLoad && settings.getLoadWithOverviewMode()) {
        // Set mInitialZoomOverview in case this is the first picture for non standard load,
        // so next new picture could be forced into overview mode if it's true.
        mInitialZoomOverview = mInZoomOverview;
    }
    return scaleHasDiff;
}","{
    final int viewWidth = mWebView.getViewWidth();
    final boolean zoomOverviewWidthChanged = setupZoomOverviewWidth(drawData, viewWidth);
    final float newZoomOverviewScale = getZoomOverviewScale();
    WebSettingsClassic settings = mWebView.getSettings();
    if (zoomOverviewWidthChanged && settings.isNarrowColumnLayout() && settings.getUseFixedViewport() && (mInitialZoomOverview || mInZoomOverview)) {
        // the text wrap scale is the same as zoom overview scale.
        if (exceedsMinScaleIncrement(mTextWrapScale, mDefaultScale) || exceedsMinScaleIncrement(newZoomOverviewScale, mDefaultScale)) {
            mTextWrapScale = getReadingLevelScale();
        } else {
            mTextWrapScale = newZoomOverviewScale;
        }
    }
    if (!mMinZoomScaleFixed || settings.getUseWideViewPort()) {
        mMinZoomScale = newZoomOverviewScale;
        mMaxZoomScale = Math.max(mMaxZoomScale, mMinZoomScale);
        sanitizeMinMaxScales();
    }
    // fit the content width to the current view for the first new picture
    // after first layout.
    boolean scaleHasDiff = exceedsMinScaleIncrement(newZoomOverviewScale, mActualScale);
    // Make sure the actual scale is no less than zoom overview scale.
    boolean scaleLessThanOverview = (newZoomOverviewScale - mActualScale) >= MINIMUM_SCALE_INCREMENT;
    // Make sure mobile sites are correctly handled since mobile site will
    // change content width after rotating.
    boolean mobileSiteInOverview = mInZoomOverview && !exceedsMinScaleIncrement(newZoomOverviewScale, mDefaultScale);
    if (!mWebView.drawHistory() && ((scaleLessThanOverview && settings.getUseWideViewPort()) || ((mInitialZoomOverview || mobileSiteInOverview) && scaleHasDiff && zoomOverviewWidthChanged))) {
        mInitialZoomOverview = false;
        setZoomScale(newZoomOverviewScale, !willScaleTriggerZoom(mTextWrapScale) && !mWebView.getSettings().getUseFixedViewport());
    } else {
        mInZoomOverview = !scaleHasDiff;
    }
    if (drawData.mFirstLayoutForNonStandardLoad && settings.getLoadWithOverviewMode()) {
        // Set mInitialZoomOverview in case this is the first picture for non standard load,
        // so next new picture could be forced into overview mode if it's true.
        mInitialZoomOverview = mInZoomOverview;
    }
    return scaleHasDiff;
}",1,"/**
 * Updates zoom values when Webkit produces a new picture. This method
 * should only be called from the UI thread's message handler.
 *
 * @return True if zoom value has changed
 */
","/**
 * Updates zoom values when Webkit produces a new picture. This method
 * should only be called from the UI thread's message handler.
 *
 * @return True if zoom value has changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method sanitizeMinMaxScales() has been introduced, so the code change type is 4.","As the new method call does not lead to the API returning a different value or throwing a different exception, there's no compatibility issue exist, so the CI type is 0."
78,<android.content.ContentResolver: String getType(Uri)>,16,17,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url);
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}","{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId());
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, ""Failed to get type for: "" + url + "" ("" + e.getMessage() + "")"");
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API has changed from ActivityManagerNative.getDefault().getProviderMimeType(url) to ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId()). Hence, the code change type is 5.","As the dependent API has invoked with an extra parameter (UserHandle.myUserId()), the output returned by the function (providerMimeType) and hence the output of this API (getType) can be potentially different, causing the CI type to be 1."
79,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",16,17,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireProvider(Context,String)>",0,"{
    return mMainThread.acquireProvider(context, name, true);
}","{
    return mMainThread.acquireProvider(context, auth, mUser.getIdentifier(), true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mMainThread.acquireProvider(context, name, true) to mMainThread.acquireProvider(context, auth, mUser.getIdentifier(), true) and the parameter type of acquireProvider() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
81,"<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>",16,17,"<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>","<android.webkit.WebViewClassic: void setNewPicture(DrawData,boolean)>",0,"{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        setBaseLayer(draw.mBaseLayer, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout);
    }
    final Point viewSize = draw.mViewSize;
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        int scrollX = viewState.mShouldStartScrolledRight ? getContentWidth() : viewState.mScrollX;
        int scrollY = viewState.mScrollY;
        contentScrollTo(scrollX, scrollY, false);
        if (!mDrawHistory) {
            // As we are on a new page, hide the keyboard
            hideSoftKeyboard();
        }
    }
    mSendScrollEvent = true;
    int functor = 0;
    boolean forceInval = isPictureAfterFirstLayout;
    ViewRootImpl viewRoot = mWebView.getViewRootImpl();
    if (mWebView.isHardwareAccelerated() && viewRoot != null) {
        functor = nativeGetDrawGLFunction(mNativeClass);
        if (functor != 0) {
            // force an invalidate if functor attach not successful
            forceInval |= !viewRoot.attachFunctor(functor);
        }
    }
    if (functor == 0 || forceInval || mWebView.getLayerType() != View.LAYER_TYPE_NONE) {
        // invalidate the screen so that the next repaint will show new content
        // TODO: partial invalidate
        mWebView.invalidate();
    }
    // update the zoom information based on the new picture
    if (mZoomManager.onNewPicture(draw))
        invalidate();
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
    scrollEditWithCursor();
    if (mPictureListener != null) {
        if (!mWebView.isHardwareAccelerated() || mWebView.getLayerType() == View.LAYER_TYPE_SOFTWARE) {
            // trigger picture listener for software layers. Hardware layers are
            // triggered in pageSwapCallback
            mPictureListener.onNewPicture(getWebView(), capturePicture());
        }
    }
}","{
    if (mNativeClass == 0) {
        if (mDelaySetPicture != null) {
            throw new IllegalStateException(""Tried to setNewPicture with"" + "" a delay picture already set! (memory leak)"");
        }
        // Not initialized yet, delay set
        mDelaySetPicture = draw;
        return;
    }
    WebViewCore.ViewState viewState = draw.mViewState;
    boolean isPictureAfterFirstLayout = viewState != null;
    if (updateBaseLayer) {
        setBaseLayer(draw.mBaseLayer, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout);
    }
    final Point viewSize = draw.mViewSize;
    // We update the layout (i.e. request a layout from the
    // view system) if the last view size that we sent to
    // WebCore matches the view size of the picture we just
    // received in the fixed dimension.
    final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
    // Don't send scroll event for picture coming from webkit,
    // since the new picture may cause a scroll event to override
    // the saved history scroll position.
    mSendScrollEvent = false;
    recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
    if (isPictureAfterFirstLayout) {
        // Reset the last sent data here since dealing with new page.
        mLastWidthSent = 0;
        mZoomManager.onFirstLayout(draw);
        int scrollX = viewState.mShouldStartScrolledRight ? getContentWidth() : viewState.mScrollX;
        int scrollY = viewState.mScrollY;
        contentScrollTo(scrollX, scrollY, false);
        if (!mDrawHistory) {
            // As we are on a new page, hide the keyboard
            hideSoftKeyboard();
        }
    }
    mSendScrollEvent = true;
    int functor = 0;
    boolean forceInval = isPictureAfterFirstLayout;
    ViewRootImpl viewRoot = mWebView.getViewRootImpl();
    if (mWebView.isHardwareAccelerated() && mWebView.getLayerType() != View.LAYER_TYPE_SOFTWARE && viewRoot != null) {
        functor = nativeGetDrawGLFunction(mNativeClass);
        if (functor != 0) {
            // force an invalidate if functor attach not successful
            forceInval |= !viewRoot.attachFunctor(functor);
        }
    }
    if (functor == 0 || forceInval || mWebView.getLayerType() != View.LAYER_TYPE_NONE) {
        // invalidate the screen so that the next repaint will show new content
        // TODO: partial invalidate
        mWebView.invalidate();
    }
    // update the zoom information based on the new picture
    if (mZoomManager.onNewPicture(draw))
        invalidate();
    if (isPictureAfterFirstLayout) {
        mViewManager.postReadyToDrawAll();
    }
    scrollEditWithCursor();
    if (mPictureListener != null) {
        if (!mWebView.isHardwareAccelerated() || mWebView.getLayerType() == View.LAYER_TYPE_SOFTWARE) {
            // trigger picture listener for software layers. Hardware layers are
            // triggered in pageSwapCallback
            mPictureListener.onNewPicture(getWebView(), capturePicture());
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the 'if' condition checking whether the WebView is hardware accelerated, an additional condition has been added to check that the layer type is not software. This is a change in control dependency, so the code change type is 3.","The introduced control dependency does not affect the potential return values or exceptions of the API, so no compatibility issue exists. The CI type is 0."
82,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>",16,17,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireUnstableProvider(Context,String)>",0,"{
    return mMainThread.acquireProvider(c, name, false);
}","{
    return mMainThread.acquireProvider(c, auth, mUser.getIdentifier(), false);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameters passed to mMainThread.acquireProvider() has changed in the late version, the argument 2 and 3 are different from the early version. So, the change type is 1,5.","As parameters passed to the mMainThread.acquireProvider() method have changed, this could potentially lead to the method returning a different IContentProvider, hence the CI type is 1."
84,<android.app.NotificationManager: void cancelAll()>,16,17,<android.app.NotificationManager: void cancelAll()>,<android.app.NotificationManager: void cancelAll()>,0,"{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg);
    } catch (RemoteException e) {
    }
}","{
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": cancelAll()"");
    try {
        service.cancelAllNotifications(pkg, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
","/**
 * Cancel all previously shown notifications. See {@link #cancel} for the
 * detailed behavior.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The function call service.cancelAllNotifications(pkg) has changed to service.cancelAllNotifications(pkg, UserHandle.myUserId()) by adding one new parameter UserHandle.myUserId(), thus change types are 4,5.","The code changes are made within a try block and it's not altering the exception handling or the return value of the method. Thus, no compatibility issue is identified."
86,<android.view.ViewGroup: boolean dispatchTrackballEvent(MotionEvent)>,16,17,<android.view.ViewGroup: boolean dispatchTrackballEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTrackballEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTrackballEvent(event, 1);
    }
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        if (super.dispatchTrackballEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        if (mFocused.dispatchTrackballEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTrackballEvent(event, 1);
    }
    if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        if (super.dispatchTrackballEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) {
        if (mFocused.dispatchTrackballEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The names of the flags used in the condition checking expressions are changed, but this doesn't affect the return value. So, the change type is 4.","Although there is a change, it doesn't affect the return value or exceptions thrown by the method, thus there is no compatibility issue (CI type 0)."
87,<android.bluetooth.BluetoothSocket: boolean isConnected()>,16,17,<android.bluetooth.BluetoothSocket: boolean isConnected()>,<android.bluetooth.BluetoothSocket: boolean isConnected()>,0,"{
    return (mSocketState == SocketState.CONNECTED);
}","{
    return mSocketState == SocketState.CONNECTED;
}",1,"/**
 * Get the connection status of this socket, ie, whether there is an active connection with
 * remote device.
 * @return true if connected
 * false if not connected
 */
","/**
 * Get the connection status of this socket, ie, whether there is an active connection with
 * remote device.
 * @return true if connected
 * false if not connected
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no change in functionality between the two versions; the only difference is in the use of parentheses, which does not influence the return of the function or cause any compatibility issues. Therefore, the code change type is 0.","Since there is no effective change in the given method between two continuous versions, it means no compatibility issue exists, so the CI type is 0."
89,<android.webkit.WebViewClassic: WebBackForwardList saveState(Bundle)>,16,17,<android.webkit.WebViewClassic: WebBackForwardList saveState(Bundle)>,<android.webkit.WebViewClassic: WebBackForwardList saveState(Bundle)>,0,"{
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean(""privateBrowsingEnabled"", isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
}","{
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardListClassic list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItemClassic item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean(""privateBrowsingEnabled"", isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
}",1,"/**
 * See {@link WebView#saveState(Bundle)}
 */
","/**
 * See {@link WebView#saveState(Bundle)}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements include a method that has changed its type from WebBackForwardList to WebBackForwardListClassic and the variable type of item has also changed, so the code change type is 1,5.","Due to the change of return statement and the change of some dependent APIs, the API could potentially return a different value, so CI type is 1."
90,<android.webkit.WebViewClassic: boolean canGoBack()>,16,17,<android.webkit.WebViewClassic: boolean canGoBack()>,<android.webkit.WebViewClassic: boolean canGoBack()>,0,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() > 0;
        }
    }
}","{
    WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() > 0;
        }
    }
}",1,"/**
 * See {@link WebView#canGoBack()}
 */
","/**
 * See {@link WebView#canGoBack()}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The type of the variable 'l' has changed from 'WebBackForwardList' to 'WebBackForwardListClassic', so the code change type is 5.","Although the type of variable 'l' has changed, the methods that being called (getClearPending() and getCurrentIndex()) have not been changed, and this will not result in a different return value or unexpected exception in this implementation, therefore, the CI type is 0."
91,<android.view.View: int[] onCreateDrawableState(int)>,16,17,<android.view.View: int[] onCreateDrawableState(int)>,<android.view.View: int[] onCreateDrawableState(int)>,0,"{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PRESSED) != 0)
        viewStateIndex |= VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= VIEW_STATE_FOCUSED;
    if ((privateFlags & SELECTED) != 0)
        viewStateIndex |= VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & ACTIVATED) != 0)
        viewStateIndex |= VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & DRAG_CAN_ACCEPT) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_CAN_ACCEPT;
    if ((privateFlags2 & DRAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_HOVERED;
    drawableState = VIEW_STATE_SETS[viewStateIndex];
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}","{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PFLAG_PRESSED) != 0)
        viewStateIndex |= VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= VIEW_STATE_FOCUSED;
    if ((privateFlags & PFLAG_SELECTED) != 0)
        viewStateIndex |= VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & PFLAG_ACTIVATED) != 0)
        viewStateIndex |= VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & PFLAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_CAN_ACCEPT;
    if ((privateFlags2 & PFLAG2_DRAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_HOVERED;
    drawableState = VIEW_STATE_SETS[viewStateIndex];
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PFLAG_PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & PFLAG_SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}",1,"/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
","/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,No Compatibility Issue exist,"The only changes made to the code were the names of the constants (e.g., PRESSED to PFLAG_PRESSED, SELECTED to PFLAG_SELECTED, etc.) but the logic and flow of the code hasn't been changed, so the code change type is 4.","Since the changes only involve renaming of constants, no new behaviour is introduced and the returns and exception handlings are kept the same. Therefore, no compatibility issue exists."
93,"<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>",16,17,"<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>","<android.provider.Settings.System: float getFloat(ContentResolver,String,float)>",0,"{
    String v = getString(cr, name);
    try {
        return v != null ? Float.parseFloat(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    return getFloatForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the function is completely different between the Early_version and the Late_Version. The return statement changed to return the value from a different function getFloatForUser() and also it no more depends on the try-catch block in the early version, so the code change type is 1,5.","Since the return statement has changed, the API will potentially return a different value or type. The method call getFloatForUser() may return different results compared to the previous logic implementation, hence there is a potential compatibility issue and the CI type is 1."
94,<android.speech.tts.BlockingAudioTrack: int write(byte[])>,16,17,<android.speech.tts.BlockingAudioTrack: int write(byte[])>,<android.speech.tts.BlockingAudioTrack: int write(byte[])>,0,"{
    if (mAudioTrack == null || mStopped) {
        return -1;
    }
    final int bytesWritten = writeToAudioTrack(mAudioTrack, data);
    mBytesWritten += bytesWritten;
    return bytesWritten;
}","{
    AudioTrack track = null;
    synchronized (mAudioTrackLock) {
        track = mAudioTrack;
    }
    if (track == null || mStopped) {
        return -1;
    }
    final int bytesWritten = writeToAudioTrack(track, data);
    mBytesWritten += bytesWritten;
    return bytesWritten;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the later version, the initialization of the 'track' variable and how it's being assigned the value 'mAudioTrack' have been changed. However, this doesn't change the control dependency, return statements, or exception handling nor the dependent APIs, so the code change type is 4.","While code changes have occurred, none of those changes would potentially cause the API to return different variable types/values or throw the exception differently. In other words, the changes won't lead to a Compatibility Issue according to the defined rules. Therefore, the CI type is 0."
95,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordHistoryLength(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordHistoryLength(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordHistoryLength(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current password history length for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 * @return The length of the password history
 */
","/**
 * Retrieve the current password history length for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 * @return The length of the password history
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement ""mService.getPasswordHistoryLength(admin)"" changed to ""getPasswordHistoryLength(admin, UserHandle.myUserId())"". As the dependent API 'getPasswordHistoryLength' has changed its parameters, the code change types are 1 and 5. ","The change in the return statement and dependent API's parameters could make the API return a different value. Therefore, the CI type is 1."
97,<android.view.View: Parcelable onSaveInstanceState()>,16,17,<android.view.View: Parcelable onSaveInstanceState()>,<android.view.View: Parcelable onSaveInstanceState()>,0,"{
    mPrivateFlags |= SAVE_STATE_CALLED;
    return BaseSavedState.EMPTY_STATE;
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    return BaseSavedState.EMPTY_STATE;
}",1,"/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save. The
 * default implementation returns null.
 * @see #onRestoreInstanceState(android.os.Parcelable)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #setSaveEnabled(boolean)
 */
","/**
 * Hook allowing a view to generate a representation of its internal state
 * that can later be used to create a new instance with that same state.
 * This state should only contain information that is not persistent or can
 * not be reconstructed later. For example, you will never store your
 * current position on screen because that will be computed again when a
 * new instance of the view is placed in its view hierarchy.
 * <p>
 * Some examples of things you may store here: the current cursor position
 * in a text view (but usually not the text itself since that is stored in a
 * content provider or other persistent storage), the currently selected
 * item in a list view.
 *
 * @return Returns a Parcelable object containing the view's current dynamic
 * state, or null if there is nothing interesting to save. The
 * default implementation returns null.
 * @see #onRestoreInstanceState(android.os.Parcelable)
 * @see #saveHierarchyState(android.util.SparseArray)
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #setSaveEnabled(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement has changed, from mPrivateFlags |= SAVE_STATE_CALLED; to mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;, so the code change type is 4.","The change in the assignment statement would not lead to any compatibility issue because it does not affect the return type or value of the method nor the exceptions it throws, therefore, no CI is detected."
99,<android.view.ViewGroup: boolean hasFocus()>,16,17,<android.view.ViewGroup: boolean hasFocus()>,<android.view.ViewGroup: boolean hasFocus()>,0,"{
    return (mPrivateFlags & FOCUSED) != 0 || mFocused != null;
}","{
    return (mPrivateFlags & PFLAG_FOCUSED) != 0 || mFocused != null;
}",1,"/**
 * Returns true if this view has or contains focus
 *
 * @return true if this view has or contains focus
 */
","/**
 * Returns true if this view has or contains focus
 *
 * @return true if this view has or contains focus
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been modified. The condition has changed from (mPrivateFlags & FOCUSED) to (mPrivateFlags & PFLAG_FOCUSED) and also the name of the field which is being checked has changed, so the code change types are 1,5.","Due to the changes in the field names and condition, the API may return a different value. Therefore, the CI type is 1."
100,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,16,17,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,<android.view.ViewGroup: boolean gatherTransparentRegion(Region)>,0,"{
    // If no transparent regions requested, we are always opaque.
    final boolean meOpaque = (mPrivateFlags & View.REQUEST_TRANSPARENT_REGIONS) == 0;
    if (meOpaque && region == null) {
        // The caller doesn't care about the region, so stop now.
        return true;
    }
    super.gatherTransparentRegion(region);
    final View[] children = mChildren;
    final int count = mChildrenCount;
    boolean noneOfTheChildrenAreTransparent = true;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            if (!child.gatherTransparentRegion(region)) {
                noneOfTheChildrenAreTransparent = false;
            }
        }
    }
    return meOpaque || noneOfTheChildrenAreTransparent;
}","{
    // If no transparent regions requested, we are always opaque.
    final boolean meOpaque = (mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0;
    if (meOpaque && region == null) {
        // The caller doesn't care about the region, so stop now.
        return true;
    }
    super.gatherTransparentRegion(region);
    final View[] children = mChildren;
    final int count = mChildrenCount;
    boolean noneOfTheChildrenAreTransparent = true;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            if (!child.gatherTransparentRegion(region)) {
                noneOfTheChildrenAreTransparent = false;
            }
        }
    }
    return meOpaque || noneOfTheChildrenAreTransparent;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The changed part is within an assignment statement (the value of 'meOpaque'). Specifically, the flag used in bitwise AND operation have changed from 'REQUEST_TRANSPARENT_REGIONS' to 'PFLAG_REQUEST_TRANSPARENT_REGIONS'.","Though there was a change in the flag used, the logic stays same. The change in flag doesn't effect the behaviour of the API since the return value or thrown exceptions are not influenced. Thus, no Compatibility Issue exists."
101,"<android.widget.AbsListView: boolean performItemClick(View,int,long)>",16,17,"<android.widget.AbsListView: boolean performItemClick(View,int,long)>","<android.widget.AbsListView: boolean performItemClick(View,int,long)>",0,"{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        boolean checkedStateChanged = false;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (newValue) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, newValue);
                dispatchItemClick = false;
            }
            checkedStateChanged = true;
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
            checkedStateChanged = true;
        }
        if (checkedStateChanged) {
            updateOnScreenCheckedViews();
        }
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}","{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        boolean checkedStateChanged = false;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean checked = !mCheckStates.get(position, false);
            mCheckStates.put(position, checked);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (checked) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (checked) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, checked);
                dispatchItemClick = false;
            }
            checkedStateChanged = true;
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean checked = !mCheckStates.get(position, false);
            if (checked) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
            checkedStateChanged = true;
        }
        if (checkedStateChanged) {
            updateOnScreenCheckedViews();
        }
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The variable 'newValue' in the early version is replaced by 'checked' in the late version. Hence, the code change type is 4 (other statement change).",The change is merely the renaming of a local variable which does not impact the API's behavior and will not result in compatibility issues. So the CI type is 0 (No Compatibility Issues exist).
104,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",16,17,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        mNetworkInfo.setSubtype(TelephonyManager.getDefault().getNetworkType(), TelephonyManager.getDefault().getNetworkTypeName());
        Phone.DataState state = Enum.valueOf(Phone.DataState.class, intent.getStringExtra(Phone.STATE_KEY));
        String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(Phone.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(Phone.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, Phone.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else if (intent.getAction().equals(DataConnectionTracker.ACTION_DATA_CONNECTION_TRACKER_MESSENGER)) {
        if (VDBG)
            log(mApnType + "" got ACTION_DATA_CONNECTION_TRACKER_MESSENGER"");
        mMessenger = intent.getParcelableExtra(DataConnectionTracker.EXTRA_MESSENGER);
        AsyncChannel ac = new AsyncChannel();
        ac.connect(mContext, MobileDataStateTracker.this.mHandler, mMessenger);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}","{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        int oldSubtype = mNetworkInfo.getSubtype();
        int newSubType = TelephonyManager.getDefault().getNetworkType();
        String subTypeName = TelephonyManager.getDefault().getNetworkTypeName();
        mNetworkInfo.setSubtype(newSubType, subTypeName);
        if (newSubType != oldSubtype && mNetworkInfo.isConnected()) {
            Message msg = mTarget.obtainMessage(EVENT_NETWORK_SUBTYPE_CHANGED, oldSubtype, 0, mNetworkInfo);
            msg.sendToTarget();
        }
        PhoneConstants.DataState state = Enum.valueOf(PhoneConstants.DataState.class, intent.getStringExtra(PhoneConstants.STATE_KEY));
        String reason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(PhoneConstants.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(PhoneConstants.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(PhoneConstants.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(PhoneConstants.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(PhoneConstants.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else if (intent.getAction().equals(DctConstants.ACTION_DATA_CONNECTION_TRACKER_MESSENGER)) {
        if (VDBG)
            log(mApnType + "" got ACTION_DATA_CONNECTION_TRACKER_MESSENGER"");
        mMessenger = intent.getParcelableExtra(DctConstants.EXTRA_MESSENGER);
        AsyncChannel ac = new AsyncChannel();
        ac.connect(mContext, MobileDataStateTracker.this.mHandler, mMessenger);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The literal strings used in the method, such as 'Phone.DATA_APN_TYPE_KEY', are changed to 'PhoneConstants.DATA_APN_TYPE_KEY' as well as other strings. The dependent APIs 'Phone', its constant keys and modifiers changed to 'PhoneConstants'. Some new variables and return statements like 'int oldSubtype = mNetworkInfo.getSubtype();', 'int newSubType = TelephonyManager.getDefault().getNetworkType();' were also added. Therefore, the change type is 1,4,5.","The API could potentially return different values or types due to the newly added return statements and changes to dependent APIs. Hence, the compatibility issue type is 1,2."
105,<android.view.ViewTreeObserver: boolean hasComputeInternalInsetsListeners()>,16,17,<android.view.ViewTreeObserver: boolean hasComputeInternalInsetsListeners()>,<android.view.ViewTreeObserver: boolean hasComputeInternalInsetsListeners()>,0,"{
    final CopyOnWriteArrayList<OnComputeInternalInsetsListener> listeners = mOnComputeInternalInsetsListeners;
    return (listeners != null && listeners.size() > 0);
}","{
    final CopyOnWriteArray<OnComputeInternalInsetsListener> listeners = mOnComputeInternalInsetsListeners;
    return (listeners != null && listeners.size() > 0);
}",1,"/**
 * Returns whether there are listeners for computing internal insets.
 */
","/**
 * Returns whether there are listeners for computing internal insets.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,The type of the dependent API CopyOnWriteArrayList to CopyOnWriteArray in 'listeners' initialization has been changed. So the code change type is 5.,"The change of the dependent API that 'listeners' relies on could potentially cause the 'return' statement to have a different outcome due to the potential functional difference between CopyOnWriteArrayList and CopyOnWriteArray, therefore the CI type is 1."
106,<android.os.PowerManager: void goToSleep(long)>,16,17,<android.os.PowerManager: void goToSleep(long)>,<android.os.PowerManager: void goToSleep(long)>,0,"{
    try {
        mService.goToSleep(time);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.goToSleep(time, GO_TO_SLEEP_REASON_USER);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Force the device to go to sleep. Overrides all the wake locks that are
 * held.
 *
 * @param time is used to order this correctly with the wake lock calls.
 * The time  should be in the {@link SystemClock#uptimeMillis
 * SystemClock.uptimeMillis()} time base.
 */
","/**
 * Forces the device to go to sleep.
 * <p>
 * Overrides all the wake locks that are held.
 * This is what happens when the power key is pressed to turn off the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to go to sleep was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the go to sleep request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to go to sleep.
 *
 * @see #userActivity
 * @see #wakeUp
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent method called inside the API has changed from mService.goToSleep(time) to mService.goToSleep(time, GO_TO_SLEEP_REASON_USER), so the code change type is 5.","As there is no change in exception handling or return value of the API between these two versions, no Compatibility Issue exists."
109,<android.view.ViewTreeObserver: void dispatchOnScrollChanged()>,16,17,<android.view.ViewTreeObserver: void dispatchOnScrollChanged()>,<android.view.ViewTreeObserver: void dispatchOnScrollChanged()>,0,"{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArrayList<OnScrollChangedListener> listeners = mOnScrollChangedListeners;
    if (listeners != null && listeners.size() > 0) {
        for (OnScrollChangedListener listener : listeners) {
            listener.onScrollChanged();
        }
    }
}","{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArray<OnScrollChangedListener> listeners = mOnScrollChangedListeners;
    if (listeners != null && listeners.size() > 0) {
        CopyOnWriteArray.Access<OnScrollChangedListener> access = listeners.start();
        try {
            int count = access.size();
            for (int i = 0; i < count; i++) {
                access.get(i).onScrollChanged();
            }
        } finally {
            listeners.end();
        }
    }
}",1,"/**
 * Notifies registered listeners that something has scrolled.
 */
","/**
 * Notifies registered listeners that something has scrolled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The control structure has changed from a 'for-each' loop to a for loop with index. Also, the dependent API type for listeners is changed from ""CopyOnWriteArrayList"" to ""CopyOnWriteArray"". Furthermore, the return type of listener.onScrollChanged(); has also potentially changed as it is invoked on a different object type, therefore the code changes are classified into types 1, 3, and 5.","Due to the change in the iterating method and the change in the dependent API, the behaviour of the 'dispatchOnScrollChanged' method can, therefore, change, and it may return different values in a different execution path, so the CI type is 1."
111,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",16,17,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There is a new method called at the beginning of the function (warnIfCallingFromSystemProcess()) and the Binder.getOrigCallingUser() is changed to getUserId(). So, the change type is 4.","Although there is a change in the method, it does not affect the potential behaviour of the function as the change does not affect the return values or the exception handling. Therefore, no Compatibility Issue exists."
112,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>",16,17,"<android.view.View: boolean draw(Canvas,ViewGroup,long)>","<android.view.View: boolean draw(Canvas,ViewGroup,long)>",0,"{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.mChildTransformation.clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = parent.mDrawLayers ? getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.mChildTransformation;
    } else {
        if ((mPrivateFlags3 & VIEW_IS_ANIMATING_TRANSFORM) == VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final boolean hasTransform = parent.getChildStaticTransformation(this, parent.mChildTransformation);
            if (hasTransform) {
                final int transformType = parent.mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? parent.mChildTransformation : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & INVALIDATED) == INVALIDATED;
        mPrivateFlags &= ~INVALIDATED;
    }
    computeScroll();
    final int sx = mScrollX;
    final int sy = mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : getAlpha();
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & VIEW_IS_ANIMATING_ALPHA) == VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & VIEW_IS_ANIMATING_ALPHA) == VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    mPrivateFlags &= ~DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        parent.invalidate(true);
        if (a.hasAlpha() && (mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}","{
    boolean useDisplayListProperties = mAttachInfo != null && mAttachInfo.mHardwareAccelerated;
    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int flags = parent.mGroupFlags;
    if ((flags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) {
        parent.mChildTransformation.clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = getLayerType();
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 || (flags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
        caching = true;
        // Auto-scaled apps are not hw-accelerated, no need to set scaling flag on DisplayList
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    final Animation a = getAnimation();
    if (a != null) {
        more = drawAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.mChildTransformation;
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) == PFLAG3_VIEW_IS_ANIMATING_TRANSFORM && mDisplayList != null) {
            // No longer animating: clear out old animation matrix
            mDisplayList.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!useDisplayListProperties && (flags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final boolean hasTransform = parent.getChildStaticTransformation(this, parent.mChildTransformation);
            if (hasTransform) {
                final int transformType = parent.mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? parent.mChildTransformation : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;
    if (!concatMatrix && (flags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS | ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN && canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) && (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    } else {
                        buildDrawingCache(true);
                        cache = getDrawingCache(true);
                    }
                    break;
                case LAYER_TYPE_HARDWARE:
                    if (useDisplayListProperties) {
                        hasDisplayList = canHaveDisplayList();
                    }
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = canHaveDisplayList();
                    break;
            }
        }
    }
    useDisplayListProperties &= hasDisplayList;
    if (useDisplayListProperties) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
            useDisplayListProperties = false;
        }
    }
    int sx = 0;
    int sy = 0;
    if (!hasDisplayList) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    int restoreTo = -1;
    if (!useDisplayListProperties || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!useDisplayListProperties) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (useDisplayListProperties) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    float alpha = useDisplayListProperties ? 1 : getAlpha();
    if (transformToApply != null || alpha < 1 || !hasIdentityMatrix() || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    if (useDisplayListProperties) {
                        displayList.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix && !useDisplayListProperties) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }
        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) == PFLAG3_VIEW_IS_ANIMATING_ALPHA) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (useDisplayListProperties) {
                        displayList.setAlpha(alpha * getAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }
    if ((flags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN && !useDisplayListProperties) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (mRight - mLeft), sy + (mBottom - mTop));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (!useDisplayListProperties && hasDisplayList) {
        displayList = getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE && !useDisplayListProperties) {
            final HardwareLayer layer = getHardwareLayer();
            if (layer != null && layer.isValid()) {
                mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + mRight - mLeft, scrollY + mBottom - mTop, mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            } else {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, null, flags);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            if (alpha < 1) {
                cachePaint.setAlpha((int) (alpha * 255));
                parent.mGroupFlags |= ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                cachePaint.setAlpha(255);
                parent.mGroupFlags &= ~ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        parent.invalidate(true);
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }
    mRecreateDisplayList = false;
    return more;
}",1,"/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
","/**
 * This method is called by ViewGroup.drawChild() to have each child view draw itself.
 * This draw() method is an implementation detail and is not intended to be overridden or
 * to be called from anywhere else other than ViewGroup.drawChild().
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
115,<android.app.Activity: Intent getParentActivityIntent()>,16,17,<android.app.Activity: Intent getParentActivityIntent()>,<android.app.Activity: Intent getParentActivityIntent()>,0,"{
    final String parentName = mActivityInfo.parentActivityName;
    if (TextUtils.isEmpty(parentName)) {
        return null;
    }
    return new Intent().setClassName(this, parentName);
}","{
    final String parentName = mActivityInfo.parentActivityName;
    if (TextUtils.isEmpty(parentName)) {
        return null;
    }
    // If the parent itself has no parent, generate a main activity intent.
    final ComponentName target = new ComponentName(this, parentName);
    try {
        final ActivityInfo parentInfo = getPackageManager().getActivityInfo(target, 0);
        final String parentActivity = parentInfo.parentActivityName;
        final Intent parentIntent = parentActivity == null ? Intent.makeMainActivity(target) : new Intent().setComponent(target);
        return parentIntent;
    } catch (NameNotFoundException e) {
        Log.e(TAG, ""getParentActivityIntent: bad parentActivityName '"" + parentName + ""' in manifest"");
        return null;
    }
}",1,"/**
 * Obtain an {@link Intent} that will launch an explicit target activity specified by
 * this activity's logical parent. The logical parent is named in the application's manifest
 * by the {@link android.R.attr#parentActivityName parentActivityName} attribute.
 * Activity subclasses may override this method to modify the Intent returned by
 * super.getParentActivityIntent() or to implement a different mechanism of retrieving
 * the parent intent entirely.
 *
 * @return a new Intent targeting the defined parent of this activity or null if
 * there is no valid parent.
 */
","/**
 * Obtain an {@link Intent} that will launch an explicit target activity specified by
 * this activity's logical parent. The logical parent is named in the application's manifest
 * by the {@link android.R.attr#parentActivityName parentActivityName} attribute.
 * Activity subclasses may override this method to modify the Intent returned by
 * super.getParentActivityIntent() or to implement a different mechanism of retrieving
 * the parent intent entirely.
 *
 * @return a new Intent targeting the defined parent of this activity or null if
 * there is no valid parent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The control statement 'if' has not changed in the late implementation version, but the statements in the 'try' block under the conditional statements have been changed. Also, the late version has the exception handling 'catch' which is new. Therefore, the code change types are 1,2, and 3. Besides, there are changes that do not fall under return statements, exception handling statements, or control dependency statements; hence type 4 is also relevant.","The late version could throw a 'NameNotFoundException' exception, which does not exist in the earlier version, so it could lead to different exception handling (CI type 2). Further, due to changes in the return statements, the values returned by the APIs could potentially be different, thus leading to a change in return value/type (CI type 1). Therefore, it falls under CI types 1 and 2."
116,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",16,17,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String key;
                key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(filename, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                Parcelable[] result = getVolumeList();
                reply.writeNoException();
                reply.writeParcelableArray(result, 0);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                boolean external;
                external = 0 != data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid, external);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                final String rawPath = data.readString();
                final String canonicalPath = data.readString();
                final String key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(rawPath, canonicalPath, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                StorageVolume[] result = getVolumeList();
                reply.writeNoException();
                reply.writeTypedArray(result, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_fixPermissionsSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int gid;
                gid = data.readInt();
                String filename;
                filename = data.readString();
                int resultCode = fixPermissionsSecureContainer(id, gid, filename);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
117,"<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>",16,17,"<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>","<android.provider.Settings.System: boolean putFloat(ContentResolver,String,float)>",0,"{
    return putString(cr, name, Float.toString(value));
}","{
    return putFloatForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling putString() to putFloatForUser(). Besides, the dependent API (i.e., putString or putFloatForUser) has changed, indicating this is a Dependent API change. Therefore, classifying this as categories 1 and 5.","The replaced API putFloatForUser() may cause different return values compared to the original API putString(), leading to a compatibility issue of category 1."
118,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,16,17,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,<android.view.accessibility.AccessibilityEvent: String eventTypeToString(int)>,0,"{
    switch(eventType) {
        case TYPE_VIEW_CLICKED:
            return ""TYPE_VIEW_CLICKED"";
        case TYPE_VIEW_LONG_CLICKED:
            return ""TYPE_VIEW_LONG_CLICKED"";
        case TYPE_VIEW_SELECTED:
            return ""TYPE_VIEW_SELECTED"";
        case TYPE_VIEW_FOCUSED:
            return ""TYPE_VIEW_FOCUSED"";
        case TYPE_VIEW_TEXT_CHANGED:
            return ""TYPE_VIEW_TEXT_CHANGED"";
        case TYPE_WINDOW_STATE_CHANGED:
            return ""TYPE_WINDOW_STATE_CHANGED"";
        case TYPE_VIEW_HOVER_ENTER:
            return ""TYPE_VIEW_HOVER_ENTER"";
        case TYPE_VIEW_HOVER_EXIT:
            return ""TYPE_VIEW_HOVER_EXIT"";
        case TYPE_NOTIFICATION_STATE_CHANGED:
            return ""TYPE_NOTIFICATION_STATE_CHANGED"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_START:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_START"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_END:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_END"";
        case TYPE_WINDOW_CONTENT_CHANGED:
            return ""TYPE_WINDOW_CONTENT_CHANGED"";
        case TYPE_VIEW_TEXT_SELECTION_CHANGED:
            return ""TYPE_VIEW_TEXT_SELECTION_CHANGED"";
        case TYPE_VIEW_SCROLLED:
            return ""TYPE_VIEW_SCROLLED"";
        case TYPE_ANNOUNCEMENT:
            return ""TYPE_ANNOUNCEMENT"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUSED"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"";
        case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
            return ""TYPE_CURRENT_AT_GRANULARITY_MOVEMENT_CHANGED"";
        default:
            return null;
    }
}","{
    switch(eventType) {
        case TYPE_VIEW_CLICKED:
            return ""TYPE_VIEW_CLICKED"";
        case TYPE_VIEW_LONG_CLICKED:
            return ""TYPE_VIEW_LONG_CLICKED"";
        case TYPE_VIEW_SELECTED:
            return ""TYPE_VIEW_SELECTED"";
        case TYPE_VIEW_FOCUSED:
            return ""TYPE_VIEW_FOCUSED"";
        case TYPE_VIEW_TEXT_CHANGED:
            return ""TYPE_VIEW_TEXT_CHANGED"";
        case TYPE_WINDOW_STATE_CHANGED:
            return ""TYPE_WINDOW_STATE_CHANGED"";
        case TYPE_VIEW_HOVER_ENTER:
            return ""TYPE_VIEW_HOVER_ENTER"";
        case TYPE_VIEW_HOVER_EXIT:
            return ""TYPE_VIEW_HOVER_EXIT"";
        case TYPE_NOTIFICATION_STATE_CHANGED:
            return ""TYPE_NOTIFICATION_STATE_CHANGED"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_START:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_START"";
        case TYPE_TOUCH_EXPLORATION_GESTURE_END:
            return ""TYPE_TOUCH_EXPLORATION_GESTURE_END"";
        case TYPE_WINDOW_CONTENT_CHANGED:
            return ""TYPE_WINDOW_CONTENT_CHANGED"";
        case TYPE_VIEW_TEXT_SELECTION_CHANGED:
            return ""TYPE_VIEW_TEXT_SELECTION_CHANGED"";
        case TYPE_VIEW_SCROLLED:
            return ""TYPE_VIEW_SCROLLED"";
        case TYPE_ANNOUNCEMENT:
            return ""TYPE_ANNOUNCEMENT"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUSED"";
        case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
            return ""TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED"";
        case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
            return ""TYPE_CURRENT_AT_GRANULARITY_MOVEMENT_CHANGED"";
        case TYPE_GESTURE_DETECTION_START:
            return ""TYPE_GESTURE_DETECTION_START"";
        case TYPE_GESTURE_DETECTION_END:
            return ""TYPE_GESTURE_DETECTION_END"";
        case TYPE_TOUCH_INTERACTION_START:
            return ""TYPE_TOUCH_INTERACTION_START"";
        case TYPE_TOUCH_INTERACTION_END:
            return ""TYPE_TOUCH_INTERACTION_END"";
        default:
            return null;
    }
}",1,"/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
","/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"Switch case statements are added, so the change type include 1 and 3.","As new case statements are added, different return values (""TYPE_GESTURE_DETECTION_START"", ""TYPE_GESTURE_DETECTION_END"", ""TYPE_TOUCH_INTERACTION_START"", ""TYPE_TOUCH_INTERACTION_END"") could be potentially returned, so the CI type is 1."
120,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",16,17,"<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean mountObb(String,String,OnObbStateChangeListener)>",0,"{
    if (filename == null) {
        throw new IllegalArgumentException(""filename cannot be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.mountObb(filename, key, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final String canonicalPath = new File(rawPath).getCanonicalPath();
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.mountObb(rawPath, canonicalPath, key, mObbActionListener, nonce);
        return true;
    } catch (IOException e) {
        throw new IllegalArgumentException(""Failed to resolve path: "" + rawPath, e);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}",1,"/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param filename the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
","/**
 * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is
 * specified, it is supplied to the mounting process to be used in any
 * encryption used in the OBB.
 * <p>
 * The OBB will remain mounted for as long as the StorageManager reference
 * is held by the application. As soon as this reference is lost, the OBBs
 * in use will be unmounted. The {@link OnObbStateChangeListener} registered
 * with this call will receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can attempt to mount any other
 * application's OBB that shares its UID.
 *
 * @param rawPath the path to the OBB file
 * @param key secret used to encrypt the OBB; may be <code>null</code> if no
 * encryption was used on the OBB.
 * @param listener will receive the success or failure of the operation
 * @return whether the mount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The exception statements, control statements, and other statements have been changed. Also, a new Independent API 'getCanonicalPath()' is introduced. Therefore, the code change type is 1,2,3,4,5.","The exception handling logic and return statements have been altered, which may lead to the API returning a different result (value or type) or throwing a different exception. So, the CI type is 1,2."
121,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,16,17,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,<android.bluetooth.BluetoothAdapter: int getProfileConnectionState(int)>,0,"{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""getProfileConnectionState:"", e);
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
","/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The only change is the addition of a synchronized block to prevent concurrent modification errors when accessing the mService object, so the code change type is 3.","Even though the synchronized block has been added, it doesn't affect the output of the function or how it handles exceptions. As a result, there's no compatibility issue between these two versions."
123,<android.text.format.Time: String format3339(boolean)>,16,17,<android.text.format.Time: String format3339(boolean)>,<android.text.format.Time: String format3339(boolean)>,0,"{
    if (allDay) {
        return format(Y_M_D);
    } else if (TIMEZONE_UTC.equals(timezone)) {
        return format(Y_M_D_T_H_M_S_000_Z);
    } else {
        String base = format(Y_M_D_T_H_M_S_000);
        String sign = (gmtoff < 0) ? ""-"" : ""+"";
        int offset = (int) Math.abs(gmtoff);
        int minutes = (offset % 3600) / 60;
        int hours = offset / 3600;
        return String.format(""%s%s%02d:%02d"", base, sign, hours, minutes);
    }
}","{
    if (allDay) {
        return format(Y_M_D);
    } else if (TIMEZONE_UTC.equals(timezone)) {
        return format(Y_M_D_T_H_M_S_000_Z);
    } else {
        String base = format(Y_M_D_T_H_M_S_000);
        String sign = (gmtoff < 0) ? ""-"" : ""+"";
        int offset = (int) Math.abs(gmtoff);
        int minutes = (offset % 3600) / 60;
        int hours = offset / 3600;
        return String.format(Locale.US, ""%s%s%02d:%02d"", base, sign, hours, minutes);
    }
}",1,"/**
 * Return a string in the RFC 3339 format.
 * <p>
 * If allDay is true, expresses the time as Y-M-D</p>
 * <p>
 * Otherwise, if the timezone is UTC, expresses the time as Y-M-D-T-H-M-S UTC</p>
 * <p>
 * Otherwise the time is expressed the time as Y-M-D-T-H-M-S +- GMT</p>
 * @param allDay
 * @return string in the RFC 3339 format.
 */
","/**
 * Return a string in the RFC 3339 format.
 * <p>
 * If allDay is true, expresses the time as Y-M-D</p>
 * <p>
 * Otherwise, if the timezone is UTC, expresses the time as Y-M-D-T-H-M-S UTC</p>
 * <p>
 * Otherwise the time is expressed the time as Y-M-D-T-H-M-S +- GMT</p>
 * @param allDay
 * @return string in the RFC 3339 format.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method String.format() within the return statement is now taking Locale.US as the first argument in the last 'else' block. Therefore, the change type is 1,5.","The method is now formatting the string with the locale being set to US. It changes the behavior of the API as it will now return a date string formatted for US locale, thus causing a Compatibility Issue. Therefore, the CI type is 1."
124,<android.webkit.WebViewClassic: WebBackForwardList restoreState(Bundle)>,16,17,<android.webkit.WebViewClassic: WebBackForwardList restoreState(Bundle)>,<android.webkit.WebViewClassic: WebBackForwardList restoreState(Bundle)>,0,"{
    WebBackForwardList returnList = null;
    if (inState == null) {
        return returnList;
    }
    if (inState.containsKey(""index"") && inState.containsKey(""history"")) {
        mCertificate = SslCertificate.restoreState(inState.getBundle(""certificate""));
        final WebBackForwardList list = mCallbackProxy.getBackForwardList();
        final int index = inState.getInt(""index"");
        // modifications.
        synchronized (list) {
            final List<byte[]> history = (List<byte[]>) inState.getSerializable(""history"");
            final int size = history.size();
            // restoring the history index.
            if (index < 0 || index >= size) {
                return null;
            }
            for (int i = 0; i < size; i++) {
                byte[] data = history.remove(0);
                if (data == null) {
                    // the item and thus our history list cannot be rebuilt.
                    return null;
                }
                WebHistoryItem item = new WebHistoryItem(data);
                list.addHistoryItem(item);
            }
            // Grab the most recent copy to return to the caller.
            returnList = copyBackForwardList();
            // Update the copy to have the correct index.
            returnList.setCurrentIndex(index);
        }
        // Restore private browsing setting.
        if (inState.getBoolean(""privateBrowsingEnabled"")) {
            getSettings().setPrivateBrowsingEnabled(true);
        }
        mZoomManager.restoreZoomState(inState);
        // Remove all pending messages because we are restoring previous
        // state.
        mWebViewCore.removeMessages();
        // Send a restore state message.
        mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
    }
    return returnList;
}","{
    WebBackForwardListClassic returnList = null;
    if (inState == null) {
        return returnList;
    }
    if (inState.containsKey(""index"") && inState.containsKey(""history"")) {
        mCertificate = SslCertificate.restoreState(inState.getBundle(""certificate""));
        final WebBackForwardListClassic list = mCallbackProxy.getBackForwardList();
        final int index = inState.getInt(""index"");
        // modifications.
        synchronized (list) {
            final List<byte[]> history = (List<byte[]>) inState.getSerializable(""history"");
            final int size = history.size();
            // restoring the history index.
            if (index < 0 || index >= size) {
                return null;
            }
            for (int i = 0; i < size; i++) {
                byte[] data = history.remove(0);
                if (data == null) {
                    // the item and thus our history list cannot be rebuilt.
                    return null;
                }
                WebHistoryItem item = new WebHistoryItemClassic(data);
                list.addHistoryItem(item);
            }
            // Grab the most recent copy to return to the caller.
            returnList = copyBackForwardList();
            // Update the copy to have the correct index.
            returnList.setCurrentIndex(index);
        }
        // Restore private browsing setting.
        if (inState.getBoolean(""privateBrowsingEnabled"")) {
            getSettings().setPrivateBrowsingEnabled(true);
        }
        mZoomManager.restoreZoomState(inState);
        // Remove all pending messages because we are restoring previous
        // state.
        mWebViewCore.removeMessages();
        if (isAccessibilityInjectionEnabled()) {
            getAccessibilityInjector().addAccessibilityApisIfNecessary();
        }
        // Send a restore state message.
        mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
    }
    return returnList;
}",1,"/**
 * See {@link WebView#restoreState(Bundle)}
 */
","/**
 * See {@link WebView#restoreState(Bundle)}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The returned object type has changed from 'WebBackForwardList' to 'WebBackForwardListClassic'. A new instance creation statement 'WebHistoryItemClassic(data)' replaced the old one 'WebHistoryItem(data)'. A new statement 'getAccessibilityInjector().addAccessibilityApisIfNecessary();' is introduced. So the code change type is 1,3,4.","The change of return type and the newly added statement could potentially make the API return different object types, so the CI type is 1."
125,"<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>",16,17,"<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ActivityInfo getActivityInfo(ComponentName,int)>",0,"{
    try {
        ActivityInfo ai = mPM.getActivityInfo(className, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ActivityInfo ai = mPM.getActivityInfo(className, flags, mContext.getUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The internal dependent API has changed from UserId.myUserId() to mContext.getUserId(). So the code change type is 4,5.","As the API has been changed from UserId.myUserId() to mContext.getUserId(), this change may cause the 'return ai' statement to return a different value, indicating that the CI type is 1."
126,"<android.app.FragmentBreadCrumbs: void onLayout(boolean,int,int,int,int)>",16,17,"<android.app.FragmentBreadCrumbs: void onLayout(boolean,int,int,int,int)>","<android.app.FragmentBreadCrumbs: void onLayout(boolean,int,int,int,int)>",0,"{
    // Eventually we should implement our own layout of the views,
    // rather than relying on a linear layout.
    final int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        final View child = getChildAt(i);
        int childRight = mPaddingLeft + child.getMeasuredWidth() - mPaddingRight;
        int childBottom = mPaddingTop + child.getMeasuredHeight() - mPaddingBottom;
        child.layout(mPaddingLeft, mPaddingTop, childRight, childBottom);
    }
}","{
    // Eventually we should implement our own layout of the views, rather than relying on
    // a single linear layout.
    final int childCount = getChildCount();
    if (childCount == 0) {
        return;
    }
    final View child = getChildAt(0);
    final int childTop = mPaddingTop;
    final int childBottom = mPaddingTop + child.getMeasuredHeight() - mPaddingBottom;
    int childLeft;
    int childRight;
    final int layoutDirection = getLayoutDirection();
    final int horizontalGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
    switch(Gravity.getAbsoluteGravity(horizontalGravity, layoutDirection)) {
        case Gravity.RIGHT:
            childRight = mRight - mLeft - mPaddingRight;
            childLeft = childRight - child.getMeasuredWidth();
            break;
        case Gravity.CENTER_HORIZONTAL:
            childLeft = mPaddingLeft + (mRight - mLeft - child.getMeasuredWidth()) / 2;
            childRight = childLeft + child.getMeasuredWidth();
            break;
        case Gravity.LEFT:
        default:
            childLeft = mPaddingLeft;
            childRight = childLeft + child.getMeasuredWidth();
            break;
    }
    if (childLeft < mPaddingLeft) {
        childLeft = mPaddingLeft;
    }
    if (childRight > mRight - mLeft - mPaddingRight) {
        childRight = mRight - mLeft - mPaddingRight;
    }
    child.layout(childLeft, childTop, childRight, childBottom);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late implementation, the control dependency changed: a new 'if' statement is introduced and the loop is removed. The 'layout' method call gets new parameters 'childLeft', 'childTop', 'childRight' and 'childBottom' which are calculated differently resulting in an 'Other Statement Change'. The return statement is also introduced, so the change type is: 1,3,4.","With the introduced return statement, the new 'if' condition and the different values of the parameters in 'layout' method, the late version of the API could potentially have different behaviors from the early one, including returning different values, which leads to a CI of type 1."
127,<android.server.search.SearchManagerService: SearchableInfo getSearchableInfo(ComponentName)>,16,17,<android.server.search.SearchManagerService: SearchableInfo getSearchableInfo(ComponentName)>,<android.server.search.SearchManagerService: SearchableInfo getSearchableInfo(ComponentName)>,0,"{
    if (launchActivity == null) {
        Log.e(TAG, ""getSearchableInfo(), activity == null"");
        return null;
    }
    return getSearchables().getSearchableInfo(launchActivity);
}","{
    if (launchActivity == null) {
        Log.e(TAG, ""getSearchableInfo(), activity == null"");
        return null;
    }
    return getSearchables(UserHandle.getCallingUserId()).getSearchableInfo(launchActivity);
}",1,"/**
 * Returns the SearchableInfo for a given activity.
 *
 * @param launchActivity The activity from which we're launching this search.
 * @return Returns a SearchableInfo record describing the parameters of the search,
 * or null if no searchable metadata was available.
 */
","/**
 * Returns the SearchableInfo for a given activity.
 *
 * @param launchActivity The activity from which we're launching this search.
 * @return Returns a SearchableInfo record describing the parameters of the search,
 * or null if no searchable metadata was available.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'getSearchables().getSearchableInfo(launchActivity)' to 'getSearchables(UserHandle.getCallingUserId()).getSearchableInfo(launchActivity)'. Along with this, dependent API getSearchables() has also changed which accepts a different parameter type in the late version. Therefore, the change types are 1 and 5.","The return value of the method might be different because now it calls a different version of getSearchables() API that accepts a parameter. Thus, a Compatibility Issue arises due to different potential return values (type 1)."
128,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",16,17,"<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>","<android.app.ApplicationPackageManager: ProviderInfo resolveContentProvider(String,int)>",0,"{
    try {
        return mPM.resolveContentProvider(name, flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    try {
        return mPM.resolveContentProvider(name, flags, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The parameter name of mPM.resolveContentProvider has changed from UserId.myUserId() to mContext.getUserId(), which indicates that both the return statement (type 1) and the dependent API (type 5) have changed.","The change in the parameter of the dependent API mPM.resolveContentProvider() may cause this method to return a different value, so the CI type is 1."
129,<android.content.pm.PackageStats: String toString()>,16,17,<android.content.pm.PackageStats: String toString()>,<android.content.pm.PackageStats: String toString()>,0,"{
    final StringBuilder sb = new StringBuilder(""PackageStats{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" packageName="");
    sb.append(packageName);
    sb.append("",codeSize="");
    sb.append(codeSize);
    sb.append("",dataSize="");
    sb.append(dataSize);
    sb.append("",cacheSize="");
    sb.append(cacheSize);
    sb.append("",externalCodeSize="");
    sb.append(externalCodeSize);
    sb.append("",externalDataSize="");
    sb.append(externalDataSize);
    sb.append("",externalCacheSize="");
    sb.append(externalCacheSize);
    sb.append("",externalMediaSize="");
    sb.append(externalMediaSize);
    sb.append("",externalObbSize="");
    sb.append(externalObbSize);
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""PackageStats{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" "");
    sb.append(packageName);
    if (codeSize != 0) {
        sb.append("" code="");
        sb.append(codeSize);
    }
    if (dataSize != 0) {
        sb.append("" data="");
        sb.append(dataSize);
    }
    if (cacheSize != 0) {
        sb.append("" cache="");
        sb.append(cacheSize);
    }
    if (externalCodeSize != 0) {
        sb.append("" extCode="");
        sb.append(externalCodeSize);
    }
    if (externalDataSize != 0) {
        sb.append("" extData="");
        sb.append(externalDataSize);
    }
    if (externalCacheSize != 0) {
        sb.append("" extCache="");
        sb.append(externalCacheSize);
    }
    if (externalMediaSize != 0) {
        sb.append("" media="");
        sb.append(externalMediaSize);
    }
    if (externalObbSize != 0) {
        sb.append("" obb="");
        sb.append(externalObbSize);
    }
    sb.append(""}"");
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The string composition logic in the return statement has changed, and new 'if' control statements have been introduced in the late version. Therefore, the code change type is 1,3.","Due to the change of 'if' condition in building the string, the return string generated by the late version API may be different from the early version. Therefore, the CI type is 1."
130,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,16,17,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    /*
         * Don't try to intercept touch if we can't scroll anyway.
         */
    if (getScrollY() == 0 && !canScrollVertically(1)) {
        return false;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int y = (int) ev.getY(pointerIndex);
                final int yDiff = Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int y = (int) ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 3, 4",1,"A new `if` condition has been introduced, and this forms a new return statement. An additional conditional check (`if (pointerIndex == -1)`) has been introduced, along with a new log message. Therefore, the code change types are 1, 3 and 4.","The additional early return statement (`if (getScrollY() == 0 && !canScrollVertically(1)) {return false;)` and the changed behavior in the `ACTION_MOVE` case due to additional conditional check can potentially make the method return a different result. Thus, the CI type is 1."
132,<android.app.Activity: boolean onNavigateUp()>,16,17,<android.app.Activity: boolean onNavigateUp()>,<android.app.Activity: boolean onNavigateUp()>,0,"{
    // Automatically handle hierarchical Up navigation if the proper
    // metadata is available.
    Intent upIntent = getParentActivityIntent();
    if (upIntent != null) {
        if (shouldUpRecreateTask(upIntent)) {
            TaskStackBuilder b = TaskStackBuilder.create(this);
            onCreateNavigateUpTaskStack(b);
            onPrepareNavigateUpTaskStack(b);
            b.startActivities();
            // Fall back and simply finish the current activity instead.
            if (mResultCode != RESULT_CANCELED || mResultData != null) {
                // Tell the developer what's going on to avoid hair-pulling.
                Log.i(TAG, ""onNavigateUp only finishing topmost activity to return a result"");
                finish();
            } else {
                finishAffinity();
            }
        } else {
            navigateUpTo(upIntent);
        }
        return true;
    }
    return false;
}","{
    // Automatically handle hierarchical Up navigation if the proper
    // metadata is available.
    Intent upIntent = getParentActivityIntent();
    if (upIntent != null) {
        if (mActivityInfo.taskAffinity == null) {
            // Activities with a null affinity are special; they really shouldn't
            // specify a parent activity intent in the first place. Just finish
            // the current activity and call it a day.
            finish();
        } else if (shouldUpRecreateTask(upIntent)) {
            TaskStackBuilder b = TaskStackBuilder.create(this);
            onCreateNavigateUpTaskStack(b);
            onPrepareNavigateUpTaskStack(b);
            b.startActivities();
            // Fall back and simply finish the current activity instead.
            if (mResultCode != RESULT_CANCELED || mResultData != null) {
                // Tell the developer what's going on to avoid hair-pulling.
                Log.i(TAG, ""onNavigateUp only finishing topmost activity to return a result"");
                finish();
            } else {
                finishAffinity();
            }
        } else {
            navigateUpTo(upIntent);
        }
        return true;
    }
    return false;
}",1,"/**
 * This method is called whenever the user chooses to navigate Up within your application's
 * activity hierarchy from the action bar.
 *
 * <p>If the attribute {@link android.R.attr#parentActivityName parentActivityName}
 * was specified in the manifest for this activity or an activity-alias to it,
 * default Up navigation will be handled automatically. If any activity
 * along the parent chain requires extra Intent arguments, the Activity subclass
 * should override the method {@link #onPrepareNavigateUpTaskStack(TaskStackBuilder)}
 * to supply those arguments.</p>
 *
 * <p>See <a href=""{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a>
 * from the developer guide and <a href=""{@docRoot}design/patterns/navigation.html"">Navigation</a>
 * from the design guide for more information about navigating within your app.</p>
 *
 * <p>See the {@link TaskStackBuilder} class and the Activity methods
 * {@link #getParentActivityIntent()}, {@link #shouldUpRecreateTask(Intent)}, and
 * {@link #navigateUpTo(Intent)} for help implementing custom Up navigation.
 * The AppNavigation sample application in the Android SDK is also available for reference.</p>
 *
 * @return true if Up navigation completed successfully and this Activity was finished,
 * false otherwise.
 */
","/**
 * This method is called whenever the user chooses to navigate Up within your application's
 * activity hierarchy from the action bar.
 *
 * <p>If the attribute {@link android.R.attr#parentActivityName parentActivityName}
 * was specified in the manifest for this activity or an activity-alias to it,
 * default Up navigation will be handled automatically. If any activity
 * along the parent chain requires extra Intent arguments, the Activity subclass
 * should override the method {@link #onPrepareNavigateUpTaskStack(TaskStackBuilder)}
 * to supply those arguments.</p>
 *
 * <p>See <a href=""{@docRoot}guide/topics/fundamentals/tasks-and-back-stack.html"">Tasks and Back Stack</a>
 * from the developer guide and <a href=""{@docRoot}design/patterns/navigation.html"">Navigation</a>
 * from the design guide for more information about navigating within your app.</p>
 *
 * <p>See the {@link TaskStackBuilder} class and the Activity methods
 * {@link #getParentActivityIntent()}, {@link #shouldUpRecreateTask(Intent)}, and
 * {@link #navigateUpTo(Intent)} for help implementing custom Up navigation.
 * The AppNavigation sample application in the Android SDK is also available for reference.</p>
 *
 * @return true if Up navigation completed successfully and this Activity was finished,
 * false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,The code change type is 3 because a new control statement (if (mActivityInfo.taskAffinity == null)) has been added in the late version.,"The newly introduced condition 'if (mActivityInfo.taskAffinity == null)' can affect the behaviour of the API, it can potentially lead to different return values. Therefore, it is classified as type 1 CI."
133,<android.view.Display: int getPixelFormat()>,16,17,<android.view.Display: int getPixelFormat()>,<android.view.Display: int getPixelFormat()>,0,"{
    return mPixelFormat;
}","{
    return PixelFormat.RGBA_8888;
}",1,"/**
 * Return the native pixel format of the display.  The returned value
 * may be one of the constants int {@link android.graphics.PixelFormat}.
 */
","/**
 * Gets the pixel format of the display.
 * @return One of the constants defined in {@link android.graphics.PixelFormat}.
 *
 * @deprecated This method is no longer supported.
 * The result is always {@link PixelFormat#RGBA_8888}.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,1,1,"The return statement is different in both versions. Initially, it was returning ""mPixelFormat"", while in the later version, it is returning a constant value ""PixelFormat.RGBA_8888"". So the code change type is 1.","Since the return value has changed, the API could potentially return a different value in the late version. Thus, the compatibility issue arises due to potentially different return values; hence CI type is 1."
134,<android.app.ActivityThread.ResourcesKey: boolean equals(Object)>,16,17,<android.app.ActivityThread.ResourcesKey: boolean equals(Object)>,<android.app.ActivityThread.ResourcesKey: boolean equals(Object)>,0,"{
    if (!(obj instanceof ResourcesKey)) {
        return false;
    }
    ResourcesKey peer = (ResourcesKey) obj;
    return mResDir.equals(peer.mResDir) && mScale == peer.mScale;
}","{
    if (!(obj instanceof ResourcesKey)) {
        return false;
    }
    ResourcesKey peer = (ResourcesKey) obj;
    if (!mResDir.equals(peer.mResDir)) {
        return false;
    }
    if (mDisplayId != peer.mDisplayId) {
        return false;
    }
    if (mOverrideConfiguration != peer.mOverrideConfiguration) {
        if (mOverrideConfiguration == null || peer.mOverrideConfiguration == null) {
            return false;
        }
        if (!mOverrideConfiguration.equals(peer.mOverrideConfiguration)) {
            return false;
        }
    }
    if (mScale != peer.mScale) {
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement: 'return mResDir.equals(peer.mResDir) && mScale == peer.mScale' has been replaced with a series of conditional checks, which falls under change type 1 and 3. ","This editing may cause the method 'equals(Object)’ to return different boolean results in different versions, therefore, the CI is type 1."
135,<android.view.View: int getPaddingRight()>,16,17,<android.view.View: int getPaddingRight()>,<android.view.View: int getPaddingRight()>,0,"{
    return mPaddingRight;
}","{
    if (!isPaddingResolved()) {
        resolvePadding();
    }
    return mPaddingRight;
}",1,"/**
 * Returns the right padding of this view. If there are inset and enabled
 * scrollbars, this value may include the space required to display the
 * scrollbars as well.
 *
 * @return the right padding in pixels
 */
","/**
 * Returns the right padding of this view. If there are inset and enabled
 * scrollbars, this value may include the space required to display the
 * scrollbars as well.
 *
 * @return the right padding in pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A condition control and a method call 'resolvePadding()' under it are added in the late version, making the change type combination of 1,3.","In the late version, the added control structure and method call 'resolvePadding()' before returning 'mPaddingRight' could potentially modify the value of 'mPaddingRight', hence causing different return values, leading to a CI with type 1."
137,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>",16,17,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryBroadcastReceivers(Intent,int)>",0,"{
    try {
        return mPM.queryIntentReceivers(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return queryBroadcastReceivers(intent, flags, mContext.getUserId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 5","1, 2","In the late version, the try-catch block has been removed, and the method call inside the return statement is changed. So, the code changes are categorized as '1 - Return statement changed' and '5 - Dependent API changed'.","The exception handling has been removed, which could lead to different behaviors if an exception occurs. Also, the method call inside the return statement is changed, which could potentially return a different value in the late version. Hence, the change has caused both '1 - Compatibility Issue caused by potential different return values or types' and '2 - Compatibility Issue caused by potential different exception handlings'."
138,"<android.widget.StackView.HolographicHelper: Bitmap createOutline(View,int,int)>",16,17,"<android.widget.StackView.HolographicHelper: Bitmap createOutline(View,int,int)>","<android.widget.StackView.HolographicHelper: Bitmap createOutline(View,int,int)>",0,"{
    mHolographicPaint.setColor(color);
    if (type == RES_OUT) {
        mBlurPaint.setMaskFilter(mSmallBlurMaskFilter);
    } else if (type == CLICK_FEEDBACK) {
        mBlurPaint.setMaskFilter(mLargeBlurMaskFilter);
    }
    if (v.getMeasuredWidth() == 0 || v.getMeasuredHeight() == 0) {
        return null;
    }
    Bitmap bitmap = Bitmap.createBitmap(v.getMeasuredWidth(), v.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
    mCanvas.setBitmap(bitmap);
    float rotationX = v.getRotationX();
    float rotation = v.getRotation();
    float translationY = v.getTranslationY();
    float translationX = v.getTranslationX();
    v.setRotationX(0);
    v.setRotation(0);
    v.setTranslationY(0);
    v.setTranslationX(0);
    v.draw(mCanvas);
    v.setRotationX(rotationX);
    v.setRotation(rotation);
    v.setTranslationY(translationY);
    v.setTranslationX(translationX);
    drawOutline(mCanvas, bitmap);
    mCanvas.setBitmap(null);
    return bitmap;
}","{
    mHolographicPaint.setColor(color);
    if (type == RES_OUT) {
        mBlurPaint.setMaskFilter(mSmallBlurMaskFilter);
    } else if (type == CLICK_FEEDBACK) {
        mBlurPaint.setMaskFilter(mLargeBlurMaskFilter);
    }
    if (v.getMeasuredWidth() == 0 || v.getMeasuredHeight() == 0) {
        return null;
    }
    Bitmap bitmap = Bitmap.createBitmap(v.getResources().getDisplayMetrics(), v.getMeasuredWidth(), v.getMeasuredHeight(), Bitmap.Config.ARGB_8888);
    mCanvas.setBitmap(bitmap);
    float rotationX = v.getRotationX();
    float rotation = v.getRotation();
    float translationY = v.getTranslationY();
    float translationX = v.getTranslationX();
    v.setRotationX(0);
    v.setRotation(0);
    v.setTranslationY(0);
    v.setTranslationX(0);
    v.draw(mCanvas);
    v.setRotationX(rotationX);
    v.setRotation(rotation);
    v.setTranslationY(translationY);
    v.setTranslationX(translationX);
    drawOutline(mCanvas, bitmap);
    mCanvas.setBitmap(null);
    return bitmap;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The createBitmap() function has been changed. Instead of having only dimensions as parameters, it now also takes display metrics. So, we can classify it as type 1 (Return statement changed) and type 5 (Dependent API changed).","The new version now takes the display metrics into account before creating a bitmap image. As a result, if the display metrics vary, it would potentially return a different bitmap object compared to the old version. Thus, the Compatibility Issue (CI) type is 1 (CI caused by potential different return values or types)."
139,<android.view.ScaleGestureDetector: float getPreviousSpan()>,16,17,<android.view.ScaleGestureDetector: float getPreviousSpan()>,<android.view.ScaleGestureDetector: float getPreviousSpan()>,0,"{
    if (mPrevLen == -1) {
        final float pvx = mPrevFingerDiffX;
        final float pvy = mPrevFingerDiffY;
        mPrevLen = FloatMath.sqrt(pvx * pvx + pvy * pvy);
    }
    return mPrevLen;
}","{
    return mPrevSpan;
}",1,"/**
 * Return the previous distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Previous distance between pointers in pixels.
 */
","/**
 * Return the previous average distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Previous distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The entire block of original code involving an 'if' statement and variable calculations are removed, and a different variable is being returned directly in the updated version. So, the change type is 1,4.","The change in return statement could lead to possible difference in the returned value of this API between two versions, indicating the type of Compatibility Issue is 1."
140,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumSymbols(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumSymbols(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of symbols required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of symbols required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of symbols required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of symbols required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1 ,"The dependent API, mService.setPasswordMinimumSymbols(), has changed by adding new parameter UserHandle.myUserId() in the late version.","The addition of the UserHandle.myUserId() parameter could lead to different behaviors when the method setPasswordMinimumSymbols() is called, potentially returning different results and thus leading to a compatibility issue of type 1."
141,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,16,17,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        BluetoothSocket acceptedSocket = acceptNative(timeout);
        mSocketState = SocketState.CONNECTED;
        return acceptedSocket;
    } finally {
        mLock.readLock().unlock();
    }
}","{
    BluetoothSocket acceptedSocket;
    if (mSocketState != SocketState.LISTENING)
        throw new IOException(""bt socket is not in listen state"");
    // TODO(BT) wait on an incoming connection
    String RemoteAddr = waitSocketSignal(mSocketIS);
    synchronized (this) {
        if (mSocketState != SocketState.LISTENING)
            throw new IOException(""bt socket is not in listen state"");
        acceptedSocket = acceptSocket(RemoteAddr);
    // quick drop the reference of the file handle
    }
    // return this;
    return acceptedSocket;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","Multiple changes have been made in the late version, including changes to the return statement, exception handling statement, control dependency statements, and other non-specific statements. So, the code change type is 1,2,3,4.","As the exception thrown and the return value could be different due to the changes in the code, there may exist a compatibility issue. Specifically, the potential different return values, or the potential different exceptions thrown will cause a compatibility issue, so the CI type is 1,2."
142,"<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>",16,17,"<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>","<android.provider.Settings.Secure: boolean putInt(ContentResolver,String,int)>",0,"{
    return putString(cr, name, Integer.toString(value));
}","{
    return putIntForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as an
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from putString(cr, name, Integer.toString(value)); to putIntForUser(cr, name, value, UserHandle.myUserId());. Moreover, dependent API putString() has changed to putIntForUser() with different parameters. Hence, the code change type is 1,5.","The operation changing from putString() to putIntForUser() could possibly result in a difference in the return value (boolean), thus the CI type is 1."
143,"<android.webkit.CertTool: String getSignedPublicKey(Context,int,String)>",16,17,"<android.webkit.CertTool: String getSignedPublicKey(Context,int,String)>","<android.webkit.CertTool: String getSignedPublicKey(Context,int,String)>",0,"{
    try {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize((index == 0) ? 2048 : 1024);
        KeyPair pair = generator.genKeyPair();
        NetscapeCertRequest request = new NetscapeCertRequest(challenge, MD5_WITH_RSA, pair.getPublic());
        request.sign(pair.getPrivate());
        byte[] signed = request.toASN1Object().getDEREncoded();
        Credentials.getInstance().install(context, pair);
        return new String(Base64.encode(signed));
    } catch (Exception e) {
        Log.w(LOGTAG, e);
    }
    return null;
}","{
    try {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize((index == 0) ? 2048 : 1024);
        KeyPair pair = generator.genKeyPair();
        NetscapeCertRequest request = new NetscapeCertRequest(challenge, MD5_WITH_RSA, pair.getPublic());
        request.sign(pair.getPrivate());
        byte[] signed = request.toASN1Primitive().getEncoded(ASN1Encoding.DER);
        Credentials.getInstance().install(context, pair);
        return new String(Base64.encode(signed));
    } catch (Exception e) {
        Log.w(LOGTAG, e);
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, the calling on ""request"" has changed from ""toASN1Object().getDEREncoded()"" to ""toASN1Primitive().getEncoded(ASN1Encoding.DER)"", so there's a change in other statements, hence, the code change type is 4.","Although there are changes in the implementation of this method, both early and late versions return the same kind of result (a signed public key in encoded string format) and there are no new exceptions thrown. Therefore, the change might not result in any compatibility issues, thus CI does not exist in the late version, making the CI type 0."
146,<android.view.Surface: Canvas lockCanvas(Rect)>,16,17,<android.view.Surface: Canvas lockCanvas(Rect)>,<android.view.Surface: Canvas lockCanvas(Rect)>,0,"{
    /*
         * the dirty rectangle may be expanded to the surface's size, if for
         * instance it has been resized or if the bits were lost, since the last
         * call.
         */
    return lockCanvasNative(dirty);
}","{
    return nativeLockCanvas(dirty);
}",1,"/**
 * draw into a surface
 */
","/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller should
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param dirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller should redraw the entire dirty region as represented
 * by the contents of the dirty rect upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement has changed from lockCanvasNative() to nativeLockCanvas() and the name of the dependent API also changed, so the code change type is 1,5.","Changing a dependent API (lockCanvasNative() to nativeLockCanvas()) might result in different returned values, so the CI type is 1."
147,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,16,17,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,<android.accessibilityservice.AccessibilityServiceInfo: String feedbackTypeToString(int)>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    while (feedbackType != 0) {
        final int feedbackTypeFlag = 1 << Integer.numberOfTrailingZeros(feedbackType);
        feedbackType &= ~feedbackTypeFlag;
        switch(feedbackTypeFlag) {
            case FEEDBACK_AUDIBLE:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_AUDIBLE"");
                break;
            case FEEDBACK_HAPTIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_HAPTIC"");
                break;
            case FEEDBACK_GENERIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_GENERIC"");
                break;
            case FEEDBACK_SPOKEN:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_SPOKEN"");
                break;
            case FEEDBACK_VISUAL:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_VISUAL"");
                break;
        }
    }
    builder.append(""]"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""["");
    while (feedbackType != 0) {
        final int feedbackTypeFlag = 1 << Integer.numberOfTrailingZeros(feedbackType);
        feedbackType &= ~feedbackTypeFlag;
        switch(feedbackTypeFlag) {
            case FEEDBACK_AUDIBLE:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_AUDIBLE"");
                break;
            case FEEDBACK_HAPTIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_HAPTIC"");
                break;
            case FEEDBACK_GENERIC:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_GENERIC"");
                break;
            case FEEDBACK_SPOKEN:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_SPOKEN"");
                break;
            case FEEDBACK_VISUAL:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_VISUAL"");
                break;
            case FEEDBACK_BRAILLE:
                if (builder.length() > 1) {
                    builder.append("", "");
                }
                builder.append(""FEEDBACK_BRAILLE"");
                break;
        }
    }
    builder.append(""]"");
    return builder.toString();
}",1,"/**
 * Returns the string representation of a feedback type. For example,
 * {@link #FEEDBACK_SPOKEN} is represented by the string FEEDBACK_SPOKEN.
 *
 * @param feedbackType The feedback type.
 * @return The string representation.
 */
","/**
 * Returns the string representation of a feedback type. For example,
 * {@link #FEEDBACK_SPOKEN} is represented by the string FEEDBACK_SPOKEN.
 *
 * @param feedbackType The feedback type.
 * @return The string representation.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new case FEEDBACK_BRAILLE was added to the switch statement in the late implementation, so the code change types are 1,3.","The addition of a new case could lead to potential different return values, causing a type 1 Compatibility Issue."
148,"<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>",16,17,"<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>","<android.app.ApplicationPackageManager: void clearApplicationUserData(String,IPackageDataObserver)>",0,"{
    try {
        mPM.clearApplicationUserData(packageName, observer, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.clearApplicationUserData(packageName, observer, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The dependent method UserId.myUserId() has changed to mContext.getUserId(), so the code change type is 5.","As the return value of the dependent method has changed, it may affect the return value of the current API, so the CI type is 1."
150,<android.view.ViewTreeObserver: boolean dispatchOnPreDraw()>,16,17,<android.view.ViewTreeObserver: boolean dispatchOnPreDraw()>,<android.view.ViewTreeObserver: boolean dispatchOnPreDraw()>,0,"{
    // NOTE: we *must* clone the listener list to perform the dispatching.
    // The clone is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we process it.
    boolean cancelDraw = false;
    if (mOnPreDrawListeners != null && mOnPreDrawListeners.size() > 0) {
        final ArrayList<OnPreDrawListener> listeners = (ArrayList<OnPreDrawListener>) mOnPreDrawListeners.clone();
        int numListeners = listeners.size();
        for (int i = 0; i < numListeners; ++i) {
            cancelDraw |= !(listeners.get(i).onPreDraw());
        }
    }
    return cancelDraw;
}","{
    boolean cancelDraw = false;
    final CopyOnWriteArray<OnPreDrawListener> listeners = mOnPreDrawListeners;
    if (listeners != null && listeners.size() > 0) {
        CopyOnWriteArray.Access<OnPreDrawListener> access = listeners.start();
        try {
            int count = access.size();
            for (int i = 0; i < count; i++) {
                cancelDraw |= !(access.get(i).onPreDraw());
            }
        } finally {
            listeners.end();
        }
    }
    return cancelDraw;
}",1,"/**
 * Notifies registered listeners that the drawing pass is about to start. If a
 * listener returns true, then the drawing pass is canceled and rescheduled. This can
 * be called manually if you are forcing the drawing on a View or a hierarchy of Views
 * that are not attached to a Window or in the GONE state.
 *
 * @return True if the current draw should be canceled and resceduled, false otherwise.
 */
","/**
 * Notifies registered listeners that the drawing pass is about to start. If a
 * listener returns true, then the drawing pass is canceled and rescheduled. This can
 * be called manually if you are forcing the drawing on a View or a hierarchy of Views
 * that are not attached to a Window or in the GONE state.
 *
 * @return True if the current draw should be canceled and resceduled, false otherwise.
 */
",-1,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The handling of the listener list has changed (the cloning process in early version is replaced by using a different class, CopyOnWriteArray, in the machine version). Also, the local implementation of accessing the listener list has been modified. This change can also be classified as a change in the dependent API as the methodology in which the 'OnPreDrawListener' is accessed has been modified. Therefore, the code change type is 1,4,5.","There is a change in the retrieval and processing of 'OnPreDrawListener' in the machine version of the API, which can potentially lead to different return values. Therefore, the Compatibility Issue type is 1."
151,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",16,17,"<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>","<android.app.admin.DevicePolicyManager: boolean resetPassword(String,int)>",0,"{
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.resetPassword(password, flags, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Force a new device unlock password (the password needed to access the
 * entire device, not for individual accounts) on the user.  This takes
 * effect immediately.
 * The given password must be sufficient for the
 * current password quality and length constraints as returned by
 * {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet
 * these constraints, then it will be rejected and false returned.  Note
 * that the password may be a stronger quality (containing alphanumeric
 * characters when the requested quality is only numeric), in which case
 * the currently active quality will be increased to match.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param password The new password for the user.
 * @param flags May be 0 or {@link #RESET_PASSWORD_REQUIRE_ENTRY}.
 * @return Returns true if the password was applied, or false if it is
 * not acceptable for the current constraints.
 */
","/**
 * Force a new device unlock password (the password needed to access the
 * entire device, not for individual accounts) on the user.  This takes
 * effect immediately.
 * The given password must be sufficient for the
 * current password quality and length constraints as returned by
 * {@link #getPasswordQuality(ComponentName)} and
 * {@link #getPasswordMinimumLength(ComponentName)}; if it does not meet
 * these constraints, then it will be rejected and false returned.  Note
 * that the password may be a stronger quality (containing alphanumeric
 * characters when the requested quality is only numeric), in which case
 * the currently active quality will be increased to match.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_RESET_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param password The new password for the user.
 * @param flags May be 0 or {@link #RESET_PASSWORD_REQUIRE_ENTRY}.
 * @return Returns true if the password was applied, or false if it is
 * not acceptable for the current constraints.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mService.resetPassword(password, flags) to mService.resetPassword(password, flags, UserHandle.myUserId()) and also the dependent method resetPassword() is changed regarding its parameters, so the code change type is 1,5.","The change of return statement and the dependent method resetPassword() will make the API potentially return a different value, so the CI type is 1."
152,<android.server.search.Searchables: void buildSearchableList()>,16,17,<android.server.search.Searchables: void buildSearchableList()>,<android.server.search.Searchables: void buildSearchableList()>,0,"{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    final PackageManager pm = mContext.getPackageManager();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    searchList = pm.queryIntentActivities(intent, PackageManager.GET_META_DATA);
    List<ResolveInfo> webSearchInfoList;
    final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
    webSearchInfoList = pm.queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
    // analyze each one, generate a Searchables record, and record
    if (searchList != null || webSearchInfoList != null) {
        int search_count = (searchList == null ? 0 : searchList.size());
        int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
        int count = search_count + web_search_count;
        for (int ii = 0; ii < count; ii++) {
            // for each component, try to find metadata
            ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
            ActivityInfo ai = info.activityInfo;
            // Check first to avoid duplicate entries.
            if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai);
                if (searchable != null) {
                    newSearchablesList.add(searchable);
                    newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                    if (searchable.shouldIncludeInGlobalSearch()) {
                        newSearchablesInGlobalSearchList.add(searchable);
                    }
                }
            }
        }
    }
    List<ResolveInfo> newGlobalSearchActivities = findGlobalSearchActivities();
    // Find the global search activity
    ComponentName newGlobalSearchActivity = findGlobalSearchActivity(newGlobalSearchActivities);
    // Find the web search activity
    ComponentName newWebSearchActivity = findWebSearchActivity(newGlobalSearchActivity);
    // Store a consistent set of new values
    synchronized (this) {
        mSearchablesMap = newSearchablesMap;
        mSearchablesList = newSearchablesList;
        mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
        mGlobalSearchActivities = newGlobalSearchActivities;
        mCurrentGlobalSearchActivity = newGlobalSearchActivity;
        mWebSearchActivity = newWebSearchActivity;
    }
}","{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    long ident = Binder.clearCallingIdentity();
    try {
        searchList = queryIntentActivities(intent, PackageManager.GET_META_DATA);
        List<ResolveInfo> webSearchInfoList;
        final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
        webSearchInfoList = queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
        // analyze each one, generate a Searchables record, and record
        if (searchList != null || webSearchInfoList != null) {
            int search_count = (searchList == null ? 0 : searchList.size());
            int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
            int count = search_count + web_search_count;
            for (int ii = 0; ii < count; ii++) {
                // for each component, try to find metadata
                ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
                ActivityInfo ai = info.activityInfo;
                // Check first to avoid duplicate entries.
                if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                    SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai, mUserId);
                    if (searchable != null) {
                        newSearchablesList.add(searchable);
                        newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                        if (searchable.shouldIncludeInGlobalSearch()) {
                            newSearchablesInGlobalSearchList.add(searchable);
                        }
                    }
                }
            }
        }
        List<ResolveInfo> newGlobalSearchActivities = findGlobalSearchActivities();
        // Find the global search activity
        ComponentName newGlobalSearchActivity = findGlobalSearchActivity(newGlobalSearchActivities);
        // Find the web search activity
        ComponentName newWebSearchActivity = findWebSearchActivity(newGlobalSearchActivity);
        // Store a consistent set of new values
        synchronized (this) {
            mSearchablesMap = newSearchablesMap;
            mSearchablesList = newSearchablesList;
            mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
            mGlobalSearchActivities = newGlobalSearchActivities;
            mCurrentGlobalSearchActivity = newGlobalSearchActivity;
            mWebSearchActivity = newWebSearchActivity;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}",1,"/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
","/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4",1,There are several changes in the new implementation: ,"3. Another argument 'mUserId' has been added to SearchableInfo.getActivityMetaData(mContext, ai, mUserId): Other statement change, so the code change type is 4."
153,<android.app.FragmentManagerImpl: SavedState saveFragmentInstanceState(Fragment)>,16,17,<android.app.FragmentManagerImpl: SavedState saveFragmentInstanceState(Fragment)>,<android.app.FragmentManagerImpl: SavedState saveFragmentInstanceState(Fragment)>,0,"{
    if (fragment.mIndex < 0) {
        throw new IllegalStateException(""Fragment "" + fragment + "" is not currently in the FragmentManager"");
    }
    if (fragment.mState > Fragment.INITIALIZING) {
        Bundle result = saveFragmentBasicState(fragment);
        return result != null ? new Fragment.SavedState(result) : null;
    }
    return null;
}","{
    if (fragment.mIndex < 0) {
        throwException(new IllegalStateException(""Fragment "" + fragment + "" is not currently in the FragmentManager""));
    }
    if (fragment.mState > Fragment.INITIALIZING) {
        Bundle result = saveFragmentBasicState(fragment);
        return result != null ? new Fragment.SavedState(result) : null;
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2, 5",2,"There is a change from 'throw' to 'throwException' and the dependent API 'throw' has changed, so the type of code change is 2, 5.","The 'throwException' may possibly handle exceptions differently compared to the direct 'throw', hence the type of Compatibility Issue is 2."
154,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,<android.app.admin.DevicePolicyManager: long getPasswordExpirationTimeout(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordExpirationTimeout(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    if (mService != null) {
        try {
            return mService.getPasswordExpirationTimeout(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}",1,"/**
 * Get the password expiration timeout for the given admin. The expiration timeout is the
 * recurring expiration timeout provided in the call to
 * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
 * aggregate of all policy administrators if admin is null.
 *
 * @param admin The name of the admin component to check, or null to aggregate all admins.
 * @return The timeout for the given admin or the minimum of all timeouts
 */
","/**
 * Get the password expiration timeout for the given admin. The expiration timeout is the
 * recurring expiration timeout provided in the call to
 * {@link #setPasswordExpirationTimeout(ComponentName, long)} for the given admin or the
 * aggregate of all policy administrators if admin is null.
 *
 * @param admin The name of the admin component to check, or null to aggregate all admins.
 * @return The timeout for the given admin or the minimum of all timeouts
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from return mService.getPasswordExpirationTimeout(admin) to return mService.getPasswordExpirationTimeout(admin, UserHandle.myUserId()). Also, the parameter list of the dependent API mService.getPasswordExpirationTimeout has changed, therefore the code change type is 1,5.","The return statement change will make the API potentially return a different value, therefore the CI type is 1."
155,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Activity)>,16,17,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Activity)>,<android.app.TaskStackBuilder: TaskStackBuilder addParentStack(Activity)>,0,"{
    final int insertAt = mIntents.size();
    Intent parent = sourceActivity.getParentActivityIntent();
    PackageManager pm = sourceActivity.getPackageManager();
    while (parent != null) {
        mIntents.add(insertAt, parent);
        try {
            ActivityInfo info = pm.getActivityInfo(parent.getComponent(), 0);
            String parentActivity = info.parentActivityName;
            if (parentActivity != null) {
                parent = new Intent().setComponent(new ComponentName(mSourceContext, parentActivity));
            } else {
                parent = null;
            }
        } catch (NameNotFoundException e) {
            Log.e(TAG, ""Bad ComponentName while traversing activity parent metadata"");
            throw new IllegalArgumentException(e);
        }
    }
    return this;
}","{
    final Intent parent = sourceActivity.getParentActivityIntent();
    if (parent != null) {
        // We have the actual parent intent, build the rest from static metadata
        // then add the direct parent intent to the end.
        ComponentName target = parent.getComponent();
        if (target == null) {
            target = parent.resolveActivity(mSourceContext.getPackageManager());
        }
        addParentStack(target);
        addNextIntent(parent);
    }
    return this;
}",1,"/**
 * Add the activity parent chain as specified by the
 * {@link Activity#getParentActivityIntent() getParentActivityIntent()} method of the activity
 * specified and the {@link android.R.attr#parentActivityName parentActivityName} attributes
 * of each successive activity (or activity-alias) element in the application's manifest
 * to the task stack builder.
 *
 * @param sourceActivity All parents of this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
","/**
 * Add the activity parent chain as specified by the
 * {@link Activity#getParentActivityIntent() getParentActivityIntent()} method of the activity
 * specified and the {@link android.R.attr#parentActivityName parentActivityName} attributes
 * of each successive activity (or activity-alias) element in the application's manifest
 * to the task stack builder.
 *
 * @param sourceActivity All parents of this activity will be added
 * @return This TaskStackBuilder for method chaining
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"A new return statement ""return this;"" is introduced. The block of code inside the while loop in the early version was totally replaced by a new block of codes in the late version where conditional and control statements are introduced. Thus, the code change type is 1,3,4.","Because the block of code that potentially influenced the return statement ""return this;"" was completely rewritten, the change causes a potential risk of returning different results. So the CI type is 1."
156,<android.webkit.HTML5VideoViewProxy.PosterDownloader: void endData()>,16,17,<android.webkit.HTML5VideoViewProxy.PosterDownloader: void endData()>,<android.webkit.HTML5VideoViewProxy.PosterDownloader: void endData()>,0,"{
    if (mStatusCode == 200) {
        if (mPosterBytes.size() > 0) {
            Bitmap poster = BitmapFactory.decodeByteArray(mPosterBytes.toByteArray(), 0, mPosterBytes.size());
            mProxy.doSetPoster(poster);
        }
        cleanup();
    } else if (mStatusCode >= 300 && mStatusCode < 400) {
        // We have a redirect.
        try {
            mUrl = new URL(mHeaders.getLocation());
        } catch (MalformedURLException e) {
            mUrl = null;
        }
        if (mUrl != null) {
            mHandler.post(new Runnable() {

                public void run() {
                    if (mRequestHandle != null) {
                        mRequestHandle.setupRedirect(mUrl.toString(), mStatusCode, new HashMap<String, String>());
                    }
                }
            });
        }
    }
}","{
    if (mStatusCode == 200) {
        if (mPosterBytes.size() > 0) {
            Bitmap poster = BitmapFactory.decodeByteArray(mPosterBytes.toByteArray(), 0, mPosterBytes.size());
            mProxy.doSetPoster(poster);
        }
        cleanup();
    } else if (mStatusCode >= 300 && mStatusCode < 400) {
        // We have a redirect.
        try {
            mUrl = new URL(mHeaders.getLocation());
        } catch (MalformedURLException e) {
            mUrl = null;
        }
        if (mUrl != null) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    if (mRequestHandle != null) {
                        mRequestHandle.setupRedirect(mUrl.toString(), mStatusCode, new HashMap<String, String>());
                    }
                }
            });
        }
    }
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,0,0,"The code has not changed between the early and late versions, except for the addition of the @Override annotation, which does not affect the logic or behaviour of the method. ","As there is no change in the implementation, there is no Compatibility Issue between the two versions."
158,<android.widget.TextView: float getLeftFadingEdgeStrength()>,16,17,<android.widget.TextView: float getLeftFadingEdgeStrength()>,<android.widget.TextView: float getLeftFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                return marquee.mScroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                final float scroll = marquee.getScroll();
                return scroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The statements ""final float scroll = marquee.getScroll();"" and ""final int layoutDirection = getLayoutDirection();"" have been newly introduced in the late version implementation. And both changes are related to invoking different methods. Thus, the types of changes are 4 and 5.","The change in the method of marquee object (marquee.mScroll to marquee.getScroll()) and method of current object (getResolvedLayoutDirection() to getLayoutDirection()) may lead to different returned values in some cases. Thus, there is a Compatibility Issue of type 1."
161,<android.widget.NumberPicker: void setDisplayedValues(String[])>,16,17,<android.widget.NumberPicker: void setDisplayedValues(String[])>,<android.widget.NumberPicker: void setDisplayedValues(String[])>,0,"{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
    tryComputeMaxWidth();
}","{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
        // values. This will take care of the current value as well.
        if (getMinValue() >= displayedValues.length) {
            setMinValue(0);
        }
        if (getMaxValue() >= displayedValues.length) {
            setMaxValue(displayedValues.length - 1);
        }
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
    tryComputeMaxWidth();
}",1,"/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
","/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are two more function calls `setMinValue(0)`, `setMaxValue(displayedValues.length - 1)` added in `if` block in the later version. Also, there are two extra conditions added `if (getMinValue() >= displayedValues.length)` and `if (getMaxValue() >= displayedValues.length)`. So, this is a Control dependency change, and Other statement change. Hence, the change types are 3,4.","Though this method mainly works for setting values rather than returning a value or throwing an exception, the added condition checks and update of minValue and maxValue potentially leads to differences in subsequent API behaviour which might return different values. Hence, this is a compatibility issue caused by potential different return values and types. Therefore, the CI type is 1."
162,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,16,17,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,0,"{
    if (mMenuItem != null || mView != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mMenuItem = item;
    mView = new MediaRouteButton(mContext);
    mView.setRouteTypes(mRouteTypes);
    mView.setExtendedSettingsClickListener(mExtendedSettingsListener);
    return mView;
}","{
    if (mMenuItem != null || mView != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mMenuItem = item;
    mView = new MediaRouteButton(mContext);
    mView.setCheatSheetEnabled(true);
    mView.setRouteTypes(mRouteTypes);
    mView.setExtendedSettingsClickListener(mExtendedSettingsListener);
    mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return mView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return variable 'mView' is modified with more method calls in the late version code, and there is also addition of other statements to set the parameters of the mView. So the code change type is 1,4 (Return statement and Other statements changed).","Due to the additional method calls and property setup on the return variable 'mView', the late version of implementation will return a potentially different object compared to the early version, thus there exists a compatibility issue of type 1 (Different return values or types)."
164,"<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>",16,17,"<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>","<android.animation.ArgbEvaluator: Object evaluate(float,Object,Object)>",0,"{
    int startInt = (Integer) startValue;
    int startA = (startInt >> 24);
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;
    int endInt = (Integer) endValue;
    int endA = (endInt >> 24);
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;
    return (int) ((startA + (int) (fraction * (endA - startA))) << 24) | (int) ((startR + (int) (fraction * (endR - startR))) << 16) | (int) ((startG + (int) (fraction * (endG - startG))) << 8) | (int) ((startB + (int) (fraction * (endB - startB))));
}","{
    int startInt = (Integer) startValue;
    int startA = (startInt >> 24) & 0xff;
    int startR = (startInt >> 16) & 0xff;
    int startG = (startInt >> 8) & 0xff;
    int startB = startInt & 0xff;
    int endInt = (Integer) endValue;
    int endA = (endInt >> 24) & 0xff;
    int endR = (endInt >> 16) & 0xff;
    int endG = (endInt >> 8) & 0xff;
    int endB = endInt & 0xff;
    return (int) ((startA + (int) (fraction * (endA - startA))) << 24) | (int) ((startR + (int) (fraction * (endR - startR))) << 16) | (int) ((startG + (int) (fraction * (endG - startG))) << 8) | (int) ((startB + (int) (fraction * (endB - startB))));
}",1,"/**
 * This function returns the calculated in-between value for a color
 * given integers that represent the start and end values in the four
 * bytes of the 32-bit int. Each channel is separately linearly interpolated
 * and the resulting calculated values are recombined into the return value.
 *
 * @param fraction The fraction from the starting to the ending values
 * @param startValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @param endValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @return A value that is calculated to be the linearly interpolated
 * result, derived by separating the start and end values into separate
 * color channels and interpolating each one separately, recombining the
 * resulting values in the same way.
 */
","/**
 * This function returns the calculated in-between value for a color
 * given integers that represent the start and end values in the four
 * bytes of the 32-bit int. Each channel is separately linearly interpolated
 * and the resulting calculated values are recombined into the return value.
 *
 * @param fraction The fraction from the starting to the ending values
 * @param startValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @param endValue A 32-bit int value representing colors in the
 * separate bytes of the parameter
 * @return A value that is calculated to be the linearly interpolated
 * result, derived by separating the start and end values into separate
 * color channels and interpolating each one separately, recombining the
 * resulting values in the same way.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is on the calculation of startA and endA variables with bitwise operations, which is an other statement change, so the change type is 4.","The change in the calculation will not affect the return value. The returned result continues to be calculated using the same arithmetic operation and same return statement, thus no CI is detected. Therefore, the CI type is 0."
165,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,16,17,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebViewClassic.PrivateHandler: void handleMessage(Message)>,0,"{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mCurrentScrollingLayerId == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX, mScrollingLayerRect.top + mAutoScrollY);
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || !imm.isActive(mWebView)) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                contentScrollTo(p.x, p.y, msg.arg1 == 1);
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case UPDATE_ZOOM_DENSITY:
            {
                final float density = (Float) msg.obj;
                mZoomManager.updateDefaultZoomDensity(density);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            WindowManager windowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
            Display display = windowManager.getDefaultDisplay();
            nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx(display));
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            if (mIsPaused) {
                nativeSetPauseDrawing(mNativeClass, true);
            }
            mInputDispatcher = new WebViewInputDispatcher(this, mWebViewCore.getInputDispatcherCallbacks());
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (msg.arg2 == mTextGeneration) {
                String text = (String) msg.obj;
                if (null == text) {
                    text = """";
                }
                if (mInputConnection != null && mFieldPointer == msg.arg1) {
                    mInputConnection.setTextAndKeepSelection(text);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case TAKE_FOCUS:
            int direction = msg.arg1;
            View focusSearch = mWebView.focusSearch(direction);
            if (focusSearch != null && focusSearch != mWebView) {
                focusSearch.requestFocus();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            hideSoftKeyboard();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            if (mFieldPointer == msg.arg1) {
                ArrayAdapter<String> adapter = (ArrayAdapter<String>) msg.obj;
                mAutoCompletePopup.setAdapter(adapter);
            }
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            mWebView.performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mInputDispatcher.setWebKitWantsTouchEvents(msg.arg1 != 0);
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
            break;
        case SCREEN_ON:
            mWebView.setKeepScreenOn(msg.arg1 == 1);
            break;
        case ENTER_FULLSCREEN_VIDEO:
            int layerId = msg.arg1;
            String url = (String) msg.obj;
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.enterFullScreenVideo(layerId, url);
            }
            break;
        case EXIT_FULLSCREEN_VIDEO:
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.exitFullScreenVideo();
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebViewClassic.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                invalidate();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                int x = (int) (left + data.mXPercentInDoc * width - data.mXPercentInView * viewWidth);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                mWebView.scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (isAccessibilityEnabled()) {
                getAccessibilityInjector().handleSelectionChangedIfNecessary((String) msg.obj);
            }
            break;
        case FOCUS_NODE_CHANGED:
            mIsEditingText = (msg.arg1 == mFieldPointer);
            if (mAutoCompletePopup != null && !mIsEditingText) {
                mAutoCompletePopup.clearAdapter();
            }
        // fall through to HIT_TEST_RESULT
        case HIT_TEST_RESULT:
            WebKitHitTest hit = (WebKitHitTest) msg.obj;
            mFocusedNode = hit;
            setTouchHighlightRects(hit);
            setHitTestResult(hit);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mInputConnection != null) {
                mInputConnection.setAutoFillable(mAutoFillData.getQueryId());
                mAutoCompletePopup.setAutoFillQueryId(mAutoFillData.getQueryId());
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mAutoCompletePopup != null) {
                ArrayList<String> pastEntries = new ArrayList<String>();
                mAutoCompletePopup.setAdapter(new ArrayAdapter<String>(mContext, com.android.internal.R.layout.web_text_view_dropdown, pastEntries));
            }
            break;
        case COPY_TO_CLIPBOARD:
            copyToClipboard((String) msg.obj);
            break;
        case INIT_EDIT_FIELD:
            if (mInputConnection != null) {
                TextFieldInitData initData = (TextFieldInitData) msg.obj;
                mTextGeneration = 0;
                mFieldPointer = initData.mFieldPointer;
                mInputConnection.initEditorInfo(initData);
                mInputConnection.setTextAndKeepSelection(initData.mText);
                mEditTextContentBounds.set(initData.mContentBounds);
                mEditTextLayerId = initData.mNodeLayerId;
                nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
                mEditTextContent.set(initData.mContentRect);
                relocateAutoCompletePopup();
            }
            break;
        case REPLACE_TEXT:
            {
                String text = (String) msg.obj;
                int start = msg.arg1;
                int end = msg.arg2;
                int cursorPosition = start + text.length();
                replaceTextfieldText(start, end, text, cursorPosition, cursorPosition);
                selectionDone();
                break;
            }
        case UPDATE_MATCH_COUNT:
            {
                WebViewCore.FindAllRequest request = (WebViewCore.FindAllRequest) msg.obj;
                if (request == null) {
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(0, 0, true);
                    }
                } else if (request == mFindRequest) {
                    int matchCount, matchIndex;
                    synchronized (mFindRequest) {
                        matchCount = request.mMatchCount;
                        matchIndex = request.mMatchIndex;
                    }
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(matchIndex, matchCount, false);
                    }
                    if (mFindListener != null) {
                        mFindListener.onFindResultReceived(matchIndex, matchCount, true);
                    }
                }
                break;
            }
        case CLEAR_CARET_HANDLE:
            if (mIsCaretSelection) {
                selectionDone();
            }
            break;
        case KEY_PRESS:
            sendBatchableInputMessage(EventHub.KEY_PRESS, msg.arg1, 0, null);
            break;
        case RELOCATE_AUTO_COMPLETE_POPUP:
            relocateAutoCompletePopup();
            break;
        case AUTOFILL_FORM:
            mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM, msg.arg1, /* unused */
            0);
            break;
        case EDIT_TEXT_SIZE_CHANGED:
            if (msg.arg1 == mFieldPointer) {
                mEditTextContent.set((Rect) msg.obj);
            }
            break;
        case SHOW_CARET_HANDLE:
            if (!mSelectingText && mIsEditingText && mIsCaretSelection) {
                setupWebkitSelect();
                resetCaretTimer();
                showPasteWindow();
            }
            break;
        case UPDATE_CONTENT_BOUNDS:
            mEditTextContentBounds.set((Rect) msg.obj);
            nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
            break;
        case SCROLL_EDIT_TEXT:
            scrollEditWithCursor();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mCurrentScrollingLayerId == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX, mScrollingLayerRect.top + mAutoScrollY);
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || !imm.isActive(mWebView)) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                contentScrollTo(p.x, p.y, msg.arg1 == 1);
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case UPDATE_ZOOM_DENSITY:
            {
                final float density = (Float) msg.obj;
                mZoomManager.updateDefaultZoomDensity(density);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx());
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            if (mIsPaused) {
                nativeSetPauseDrawing(mNativeClass, true);
            }
            mInputDispatcher = new WebViewInputDispatcher(this, mWebViewCore.getInputDispatcherCallbacks());
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (msg.arg2 == mTextGeneration) {
                String text = (String) msg.obj;
                if (null == text) {
                    text = """";
                }
                if (mInputConnection != null && mFieldPointer == msg.arg1) {
                    mInputConnection.setTextAndKeepSelection(text);
                }
            }
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case TAKE_FOCUS:
            int direction = msg.arg1;
            View focusSearch = mWebView.focusSearch(direction);
            if (focusSearch != null && focusSearch != mWebView) {
                focusSearch.requestFocus();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            hideSoftKeyboard();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            if (mFieldPointer == msg.arg1) {
                ArrayAdapter<String> adapter = (ArrayAdapter<String>) msg.obj;
                mAutoCompletePopup.setAdapter(adapter);
            }
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            mWebView.performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mInputDispatcher.setWebKitWantsTouchEvents(msg.arg1 != 0);
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
            break;
        case SCREEN_ON:
            mWebView.setKeepScreenOn(msg.arg1 == 1);
            break;
        case EXIT_FULLSCREEN_VIDEO:
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.exitFullScreenVideo();
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebViewClassic.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                invalidate();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                int x = (int) (left + data.mXPercentInDoc * width - data.mXPercentInView * viewWidth);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                mWebView.scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (isAccessibilityInjectionEnabled()) {
                getAccessibilityInjector().handleSelectionChangedIfNecessary((String) msg.obj);
            }
            break;
        case FOCUS_NODE_CHANGED:
            mIsEditingText = (msg.arg1 == mFieldPointer);
            if (mAutoCompletePopup != null && !mIsEditingText) {
                mAutoCompletePopup.clearAdapter();
            }
        // fall through to HIT_TEST_RESULT
        case HIT_TEST_RESULT:
            WebKitHitTest hit = (WebKitHitTest) msg.obj;
            mFocusedNode = hit;
            setTouchHighlightRects(hit);
            setHitTestResult(hit);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mInputConnection != null) {
                mInputConnection.setAutoFillable(mAutoFillData.getQueryId());
                mAutoCompletePopup.setAutoFillQueryId(mAutoFillData.getQueryId());
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mAutoCompletePopup != null) {
                ArrayList<String> pastEntries = new ArrayList<String>();
                mAutoCompletePopup.setAdapter(new ArrayAdapter<String>(mContext, com.android.internal.R.layout.web_text_view_dropdown, pastEntries));
            }
            break;
        case COPY_TO_CLIPBOARD:
            copyToClipboard((String) msg.obj);
            break;
        case INIT_EDIT_FIELD:
            if (mInputConnection != null) {
                TextFieldInitData initData = (TextFieldInitData) msg.obj;
                mTextGeneration = 0;
                mFieldPointer = initData.mFieldPointer;
                mInputConnection.initEditorInfo(initData);
                mInputConnection.setTextAndKeepSelection(initData.mText);
                mEditTextContentBounds.set(initData.mContentBounds);
                mEditTextLayerId = initData.mNodeLayerId;
                nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
                mEditTextContent.set(initData.mClientRect);
                relocateAutoCompletePopup();
            }
            break;
        case REPLACE_TEXT:
            {
                String text = (String) msg.obj;
                int start = msg.arg1;
                int end = msg.arg2;
                int cursorPosition = start + text.length();
                replaceTextfieldText(start, end, text, cursorPosition, cursorPosition);
                selectionDone();
                break;
            }
        case UPDATE_MATCH_COUNT:
            {
                WebViewCore.FindAllRequest request = (WebViewCore.FindAllRequest) msg.obj;
                if (request == null) {
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(0, 0, true);
                    }
                } else if (request == mFindRequest) {
                    int matchCount, matchIndex;
                    synchronized (mFindRequest) {
                        matchCount = request.mMatchCount;
                        matchIndex = request.mMatchIndex;
                    }
                    if (mFindCallback != null) {
                        mFindCallback.updateMatchCount(matchIndex, matchCount, false);
                    }
                    if (mFindListener != null) {
                        mFindListener.onFindResultReceived(matchIndex, matchCount, true);
                    }
                }
                break;
            }
        case CLEAR_CARET_HANDLE:
            if (mIsCaretSelection) {
                selectionDone();
            }
            break;
        case KEY_PRESS:
            sendBatchableInputMessage(EventHub.KEY_PRESS, msg.arg1, 0, null);
            break;
        case RELOCATE_AUTO_COMPLETE_POPUP:
            relocateAutoCompletePopup();
            break;
        case AUTOFILL_FORM:
            mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM, msg.arg1, /* unused */
            0);
            break;
        case EDIT_TEXT_SIZE_CHANGED:
            if (msg.arg1 == mFieldPointer) {
                mEditTextContent.set((Rect) msg.obj);
            }
            break;
        case SHOW_CARET_HANDLE:
            if (!mSelectingText && mIsEditingText && mIsCaretSelection) {
                setupWebkitSelect();
                resetCaretTimer();
                showPasteWindow();
            }
            break;
        case UPDATE_CONTENT_BOUNDS:
            mEditTextContentBounds.set((Rect) msg.obj);
            nativeMapLayerRect(mNativeClass, mEditTextLayerId, mEditTextContentBounds);
            break;
        case SCROLL_EDIT_TEXT:
            scrollEditWithCursor();
            break;
        case SCROLL_HANDLE_INTO_VIEW:
            scrollDraggedSelectionHandleIntoView();
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
167,<android.view.View: void setContentDescription(CharSequence)>,16,17,<android.view.View: void setContentDescription(CharSequence)>,<android.view.View: void setContentDescription(CharSequence)>,0,"{
    mContentDescription = contentDescription;
    final boolean nonEmptyDesc = contentDescription != null && contentDescription.length() > 0;
    if (nonEmptyDesc && getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
}","{
    if (mContentDescription == null) {
        if (contentDescription == null) {
            return;
        }
    } else if (mContentDescription.equals(contentDescription)) {
        return;
    }
    mContentDescription = contentDescription;
    final boolean nonEmptyDesc = contentDescription != null && contentDescription.length() > 0;
    if (nonEmptyDesc && getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    notifyAccessibilityStateChanged();
}",1,"/**
 * Sets the {@link View} description. It briefly describes the view and is
 * primarily used for accessibility support. Set this property to enable
 * better accessibility support for your application. This is especially
 * true for views that do not have textual representation (For example,
 * ImageButton).
 *
 * @param contentDescription The content description.
 *
 * @attr ref android.R.styleable#View_contentDescription
 */
","/**
 * Sets the {@link View} description. It briefly describes the view and is
 * primarily used for accessibility support. Set this property to enable
 * better accessibility support for your application. This is especially
 * true for views that do not have textual representation (For example,
 * ImageButton).
 *
 * @param contentDescription The content description.
 *
 * @attr ref android.R.styleable#View_contentDescription
 */
",-1,[@RemotableViewMethod],[@RemotableViewMethod],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The change involves adding new if-else control blocks handling differences in contentDescription and mContentDescription, indicating a control dependency change. The return statement has also been introduced from the late version, marking a return statement change. Moreover, a new method call- notifyAccessibilityStateChanged(); is added at the end which changes another statement. Therefore, the code change type is 1,3,4.","Since new control blocks and return statements have been added, the API will possibly return at new points in the late version (either nothing with the 'return;' statement or an exception), depending on the execution path. This could result in a different behavior compared to the early version, signifying a potential compatibility issue (CI) of type 1."
168,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,16,17,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,0,"{
    if (getState() != STATE_ON) {
        return toDeviceSet(new String[0]);
    }
    try {
        return toDeviceSet(mService.listBonds());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
","/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The check getState() != STATE_ON condition remains unchanged, however, the return value now comes from a different method call (toDeviceSet(new BluetoothDevice[0]) instead of toDeviceSet(new String[0])). Plus, there is also change in the synchronization part where there is an additional if statement (if (mService != null)) and a new method call (mService.getBondedDevices()). Thus the code change involves a return statement change, the control dependency change and other statement change, so the types are 1,3,4.","The different method calls in the return statements indicate that the returned value or type might be different from the early version. Thus there are potential Compatibility Issues due to a different return value or type, so the CI type is 1."
170,<android.app.ApplicationPackageManager: List<PackageInfo> getInstalledPackages(int)>,16,17,<android.app.ApplicationPackageManager: List<PackageInfo> getInstalledPackages(int)>,<android.app.ApplicationPackageManager: List<PackageInfo> getInstalledPackages(int)>,0,"{
    try {
        final List<PackageInfo> packageInfos = new ArrayList<PackageInfo>();
        PackageInfo lastItem = null;
        ParceledListSlice<PackageInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledPackages(flags, lastKey);
            lastItem = slice.populateList(packageInfos, PackageInfo.CREATOR);
        } while (!slice.isLastSlice());
        return packageInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return getInstalledPackages(flags, mContext.getUserId());
}",1,,,-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement had a complete change, from implementation code details to calling a new method. And also the dependent API getInstalledPackages() was changed in terms of the parameters. Therefore, the code change type is 1,5.","Since the return statement has been totally changed, the potential outcome of the method can be different. Therefore, it is considered as a compatibility issue type 1."
171,<android.util.Pair: boolean equals(Object)>,16,17,<android.util.Pair: boolean equals(Object)>,<android.util.Pair: boolean equals(Object)>,0,"{
    if (o == this)
        return true;
    if (!(o instanceof Pair))
        return false;
    final Pair<F, S> other;
    try {
        other = (Pair<F, S>) o;
    } catch (ClassCastException e) {
        return false;
    }
    return first.equals(other.first) && second.equals(other.second);
}","{
    if (!(o instanceof Pair)) {
        return false;
    }
    Pair<?, ?> p = (Pair<?, ?>) o;
    return Objects.equal(p.first, first) && Objects.equal(p.second, second);
}",1,"/**
 * Checks the two objects for equality by delegating to their respective equals() methods.
 * @param o the Pair to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both considered equals()
 */
","/**
 * Checks the two objects for equality by delegating to their respective
 * {@link Object#equals(Object)} methods.
 *
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both considered
 * equal
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late implementation, the earlier return statement o == this has been removed and the class casting approach along with the corresponding exception handling has been updated. Additionally, the return condition is using Objects.equal() instead of direct .equals() method on the values. These changes corresponds to type 1 and 4 changes.","Due to changes in how equality is determined (Using Objects.equal() that can handle null safely, unlike the direct .equals() method), and removal of one of the early return statement, the return result of the equal method might potentially change, which corresponds to type 1 compatibility issue - potential different return values."
172,<android.database.AbstractCursor: void finalize()>,16,17,<android.database.AbstractCursor: void finalize()>,<android.database.AbstractCursor: void finalize()>,0,"{
    if (mSelfObserver != null && mSelfObserverRegistered == true) {
        mContentResolver.unregisterContentObserver(mSelfObserver);
    }
}","{
    if (mSelfObserver != null && mSelfObserverRegistered == true) {
        mContentResolver.unregisterContentObserver(mSelfObserver);
    }
    try {
        if (!mClosed)
            close();
    } catch (Exception e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,4",0,"In the late version implementation, new try/catch statement is added with a specific execution to close() if 'mClosed' equals to false. The change type is 2 (Exception handling statement changed) and 4 (Other statement changed).","Although there is a change in the code implementation, it should not affect the potential behaviors of the API as the new added statement is for unclosed instance to be closed and it catches its all exceptions, so the CI type is 0."
174,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,16,17,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
175,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,16,17,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                return;
            }
        case DO_RESTART_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                return;
            }
        case DO_CREATE_SESSION:
            {
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (IInputMethodCallback) msg.obj));
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.startInput(ic, info);
                args.recycle();
                return;
            }
        case DO_RESTART_INPUT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                EditorInfo info = (EditorInfo) args.arg2;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.restartInput(ic, info);
                args.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (IInputMethodCallback) msg.obj));
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only differences between these two implementations are that in the late version, the method recycle() is called on 'args' in cases DO_DUMP, DO_START_INPUT, and DO_RESTART_INPUT. This is a straightforward statement change, and not related to control dependencies, return statements, exception handling, or dependent APIs, so the change type is 4.","The addition of 'args.recycle()' statement in the latest version does not affect the returned values or exception behavior of the method. Therefore, this change does not cause a Compatibility Issue, so the CI type is 0."
176,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",16,17,"<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>","<android.text.format.DateFormat: CharSequence format(CharSequence,Calendar)>",0,"{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int c;
    int count;
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        int temp;
        count = 1;
        c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i, len);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case AM_PM:
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case CAPITAL_AM_PM:
                // FIXME: this is the same as AM_PM? no capital?
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case DATE:
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case DAY:
                temp = inDate.get(Calendar.DAY_OF_WEEK);
                replacement = DateUtils.getDayOfWeekString(temp, count < 4 ? DateUtils.LENGTH_MEDIUM : DateUtils.LENGTH_LONG);
                break;
            case HOUR:
                temp = inDate.get(Calendar.HOUR);
                if (0 == temp)
                    temp = 12;
                replacement = zeroPad(temp, count);
                break;
            case HOUR_OF_DAY:
                replacement = zeroPad(inDate.get(Calendar.HOUR_OF_DAY), count);
                break;
            case MINUTE:
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case MONTH:
                replacement = getMonthString(inDate, count);
                break;
            case SECONDS:
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case TIME_ZONE:
                replacement = getTimeZoneString(inDate, count);
                break;
            case YEAR:
                replacement = getYearString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned)
        return new SpannedString(s);
    else
        return s.toString();
}","{
    SpannableStringBuilder s = new SpannableStringBuilder(inFormat);
    int c;
    int count;
    int len = inFormat.length();
    for (int i = 0; i < len; i += count) {
        int temp;
        count = 1;
        c = s.charAt(i);
        if (c == QUOTE) {
            count = appendQuotedText(s, i, len);
            len = s.length();
            continue;
        }
        while ((i + count < len) && (s.charAt(i + count) == c)) {
            count++;
        }
        String replacement;
        switch(c) {
            case AM_PM:
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case CAPITAL_AM_PM:
                // FIXME: this is the same as AM_PM? no capital?
                replacement = DateUtils.getAMPMString(inDate.get(Calendar.AM_PM));
                break;
            case DATE:
                replacement = zeroPad(inDate.get(Calendar.DATE), count);
                break;
            case DAY:
                temp = inDate.get(Calendar.DAY_OF_WEEK);
                replacement = DateUtils.getDayOfWeekString(temp, count < 4 ? DateUtils.LENGTH_MEDIUM : DateUtils.LENGTH_LONG);
                break;
            case HOUR:
                temp = inDate.get(Calendar.HOUR);
                if (0 == temp)
                    temp = 12;
                replacement = zeroPad(temp, count);
                break;
            case HOUR_OF_DAY:
                replacement = zeroPad(inDate.get(Calendar.HOUR_OF_DAY), count);
                break;
            case MINUTE:
                replacement = zeroPad(inDate.get(Calendar.MINUTE), count);
                break;
            case MONTH:
            case STANDALONE_MONTH:
                replacement = getMonthString(inDate, count, c);
                break;
            case SECONDS:
                replacement = zeroPad(inDate.get(Calendar.SECOND), count);
                break;
            case TIME_ZONE:
                replacement = getTimeZoneString(inDate, count);
                break;
            case YEAR:
                replacement = getYearString(inDate, count);
                break;
            default:
                replacement = null;
                break;
        }
        if (replacement != null) {
            s.replace(i, i + count, replacement);
            // CARE: count is used in the for loop above
            count = replacement.length();
            len = s.length();
        }
    }
    if (inFormat instanceof Spanned)
        return new SpannedString(s);
    else
        return s.toString();
}",1,"/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
","/**
 * Given a format string and a {@link java.util.Calendar} object, returns a CharSequence
 * containing the requested date.
 * @param inFormat the format string, as described in {@link android.text.format.DateFormat}
 * @param inDate the date to format
 * @return a {@link CharSequence} containing the requested text
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The control statement '(case MONTH)' has modified and a new case '(case STANDALONE_MONTH)' is added. Moreover, there is a change in dependent API in the 'case MONTH' as well as in the new 'case STANDALONE_MONTH' where the method getMonthString() now takes an additional parameter 'c'. Hence the code change types are 3, 4, and 5.","The modification and new addition in switch case statements affect what 'replacement' gets set to, which in turn could change what the function returns. Thus, the CI type is 1."
178,<android.app.FragmentManagerImpl: String toString()>,16,17,<android.app.FragmentManagerImpl: String toString()>,<android.app.FragmentManagerImpl: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""FragmentManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    DebugUtils.buildShortClassTag(mActivity, sb);
    sb.append(""}}"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""FragmentManager{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" in "");
    if (mParent != null) {
        DebugUtils.buildShortClassTag(mParent, sb);
    } else {
        DebugUtils.buildShortClassTag(mActivity, sb);
    }
    sb.append(""}}"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement 'if (mParent != null)' and the statement under it have been added, and the else statement 'DebugUtils.buildShortClassTag(mActivity, sb)' is also new. So, the code change type is 3,4.","The introduced condition statement and the statement under it may lead to a different return value, so the CI type is 1."
179,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumSymbols(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumSymbols(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumSymbols(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of symbols required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumSymbols(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of symbols required in the password.
 */
","/**
 * Retrieve the current number of symbols required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumSymbols(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of symbols required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function has a different return statement in the late version ('return getPasswordMinimumSymbols(admin, UserHandle.myUserId())') from the early version ('return mService.getPasswordMinimumSymbols(admin)') and it alters in its dependent API (from mService.getPasswordMinimumSymbols(admin) to getPasswordMinimumSymbols(admin, UserHandle.myUserId())), so the code change types are 1 and 5.","Since the return statement has changed, it may lead to different return values in the two versions. Therefore, it could potentially cause a compatibility issue of type 1."
181,<android.webkit.WebSettings: TextSize getTextSize()>,16,17,<android.webkit.WebSettings: TextSize getTextSize()>,<android.webkit.WebSettings: TextSize getTextSize()>,0,"{
    throw new MustOverrideException();
}","{
    TextSize closestSize = null;
    int smallestDelta = Integer.MAX_VALUE;
    int textSize = getTextZoom();
    for (TextSize size : TextSize.values()) {
        int delta = Math.abs(textSize - size.value);
        if (delta == 0) {
            return size;
        }
        if (delta < smallestDelta) {
            smallestDelta = delta;
            closestSize = size;
        }
    }
    return closestSize != null ? closestSize : TextSize.NORMAL;
}",1,"/**
 * Gets the text size of the page. If the text size was previously specified
 * in percent using {@link #setTextZoom(int)}, this will return
 * the closest matching {@link TextSize}.
 *
 * @return a TextSize enum value describing the text size
 * @see WebSettings.TextSize
 * @deprecated Use {@link #getTextZoom()} instead.
 */
","/**
 * Gets the text size of the page. If the text size was previously specified
 * in percent using {@link #setTextZoom}, this will return the closest
 * matching {@link TextSize}.
 *
 * @return the text size as a {@link TextSize} value
 * @see #setTextSize
 * @deprecated Use {@link #getTextZoom} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The throw statement in the early version has been removed and control statements (for loop and 'if' condition), and other statements (like mathematical operations, comparisons and variable initializations) has been added in the late version. Hence the change type is 1,3,4.","Since return statements that were not present in the early version have been added, it's possible for the late version API to return different values and thus, it falls under CI type 1."
183,"<android.os.PowerManager: void userActivity(long,boolean)>",16,17,"<android.os.PowerManager: void userActivity(long,boolean)>","<android.os.PowerManager: void userActivity(long,boolean)>",0,"{
    try {
        mService.userActivity(when, noChangeLights);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.userActivity(when, USER_ACTIVITY_EVENT_OTHER, noChangeLights ? USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS : 0);
    } catch (RemoteException e) {
    }
}",1,"/**
 * User activity happened.
 * <p>
 * Turns the device from whatever state it's in to full on, and resets
 * the auto-off timer.
 *
 * @param when is used to order this correctly with the wake lock calls.
 * This time should be in the {@link SystemClock#uptimeMillis
 * SystemClock.uptimeMillis()} time base.
 * @param noChangeLights should be true if you don't want the lights to
 * turn on because of this event.  This is set when the power
 * key goes down.  We want the device to stay on while the button
 * is down, but we're about to turn off.  Otherwise the lights
 * flash on and then off and it looks weird.
 */
","/**
 * Notifies the power manager that user activity happened.
 * <p>
 * Resets the auto-off timer and brightens the screen if the device
 * is not asleep.  This is what happens normally when a key or the touch
 * screen is pressed or when some other user activity occurs.
 * This method does not wake up the device if it has been put to sleep.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param when The time of the user activity, in the {@link SystemClock#uptimeMillis()}
 * time base.  This timestamp is used to correctly order the user activity request with
 * other power management functions.  It should be set
 * to the timestamp of the input event that caused the user activity.
 * @param noChangeLights If true, does not cause the keyboard backlight to turn on
 * because of this event.  This is set when the power key is pressed.
 * We want the device to stay on while the button is down, but we're about
 * to turn off the screen so we don't want the keyboard backlight to turn on again.
 * Otherwise the lights flash on and then off and it looks weird.
 *
 * @see #wakeUp
 * @see #goToSleep
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method 'userActivity()' which is called by the API has changed its input parameters. Thus, categories 1 (Return statement changed) and 5 (Dependent API changed) are suitable for this code change.","Although there was a change in the parameters of the method 'userActivity()', there are no changes in error handling or returned results, thus there is no Compatibility Issue in this case."
185,"<android.speech.tts.TextToSpeech.Connection: R runAction(Action<R>,R,String,boolean)>",16,17,"<android.speech.tts.TextToSpeech.Connection: R runAction(Action<R>,R,String,boolean)>","<android.speech.tts.TextToSpeech.Connection: R runAction(Action<R>,R,String,boolean)>",0,"{
    try {
        synchronized (mStartLock) {
            if (mService == null) {
                Log.w(TAG, method + "" failed: not connected to TTS engine"");
                return errorResult;
            }
            return action.run(mService);
        }
    } catch (RemoteException ex) {
        Log.e(TAG, method + "" failed"", ex);
        if (reconnect) {
            disconnect();
            initTts();
        }
        return errorResult;
    }
}","{
    synchronized (mStartLock) {
        try {
            if (mService == null) {
                Log.w(TAG, method + "" failed: not connected to TTS engine"");
                return errorResult;
            }
            return action.run(mService);
        } catch (RemoteException ex) {
            Log.e(TAG, method + "" failed"", ex);
            if (reconnect) {
                disconnect();
                initTts();
            }
            return errorResult;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is in the location of the try-catch statement. Initially, it wrapped the entire code block in the method, but later it only wrapped the if statement and the return statement inside the synchronized block, so the code change type is 3.","The try-catch statement change will not affect the API's behavior. Regardless of the change, in both the early and late versions, they return the same value or throw the same type of exception when a RemoteException occurs. Therefore, there is no Compatibility Issue - 0."
187,<android.view.ViewGroup: boolean dispatchGenericFocusedEvent(MotionEvent)>,16,17,<android.view.ViewGroup: boolean dispatchGenericFocusedEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchGenericFocusedEvent(MotionEvent)>,0,"{
    // Send the event to the focused child or to this view group if it has focus.
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        return super.dispatchGenericFocusedEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        return mFocused.dispatchGenericMotionEvent(event);
    }
    return false;
}","{
    // Send the event to the focused child or to this view group if it has focus.
    if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        return super.dispatchGenericFocusedEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) {
        return mFocused.dispatchGenericMotionEvent(event);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The flags used for the bitwise AND operation inside if statements have changed from (FOCUSED | HAS_BOUNDS) to (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS) and from HAS_BOUNDS to PFLAG_HAS_BOUNDS, which is considered as other statement changed. Also, the constants used in the bitwise operation, which can be another method in a different file, have been changed. Therefore, the change is classified as both 4 and 5.","The change of the flags may result in different conditions being checked, potentially leading to different return values of the method. Therefore, the compatibility issue situation is considered as 1."
188,<android.text.format.Time: String format(String)>,16,17,<android.text.format.Time: String format(String)>,<android.text.format.Time: String format(String)>,0,"{
    synchronized (Time.class) {
        Locale locale = Locale.getDefault();
        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
            Resources r = Resources.getSystem();
            sShortMonths = new String[] { r.getString(com.android.internal.R.string.month_medium_january), r.getString(com.android.internal.R.string.month_medium_february), r.getString(com.android.internal.R.string.month_medium_march), r.getString(com.android.internal.R.string.month_medium_april), r.getString(com.android.internal.R.string.month_medium_may), r.getString(com.android.internal.R.string.month_medium_june), r.getString(com.android.internal.R.string.month_medium_july), r.getString(com.android.internal.R.string.month_medium_august), r.getString(com.android.internal.R.string.month_medium_september), r.getString(com.android.internal.R.string.month_medium_october), r.getString(com.android.internal.R.string.month_medium_november), r.getString(com.android.internal.R.string.month_medium_december) };
            sLongMonths = new String[] { r.getString(com.android.internal.R.string.month_long_january), r.getString(com.android.internal.R.string.month_long_february), r.getString(com.android.internal.R.string.month_long_march), r.getString(com.android.internal.R.string.month_long_april), r.getString(com.android.internal.R.string.month_long_may), r.getString(com.android.internal.R.string.month_long_june), r.getString(com.android.internal.R.string.month_long_july), r.getString(com.android.internal.R.string.month_long_august), r.getString(com.android.internal.R.string.month_long_september), r.getString(com.android.internal.R.string.month_long_october), r.getString(com.android.internal.R.string.month_long_november), r.getString(com.android.internal.R.string.month_long_december) };
            sLongStandaloneMonths = new String[] { r.getString(com.android.internal.R.string.month_long_standalone_january), r.getString(com.android.internal.R.string.month_long_standalone_february), r.getString(com.android.internal.R.string.month_long_standalone_march), r.getString(com.android.internal.R.string.month_long_standalone_april), r.getString(com.android.internal.R.string.month_long_standalone_may), r.getString(com.android.internal.R.string.month_long_standalone_june), r.getString(com.android.internal.R.string.month_long_standalone_july), r.getString(com.android.internal.R.string.month_long_standalone_august), r.getString(com.android.internal.R.string.month_long_standalone_september), r.getString(com.android.internal.R.string.month_long_standalone_october), r.getString(com.android.internal.R.string.month_long_standalone_november), r.getString(com.android.internal.R.string.month_long_standalone_december) };
            sShortWeekdays = new String[] { r.getString(com.android.internal.R.string.day_of_week_medium_sunday), r.getString(com.android.internal.R.string.day_of_week_medium_monday), r.getString(com.android.internal.R.string.day_of_week_medium_tuesday), r.getString(com.android.internal.R.string.day_of_week_medium_wednesday), r.getString(com.android.internal.R.string.day_of_week_medium_thursday), r.getString(com.android.internal.R.string.day_of_week_medium_friday), r.getString(com.android.internal.R.string.day_of_week_medium_saturday) };
            sLongWeekdays = new String[] { r.getString(com.android.internal.R.string.day_of_week_long_sunday), r.getString(com.android.internal.R.string.day_of_week_long_monday), r.getString(com.android.internal.R.string.day_of_week_long_tuesday), r.getString(com.android.internal.R.string.day_of_week_long_wednesday), r.getString(com.android.internal.R.string.day_of_week_long_thursday), r.getString(com.android.internal.R.string.day_of_week_long_friday), r.getString(com.android.internal.R.string.day_of_week_long_saturday) };
            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
            sAm = r.getString(com.android.internal.R.string.am);
            sPm = r.getString(com.android.internal.R.string.pm);
            sLocale = locale;
        }
        return format1(format);
    }
}","{
    synchronized (Time.class) {
        Locale locale = Locale.getDefault();
        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
            LocaleData localeData = LocaleData.get(locale);
            sAm = localeData.amPm[0];
            sPm = localeData.amPm[1];
            sZeroDigit = localeData.zeroDigit;
            sShortMonths = localeData.shortMonthNames;
            sLongMonths = localeData.longMonthNames;
            sLongStandaloneMonths = localeData.longStandAloneMonthNames;
            sShortWeekdays = localeData.shortWeekdayNames;
            sLongWeekdays = localeData.longWeekdayNames;
            Resources r = Resources.getSystem();
            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
            sLocale = locale;
        }
        String result = format1(format);
        if (sZeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    }
}",1,"/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */
","/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Changes include a new return statement 'return result;' and multiple variable assignments. Besides, the control dependency structure changed 'if (sZeroDigit != '0')'. Therefore, it can be classified into change type is 1, 3, and 4.","Given the introduction of new return statement and the changes in the control dependency, the output of this method can be different in the newer version based on the new conditions. Thus, it can be a Compatibility Issue of type 1."
189,<android.webkit.WebViewClassic: String getTouchIconUrl()>,16,17,<android.webkit.WebViewClassic: String getTouchIconUrl()>,<android.webkit.WebViewClassic: String getTouchIconUrl()>,0,"{
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTouchIconUrl() : null;
}","{
    WebHistoryItemClassic h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTouchIconUrl() : null;
}",1,"/**
 * See {@link WebView#getTouchIconUrl()}
 */
","/**
 * See {@link WebView#getTouchIconUrl()}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The type of variable h has been changed from WebHistoryItem to WebHistoryItemClassic, which means a method used in the implementation has changes in the type of returned object. So, the classification is 5.","There is no Compatibility Issue as the change in the type of the variable h does not lead to changes in the return value or thrown exceptions of the method 'getTouchIconUrl'. Therefore, no CI exists for this API."
190,<android.os.storage.StorageManager: boolean isObbMounted(String)>,16,17,<android.os.storage.StorageManager: boolean isObbMounted(String)>,<android.os.storage.StorageManager: boolean isObbMounted(String)>,0,"{
    if (filename == null) {
        throw new IllegalArgumentException(""filename cannot be null"");
    }
    try {
        return mMountService.isObbMounted(filename);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to check if OBB is mounted"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.isObbMounted(rawPath);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to check if OBB is mounted"", e);
    }
    return false;
}",1,"/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param filename path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
","/**
 * Check whether an Opaque Binary Blob (OBB) is mounted or not.
 *
 * @param rawPath path to OBB image
 * @return true if OBB is mounted; false if not mounted or on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The statement 'throw new IllegalArgumentException(""filename cannot be null"")' has been replaced by 'Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"")'. Additionally, the dependent API, the method isObbMounted()'s input parameter is changed from filename to rawPath. Thus, the change type is 4,5.","Since the check condition and the input variable of dependent API isObbMounted() has changed, the method may return a different value than before. Therefore, the CI type is 1."
191,"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>",16,17,"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>","<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>",0,"{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        try {
            mFragmentBreadCrumbs = (FragmentBreadCrumbs) crumbs;
        } catch (ClassCastException e) {
            return;
        }
        if (mFragmentBreadCrumbs == null) {
            if (title != null) {
                setTitle(title);
            }
            return;
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    mFragmentBreadCrumbs.setTitle(title, shortTitle);
    mFragmentBreadCrumbs.setParentTitle(null, null, null);
}","{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        try {
            mFragmentBreadCrumbs = (FragmentBreadCrumbs) crumbs;
        } catch (ClassCastException e) {
            return;
        }
        if (mFragmentBreadCrumbs == null) {
            if (title != null) {
                setTitle(title);
            }
            return;
        }
        if (mSinglePane) {
            mFragmentBreadCrumbs.setVisibility(View.GONE);
            // Hide the breadcrumb section completely for single-pane
            View bcSection = findViewById(com.android.internal.R.id.breadcrumb_section);
            if (bcSection != null)
                bcSection.setVisibility(View.GONE);
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    mFragmentBreadCrumbs.setTitle(title, shortTitle);
    mFragmentBreadCrumbs.setParentTitle(null, null, null);
}",1,"/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
","/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change contains control dependency changes, specifically related to condition 'if (mSinglePane)'. It introduces new view state changes such as 'mFragmentBreadCrumbs.setVisibility(View.GONE)' and 'bcSection.setVisibility(View.GONE)', so the code change type is 3,4.","None of the added statements and condition block will modify the return values or thrown exceptions of this method, so there is no Compatibility Issue predicted. The additional view state changes should not affect the calling APIs."
192,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,16,17,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,0,"{
    try {
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
","/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The depending API has changed from `ViewRootImpl.getWindowSession` in the previous version to `WindowManagerGlobal.getWindowSession` in the later version, so the code change type is 5.","Despite the change of the dependent API, the behavior of the function hasn't been altered, which means the return value and the exception handling remain the same. Therefore, type 0 is chosen indicating no compatibility issues exist."
193,<android.view.ScaleGestureDetector: float getPreviousSpanX()>,16,17,<android.view.ScaleGestureDetector: float getPreviousSpanX()>,<android.view.ScaleGestureDetector: float getPreviousSpanX()>,0,"{
    return mPrevFingerDiffX;
}","{
    return mPrevSpanX;
}",1,"/**
 * Return the previous x distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Previous distance between pointers in pixels.
 */
","/**
 * Return the previous average X distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Previous distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mPrevFingerDiffX to mPrevSpanX. Therefore, the code change belongs to category 1 - Return statement changed.","Given the different return variable in the newer version, the return value may differ when the same inputs are provided for both versions. Hence, a Compatibility Issue of type 1 (potential different return values or types) exists."
194,<android.widget.Switch: int getCompoundPaddingRight()>,16,17,<android.widget.Switch: int getCompoundPaddingRight()>,<android.widget.Switch: int getCompoundPaddingRight()>,0,"{
    int padding = super.getCompoundPaddingRight() + mSwitchWidth;
    if (!TextUtils.isEmpty(getText())) {
        padding += mSwitchPadding;
    }
    return padding;
}","{
    if (isLayoutRtl()) {
        return super.getCompoundPaddingRight();
    }
    int padding = super.getCompoundPaddingRight() + mSwitchWidth;
    if (!TextUtils.isEmpty(getText())) {
        padding += mSwitchPadding;
    }
    return padding;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed due to the addition of the `isLayoutRtl()` condition statement. Hence, the code change type is 3.","The inclusion of the `isLayoutRtl()` condition has affected the computed value of ""padding"". This could lead to a difference in the return value between the two versions, contributing to a potential compatibility issue of type 1."
195,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,16,17,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (DBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the debug log syntax has changed from DBG to VDBG, thus the code change type is only 4.","The change is irrelevant to the API behaviour and will not cause any compatibility issue, thus the CI type should be 0."
196,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,16,17,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,<android.app.FragmentManagerImpl: boolean dispatchContextItemSelected(MenuItem)>,0,"{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mUserVisibleHint) {
                if (f.onContextItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performContextItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The function call of the dependent code has changed from f.onContextItemSelected(item) to f.performContextItemSelected(item), so the code change type is 1,4.","As the function call of the dependent code has changed, the return value of the API can potentially also change. As a result the CI type is 1."
197,"<android.view.View: void measure(int,int)>",16,17,"<android.view.View: void measure(int,int)>","<android.view.View: void measure(int,int)>",0,"{
    if ((mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~MEASURED_DIMENSION_SET;
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}","{
    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) {
        // first clears the measured dimension flag
        mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;
        resolveRtlPropertiesIfNeeded();
        // measure ourselves, this should set the measured dimension flag back
        onMeasure(widthMeasureSpec, heightMeasureSpec);
        // an exception to warn the developer
        if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
            throw new IllegalStateException(""onMeasure() did not set the"" + "" measured dimension by calling"" + "" setMeasuredDimension()"");
        }
        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
    }
    mOldWidthMeasureSpec = widthMeasureSpec;
    mOldHeightMeasureSpec = heightMeasureSpec;
}",1,"/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
","/**
 * <p>
 * This is called to find out how big a view should be. The parent
 * supplies constraint information in the width and height parameters.
 * </p>
 *
 * <p>
 * The actual measurement work of a view is performed in
 * {@link #onMeasure(int, int)}, called by this method. Therefore, only
 * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
 * </p>
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the
 * parent
 * @param heightMeasureSpec Vertical space requirements as imposed by the
 * parent
 *
 * @see #onMeasure(int, int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The change in the condition statement in 'if', the introduction of a new statement resolveRtlPropertiesIfNeeded(), and the change of dependent APIs from onMeasure() and setMeasuredDimension() to PFLAG_* determine the code change type as 3, 4 and 5.","The control flow pattern modification in the 'if' condition and the addition of the resolveRtlPropertiesIfNeeded() method could potentially cause the method to behave differently leading to a different return value (even though the method is void, the internal state of the object might change) or potentially throw a different exception. Thus, the CI type involve both 1 and 2."
198,<android.app.admin.DevicePolicyManager: void wipeData(int)>,16,17,<android.app.admin.DevicePolicyManager: void wipeData(int)>,<android.app.admin.DevicePolicyManager: void wipeData(int)>,0,"{
    if (mService != null) {
        try {
            mService.wipeData(flags);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.wipeData(flags, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Ask the user date be wiped.  This will cause the device to reboot,
 * erasing all user data while next booting up.  External storage such
 * as SD cards will not be erased.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently must be 0.
 */
","/**
 * Ask the user date be wiped.  This will cause the device to reboot,
 * erasing all user data while next booting up.  External storage such
 * as SD cards will be also erased if the flag {@link #WIPE_EXTERNAL_STORAGE}
 * is set.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_WIPE_DATA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param flags Bit mask of additional options: currently 0 and
 * {@link #WIPE_EXTERNAL_STORAGE} are supported.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The return statement of the API implementation has changed from calling mService.wipeData(flags) to calling mService.wipeData(flags, UserHandle.myUserId()), and the dependent method 'wipeData(int)' has added a new parameter 'UserHandle.myUserId()', so the code change type is 1,5.","Even though there is a change in the API's implementation, but it doesn't have any return value and does not change the type of exception it throws, thus no compatibility issue is detected."
199,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",16,17,"<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>","<android.webkit.AccessibilityInjector.CallbackHandler: void onResult(String,String)>",0,"{
    final long resultId;
    try {
        resultId = Long.parseLong(id);
    } catch (NumberFormatException e) {
        return;
    }
    synchronized (mResultLock) {
        if (resultId > mResultId) {
            mResult = Boolean.parseBoolean(result);
            mResultId = resultId;
        }
        mResultLock.notifyAll();
    }
}","{
    if (DEBUG) {
        Log.w(TAG, ""Saw CVOX result of '"" + result + ""' for ID "" + id);
    }
    final int resultId;
    try {
        resultId = Integer.parseInt(id);
    } catch (NumberFormatException e) {
        return;
    }
    synchronized (mResultLock) {
        if (resultId > mResultId) {
            mResult = Boolean.parseBoolean(result);
            mResultId = resultId;
        } else {
            if (DEBUG) {
                Log.w(TAG, ""Result with ID "" + resultId + "" was stale vesus "" + mResultId);
            }
        }
        mResultLock.notifyAll();
    }
}",1,"/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
","/**
 * Callback exposed to JavaScript. Handles returning the result of a
 * request to a waiting (or potentially timed out) thread.
 *
 * @param id The result id of the request as a {@link String}.
 * @param result The result of the request as a {@link String}.
 */
",-1,"[@SuppressWarnings(""unused"")]","[@JavascriptInterface, @SuppressWarnings(""unused"")]",-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, new debug logs have been introduced, and the 'resultId' variable type has been changed form long to int, so the code change type is 1,3,4.","The change of 'resultId' variable from long type to int type could potentially result in change in the condition result and affect the value of mResult variable, thus the 'return' can be potentially different in late version API, so the CI type is 1."
200,<android.os.Environment: boolean isExternalStorageEmulated()>,16,17,<android.os.Environment: boolean isExternalStorageEmulated()>,<android.os.Environment: boolean isExternalStorageEmulated()>,0,"{
    StorageVolume volume = getPrimaryVolume();
    return (volume != null && volume.isEmulated());
}","{
    final StorageVolume primary = getPrimaryVolume();
    return (primary != null && primary.isEmulated());
}",1,"/**
 * Returns whether the device has an external storage device which is
 * emulated. If true, the device does not have real external storage, and the directory
 * returned by {@link #getExternalStorageDirectory()} will be allocated using a portion of
 * the internal storage system.
 *
 * <p>Certain system services, such as the package manager, use this
 * to determine where to install an application.
 *
 * <p>Emulated external storage may also be encrypted - see
 * {@link android.app.admin.DevicePolicyManager#setStorageEncryption(
 * android.content.ComponentName, boolean)} for additional details.
 */
","/**
 * Returns whether the device has an external storage device which is
 * emulated. If true, the device does not have real external storage, and the directory
 * returned by {@link #getExternalStorageDirectory()} will be allocated using a portion of
 * the internal storage system.
 *
 * <p>Certain system services, such as the package manager, use this
 * to determine where to install an application.
 *
 * <p>Emulated external storage may also be encrypted - see
 * {@link android.app.admin.DevicePolicyManager#setStorageEncryption(
 * android.content.ComponentName, boolean)} for additional details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only about a variable name, from 'volume' to 'primary'. So the code change type is 4.","As the variable name change doesn't lead to potential behavior changes of the API, the CI type is 0 in this case."
201,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,16,17,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,<android.app.admin.DevicePolicyManager: int getStorageEncryptionStatus()>,0,"{
    if (mService != null) {
        try {
            return mService.getStorageEncryptionStatus();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}","{
    return getStorageEncryptionStatus(UserHandle.myUserId());
}",1,"/**
 * Called by an application that is administering the device to
 * determine the current encryption status of the device.
 *
 * Depending on the returned status code, the caller may proceed in different
 * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the
 * storage system does not support encryption.  If the
 * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link
 * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
 * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING} or
 * {@link #ENCRYPTION_STATUS_ACTIVE}, no further action is required.
 *
 * @return current status of encryption.  The value will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},
 * {@link #ENCRYPTION_STATUS_ACTIVATING}, or{@link #ENCRYPTION_STATUS_ACTIVE}.
 */
","/**
 * Called by an application that is administering the device to
 * determine the current encryption status of the device.
 *
 * Depending on the returned status code, the caller may proceed in different
 * ways.  If the result is {@link #ENCRYPTION_STATUS_UNSUPPORTED}, the
 * storage system does not support encryption.  If the
 * result is {@link #ENCRYPTION_STATUS_INACTIVE}, use {@link
 * #ACTION_START_ENCRYPTION} to begin the process of encrypting or decrypting the
 * storage.  If the result is {@link #ENCRYPTION_STATUS_ACTIVATING} or
 * {@link #ENCRYPTION_STATUS_ACTIVE}, no further action is required.
 *
 * @return current status of encryption.  The value will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE},
 * {@link #ENCRYPTION_STATUS_ACTIVATING}, or{@link #ENCRYPTION_STATUS_ACTIVE}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early implementation involves making a call to mService.getStorageEncryptionStatus() after performing a null check on mService. If this call fails, an ENCRYPTION_STATUS_UNSUPPORTED is returned. In the late implementation, the method getStorageEncryptionStatus(UserHandle.myUserId()) is called directly without any control statements. Hence the change types are 1 (Return statement changed) and 5 (Dependent API changed).","The fundamental return behaviour of the function has been changed, as it not only returns a different function now, but also the conditions under which it returns have been altered. Rather than potentially returning ENCRYPTION_STATUS_UNSUPPORTED due to mService being null or a RemoteException, it now simply returns the result of getStorageEncryptionStatus(UserHandle.myUserId()). This change implies that the API may return a different value, hence the CI type is 1 (Compatibility Issue caused by potential different return values)."
202,"<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>",16,17,"<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>","<android.webkit.CallbackProxy: void onReceivedTouchIconUrl(String,boolean)>",0,"{
    // We should have a current item but we do not want to crash so check
    // for null.
    WebHistoryItem i = mBackForwardList.getCurrentItem();
    if (i != null) {
        i.setTouchIconUrl(url, precomposed);
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_TOUCH_ICON_URL, precomposed ? 1 : 0, 0, url));
}","{
    // We should have a current item but we do not want to crash so check
    // for null.
    WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
    if (i != null) {
        i.setTouchIconUrl(url, precomposed);
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_TOUCH_ICON_URL, precomposed ? 1 : 0, 0, url));
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the class type of variable 'i' has changed from WebHistoryItem to WebHistoryItemClassic, which is not a return statement, exception handling statement, control dependency or dependent API but an Other Statement Change. Therefore, the pred_change is 4.","The code change does not influence the return value, exception handling, or the behavior of the API. Thus, there is no compatibility issue, and the pred_CI is 0."
203,"<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>",16,17,"<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>","<android.app.ApplicationErrorReport: ComponentName getErrorReportReceiver(Context,String,int)>",0,"{
    // check if error reporting is enabled in secure settings
    int enabled = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.SEND_ACTION_APP_ERROR, 0);
    if (enabled == 0) {
        return null;
    }
    PackageManager pm = context.getPackageManager();
    // look for receiver in the installer package
    String candidate = pm.getInstallerPackageName(packageName);
    ComponentName result = getErrorReportReceiver(pm, packageName, candidate);
    if (result != null) {
        return result;
    }
    // error receiver
    if ((appFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        candidate = SystemProperties.get(SYSTEM_APPS_ERROR_RECEIVER_PROPERTY);
        result = getErrorReportReceiver(pm, packageName, candidate);
        if (result != null) {
            return result;
        }
    }
    // if there is a default receiver, try that
    candidate = SystemProperties.get(DEFAULT_ERROR_RECEIVER_PROPERTY);
    return getErrorReportReceiver(pm, packageName, candidate);
}","{
    // check if error reporting is enabled in secure settings
    int enabled = Settings.Global.getInt(context.getContentResolver(), Settings.Global.SEND_ACTION_APP_ERROR, 0);
    if (enabled == 0) {
        return null;
    }
    PackageManager pm = context.getPackageManager();
    // look for receiver in the installer package
    String candidate = pm.getInstallerPackageName(packageName);
    ComponentName result = getErrorReportReceiver(pm, packageName, candidate);
    if (result != null) {
        return result;
    }
    // error receiver
    if ((appFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        candidate = SystemProperties.get(SYSTEM_APPS_ERROR_RECEIVER_PROPERTY);
        result = getErrorReportReceiver(pm, packageName, candidate);
        if (result != null) {
            return result;
        }
    }
    // if there is a default receiver, try that
    candidate = SystemProperties.get(DEFAULT_ERROR_RECEIVER_PROPERTY);
    return getErrorReportReceiver(pm, packageName, candidate);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method used to get settings value has changed from Settings.Secure.getInt() to Settings.Global.getInt(), this is a dependent API change (type 5), but can also be seen as an other statement change (type 4).","Even though the setting retrieval method has changed, the variable 'enabled' returned does not change the type or potentially possible values. This change does not cause the API to throw a different exception or return a different type or value, so there is no Compatibility Issue (type 0)."
204,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordHistoryLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordHistoryLength(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the length
 * of the password history. After setting this, the user will not be able to
 * enter a new password that is the same as any password in the history. Note
 * that the current password will remain until the user has set a new one, so
 * the change does not take place immediately. To prompt the user for a new
 * password, use {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 * This constraint is only imposed if the administrator has also requested
 * either {@link #PASSWORD_QUALITY_NUMERIC},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, or
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} with {@link #setPasswordQuality}.
 *
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired length of password history. A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the length
 * of the password history. After setting this, the user will not be able to
 * enter a new password that is the same as any password in the history. Note
 * that the current password will remain until the user has set a new one, so
 * the change does not take place immediately. To prompt the user for a new
 * password, use {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 * This constraint is only imposed if the administrator has also requested
 * either {@link #PASSWORD_QUALITY_NUMERIC},
 * {@link #PASSWORD_QUALITY_ALPHABETIC}, or
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} with {@link #setPasswordQuality}.
 *
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired length of password history. A value of 0
 * means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The parameters of the mService.setPasswordHistoryLength() method have changed from two (admin, length) to three (admin, length, UserHandle.myUserId()) and thus the return statement has been altered. Therefore, the code change type is 1,5.","Even though the number of parameters in the setPasswordHistoryLength() method has changed, it does not affect the return value or throw a different exception. Hence, there is no Compatibility Issue, so pred_CI is 0."
210,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,16,17,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothHeadset: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (DBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the log-level variable has changed from DBG to VDBG, so the change type is 4.","This change does not affect the return value of the API or the exception handling, it doesn't cause any compatibility issue. So the CI type is 0."
211,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,16,17,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,0,"{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    JniUtil.setContext(context);
    Context appContext = context.getApplicationContext();
    if (sRef == null) {
        sRef = new CookieSyncManager(appContext);
    }
    return sRef;
}","{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    if (sRef == null) {
        sRef = new CookieSyncManager(context);
    }
    return sRef;
}",1,"/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
","/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The method call JniUtil.setContext(context); and the assignment Context appContext = context.getApplicationContext(); within an 'if' statement are deleted, and the variable used to create a new object of CookieSyncManager has changed from appContext to context in the late version. Hence, type of the change is 3,4.","The changes in logic control and other relevant statements can potentially lead to different objects being returned by the method, leading to possible compatibility issues. As a result, the type of CI here is 1."
213,<android.widget.Scroller: float getCurrVelocity()>,16,17,<android.widget.Scroller: float getCurrVelocity()>,<android.widget.Scroller: float getCurrVelocity()>,0,"{
    return mVelocity - mDeceleration * timePassed() / 2000.0f;
}","{
    return mMode == FLING_MODE ? mCurrVelocity : mVelocity - mDeceleration * timePassed() / 2000.0f;
}",1,"/**
 * Returns the current velocity.
 *
 * @return The original velocity less the deceleration. Result may be
 * negative.
 */
","/**
 * Returns the current velocity.
 *
 * @return The original velocity less the deceleration. Result may be
 * negative.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new control dependency statement (mMode == FLING_MODE) has been introduced, and the return statements have changed based on the control statement, thus the code change type is 1,3.","Due to the introduction of the new control dependency 'mMode == FLING_MODE', the method could potentially return two different values, depending on the value of mMode. This could cause the behaviour of the method to change, thus the CI type is 1."
214,"<android.app.FragmentManagerImpl: void removeFragment(Fragment,int,int)>",16,17,"<android.app.FragmentManagerImpl: void removeFragment(Fragment,int,int)>","<android.app.FragmentManagerImpl: void removeFragment(Fragment,int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""remove: "" + fragment + "" nesting="" + fragment.mBackStackNesting);
    final boolean inactive = !fragment.isInBackStack();
    if (!fragment.mDetached || inactive) {
        if (mAdded != null) {
            mAdded.remove(fragment);
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        fragment.mAdded = false;
        fragment.mRemoving = true;
        moveToState(fragment, inactive ? Fragment.INITIALIZING : Fragment.CREATED, transition, transitionStyle, false);
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""remove: "" + fragment + "" nesting="" + fragment.mBackStackNesting);
    final boolean inactive = !fragment.isInBackStack();
    if (!fragment.mDetached || inactive) {
        if (false) {
            // where it is not a problem.
            if (!mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment not added: "" + fragment);
            }
        }
        if (mAdded != null) {
            mAdded.remove(fragment);
        }
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        fragment.mAdded = false;
        fragment.mRemoving = true;
        moveToState(fragment, inactive ? Fragment.INITIALIZING : Fragment.CREATED, transition, transitionStyle, false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new block of statements which includes control and throw statement are introduced in the later version. Although, the block statement is in a condition check for false, meaning it won't be executed. Thus, the change types are 3 (because a new condition statement has been added) and 4 (because of the introduction of a throw statement and the addition of the condition check false).","Since the added block is inside a 'false' condition, it will not be executed, nor would it change the API's behavior in any way. Hence, there is no compatibility issue in this case."
215,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",16,17,"<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>","<android.view.inputmethod.InputMethodManager: boolean startInputInner(IBinder,int,int,int)>",0,"{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // from under us, so just bail.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view!"");
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                } else if (mCurMethod == null) {
                    // This means there is no input method available.
                    if (DEBUG)
                        Log.v(TAG, ""ABORT input: no input method!"");
                    return true;
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}","{
    final View view;
    synchronized (mH) {
        view = mServedView;
        // Make sure we have a window token for the served view.
        if (DEBUG)
            Log.v(TAG, ""Starting input: view="" + view);
        if (view == null) {
            if (DEBUG)
                Log.v(TAG, ""ABORT input: no served view!"");
            return false;
        }
    }
    // Now we need to get an input connection from the served view.
    // This is complicated in a couple ways: we can't be holding our lock
    // when calling out to the view, and we need to make sure we call into
    // the view on the same thread that is driving its view hierarchy.
    Handler vh = view.getHandler();
    if (vh == null) {
        // screen without a connection.
        if (DEBUG)
            Log.v(TAG, ""ABORT input: no handler for view! Close current input."");
        closeCurrentInput();
        return false;
    }
    if (vh.getLooper() != Looper.myLooper()) {
        // we need to reschedule our work for over there.
        if (DEBUG)
            Log.v(TAG, ""Starting input: reschedule to view thread"");
        vh.post(new Runnable() {

            public void run() {
                startInputInner(null, 0, 0, 0);
            }
        });
        return false;
    }
    // Okay we are now ready to call into the served view and have it
    // do its stuff.
    // Life is good: let's hook everything up!
    EditorInfo tba = new EditorInfo();
    tba.packageName = view.getContext().getPackageName();
    tba.fieldId = view.getId();
    InputConnection ic = view.onCreateInputConnection(tba);
    if (DEBUG)
        Log.v(TAG, ""Starting input: tba="" + tba + "" ic="" + ic);
    synchronized (mH) {
        // changed.
        if (mServedView != view || !mServedConnecting) {
            // Something else happened, so abort.
            if (DEBUG)
                Log.v(TAG, ""Starting input: finished by someone else (view="" + mServedView + "" conn="" + mServedConnecting + "")"");
            return false;
        }
        // connected so we want to restart it.
        if (mCurrentTextBoxAttribute == null) {
            controlFlags |= CONTROL_START_INITIAL;
        }
        // Hook 'em up and let 'er rip.
        mCurrentTextBoxAttribute = tba;
        mServedConnecting = false;
        // Notify the served view that its previous input connection is finished
        notifyInputConnectionFinished();
        mServedInputConnection = ic;
        ControlledInputConnectionWrapper servedContext;
        if (ic != null) {
            mCursorSelStart = tba.initialSelStart;
            mCursorSelEnd = tba.initialSelEnd;
            mCursorCandStart = -1;
            mCursorCandEnd = -1;
            mCursorRect.setEmpty();
            servedContext = new ControlledInputConnectionWrapper(vh.getLooper(), ic, this);
        } else {
            servedContext = null;
        }
        if (mServedInputConnectionWrapper != null) {
            mServedInputConnectionWrapper.deactivate();
        }
        mServedInputConnectionWrapper = servedContext;
        try {
            if (DEBUG)
                Log.v(TAG, ""START INPUT: "" + view + "" ic="" + ic + "" tba="" + tba + "" controlFlags=#"" + Integer.toHexString(controlFlags));
            InputBindResult res;
            if (windowGainingFocus != null) {
                res = mService.windowGainedFocus(mClient, windowGainingFocus, controlFlags, softInputMode, windowFlags, tba, servedContext);
            } else {
                res = mService.startInput(mClient, servedContext, tba, controlFlags);
            }
            if (DEBUG)
                Log.v(TAG, ""Starting input: Bind result="" + res);
            if (res != null) {
                if (res.id != null) {
                    mBindSequence = res.sequence;
                    mCurMethod = res.method;
                    mCurId = res.id;
                } else if (mCurMethod == null) {
                    // This means there is no input method available.
                    if (DEBUG)
                        Log.v(TAG, ""ABORT input: no input method!"");
                    return true;
                }
            }
            if (mCurMethod != null && mCompletions != null) {
                try {
                    mCurMethod.displayCompletions(mCompletions);
                } catch (RemoteException e) {
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"A new statement ""closeCurrentInput()"" is added. This is a categorised as other statement that has been changed (Category 4).","The addition of the ""closeCurrentInput()"" function potentially changes the behaviour of the method, which in turn could influence the return values of this method. Hence, it could lead to a Compatibility Issue caused by potentially different return values or types (Category 1)."
216,"<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>",16,17,"<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>","<android.widget.Gallery: boolean onKeyDown(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (movePrevious()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
            }
            return true;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveNext()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
            }
            return true;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (movePrevious()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveNext()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}",1,"/**
 * Handles left, right, and clicking
 * @see android.view.View#onKeyDown
 */
","/**
 * Handles left, right, and clicking
 * @see android.view.View#onKeyDown
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The 'return true' statements have been moved from the case blocks of KeyEvent.KEYCODE_DPAD_LEFT and KeyEvent.KEYCODE_DPAD_RIGHT to their corresponding if statements. This is a change in control dependency, the code change type is 3.","Due to the location shift of the statements 'return true', this function will potentially return different values in different versions when the conditions 'movePrevious()' and 'moveNext()' don't meet. Therefore, it will cause potential compatibility issue by returning different values. The CI type is 1."
217,<android.view.View: boolean canAcceptDrag()>,16,17,<android.view.View: boolean canAcceptDrag()>,<android.view.View: boolean canAcceptDrag()>,0,"{
    return (mPrivateFlags2 & DRAG_CAN_ACCEPT) != 0;
}","{
    return (mPrivateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The symbolic constant has been updated from DRAG_CAN_ACCEPT to PFLAG2_DRAG_CAN_ACCEPT. This is considered other statement type change and dependent API change.,"Because of the change in the constant value used in the computation, we obtain potentially different return values which leads to Compatibility Issue type 1."
221,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,16,17,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,0,"{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteViewsAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteViewsAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}","{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteViewsAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteViewsAdapter = new RemoteViewsAdapter(getContext(), intent, this);
    if (mRemoteViewsAdapter.isDataReady()) {
        setAdapter(mRemoteViewsAdapter);
    }
}",1,"/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
","/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
",-1,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, a new judgement about whether data is ready and function `setAdapter(mRemoteViewsAdapter)` have been added (otherwise, the function is not invoked). Which means a return statement about not invoking `setAdapter(mRemoteViewsAdapter)` is deleted. Therefore the change type is 1,4.","The existence of the new statement `setAdapter(mRemoteViewsAdapter)` makes the late version could do more things than the early version after this function is invoked, which potentially leads to a behavior change, and hence the CI type is 1."
222,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",16,17,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>","<android.content.res.Configuration: void writeToParcel(Parcel,int)>",0,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(layoutDirection);
    dest.writeInt(seq);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(densityDpi);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(seq);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,There is one extra line in Late_Implementation - dest.writeInt(densityDpi) which was not present in Early_Implementation which results in change type 1.,"The extra writeInt() statement introduced in Late_Implementation will potentially change the output of the writeToParcel() method, therefore the CI type is 1."
224,<android.webkit.WebViewClassic.PrivateHandler: boolean shouldInterceptTouchEvent(MotionEvent)>,16,17,<android.webkit.WebViewClassic.PrivateHandler: boolean shouldInterceptTouchEvent(MotionEvent)>,<android.webkit.WebViewClassic.PrivateHandler: boolean shouldInterceptTouchEvent(MotionEvent)>,0,"{
    if (!mSelectingText) {
        return false;
    }
    ensureSelectionHandles();
    int y = Math.round(event.getY() - getTitleHeight() + getScrollY());
    int x = Math.round(event.getX() + getScrollX());
    boolean isPressingHandle;
    if (mIsCaretSelection) {
        isPressingHandle = mSelectHandleCenter.getBounds().contains(x, y);
    } else {
        isPressingHandle = mSelectHandleLeft.getBounds().contains(x, y) || mSelectHandleRight.getBounds().contains(x, y);
    }
    return isPressingHandle;
}","{
    if (!mSelectingText) {
        return false;
    }
    ensureSelectionHandles();
    int y = Math.round(event.getY() - getTitleHeight() + getScrollY());
    int x = Math.round(event.getX() + getScrollX());
    boolean isPressingHandle;
    if (mIsCaretSelection) {
        isPressingHandle = mSelectHandleCenter.getBounds().contains(x, y);
    } else {
        isPressingHandle = mSelectHandleBaseBounds.contains(x, y) || mSelectHandleExtentBounds.contains(x, y);
    }
    return isPressingHandle;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API in the implementation has changed from `mSelectHandleLeft.getBounds().contains(x, y)` and `mSelectHandleRight.getBounds().contains(x, y)` to `mSelectHandleBaseBounds.contains(x, y)` and `mSelectHandleExtentBounds.contains(x, y)`. This leads to different return statement values, hence classifying it as types 1,5.",The change of dependent API causes a potential change in the returned value of the method which could cause a compatibility issue of type 1.
225,"<android.view.ViewRootImpl.W: void dispatchWallpaperCommand(String,int,int,int,Bundle,boolean)>",16,17,"<android.view.ViewRootImpl.W: void dispatchWallpaperCommand(String,int,int,int,Bundle,boolean)>","<android.view.ViewRootImpl.W: void dispatchWallpaperCommand(String,int,int,int,Bundle,boolean)>",0,"{
    if (sync) {
        try {
            sWindowSession.wallpaperCommandComplete(asBinder(), null);
        } catch (RemoteException e) {
        }
    }
}","{
    if (sync) {
        try {
            mWindowSession.wallpaperCommandComplete(asBinder(), null);
        } catch (RemoteException e) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The implementation changes from calling sWindowSession.wallpaperCommandComplete(asBinder(), null) to calling mWindowSession.wallpaperCommandComplete(asBinder(), null), which indicates Other statement and Dependent API change, the code change types are 4,5.","The potential behaviours of this API didn't change between two versions (i.e., no new values or exceptions, etc.), thus there is No Compatibility Issue for this API, so the CI type is 0."
227,"<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>",16,17,"<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>","<android.view.View: boolean requestRectangleOnScreen(Rect,boolean)>",0,"{
    View child = this;
    ViewParent parent = mParent;
    boolean scrolled = false;
    while (parent != null) {
        scrolled |= parent.requestChildRectangleOnScreen(child, rectangle, immediate);
        // offset rect so next call has the rectangle in the
        // coordinate system of its direct child.
        rectangle.offset(child.getLeft(), child.getTop());
        rectangle.offset(-child.getScrollX(), -child.getScrollY());
        if (!(parent instanceof View)) {
            break;
        }
        child = (View) parent;
        parent = child.getParent();
    }
    return scrolled;
}","{
    if (mParent == null) {
        return false;
    }
    View child = this;
    RectF position = (mAttachInfo != null) ? mAttachInfo.mTmpTransformRect : new RectF();
    position.set(rectangle);
    ViewParent parent = mParent;
    boolean scrolled = false;
    while (parent != null) {
        rectangle.set((int) position.left, (int) position.top, (int) position.right, (int) position.bottom);
        scrolled |= parent.requestChildRectangleOnScreen(child, rectangle, immediate);
        if (!child.hasIdentityMatrix()) {
            child.getMatrix().mapRect(position);
        }
        position.offset(child.mLeft, child.mTop);
        if (!(parent instanceof View)) {
            break;
        }
        View parentView = (View) parent;
        position.offset(-parentView.getScrollX(), -parentView.getScrollY());
        child = parentView;
        parent = child.getParent();
    }
    return scrolled;
}",1,"/**
 * Request that a rectangle of this view be visible on the screen,
 * scrolling if necessary just enough.
 *
 * <p>A View should call this if it maintains some notion of which part
 * of its content is interesting.  For example, a text editing view
 * should call this when its cursor moves.
 *
 * <p>When <code>immediate</code> is set to true, scrolling will not be
 * animated.
 *
 * @param rectangle The rectangle.
 * @param immediate True to forbid animated scrolling, false otherwise
 * @return Whether any parent scrolled.
 */
","/**
 * Request that a rectangle of this view be visible on the screen,
 * scrolling if necessary just enough.
 *
 * <p>A View should call this if it maintains some notion of which part
 * of its content is interesting.  For example, a text editing view
 * should call this when its cursor moves.
 *
 * <p>When <code>immediate</code> is set to true, scrolling will not be
 * animated.
 *
 * @param rectangle The rectangle.
 * @param immediate True to forbid animated scrolling, false otherwise
 * @return Whether any parent scrolled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version and late version have significant differences, including the introduction of a new return statement at the beginning, changes to control dependencies, and changes to the calculation of rectangle and position. Therefore, the code change could be classified as return statement changed(1), control dependency changed(3) and other statement changed(4).","Given that the process and logic in how 'scrolled' is calculated has been changed, the return variable 'scrolled' might be different between the two versions. Therefore, the compatibility issue could potentially be caused by a different return value (1)."
230,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,16,17,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,<android.bluetooth.BluetoothDevice: boolean fetchUuidsWithSdp()>,0,"{
    try {
        return sService.fetchRemoteUuids(mAddress, null, null);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        return sService.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
","/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from sService.fetchRemoteUuids(mAddress, null, null) to sService.fetchRemoteUuids(this), and the parameters of the fetchRemoteUuids() method have also changed, so the code change type is 1,5.","The change in the return statement and in the fetchRemoteUuids() method parameters may cause the API to return a different value, so the CI type is 1."
231,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",16,17,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return readNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}","{
    if (VDBG)
        Log.d(TAG, ""read in:  "" + mSocketIS + "" len: "" + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException(""bt socket closed, read return: "" + ret);
    if (VDBG)
        Log.d(TAG, ""read out:  "" + mSocketIS + "" ret: "" + ret);
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",2,"The readNative() method is replaced with mSocketIS.read() and the related control structure has been modified, so the code change type is 1,4.","In the early version, an exception is thrown if the mSocketState is ""CLOSED"". In the late version, an exception is raised if mSocketIS.read() returns a value less than zero, which means that the socket is closed. So, the API could throw exceptions in different situations, thus the CI type is 2."
232,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,16,17,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(int)>,0,"{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getEnabledAccessibilityServiceList(feedbackTypeFlags);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}","{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getEnabledAccessibilityServiceList(feedbackTypeFlags, mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the enabled accessibility services
 * for a given feedback type.
 *
 * @param feedbackTypeFlags The feedback type flags.
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 *
 * @see AccessibilityServiceInfo#FEEDBACK_AUDIBLE
 * @see AccessibilityServiceInfo#FEEDBACK_GENERIC
 * @see AccessibilityServiceInfo#FEEDBACK_HAPTIC
 * @see AccessibilityServiceInfo#FEEDBACK_SPOKEN
 * @see AccessibilityServiceInfo#FEEDBACK_VISUAL
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method getEnabledAccessibilityServiceList() has changed as the number of parameters increased from one to two, which belongs to class 5. Moreover, this change also leads to a different return statement, thus code change type is 1,5.","The alteration in the dependent API mService.getEnabledAccessibilityServiceList() may result in different lists returned by this API, leading to potential different return values, so the CI_type is 1."
233,<android.webkit.WebViewClassic: boolean performLongClick()>,16,17,<android.webkit.WebViewClassic: boolean performLongClick()>,<android.webkit.WebViewClassic: boolean performLongClick()>,0,"{
    // view system. In that case, do nothing.
    if (mWebView.getParent() == null)
        return false;
    // A multi-finger gesture can look like a long press; make sure we don't take
    // long press actions if we're scaling.
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    if (detector != null && detector.isInProgress()) {
        return false;
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (mWebViewPrivate.super_performLongClick()) {
        return true;
    }
    /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
    final boolean isSelecting = selectText();
    if (isSelecting) {
        mWebView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    } else if (focusCandidateIsEditableText()) {
        mSelectCallback = new SelectActionModeCallback();
        mSelectCallback.setWebView(this);
        mSelectCallback.setTextSelected(false);
        mWebView.startActionMode(mSelectCallback);
    }
    return isSelecting;
}","{
    // view system. In that case, do nothing.
    if (mWebView.getParent() == null)
        return false;
    // A multi-finger gesture can look like a long press; make sure we don't take
    // long press actions if we're scaling.
    final ScaleGestureDetector detector = mZoomManager.getScaleGestureDetector();
    if (detector != null && detector.isInProgress()) {
        return false;
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (mWebViewPrivate.super_performLongClick()) {
        return true;
    }
    /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
    final boolean isSelecting = selectText();
    if (isSelecting) {
        mWebView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    } else if (focusCandidateIsEditableText()) {
        mSelectCallback = new SelectActionModeCallback();
        mSelectCallback.setWebView(this);
        mSelectCallback.setTextSelected(false);
        mWebView.startActionMode(mSelectCallback);
    }
    return isSelecting;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API getMultiTouchGestureDetector() was replaced by getScaleGestureDetector(). Since this will change the result of function calls and potentially lead to a different return value, the code change type is 1,5.","Dependent API getMultiTouchGestureDetector() has changed to getScaleGestureDetector(), which could potentially change the return statement result. It means a new expected return value of this API, so the CI type is 1."
234,<android.app.Activity: void performStop()>,16,17,<android.app.Activity: void performStop()>,<android.app.Activity: void performStop()>,0,"{
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}","{
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API has changed from WindowManagerImpl.getDefault() to WindowManagerGlobal.getInstance(), classifying the change type as 5.","Despite the API change, the functionality remains the same, it would not cause functionality or behavioural differences, so no compatibility issues exist, classifying the CI type as 0."
235,<android.view.ScaleGestureDetector: float getCurrentSpan()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpan()>,<android.view.ScaleGestureDetector: float getCurrentSpan()>,0,"{
    if (mCurrLen == -1) {
        final float cvx = mCurrFingerDiffX;
        final float cvy = mCurrFingerDiffY;
        mCurrLen = FloatMath.sqrt(cvx * cvx + cvy * cvy);
    }
    return mCurrLen;
}","{
    return mCurrSpan;
}",1,"/**
 * Return the current distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,The return statement has been changed from 'mCurrLen' to 'mCurrSpan' and the original calculation of 'mCurrLen' has been removed. So the code change type is 1.,"As the returned variable changes from 'mCurrLen' to 'mCurrSpan', this could cause a potential different return value or type, so the CI type is 1."
236,"<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>",16,17,"<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>","<android.provider.Settings.Secure: boolean putLong(ContentResolver,String,long)>",0,"{
    return putString(cr, name, Long.toString(value));
}","{
    return putLongForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a secure settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a secure settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from putString(cr, name, Long.toString(value)) to putLongForUser(cr, name, value, UserHandle.myUserId()) and the dependent API also changed from putString() to putLongForUser(), so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
237,<android.app.ActivityThread.H: void handleMessage(Message)>,16,17,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityRestart"");
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            break;
        case PAUSE_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PAUSE_ACTIVITY_FINISHING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityPause"");
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_SHOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_ACTIVITY_HIDE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityStop"");
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SHOW_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityShowWindow"");
            handleWindowVisibility((IBinder) msg.obj, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case HIDE_WINDOW:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityHideWindow"");
            handleWindowVisibility((IBinder) msg.obj, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RESUME_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityResume"");
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SEND_RESULT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDeliverResult"");
            handleSendResult((ResultData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_ACTIVITY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityDestroy"");
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityNewIntent"");
            handleNewIntent((NewIntentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceCreate"");
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStart"");
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case REQUEST_THUMBNAIL:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""requestThumbnail"");
            handleRequestThumbnail((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""configChanged"");
            mCurDefaultDisplayDpi = ((Configuration) msg.obj).densityDpi;
            handleConfigurationChanged((Configuration) msg.obj, null);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""activityConfigChanged"");
            handleActivityConfigurationChanged((IBinder) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""sleeping"");
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""trimMemory"");
            handleTrimMemory(msg.arg1);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
238,<android.view.View: void invalidate(boolean)>,16,17,<android.view.View: void invalidate(boolean)>,<android.view.View: void invalidate(boolean)>,0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) || (mPrivateFlags & INVALIDATED) != INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~DRAWN;
        mPrivateFlags |= DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= INVALIDATED;
            mPrivateFlags &= ~DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~PFLAG_DRAWN;
        mPrivateFlags |= PFLAG_DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}",1,"/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
","/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constants (DRAWN, HAS_BOUNDS, DRAWING_CACHE_VALID, INVALIDATED, DIRTY) have been changed to (PFLAG_DRAWN, PFLAG_HAS_BOUNDS, PFLAG_DRAWING_CACHE_VALID, PFLAG_INVALIDATED, PFLAG_DIRTY), so the code change type is 4.","The change is essentially renaming the constants, and will not change the behavior of the method, or the returned variables, so no Compatibility Issue exists."
240,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,16,17,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,<android.view.SurfaceView: boolean gatherTransparentRegion(Region)>,0,"{
    if (mWindowType == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
        return super.gatherTransparentRegion(region);
    }
    boolean opaque = true;
    if ((mPrivateFlags & SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}","{
    if (mWindowType == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
        return super.gatherTransparentRegion(region);
    }
    boolean opaque = true;
    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == 0) {
        // this view draws, remove it from the transparent region
        opaque = super.gatherTransparentRegion(region);
    } else if (region != null) {
        int w = getWidth();
        int h = getHeight();
        if (w > 0 && h > 0) {
            getLocationInWindow(mLocation);
            // otherwise, punch a hole in the whole hierarchy
            int l = mLocation[0];
            int t = mLocation[1];
            region.op(l, t, l + w, t + h, Region.Op.UNION);
        }
    }
    if (PixelFormat.formatHasAlpha(mRequestedFormat)) {
        opaque = false;
    }
    return opaque;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There is a change in the value of the constant used in the if condition: from SKIP_DRAW to PFLAG_SKIP_DRAW. So, the type of change is 4 (Other statement change).","The changed condition might affect the execution path of the method and thus potentially return a different value (opaque) depending on the mPrivateFlags property of the object. Thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
241,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getStorageEncryption(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getStorageEncryption(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.getStorageEncryption(admin, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Called by an application that is administering the device to
 * determine the requested setting for secure storage.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,
 * this will return the requested encryption setting as an aggregate of all active
 * administrators.
 * @return true if the admin(s) are requesting encryption, false if not.
 */
","/**
 * Called by an application that is administering the device to
 * determine the requested setting for secure storage.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  If null,
 * this will return the requested encryption setting as an aggregate of all active
 * administrators.
 * @return true if the admin(s) are requesting encryption, false if not.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API changed from 'mService.getStorageEncryption(admin)' to 'mService.getStorageEncryption(admin, UserHandle.myUserId())'. So, the classification is 1,5.","The return statement could be different because the dependent API method's parameters have changed. Thus, a compatibility issue may exist due to potential different return values. So the CI type is 1."
242,<android.hardware.Camera.Parameters: String flatten()>,16,17,<android.hardware.Camera.Parameters: String flatten()>,<android.hardware.Camera.Parameters: String flatten()>,0,"{
    StringBuilder flattened = new StringBuilder();
    for (String k : mMap.keySet()) {
        flattened.append(k);
        flattened.append(""="");
        flattened.append(mMap.get(k));
        flattened.append("";"");
    }
    // chop off the extra semicolon at the end
    flattened.deleteCharAt(flattened.length() - 1);
    return flattened.toString();
}","{
    StringBuilder flattened = new StringBuilder(128);
    for (String k : mMap.keySet()) {
        flattened.append(k);
        flattened.append(""="");
        flattened.append(mMap.get(k));
        flattened.append("";"");
    }
    // chop off the extra semicolon at the end
    flattened.deleteCharAt(flattened.length() - 1);
    return flattened.toString();
}",1,"/**
 * Creates a single string with all the parameters set in
 * this Parameters object.
 * <p>The {@link #unflatten(String)} method does the reverse.</p>
 *
 * @return a String with all values from this Parameters object, in
 * semi-colon delimited key-value pairs
 */
","/**
 * Creates a single string with all the parameters set in
 * this Parameters object.
 * <p>The {@link #unflatten(String)} method does the reverse.</p>
 *
 * @return a String with all values from this Parameters object, in
 * semi-colon delimited key-value pairs
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is about initializing the StringBuilder's capacity to 128 during the object creation. Therefore, the code change type is 4.","Even though the initial capacity of StringBuilder has changed, it does not affect the behaviour of the method because the final returned string is the same. Therefore, there are no compatibility issues in this case, so the CI type is 0."
243,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,16,17,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,<android.view.View: void getWindowVisibleDisplayFrame(Rect)>,0,"{
    if (mAttachInfo != null) {
        try {
            mAttachInfo.mSession.getDisplayFrame(mAttachInfo.mWindow, outRect);
        } catch (RemoteException e) {
            return;
        }
        // XXX This is really broken, and probably all needs to be done
        // in the window manager, and we need to know more about whether
        // we want the area behind or in front of the IME.
        final Rect insets = mAttachInfo.mVisibleInsets;
        outRect.left += insets.left;
        outRect.top += insets.top;
        outRect.right -= insets.right;
        outRect.bottom -= insets.bottom;
        return;
    }
    Display d = WindowManagerImpl.getDefault().getDefaultDisplay();
    d.getRectSize(outRect);
}","{
    if (mAttachInfo != null) {
        try {
            mAttachInfo.mSession.getDisplayFrame(mAttachInfo.mWindow, outRect);
        } catch (RemoteException e) {
            return;
        }
        // XXX This is really broken, and probably all needs to be done
        // in the window manager, and we need to know more about whether
        // we want the area behind or in front of the IME.
        final Rect insets = mAttachInfo.mVisibleInsets;
        outRect.left += insets.left;
        outRect.top += insets.top;
        outRect.right -= insets.right;
        outRect.bottom -= insets.bottom;
        return;
    }
    // The view is not attached to a display so we don't have a context.
    // Make a best guess about the display size.
    Display d = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    d.getRectSize(outRect);
}",1,"/**
 * Retrieve the overall visible display size in which the window this view is
 * attached to has been positioned in.  This takes into account screen
 * decorations above the window, for both cases where the window itself
 * is being position inside of them or the window is being placed under
 * then and covered insets are used for the window to position its content
 * inside.  In effect, this tells you the available area where content can
 * be placed and remain visible to users.
 *
 * <p>This function requires an IPC back to the window manager to retrieve
 * the requested information, so should not be used in performance critical
 * code like drawing.
 *
 * @param outRect Filled in with the visible display frame.  If the view
 * is not attached to a window, this is simply the raw display size.
 */
","/**
 * Retrieve the overall visible display size in which the window this view is
 * attached to has been positioned in.  This takes into account screen
 * decorations above the window, for both cases where the window itself
 * is being position inside of them or the window is being placed under
 * then and covered insets are used for the window to position its content
 * inside.  In effect, this tells you the available area where content can
 * be placed and remain visible to users.
 *
 * <p>This function requires an IPC back to the window manager to retrieve
 * the requested information, so should not be used in performance critical
 * code like drawing.
 *
 * @param outRect Filled in with the visible display frame.  If the view
 * is not attached to a window, this is simply the raw display size.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The way to get the `Display` object has changed, and this is an instance of the class called `DisplayManagerGlobal` which is different from the earlier version `WindowManagerImpl`. This is a change in other statement (type 4) and dependent API (type 5).","As the change to the `Display` object could potentially create a change in the DisplayFrame, which directly affects the output of the `getWindowVisibleDisplayFrame(Rect)` method. This represents a Compatibility Issue caused by a potential different return value (type 1)."
245,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,16,17,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"Additional condition checking and assignment operation for 'userActivityTimeout' have been added in the late version, the code change type is 4 (Other statement changed).","The new condition and assignment brought by the code change could change the outcome of 'changes' which gets returned. It means the API can potentially return different values. Thus, the Compatibility Issue type is 1."
246,<android.view.WindowManager.LayoutParams: String toString()>,16,17,<android.view.WindowManager.LayoutParams: String toString()>,<android.view.WindowManager.LayoutParams: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    if (userActivityTimeout >= 0) {
        sb.append("" userActivityTimeout="").append(userActivityTimeout);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,A new sentence has been added at the end of the implementation: if (inputFeatures != 0) {...} Therefore the code change type is 1 (Return statement changed) and 4 (Other statement changed). ,"With an additional statement added in the new version, the returning string might be different between early and late versions, which can lead to a compatibility issue, therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
249,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,16,17,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,<android.os.StrictMode.ThreadPolicy.Builder: Builder permitCustomSlowCalls()>,0,"{
    return enable(DETECT_CUSTOM);
}","{
    return disable(DETECT_CUSTOM);
}",1,"/**
 * Enable detection of disk reads.
 */
","/**
 * Disable detection of slow calls.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method in the late version has changed from enable(DETECT_CUSTOM) to disable(DETECT_CUSTOM), which is another method and the parameter of the method remains the same. Therefore, the change type is 1,5.","Because the method called in the return statement has changed from enable to disable in the late version, it will make the API potentially return a different value, so the CI type is 1."
250,<android.webkit.BrowserFrame: void handleMessage(Message)>,16,17,<android.webkit.BrowserFrame: void handleMessage(Message)>,<android.webkit.BrowserFrame: void handleMessage(Message)>,0,"{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = WebViewDatabaseClassic.getInstance(mContext).getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}","{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.getScheme() + uri.getHost();
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}",1,"/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
","/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The method WebViewDatabaseClassic.getInstance(mContext).getUsernamePassword(schemePlusHost) in early implementation is replaced by mDatabase.getUsernamePassword(schemePlusHost) in the late implementation, but no control dependency is changed. Therefore, the code change types are 4,5.","The API call changes may lead to different return values of getUsernamePassword(schemePlusHost) and subsequently affect the behaviors of this method. Thus, the CI type is 1."
251,<android.widget.PopupWindow: void update()>,16,17,<android.widget.PopupWindow: void update()>,<android.widget.PopupWindow: void update()>,0,"{
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}","{
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = false;
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}",1,"/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.  This include:
 * {@link #setClippingEnabled(boolean)}, {@link #setFocusable(boolean)},
 * {@link #setIgnoreCheekPress()}, {@link #setInputMethodMode(int)},
 * {@link #setTouchable(boolean)}, and {@link #setAnimationStyle(int)}.
 */
","/**
 * Updates the state of the popup window, if it is currently being displayed,
 * from the currently set state.  This include:
 * {@link #setClippingEnabled(boolean)}, {@link #setFocusable(boolean)},
 * {@link #setIgnoreCheekPress()}, {@link #setInputMethodMode(int)},
 * {@link #setTouchable(boolean)}, and {@link #setAnimationStyle(int)}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `setLayoutDirectionFromAnchor()` is introduced in the late version. Therefore, the code change is classified as ""Other statement changed"" (category 4).",There are no Compatibility Issues because this addition does not change the return value or the exception handling of the method.
253,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNonLetter(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNonLetter(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumNonLetter(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of non-letter characters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumNonLetter(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
","/**
 * Retrieve the current number of non-letter characters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumNonLetter(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed as it is now calling a different API. Instead of calling mService.getPasswordMinimumNonLetter(admin) which is dependent on conditionals and an exception handling block, it's now calling getPasswordMinimumNonLetter(admin, UserHandle.myUserId()). This indicates a change in dependent APIs and return statements, hence the change type is 1,5.","The API in the late version is directly returning the values from a different method compared to the early version. Moreover, the introduction of new parameter to getPasswordMinimumNonLetter(), i.e., UserHandle.myUserId() could change the way return values are determined. This potentially leads to returning different results, leading to compatibility issues. Thus, the CI type is 1."
254,"<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>",16,17,"<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>","<android.hardware.LegacySensorManager.LmsFilter: float filter(long,float)>",0,"{
    float v = in;
    final float ns = 1.0f / 1000000000.0f;
    final float t = time * ns;
    float v1 = mV[mIndex];
    if ((v - v1) > 180) {
        v -= 360;
    } else if ((v1 - v) > 180) {
        v += 360;
    }
    /* Manage the circular buffer, we write the data twice spaced
             * by COUNT values, so that we don't have to copy the array
             * when it's full
             */
    mIndex++;
    if (mIndex >= COUNT * 2)
        mIndex = COUNT;
    mV[mIndex] = v;
    mT[mIndex] = t;
    mV[mIndex - COUNT] = v;
    mT[mIndex - COUNT] = t;
    float A, B, C, D, E;
    float a, b;
    int i;
    A = B = C = D = E = 0;
    for (i = 0; i < COUNT - 1; i++) {
        final int j = mIndex - 1 - i;
        final float Z = mV[j];
        final float T = 0.5f * (mT[j] + mT[j + 1]) - t;
        float dT = mT[j] - mT[j + 1];
        dT *= dT;
        A += Z * dT;
        B += T * (T * dT);
        C += (T * dT);
        D += Z * (T * dT);
        E += dT;
    }
    b = (A * B + C * D) / (E * B + C * C);
    a = (E * b - A) / C;
    float f = b + PREDICTION_TIME * a;
    // Normalize
    f *= (1.0f / 360.0f);
    if (((f >= 0) ? f : -f) >= 0.5f)
        f = f - (float) Math.ceil(f + 0.5f) + 1.0f;
    if (f < 0)
        f += 1.0f;
    f *= 360.0f;
    return f;
}","{
    float v = in;
    final float ns = 1.0f / 1000000000.0f;
    float v1 = mV[mIndex];
    if ((v - v1) > 180) {
        v -= 360;
    } else if ((v1 - v) > 180) {
        v += 360;
    }
    /* Manage the circular buffer, we write the data twice spaced
             * by COUNT values, so that we don't have to copy the array
             * when it's full
             */
    mIndex++;
    if (mIndex >= COUNT * 2)
        mIndex = COUNT;
    mV[mIndex] = v;
    mT[mIndex] = time;
    mV[mIndex - COUNT] = v;
    mT[mIndex - COUNT] = time;
    float A, B, C, D, E;
    float a, b;
    int i;
    A = B = C = D = E = 0;
    for (i = 0; i < COUNT - 1; i++) {
        final int j = mIndex - 1 - i;
        final float Z = mV[j];
        final float T = (mT[j] / 2 + mT[j + 1] / 2 - time) * ns;
        float dT = (mT[j] - mT[j + 1]) * ns;
        dT *= dT;
        A += Z * dT;
        B += T * (T * dT);
        C += (T * dT);
        D += Z * (T * dT);
        E += dT;
    }
    b = (A * B + C * D) / (E * B + C * C);
    a = (E * b - A) / C;
    float f = b + PREDICTION_TIME * a;
    // Normalize
    f *= (1.0f / 360.0f);
    if (((f >= 0) ? f : -f) >= 0.5f)
        f = f - (float) Math.ceil(f + 0.5f) + 1.0f;
    if (f < 0)
        f += 1.0f;
    f *= 360.0f;
    return f;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are several assignment statement changes, such as `float t = time * ns;` to `mT[mIndex] = time;`. Also, the condition and calculation inside `for` loop have changed, the control dependency has changed as well. Hence, change types are 3 and 4.","Due to changes in the assignment statements and the condition and calculation inside the control statement (for loop), the variables `A`, `B`, `C`, `D`, `E`, and `f` could have different values between two versions. This potentially leads to a difference in the return value. Hence, the CI type is 1."
255,<android.webkit.WebViewClassic: boolean canGoForward()>,16,17,<android.webkit.WebViewClassic: boolean canGoForward()>,<android.webkit.WebViewClassic: boolean canGoForward()>,0,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() < l.getSize() - 1;
        }
    }
}","{
    WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() < l.getSize() - 1;
        }
    }
}",1,"/**
 * See {@link WebView#canGoForward()}
 */
","/**
 * See {@link WebView#canGoForward()}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,0,"The type of 'l' has changed from WebBackForwardList to WebBackForwardListClassic in the late version, so the code change type is 5.","Although the type of 'l' was changed, the invoked method getBackForwardList(), getClearPending(), getCurrentIndex() and getSize() are still the same, also the return statements and exception handlings remain the same. Therefore, this change does not introduce a compatibility issue. The CI type is 0."
256,<android.bluetooth.BluetoothAdapter: int getState()>,16,17,<android.bluetooth.BluetoothAdapter: int getState()>,<android.bluetooth.BluetoothAdapter: int getState()>,0,"{
    try {
        return mService.getBluetoothState();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return STATE_OFF;
}","{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, """" + hashCode() + "": getState(). Returning "" + state);
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    if (DBG)
        Log.d(TAG, """" + hashCode() + "": getState() :  mService = null. Returning STATE_OFF"");
    return STATE_OFF;
}",1,"/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
","/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The code has added a new 'synchronized' block and a new 'if' condition check for 'mService != null' which is a control dependency change. Moreover, the method call 'mService.getBluetoothState()' has been changed to 'mService.getState()', which is another statement change, so the code change type is 3, 4.","With these changes, especially the addition of the 'if' statement and synchronization block, the method may potentially return a different value (depending on whether mService is 'null' or not, and whether return happens inside the synchronization block or not). Therefore, the CI type is 1."
258,"<android.widget.AbsListView: View obtainView(int,boolean[])>",16,17,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView != null) {
        return scrapView;
    }
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        child.setAccessibilityDelegate(mAccessibilityDelegate);
    }
    return child;
}","{
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView != null) {
        return scrapView;
    }
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change includes the addition of an if-statement (if (child.getAccessibilityDelegate() == null)). This checks whether the AccessibilityDelegate of the child is null or not before setting it, which does not belong to return statements, exception handling statements, control dependency statements or dependent API statements. Therefore, it falls into the category of other statement change (category 4).","This additional null-check on the AccessibilityDelegate before it is set does not change the potential behaviours of the API. The returned result (child) will not be affected and no additional exceptions are introduced. Therefore, no Compatibility Issue exists (category 0)."
259,<android.view.accessibility.AccessibilityManager: void interrupt()>,16,17,<android.view.accessibility.AccessibilityManager: void interrupt()>,<android.view.accessibility.AccessibilityManager: void interrupt()>,0,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    try {
        mService.interrupt();
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}","{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    try {
        mService.interrupt(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}",1,"/**
 * Requests feedback interruption from all accessibility services.
 */
","/**
 * Requests feedback interruption from all accessibility services.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method `mService.interrupt()` is changed to `mService.interrupt(mUserId)`, which means the dependent API has changed by adding parameter `mUserId`. Therefore, the code change type is 5.","The change in method does not modify return statements or exception handling, but by adding a new parameter to the called method, the behavior of the API may be altered, which could potentially return a different value. Thus, the CI type is 1."
262,<android.widget.ListView: void layoutChildren()>,16,17,<android.widget.ListView: void layoutChildren()>,<android.widget.ListView: void layoutChildren()>,0,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;
        View accessibilityFocusLayoutRestoreView = null;
        int accessibilityFocusPosition = INVALID_POSITION;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Remember which child, if any, had accessibility focus.
        final ViewRootImpl viewRootImpl = getViewRootImpl();
        if (viewRootImpl != null) {
            final View accessFocusedView = viewRootImpl.getAccessibilityFocusedHost();
            if (accessFocusedView != null) {
                final View accessFocusedChild = findAccessibilityFocusedChild(accessFocusedView);
                if (accessFocusedChild != null) {
                    if (!dataChanged || isDirectChildHeaderOrFooter(accessFocusedChild)) {
                        // If the views won't be changing, try to maintain
                        // focus on the current view host and (if
                        // applicable) its virtual view.
                        accessibilityFocusLayoutRestoreView = accessFocusedView;
                        accessibilityFocusLayoutRestoreNode = viewRootImpl.getAccessibilityFocusedVirtualView();
                    } else {
                        // Otherwise, try to maintain focus at the same
                        // position.
                        accessibilityFocusPosition = getPositionForView(accessFocusedChild);
                    }
                }
            }
        }
        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // Attempt to restore accessibility focus.
        if (accessibilityFocusLayoutRestoreNode != null) {
            accessibilityFocusLayoutRestoreNode.performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
        } else if (accessibilityFocusLayoutRestoreView != null) {
            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
        } else if (accessibilityFocusPosition != INVALID_POSITION) {
            // Bound the position within the visible children.
            final int position = MathUtils.constrain((accessibilityFocusPosition - mFirstPosition), 0, (getChildCount() - 1));
            final View restoreView = getChildAt(position);
            if (restoreView != null) {
                restoreView.requestAccessibilityFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        if (mPositionScrollAfterLayout != null) {
            post(mPositionScrollAfterLayout);
            mPositionScrollAfterLayout = null;
        }
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
264,<android.webkit.CallbackProxy: void handleMessage(Message)>,16,17,<android.webkit.CallbackProxy: void handleMessage(Message)>,<android.webkit.CallbackProxy: void handleMessage(Message)>,0,"{
    // 32-bit reads and writes.
    if (messagesBlocked())
        return;
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(), (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView.getWebView(), (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null) {
                mWebViewClient.onProceededAfterSslError(mWebView.getWebView(), (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedClientCertRequest(mWebView.getWebView(), (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView.getWebView(), mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(), (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(), msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView.getWebView());
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(), (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long quota = ((Long) map.get(""quota"")).longValue();
                long totalQuota = ((Long) map.get(""totalQuota"")).longValue();
                long estimatedDatabaseSize = ((Long) map.get(""estimatedDatabaseSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long requiredStorage = ((Long) map.get(""requiredStorage"")).longValue();
                long quota = ((Long) map.get(""quota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsPromptResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(), url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                receiver.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(), data.getCapture());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case SET_INSTALLABLE_WEBAPP:
            if (mWebChromeClient != null) {
                mWebChromeClient.setInstallableWebApp();
            }
            break;
        case NOTIFY_SEARCHBOX_LISTENERS:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                @SuppressWarnings(""unchecked"") List<String> suggestions = (List<String>) msg.obj;
                searchBox.handleSuggestions(msg.getData().getString(""query""), suggestions);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm, account, args);
                }
                break;
            }
        case SEARCHBOX_IS_SUPPORTED_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean supported = (Boolean) msg.obj;
                searchBox.handleIsSupportedCallback(supported);
                break;
            }
        case SEARCHBOX_DISPATCH_COMPLETE_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean success = (Boolean) msg.obj;
                searchBox.handleDispatchCompleteCallback(msg.getData().getString(""function""), msg.getData().getInt(""id""), success);
                break;
            }
    }
}","{
    // 32-bit reads and writes.
    if (messagesBlocked())
        return;
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView.getWebView(), startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView.getWebView(), finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView.getWebView(), (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView.getWebView(), (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView.getWebView(), reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView.getWebView(), dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView.getWebView(), handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView.getWebView(), (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                ((WebViewClientClassicExt) mWebViewClient).onProceededAfterSslError(mWebView.getWebView(), (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                ((WebViewClientClassicExt) mWebViewClient).onReceivedClientCertRequest(mWebView.getWebView(), (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView.getWebView(), mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView.getWebView(), (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView.getWebView(), (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                String referer = msg.getData().getString(""referer"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                if (mDownloadListener instanceof BrowserDownloadListener) {
                    ((BrowserDownloadListener) mDownloadListener).onDownloadStart(url, userAgent, contentDisposition, mimetype, referer, contentLength);
                } else {
                    mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
                }
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView.getWebView(), msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView.getWebView());
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow(((WebViewClassic) msg.obj).getWebView());
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView.getWebView(), (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long quota = ((Long) map.get(""quota"")).longValue();
                long totalQuota = ((Long) map.get(""totalQuota"")).longValue();
                long estimatedDatabaseSize = ((Long) map.get(""estimatedDatabaseSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, quota, estimatedDatabaseSize, totalQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long requiredStorage = ((Long) map.get(""requiredStorage"")).longValue();
                long quota = ((Long) map.get(""quota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(requiredStorage, quota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsPromptResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView.getWebView(), url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                receiver.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView.getWebView(), url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        receiver.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        @Override
                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                receiver.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResultReceiver receiver = (JsResultReceiver) msg.obj;
                final JsResult res = receiver.mJsResult;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                receiver.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView.getWebView(), msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType(), data.getCapture());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView.getWebView(), realm, account, args);
                }
                break;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
265,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",16,17,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, Display.DEFAULT_DISPLAY, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, 0, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
266,<android.webkit.WebSettings: void setTextSize(TextSize)>,16,17,<android.webkit.WebSettings: void setTextSize(TextSize)>,<android.webkit.WebSettings: void setTextSize(TextSize)>,0,"{
    throw new MustOverrideException();
}","{
    setTextZoom(t.value);
}",1,"/**
 * Sets the text size of the page.
 *
 * @param t the TextSize value for increasing or decreasing the text
 * @see WebSettings.TextSize
 * @deprecated Use {@link #setTextZoom(int)} instead.
 */
","/**
 * Sets the text size of the page. The default is {@link TextSize#NORMAL}.
 *
 * @param t the text size as a {@link TextSize} value
 * @deprecated Use {@link #setTextZoom} instead.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","In the early version, the method throws a 'MustOverrideException()', and there is no this statement in the later version. Instead, a new statement 'setTextZoom(t.value)' is added to the later version. Therefore, the code change types are 1(Return statement changed), 2(Exception handling statement changed), 4(Other statement changed).","In the early version, the method throws an exception no matter what, while in the later version, it runs a function`setTextZoom(t.value)`. This change of exception handling and return statement will lead to different behaviours of the same API. Therefore, the CI types are 1(Compatibility Issue caused by potential different return values or types) and 2(Compatibility Issue caused by potential different exception handlings)."
267,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,16,17,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
","/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The function 'setName(String)' is now wrapped with a 'synchronized' block under the condition 'if (mService != null)'. Meanwhile, the 'synchronized' block is newly added in the function. These are both control dependency and other statements, so change type is 3,4.","The modification preserves the behaviour of all previous return statements and does not create any new ones. Furthermore, the exception handling is consistent across both versions. Thus, there is no compatibility issue, and the CI type is 0."
268,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,16,17,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change occurs in the 'switch' control structure: A new case 'MSG_WINDOW_MOVED' has been added which does nothing. Thus, the code change type is 3 (Control dependency changed).","As the added case statement does nothing, it doesn't affect the behaviour of the function, thus no compatibility issues have raised. The CI type is 0 (No Compatibility Issue exist)."
271,<android.widget.FastScroller: void draw(Canvas)>,16,17,<android.widget.FastScroller: void draw(Canvas)>,<android.widget.FastScroller: void draw(Canvas)>,0,"{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_DEFAULT:
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_DEFAULT:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else if (mTrackDrawable != null) {
            mList.invalidate(viewWidth - mThumbW, 0, viewWidth, mList.getHeight());
        } else {
            mList.invalidate(viewWidth - mThumbW, y, viewWidth, y + mThumbH);
        }
    }
}","{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else if (mTrackDrawable != null) {
            mList.invalidate(viewWidth - mThumbW, 0, viewWidth, mList.getHeight());
        } else {
            mList.invalidate(viewWidth - mThumbW, y, viewWidth, y + mThumbH);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,The 'case' condition for 'View.SCROLLBAR_POSITION_DEFAULT' has been removed in the 'switch' statements in both 'mState == STATE_EXIT' and 'mState == STATE_DRAGGING' control structures for the 'mPosition' variable. This is a control dependency change.,"There is no compatibility issue because the removed 'case' was only related to the 'mPosition' variable and how it affects the 'left' variable, but this does not lead to different return values or altering exception handling between versions."
273,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,16,17,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (childrenCount != 0) {
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final View child = children[i];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = i;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (childrenCount != 0) {
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
274,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,16,17,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,<android.view.HardwareRenderer.Gl20Renderer: int[] getConfig(boolean)>,0,"{
    return new int[] { EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_STENCIL_SIZE, GLES20Canvas.getStencilSize(), EGL_SURFACE_TYPE, EGL_WINDOW_BIT | (dirtyRegions ? EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0), EGL_NONE };
}","{
    return new int[] { EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT, EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 0, EGL_CONFIG_CAVEAT, EGL_NONE, // TODO: Find a better way to choose the stencil size
    EGL_STENCIL_SIZE, mShowOverdraw ? GLES20Canvas.getStencilSize() : 0, EGL_SURFACE_TYPE, EGL_WINDOW_BIT | (dirtyRegions ? EGL14.EGL_SWAP_BEHAVIOR_PRESERVED_BIT : 0), EGL_NONE };
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"There are three changes: Firstly, the call to the EGL14 API has been added; Secondly, the logic of adding the stencil size changed (if there is an ""overdraw"", the stencil size is added, err not); Lastly, a new item (caveat of config) has been added into the returned array. Thus, the change type is 1,4,5.","The above mentioned three changes could make the return array different in the late version API, therefore, the CI type is 1."
275,"<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>",16,17,"<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>","<android.provider.Settings.System: boolean putConfiguration(ContentResolver,Configuration)>",0,"{
    return Settings.System.putFloat(cr, FONT_SCALE, config.fontScale);
}","{
    return putConfigurationForUser(cr, config, UserHandle.myUserId());
}",1,"/**
 * Convenience function to write a batch of configuration-related
 * settings from a {@link Configuration} object.
 *
 * @param cr The ContentResolver to access.
 * @param config The settings to write.
 * @return true if the values were set, false on database errors
 */
","/**
 * Convenience function to write a batch of configuration-related
 * settings from a {@link Configuration} object.
 *
 * @param cr The ContentResolver to access.
 * @param config The settings to write.
 * @return true if the values were set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from putFloat(cr, FONT_SCALE, config.fontScale) to putConfigurationForUser(cr, config, UserHandle.myUserId()), and the dependent API also changed, so the code change type is 1,5.","The change of return statement will result in a different return value, so the CI type is 1."
276,<android.os.Handler: boolean sendMessageAtFrontOfQueue(Message)>,16,17,<android.os.Handler: boolean sendMessageAtFrontOfQueue(Message)>,<android.os.Handler: boolean sendMessageAtFrontOfQueue(Message)>,0,"{
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, 0);
    } else {
        RuntimeException e = new RuntimeException(this + "" sendMessageAtTime() called with no mQueue"");
        Log.w(""Looper"", e.getMessage(), e);
    }
    return sent;
}","{
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(this + "" sendMessageAtTime() called with no mQueue"");
        Log.w(""Looper"", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, 0);
}",1,"/**
 * Enqueue a message at the front of the message queue, to be processed on
 * the next iteration of the message loop.  You will receive it in
 * {@link #handleMessage}, in the thread attached to this handler.
 * <b>This method is only for use in very special circumstances -- it
 * can easily starve the message queue, cause ordering problems, or have
 * other unexpected side-effects.</b>
 *
 * @return Returns true if the message was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 */
","/**
 * Enqueue a message at the front of the message queue, to be processed on
 * the next iteration of the message loop.  You will receive it in
 * {@link #handleMessage}, in the thread attached to this handler.
 * <b>This method is only for use in very special circumstances -- it
 * can easily starve the message queue, cause ordering problems, or have
 * other unexpected side-effects.</b>
 *
 * @return Returns true if the message was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3",1,"The value (boolean) assigned to 'sent' is deleted. Instead, a new return statement that directly returns a boolean value is added. Also, the variable sent is removed in the late version, and the condition statement has been reversed. As a result, the code change type is 1, 3.","The return statements have changed, and as a result, the API may return a different boolean value. Therefore, the CI type is 1."
280,"<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>",16,17,"<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>","<android.view.ViewGroup: boolean addViewInLayout(View,int,LayoutParams,boolean)>",0,"{
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~DIRTY_MASK) | DRAWN;
    return true;
}","{
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    return true;
}",1,"/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @param preventRequestLayout if true, calling this method will not trigger a
 * layout request on child
 * @return true if the child was added, false otherwise
 */
","/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @param preventRequestLayout if true, calling this method will not trigger a
 * layout request on child
 * @return true if the child was added, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable names DIRTY_MASK and DRAWN has changed to PFLAG_DIRTY_MASK and PFLAG_DRAWN, and these changes do not meet the condition of any sub-criteria directly. Therefore, the change type is 4.","The change in variable names in the code will not affect the expected outcome or the thrown exceptions of the API. Therefore, no Compatibility Issue (CI) exists, denoted as 0."
281,<android.view.View: void invalidate(Rect)>,16,17,<android.view.View: void invalidate(Rect)>,<android.view.View: void invalidate(Rect)>,0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED) {
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        mPrivateFlags |= PFLAG_INVALIDATED;
        mPrivateFlags |= PFLAG_DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}",1,"/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
","/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The code change is about the renaming of some constants. The constant names DRAWN, HAS_BOUNDS, DRAWING_CACHE_VALID, INVALIDATED, DIRTY are renamed to PFLAG_DRAWN, PFLAG_HAS_BOUNDS, PFLAG_DRAWING_CACHE_VALID, PFLAG_INVALIDATED, PFLAG_DIRTY respectively. It only affects the readability and does not alter the API's functional behavior. Therefore, the change type is 4.","Despite the change in constant name, the API's functional behavior remains the same (returning the same values and throwing the same exceptions as before). Hence, there is no Compatibility Issue (CI type is 0)."
282,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLength(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLength(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum allowed password length.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.  This
 * constraint is only imposed if the administrator has also requested either
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_ALPHABETIC}
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX}
 * with {@link #setPasswordQuality}.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length.  A value of 0
 * means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum allowed password length.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.  This
 * constraint is only imposed if the administrator has also requested either
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_ALPHABETIC}
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC}, or {@link #PASSWORD_QUALITY_COMPLEX}
 * with {@link #setPasswordQuality}.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param length The new desired minimum password length.  A value of 0
 * means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method call 'setPasswordMinimumLength(admin, length)' has been changed to 'setPasswordMinimumLength(admin, length, UserHandle.myUserId())', by adding an extra parameter. This change belongs to type 1 (Return statement changed) because it affects the operation this method is responsible for (even though it does not have a return statement), and type 5 (Dependent API changed) because it modifies the call to a dependent API `setPasswordMinimumLength`.","This change does not seem to cause a compatibility issue, because the adjustment is adding an extra parameter and the result of the operation (setting a password minimum length for a user) should remain the same, just with more precise user identification. Therefore, the CI type is 0 (No Compatibility Issue exists)."
283,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,16,17,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,<android.view.ViewRootImpl.ViewRootHandler: String getMessageName(Message)>,0,"{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_KEY:
            return ""MSG_DISPATCH_KEY"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_IME_FINISHED_EVENT:
            return ""MSG_IME_FINISHED_EVENT"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_INVALIDATE_DISPLAY_LIST:
            return ""MSG_INVALIDATE_DISPLAY_LIST"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
    }
    return super.getMessageName(message);
}","{
    switch(message.what) {
        case MSG_INVALIDATE:
            return ""MSG_INVALIDATE"";
        case MSG_INVALIDATE_RECT:
            return ""MSG_INVALIDATE_RECT"";
        case MSG_DIE:
            return ""MSG_DIE"";
        case MSG_RESIZED:
            return ""MSG_RESIZED"";
        case MSG_RESIZED_REPORT:
            return ""MSG_RESIZED_REPORT"";
        case MSG_WINDOW_FOCUS_CHANGED:
            return ""MSG_WINDOW_FOCUS_CHANGED"";
        case MSG_DISPATCH_KEY:
            return ""MSG_DISPATCH_KEY"";
        case MSG_DISPATCH_APP_VISIBILITY:
            return ""MSG_DISPATCH_APP_VISIBILITY"";
        case MSG_DISPATCH_GET_NEW_SURFACE:
            return ""MSG_DISPATCH_GET_NEW_SURFACE"";
        case MSG_IME_FINISHED_EVENT:
            return ""MSG_IME_FINISHED_EVENT"";
        case MSG_DISPATCH_KEY_FROM_IME:
            return ""MSG_DISPATCH_KEY_FROM_IME"";
        case MSG_FINISH_INPUT_CONNECTION:
            return ""MSG_FINISH_INPUT_CONNECTION"";
        case MSG_CHECK_FOCUS:
            return ""MSG_CHECK_FOCUS"";
        case MSG_CLOSE_SYSTEM_DIALOGS:
            return ""MSG_CLOSE_SYSTEM_DIALOGS"";
        case MSG_DISPATCH_DRAG_EVENT:
            return ""MSG_DISPATCH_DRAG_EVENT"";
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            return ""MSG_DISPATCH_DRAG_LOCATION_EVENT"";
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            return ""MSG_DISPATCH_SYSTEM_UI_VISIBILITY"";
        case MSG_UPDATE_CONFIGURATION:
            return ""MSG_UPDATE_CONFIGURATION"";
        case MSG_PROCESS_INPUT_EVENTS:
            return ""MSG_PROCESS_INPUT_EVENTS"";
        case MSG_DISPATCH_SCREEN_STATE:
            return ""MSG_DISPATCH_SCREEN_STATE"";
        case MSG_INVALIDATE_DISPLAY_LIST:
            return ""MSG_INVALIDATE_DISPLAY_LIST"";
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            return ""MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST"";
        case MSG_DISPATCH_DONE_ANIMATING:
            return ""MSG_DISPATCH_DONE_ANIMATING"";
        case MSG_WINDOW_MOVED:
            return ""MSG_WINDOW_MOVED"";
    }
    return super.getMessageName(message);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The switch statement inside the function has been modified by adding one more case ""MSG_WINDOW_MOVED"", which varies the control flow depending on the input. So the code change type is 1 and 3.","Because of the added case in the switch statement, for certain inputs (MSG_WINDOW_MOVED), the API will now return a different value, causing potential behavior difference. Thus, the CI type is 1."
284,<android.os.Environment: String getExternalStorageState()>,16,17,<android.os.Environment: String getExternalStorageState()>,<android.os.Environment: String getExternalStorageState()>,0,"{
    try {
        IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        return mountService.getVolumeState(getExternalStorageDirectory().toString());
    } catch (Exception rex) {
        return Environment.MEDIA_REMOVED;
    }
}","{
    try {
        IMountService mountService = IMountService.Stub.asInterface(ServiceManager.getService(""mount""));
        final StorageVolume primary = getPrimaryVolume();
        return mountService.getVolumeState(primary.getPath());
    } catch (RemoteException rex) {
        Log.w(TAG, ""Failed to read external storage state; assuming REMOVED: "" + rex);
        return Environment.MEDIA_REMOVED;
    }
}",1,"/**
 * Gets the current state of the primary ""external"" storage device.
 *
 * <p>See {@link #getExternalStorageDirectory()} for more information.
 */
","/**
 * Gets the current state of the primary ""external"" storage device.
 *
 * @see #getExternalStorageDirectory()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4",1,"The return statement has changed from 'getVolumeState(getExternalStorageDirectory().toString())' to 'getVolumeState(primary.getPath())' and 'getPrimaryVolume()' method is invoked instead. Also, the exception handling statement has changed, so the code change type is 1,2,4.","Upon change of the return statement and exception handling, there may be a potential different return values or exceptions, so the CI type is 1."
285,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,16,17,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getDevicesMatchingConnectionStates(int[])>,0,"{
    if (DBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getDevicesMatchingStates()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is only a variable name change from DBG to VDBG, which doesn't actually change the implementation, so the code change type is 0.","As there is only a variable name change and will not affect the execution of the API, thus, there is no Compatibility Issue and the CI type is 0."
287,<android.view.View: void draw(Canvas)>,16,17,<android.view.View: void draw(Canvas)>,<android.view.View: void draw(Canvas)>,0,"{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}","{
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBackground;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
288,<android.app.TaskStackBuilder: void startActivities(Bundle)>,16,17,<android.app.TaskStackBuilder: void startActivities(Bundle)>,<android.app.TaskStackBuilder: void startActivities(Bundle)>,0,"{
    if (mIntents.isEmpty()) {
        throw new IllegalStateException(""No intents added to TaskStackBuilder; cannot startActivities"");
    }
    Intent[] intents = mIntents.toArray(new Intent[mIntents.size()]);
    intents[0].addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
    mSourceContext.startActivities(intents, options);
}","{
    startActivities(options, new UserHandle(UserHandle.myUserId()));
}",1,"/**
 * Start the task stack constructed by this builder.
 *
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 */
","/**
 * Start the task stack constructed by this builder.
 *
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","The early implementation of the method has been completely replaced by a new method call, indicating that 4) other statements have been changed and 5) the dependent API has changed.","The original implementation has been totally replaced, and now, the return value and execution flow of this method are entirely controlled by the newly dependent method 'startActivities(options, new UserHandle(UserHandle.myUserId()))'. This change could potentially lead to different return values or types, making the Compatibility Issue type 1. Additionally, if the new method handles exceptions differently from the previous implementation, this can cause potential different exception handlings. Therefore, the Compatibility Issue type is 1,2."
289,<android.widget.TextView: float getRightFadingEdgeStrength()>,16,17,<android.widget.TextView: float getRightFadingEdgeStrength()>,<android.widget.TextView: float getRightFadingEdgeStrength()>,0,"{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            return (marquee.mMaxFadeScroll - marquee.mScroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}","{
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            final float maxFadeScroll = marquee.getMaxFadeScroll();
            final float scroll = marquee.getScroll();
            return (maxFadeScroll - scroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The variables marquee.mMaxFadeScroll and marquee.mScroll in the early version has been replaced with the methods marquee.getMaxFadeScroll() and marquee.getScroll() in the later version. Along with it, the method getResolvedLayoutDirection() has been changed to getLayoutDirection() in the late version. So the code change type is 4,5.","The replacement of variables with methods and modification of dependent API could potentially lead to the method returning different values, so the CI type is 1."
291,"<android.app.ApplicationPackageManager: void addPreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>",16,17,"<android.app.ApplicationPackageManager: void addPreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>","<android.app.ApplicationPackageManager: void addPreferredActivity(IntentFilter,int,ComponentName[],ComponentName)>",0,"{
    try {
        mPM.addPreferredActivity(filter, match, set, activity);
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.addPreferredActivity(filter, match, set, activity, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",0,"In the late version, a new parameter has been added to the mPM.addPreferredActivity method, which causes the change type is 1,5.","Although the implementation is changed, the method still returns no result, and will not output different exceptions. Therefore, the CI doesn't exist, so the CI type is 0."
292,"<android.view.View: void invalidate(int,int,int,int)>",16,17,"<android.view.View: void invalidate(int,int,int,int)>","<android.view.View: void invalidate(int,int,int,int)>",0,"{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}","{
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED) {
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        mPrivateFlags |= PFLAG_INVALIDATED;
        mPrivateFlags |= PFLAG_DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}",1,"/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
","/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some constant values have been renamed, such as DRAWN to PFLAG_DRAWN, without any change in semantics. The change type is 4.","Although variable names have been changed, they will not affect the behavior of the API and therefore no Compatibility Issue should be expected. The CI type is 0."
294,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,16,17,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,0,"{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}","{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}",1,"/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
","/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Two APIs, remoteViews.reapply() and remoteViews.apply(), have additional parameters in the late version (mOnClickHandler), thus they belong to dependent APIs. Their parameters type and number are changed, therefore, both the code change types are 4 and 5.","Though the code has changed, the the additional parameters in the dependent APIs do not influence the return values or exception handling, hence there is no compatibility issue."
295,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordQuality(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordQuality(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return PASSWORD_QUALITY_UNSPECIFIED;
}","{
    return getPasswordQuality(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current minimum password quality for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password quality for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statements have changed from using mService.getPasswordQuality(admin) and PASSWORD_QUALITY_UNSPECIFIED to getPasswordQuality(admin, UserHandle.myUserId()). Methods mService.getPasswordQuality() and getPasswordQuality() can be considered as dependent APIs because the first one is called via an object of another class and the second one is a method of the current class which could have undergone changes. Thereby, the change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
296,<android.provider.Settings.Secure: Uri getUriFor(String)>,16,17,<android.provider.Settings.Secure: Uri getUriFor(String)>,<android.provider.Settings.Secure: Uri getUriFor(String)>,0,"{
    return getUriFor(CONTENT_URI, name);
}","{
    if (MOVED_TO_GLOBAL.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.Secure"" + "" to android.provider.Settings.Global, returning global URI."");
        return Global.getUriFor(Global.CONTENT_URI, name);
    }
    return getUriFor(CONTENT_URI, name);
}",1,"/**
 * Construct the content URI for a particular name/value pair,
 * useful for monitoring changes with a ContentObserver.
 * @param name to look up in the table
 * @return the corresponding content URI, or null if not present
 */
","/**
 * Construct the content URI for a particular name/value pair,
 * useful for monitoring changes with a ContentObserver.
 * @param name to look up in the table
 * @return the corresponding content URI, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, new condition check `if (MOVED_TO_GLOBAL.contains(name))` is added. Also, under this new if condition there is a new statement logging warning message and a new return statement `return Global.getUriFor(Global.CONTENT_URI, name);`. Therefore, the code changes include control dependency change (3), different return statement(1), and other statement changed(4).","The method introduced new return statement under the new if condition. As a result, if name is in MOVED_TO_GLOBAL, now the method will return a different value compared to the early version. Therefore, this could cause potential compatibility issue due to the potential different return values or types (1)."
298,"<android.widget.RemoteViews: View apply(Context,ViewGroup)>",16,17,"<android.widget.RemoteViews: View apply(Context,ViewGroup)>","<android.widget.RemoteViews: View apply(Context,ViewGroup)>",0,"{
    return apply(context, parent, DEFAULT_ON_CLICK_HANDLER);
}","{
    return apply(context, parent, null);
}",1,"/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
","/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from apply(context, parent, DEFAULT_ON_CLICK_HANDLER) to apply(context, parent, null) and the parameter type of apply() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return different value in different version. As a result, the CI type is 1."
299,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,16,17,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,<android.bluetooth.BluetoothDevice: IBluetooth getService()>,0,"{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
            if (b == null) {
                throw new RuntimeException(""Bluetooth service not available"");
            }
            sService = IBluetooth.Stub.asInterface(b);
        }
    }
    return sService;
}","{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(mStateChangeCallback);
        }
    }
    return sService;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","In the early implementation, sService is assigned using the ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE) method and IBluetooth.Stub.asInterface(b) method. However, in the updated implementation, the sService is assigned with BluetoothAdapter.getDefaultAdapter() and adapter.getBluetoothService(mStateChangeCallback) methods, indicating changes in the return statement and the dependent API. Therefore, the code change types should be 1,5.","In the early version, the 'Bluetooth service not available' RuntimeException will be thrown when 'b' is null. But in the later version, this exception won't be thrown. Instead, a different method, adapter.getBluetoothService(mStateChangeCallback), is used to assign sService. This change could potentially lead to the API returning a different value and the exception handling has changed too. Therefore, the CI types are 1,2."
300,<android.webkit.CallbackProxy: void onProceededAfterSslError(SslError)>,16,17,<android.webkit.CallbackProxy: void onProceededAfterSslError(SslError)>,<android.webkit.CallbackProxy: void onProceededAfterSslError(SslError)>,0,"{
    if (mWebViewClient == null) {
        return;
    }
    Message msg = obtainMessage(PROCEEDED_AFTER_SSL_ERROR);
    msg.obj = error;
    sendMessage(msg);
}","{
    if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
        return;
    }
    Message msg = obtainMessage(PROCEEDED_AFTER_SSL_ERROR);
    msg.obj = error;
    sendMessage(msg);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The code has been changed within the initial 'if' statement condition. The condition for returning from the method has been extended to also check whether mWebViewClient is an instance of WebViewClientClassicExt, so the change type is 3 (Control dependency change).","The change in the control condition is likely to affect the behavior of the API as it can potentially lead to an early return in scenarios where mWebViewClient is not a instance of WebViewClientClassicExt. This means that the method might not always reach the code portion that sends the message, which it did in the early version. Thus, the Compatibility Issue type is 1 (Compatibility Issue caused by potential different return values or types)."
301,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,16,17,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,<android.provider.Settings.System: boolean getShowGTalkServiceStatus(ContentResolver)>,0,"{
    return getInt(cr, SHOW_GTALK_SERVICE_STATUS, 0) != 0;
}","{
    return getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId());
}",1,,"/**
 * @deprecated - Do not use
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from getInt(cr, SHOW_GTALK_SERVICE_STATUS, 0) != 0 to getShowGTalkServiceStatusForUser(cr, UserHandle.myUserId()). Also, the dependent API (getInt and getShowGTalkServiceStatusForUser) used is different. Hence, the change type is 1,5.","Due to the change in the return statement, the API could potentially return a different value, thus causing a compatibility issue. Therefore, the CI type is 1."
302,"<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>",16,17,"<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>","<android.widget.Editor.SuggestionsPopupWindow.SuggestionAdapter: View getView(int,View,ViewGroup)>",0,"{
    TextView textView = (TextView) convertView;
    if (textView == null) {
        textView = (TextView) mInflater.inflate(mTextView.mTextEditSuggestionItemLayout, parent, false);
    }
    final SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    textView.setText(suggestionInfo.text);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY) {
        textView.setCompoundDrawablesWithIntrinsicBounds(com.android.internal.R.drawable.ic_suggestions_add, 0, 0, 0);
    } else if (suggestionInfo.suggestionIndex == DELETE_TEXT) {
        textView.setCompoundDrawablesWithIntrinsicBounds(com.android.internal.R.drawable.ic_suggestions_delete, 0, 0, 0);
    } else {
        textView.setCompoundDrawables(null, null, null, null);
    }
    return textView;
}","{
    TextView textView = (TextView) convertView;
    if (textView == null) {
        textView = (TextView) mInflater.inflate(mTextView.mTextEditSuggestionItemLayout, parent, false);
    }
    final SuggestionInfo suggestionInfo = mSuggestionInfos[position];
    textView.setText(suggestionInfo.text);
    if (suggestionInfo.suggestionIndex == ADD_TO_DICTIONARY || suggestionInfo.suggestionIndex == DELETE_TEXT) {
        textView.setBackgroundColor(Color.TRANSPARENT);
    } else {
        textView.setBackgroundColor(Color.WHITE);
    }
    return textView;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the early implementation, the 'if' and 'else if' conditions manipulate the compound drawables of the TextView 'textView'. However, in the late implementation, the logic is changed to manipulate the background color of the TextView 'textView'. The changes are both at control dependency level and other statements level, hence the code change type is 3,4.","Given the changes in the code, the 'getView' API now potentially returns a textView with different aspects (background color instead of compound drawables) between the early version and the late version, hence the CI type is 1."
305,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,16,17,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchGenericPointerEvent(MotionEvent)>,0,"{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final View[] children = mChildren;
        final float x = event.getX();
        final float y = event.getY();
        for (int i = childrenCount - 1; i >= 0; i--) {
            final View child = children[i];
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                return true;
            }
        }
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}","{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final View[] children = mChildren;
        final float x = event.getX();
        final float y = event.getY();
        final boolean customOrder = isChildrenDrawingOrderEnabled();
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = children[childIndex];
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                return true;
            }
        }
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control statement 'for' has changed and new local variable 'customOrder' and 'childIndex' has been introduced and used, so code change type is 3 and 4.","Due the change in control flow structure (loop indexing has changed based on the condition: whether children's drawing order is enabled or not) can lead to potential different behaviours (different child may handle the event in different order), the CI type is 1."
306,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",16,17,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>","<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",0,"{
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, (where == TruncateAt.END_SMALL) ? ELLIPSIS_TWO_DOTS : ELLIPSIS_NORMAL);
}","{
    final String ellipsis = (where == TruncateAt.END_SMALL) ? Resources.getSystem().getString(R.string.ellipsis_two_dots) : Resources.getSystem().getString(R.string.ellipsis);
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, ellipsis);
}",1,"/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
","/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, with the parameters of `ellipsize` function being updated. More specifically, the last parameter value changed from a local variable (`ELLIPSIS_TWO_DOTS` or `ELLIPSIS_NORMAL`) to fetch the string resource from `Resources.getSystem().getString()`. This involves invoking a different API (`Resources.getSystem().getString()`), which leads to the change type being categorised as both 1 (return statement changed) and 5 (dependent API changed).","As the return value of the API changes with the modification in the `ellipsis` computation that now depends on a system resource, this could potentially result in different output compared to the older version, thus leading to a compatibility issue of type 1 (API potentially returns different values)."
307,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLetters(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLetters(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumLetters(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of letters required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumLetters(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
","/**
 * Retrieve the current number of letters required in the password for all
 * admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumLetters(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of letters required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The 'return' statement in Early Implementation has been replaced by a new 'return' statement in Late Implementation, which calls a different method 'getPasswordMinimumLetters'. This represents a change in dependent API and return statement, so the code change type is 1,5.","The change of return statement could make the API return a different value. A different method is being used in the return statement which might have different internal implementation and could lead to different outcomes, therefore we consider this a compatiblity issue of type 1."
308,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",16,17,"<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>","<android.app.ApplicationPackageManager: void setApplicationEnabledSetting(String,int,int)>",0,"{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setApplicationEnabledSetting(packageName, newState, flags, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API 'UserId.myUserId()' is changed to another dependent API 'mContext.getUserId()'. so the code change type is 1,5.","Since a different User ID might be returned from 'mContext.getUserId()' compared to 'UserId.myUserId()', the behaviour of 'mPM.setApplicationEnabledSetting()' can be different, providing a different output, hence the type of Compatibility Issue is 1."
309,"<android.app.ContextImpl: Context createPackageContext(String,int)>",16,17,"<android.app.ContextImpl: Context createPackageContext(String,int)>","<android.app.ContextImpl: Context createPackageContext(String,int)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        final ContextImpl context = new ContextImpl(mMainThread.getSystemContext());
        context.mBasePackageName = mBasePackageName;
        return context;
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources, mBasePackageName);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    return createPackageContextAsUser(packageName, flags, mUser != null ? mUser : Process.myUserHandle());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","In the implementation of the method, the whole body is changed. The statement `return createPackageContextAsUser(packageName, flags, mUser != null ? mUser : Process.myUserHandle())` is introduced in the late version, and the complete implementation is removed from the early version. Additionally, the dependent API `createPackageContextAsUser` is now being used, leading to the code change type being 1,4,5.","Due to the replacement of entire implementation, this change will cause not only the potential different return values or types, but also different exception handling. The exception `PackageManager.NameNotFoundException` is now not thrown in the late version. Consequently, the Compatibility Issue type is 1,2."
311,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,16,17,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    ContextImpl context = new ContextImpl();
    context.init(Resources.getSystem(), mainThread);
    return context;
}","{
    final ContextImpl context = new ContextImpl();
    context.init(Resources.getSystem(), mainThread, Process.myUserHandle());
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API init() in ContextImpl has changed its parameters, it adds an extra parameter: Process.myUserHandle(). Also, the return statement that relies on this dependent API also has changed. Therefore, the code change type is 1,5.","The change of the init() parameters means potential different behaviors of the ContextImpl object. Consequently, the return statement could return a context object with a different status, which means CI type 1."
312,"<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>","<android.app.admin.DevicePolicyManager: boolean hasGrantedPolicy(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            return mService.hasGrantedPolicy(admin, usesPolicy);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.hasGrantedPolicy(admin, usesPolicy, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Returns true if an administrator has been granted a particular device policy.  This can
 * be used to check if the administrator was activated under an earlier set of policies,
 * but requires additional policies after an upgrade.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  Must be
 * an active administrator, or an exception will be thrown.
 * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.
 */
","/**
 * Returns true if an administrator has been granted a particular device policy.  This can
 * be used to check if the administrator was activated under an earlier set of policies,
 * but requires additional policies after an upgrade.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.  Must be
 * an active administrator, or an exception will be thrown.
 * @param usesPolicy Which uses-policy to check, as defined in {@link DeviceAdminInfo}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling mService.hasGrantedPolicy() with two parameters to calling it with three parameters, resulting in a type 1 and 5 code change.","The mService.hasGrantedPolicy() calls between the versions have different parameters, potentially impacting the returned value. Hence, a type 1 Compatibility Issue is present."
314,"<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>",16,17,"<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>","<android.provider.Settings.Secure: boolean putFloat(ContentResolver,String,float)>",0,"{
    return putString(cr, name, Float.toString(value));
}","{
    return putFloatForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a
 * floating point number. This will either create a new entry in the
 * table if the given name does not exist, or modify the value of the
 * existing row with that name.  Note that internally setting values
 * are always stored as strings, so this function converts the given
 * value to a string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'putString(cr, name, Float.toString(value))' to 'putFloatForUser(cr, name, value, UserHandle.myUserId())', so the code change type is 1,5 since both the called function and its parameters are changed.","Due to the change in the return statement, the API could potentially return a different value, so the CI type is 1."
315,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",16,17,"<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>","<android.app.ApplicationPackageManager: ApplicationInfo getApplicationInfo(String,int)>",0,"{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}","{
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(packageName, flags, mContext.getUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(packageName);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The API implementation changed from using UserId.myUserId() to mContext.getUserId(), therefore, the change type is 5 (Dependent API changed).","Since the API change from UserId.myUserId() to mContext.getUserId(), this could potentially change the returned ApplicationInfo, thereby the type of CI is 1 (Compatibility Issue caused by potential different return values or types)."
318,<android.app.Activity: LoaderManager getLoaderManager()>,16,17,<android.app.Activity: LoaderManager getLoaderManager()>,<android.app.Activity: LoaderManager getLoaderManager()>,0,"{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = getLoaderManager(-1, mLoadersStarted, true);
    return mLoaderManager;
}","{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = getLoaderManager(null, mLoadersStarted, true);
    return mLoaderManager;
}",1,"/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
","/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getLoaderManager(-1, mLoadersStarted, true) to getLoaderManager(null, mLoadersStarted, true) and the dependent API getLoaderManager() has a change on the type of its first parameter, so the code change type is 1,5.","The dependent API getLoaderManager() has undergone changes. Specifically, the type of the first parameter has been changed. Thus the API potentially returns different variable, so the CI type is 1."
319,<android.view.View: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,16,17,<android.view.View: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,<android.view.View: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,0,"{
    if (mID != NO_ID) {
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i(""View"", ""Restoreing #"" + Integer.toHexString(mID)
            // + "": "" + state);
            mPrivateFlags &= ~SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags & SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(""Derived class did not call super.onRestoreInstanceState()"");
            }
        }
    }
}","{
    if (mID != NO_ID) {
        Parcelable state = container.get(mID);
        if (state != null) {
            // Log.i(""View"", ""Restoreing #"" + Integer.toHexString(mID)
            // + "": "" + state);
            mPrivateFlags &= ~PFLAG_SAVE_STATE_CALLED;
            onRestoreInstanceState(state);
            if ((mPrivateFlags & PFLAG_SAVE_STATE_CALLED) == 0) {
                throw new IllegalStateException(""Derived class did not call super.onRestoreInstanceState()"");
            }
        }
    }
}",1,"/**
 * Called by {@link #restoreHierarchyState(android.util.SparseArray)} to retrieve the
 * state for this view and its children. May be overridden to modify how restoring
 * happens to a view's children; for example, some views may want to not store state
 * for their children.
 *
 * @param container The SparseArray which holds previously saved state.
 *
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #onRestoreInstanceState(android.os.Parcelable)
 */
","/**
 * Called by {@link #restoreHierarchyState(android.util.SparseArray)} to retrieve the
 * state for this view and its children. May be overridden to modify how restoring
 * happens to a view's children; for example, some views may want to not store state
 * for their children.
 *
 * @param container The SparseArray which holds previously saved state.
 *
 * @see #dispatchSaveInstanceState(android.util.SparseArray)
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #onRestoreInstanceState(android.os.Parcelable)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A variable (mPrivateFlags) was changed in two spots, but this is considered as other statement change but none of 1-3. So the code change type is 4.","The change in mPrivateFlags statement doesn't affect the return value or the exception handling of the method. So, no compatibility issue exists. So the CI type is 0."
320,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",16,17,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>","<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (isColorDrawable) {
                    sPreloadedColorDrawables.put(key, cs);
                } else {
                    sPreloadedDrawables.put(key, cs);
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : (sPreloadedDensity == mConfiguration.densityDpi ? sPreloadedDrawables.get(key) : null);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (verifyPreloadConfig(value, ""drawable"")) {
                    if (isColorDrawable) {
                        sPreloadedColorDrawables.put(key, cs);
                    } else {
                        sPreloadedDrawables.put(key, cs);
                    }
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the late version, the assignment of 'key' changes according to the variable 'isColorDrawable'. Besides, the way to get 'cs' from 'sPreloadedDrawables' has added a conditional judgement 'sPreloadedDensity == mConfiguration.densityDpi'. In the code block 'if (mPreloading)', a new 'if' statement 'verifyPreloadConfig(value, ""drawable"")' is added. Therefore, the change type should be 3, 4.","Since the assignment of 'key' and the way to get 'cs' have both changed, the final return value 'dr' might be different between these two versions. Thus, the CI should be type 1."
321,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,<android.app.admin.DevicePolicyManager: boolean getCameraDisabled(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getCameraDisabled(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    return getCameraDisabled(admin, UserHandle.myUserId());
}",1,"/**
 * Determine whether or not the device's cameras have been disabled either by the current
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or null to check if any admins
 * have disabled the camera
 */
","/**
 * Determine whether or not the device's cameras have been disabled either by the current
 * admin, if specified, or all admins.
 * @param admin The name of the admin component to check, or null to check if any admins
 * have disabled the camera
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has been completely changed. The 'try - catch' block and 'if' condition statement have been removed, and the return statement was changed from mService.getCameraDisabled(admin) to getCameraDisabled(admin, UserHandle.myUserId()), indicating dependent API has changed. Thus, the change type is 1,5.","The entire logic of the method implementation has been altered. Therefore, there is a high probability that the return value of the updated method implementation is different from the previous implementation which potentially introduces compatibility issues. We hence classify it as type 1 CI."
322,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>","<android.app.admin.DevicePolicyManager: void setPasswordExpirationTimeout(ComponentName,long)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordExpirationTimeout(admin, timeout, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by a device admin to set the password expiration timeout. Calling this method
 * will restart the countdown for password expiration for the given admin, as will changing
 * the device password (for all admins).
 *
 * <p>The provided timeout is the time delta in ms and will be added to the current time.
 * For example, to have the password expire 5 days from now, timeout would be
 * 5 * 86400 * 1000 = 432000000 ms for timeout.
 *
 * <p>To disable password expiration, a value of 0 may be used for timeout.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
 * means there is no restriction (unlimited).
 */
","/**
 * Called by a device admin to set the password expiration timeout. Calling this method
 * will restart the countdown for password expiration for the given admin, as will changing
 * the device password (for all admins).
 *
 * <p>The provided timeout is the time delta in ms and will be added to the current time.
 * For example, to have the password expire 5 days from now, timeout would be
 * 5 * 86400 * 1000 = 432000000 ms for timeout.
 *
 * <p>To disable password expiration, a value of 0 may be used for timeout.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_EXPIRE_PASSWORD} to be able to call this
 * method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param timeout The limit (in ms) that a password can remain in effect. A value of 0
 * means there is no restriction (unlimited).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API setPasswordExpirationTimeout has added an extra argument which changes the method call from mService.setPasswordExpirationTimeout(admin, timeout) to mService.setPasswordExpirationTimeout(admin, timeout, UserHandle.myUserId()). Thus, the dependent API has changed as well as the return statement is potentially different due to this change in call. Hence, the code change type is 1,5.","The modification to the dependent API setPasswordExpirationTimeout means that the API could potentially exhibit different behavior by calling a different definite API function and returning different values. Hence, the Compatibility Issue type is 1."
323,<android.bluetooth.BluetoothAdapter: String getName()>,16,17,<android.bluetooth.BluetoothAdapter: String getName()>,<android.bluetooth.BluetoothAdapter: String getName()>,0,"{
    try {
        return mService.getName();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    try {
        return mManagerService.getName();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
","/**
 * Get the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The return statement centred on the dependent API 'mService.getName()' in the early version has changed to 'mManagerService.getName()' in the late version. This change can fall into the change types 1 and 5.,"The change of the dependent API could potentially lead to different return values, and this change would cause a Compatibility Issue of type 1."
324,<android.widget.Scroller: boolean computeScrollOffset()>,16,17,<android.widget.Scroller: boolean computeScrollOffset()>,<android.widget.Scroller: boolean computeScrollOffset()>,0,"{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                final float t_inf = (float) index / NB_SAMPLES;
                final float t_sup = (float) (index + 1) / NB_SAMPLES;
                final float d_inf = SPLINE[index];
                final float d_sup = SPLINE[index + 1];
                final float distanceCoef = d_inf + (t - t_inf) / (t_sup - t_inf) * (d_sup - d_inf);
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}","{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}",1,"/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
","/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Some variables calculation logic is updated in the FLING_MODE case under the switch statement. The variables obtain different values based on new calculations. Hence, the code change is classified as 4 (Other statement changed).","Despite changes in the calculation logic of some variables, these variables don't affect the final return value of the method or the exceptions that the method could throw. Therefore the change doesn't result in likely changes in API behavior, and thus no compatibility issue (0) is detected."
325,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,16,17,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,<android.app.Activity: NonConfigurationInstances retainNonConfigurationInstances()>,0,"{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // have nothing useful to retain.
        for (int i = mAllLoaderManagers.size() - 1; i >= 0; i--) {
            LoaderManagerImpl lm = mAllLoaderManagers.valueAt(i);
            if (lm.mRetaining) {
                retainLoaders = true;
            } else {
                lm.doDestroy();
                mAllLoaderManagers.removeAt(i);
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    return nci;
}","{
    Object activity = onRetainNonConfigurationInstance();
    HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
    ArrayList<Fragment> fragments = mFragments.retainNonConfig();
    boolean retainLoaders = false;
    if (mAllLoaderManagers != null) {
        // prune out any loader managers that were already stopped and so
        // have nothing useful to retain.
        LoaderManagerImpl[] loaders = new LoaderManagerImpl[mAllLoaderManagers.size()];
        mAllLoaderManagers.values().toArray(loaders);
        if (loaders != null) {
            for (int i = 0; i < loaders.length; i++) {
                LoaderManagerImpl lm = loaders[i];
                if (lm.mRetaining) {
                    retainLoaders = true;
                } else {
                    lm.doDestroy();
                    mAllLoaderManagers.remove(lm.mWho);
                }
            }
        }
    }
    if (activity == null && children == null && fragments == null && !retainLoaders) {
        return null;
    }
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity;
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = mAllLoaderManagers;
    return nci;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency ('for' loop structure) has been changed, where the way to iterate through the 'mAllLoaderManagers' is different between the two versions. Also, the array 'loaders' is introduced and the statement 'mAllLoaderManagers.removeAt(i)' is replaced by 'mAllLoaderManagers.remove(lm.mWho)'. Thus the change type is 3,4.","The change in the control dependency and other statements might lead to a different 'return' statement, because the 'NonConfigurationInstances' instance 'nci' that is returned at last may hold a different 'loaders'. Thus the CI type is 1."
329,"<android.os.Handler: boolean sendMessageAtTime(Message,long)>",16,17,"<android.os.Handler: boolean sendMessageAtTime(Message,long)>","<android.os.Handler: boolean sendMessageAtTime(Message,long)>",0,"{
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    } else {
        RuntimeException e = new RuntimeException(this + "" sendMessageAtTime() called with no mQueue"");
        Log.w(""Looper"", e.getMessage(), e);
    }
    return sent;
}","{
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(this + "" sendMessageAtTime() called with no mQueue"");
        Log.w(""Looper"", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}",1,"/**
 * Enqueue a message into the message queue after all pending messages
 * before the absolute time (in milliseconds) <var>uptimeMillis</var>.
 * <b>The time-base is {@link android.os.SystemClock#uptimeMillis}.</b>
 * You will receive it in {@link #handleMessage}, in the thread attached
 * to this handler.
 *
 * @param uptimeMillis The absolute time at which the message should be
 * delivered, using the
 * {@link android.os.SystemClock#uptimeMillis} time-base.
 *
 * @return Returns true if the message was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the message will be processed -- if
 * the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 */
","/**
 * Enqueue a message into the message queue after all pending messages
 * before the absolute time (in milliseconds) <var>uptimeMillis</var>.
 * <b>The time-base is {@link android.os.SystemClock#uptimeMillis}.</b>
 * You will receive it in {@link #handleMessage}, in the thread attached
 * to this handler.
 *
 * @param uptimeMillis The absolute time at which the message should be
 * delivered, using the
 * {@link android.os.SystemClock#uptimeMillis} time-base.
 *
 * @return Returns true if the message was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the message will be processed -- if
 * the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"The control dependency has changed since the condition in the 'if' statement reversed. Also, two different return points ""return sent"" and ""return false"" are introduced in the Late_Implementation replacing the ""return sent"" in the Early_Implementation. Hence, the change type is 3,1.","Since the control dependency changes and the return point has been moved under this condition, it can potentially return a different value therefore, the CI type is 1."
332,<android.bluetooth.BluetoothDevice: String getAddress()>,16,17,<android.bluetooth.BluetoothDevice: String getAddress()>,<android.bluetooth.BluetoothDevice: String getAddress()>,0,"{
    return mAddress;
}","{
    if (DBG)
        Log.d(TAG, ""mAddress: "" + mAddress);
    return mAddress;
}",1,"/**
 * Returns the hardware address of this BluetoothDevice.
 * <p> For example, ""00:11:22:AA:BB:CC"".
 * @return Bluetooth hardware address as string
 */
","/**
 * Returns the hardware address of this BluetoothDevice.
 * <p> For example, ""00:11:22:AA:BB:CC"".
 * @return Bluetooth hardware address as string
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are new statements 'if (DBG) Log.d(TAG, ""mAddress: "" + mAddress);' introduced in the late version. The newly added control (if) and output (Log) statements can be categorized into change types 3 and 4.","The change in the late version only adds a log output statement when DBG is true, which doesn’t affect the output variable (mAddress) or the exception. Thus, there is no compatibility issue, and the CI type is 0."
334,"<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>",16,17,"<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ServiceInfo getServiceInfo(ComponentName,int)>",0,"{
    try {
        ServiceInfo si = mPM.getServiceInfo(className, flags, UserId.myUserId());
        if (si != null) {
            return si;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ServiceInfo si = mPM.getServiceInfo(className, flags, mContext.getUserId());
        if (si != null) {
            return si;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call for UserID has changed from UserId.myUserId() to mContext.getUserId(), so the code change type is 1,5.","Since the method has changed from UserId.myUserId() to mContext.getUserId(), the return value of the method getServiceInfo() can potentially be different, causing compatibility issues under type 1."
335,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,16,17,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,<android.app.FragmentManagerImpl: void makeActive(Fragment)>,0,"{
    if (f.mIndex >= 0) {
        return;
    }
    if (mAvailIndices == null || mAvailIndices.size() <= 0) {
        if (mActive == null) {
            mActive = new ArrayList<Fragment>();
        }
        f.setIndex(mActive.size());
        mActive.add(f);
    } else {
        f.setIndex(mAvailIndices.remove(mAvailIndices.size() - 1));
        mActive.set(f.mIndex, f);
    }
    if (DEBUG)
        Log.v(TAG, ""Allocated fragment index "" + f);
}","{
    if (f.mIndex >= 0) {
        return;
    }
    if (mAvailIndices == null || mAvailIndices.size() <= 0) {
        if (mActive == null) {
            mActive = new ArrayList<Fragment>();
        }
        f.setIndex(mActive.size(), mParent);
        mActive.add(f);
    } else {
        f.setIndex(mAvailIndices.remove(mAvailIndices.size() - 1), mParent);
        mActive.set(f.mIndex, f);
    }
    if (DEBUG)
        Log.v(TAG, ""Allocated fragment index "" + f);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The dependent API setIndex() in the method makeActive(Fragment) has changed its parameters from one to two, so the code change type includes 4 and 5.","Although the dependent API setIndex() has added a new parameter, it does not affect the behavior of the method makeActive(Fragment) as it does not change the return statement nor the handling of exceptions. Thus, there is no type of CI, so the CI type is 0."
337,"<android.widget.AbsListView: void setItemChecked(int,boolean)>",16,17,"<android.widget.AbsListView: void setItemChecked(int,boolean)>","<android.widget.AbsListView: void setItemChecked(int,boolean)>",0,"{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        if (oldValue != value) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}","{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        if (mMultiChoiceModeCallback == null || !mMultiChoiceModeCallback.hasWrappedCallback()) {
            throw new IllegalStateException(""AbsListView: attempted to start selection mode "" + ""for CHOICE_MODE_MULTIPLE_MODAL but no choice mode callback was "" + ""supplied. Call setMultiChoiceModeListener to set a callback."");
        }
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        if (oldValue != value) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}",1,"/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
","/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A new throw exception statement is introduced in the late version and the if clause that checks the presence of the mMultiChoiceModeCallback instance before starting the action mode has changed as well. Hence, the code change type is 2,3.","The introduction of a new throw exception statement in the late version can lead to potentially different exception handling between the two versions. Hence, the CI type is 2."
338,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",16,17,"<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>","<android.content.res.Resources: ColorStateList loadColorStateList(TypedValue,int)>",0,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            sPreloadedColorStateLists.put(key, csl);
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            sPreloadedColorStateLists.put(key, csl);
        } else {
            synchronized (mTmpValue) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadColorStateList"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException(""Resource is not a ColorStateList (color or path): "" + value);
    }
    String file = value.string.toString();
    if (file.endsWith("".xml"")) {
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""colorstatelist"");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            NotFoundException rnf = new NotFoundException(""File "" + file + "" from color state list resource ID #0x"" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
    } else {
        throw new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id) + "": .xml extension required"");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value, ""color"")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mTmpValue) {
                // Log.i(TAG, ""Saving cached color state list @ #"" +
                // Integer.toHexString(key.intValue())
                // + "" in "" + this + "": "" + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"In the 'if (mPreloading)' block, the implementation has been updated to introduce a new dependency method 'verifyPreloadConfig(value, ""color"")' and replace a direct execution of 'sPreloadedColorStateLists.put(key, csl)' with a conditional execution. This corresponds to change type 3,5 (control dependency change, dependent API changed).","Though the internal implementation has changed, it won't affect the behavior of the API from an external perspective. Both versions return a ColorStateList in the same scenarios and deal with exceptions similarly. Therefore, there is no compatibility issue present."
340,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,16,17,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,<android.text.format.DateFormat: char[] getDateFormatOrder(Context)>,0,"{
    char[] order = new char[] { DATE, MONTH, YEAR };
    String value = getDateFormatString(context);
    int index = 0;
    boolean foundDate = false;
    boolean foundMonth = false;
    boolean foundYear = false;
    for (char c : value.toCharArray()) {
        if (!foundDate && (c == DATE)) {
            foundDate = true;
            order[index] = DATE;
            index++;
        }
        if (!foundMonth && (c == MONTH)) {
            foundMonth = true;
            order[index] = MONTH;
            index++;
        }
        if (!foundYear && (c == YEAR)) {
            foundYear = true;
            order[index] = YEAR;
            index++;
        }
    }
    return order;
}","{
    char[] order = new char[] { DATE, MONTH, YEAR };
    String value = getDateFormatString(context);
    int index = 0;
    boolean foundDate = false;
    boolean foundMonth = false;
    boolean foundYear = false;
    for (char c : value.toCharArray()) {
        if (!foundDate && (c == DATE)) {
            foundDate = true;
            order[index] = DATE;
            index++;
        }
        if (!foundMonth && (c == MONTH || c == STANDALONE_MONTH)) {
            foundMonth = true;
            order[index] = MONTH;
            index++;
        }
        if (!foundYear && (c == YEAR)) {
            foundYear = true;
            order[index] = YEAR;
            index++;
        }
    }
    return order;
}",1,"/**
 * Gets the current date format stored as a char array. The array will contain
 * 3 elements ({@link #DATE}, {@link #MONTH}, and {@link #YEAR}) in the order
 * specified by the user's format preference.  Note that this order is
 * only appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
","/**
 * Gets the current date format stored as a char array. The array will contain
 * 3 elements ({@link #DATE}, {@link #MONTH}, and {@link #YEAR}) in the order
 * specified by the user's format preference.  Note that this order is
 * only appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement under 'if' (line: second 'if' in for loop) has changed its control conditions, so the code change type is 3.","As the condition statement after 'if' has changed, the value of variable 'index' and the value at order[index] may vary from its early version. Which results in a potentially different returned value of 'order', so the CI type is 1."
341,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,16,17,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,<android.app.admin.DevicePolicyManager: List<ComponentName> getActiveAdmins()>,0,"{
    if (mService != null) {
        try {
            return mService.getActiveAdmins();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}","{
    if (mService != null) {
        try {
            return mService.getActiveAdmins(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return null;
}",1,"/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */
","/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"Return statement has changed from mService.getActiveAdmins() to mService.getActiveAdmins(UserHandle.myUserId()), and the parameter of getActiveAdmins() also changed. Therefore, the code change type is 1,5.","With the change in the return statement, the late version API could potentially return a different value than the early version. Thus the CI type is 1."
342,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,16,17,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,<android.bluetooth.BluetoothAdapter: boolean isEnabled()>,0,"{
    try {
        return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return true if the local adapter is turned on
 */
","/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return true if the local adapter is turned on
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,"The control dependency changed because a new 'synchronized' statement has been added, and a new 'if' statement has been introduced inside it, thus the code change types are 3 and 4.","Despite the changes in the code, they do not affect the return value or the handling of the exception. Therefore, the CI type is 0 which means No Compatibility Issue exist."
344,<android.view.Display: int getHeight()>,16,17,<android.view.Display: int getHeight()>,<android.view.Display: int getHeight()>,0,"{
    synchronized (mTmpPoint) {
        long now = SystemClock.uptimeMillis();
        if (now > (mLastGetTime + 20)) {
            getSizeInternal(mTmpPoint, true);
            mLastGetTime = now;
        }
        return mTmpPoint.y;
    }
}","{
    synchronized (this) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppHeightCompat;
    }
}",1,"/**
 * @deprecated Use {@link #getSize(Point)} instead.
 */
","/**
 * @deprecated Use {@link #getSize(Point)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The method implementation has completely changed. Some statements have been deleted while some new ones have been added. Specifically, the return statement has changed from returning mTmpPoint.y to mCachedAppHeightCompat. Also, the method getSizeInternal is not called anymore and it has been replaced by updateCachedAppSizeIfNeededLocked(). Hence, the change types are 1 and 4.","The change in the return statement makes the API potentially return a different value. Therefore, the type of compatibility issue is 1."
345,<android.view.ScaleGestureDetector: float getCurrentSpanY()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpanY()>,<android.view.ScaleGestureDetector: float getCurrentSpanY()>,0,"{
    return mCurrFingerDiffY;
}","{
    return mCurrSpanY;
}",1,"/**
 * Return the current y distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average Y distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is different between the two versions, from return mCurrFingerDiffY; in the early version to return mCurrSpanY; in the late version. So the code change type is 1.","Since the return type of the function has changed, it could potentially lead to a different returned value when the method is called. So, the Compatibility Issue type is 1."
348,<android.view.View: View findFocus()>,16,17,<android.view.View: View findFocus()>,<android.view.View: View findFocus()>,0,"{
    return (mPrivateFlags & FOCUSED) != 0 ? this : null;
}","{
    return (mPrivateFlags & PFLAG_FOCUSED) != 0 ? this : null;
}",1,"/**
 * Find the view in the hierarchy rooted at this view that currently has
 * focus.
 *
 * @return The view that currently has focus, or null if no focused view can
 * be found.
 */
","/**
 * Find the view in the hierarchy rooted at this view that currently has
 * focus.
 *
 * @return The view that currently has focus, or null if no focused view can
 * be found.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from checking 'FOCUSED' condition to checking 'PFLAG_FOCUSED' in the bit-wise operation. This means that dependent variable has changed from FOCUSED to PFLAG_FOCUSED. So the change type is 1,5.","The change in checking the condition in the return statement could lead to a different return value (between 'this' and 'null'), so the CI type is 1."
349,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,16,17,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,<android.server.search.SearchManagerService: ComponentName getWebSearchActivity()>,0,"{
    return getSearchables().getWebSearchActivity();
}","{
    return getSearchables(UserHandle.getCallingUserId()).getWebSearchActivity();
}",1,"/**
 * Gets the name of the web search activity.
 */
","/**
 * Gets the name of the web search activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API getSearchables() has changed, and the return statement has also changed with the alteration of parameter in the method getSearchables(UserHandle.getCallingUserId()). Therefore, the code change type is 1,5.","Because of the change in the return statement, it is possible that the API might return a different value or type. Therefore, the CI type is 1."
351,<android.view.View: void onRestoreInstanceState(Parcelable)>,16,17,<android.view.View: void onRestoreInstanceState(Parcelable)>,<android.view.View: void onRestoreInstanceState(Parcelable)>,0,"{
    mPrivateFlags |= SAVE_STATE_CALLED;
    if (state != BaseSavedState.EMPTY_STATE && state != null) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
}","{
    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;
    if (state != BaseSavedState.EMPTY_STATE && state != null) {
        throw new IllegalArgumentException(""Wrong state class, expecting View State but "" + ""received "" + state.getClass().toString() + "" instead. This usually happens "" + ""when two views of different type have the same id in the same hierarchy. "" + ""This view's id is "" + ViewDebug.resolveId(mContext, getId()) + "". Make sure "" + ""other views do not use the same id."");
    }
}",1,"/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
","/**
 * Hook allowing a view to re-apply a representation of its internal state that had previously
 * been generated by {@link #onSaveInstanceState}. This function will never be called with a
 * null state.
 *
 * @param state The frozen state that had previously been returned by
 * {@link #onSaveInstanceState}.
 *
 * @see #onSaveInstanceState()
 * @see #restoreHierarchyState(android.util.SparseArray)
 * @see #dispatchRestoreInstanceState(android.util.SparseArray)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the variable mPrivateFlags has changed from SAVE_STATE_CALLED to PFLAG_SAVE_STATE_CALLED, so the code change type is 4.","The variable name change does not impact the return values or exception handlings of the method, so no Compatibility Issue exists, hence the CI type is 0."
354,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>",16,17,"<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>","<android.webkit.HTML5VideoViewProxy.VideoPlayer: void play(String,int,HTML5VideoViewProxy,WebChromeClient,int)>",0,"{
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        // and play the video after prepared.
        if (mHTML5VideoView.isFullScreenMode() && !backFromFullScreenMode && currentVideoLayerId != videoLayerId && mCurrentProxy != proxy) {
            mCurrentProxy = proxy;
            mHTML5VideoView.setStartWhenPrepared(true);
            mHTML5VideoView.setVideoURI(url, proxy);
            mHTML5VideoView.reprepareData(proxy);
            return;
        }
    }
    if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || mHTML5VideoView.surfaceTextureDeleted()) {
        // inside the HTML5VideoView.
        if (mHTML5VideoView != null) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            mHTML5VideoView.reset();
        }
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
    } else if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}","{
    int currentVideoLayerId = -1;
    boolean backFromFullScreenMode = false;
    if (mHTML5VideoView != null) {
        currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
        backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
        // and play the video after prepared.
        if (mHTML5VideoView.isFullScreenMode() && !backFromFullScreenMode && currentVideoLayerId != videoLayerId && mCurrentProxy != proxy) {
            mCurrentProxy = proxy;
            mHTML5VideoView.setStartWhenPrepared(true);
            mHTML5VideoView.setVideoURI(url, proxy);
            mHTML5VideoView.reprepareData(proxy);
            return;
        }
    }
    boolean skipPrepare = false;
    boolean createInlineView = false;
    if (backFromFullScreenMode && currentVideoLayerId == videoLayerId && !mHTML5VideoView.isReleased()) {
        skipPrepare = true;
        createInlineView = true;
    } else if (backFromFullScreenMode || currentVideoLayerId != videoLayerId || HTML5VideoInline.surfaceTextureDeleted()) {
        // inside the HTML5VideoView.
        if (mHTML5VideoView != null) {
            if (!backFromFullScreenMode) {
                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
            }
            mHTML5VideoView.reset();
        }
        createInlineView = true;
    }
    if (createInlineView) {
        mCurrentProxy = proxy;
        mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, skipPrepare);
        mHTML5VideoView.setVideoURI(url, mCurrentProxy);
        mHTML5VideoView.prepareDataAndDisplayMode(proxy);
        return;
    }
    if (mCurrentProxy == proxy) {
        // Here, we handle the case when we keep playing with one video
        if (!mHTML5VideoView.isPlaying()) {
            mHTML5VideoView.seekTo(time);
            mHTML5VideoView.start();
        }
    } else if (mCurrentProxy != null) {
        // Some other video is already playing. Notify the caller that
        // its playback ended.
        proxy.dispatchOnEnded();
    }
}",1,"// still the same video by using videoLayerId and treat it differently.
","// still the same video by using videoLayerId and treat it differently.
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"In the late implementation, two new variables: ""skipPrepare"" and ""createInlineView"" have been added, and the conditions of 'if' and 'else if' statements have been updated. There is also a new parameter ""skipPrepare"" in the constructor of HTML5VideoInline has been added, and there is a new return statement. Thus, the code change type is 1,3,4,5.","This API could return at different points due to the change. In the early version, this method would not return in case of 'createInLineView', while in the updated version, it will return. Besides, the dependent API HTML5VideoInline has changed its constructor which may also cause different return values. So the CI type is 1."
357,<android.net.DhcpStateMachine.DefaultState: boolean processMessage(Message)>,16,17,<android.net.DhcpStateMachine.DefaultState: boolean processMessage(Message)>,<android.net.DhcpStateMachine.DefaultState: boolean processMessage(Message)>,0,"{
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_RENEW_DHCP:
            Log.e(TAG, ""Error! Failed to handle a DHCP renewal on "" + mInterfaceName);
            mDhcpRenewWakeLock.release();
            break;
        case SM_QUIT_CMD:
            mContext.unregisterReceiver(mBroadcastReceiver);
            // let parent kill the state machine
            return NOT_HANDLED;
        default:
            Log.e(TAG, ""Error! unhandled message  "" + message);
            break;
    }
    return HANDLED;
}","{
    if (DBG)
        Log.d(TAG, getName() + message.toString() + ""\n"");
    switch(message.what) {
        case CMD_RENEW_DHCP:
            Log.e(TAG, ""Error! Failed to handle a DHCP renewal on "" + mInterfaceName);
            mDhcpRenewWakeLock.release();
            break;
        default:
            Log.e(TAG, ""Error! unhandled message  "" + message);
            break;
    }
    return HANDLED;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,The case related to SM_QUIT_CMD in the switch control statement is removed. This means the control dependency has changed.,"Despite the case change, this does not lead to a compatibility issue because no change was made to the values or types returned by the API. Regardless of the input message, the return value is still 'HANDLED', and no new exceptions are thrown. Therefore, there is no compatibility issue."
358,<android.view.View: void setLayoutParams(LayoutParams)>,16,17,<android.view.View: void setLayoutParams(LayoutParams)>,<android.view.View: void setLayoutParams(LayoutParams)>,0,"{
    if (params == null) {
        throw new NullPointerException(""Layout parameters cannot be null"");
    }
    mLayoutParams = params;
    if (mParent instanceof ViewGroup) {
        ((ViewGroup) mParent).onSetLayoutParams(this, params);
    }
    requestLayout();
}","{
    if (params == null) {
        throw new NullPointerException(""Layout parameters cannot be null"");
    }
    mLayoutParams = params;
    resolveLayoutParams();
    if (mParent instanceof ViewGroup) {
        ((ViewGroup) mParent).onSetLayoutParams(this, params);
    }
    requestLayout();
}",1,"/**
 * Set the layout parameters associated with this view. These supply
 * parameters to the <i>parent</i> of this view specifying how it should be
 * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
 * correspond to the different subclasses of ViewGroup that are responsible
 * for arranging their children.
 *
 * @param params The layout parameters for this view, cannot be null
 */
","/**
 * Set the layout parameters associated with this view. These supply
 * parameters to the <i>parent</i> of this view specifying how it should be
 * arranged. There are many subclasses of ViewGroup.LayoutParams, and these
 * correspond to the different subclasses of ViewGroup that are responsible
 * for arranging their children.
 *
 * @param params The layout parameters for this view, cannot be null
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The new method 'resolveLayoutParams()' has been added in the newer version. This does not directly affect the input, control statements or return values of the function. Therefore, the code change type is 4 (Other statement changed).","Even though an additional method is introduced in the late version, it doesn't affect the behavior of the original function. The layout parameters are still set in the same manner and the flow control of the method does not change. So, there is no compatibility issue (CI type 0)."
360,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",16,17,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The dependent API ActivityManagerNative.getDefault().getIntentSender's parameter has changed with an additional UserHandle.myUserId() input, so the code change type is 5.","The return value depends on the target, which is derived from an API whose parameters have changed. Consequently, the value of the target might change which can lead to a differernt return, so the CI type is 1."
361,"<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>",16,17,"<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>","<android.app.ApplicationPackageManager: ResolveInfo resolveActivity(Intent,int)>",0,"{
    try {
        return mPM.resolveIntent(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return resolveActivityAsUser(intent, flags, mContext.getUserId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 5",1,"The return statements between the two version implementations are different as 'mPM.resolveIntent' is replaced with 'resolveActivityAsUser'. Also, note that the involved API being used in latter return statement is different from the previous which signifies a dependent API change. Therefore, the change type should be 1, 5.","The change of the return statement might cause the method to return different values between the two versions if 'resolveIntent' and 'resolveActivityAsUser' don't always return the same values for the same inputs. Therefore, the CI type is 1."
362,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumLength(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumLength(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumLength(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current minimum password length for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
","/**
 * Retrieve the current minimum password length for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version implementation includes a try-catch block which interacts with 'mService' and returns some values, however, the late version directly returns the result from `getPasswordMinimumLength(admin, UserHandle.myUserId())` function. So, the code change falls into categories 1 (Return statement changed), 4 (Other statement changed - introduction of 'UserHandle.myUserId()' and removal of the try-catch block), and 5 (Dependent API changed - the function 'getPasswordMinimumLength' now requires another parameter).","Since with the new implementation, the return value is now affected by 'UserHandle.myUserId()' and doesn't handle situations where 'mService' returns null or encounters 'RemoteException', this may lead to potentially different return values in the late version thus, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
363,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",16,17,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 5",1,"In the late version, a new method warnIfCallingFromSystemProcess() is invoked, which classified as type 3: control dependency changed. Additionally, the 'getUserId()' method replaces 'Binder.getOrigCallingUser()' in the method 'broadcastIntent', which is classified as type 5, dependent API changed.","The change in the method of 'broadcastIntent', specifically 'getUserId()' replacing 'Binder.getOrigCallingUser()' could potentially lead to different return values of the API, making the CI type 1, caused by potential different return values or types."
366,<android.view.ViewGroup: boolean dispatchKeyShortcutEvent(KeyEvent)>,16,17,<android.view.ViewGroup: boolean dispatchKeyShortcutEvent(KeyEvent)>,<android.view.ViewGroup: boolean dispatchKeyShortcutEvent(KeyEvent)>,0,"{
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        return super.dispatchKeyShortcutEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        return mFocused.dispatchKeyShortcutEvent(event);
    }
    return false;
}","{
    if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        return super.dispatchKeyShortcutEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) {
        return mFocused.dispatchKeyShortcutEvent(event);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,The variable used in 'if' condition has changed from 'FOCUSED' and 'HAS_BOUNDS' to 'PFLAG_FOCUSED' and 'PFLAG_HAS_BOUNDS'. The change type should be 3 for control dependency change and 5 for dependent API changed. ,"Due to the change in the condition variables, the API could possibly return different boolean values based on the condition check, so the CI type is 1."
367,<android.app.DownloadManager: Long getMaxBytesOverMobile(Context)>,16,17,<android.app.DownloadManager: Long getMaxBytesOverMobile(Context)>,<android.app.DownloadManager: Long getMaxBytesOverMobile(Context)>,0,"{
    try {
        return Settings.Secure.getLong(context.getContentResolver(), Settings.Secure.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
    } catch (SettingNotFoundException exc) {
        return null;
    }
}","{
    try {
        return Settings.Global.getLong(context.getContentResolver(), Settings.Global.DOWNLOAD_MAX_BYTES_OVER_MOBILE);
    } catch (SettingNotFoundException exc) {
        return null;
    }
}",1,"/**
 * Returns maximum size, in bytes, of downloads that may go over a mobile connection; or null if
 * there's no limit
 *
 * @param context the {@link Context} to use for accessing the {@link ContentResolver}
 * @return maximum size, in bytes, of downloads that may go over a mobile connection; or null if
 * there's no limit
 */
","/**
 * Returns maximum size, in bytes, of downloads that may go over a mobile connection; or null if
 * there's no limit
 *
 * @param context the {@link Context} to use for accessing the {@link ContentResolver}
 * @return maximum size, in bytes, of downloads that may go over a mobile connection; or null if
 * there's no limit
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the implementation has changed from ""Settings.Secure.getLong()"" to ""Settings.Global.getLong()"" and the parameters of the method have changed too, hence the change type is 1,5.","Since the method call in the return statement has changed, it can potentially return a different value in the later version API, leading to a CI of type 1."
368,"<android.webkit.WebViewClassic: void addJavascriptInterface(Object,String)>",16,17,"<android.webkit.WebViewClassic: void addJavascriptInterface(Object,String)>","<android.webkit.WebViewClassic: void addJavascriptInterface(Object,String)>",0,"{
    if (object == null) {
        return;
    }
    WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
    arg.mObject = object;
    arg.mInterfaceName = name;
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
}","{
    if (object == null) {
        return;
    }
    WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
    arg.mObject = object;
    arg.mInterfaceName = name;
    // methods that are accessible from JS.
    if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        arg.mRequireAnnotation = true;
    } else {
        arg.mRequireAnnotation = false;
    }
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
}",1,"/**
 * See {@link WebView#addJavascriptInterface(Object, String)}
 */
","/**
 * See {@link WebView#addJavascriptInterface(Object, String)}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"There are condition statements introduced in the late version but no change in the type of return value and exception handle. Therefore, only the logic of the code has changed. This means the code change type is 3 (Control dependency change).","Depending on the value of ""mContext.getApplicationInfo().targetSdkVersion"", the added new code section may affect the value of ""arg.mRequireAnnotation"", which in turn can affect the behavior and result of ""mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg)"". So the potential behaviour of the API may change and return a different value. Therefore, the compatibility issue type is 1."
370,<android.webkit.WebViewClassic: boolean canGoBackOrForward(int)>,16,17,<android.webkit.WebViewClassic: boolean canGoBackOrForward(int)>,<android.webkit.WebViewClassic: boolean canGoBackOrForward(int)>,0,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            int newIndex = l.getCurrentIndex() + steps;
            return newIndex >= 0 && newIndex < l.getSize();
        }
    }
}","{
    WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            int newIndex = l.getCurrentIndex() + steps;
            return newIndex >= 0 && newIndex < l.getSize();
        }
    }
}",1,"/**
 * See {@link WebView#canGoBackOrForward(int)}
 */
","/**
 * See {@link WebView#canGoBackOrForward(int)}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The type of the object 'l' is changed from 'WebBackForwardList' to 'WebBackForwardListClassic' (type change - API dependency change), and the function it invokes hasn't changed (object type change - other statement changed), so the code change types are 4,5.","The change of the object type won't lead to a different return value or different exceptions handling, since the dependency method it invokes remains unchanged. Thus no Compatibility Issue exists here, the CI type is 0."
371,<android.view.Surface: String toString()>,16,17,<android.view.Surface: String toString()>,<android.view.Surface: String toString()>,0,"{
    return ""Surface(name="" + mName + "", identity="" + getIdentity() + "")"";
}","{
    return ""Surface(name="" + mName + "", identity="" + nativeGetIdentity() + "")"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement from getIdentity() to nativeGetIdentity() has changed, and also the dependent API getIdentity() has been replaced with nativeGetIdentity() , so the change type is 1,5.","Changing the method from getIdentity() to nativeGetIdentity() may cause a different return value, thus leading to the CI type 1."
372,<android.widget.GridView: int computeVerticalScrollOffset()>,16,17,<android.widget.GridView: int computeVerticalScrollOffset()>,<android.widget.GridView: int computeVerticalScrollOffset()>,0,"{
    if (mFirstPosition >= 0 && getChildCount() > 0) {
        final View view = getChildAt(0);
        final int top = view.getTop();
        int height = view.getHeight();
        if (height > 0) {
            final int numColumns = mNumColumns;
            final int whichRow = mFirstPosition / numColumns;
            final int rowCount = (mItemCount + numColumns - 1) / numColumns;
            return Math.max(whichRow * 100 - (top * 100) / height + (int) ((float) mScrollY / getHeight() * rowCount * 100), 0);
        }
    }
    return 0;
}","{
    if (mFirstPosition >= 0 && getChildCount() > 0) {
        final View view = getChildAt(0);
        final int top = view.getTop();
        int height = view.getHeight();
        if (height > 0) {
            final int numColumns = mNumColumns;
            final int rowCount = (mItemCount + numColumns - 1) / numColumns;
            // In case of stackFromBottom the calculation of whichRow needs
            // to take into account that counting from the top the first row
            // might not be entirely filled.
            final int oddItemsOnFirstRow = isStackFromBottom() ? ((rowCount * numColumns) - mItemCount) : 0;
            final int whichRow = (mFirstPosition + oddItemsOnFirstRow) / numColumns;
            return Math.max(whichRow * 100 - (top * 100) / height + (int) ((float) mScrollY / getHeight() * rowCount * 100), 0);
        }
    }
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"A new statement ""final int oddItemsOnFirstRow = isStackFromBottom() ? ((rowCount * numColumns) - mItemCount) : 0;"" has been introduced and the calculation of 'whichRow' also changed, so the code change type is 3,4.","While 'whichRow' is calculated differently and may lead to a different value, and it impacts the final returned value. So the CI type is 1."
373,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>",16,17,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>","<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>",0,"{
    synchronized (this) {
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked();
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (returnDefault) {
            if (mWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context);
                return mDefaultWallpaper;
            } else {
                mDefaultWallpaper = null;
            }
        }
        return mWallpaper;
    }
}","{
    synchronized (this) {
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked(context);
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (returnDefault) {
            if (mWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context);
                return mDefaultWallpaper;
            } else {
                mDefaultWallpaper = null;
            }
        }
        return mWallpaper;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The assignment statement of 'mWallpaper' has changed with the calling of the method 'getCurrentWallpaperLocked' now taking a context as a parameter, so the code change is of type 1 and 5.","The change in the 'getCurrentWallpaperLocked' method call can potentially make the API return a different value and hence, the CI type is 1."
377,<android.app.Fragment: void setRetainInstance(boolean)>,16,17,<android.app.Fragment: void setRetainInstance(boolean)>,<android.app.Fragment: void setRetainInstance(boolean)>,0,"{
    mRetainInstance = retain;
}","{
    if (retain && mParentFragment != null) {
        throw new IllegalStateException(""Can't retain fragements that are nested in other fragments"");
    }
    mRetainInstance = retain;
}",1,"/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * <ul>
 * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * <li> {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>
 * still be called.
 * </ul>
 */
","/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * <ul>
 * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * <li> {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>
 * still be called.
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2, 3","1, 2","A conditional ('if') statement and an exception handling statement have been introduced in the late version, therefore the code change types are 2 (exception handling statement changed) and 3 (control dependency changed).","The exception handling change potentially makes the API throw a new exception, which didn't happen in the early version. Also, the new control dependency could result in a different behaviour because the variable 'mRetainInstance' might not be updated if the condition in the 'if' statement is fulfilled. Therefore, the Compatibility Issue (CI) types are 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
378,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,16,17,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,<android.bluetooth.BluetoothDevice: ParcelUuid[] getUuids()>,0,"{
    try {
        return sService.getRemoteUuids(mAddress);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get remote device Uuids"");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
","/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control dependency (if condition) and return statements have been added and the parameter of getRemoteUuids function has also been changed from ""mAddress"" to ""this"", so the change types are 1,3,4.","The newly added 'if' statement at the beginning could potentially change the behavior of the method (it might return null in cases where it wouldn't have in the early version). Moreover, the change of parameters passed to the function getRemoteUuids() could also lead to different return values. Therefore, the CI type is 1."
379,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,16,17,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,0,"{
    // service handling the specified intent.
    if (mRemoteAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}","{
    // service handling the specified intent.
    if (mRemoteAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteAdapter = new RemoteViewsAdapter(getContext(), intent, this);
    if (mRemoteAdapter.isDataReady()) {
        setAdapter(mRemoteAdapter);
    }
}",1,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"A new 'if' block has been added in the late version, and a new statement 'setAdapter(mRemoteAdapter)' has been introduced. Hence the change type is 4.","As a new statement is introduced, the behaviour of the method has been potentially altered. 'setAdapter(mRemoteAdapter)' could lead to an observable behavioural difference and hence a compatibility issue. The CI is hence of type 1 caused by potential different return values or types."
380,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumLetters(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumLetters(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of letters required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of letters required in the password. After setting this,
 * the user will not be able to enter a new password that is not at least as
 * restrictive as what has been set. Note that the current password will
 * remain until the user has set a new one, so the change does not take
 * place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API, setPasswordMinimumLetters, has changed. It accepts a new parameter now i.e., UserHandle.myUserId() and hence the change type is 5.","No Compatibility Issue (CI) exists since the new parameter added does not alter the behaviour of the API, the exceptions thrown or the return values."
381,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",16,17,"<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: void setCameraDisabled(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setCameraDisabled(admin, disabled, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to disable all cameras
 * on the device.  After setting this, no applications will be able to access any cameras
 * on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
","/**
 * Called by an application that is administering the device to disable all cameras
 * on the device.  After setting this, no applications will be able to access any cameras
 * on the device.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_DISABLE_CAMERA} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param disabled Whether or not the camera should be disabled.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The dependent method `setCameraDisabled` on object `mService`, has an additional parameter in the late version, so change types are 1 and 5.","Although there's a change in the dependent method being called, the return type of the API didn't change, and the Exception handling didn't change as well, hence no Compatibility Issue exists."
382,"<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>",16,17,"<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>","<android.provider.Settings.System: boolean putLong(ContentResolver,String,long)>",0,"{
    return putString(cr, name, Long.toString(value));
}","{
    return putLongForUser(cr, name, value, UserHandle.myUserId());
}",1,"/**
 * Convenience function for updating a single settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
","/**
 * Convenience function for updating a single settings value as a long
 * integer. This will either create a new entry in the table if the
 * given name does not exist, or modify the value of the existing row
 * with that name.  Note that internally setting values are always
 * stored as strings, so this function converts the given value to a
 * string before storing it.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to modify.
 * @param value The new value for the setting.
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement was changed from ""putString(cr, name, Long.toString(value))"" in the early version to ""putLongForUser(cr, name, value, UserHandle.myUserId())"" in the late version. Also, the dependent putString() method has been replaced by putLongForUser() method, indicating a change type of 1,5.","The change in the return statement may cause the API to return a different value in the late version than in the early version, causing a type 1 compatibility issue."
383,<android.view.ViewGroup: boolean dispatchKeyEventPreIme(KeyEvent)>,16,17,<android.view.ViewGroup: boolean dispatchKeyEventPreIme(KeyEvent)>,<android.view.ViewGroup: boolean dispatchKeyEventPreIme(KeyEvent)>,0,"{
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        return super.dispatchKeyEventPreIme(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        return mFocused.dispatchKeyEventPreIme(event);
    }
    return false;
}","{
    if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        return super.dispatchKeyEventPreIme(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) {
        return mFocused.dispatchKeyEventPreIme(event);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code changes are related to the renaming of constants used in the if conditions (FOCUSED -> PFLAG_FOCUSED, HAS_BOUNDS -> PFLAG_HAS_BOUNDS), so the code change type is 4.","Despite the name change of the constants, their functionality is the same and the returned values and exceptions thrown remain unchanged. Hence, there is no Compatibility Issue (CI type 0)."
385,<android.widget.AbsListView: Parcelable onSaveInstanceState()>,16,17,<android.widget.AbsListView: Parcelable onSaveInstanceState()>,<android.widget.AbsListView: Parcelable onSaveInstanceState()>,0,"{
    /*
         * This doesn't really make sense as the place to dismiss the
         * popups, but there don't seem to be any other useful hooks
         * that happen early enough to keep from getting complaints
         * about having leaked the window.
         */
    dismissPopup();
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    boolean haveChildren = getChildCount() > 0 && mItemCount > 0;
    long selectedId = getSelectedItemId();
    ss.selectedId = selectedId;
    ss.height = getHeight();
    if (selectedId >= 0) {
        // Remember the selection
        ss.viewTop = mSelectedTop;
        ss.position = getSelectedItemPosition();
        ss.firstId = INVALID_POSITION;
    } else {
        if (haveChildren && mFirstPosition > 0) {
            // Remember the position of the first child.
            // We only do this if we are not currently at the top of
            // the list, for two reasons:
            // (1) The list may be in the process of becoming empty, in
            // which case mItemCount may not be 0, but if we try to
            // ask for any information about position 0 we will crash.
            // (2) Being ""at the top"" seems like a special case, anyway,
            // and the user wouldn't expect to end up somewhere else when
            // they revisit the list even if its content has changed.
            View v = getChildAt(0);
            ss.viewTop = v.getTop();
            int firstPos = mFirstPosition;
            if (firstPos >= mItemCount) {
                firstPos = mItemCount - 1;
            }
            ss.position = firstPos;
            ss.firstId = mAdapter.getItemId(firstPos);
        } else {
            ss.viewTop = 0;
            ss.firstId = INVALID_POSITION;
            ss.position = 0;
        }
    }
    ss.filter = null;
    if (mFiltered) {
        final EditText textFilter = mTextFilter;
        if (textFilter != null) {
            Editable filterText = textFilter.getText();
            if (filterText != null) {
                ss.filter = filterText.toString();
            }
        }
    }
    ss.inActionMode = mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null;
    if (mCheckStates != null) {
        ss.checkState = mCheckStates.clone();
    }
    if (mCheckedIdStates != null) {
        final LongSparseArray<Integer> idState = new LongSparseArray<Integer>();
        final int count = mCheckedIdStates.size();
        for (int i = 0; i < count; i++) {
            idState.put(mCheckedIdStates.keyAt(i), mCheckedIdStates.valueAt(i));
        }
        ss.checkIdState = idState;
    }
    ss.checkedItemCount = mCheckedItemCount;
    return ss;
}","{
    /*
         * This doesn't really make sense as the place to dismiss the
         * popups, but there don't seem to be any other useful hooks
         * that happen early enough to keep from getting complaints
         * about having leaked the window.
         */
    dismissPopup();
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    if (mPendingSync != null) {
        // Just keep what we last restored.
        ss.selectedId = mPendingSync.selectedId;
        ss.firstId = mPendingSync.firstId;
        ss.viewTop = mPendingSync.viewTop;
        ss.position = mPendingSync.position;
        ss.height = mPendingSync.height;
        ss.filter = mPendingSync.filter;
        ss.inActionMode = mPendingSync.inActionMode;
        ss.checkedItemCount = mPendingSync.checkedItemCount;
        ss.checkState = mPendingSync.checkState;
        ss.checkIdState = mPendingSync.checkIdState;
        return ss;
    }
    boolean haveChildren = getChildCount() > 0 && mItemCount > 0;
    long selectedId = getSelectedItemId();
    ss.selectedId = selectedId;
    ss.height = getHeight();
    if (selectedId >= 0) {
        // Remember the selection
        ss.viewTop = mSelectedTop;
        ss.position = getSelectedItemPosition();
        ss.firstId = INVALID_POSITION;
    } else {
        if (haveChildren && mFirstPosition > 0) {
            // Remember the position of the first child.
            // We only do this if we are not currently at the top of
            // the list, for two reasons:
            // (1) The list may be in the process of becoming empty, in
            // which case mItemCount may not be 0, but if we try to
            // ask for any information about position 0 we will crash.
            // (2) Being ""at the top"" seems like a special case, anyway,
            // and the user wouldn't expect to end up somewhere else when
            // they revisit the list even if its content has changed.
            View v = getChildAt(0);
            ss.viewTop = v.getTop();
            int firstPos = mFirstPosition;
            if (firstPos >= mItemCount) {
                firstPos = mItemCount - 1;
            }
            ss.position = firstPos;
            ss.firstId = mAdapter.getItemId(firstPos);
        } else {
            ss.viewTop = 0;
            ss.firstId = INVALID_POSITION;
            ss.position = 0;
        }
    }
    ss.filter = null;
    if (mFiltered) {
        final EditText textFilter = mTextFilter;
        if (textFilter != null) {
            Editable filterText = textFilter.getText();
            if (filterText != null) {
                ss.filter = filterText.toString();
            }
        }
    }
    ss.inActionMode = mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null;
    if (mCheckStates != null) {
        ss.checkState = mCheckStates.clone();
    }
    if (mCheckedIdStates != null) {
        final LongSparseArray<Integer> idState = new LongSparseArray<Integer>();
        final int count = mCheckedIdStates.size();
        for (int i = 0; i < count; i++) {
            idState.put(mCheckedIdStates.keyAt(i), mCheckedIdStates.valueAt(i));
        }
        ss.checkIdState = idState;
    }
    ss.checkedItemCount = mCheckedItemCount;
    if (mRemoteAdapter != null) {
        mRemoteAdapter.saveRemoteViewsCache();
    }
    return ss;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The code change adds a condition for when 'mPendingSync != null' in early version which could change the return value of the method. Also, a new method 'saveRemoteViewsCache()' is called on 'mRemoteAdapter'. Thus the type of code change is 1,4.","The return type will potentially be different, based on the case where 'mPendingSync != null' due to introduced if condition, and this could lead to compatibility Issue. Therefore, the CI type is 1."
386,<android.bluetooth.BluetoothHealth: void close()>,16,17,<android.bluetooth.BluetoothHealth: void close()>,<android.bluetooth.BluetoothHealth: void close()>,0,"{
    mServiceListener = null;
}","{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, """", re);
            }
        }
    }
    mServiceListener = null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Several new code statements have been added in the late version, basically focusing on the 'close' function. There are no changes directly made at return, control dependency, exception handling, and dependent API, so the change type is 4.","These changes will not cause the API to return different variables nor throw different exceptions, so there is no compatibility issue, thus the CI type is 0."
388,<android.speech.tts.FileSynthesisCallback: int done()>,16,17,<android.speech.tts.FileSynthesisCallback: int done()>,<android.speech.tts.FileSynthesisCallback: int done()>,0,"{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFile.seek(0);
            int dataLength = (int) (mFile.length() - WAV_HEADER_LENGTH);
            mFile.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFileAndWidenPermissions();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG)
        Log.d(TAG, ""FileSynthesisRequest.done()"");
    synchronized (mStateLock) {
        if (mDone) {
            if (DBG)
                Log.d(TAG, ""Duplicate call to done()"");
            // we'd return ERROR because mFile == null and we'd add to logspam.
            return TextToSpeech.ERROR;
        }
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile == null) {
            Log.e(TAG, ""File not open"");
            return TextToSpeech.ERROR;
        }
        try {
            // Write WAV header at start of file
            mFile.seek(0);
            int dataLength = (int) (mFile.length() - WAV_HEADER_LENGTH);
            mFile.write(makeWavHeader(mSampleRateInHz, mAudioFormat, mChannelCount, dataLength));
            closeFileAndWidenPermissions();
            mDone = true;
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to write to "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The conditional statement ""if (mDone)"" has been added and the ""if (mStopped)"" statement has been moved, so the change type is 3.","Due to the addition of a new condition ""mDone"", the return statement could be affected and return a different value in the late version. Therefore, the CI type is 1."
389,<android.view.Surface: void finalize()>,16,17,<android.view.Surface: void finalize()>,<android.view.Surface: void finalize()>,0,"{
    try {
        super.finalize();
    } finally {
        if (mNativeSurface != 0 || mSurfaceControl != 0) {
            if (DEBUG_RELEASE) {
                Log.w(LOG_TAG, ""Surface.finalize() has work. You should have called release() ("" + mNativeSurface + "", "" + mSurfaceControl + "")"", mCreationStack);
            } else {
                Log.w(LOG_TAG, ""Surface.finalize() has work. You should have called release() ("" + mNativeSurface + "", "" + mSurfaceControl + "")"");
            }
        }
        release();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        nativeRelease();
    } finally {
        super.finalize();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",2,"In the Late_Implementation, 'finalize()' method now includes a condition statement ""if (mCloseGuard != null)"" and a new invocation ""mCloseGuard.warnIfOpen()""; Also, the method ""nativeRelease()"" has been introduced; Meanwhile, the sequence of the method ""super.finalize()"" and the 'finally' block changed. Therefore, the change types are 1,3,4.","The warning messages previously logged in the 'finally' block in the Early_Implementation are not anymore in the Late_Implementation; also, the method 'mCloseGuard.warnIfOpen()' could throw an exception if 'mCloseGuard' is not open, which is different from Early_Implementation. Hence, there is a compatibility issue due to potential exception handling change, the CI type is 2."
390,<android.view.ScaleGestureDetector: long getEventTime()>,16,17,<android.view.ScaleGestureDetector: long getEventTime()>,<android.view.ScaleGestureDetector: long getEventTime()>,0,"{
    return mCurrEvent.getEventTime();
}","{
    return mCurrTime;
}",1,"/**
 * Return the event time of the current event being processed.
 *
 * @return Current event time in milliseconds.
 */
","/**
 * Return the event time of the current event being processed.
 *
 * @return Current event time in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The returned value in the late version is different from the early version (from mCurrEvent.getEventTime() to mCurrTime), so the code change type is 1.","As the returned value has changed, it will potentially make the API return a different value, so the CI type is 1."
392,<android.app.LauncherActivity: List<ListItem> makeListItems()>,16,17,<android.app.LauncherActivity: List<ListItem> makeListItems()>,<android.app.LauncherActivity: List<ListItem> makeListItems()>,0,"{
    // Load all matching activities and sort correctly
    List<ResolveInfo> list = onQueryPackageManager(mIntent);
    Collections.sort(list, new ResolveInfo.DisplayNameComparator(mPackageManager));
    ArrayList<ListItem> result = new ArrayList<ListItem>(list.size());
    int listSize = list.size();
    for (int i = 0; i < listSize; i++) {
        ResolveInfo resolveInfo = list.get(i);
        result.add(new ListItem(mPackageManager, resolveInfo, null));
    }
    return result;
}","{
    // Load all matching activities and sort correctly
    List<ResolveInfo> list = onQueryPackageManager(mIntent);
    onSortResultList(list);
    ArrayList<ListItem> result = new ArrayList<ListItem>(list.size());
    int listSize = list.size();
    for (int i = 0; i < listSize; i++) {
        ResolveInfo resolveInfo = list.get(i);
        result.add(new ListItem(mPackageManager, resolveInfo, null));
    }
    return result;
}",1,"/**
 * Perform the query to determine which results to show and return a list of them.
 */
","/**
 * Perform the query to determine which results to show and return a list of them.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The sorting implementation has changed from directly calling Collections.sort() in the early version to calling method onSortResultList() in the late version. Therefore, the code change type is 4,5.","The change in sorting could lead to different orders of the resulting list which results in different return values. Thus, the CI type is 1."
394,<android.app.Fragment: void performDestroyView()>,16,17,<android.app.Fragment: void performDestroyView()>,<android.app.Fragment: void performDestroyView()>,0,"{
    onDestroyView();
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onDestroyView()"");
    }
    if (mLoaderManager != null) {
        mLoaderManager.doReportNextStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","In the late version, an exception handling statement (throw new SuperNotCalledException(...)) is added, and also control and other new statements are introduced. So the code change categories are 2,3,4.","The newly added code in the late version introduces a new exception throw, which could potentially lead to change in the behaviour leading to CI. Also, the new control statements mChildFragmentManager.dispatchDestroyView() and mCalled = false introduce a potential different return. Therefore, both of the types of CI (type 1 and type 2) exist."
396,"<android.provider.Settings.System: int getInt(ContentResolver,String,int)>",16,17,"<android.provider.Settings.System: int getInt(ContentResolver,String,int)>","<android.provider.Settings.System: int getInt(ContentResolver,String,int)>",0,"{
    String v = getString(cr, name);
    try {
        return v != null ? Integer.parseInt(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    return getIntForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The early version of the code obtains the string of the name and attempts to parse it into an integer, returning the provided default value if it is null or if a number format exception is caught. The late version, however, directly calls the method getIntForUser(). Thus, the change type includes 1 (Return statement changed) and 5 (Dependent API changed).","Because the method calls in the return statement are completely different between the two versions, the returned values can be different based on the implementation of the Dependent API in the late version. Consequently, this qualifies as a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
397,<android.content.res.Configuration: int hashCode()>,16,17,<android.content.res.Configuration: int hashCode()>,<android.content.res.Configuration: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + (locale != null ? locale.hashCode() : 0);
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    return result;
}","{
    int result = 17;
    result = 31 * result + Float.floatToIntBits(fontScale);
    result = 31 * result + mcc;
    result = 31 * result + mnc;
    result = 31 * result + (locale != null ? locale.hashCode() : 0);
    result = 31 * result + touchscreen;
    result = 31 * result + keyboard;
    result = 31 * result + keyboardHidden;
    result = 31 * result + hardKeyboardHidden;
    result = 31 * result + navigation;
    result = 31 * result + navigationHidden;
    result = 31 * result + orientation;
    result = 31 * result + screenLayout;
    result = 31 * result + uiMode;
    result = 31 * result + screenWidthDp;
    result = 31 * result + screenHeightDp;
    result = 31 * result + smallestScreenWidthDp;
    result = 31 * result + densityDpi;
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"A new statement ""result = 31 * result + densityDpi;"" is added in the late version which affects the return value of the implementation, so the code change type is 1.","Due to the addition of the new statement, the returned value of the hashCode function will potentially be different between the two versions and as such, the CI type is 1."
398,<android.os.storage.StorageManager: String getMountedObbPath(String)>,16,17,<android.os.storage.StorageManager: String getMountedObbPath(String)>,<android.os.storage.StorageManager: String getMountedObbPath(String)>,0,"{
    if (filename == null) {
        throw new IllegalArgumentException(""filename cannot be null"");
    }
    try {
        return mMountService.getMountedObbPath(filename);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to find mounted path for OBB"", e);
    }
    return null;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    try {
        return mMountService.getMountedObbPath(rawPath);
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to find mounted path for OBB"", e);
    }
    return null;
}",1,"/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param filename path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
","/**
 * Check the mounted path of an Opaque Binary Blob (OBB) file. This will
 * give you the path to where you can obtain access to the internals of the
 * OBB.
 *
 * @param rawPath path to OBB image
 * @return absolute path to mounted OBB image data or <code>null</code> if
 * not mounted or exception encountered trying to read status
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The early version of the API throws IllegalArgumentException when the filename is null, but the late version has different handling as it now throws NullPointerException if rawPath is null. Additionally, the parameter name for the method mMountService.getMountedObbPath() has changed from 'filename' to 'rawPath'. Hence the code change type is 1,4.","The change in the exception handling and in the method parameter means that the API can potentially return different values (either as an exception or the result from the method), so the CI type is 1."
399,<android.os.storage.IMountService.Stub.Proxy: boolean isObbMounted(String)>,16,17,<android.os.storage.IMountService.Stub.Proxy: boolean isObbMounted(String)>,<android.os.storage.IMountService.Stub.Proxy: boolean isObbMounted(String)>,0,"{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    boolean _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(filename);
        mRemote.transact(Stub.TRANSACTION_isObbMounted, _data, _reply, 0);
        _reply.readException();
        _result = 0 != _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}","{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    boolean _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(rawPath);
        mRemote.transact(Stub.TRANSACTION_isObbMounted, _data, _reply, 0);
        _reply.readException();
        _result = 0 != _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}",1,"/**
 * Checks whether the specified Opaque Binary Blob (OBB) is mounted
 * somewhere.
 */
","/**
 * Checks whether the specified Opaque Binary Blob (OBB) is mounted
 * somewhere.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name that is used as a parameter in `_data.writeString` function has changed from 'filename' to 'rawPath', but it does not affect the results returned by the API, so the change type is 4.","The change is regarding the change of variable name only. It doesn't change the functional behavior of the method, so no Compatibility Issues exist."
400,<android.widget.Gallery: void trackMotionScroll(int)>,16,17,<android.widget.Gallery: void trackMotionScroll(int)>,<android.widget.Gallery: void trackMotionScroll(int)>,0,"{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
    invalidate();
}","{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    final View selChild = mSelectedChild;
    if (selChild != null) {
        final int childLeft = selChild.getLeft();
        final int childCenter = selChild.getWidth() / 2;
        final int galleryCenter = getWidth() / 2;
        mSelectedCenterOffset = childLeft + childCenter - galleryCenter;
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
    invalidate();
}",1,"/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
","/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, a new block of code has been added that alters the value of mSelectedCenterOffset, which is not part of a conditional, control, return or exception handling statement and does not call into another API. Hence, the change type is 4.","The modification to mSelectedCenterOffset does not affect the potential return value or the exception handling of the API as mSelectedCenterOffset is not utilized in a return statement or in any exception handling code. Therefore, there is no compatibility issue and the CI type is 0."
401,<android.view.View: void onDrawScrollBars(Canvas)>,16,17,<android.view.View: void onDrawScrollBars(Canvas)>,<android.view.View: void onDrawScrollBars(Canvas)>,0,"{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left, top, right, bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                switch(mVerticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_DEFAULT:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}","{
    // scrollbars are drawn only when the animation is running
    final ScrollabilityCache cache = mScrollCache;
    if (cache != null) {
        int state = cache.state;
        if (state == ScrollabilityCache.OFF) {
            return;
        }
        boolean invalidate = false;
        if (state == ScrollabilityCache.FADING) {
            // We're fading -- get our fade interpolation
            if (cache.interpolatorValues == null) {
                cache.interpolatorValues = new float[1];
            }
            float[] values = cache.interpolatorValues;
            // Stops the animation if we're done
            if (cache.scrollBarInterpolator.timeToValues(values) == Interpolator.Result.FREEZE_END) {
                cache.state = ScrollabilityCache.OFF;
            } else {
                cache.scrollBar.setAlpha(Math.round(values[0]));
            }
            // This will make the scroll bars inval themselves after
            // drawing. We only want this when we're fading so that
            // we prevent excessive redraws
            invalidate = true;
        } else {
            // We're just on -- but we may have been fading before so
            // reset alpha
            cache.scrollBar.setAlpha(255);
        }
        final int viewFlags = mViewFlags;
        final boolean drawHorizontalScrollBar = (viewFlags & SCROLLBARS_HORIZONTAL) == SCROLLBARS_HORIZONTAL;
        final boolean drawVerticalScrollBar = (viewFlags & SCROLLBARS_VERTICAL) == SCROLLBARS_VERTICAL && !isVerticalScrollBarHidden();
        if (drawVerticalScrollBar || drawHorizontalScrollBar) {
            final int width = mRight - mLeft;
            final int height = mBottom - mTop;
            final ScrollBarDrawable scrollBar = cache.scrollBar;
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final int inside = (viewFlags & SCROLLBARS_OUTSIDE_MASK) == 0 ? ~0 : 0;
            int left, top, right, bottom;
            if (drawHorizontalScrollBar) {
                int size = scrollBar.getSize(false);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeHorizontalScrollRange(), computeHorizontalScrollOffset(), computeHorizontalScrollExtent(), false);
                final int verticalScrollBarGap = drawVerticalScrollBar ? getVerticalScrollbarWidth() : 0;
                top = scrollY + height - size - (mUserPaddingBottom & inside);
                left = scrollX + (mPaddingLeft & inside);
                right = scrollX + width - (mUserPaddingRight & inside) - verticalScrollBarGap;
                bottom = top + size;
                onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
            if (drawVerticalScrollBar) {
                int size = scrollBar.getSize(true);
                if (size <= 0) {
                    size = cache.scrollBarSize;
                }
                scrollBar.setParameters(computeVerticalScrollRange(), computeVerticalScrollOffset(), computeVerticalScrollExtent(), true);
                int verticalScrollbarPosition = mVerticalScrollbarPosition;
                if (verticalScrollbarPosition == SCROLLBAR_POSITION_DEFAULT) {
                    verticalScrollbarPosition = isLayoutRtl() ? SCROLLBAR_POSITION_LEFT : SCROLLBAR_POSITION_RIGHT;
                }
                switch(verticalScrollbarPosition) {
                    default:
                    case SCROLLBAR_POSITION_RIGHT:
                        left = scrollX + width - size - (mUserPaddingRight & inside);
                        break;
                    case SCROLLBAR_POSITION_LEFT:
                        left = scrollX + (mUserPaddingLeft & inside);
                        break;
                }
                top = scrollY + (mPaddingTop & inside);
                right = left + size;
                bottom = scrollY + height - (mUserPaddingBottom & inside);
                onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                if (invalidate) {
                    invalidate(left, top, right, bottom);
                }
            }
        }
    }
}",1,"/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
","/**
 * <p>Request the drawing of the horizontal and the vertical scrollbar. The
 * scrollbars are painted only if they have been awakened first.</p>
 *
 * @param canvas the canvas on which to draw the scrollbars
 *
 * @see #awakenScrollBars(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The changes lies in the section 'if (drawVerticalScrollBar)'. Before assigning value to the variable 'verticalScrollbarPosition', the late version involves a condition and set 'verticalScrollbarPosition' to different values according to whether 'isLayoutRtl()' returns true or false. In this sense the change type is 3.","The control dependency change does not potentially leads to different return values or different exceptions, so there exists no CI. Therefore, the CI type is 0."
403,<android.view.View: boolean hasFocus()>,16,17,<android.view.View: boolean hasFocus()>,<android.view.View: boolean hasFocus()>,0,"{
    return (mPrivateFlags & FOCUSED) != 0;
}","{
    return (mPrivateFlags & PFLAG_FOCUSED) != 0;
}",1,"/**
 * Returns true if this view has focus iteself, or is the ancestor of the
 * view that has focus.
 *
 * @return True if this view has or contains focus, false otherwise.
 */
","/**
 * Returns true if this view has focus iteself, or is the ancestor of the
 * view that has focus.
 *
 * @return True if this view has or contains focus, false otherwise.
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""focus"")]","[@ViewDebug.ExportedProperty(category = ""focus"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The function that this method returns has changed from (mPrivateFlags & FOCUSED) to (mPrivateFlags & PFLAG_FOCUSED), this indicates that the function that determines the focus status has changed visually, and the method this depends on has changed. Therefore, the change type is 1,5.","As the check for focus condition has changed, this method can potentially return different boolean value between early and later versions in some cases, thus causing compatibility issues. So the CI type is 1."
405,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>",16,17,"<android.view.View: void addFocusables(ArrayList<View>,int,int)>","<android.view.View: void addFocusables(ArrayList<View>,int,int)>",0,"{
    if (views == null) {
        return;
    }
    if ((focusableMode & FOCUSABLES_ACCESSIBILITY) == FOCUSABLES_ACCESSIBILITY) {
        if (isAccessibilityFocusable()) {
            views.add(this);
            return;
        }
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}","{
    if (views == null) {
        return;
    }
    if (!isFocusable()) {
        return;
    }
    if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {
        return;
    }
    views.add(this);
}",1,"/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabeld
 * depending on the focusable mode paramater.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
","/**
 * Adds any focusable views that are descendants of this view (possibly
 * including this view if it is focusable itself) to views. This method
 * adds all focusable views regardless if we are in touch mode or
 * only views focusable in touch mode if we are in touch mode or
 * only views that can take accessibility focus if accessibility is enabeld
 * depending on the focusable mode paramater.
 *
 * @param views Focusable views found so far or null if all we are interested is
 * the number of focusables.
 * @param direction The direction of the focus.
 * @param focusableMode The type of focusables to be added.
 *
 * @see #FOCUSABLES_ALL
 * @see #FOCUSABLES_TOUCH_MODE
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A whole 'if' condition block was deleted, and therefore one return statement was eliminated, thus the code change type is 1,3.","Since the return statement was removed, the behaviour of the function may have changed in certain conditions (when that if block condition satisfied). The function can potentially return different values now, so the CI type is 1."
406,<android.view.View: boolean isActivated()>,16,17,<android.view.View: boolean isActivated()>,<android.view.View: boolean isActivated()>,0,"{
    return (mPrivateFlags & ACTIVATED) != 0;
}","{
    return (mPrivateFlags & PFLAG_ACTIVATED) != 0;
}",1,"/**
 * Indicates the activation state of this view.
 *
 * @return true if the view is activated, false otherwise
 */
","/**
 * Indicates the activation state of this view.
 *
 * @return true if the view is activated, false otherwise
 */
",-1,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from using 'ACTIVATED' to 'PFLAG_ACTIVATED' and the condition inside the return stmt has altered, so the code change type is 1,5.","The change of return statement will make the API potentially return a different boolean value, so the CI type is 1."
407,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",16,17,"<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>","<android.app.admin.DevicePolicyManager: int setStorageEncryption(ComponentName,boolean)>",0,"{
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}","{
    if (mService != null) {
        try {
            return mService.setStorageEncryption(admin, encrypt, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return ENCRYPTION_STATUS_UNSUPPORTED;
}",1,"/**
 * Called by an application that is administering the device to
 * request that the storage system be encrypted.
 *
 * <p>When multiple device administrators attempt to control device
 * encryption, the most secure, supported setting will always be
 * used.  If any device administrator requests device encryption,
 * it will be enabled;  Conversely, if a device administrator
 * attempts to disable device encryption while another
 * device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 *
 * <p>This policy controls encryption of the secure (application data) storage area.  Data
 * written to other storage areas may or may not be encrypted, and this policy does not require
 * or control the encryption of any other storage areas.
 * There is one exception:  If {@link android.os.Environment#isExternalStorageEmulated()} is
 * {@code true}, then the directory returned by
 * {@link android.os.Environment#getExternalStorageDirectory()} must be written to disk
 * within the encrypted storage area.
 *
 * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
 * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
 * the encryption key may not be fully secured.  For maximum security, the administrator should
 * also require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 */
","/**
 * Called by an application that is administering the device to
 * request that the storage system be encrypted.
 *
 * <p>When multiple device administrators attempt to control device
 * encryption, the most secure, supported setting will always be
 * used.  If any device administrator requests device encryption,
 * it will be enabled;  Conversely, if a device administrator
 * attempts to disable device encryption while another
 * device administrator has enabled it, the call to disable will
 * fail (most commonly returning {@link #ENCRYPTION_STATUS_ACTIVE}).
 *
 * <p>This policy controls encryption of the secure (application data) storage area.  Data
 * written to other storage areas may or may not be encrypted, and this policy does not require
 * or control the encryption of any other storage areas.
 * There is one exception:  If {@link android.os.Environment#isExternalStorageEmulated()} is
 * {@code true}, then the directory returned by
 * {@link android.os.Environment#getExternalStorageDirectory()} must be written to disk
 * within the encrypted storage area.
 *
 * <p>Important Note:  On some devices, it is possible to encrypt storage without requiring
 * the user to create a device PIN or Password.  In this case, the storage is encrypted, but
 * the encryption key may not be fully secured.  For maximum security, the administrator should
 * also require (and check for) a pattern, PIN, or password.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param encrypt true to request encryption, false to release any previous request
 * @return the new request status (for all active admins) - will be one of
 * {@link #ENCRYPTION_STATUS_UNSUPPORTED}, {@link #ENCRYPTION_STATUS_INACTIVE}, or
 * {@link #ENCRYPTION_STATUS_ACTIVE}.  This is the value of the requests;  Use
 * {@link #getStorageEncryptionStatus()} to query the actual device state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent API mService.setStorageEncryption has added a new parameter UserHandle.myUserId() in the late version, so the code change type is 1,5.","The change of dependent API mService.setStorageEncryption with new parameters could lead to a different result when calling this API, which means the API potentially returns a different varaible (value or type), so the CI type is 1."
408,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,16,17,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the given two version, there is a synchronization statement (synchronized (mManagerCallback)) and an additional condition (if (mService != null)) introduced before the return statement, so the classification of code change is 3,4.","The introduction of the new 'if' condition can potentially lead to different return values based on the condition for mService variable. Hence, the CI type is 1."
410,<android.webkit.WebViewClassic: boolean onGenericMotionEvent(MotionEvent)>,16,17,<android.webkit.WebViewClassic: boolean onGenericMotionEvent(MotionEvent)>,<android.webkit.WebViewClassic: boolean onGenericMotionEvent(MotionEvent)>,0,"{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    final float vscroll;
                    final float hscroll;
                    if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                        vscroll = 0;
                        hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    } else {
                        vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                    }
                    if (hscroll != 0 || vscroll != 0) {
                        final int vdelta = (int) (vscroll * mWebViewPrivate.getVerticalScrollFactor());
                        final int hdelta = (int) (hscroll * mWebViewPrivate.getHorizontalScrollFactor());
                        if (pinScrollBy(hdelta, vdelta, false, 0)) {
                            return true;
                        }
                    }
                }
        }
    }
    return mWebViewPrivate.super_onGenericMotionEvent(event);
}","{
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_SCROLL:
                {
                    final float vscroll;
                    final float hscroll;
                    if ((event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0) {
                        vscroll = 0;
                        hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                    } else {
                        vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                        hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                    }
                    if (hscroll != 0 || vscroll != 0) {
                        final int vdelta = (int) (vscroll * mWebViewPrivate.getVerticalScrollFactor());
                        final int hdelta = (int) (hscroll * mWebViewPrivate.getHorizontalScrollFactor());
                        abortAnimation();
                        int oldTouchMode = mTouchMode;
                        startScrollingLayer(event.getX(), event.getY());
                        doDrag(hdelta, vdelta);
                        mTouchMode = oldTouchMode;
                        return true;
                    }
                }
        }
    }
    return mWebViewPrivate.super_onGenericMotionEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The only change made in Late_Version is the introduction of new statements replacing the pinScrollBy method in the Early_Version, so the code change type is 4.","The elimination of the pinScrollBy method and the introduction of new statements may cause the API to return a different result when the same input is given, therefore the CI type is 1."
411,<android.bluetooth.BluetoothSocket: void connect()>,16,17,<android.bluetooth.BluetoothSocket: void connect()>,<android.bluetooth.BluetoothSocket: void connect()>,0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        if (mSdp != null) {
            // blocks
            mPort = mSdp.doSdp();
        }
        // blocks
        connectNative();
        mSocketState = SocketState.CONNECTED;
    } finally {
        mLock.readLock().unlock();
    }
}","{
    if (mDevice == null)
        throw new IOException(""Connect is called on null device"");
    try {
        // TODO(BT) derive flag from auth and encrypt
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException(""Bluetooth is off"");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, ""connect(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""socket closed"");
            if (mPfd == null)
                throw new IOException(""bt socket connect failed"");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException(""bt socket connect failed"");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException(""bt socket closed"");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The whole logic of the method is re-implemented in the late version. The method starts with an additional exception check. More exception handling statements are introduced. There are some control dependency changes - the sequence and location of nested control flow statements. The method also involves new other operations, such as assigning a new service object, a new assignment of the variable 'mFd', 'mSocket', 'mSocketIS', 'mSocketOS'. Additionally, some dependent APIs like 'BluetoothAdapter.getDefaultAdapter().getBluetoothService(null)'' and 'bluetoothProxy.connectSocket(...)' are introduced. Therefore, The code change types are 1,2,3,4,5. ","This extensive code change induces major potential behavior changes. First, there are potential different return types/values due to the change of exception handling (new exceptions are introduced) and control dependencies (different assignment of variables). Second, the execution of new dependent APIs may trigger different exceptions from previous behavior. Thus, the CI types are 1,2."
412,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",16,17,"<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>","<android.content.res.Resources: Drawable getDrawableForDensity(int,int)>",0,"{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = DisplayMetrics.DENSITY_DEVICE;
            } else {
                value.density = (value.density * DisplayMetrics.DENSITY_DEVICE) / density;
            }
        }
        return loadDrawable(value, id);
    }
}","{
    synchronized (mTmpValue) {
        TypedValue value = mTmpValue;
        getValueForDensity(id, density, value, true);
        /*
             * Pretend the requested density is actually the display density. If
             * the drawable returned is not the requested density, then force it
             * to be scaled later by dividing its density by the ratio of
             * requested density to actual device density. Drawables that have
             * undefined density or no density don't need to be handled here.
             */
        if (value.density > 0 && value.density != TypedValue.DENSITY_NONE) {
            if (value.density == density) {
                value.density = mMetrics.densityDpi;
            } else {
                value.density = (value.density * mMetrics.densityDpi) / density;
            }
        }
        return loadDrawable(value, id);
    }
}",1,"/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @return Drawable An object that can be used to draw this resource.
 */
","/**
 * Return a drawable object associated with a particular resource ID for the
 * given screen density in DPI. This will set the drawable's density to be
 * the device's density multiplied by the ratio of actual drawable density
 * to requested density. This allows the drawable to be scaled up to the
 * correct size if needed. Various types of objects will be returned
 * depending on the underlying resource -- for example, a solid color, PNG
 * image, scalable image, etc. The Drawable API hides these implementation
 * details.
 *
 * @param id The desired resource identifier, as generated by the aapt tool.
 * This integer encodes the package, type, and resource entry.
 * The value 0 is an invalid identifier.
 * @param density the desired screen density indicated by the resource as
 * found in {@link DisplayMetrics}.
 * @throws NotFoundException Throws NotFoundException if the given ID does
 * not exist.
 * @return Drawable An object that can be used to draw this resource.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The constant value, DisplayMetrics.DENSITY_DEVICE, is replaced by the variable value, mMetrics.densityDpi, in lines setting value.density. It belongs to ""Other statement changed"" (code 4).","This change may potentially cause the method to return a different drawable object as the calculation of value.density changed, depending upon the value of mMetrics.densityDpi. Thus, it is categorized as ""Compatibility Issue caused by potential different return values or types"" (CI type 1)."
413,"<android.view.ViewGroup: View focusSearch(View,int)>",16,17,"<android.view.ViewGroup: View focusSearch(View,int)>","<android.view.ViewGroup: View focusSearch(View,int)>",0,"{
    // the screen.
    if (isRootNamespace() && (direction & FOCUS_ACCESSIBILITY) == 0) {
        // into other tabs.  see LocalActivityManager and TabHost for more info
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}","{
    if (isRootNamespace()) {
        // into other tabs.  see LocalActivityManager and TabHost for more info
        return FocusFinder.getInstance().findNextFocus(this, focused, direction);
    } else if (mParent != null) {
        return mParent.focusSearch(focused, direction);
    }
    return null;
}",1,"/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
","/**
 * Find the nearest view in the specified direction that wants to take
 * focus.
 *
 * @param focused The view that currently has focus
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and
 * FOCUS_RIGHT, or 0 for not applicable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement 'if (isRootNamespace() && (direction & FOCUS_ACCESSIBILITY) == 0)' of the early version has been changed to 'if (isRootNamespace())' in the late version. Hence, the change type is 3.","As the condition of the 'if' statement has changed and it is associated with a return statement ('return FocusFinder.getInstance().findNextFocus(this, focused, direction)'), the API might return a different value or type in certain cases when the 'direction' parameter doesn't satisfy the condition '(direction & FOCUS_ACCESSIBILITY) == 0'. Therefore, the CI type is 1."
415,"<android.app.TaskStackBuilder: PendingIntent getPendingIntent(int,int,Bundle)>",16,17,"<android.app.TaskStackBuilder: PendingIntent getPendingIntent(int,int,Bundle)>","<android.app.TaskStackBuilder: PendingIntent getPendingIntent(int,int,Bundle)>",0,"{
    if (mIntents.isEmpty()) {
        throw new IllegalStateException(""No intents added to TaskStackBuilder; cannot getPendingIntent"");
    }
    Intent[] intents = mIntents.toArray(new Intent[mIntents.size()]);
    intents[0].addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
    return PendingIntent.getActivities(mSourceContext, requestCode, intents, flags, options);
}","{
    if (mIntents.isEmpty()) {
        throw new IllegalStateException(""No intents added to TaskStackBuilder; cannot getPendingIntent"");
    }
    return PendingIntent.getActivities(mSourceContext, requestCode, getIntents(), flags, options);
}",1,"/**
 * Obtain a {@link PendingIntent} for launching the task constructed by this builder so far.
 *
 * @param requestCode Private request code for the sender
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE}, {@link PendingIntent#FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT}, or any of the flags supported by
 * {@link Intent#fillIn(Intent, int)} to control which unspecified parts of the
 * intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return The obtained PendingIntent
 */
","/**
 * Obtain a {@link PendingIntent} for launching the task constructed by this builder so far.
 *
 * @param requestCode Private request code for the sender
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE}, {@link PendingIntent#FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT}, or any of the flags supported by
 * {@link Intent#fillIn(Intent, int)} to control which unspecified parts of the
 * intent that can be supplied when the actual send happens.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.
 *
 * @return The obtained PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,The function of constructing the 'intents' array and setting flags for the first element has been replaced by a newly introduced method 'getIntents()'. So the change type includes 'Return statement changed'(1) and 'Other statement changed'(4).,"Due to the replace of the 'intents' array construction and setting flags process with a new method, the returned object of the method 'getPendingIntent()' could be different in the newer version, thus it is a 'Compatibility Issue caused by potential different return values or types'(1)."
417,<android.database.DatabaseUtils.InsertHelper: long execute()>,16,17,<android.database.DatabaseUtils.InsertHelper: long execute()>,<android.database.DatabaseUtils.InsertHelper: long execute()>,0,"{
    if (mPreparedStatement == null) {
        throw new IllegalStateException(""you must prepare this inserter before calling "" + ""execute"");
    }
    try {
        if (LOCAL_LOGV)
            Log.v(TAG, ""--- doing insert or replace in table "" + mTableName);
        return mPreparedStatement.executeInsert();
    } catch (SQLException e) {
        Log.e(TAG, ""Error executing InsertHelper with table "" + mTableName, e);
        return -1;
    } finally {
        // you can only call this once per prepare
        mPreparedStatement = null;
    }
}","{
    if (mPreparedStatement == null) {
        throw new IllegalStateException(""you must prepare this inserter before calling "" + ""execute"");
    }
    try {
        if (DEBUG)
            Log.v(TAG, ""--- doing insert or replace in table "" + mTableName);
        return mPreparedStatement.executeInsert();
    } catch (SQLException e) {
        Log.e(TAG, ""Error executing InsertHelper with table "" + mTableName, e);
        return -1;
    } finally {
        // you can only call this once per prepare
        mPreparedStatement = null;
    }
}",1,"/**
 * Execute the previously prepared insert or replace using the bound values
 * since the last call to prepareForInsert or prepareForReplace.
 *
 * <p>Note that calling bind() and then execute() is not thread-safe. The only thread-safe
 * way to use this class is to call insert() or replace().
 *
 * @return the row ID of the newly inserted row, or -1 if an
 * error occurred
 */
","/**
 * Execute the previously prepared insert or replace using the bound values
 * since the last call to prepareForInsert or prepareForReplace.
 *
 * <p>Note that calling bind() and then execute() is not thread-safe. The only thread-safe
 * way to use this class is to call insert() or replace().
 *
 * @return the row ID of the newly inserted row, or -1 if an
 * error occurred
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The condition variable changed from LOCAL_LOGV to DEBUG in the 'if' condition. Hence, the code change type is 4.",There are no compatibility issues between these two versions because the change is within a logging statement which does not affect the main functionality or output of the method. Hence the CI type is 0.
419,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,16,17,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,<android.animation.Keyframe.IntKeyframe: IntKeyframe clone()>,0,"{
    IntKeyframe kfClone = new IntKeyframe(getFraction(), mValue);
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    IntKeyframe kfClone = mHasValue ? new IntKeyframe(getFraction(), mValue) : new IntKeyframe(getFraction());
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The statement to create 'kfClone' has changed, and the control of 'kfClone' creation is introduced with a condition based on 'mHasValue', so the change type is 1,3.","Since a new control dependency has been added in the late version, which results in potentially different 'IntKeyframe' objects being returned by the method, the CI type is 1."
420,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,16,17,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,<android.app.ApplicationPackageManager: int getComponentEnabledSetting(ComponentName)>,0,"{
    try {
        return mPM.getComponentEnabledSetting(componentName, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}","{
    try {
        return mPM.getComponentEnabledSetting(componentName, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
    return PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The change here is in method invocation from UserId.myUserId() to mContext.getUserId(). So, the class of change is ""Dependent API changed"", which is 5.","The method invocation change may cause the return value of this API potentially different between these two versions, so the compatibility issue can arise due to potential different return values, which is represented by 1."
422,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumUpperCase(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumUpperCase(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumUpperCase(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of upper case letters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumUpperCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of upper case letters required in the
 * password.
 */
","/**
 * Retrieve the current number of upper case letters required in the
 * password for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumUpperCase(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of upper case letters required in the
 * password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The implementation of the method has been drastically changed. The previous implementation includes a try-catch block which potentially has been handled differently in the newer version. The new implementation also involves the call to another dependent API, `getPasswordMinimumUpperCase(admin, UserHandle.myUserId())` replacing `mService.getPasswordMinimumUpperCase(admin)`, indicating the code change types: 1, 4 and 5.","The new implementation changes the return statement of the method. The previous implementation potentially returned a variable '0', if an exception was caught. However, the late implementation directly returns the result of another dependent API call. This could potentially lead to different return values between two versions, hence indicates compatibility issue type 1."
423,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",16,17,"<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>","<android.app.SharedPreferencesImpl.EditorImpl: Editor putStringSet(String,Set<String>)>",0,"{
    synchronized (this) {
        mModified.put(key, values);
        return this;
    }
}","{
    synchronized (this) {
        mModified.put(key, (values == null) ? null : new HashSet<String>(values));
        return this;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The 'mModified.put' statement has changed, but this is an inner implementation detail and does not affect the type of return value or thrown exception, so the code change type is 4.","Despite the change in the implementation of the method, the previous and new versions will still return the same type under the same conditions, and the exception handling hasn't been changed either. Therefore, there should be no Compatibility Issues, so the CI type is 0."
424,"<android.webkit.WebViewClassic: boolean onKeyDown(int,KeyEvent)>",16,17,"<android.webkit.WebViewClassic: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebViewClassic: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mIsCaretSelection) {
        selectionDone();
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // See if the accessibility injector needs to handle this event.
    if (isAccessibilityEnabled() && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
    }
    if (isEnterActionKey(keyCode)) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
        }
    }
    // pass the key to DOM
    sendKeyEvent(event);
    // return true as DOM handles the key
    return true;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mIsCaretSelection) {
        selectionDone();
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // See if the accessibility injector needs to handle this event.
    if (isAccessibilityInjectionEnabled() && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
    }
    if (isEnterActionKey(keyCode)) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
        }
    }
    // pass the key to DOM
    sendKeyEvent(event);
    // return true as DOM handles the key
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The function call 'isAccessibilityEnabled()' is replaced with 'isAccessibilityInjectionEnabled()' in the condition check, which indicates a change in the function call and thereby it is type 4,5 change.","The change in the function call 'isAccessibilityEnabled()' to 'isAccessibilityInjectionEnabled()' could potentially let the API return different values as the condition check results can be different, which can lead to a different sequence of execution. Hence, the CI type is 1."
425,<android.app.ContextImpl: boolean stopService(Intent)>,16,17,<android.app.ContextImpl: boolean stopService(Intent)>,<android.app.ContextImpl: boolean stopService(Intent)>,0,"{
    try {
        service.setAllowFds(false);
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    warnIfCallingFromSystemProcess();
    return stopServiceAsUser(service, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5","1,2","In the late version, the entire implementation has been replaced with two different method calls. First, warnIfCallingFromSystemProcess() is invoked, then stopServiceAsUser(service, mUser) is called. The return statement has completely altered and thus it can be classified as the code change type of 5.",#CI_description
426,<android.bluetooth.BluetoothDevice: String getName()>,16,17,<android.bluetooth.BluetoothDevice: String getName()>,<android.bluetooth.BluetoothDevice: String getName()>,0,"{
    try {
        return sService.getRemoteName(mAddress);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device name"");
        return null;
    }
    try {
        return sService.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
","/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the Bluetooth name, or null if there was a problem.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There's a new condition check for 'sService == null' (control dependency changed), the statement 'return sService.getRemoteName(mAddress);' changed to 'return sService.getRemoteName(this);' (return statement changed), and this change does not involve different exception handling or annotations from the dependent APIs (Other statement changed). Hence the change type is 1,3,4.","The modification in the return statement 'sService.getRemoteName(mAddress);' potentially changes the returned value by the method, causing different behaviors. Thus the type of Compatibility Issue is 1."
427,<android.view.Display: int getWidth()>,16,17,<android.view.Display: int getWidth()>,<android.view.Display: int getWidth()>,0,"{
    synchronized (mTmpPoint) {
        long now = SystemClock.uptimeMillis();
        if (now > (mLastGetTime + 20)) {
            getSizeInternal(mTmpPoint, true);
            mLastGetTime = now;
        }
        return mTmpPoint.x;
    }
}","{
    synchronized (this) {
        updateCachedAppSizeIfNeededLocked();
        return mCachedAppWidthCompat;
    }
}",1,"/**
 * @deprecated Use {@link #getSize(Point)} instead.
 */
","/**
 * @deprecated Use {@link #getSize(Point)} instead.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed from 'return mTmpPoint.x;' to 'return mCachedAppWidthCompat;' and the synchronization locking mechanism switched from 'mTmpPoint' to 'this'. Also, a new function 'updateCachedAppSizeIfNeededLocked()' is introduced in the late implementation. So, the code change type is 1,3.","Changes in the return statement and the introduction of a new function that inherently changes the manipulation of the object (because they are using different locking objects), suggest that the method could potentially return different values when invoked in the late version. Therefore, the CI type is 1."
429,"<android.text.format.DateUtils: String getDayOfWeekString(int,int)>",16,17,"<android.text.format.DateUtils: String getDayOfWeekString(int,int)>","<android.text.format.DateUtils: String getDayOfWeekString(int,int)>",0,"{
    int[] list;
    switch(abbrev) {
        case LENGTH_LONG:
            list = sDaysLong;
            break;
        case LENGTH_MEDIUM:
            list = sDaysMedium;
            break;
        case LENGTH_SHORT:
            list = sDaysShort;
            break;
        case LENGTH_SHORTER:
            list = sDaysShort;
            break;
        case LENGTH_SHORTEST:
            list = sDaysShortest;
            break;
        default:
            list = sDaysMedium;
            break;
    }
    Resources r = Resources.getSystem();
    return r.getString(list[dayOfWeek - Calendar.SUNDAY]);
}","{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longWeekdayNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORT:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORTER:
            names = d.shortWeekdayNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyWeekdayNames;
            break;
        default:
            names = d.shortWeekdayNames;
            break;
    }
    return names[dayOfWeek];
}",1,"/**
 * Return a string for the day of the week.
 * @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},
 * {@link Calendar#MONDAY Calendar.MONDAY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},
 * {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.
 * Note that in most languages, {@link #LENGTH_SHORT}
 * will return the same as {@link #LENGTH_MEDIUM}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
 */
","/**
 * Return a string for the day of the week.
 * @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},
 * {@link Calendar#MONDAY Calendar.MONDAY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},
 * {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.
 * Note that in most languages, {@link #LENGTH_SHORT}
 * will return the same as {@link #LENGTH_MEDIUM}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
 * @deprecated use {@link java.text.SimpleDateFormat} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method implementation has undergone several changes. The switch-case logic remains but handles the cases differently, and the return statement has changed from returning a resource string to returning an element from an array. This signifies a change in control dependency (4) and return statement (1). Additionally, the dependent API - Resources.getSystem() - used in the first implementation has been replaced with LocaleData.get in the second, which denotes a change in the dependent API (5).","Due to changes in the implementation logic, including the return statement and the used APIs, the method can potentially return different output depending on the version. This introduces a compatibility issue due to potentially different return values or types (1)."
430,"<android.widget.Gallery: void layout(int,boolean)>",16,17,"<android.widget.Gallery: void layout(int,boolean)>","<android.widget.Gallery: void layout(int,boolean)>",0,"{
    mIsRtl = isLayoutRtl();
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}","{
    mIsRtl = isLayoutRtl();
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2) + mSelectedCenterOffset;
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}",1,"/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The addition of ""+ mSelectedCenterOffset"" to selectedOffset in the late implementation is changed in a non-control statement, therefore, the change type is 3.","Due to the change in calculation of selectedOffset, the final value of the variable may be different between the early version and late version. Hence, it potentially causes to return a different value. Therefore, CI type is 1."
432,<android.view.View: boolean fitSystemWindows(Rect)>,16,17,<android.view.View: boolean fitSystemWindows(Rect)>,<android.view.View: boolean fitSystemWindows(Rect)>,0,"{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = -1;
        mUserPaddingEnd = -1;
        mUserPaddingRelative = false;
        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0) {
            internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);
            return true;
        } else {
            internalSetPadding(0, 0, 0, 0);
            return false;
        }
    }
    return false;
}","{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        if ((mViewFlags & OPTIONAL_FITS_SYSTEM_WINDOWS) == 0 || mAttachInfo == null || (mAttachInfo.mSystemUiVisibility & SYSTEM_UI_LAYOUT_FLAGS) == 0) {
            internalSetPadding(insets.left, insets.top, insets.right, insets.bottom);
            return true;
        } else {
            internalSetPadding(0, 0, 0, 0);
            return false;
        }
    }
    return false;
}",1,"/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * inset's to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return Return true if this view applied the insets and it should not
 * continue propagating further down the hierarchy, false otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows()
 * @see #setSystemUiVisibility(int)
 */
","/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * inset's to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return Return true if this view applied the insets and it should not
 * continue propagating further down the hierarchy, false otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes occurred in variable assignment statements: mUserPaddingStart and mUserPaddingEnd. So, the code change type is 4. ","There's no Compatibility Issue (CI). The changes in the two versions are internal, setting local variables mUserPaddingStart and mUserPaddingEnd differently. The difference doesn't lead to any changes in the behavior of the API, such as return different values or throw different exceptions."
434,<android.view.Display: int getRotation()>,16,17,<android.view.Display: int getRotation()>,<android.view.Display: int getRotation()>,0,"{
    return getOrientation();
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.rotation;
    }
}",1,"/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
","/**
 * Returns the rotation of the screen from its ""natural"" orientation.
 * The returned value may be {@link Surface#ROTATION_0 Surface.ROTATION_0}
 * (no rotation), {@link Surface#ROTATION_90 Surface.ROTATION_90},
 * {@link Surface#ROTATION_180 Surface.ROTATION_180}, or
 * {@link Surface#ROTATION_270 Surface.ROTATION_270}.  For
 * example, if a device has a naturally tall screen, and the user has
 * turned it on its side to go into a landscape orientation, the value
 * returned here may be either {@link Surface#ROTATION_90 Surface.ROTATION_90}
 * or {@link Surface#ROTATION_270 Surface.ROTATION_270} depending on
 * the direction it was turned.  The angle is the rotation of the drawn
 * graphics on the screen, which is the opposite direction of the physical
 * rotation of the device.  For example, if the device is rotated 90
 * degrees counter-clockwise, to compensate rendering will be rotated by
 * 90 degrees clockwise and thus the returned value here will be
 * {@link Surface#ROTATION_90 Surface.ROTATION_90}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The return statement changed from getOrientation() to mDisplayInfo.rotation. A synchronization block is introduced along with the method call updateDisplayInfoLocked(), so the change types are 1,3,4.","The change in the return statement could potentially lead to the API returning a different value in the late version, hence a Compatibility Issue of type 1."
435,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,16,17,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothA2dp: int getConnectionState(BluetoothDevice)>,0,"{
    if (DBG)
        log(""getState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (VDBG)
        log(""getState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A debug log statement was altered from `if (DBG)` to `if (VDBG)`. This classifies as a code change type 4, i.e., other statement changed.","This change does not impact the functional behaviour of the method, hence, no Compatibility Issue exists."
436,<android.webkit.WebViewDatabaseClassic: WebViewDatabaseClassic getInstance(Context)>,16,17,<android.webkit.WebViewDatabaseClassic: WebViewDatabaseClassic getInstance(Context)>,<android.webkit.WebViewDatabaseClassic: WebViewDatabaseClassic getInstance(Context)>,0,"{
    if (sInstance == null) {
        sInstance = new WebViewDatabaseClassic(context);
    }
    return sInstance;
}","{
    synchronized (sInstanceLock) {
        if (sInstance == null) {
            sInstance = new WebViewDatabaseClassic(context);
        }
        return sInstance;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,0,"A 'synchronized' control statement has been added in the late version, so the code change type is 3.","The output of the method doesn't change because of the addition of the 'synchronized' block. Therefore, there is no compatibility issue existing, classified as type 0."
437,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,16,17,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,<android.server.search.Searchables: SearchableInfo getSearchableInfo(ComponentName)>,0,"{
    // Step 1.  Is the result already hashed?  (case 1)
    SearchableInfo result;
    synchronized (this) {
        result = mSearchablesMap.get(activity);
        if (result != null)
            return result;
    }
    // Step 2.  See if the current activity references a searchable.
    // Note:  Conceptually, this could be a while(true) loop, but there's
    // no point in implementing reference chaining here and risking a loop.
    // References must point directly to searchable activities.
    ActivityInfo ai = null;
    try {
        ai = mContext.getPackageManager().getActivityInfo(activity, PackageManager.GET_META_DATA);
        String refActivityName = null;
        // First look for activity-specific reference
        Bundle md = ai.metaData;
        if (md != null) {
            refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
        }
        // If not found, try for app-wide reference
        if (refActivityName == null) {
            md = ai.applicationInfo.metaData;
            if (md != null) {
                refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
            }
        }
        // Irrespective of source, if a reference was found, follow it.
        if (refActivityName != null) {
            // This value is deprecated, return null
            if (refActivityName.equals(MD_SEARCHABLE_SYSTEM_SEARCH)) {
                return null;
            }
            String pkg = activity.getPackageName();
            ComponentName referredActivity;
            if (refActivityName.charAt(0) == '.') {
                referredActivity = new ComponentName(pkg, pkg + refActivityName);
            } else {
                referredActivity = new ComponentName(pkg, refActivityName);
            }
            // it against the original name so we can skip the check
            synchronized (this) {
                result = mSearchablesMap.get(referredActivity);
                if (result != null) {
                    mSearchablesMap.put(activity, result);
                    return result;
                }
            }
        }
    } catch (PackageManager.NameNotFoundException e) {
    // case 3: no metadata
    }
    // Step 3.  None found. Return null.
    return null;
}","{
    // Step 1.  Is the result already hashed?  (case 1)
    SearchableInfo result;
    synchronized (this) {
        result = mSearchablesMap.get(activity);
        if (result != null)
            return result;
    }
    // Step 2.  See if the current activity references a searchable.
    // Note:  Conceptually, this could be a while(true) loop, but there's
    // no point in implementing reference chaining here and risking a loop.
    // References must point directly to searchable activities.
    ActivityInfo ai = null;
    try {
        ai = mPm.getActivityInfo(activity, PackageManager.GET_META_DATA, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error getting activity info "" + re);
        return null;
    }
    String refActivityName = null;
    // First look for activity-specific reference
    Bundle md = ai.metaData;
    if (md != null) {
        refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
    }
    // If not found, try for app-wide reference
    if (refActivityName == null) {
        md = ai.applicationInfo.metaData;
        if (md != null) {
            refActivityName = md.getString(MD_LABEL_DEFAULT_SEARCHABLE);
        }
    }
    // Irrespective of source, if a reference was found, follow it.
    if (refActivityName != null) {
        // This value is deprecated, return null
        if (refActivityName.equals(MD_SEARCHABLE_SYSTEM_SEARCH)) {
            return null;
        }
        String pkg = activity.getPackageName();
        ComponentName referredActivity;
        if (refActivityName.charAt(0) == '.') {
            referredActivity = new ComponentName(pkg, pkg + refActivityName);
        } else {
            referredActivity = new ComponentName(pkg, refActivityName);
        }
        // it against the original name so we can skip the check
        synchronized (this) {
            result = mSearchablesMap.get(referredActivity);
            if (result != null) {
                mSearchablesMap.put(activity, result);
                return result;
            }
        }
    }
    // Step 3.  None found. Return null.
    return null;
}",1,"/**
 * Look up, or construct, based on the activity.
 *
 * The activities fall into three cases, based on meta-data found in
 * the manifest entry:
 * <ol>
 * <li>The activity itself implements search.  This is indicated by the
 * presence of a ""android.app.searchable"" meta-data attribute.
 * The value is a reference to an XML file containing search information.</li>
 * <li>A related activity implements search.  This is indicated by the
 * presence of a ""android.app.default_searchable"" meta-data attribute.
 * The value is a string naming the activity implementing search.  In this
 * case the factory will ""redirect"" and return the searchable data.</li>
 * <li>No searchability data is provided.  We return null here and other
 * code will insert the ""default"" (e.g. contacts) search.
 *
 * TODO: cache the result in the map, and check the map first.
 * TODO: it might make sense to implement the searchable reference as
 * an application meta-data entry.  This way we don't have to pepper each
 * and every activity.
 * TODO: can we skip the constructor step if it's a non-searchable?
 * TODO: does it make sense to plug the default into a slot here for
 * automatic return?  Probably not, but it's one way to do it.
 *
 * @param activity The name of the current activity, or null if the
 * activity does not define any explicit searchable metadata.
 */
","/**
 * Look up, or construct, based on the activity.
 *
 * The activities fall into three cases, based on meta-data found in
 * the manifest entry:
 * <ol>
 * <li>The activity itself implements search.  This is indicated by the
 * presence of a ""android.app.searchable"" meta-data attribute.
 * The value is a reference to an XML file containing search information.</li>
 * <li>A related activity implements search.  This is indicated by the
 * presence of a ""android.app.default_searchable"" meta-data attribute.
 * The value is a string naming the activity implementing search.  In this
 * case the factory will ""redirect"" and return the searchable data.</li>
 * <li>No searchability data is provided.  We return null here and other
 * code will insert the ""default"" (e.g. contacts) search.
 *
 * TODO: cache the result in the map, and check the map first.
 * TODO: it might make sense to implement the searchable reference as
 * an application meta-data entry.  This way we don't have to pepper each
 * and every activity.
 * TODO: can we skip the constructor step if it's a non-searchable?
 * TODO: does it make sense to plug the default into a slot here for
 * automatic return?  Probably not, but it's one way to do it.
 *
 * @param activity The name of the current activity, or null if the
 * activity does not define any explicit searchable metadata.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4,5","1,2","Two things have changed, the method call to fetch Activity Info which is a dependent API has been changed from mContext.getPackageManager().getActivityInfo(activity, PackageManager.GET_META_DATA) to mPm.getActivityInfo(activity, PackageManager.GET_META_DATA, mUserId) and Exception handling has been added which handles the RemoteException, so the change type is 2, 4, and 5.","The change in the dependent API could lead to different results being returned and the newly added exception handling might lead to returning a NULL value earlier than in previous implementation which might cause significant behavioural changes in the code leading to both potential different return values and potential different exception handlings. Therefore, the CI type is 1, 2."
438,<android.server.search.SearchManagerService: ComponentName getGlobalSearchActivity()>,16,17,<android.server.search.SearchManagerService: ComponentName getGlobalSearchActivity()>,<android.server.search.SearchManagerService: ComponentName getGlobalSearchActivity()>,0,"{
    return getSearchables().getGlobalSearchActivity();
}","{
    return getSearchables(UserHandle.getCallingUserId()).getGlobalSearchActivity();
}",1,"/**
 * Gets the name of the global search activity.
 */
","/**
 * Gets the name of the global search activity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed, as different methods are being called for getting the required value. In the previous version, `getSearchables()` method is being used while in the newer version, `getSearchables(UserHandle.getCallingUserId())` is being used, thus method invoked in dependent API has changed. So the code change type is 1,5.","Due to the change of method invoked in dependent API, the return value of the method can potentially be different. In this case, it's the change of the value fetched from the getSearchables() function that causes the potential incompatibility. Thus the CI type is 1."
440,<android.webkit.WebViewFactory: WebViewFactoryProvider getProvider()>,16,17,<android.webkit.WebViewFactory: WebViewFactoryProvider getProvider()>,<android.webkit.WebViewFactory: WebViewFactoryProvider getProvider()>,0,"{
    // us honest and minimize usage of WebViewClassic internals when binding the proxy.
    if (sProviderInstance != null)
        return sProviderInstance;
    sProviderInstance = getFactoryByName(DEFAULT_WEB_VIEW_FACTORY);
    if (sProviderInstance == null) {
        if (DEBUG)
            Log.v(LOGTAG, ""Falling back to explicit linkage"");
        sProviderInstance = new WebViewClassic.Factory();
    }
    return sProviderInstance;
}","{
    synchronized (sProviderLock) {
        // us honest and minimize usage of WebViewClassic internals when binding the proxy.
        if (sProviderInstance != null)
            return sProviderInstance;
        // at runtime. For user (release) builds, don't allow this.
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(""webview.use_chromium"", false)) {
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            try {
                sProviderInstance = loadChromiumProvider();
                if (DEBUG)
                    Log.v(LOGTAG, ""Loaded Chromium provider: "" + sProviderInstance);
            } finally {
                StrictMode.setThreadPolicy(oldPolicy);
            }
        }
        if (sProviderInstance == null) {
            if (DEBUG)
                Log.v(LOGTAG, ""Falling back to default provider: "" + DEFAULT_WEBVIEW_FACTORY);
            sProviderInstance = getFactoryByName(DEFAULT_WEBVIEW_FACTORY, WebViewFactory.class.getClassLoader());
            if (sProviderInstance == null) {
                if (DEBUG)
                    Log.v(LOGTAG, ""Falling back to explicit linkage"");
                sProviderInstance = new WebViewClassic.Factory();
            }
        }
        return sProviderInstance;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"In the late version, the method getProvider() is surrounded by the synchronized statement. It introduced new return statement (return sProviderInstance) inside the 'if' block and changes the dependent API call from getFactoryByName(DEFAULT_WEB_VIEW_FACTORY) to getFactoryByName(DEFAULT_WEBVIEW_FACTORY, WebViewFactory.class.getClassLoader()). The exception handling statements and other statements have also been added, respectively. Thus, the code change types are 1,3,4,5.","Although the late version introduces new return statements and change some dependent APIs, these changes are under specific if conditions. None of these changes could potentially lead to the different outcomes of getProvider() compared with the early version, since sProviderInstance is either already assigned or will be assigned by the same instance (new WebViewClassic.Factory()). Therefore, no compatibility issue exists in the late version, so the CI type is 0."
444,<android.view.View: boolean isHovered()>,16,17,<android.view.View: boolean isHovered()>,<android.view.View: boolean isHovered()>,0,"{
    return (mPrivateFlags & HOVERED) != 0;
}","{
    return (mPrivateFlags & PFLAG_HOVERED) != 0;
}",1,"/**
 * Returns true if the view is currently hovered.
 *
 * @return True if the view is currently hovered.
 *
 * @see #setHovered
 * @see #onHoverChanged
 */
","/**
 * Returns true if the view is currently hovered.
 *
 * @return True if the view is currently hovered.
 *
 * @see #setHovered
 * @see #onHoverChanged
 */
",-1,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from (mPrivateFlags & HOVERED) to (mPrivateFlags & PFLAG_HOVERED) and the constant in the return operation also changed, so the code change type is 1,5.","The change of return statement and constant in the operation means that the final returned boolean result could be different, so the CI type is 1."
449,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",16,17,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>","<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int,boolean)>",0,"{
    // Fragments that are not currently added will sit in the onCreate() state.
    if (!f.mAdded && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mFragmentManager = mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                mActivity.onAttachFragment(f);
                if (!f.mRetaining) {
                    f.mCalled = false;
                    f.onCreate(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onCreate()"");
                    }
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mActivity.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throw new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" for fragment "" + f);
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.mCalled = false;
                    f.onActivityCreated(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onActivityCreated()"");
                    }
                    if (f.mView != null) {
                        f.restoreViewState();
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.mCalled = false;
                    f.performStart();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStart()"");
                    }
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mCalled = false;
                    f.mResumed = true;
                    f.onResume();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onResume()"");
                    }
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.mCalled = false;
                    f.onPause();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onPause()"");
                    }
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.mCalled = false;
                    f.performStop();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStop()"");
                    }
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.mCalled = false;
                    f.performDestroyView();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroyView()"");
                    }
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.mCalled = false;
                            f.onDestroy();
                            if (!f.mCalled) {
                                throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroy()"");
                            }
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mActivity = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    if (DEBUG && false)
        Log.v(TAG, ""moveToState: "" + f + "" oldState="" + f.mState + "" newState="" + newState + "" mRemoving="" + f.mRemoving + "" Callers="" + Debug.getCallers(5));
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.STOPPED) {
        newState = Fragment.STOPPED;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                    f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                    if (!f.mUserVisibleHint) {
                        f.mDeferStart = true;
                        if (newState > Fragment.STOPPED) {
                            newState = Fragment.STOPPED;
                        }
                    }
                }
                f.mActivity = mActivity;
                f.mParentFragment = mParent;
                f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                if (f.mParentFragment == null) {
                    mActivity.onAttachFragment(f);
                }
                if (!f.mRetaining) {
                    f.performCreate(f.mSavedFragmentState);
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mContainer.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throwException(new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" ("" + f.getResources().getResourceName(f.mContainerId) + "") for fragment "" + f));
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.performStart();
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mResumed = true;
                    f.performResume();
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.performPause();
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.performStop();
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0, false);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.performDestroy();
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!keepActive) {
                            if (!f.mRetaining) {
                                makeInactive(f);
                            } else {
                                f.mActivity = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                            }
                        }
                    }
                }
        }
    }
    f.mState = newState;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
450,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",16,17,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>","<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",0,"{
    String allowedProviders = Settings.Secure.getString(cr, LOCATION_PROVIDERS_ALLOWED);
    return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
}","{
    return isLocationProviderEnabledForUser(cr, provider, UserHandle.myUserId());
}",1,"/**
 * Helper method for determining if a location provider is enabled.
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 */
","/**
 * Helper method for determining if a location provider is enabled.
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changes from multiple lines which also uses a dependent API getString, to a different return statement which also uses a different dependent API isLocationProviderEnabledForUser, so the code change type is 1,5.","The return statement has changed to a different method, potentially changing the behaviour and returning different values. Hence, the CI type is 1."
452,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,16,17,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    if (mInputMethodSession == null)
        return;
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null)
        return;
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_DISPATCH_GENERIC_MOTION_EVENT:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.dispatchGenericMotionEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                args.recycle();
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                args.recycle();
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the early version, the object of class 'HandlerCaller.SomeArgs' is used but in the late version, the object of class 'SomeArgs' is used. Moreover, the method call 'mCaller.recycleArgs(args);' in all case statements has been changed to 'args.recycle();'. Additionally, there are few case statements of a switch that have changed ('DO_DISPATCH_TRACKBALL_EVENT', 'DO_UPDATE_SELECTION', 'DO_APP_PRIVATE_COMMAND') and a new case statement ('DO_DISPATCH_GENERIC_MOTION_EVENT') has been introduced. Hence, the change types are 3 and 4.","With above changes, the return values or the flow control of switch statement may vary in terms of invoking the method in different versions. So, these changes could potentially lead to a Compatibility Issue of type 1."
453,<android.text.format.Time: boolean parse(String)>,16,17,<android.text.format.Time: boolean parse(String)>,<android.text.format.Time: boolean parse(String)>,0,"{
    if (nativeParse(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}","{
    if (s == null) {
        throw new NullPointerException(""time string is null"");
    }
    if (nativeParse(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}",1,"/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the ""time"" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>""20081013T160000Z""</li>
 * <li>""20081013T160000""</li>
 * <li>""20081013""</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with ""Z"" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = ""20081013T160000Z"";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
","/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the ""time"" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>""20081013T160000Z""</li>
 * <li>""20081013T160000""</li>
 * <li>""20081013""</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with ""Z"" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = ""20081013T160000Z"";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"A control statement, if the string s is null, is added, and it will throw a NullPointerException, so the change type is 2, 3.","In the early version, if the time string is null, the program will not throw an exception. In the late version, it will throw a NullPointerException. So, the exception handling is different, therefore, CI type is 2."
454,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,16,17,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,<android.bluetooth.BluetoothHeadset: boolean isAudioConnected(BluetoothDevice)>,0,"{
    if (DBG)
        log(""isAudioConnected()"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}","{
    if (VDBG)
        log(""isAudioConnected()"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return false;
}",1,"/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected,
 * false otherwise or on error
 */
","/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected,
 * false otherwise or on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the condition statement of 'if' has changed from DBG to VDBG, so the code change type is 4.","The change in the 'if' control statement does not affect the behaviour of API because it is just a debug mode flag. Thus, no compatibility issue exists."
455,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",16,17,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>","<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return writeNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}","{
    if (VDBG)
        Log.d(TAG, ""write: "" + mSocketOS + "" length: "" + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, ""write out: "" + mSocketOS + "" length: "" + length);
    return length;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The entire block of code has been changed. The early version has exception handling, and uses the `writeNative` method. The late version, however, logs debug information, uses `mSocketOS.write` instead, and returns 'length'. This involves changes in the return statement, other statements and dependent APIs, so the change type is 1,4,5.","The change of return statement from 'writeNative(b, offset, length)' to 'length' will make the API potentially return a different value, so the CI type is 1."
456,<android.app.TaskStackBuilder: Intent[] getIntents()>,16,17,<android.app.TaskStackBuilder: Intent[] getIntents()>,<android.app.TaskStackBuilder: Intent[] getIntents()>,0,"{
    return mIntents.toArray(new Intent[mIntents.size()]);
}","{
    Intent[] intents = new Intent[mIntents.size()];
    if (intents.length == 0)
        return intents;
    intents[0] = new Intent(mIntents.get(0)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_TASK_ON_HOME);
    for (int i = 1; i < intents.length; i++) {
        intents[i] = new Intent(mIntents.get(i));
    }
    return intents;
}",1,"/**
 * Return an array containing the intents added to this builder. The intent at the
 * root of the task stack will appear as the first item in the array and the
 * intent at the top of the stack will appear as the last item.
 *
 * @return An array containing the intents added to this builder.
 */
","/**
 * Return an array containing the intents added to this builder. The intent at the
 * root of the task stack will appear as the first item in the array and the
 * intent at the top of the stack will appear as the last item.
 *
 * @return An array containing the intents added to this builder.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"Among these changes, 'mIntents.toArray(new Intent[mIntents.size()])' has been replaced by entire separate statements. The return statement has changed, new control statements (if and for) are added, which shows that changes include refining return statement, control dependency and other statements, which would be categorized as 1,3,4 accordingly.","The change in return value of this method could potentially cause Compatibility Issue because the returned 'Intent[]' array in the new version is filled with new intent objects, instead of being filled directly with objects from 'mIntents', which is made sure by the former return statement. This change could provide different behaviour of this API between these two versions. Hence, the Compatibility Issue (CI) is caused by potential different return values, so its type is 1."
457,<android.view.ScaleGestureDetector: boolean isInProgress()>,16,17,<android.view.ScaleGestureDetector: boolean isInProgress()>,<android.view.ScaleGestureDetector: boolean isInProgress()>,0,"{
    return mGestureInProgress;
}","{
    return mInProgress;
}",1,"/**
 * Returns {@code true} if a two-finger scale gesture is in progress.
 * @return {@code true} if a scale gesture is in progress, {@code false} otherwise.
 */
","/**
 * Returns {@code true} if a scale gesture is in progress.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The variable in the return statement has been changed from 'mGestureInProgress' to 'mInProgress', which can be classified as 'Return statement changed' and 'Other statement changed'. So, the change type is 1,4.","As the API's return statement has changed, it may potentially return a different boolean value which leads to compatibility issue. So, the CI type is 1."
459,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,16,17,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = (int) ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int x = (int) ev.getX(activePointerIndex);
            int deltaX = mLastMotionX - x;
            if (!mIsBeingDragged && Math.abs(deltaX) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaX > 0) {
                    deltaX -= mTouchSlop;
                } else {
                    deltaX += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"A new line of code for checking the valid index of pointer has been added in 'MotionEvent.ACTION_MOVE' switch case in the late version compared to the early version. This piece of code doesn't have any impact on the return value or exception handling of the method, therefore the change type is 3 which is Control dependency change.","Even though there is a code change, none of the changes may lead to a different return value or a new exception being thrown by the method, hence there are no Compatibility Issues that exist."
462,<android.view.View: void buildDrawingCache(boolean)>,16,17,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        final long projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
        final long drawingCacheSize = ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();
        if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
            if (width > 0 && height > 0) {
                Log.w(VIEW_LOG_TAG, ""View too large to fit into drawing cache, needs "" + projectedBitmapSize + "" bytes, only "" + drawingCacheSize + "" available"");
            }
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(), width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= PFLAG_DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementation has some non-conditional statements changed. It changed from using a variable to an output from a function specifically at Bitmap.createBitmap(). Also, a logging statement was introduced indicating the projectedBitmapSize and drawingCacheSize. Therefore, the change is classified as 4 (Other statements changed).","The changes in the method implementation do not alter the output nor introduce new exceptions. Therefore, no Compatibility Issue (CI) is detected."
463,<android.view.ViewTreeObserver: void dispatchOnGlobalLayout()>,16,17,<android.view.ViewTreeObserver: void dispatchOnGlobalLayout()>,<android.view.ViewTreeObserver: void dispatchOnGlobalLayout()>,0,"{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArrayList<OnGlobalLayoutListener> listeners = mOnGlobalLayoutListeners;
    if (listeners != null && listeners.size() > 0) {
        for (OnGlobalLayoutListener listener : listeners) {
            listener.onGlobalLayout();
        }
    }
}","{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArray<OnGlobalLayoutListener> listeners = mOnGlobalLayoutListeners;
    if (listeners != null && listeners.size() > 0) {
        CopyOnWriteArray.Access<OnGlobalLayoutListener> access = listeners.start();
        try {
            int count = access.size();
            for (int i = 0; i < count; i++) {
                access.get(i).onGlobalLayout();
            }
        } finally {
            listeners.end();
        }
    }
}",1,"/**
 * Notifies registered listeners that a global layout happened. This can be called
 * manually if you are forcing a layout on a View or a hierarchy of Views that are
 * not attached to a Window or in the GONE state.
 */
","/**
 * Notifies registered listeners that a global layout happened. This can be called
 * manually if you are forcing a layout on a View or a hierarchy of Views that are
 * not attached to a Window or in the GONE state.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are changes in the method of iterating the 'listeners' list and the data type of the 'listeners' variable. The change type is 3,4.","The changes made in iteration method doesn't affect the return variable of the API, or cause the API to throw a different exception. Therefore, no compatibility issue exists, the CI type is 0."
465,<android.view.View: boolean isDirty()>,16,17,<android.view.View: boolean isDirty()>,<android.view.View: boolean isDirty()>,0,"{
    return (mPrivateFlags & DIRTY_MASK) != 0;
}","{
    return (mPrivateFlags & PFLAG_DIRTY_MASK) != 0;
}",1,"/**
 * True if this view has changed since the last time being drawn.
 *
 * @return The dirty state of this view.
 */
","/**
 * True if this view has changed since the last time being drawn.
 *
 * @return The dirty state of this view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The name of the constant used in the return statement changed from DIRTY_MASK to PFLAG_DIRTY_MASK, so the code change type is 1,5.","The return statement has been changed. Depending on the values of DIRTY_MASK and PFLAG_DIRTY_MASK, the method may return a different result, thus the CI type is 1."
466,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",16,17,"<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>","<android.appwidget.AppWidgetManager: boolean bindAppWidgetIdIfAllowed(int,ComponentName)>",0,"{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    if (mContext == null) {
        return false;
    }
    try {
        return sService.bindAppWidgetIdIfAllowed(mContext.getPackageName(), appWidgetId, provider, null);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
","/**
 * Set the component for a given appWidgetId.
 *
 * <p class=""note"">You need the BIND_APPWIDGET permission or the user must have enabled binding
 * widgets always for your component. Should be used by apps that host widgets; if this
 * method returns false, call {@link #ACTION_APPWIDGET_BIND} to request permission to
 * bind
 *
 * @param appWidgetId     The AppWidget instance for which to set the RemoteViews.
 * @param provider      The {@link android.content.BroadcastReceiver} that will be the AppWidget
 * provider for this AppWidget.
 * @return true if this component has permission to bind the AppWidget
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method called in the return statement has changed by adding a new parameter (from sService.bindAppWidgetIdIfAllowed)(... , provider) to sService.bindAppWidgetIdIfAllowed(..., provider, null), so the code change classification is 1,5.","Since the return statement has changed, this could potentially cause the method to return a different value, therefore the CI type is 1."
468,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",16,17,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int,String)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate;
    if (timeZone != null) {
        startDate = new Time(timeZone);
    } else if (useUTC) {
        startDate = new Time(Time.TIMEZONE_UTC);
    } else {
        startDate = new Time();
    }
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        if (timeZone != null) {
            endDate = new Time(timeZone);
        } else if (useUTC) {
            endDate = new Time(Time.TIMEZONE_UTC);
        } else {
            endDate = new Time();
        }
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum && startYear == endYear) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    String startStandaloneMonthString = startMonthString;
    String endStandaloneMonthString = endMonthString;
    // We need standalone months for these strings in Persian (fa): http://b/6811327
    if (!numericDate && !abbrevMonth && Locale.getDefault().getLanguage().equals(""fa"")) {
        startStandaloneMonthString = startDate.format(""%-B"");
        endStandaloneMonthString = endDate.format(""%-B"");
    }
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString, startStandaloneMonthString, endStandaloneMonthString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC time zone is used for the start
 * and end milliseconds unless a time zone is specified. If a time zone
 * is specified it will be used regardless of the FORMAT_UTC flag.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * <p>
 * If the end date ends at 12:00am at the beginning of a day, it is
 * formatted as the end of the previous day in two scenarios:
 * <ul>
 * <li>For single day events. This results in ""8pm - midnight"" instead of
 * ""Nov 10, 8pm - Nov 11, 12am"".</li>
 * <li>When the time is not displayed. This results in ""Nov 10 - 11"" for
 * an event with a start date of Nov 10 and an end date of Nov 12 at
 * 00:00.</li>
 * </ul>
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @param timeZone the time zone to compute the string in. Use null for local
 * or if the FORMAT_UTC flag is being used.
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
469,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,16,17,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,<android.bluetooth.BluetoothA2dp: List<BluetoothDevice> getConnectedDevices()>,0,"{
    if (DBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}","{
    if (VDBG)
        log(""getConnectedDevices()"");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, ""Stack:"" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return new ArrayList<BluetoothDevice>();
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The debug output statement changes from using the DBG flag to the VDBG flag which is not affecting the functionality of the method, hence the change is classified as type 4.","There is no Compatibility Issue(CI) detected because the change does not affect the return statement, exception handling, or dependencies of the API leading type 0 for prediction_CI."
471,"<android.app.ReceiverRestrictedContext: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",16,17,"<android.app.ReceiverRestrictedContext: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>","<android.app.ReceiverRestrictedContext: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",0,"{
    throw new ReceiverCallNotAllowedException(""IntentReceiver components are not allowed to register to receive intents"");
// ex.fillInStackTrace();
// Log.e(""IntentReceiver"", ex.getMessage(), ex);
// return mContext.registerReceiver(receiver, filter, broadcastPermission,
// scheduler);
}","{
    if (receiver == null) {
        // aren't actually registering a receiver.
        return super.registerReceiver(null, filter, broadcastPermission, scheduler);
    } else {
        throw new ReceiverCallNotAllowedException(""BroadcastReceiver components are not allowed to register to receive intents"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3,1","1,2","A new 'if' control flow statement, a new 'return' statement and a new 'throw' exception statement were introduced. Hence, the change type is 2,3,1.","With the new 'return' statement and 'throw' exception statement, the API could potentially return a different value in different situations or throw different exceptions—hence the CI type is 1,2."
472,<android.server.search.SearchManagerService: List<SearchableInfo> getSearchablesInGlobalSearch()>,16,17,<android.server.search.SearchManagerService: List<SearchableInfo> getSearchablesInGlobalSearch()>,<android.server.search.SearchManagerService: List<SearchableInfo> getSearchablesInGlobalSearch()>,0,"{
    return getSearchables().getSearchablesInGlobalSearchList();
}","{
    return getSearchables(UserHandle.getCallingUserId()).getSearchablesInGlobalSearchList();
}",1,"/**
 * Returns a list of the searchable activities that can be included in global search.
 */
","/**
 * Returns a list of the searchable activities that can be included in global search.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from getSearchables().getSearchablesInGlobalSearchList() to getSearchables(UserHandle.getCallingUserId()).getSearchablesInGlobalSearchList() and the parameter type of getSearchables() also changed, so the code change type is 1,5.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
473,<android.bluetooth.BluetoothAdapter: boolean disable()>,16,17,<android.bluetooth.BluetoothAdapter: boolean disable()>,<android.bluetooth.BluetoothAdapter: boolean disable()>,0,"{
    try {
        return mService.disable(true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    try {
        return mManagerService.disable(true);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter shutdown has begun, or false on
 * immediate error
 */
","/**
 * Turn off the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn off Bluetooth.
 * <p>This gracefully shuts down all Bluetooth connections, stops Bluetooth
 * system services, and powers down the underlying Bluetooth hardware.
 * <p class=""caution""><strong>Bluetooth should never be disabled without
 * direct user consent</strong>. The {@link #disable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_ON} to {@link #STATE_TURNING_OFF}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned off -
 * such as the adapter already being turned off.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter shutdown has begun, or false on
 * immediate error
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"API changes from `mService.disable(true)` to `mManagerService.disable(true)`. It means that the dependent API or variable has changed, so the code change type is 5.","Though there is dependent API change, since the dependent API `disable(true)` is still called in the catch block and does not change the return statement, there is no potential behaviour changes detected in this modification. Thus, no Compatibility Issue exists, predicting CI type as 0."
474,<android.util.Pair: int hashCode()>,16,17,<android.util.Pair: int hashCode()>,<android.util.Pair: int hashCode()>,0,"{
    int result = 17;
    result = 31 * result + first.hashCode();
    result = 31 * result + second.hashCode();
    return result;
}","{
    return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());
}",1,"/**
 * Compute a hash code using the hash codes of the underlying objects
 * @return a hashcode of the Pair
 */
","/**
 * Compute a hash code using the hash codes of the underlying objects
 *
 * @return a hashcode of the Pair
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the method has changed completely, including the computations for the return value, so the change types are 1 and 4.","Because the computation of the return value has changed, the returned int value may not be the same for the same input in the two API versions, thus leading to a compatibility issue of category 1."
476,<android.app.ActivityOptions: Bundle toBundle()>,16,17,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
            break;
        case ANIM_THUMBNAIL:
        case ANIM_THUMBNAIL_DELAYED:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"In the 'switch' statement, the case condition of 'ANIM_THUMBNAIL' and 'ANIM_THUMBNAIL_DELAYED' is changed to 'ANIM_THUMBNAIL_SCALE_UP' and 'ANIM_THUMBNAIL_SCALE_DOWN', so the code change type is 3.","The change in 'switch' condition indicates that for different mAnimationType values, the outputted bundle will have different contents, which means it will return a different variable. So the CI type is 1."
477,"<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>",16,17,"<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>","<android.provider.Settings.Secure: long getLong(ContentResolver,String,long)>",0,"{
    String valString = getString(cr, name);
    long value;
    try {
        value = valString != null ? Long.parseLong(valString) : def;
    } catch (NumberFormatException e) {
        value = def;
    }
    return value;
}","{
    return getLongForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The early version uses exceptions to handle the null object and number format problem. However, in the late version, a different method is called with different parameters. This means the return statement, other statements, and the dependent APIs have all changed. Therefore, the change type is 1,4,5.","The change in the late version significantly alters the behavior of the function, returning a value from a different function. This could lead to the API potentially returning different values, so the compatibility issue type is 1."
478,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,16,17,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,<android.appwidget.AppWidgetHostView: void dispatchRestoreInstanceState(SparseArray<Parcelable>)>,0,"{
    final Parcelable parcelable = container.get(generateId());
    ParcelableSparseArray jail = null;
    if (parcelable != null && parcelable instanceof ParcelableSparseArray) {
        jail = (ParcelableSparseArray) parcelable;
    }
    if (jail == null)
        jail = new ParcelableSparseArray();
    super.dispatchRestoreInstanceState(jail);
}","{
    final Parcelable parcelable = container.get(generateId());
    ParcelableSparseArray jail = null;
    if (parcelable != null && parcelable instanceof ParcelableSparseArray) {
        jail = (ParcelableSparseArray) parcelable;
    }
    if (jail == null)
        jail = new ParcelableSparseArray();
    try {
        super.dispatchRestoreInstanceState(jail);
    } catch (Exception e) {
        Log.e(TAG, ""failed to restoreInstanceState for widget id: "" + mAppWidgetId + "", "" + (mInfo == null ? ""null"" : mInfo.provider), e);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"In the late version of the implementation, the code added an exception handling statement: 'catch (Exception e)', so the code change type is 2.","The exception handling statement could affect the output expectations of the method. If in case any exception occurred during the function execution, the early version doesn't have any exception handling. In the late version, the exception is caught and logged. This could break existing applications which use this function and expect it to either return a result or throw an exception. Therefore, the Compatibility Issue type is 2."
479,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,16,17,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,<android.text.TextDirectionHeuristics.TextDirectionHeuristicLocale: boolean defaultIsRtl()>,0,"{
    final int dir = LocaleUtil.getLayoutDirectionFromLocale(java.util.Locale.getDefault());
    return (dir == View.LAYOUT_DIRECTION_RTL);
}","{
    final int dir = TextUtils.getLayoutDirectionFromLocale(java.util.Locale.getDefault());
    return (dir == View.LAYOUT_DIRECTION_RTL);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The dependent API has changed from LocaleUtil's getLayoutDirectionFromLocale to TextUtils' getLayoutDirectionFromLocale, so the code change type is 5.","As the dependent API has changed, it might returns a different value which potentially leads to a different return value of the current API. Therefore, the compatibility issue type is 1."
480,<android.bluetooth.BluetoothDevice: int getBondState()>,16,17,<android.bluetooth.BluetoothDevice: int getBondState()>,<android.bluetooth.BluetoothDevice: int getBondState()>,0,"{
    try {
        return sService.getBondState(mAddress);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return BOND_NONE;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get bond state"");
        return BOND_NONE;
    }
    try {
        return sService.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    } catch (NullPointerException npe) {
        // Handle case where bluetooth service proxy
        // is already null.
        Log.e(TAG, ""NullPointerException for getBondState() of device ("" + getAddress() + "")"", npe);
    }
    return BOND_NONE;
}",1,"/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the bond state
 */
","/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the bond state
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,5","1,2","The condition statement (if (sService == null)) is added, the execution statement in the try block has changed from sService.getBondState(mAddress) to  sService.getBondState(this), and a new exception (NullPointerException) handling statement was added, so the code change type is 1,2,3,5.","The API might return a different value due to control dependency change, and throw a new type of exception, thus, the CI type is 1,2."
482,<android.view.View: boolean onTouchEvent(MotionEvent)>,16,17,<android.view.View: boolean onTouchEvent(MotionEvent)>,<android.view.View: boolean onTouchEvent(MotionEvent)>,0,"{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true);
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true);
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        setPressed(false);
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Observing the two versions, we can see that a method invoked on 'mPrivateFlags' has changed its parameter and a new statement (removeLongPressCallback()) has been added in MotionEvent.ACTION_CANCEL case. So, the code change type is 3,4.","The change in parameter and the addition of a new method in MotionEvent.ACTION_CANCEL case could potentially affect the value returned by the onTouchEvent() method in the late version, leading to a compatibility issue of type 1."
483,"<android.text.format.DateUtils: String getMonthString(int,int)>",16,17,"<android.text.format.DateUtils: String getMonthString(int,int)>","<android.text.format.DateUtils: String getMonthString(int,int)>",0,"{
    // Note that here we use sMonthsMedium for MEDIUM, SHORT and SHORTER.
    // This is a shortcut to not spam the translators with too many variations
    // of the same string.  If we find that in a language the distinction
    // is necessary, we can can add more without changing this API.
    int[] list;
    switch(abbrev) {
        case LENGTH_LONG:
            list = sMonthsLong;
            break;
        case LENGTH_MEDIUM:
            list = sMonthsMedium;
            break;
        case LENGTH_SHORT:
            list = sMonthsMedium;
            break;
        case LENGTH_SHORTER:
            list = sMonthsMedium;
            break;
        case LENGTH_SHORTEST:
            list = sMonthsShortest;
            break;
        default:
            list = sMonthsMedium;
            break;
    }
    Resources r = Resources.getSystem();
    return r.getString(list[month - Calendar.JANUARY]);
}","{
    // Note that here we use d.shortMonthNames for MEDIUM, SHORT and SHORTER.
    // This is a shortcut to not spam the translators with too many variations
    // of the same string.  If we find that in a language the distinction
    // is necessary, we can can add more without changing this API.
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longMonthNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORT:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTER:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyMonthNames;
            break;
        default:
            names = d.shortMonthNames;
            break;
    }
    return names[month];
}",1,"/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 */
","/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated use {@link java.text.SimpleDateFormat} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The dependent API has changed from 'Resources.getSystem().getString()' to LocaleData.get(Locale.getDefault()). Also, the assignment of list[names] has notably changed. The return statement 'return list[names][month-calendar.january]' in the early version was changed to 'return names[month]'. Therefore, the code changes are classified as 1,4,5.","Given that the value and type of the retrieved month name from 'names[month]' may differ from those retrieved using 'list[month - Calendar.JANUARY]', it renders the late version of the API potentially returning a different value compared to its early version, thereby leading to the compatibility issue identified as type 1."
484,<android.bluetooth.BluetoothA2dp: void close()>,16,17,<android.bluetooth.BluetoothA2dp: void close()>,<android.bluetooth.BluetoothA2dp: void close()>,0,"{
    mServiceListener = null;
}","{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, """", re);
            }
        }
    }
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",2,"The late version includes additional statements in conditional blocks, including unregisterStateChangeCallback method invocation and unbindService method invocation wrapped in try/catch blocks, therefore change type involves 3 and 4.","The late version introduces additional exception handling with the try/catch blocks, which could potentially lead to different exception handling behavior. Therefore, the CI type is 2."
486,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,16,17,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The implementation of the method has added a synchronized statement and an extra condition check on the mService object before calling the method mService.cancelDiscovery(). The changes in the method implementation are control dependencies changes, hence, the code change type is 3. ","Even though there is a change in the method implementation, there is no change in the return type or value of the method. If the preconditions are not met, the method returns false in both versions. If preconditions are met, both versions try to cancel the discovery and return the result or throw exception if a RemoteException occurs. Therefore, no compatibility issue exists, hence, the CI type is 0."
487,"<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>",16,17,"<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>","<android.bluetooth.BluetoothHealth: boolean registerSinkAppConfiguration(String,int,BluetoothHealthCallback)>",0,"{
    if (!isEnabled() || name == null)
        return false;
    if (DBG)
        log(""registerSinkApplication("" + name + "":"" + dataType + "")"");
    return registerAppConfiguration(name, dataType, SINK_ROLE, CHANNEL_TYPE_ANY, callback);
}","{
    if (!isEnabled() || name == null)
        return false;
    if (VDBG)
        log(""registerSinkApplication("" + name + "":"" + dataType + "")"");
    return registerAppConfiguration(name, dataType, SINK_ROLE, CHANNEL_TYPE_ANY, callback);
}",1,"/**
 * Register an application configuration that acts as a Health SINK.
 * This is the configuration that will be used to communicate with health devices
 * which will act as the {@link #SOURCE_ROLE}. This is an asynchronous call and so
 * the callback is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param name The friendly name associated with the application or configuration.
 * @param dataType The dataType of the Source role of Health Profile to which
 * the sink wants to connect to.
 * @param callback A callback to indicate success or failure of the registration and
 * all operations done on this application configuration.
 * @return If true, callback will be called.
 */
","/**
 * Register an application configuration that acts as a Health SINK.
 * This is the configuration that will be used to communicate with health devices
 * which will act as the {@link #SOURCE_ROLE}. This is an asynchronous call and so
 * the callback is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param name The friendly name associated with the application or configuration.
 * @param dataType The dataType of the Source role of Health Profile to which
 * the sink wants to connect to.
 * @param callback A callback to indicate success or failure of the registration and
 * all operations done on this application configuration.
 * @return If true, callback will be called.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only difference between the two versions is that the debug log constant has changed from DBG to VDBG. This is neither a return, exception, control dependency, or dependent API change, but falls under the category of Other statement changed.","Changing debug logs does not affect the behavior of the API, therefore there is no compatibility issue."
488,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,16,17,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,<android.app.ApplicationPackageManager: Resources getResourcesForApplication(ApplicationInfo)>,0,"{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    Resources r = mContext.mMainThread.getTopLevelResources(app.uid == Process.myUid() ? app.sourceDir : app.publicSourceDir, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}","{
    if (app.packageName.equals(""system"")) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    Resources r = mContext.mMainThread.getTopLevelResources(app.uid == Process.myUid() ? app.sourceDir : app.publicSourceDir, Display.DEFAULT_DISPLAY, null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
    throw new NameNotFoundException(""Unable to open "" + app.publicSourceDir);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed due to the method call getTopLevelResources() with different arguments, besides, the method getTopLevelResources() itself also changed (Dependent API changed), so the code change type is 1,5.","As the return value of 'getTopLevelResources()' could be different due to different arguments, the potential returned resource by 'getResourcesForApplication' is changed, hence the CI type is 1."
489,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,16,17,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,0,"{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                if (f.onOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The condition statements and the call of dependent API have changed from f.onOptionsItemSelected(item) to f.performOptionsItemSelected(item). So the code change type is 3,4,5.","Due to the change in condition statements and the dependent API change, there is a potential difference in the returned values. So the CI type is 1."
490,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,16,17,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,<android.view.ViewPropertyAnimator.AnimatorEventListener: void onAnimationUpdate(ValueAnimator)>,0,"{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
}","{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
}",1,"/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
","/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only change in the method between versions is ""View.DRAWN"" being replaced by ""View.PFLAG_DRAWN"". So, the change belongs to category 4: Other statement changed.","Despite the statement change, it doesn't result in potential different return values or exceptions being thrown by the API. Therefore, no Compatibility Issue exist."
491,"<android.app.ContextImpl: void startActivities(Intent[],Bundle)>",16,17,"<android.app.ContextImpl: void startActivities(Intent[],Bundle)>","<android.app.ContextImpl: void startActivities(Intent[],Bundle)>",0,"{
    if ((intents[0].getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivities() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag on first Intent."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivities(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intents, options);
}","{
    warnIfCallingFromSystemProcess();
    if ((intents[0].getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivities() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag on first Intent."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivities(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intents, options);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,2,"The method ""warnIfCallingFromSystemProcess();"" has been introduced at the start. This method potentially call the system process and throws an exception if called from the system process. Therefore, the code change type is 3 (Control dependency change).","The added ""warnIfCallingFromSystemProcess();"" may cause the method to throw an exception in some scenarios where it would not have thrown an exception in the early version. Therefore, the compatibility issue type is 2 (Compatibility Issue caused by potentially different exceptions handling)."
492,<android.net.SSLCertificateSocketFactory: byte[] getNpnSelectedProtocol(Socket)>,16,17,<android.net.SSLCertificateSocketFactory: byte[] getNpnSelectedProtocol(Socket)>,<android.net.SSLCertificateSocketFactory: byte[] getNpnSelectedProtocol(Socket)>,0,"{
    return ((OpenSSLSocketImpl) socket).getNpnSelectedProtocol();
}","{
    return castToOpenSSLSocket(socket).getNpnSelectedProtocol();
}",1,"/**
 * Returns the <a href=""http://technotes.googlecode.com/git/nextprotoneg.html"">Next
 * Protocol Negotiation (NPN)</a> protocol selected by client and server, or
 * null if no protocol was negotiated.
 *
 * @param socket a socket created by this factory.
 */
","/**
 * Returns the <a href=""http://technotes.googlecode.com/git/nextprotoneg.html"">Next
 * Protocol Negotiation (NPN)</a> protocol selected by client and server, or
 * null if no protocol was negotiated.
 *
 * @param socket a socket created by this factory.
 * @throws IllegalArgumentException if the socket was not created by this factory.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from ((OpenSSLSocketImpl) socket).getNpnSelectedProtocol() to castToOpenSSLSocket(socket).getNpnSelectedProtocol(), and also the dependent API has changed, so the code change type is 1,5.","As the return statement changed, the API may potentially return a different value, leading to a compatibility issue. Therefore, the CI type is 1."
493,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",16,17,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    return bindService(service, conn, flags, UserId.getUserId(Process.myUid()));
}","{
    warnIfCallingFromSystemProcess();
    return bindService(service, conn, flags, UserHandle.getUserId(Process.myUid()));
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"A new statement, 'warnIfCallingFromSystemProcess();', was added to the latest implementation and the dependent API 'UserId.getUserId()' changed to 'UserHandle.getUserId()', so the change type is 4,5.","The additional 'warnIfCallingFromSystemProcess();' operation could modify the state of the program, potentially influence the return statement, so CI type is 1. Also, the change of the dependent API 'UserId.getUserId()' to 'UserHandle.getUserId()' might possibly return a different value, causing CI type 1."
494,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,16,17,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,0,"{
    boolean show = false;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onPrepareOptionsMenu(menu);
            }
        }
    }
    return show;
}","{
    boolean show = false;
    if (mAdded != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null) {
                if (f.performPrepareOptionsMenu(menu)) {
                    show = true;
                }
            }
        }
    }
    return show;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if condition inside the for loop has changed, and the 'f.onPrepareOptionsMenu(menu);' statement in early implementation version has changed to 'if (f.performPrepareOptionsMenu(menu)) { show = true; }' in the late version. So the code changes belong to category 1 and 3.","As the implementation change can effect the return value, despite the actual outcome of 'boolean show', it is still a potential different return value situation, so the API potentially returns a different variable, hence falling under category 1 of Compatibility Issue."
495,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,<android.app.admin.DevicePolicyManager: int getMaximumFailedPasswordsForWipe(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getMaximumFailedPasswordsForWipe(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getMaximumFailedPasswordsForWipe(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current maximum number of login attempts that are allowed
 * before the device wipes itself, for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
","/**
 * Retrieve the current maximum number of login attempts that are allowed
 * before the device wipes itself, for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return mService.getMaximumFailedPasswordsForWipe(admin);' to 'return getMaximumFailedPasswordsForWipe(admin, UserHandle.myUserId());' and the parameters for the 'getMaximumFailedPasswordsForWipe()' method have also changed, so the code change type is 1,5.","The change in the return statement will make the API potentially return different values, so the CI type is 1."
497,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",16,17,"<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>","<android.view.GLES20Canvas: void drawHardwareLayer(HardwareLayer,float,float,Paint)>",0,"{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    try {
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
    } finally {
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
    }
}","{
    final GLES20Layer glLayer = (GLES20Layer) layer;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawLayer(mRenderer, glLayer.getLayer(), x, y, nativePaint);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code change lies in the deletion of condition control statements and related variable 'modifier', added in the Early Version, which then updates the 'nativePaint' directly in the Late Version. Therefore, the code change types are 3,4.","Though code change exists, it does not affect the return value or the exceptions of the method, thus no compatibility issue exists in this change. Hence, the CI type is 0."
498,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",16,17,"<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>","<android.app.ContextImpl.ApplicationContentResolver: IContentProvider acquireExistingProvider(Context,String)>",0,"{
    return mMainThread.acquireExistingProvider(context, name, true);
}","{
    return mMainThread.acquireExistingProvider(context, auth, mUser.getIdentifier(), true);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method ""acquireExistingProvider"" has changed the parameters it takes. As a result, the dependent API ""mMainThread.acquireExistingProvider"" has changed. So, the code change types are 1 and 5.","In the late version, the additional parameter ""mUser.getIdentifier()"" introduced could potentially change the return value of ""acquireExistingProvider"". Therefore, it could cause a compatibility issue where the API potentially returns a different value. Hence, the CI type is 1."
499,<android.widget.RemoteViews: RemoteViews clone()>,16,17,<android.widget.RemoteViews: RemoteViews clone()>,<android.widget.RemoteViews: RemoteViews clone()>,0,"{
    RemoteViews that;
    if (!hasLandscapeAndPortraitLayouts()) {
        that = new RemoteViews(mPackage, mLayoutId);
        if (mActions != null) {
            that.mActions = (ArrayList<Action>) mActions.clone();
        }
    } else {
        RemoteViews land = mLandscape.clone();
        RemoteViews port = mPortrait.clone();
        that = new RemoteViews(land, port);
    }
    // update the memory usage stats of the cloned RemoteViews
    that.recalculateMemoryUsage();
    return that;
}","{
    Parcel p = Parcel.obtain();
    writeToParcel(p, 0);
    p.setDataPosition(0);
    return new RemoteViews(p);
}",1,,,-1,[@Override],,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of cloning has changed completely. It has gone from using a conditional statement and a recursive clone approach to using a Parcel-based way to achieve the same. This is an ""other statement change"" (4) and also a ""dependent API changed"" (5) as it introduces a new method ""writeToParcel(p, 0)"" and ""Parcel.obtain()"".","The change introduced completely new behaviours for the function, potentially leading to different returned 'RemoteViews' compared to the early version. Therefore, the compatibility issue is ""caused by potential different return values"" (1)."
500,<android.app.ActivityManager: void killBackgroundProcesses(String)>,16,17,<android.app.ActivityManager: void killBackgroundProcesses(String)>,<android.app.ActivityManager: void killBackgroundProcesses(String)>,0,"{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName);
    } catch (RemoteException e) {
    }
}","{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}",1,"/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
","/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the late version, a new parameter UserHandle.myUserId() is added to the Api killBackgroundProcesses(), this change belongs to dependent API change, type 5. Also, the line of code executing the API call has changed, which corresponds to type 1, Return statement changed.","The change of the dependent API and the relevant code execution can result in a different return behaviour, which can potentially lead to a compatibility issue. Thus, the CI type is 1."
501,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",16,17,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, false, COMPONENT_ENABLED_STATE_DEFAULT);
}","{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    PackageUserState state = new PackageUserState();
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"A new statement 'PackageUserState state = new PackageUserState();' is introduced and return statement changes from 'return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, false);' to 'return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);', so the code change type is 1.","As the parameters of the function 'PackageParser.generatePackageInfo' has changed, the return values may be different between the two API versions, so the CI type is 1."
502,<android.content.res.Configuration: int diff(Configuration)>,16,17,<android.content.res.Configuration: int diff(Configuration)>,<android.content.res.Configuration: int diff(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
        changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {
        changed |= ActivityInfo.CONFIG_DENSITY;
    }
    return changed;
}",1,"/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 */
","/**
 * Return a bit mask of the differences between this Configuration
 * object and the given one.  Does not change the values of either.  Any
 * undefined fields in <var>delta</var> are ignored.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of
 * {@link android.content.pm.ActivityInfo#CONFIG_FONT_SCALE
 * PackageManager.ActivityInfo.CONFIG_FONT_SCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_MCC
 * PackageManager.ActivityInfo.CONFIG_MCC},
 * {@link android.content.pm.ActivityInfo#CONFIG_MNC
 * PackageManager.ActivityInfo.CONFIG_MNC},
 * {@link android.content.pm.ActivityInfo#CONFIG_LOCALE
 * PackageManager.ActivityInfo.CONFIG_LOCALE},
 * {@link android.content.pm.ActivityInfo#CONFIG_TOUCHSCREEN
 * PackageManager.ActivityInfo.CONFIG_TOUCHSCREEN},
 * {@link android.content.pm.ActivityInfo#CONFIG_KEYBOARD
 * PackageManager.ActivityInfo.CONFIG_KEYBOARD},
 * {@link android.content.pm.ActivityInfo#CONFIG_NAVIGATION
 * PackageManager.ActivityInfo.CONFIG_NAVIGATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_ORIENTATION
 * PackageManager.ActivityInfo.CONFIG_ORIENTATION},
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_LAYOUT
 * PackageManager.ActivityInfo.CONFIG_SCREEN_LAYOUT}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SCREEN_SIZE}, or
 * {@link android.content.pm.ActivityInfo#CONFIG_SMALLEST_SCREEN_SIZE
 * PackageManager.ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE}.
 * {@link android.content.pm.ActivityInfo#CONFIG_LAYOUT_DIRECTION
 * PackageManager.ActivityInfo.CONFIG_LAYOUT_DIRECTION}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"There are several changes between the early version and the late version. A new line 'changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;' is added, which is a 'return' statement change. The condition statement 'screenLayout != delta.screenLayout' is changed to 'getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout)', which is a 'control dependency' change. Two new lines 'if (delta.densityDpi != DENSITY_DPI_UNDEFINED && densityDpi != delta.densityDpi) {changed |= ActivityInfo.CONFIG_DENSITY;}' are added, which are 'other statements' change. Thus, the code change type is 1,3,4.","The added 'return' statement, 'control dependency' change and the introduced new lines can cause the 'changed' variable possibly change, which is the return value of the API. Thus, the return value of the late version could be different from the early version, causing a potential compatibility issue. Therefore, the CI type is 1."
503,<android.view.ViewTreeObserver: void dispatchOnComputeInternalInsets(InternalInsetsInfo)>,16,17,<android.view.ViewTreeObserver: void dispatchOnComputeInternalInsets(InternalInsetsInfo)>,<android.view.ViewTreeObserver: void dispatchOnComputeInternalInsets(InternalInsetsInfo)>,0,"{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArrayList<OnComputeInternalInsetsListener> listeners = mOnComputeInternalInsetsListeners;
    if (listeners != null && listeners.size() > 0) {
        for (OnComputeInternalInsetsListener listener : listeners) {
            listener.onComputeInternalInsets(inoutInfo);
        }
    }
}","{
    // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
    // perform the dispatching. The iterator is a safe guard against listeners that
    // could mutate the list by calling the various add/remove methods. This prevents
    // the array from being modified while we iterate it.
    final CopyOnWriteArray<OnComputeInternalInsetsListener> listeners = mOnComputeInternalInsetsListeners;
    if (listeners != null && listeners.size() > 0) {
        CopyOnWriteArray.Access<OnComputeInternalInsetsListener> access = listeners.start();
        try {
            int count = access.size();
            for (int i = 0; i < count; i++) {
                access.get(i).onComputeInternalInsets(inoutInfo);
            }
        } finally {
            listeners.end();
        }
    }
}",1,"/**
 * Calls all listeners to compute the current insets.
 */
","/**
 * Calls all listeners to compute the current insets.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",0,"The statement to initialize the variable 'listeners' is changed, and the 'for each' statement is also changed to 'for' statement, so the code change type is 3 and 4. Moreover, the type of 'listeners' has changed from 'CopyOnWriteArrayList' to 'CopyOnWriteArray', thus the dependent API has also been changed, so the code change type also includes 5.","Despite these changes, the outcome of the method will remain the same. The list of listeners (if not null) will still have the `onComputeInternalInsets` method called based on the iteration through the list. Since this doesn't alter the return behaviour or exception handling behaviour, there is no compatibility issue in this case. So the CI type is 0."
504,<android.os.Environment: File getExternalStorageDirectory()>,16,17,<android.os.Environment: File getExternalStorageDirectory()>,<android.os.Environment: File getExternalStorageDirectory()>,0,"{
    return EXTERNAL_STORAGE_DIRECTORY;
}","{
    throwIfSystem();
    return sCurrentUser.getExternalStorageDirectory();
}",1,"/**
 * Gets the Android external storage directory.  This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened.  You can determine its current state with
 * {@link #getExternalStorageState()}.
 *
 * <p><em>Note: don't be confused by the word ""external"" here.  This
 * directory can better be thought as media/shared storage.  It is a
 * filesystem that can hold a relatively large amount of data and that
 * is shared across all applications (does not enforce permissions).
 * Traditionally this is an SD card, but it may also be implemented as
 * built-in storage in a device that is distinct from the protected
 * internal storage and can be mounted as a filesystem on a computer.</em></p>
 *
 * <p>In devices with multiple ""external"" storage directories (such as
 * both secure app storage and mountable shared storage), this directory
 * represents the ""primary"" external storage that the user will interact
 * with.</p>
 *
 * <p>Applications should not directly use this top-level directory, in
 * order to avoid polluting the user's root namespace.  Any files that are
 * private to the application should be placed in a directory returned
 * by {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled.  Other shared files should be placed
 * in one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.
 *
 * <p>Here is an example of typical code to monitor the state of
 * external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
","/**
 * Gets the Android external storage directory.  This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened.  You can determine its current state with
 * {@link #getExternalStorageState()}.
 *
 * <p><em>Note: don't be confused by the word ""external"" here.  This
 * directory can better be thought as media/shared storage.  It is a
 * filesystem that can hold a relatively large amount of data and that
 * is shared across all applications (does not enforce permissions).
 * Traditionally this is an SD card, but it may also be implemented as
 * built-in storage in a device that is distinct from the protected
 * internal storage and can be mounted as a filesystem on a computer.</em></p>
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>In devices with multiple ""external"" storage directories (such as
 * both secure app storage and mountable shared storage), this directory
 * represents the ""primary"" external storage that the user will interact
 * with.</p>
 *
 * <p>Applications should not directly use this top-level directory, in
 * order to avoid polluting the user's root namespace.  Any files that are
 * private to the application should be placed in a directory returned
 * by {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled.  Other shared files should be placed
 * in one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.</p>
 *
 * <p>Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission. In
 * a future platform release, access to this path will require the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.</p>
 *
 * <p>This path may change between platform versions, so applications
 * should only persist relative paths.</p>
 *
 * <p>Here is an example of typical code to monitor the state of
 * external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2","1,2","A new 'throw' statement throwIfSystem() is added and the return statement has changed: The value that is returned in the late version is now sCurrentUser.getExternalStorageDirectory() whereas in the early version it was EXTERNAL_STORAGE_DIRECTORY. Hence, the code change types are 1,2.","The addition of a new exception throwIfSystem() and the change in returned variable can cause different behaviors. Hence, the compatibility issue types are 1,2."
505,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",16,17,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>","<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
","/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The API call in the try block has changed from ViewRootImpl.getWindowSession to WindowManagerGlobal.getWindowSession, but the parameters and the variable it returns are unchanged, so the code change type is 5.","As the change in the dependent API wouldn't lead to different behaviour, there is no compatibility issue, hence the CI type is 0."
506,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNonLetter(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNonLetter(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of non-letter characters (numerical digits or symbols)
 * required in the password. After setting this, the user will not be able
 * to enter a new password that is not at least as restrictive as what has
 * been set. Note that the current password will remain until the user has
 * set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator
 * has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of non-letter characters (numerical digits or symbols)
 * required in the password. After setting this, the user will not be able
 * to enter a new password that is not at least as restrictive as what has
 * been set. Note that the current password will remain until the user has
 * set a new one, so the change does not take place immediately. To prompt
 * the user for a new password, use {@link #ACTION_SET_NEW_PASSWORD} after
 * setting this value. This constraint is only imposed if the administrator
 * has also requested {@link #PASSWORD_QUALITY_COMPLEX} with
 * {@link #setPasswordQuality}. The default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of letters required in the
 * password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method ""setPasswordMinimumNonLetter(admin, length)"" is changed to ""setPasswordMinimumNonLetter(admin, length, UserHandle.myUserId())"". It introduces a new argument UserHandle.myUserId() in the later implementation. This indicates the change type is 1, 5.",The change in the dependent API potentially changes the behaviour of the method which could in turn affect the return type or value. Thus the Compatibility Issue is 1.
507,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",16,17,"<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView createView(Context,int,AppWidgetProviderInfo)>",0,"{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}","{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
    view.updateAppWidget(views);
    return view;
}",1,"/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
","/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There's an additional method call 'view.setOnClickHandler(mOnClickHandler)' in the late implementation, which isn't a change in return, exception handling or dependent API, so the code change type is 4.","Even though the method call 'view.setOnClickHandler(mOnClickHandler)' was added in the late implementation, it will not possibly lead to return different values or throw different exceptions between two versions of API, so no compatibility issue exists, classify the CI type as 0."
508,"<android.widget.Spinner: void layout(int,boolean)>",16,17,"<android.widget.Spinner: void layout(int,boolean)>","<android.widget.Spinner: void layout(int,boolean)>",0,"{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition);
    int width = sel.getMeasuredWidth();
    int selectedOffset = childrenLeft;
    switch(mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
        case Gravity.CENTER_HORIZONTAL:
            selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
            break;
        case Gravity.RIGHT:
            selectedOffset = childrenLeft + childrenWidth - width;
            break;
    }
    sel.offsetLeftAndRight(selectedOffset);
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}","{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle the empty set by removing all views
    if (mItemCount == 0) {
        resetList();
        return;
    }
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    recycleAllViews();
    // Clear out old views
    removeAllViewsInLayout();
    // Make selected view and position it
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition);
    int width = sel.getMeasuredWidth();
    int selectedOffset = childrenLeft;
    final int layoutDirection = getLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
        case Gravity.CENTER_HORIZONTAL:
            selectedOffset = childrenLeft + (childrenWidth / 2) - (width / 2);
            break;
        case Gravity.RIGHT:
            selectedOffset = childrenLeft + childrenWidth - width;
            break;
    }
    sel.offsetLeftAndRight(selectedOffset);
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
}",1,"/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 moves selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Spinner.
 *
 * @param delta Change in the selected position. +1 means selection is moving to the right,
 * so views are scrolling to the left. -1 means selection is moving to the left.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Two statements have been added in the later version, introducing the 'layoutDirection' and 'absoluteGravity' variables. It is not a change in the return, exception handling, control dependency, or dependent APIs. Hence, it belongs to category 4.","Although the implementation has changed, it doesn't alter the behavior of the function. The added variables are used to handle the positioning of elements in different layouts, which doesn't affect the return or exception handling of the method. Thus, it doesn't cause any compatibility issue."
509,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,16,17,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,<android.app.admin.DevicePolicyManager: boolean isActivePasswordSufficient()>,0,"{
    if (mService != null) {
        try {
            return mService.isActivePasswordSufficient();
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}","{
    if (mService != null) {
        try {
            return mService.isActivePasswordSufficient(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return false;
}",1,"/**
 * Determine whether the current password the user has set is sufficient
 * to meet the policy requirements (quality, minimum length) that have been
 * requested.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @return Returns true if the password meets the current requirements,
 * else false.
 */
","/**
 * Determine whether the current password the user has set is sufficient
 * to meet the policy requirements (quality, minimum length) that have been
 * requested.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @return Returns true if the password meets the current requirements,
 * else false.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The ""return"" statement changes from return mService.isActivePasswordSufficient() to return mService.isActivePasswordSufficient(UserHandle.myUserId()), and an additional parameter is included while calling the ""isActivePasswordSufficient()"" method which is the dependent API, so the change types are 1,5.","This change of return statement could potentially lead to different return values, because the value of 'UserHandle.myUserId()' could affect the result of 'mService.isActivePasswordSufficient()', so the API could return a different value, and the CI type is 1."
510,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",16,17,"<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>","<android.app.FragmentManagerImpl: Fragment getFragment(Bundle,String)>",0,"{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    if (index >= mActive.size()) {
        throw new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index);
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throw new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index);
    }
    return f;
}","{
    int index = bundle.getInt(key, -1);
    if (index == -1) {
        return null;
    }
    if (index >= mActive.size()) {
        throwException(new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index));
    }
    Fragment f = mActive.get(index);
    if (f == null) {
        throwException(new IllegalStateException(""Fragement no longer exists for key "" + key + "": index "" + index));
    }
    return f;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,5","1,2","The way to throw exception in the code has changed from 'throw new IllegalStateException...' to 'throwException(new IllegalStateException...)'. The beheaviour of 'throwException()' method is unknown and this method seems relied on another API, so, the code change is classified as 2,5.","The way to throw exception has changed and the dependent API has changed, potentially leads to different behaviours. So, the CI is classified as 1,2."
511,"<android.view.TextureView: Bitmap getBitmap(int,int)>",16,17,"<android.view.TextureView: Bitmap getBitmap(int,int)>","<android.view.TextureView: Bitmap getBitmap(int,int)>",0,"{
    if (isAvailable() && width > 0 && height > 0) {
        return getBitmap(Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888));
    }
    return null;
}","{
    if (isAvailable() && width > 0 && height > 0) {
        return getBitmap(Bitmap.createBitmap(getResources().getDisplayMetrics(), width, height, Bitmap.Config.ARGB_8888));
    }
    return null;
}",1,"/**
 * <p>Returns a {@link android.graphics.Bitmap} representation of the content
 * of the associated surface texture. If the surface texture is not available,
 * this method returns null.</p>
 *
 * <p>The bitmap returned by this method uses the {@link Bitmap.Config#ARGB_8888}
 * pixel format.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs during the copy, an empty bitmap will be returned.</p>
 *
 * @param width The width of the bitmap to create
 * @param height The height of the bitmap to create
 *
 * @return A valid {@link Bitmap.Config#ARGB_8888} bitmap, or null if the surface
 * texture is not available or width is &lt;= 0 or height is &lt;= 0
 *
 * @see #isAvailable()
 * @see #getBitmap(android.graphics.Bitmap)
 * @see #getBitmap()
 */
","/**
 * <p>Returns a {@link android.graphics.Bitmap} representation of the content
 * of the associated surface texture. If the surface texture is not available,
 * this method returns null.</p>
 *
 * <p>The bitmap returned by this method uses the {@link Bitmap.Config#ARGB_8888}
 * pixel format.</p>
 *
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 *
 * <p>If an error occurs during the copy, an empty bitmap will be returned.</p>
 *
 * @param width The width of the bitmap to create
 * @param height The height of the bitmap to create
 *
 * @return A valid {@link Bitmap.Config#ARGB_8888} bitmap, or null if the surface
 * texture is not available or width is &lt;= 0 or height is &lt;= 0
 *
 * @see #isAvailable()
 * @see #getBitmap(android.graphics.Bitmap)
 * @see #getBitmap()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation of the method 'getBitmap(...)' has changed where the method it calls 'Bitmap.createBitmap(...)' has different parameters. Hence, the code change types are 1 and 5.","The altered return statement in the 'if' block can result in a different return variable. The dependency on 'getResources().getDisplayMetrics()' in the method 'Bitmap.createBitmap(...)' also contributes to the modification of behavior. Thus, the Compatibility Issue exists due to the potential different return values (CI type 1)."
512,"<android.provider.Settings.System: String getString(ContentResolver,String)>",16,17,"<android.provider.Settings.System: String getString(ContentResolver,String)>","<android.provider.Settings.System: String getString(ContentResolver,String)>",0,"{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, returning read-only value."");
        return Secure.getString(resolver, name);
    }
    if (sNameValueCache == null) {
        sNameValueCache = new NameValueCache(SYS_PROP_SETTING_VERSION, CONTENT_URI, CALL_METHOD_GET_SYSTEM);
    }
    return sNameValueCache.getString(resolver, name);
}","{
    return getStringForUser(resolver, name, UserHandle.myUserId());
}",1,"/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
","/**
 * Look up a name in the database.
 * @param resolver to access the database with
 * @param name to look up in the table
 * @return the corresponding value, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The new version of the method does not use sNameValueCache and does not check if the name is contained in MOVED_TO_SECURE but instead calls the getStringForUser method. This implies that both return statement and the dependent API was changed, so the code change type is 1,5.","Because of the change in return statements and the depending method, the behavior of the API could be different, thus potentially returning different values, so the CI type is 1."
513,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,16,17,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                if (pointerIndex == -1) {
                    Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"");
                    break;
                }
                final int x = (int) ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final int x = (int) ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                postInvalidateOnAnimation();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = (int) ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = (int) ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new log statement (Log.e(TAG, ""Invalid pointerId="" + activePointerId + "" in onInterceptTouchEvent"")) has been added so the code change type is 4.","The added log statement will not change the behaviour of the API in terms of return values and exceptions, so no Compatibility Issue exists."
514,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,<android.app.admin.DevicePolicyManager: long getMaximumTimeToLock(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getMaximumTimeToLock(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getMaximumTimeToLock(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current maximum time to unlock for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
","/**
 * Retrieve the current maximum time to unlock for all admins
 * or a particular one.
 * @param admin The name of the admin component to check, or null to aggregate
 * all admins.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, the function return value is either obtained by the getMaximumTimeToLock method in the mService instance, or 0. However, in the late version, the return value is directly obtained through the getMaximumTimeToLock method, which accepts two parameters. Thus the change belongs to types 5 (Dependent API changed) and 1 (Return statement changed).","The changes in the return value of the function could cause different behaviours when calling this function between two versions. Hence, it falls under the Compatibility Issue type 1, which signifies a potential change in returned values or types."
516,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,16,17,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,<android.provider.CalendarContract.EventsEntity.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,0,"{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_PACKAGE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_URI);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            attendeeValues.put(Attendees.ATTENDEE_IDENTITY, subCursor.getInt(COLUMN_ATTENDEE_IDENTITY));
            attendeeValues.put(Attendees.ATTENDEE_ID_NAMESPACE, subCursor.getInt(COLUMN_ATTENDEE_ID_NAMESPACE));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}","{
    // we expect the cursor is already at the row we need to read from
    final long eventId = cursor.getLong(cursor.getColumnIndexOrThrow(Events._ID));
    ContentValues cv = new ContentValues();
    cv.put(Events._ID, eventId);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, CALENDAR_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, TITLE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DESCRIPTION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_LOCATION);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, STATUS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, SELF_ATTENDEE_STATUS);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTSTART);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DTEND);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DURATION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EVENT_END_TIMEZONE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ALL_DAY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ACCESS_LEVEL);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, AVAILABILITY);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_ALARM);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, HAS_EXTENDED_PROPERTIES);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, RDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXRULE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, EXDATE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_SYNC_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORIGINAL_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, ORIGINAL_INSTANCE_TIME);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, ORIGINAL_ALL_DAY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_DATE);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, HAS_ATTENDEE_DATA);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_INVITE_OTHERS);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_MODIFY);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, GUESTS_CAN_SEE_GUESTS);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_PACKAGE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CUSTOM_APP_URI);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, UID_2445);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, IS_ORGANIZER);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, _SYNC_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, LAST_SYNCED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC_DATA10);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC4);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC5);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC6);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC7);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC8);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC9);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CAL_SYNC10);
    Entity entity = new Entity(cv);
    Cursor subCursor;
    if (mResolver != null) {
        subCursor = mResolver.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Reminders.CONTENT_URI, REMINDERS_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues reminderValues = new ContentValues();
            reminderValues.put(Reminders.MINUTES, subCursor.getInt(COLUMN_MINUTES));
            reminderValues.put(Reminders.METHOD, subCursor.getInt(COLUMN_METHOD));
            entity.addSubValue(Reminders.CONTENT_URI, reminderValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(Attendees.CONTENT_URI, ATTENDEES_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues attendeeValues = new ContentValues();
            attendeeValues.put(Attendees.ATTENDEE_NAME, subCursor.getString(COLUMN_ATTENDEE_NAME));
            attendeeValues.put(Attendees.ATTENDEE_EMAIL, subCursor.getString(COLUMN_ATTENDEE_EMAIL));
            attendeeValues.put(Attendees.ATTENDEE_RELATIONSHIP, subCursor.getInt(COLUMN_ATTENDEE_RELATIONSHIP));
            attendeeValues.put(Attendees.ATTENDEE_TYPE, subCursor.getInt(COLUMN_ATTENDEE_TYPE));
            attendeeValues.put(Attendees.ATTENDEE_STATUS, subCursor.getInt(COLUMN_ATTENDEE_STATUS));
            attendeeValues.put(Attendees.ATTENDEE_IDENTITY, subCursor.getString(COLUMN_ATTENDEE_IDENTITY));
            attendeeValues.put(Attendees.ATTENDEE_ID_NAMESPACE, subCursor.getString(COLUMN_ATTENDEE_ID_NAMESPACE));
            entity.addSubValue(Attendees.CONTENT_URI, attendeeValues);
        }
    } finally {
        subCursor.close();
    }
    if (mResolver != null) {
        subCursor = mResolver.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    } else {
        subCursor = mProvider.query(ExtendedProperties.CONTENT_URI, EXTENDED_PROJECTION, WHERE_EVENT_ID, new String[] { Long.toString(eventId) }, /* selectionArgs */
        null);
    }
    try {
        while (subCursor.moveToNext()) {
            ContentValues extendedValues = new ContentValues();
            extendedValues.put(ExtendedProperties._ID, subCursor.getString(COLUMN_ID));
            extendedValues.put(ExtendedProperties.NAME, subCursor.getString(COLUMN_NAME));
            extendedValues.put(ExtendedProperties.VALUE, subCursor.getString(COLUMN_VALUE));
            entity.addSubValue(ExtendedProperties.CONTENT_URI, extendedValues);
        }
    } finally {
        subCursor.close();
    }
    cursor.moveToNext();
    return entity;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
517,<android.bluetooth.BluetoothSocket: void close()>,16,17,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    // abort blocking operations on the socket
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            return;
        if (mSdp != null) {
            mSdp.cancel();
        }
        abortNative();
    } finally {
        mLock.readLock().unlock();
    }
    // all native calls are guaranteed to immediately return after
    // abortNative(), so this lock should immediately acquire
    mLock.writeLock().lock();
    try {
        mSocketState = SocketState.CLOSED;
        destroyNative();
    } finally {
        mLock.writeLock().unlock();
    }
}","{
    Log.d(TAG, ""close() in, this: "" + this + "", channel: "" + mPort + "", state: "" + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (VDBG)
                Log.d(TAG, ""close() this: "" + this + "", channel: "" + mPort + "", mSocketIS: "" + mSocketIS + "", mSocketOS: "" + mSocketOS + ""mSocket: "" + mSocket);
            if (mSocket != null) {
                if (VDBG)
                    Log.d(TAG, ""Closing mSocket: "" + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null)
                mPfd.detachFd();
        }
    }
// TODO(BT) unbind proxy,
}",1,"/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Return statements remain the same in both versions, but the whole implementation logic has changed, with several method calls like `mSocket.shutdownInput()`, `mSocket.shutdownOutput()`, and `mSocket.close()` added, and several method calls like `mSdp.cancel()` and `abortNative()` removed. Hence, the change is classified as Both 1)Return statement changed and 4)Other statement changed.","Since the implementations of the API have largely changed, it's plausible that the late version of the API will behave differently from the early version. Especially, the `void close()` method may potentially manipulate IO streams in a different way (as the inner calls to shutdown input, output, and close socket have been added to the late version). Thus, this is classified as 1) Compatibility Issue caused by potential different return values or types."
522,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,16,17,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,0,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}","{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event, mUserId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change happens on the statement to call mService.sendAccessibilityEvent(event). In the late version, an extra parameter mUserId is added. So, the change types are 4 and 5.","The added parameter in the sendAccessibilityEvent call will potentially affect the behaviour of this method, and consequently, different results may be returned. Therefore, the Compatibility Issue type lies in category 1, which is defined by potential different return values or types."
523,<android.os.PowerManager: void reboot(String)>,16,17,<android.os.PowerManager: void reboot(String)>,<android.os.PowerManager: void reboot(String)>,0,"{
    try {
        mService.reboot(reason);
    } catch (RemoteException e) {
    }
}","{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
    }
}",1,"/**
 * Reboot the device.  Will not return if the reboot is
 * successful.  Requires the {@link android.Manifest.permission#REBOOT}
 * permission.
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 */
","/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., ""recovery"") to
 * request special boot modes, or null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method ""reboot"" in the dependent API ""mService"" has changed from ""reboot(reason)"" to ""reboot(false, reason, true)"", so the code change type is 5.","Although the method ""reboot"" in ""mService"" has changed, it doesn't impact on the potential behaviour of the current API as it does not lead to change in return values or exception handlings. Therefore, no CI exists (CI type is 0)."
525,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>",16,17,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>","<android.provider.Settings.Secure: float getFloat(ContentResolver,String)>",0,"{
    String v = getString(cr, name);
    if (v == null) {
        throw new SettingNotFoundException(name);
    }
    try {
        return Float.parseFloat(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getFloatForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The entire method's implementation has been replaced with a single return statement that calls a different method. The invoked method has changed from getString() and Float.parseFloat() to getFloatForUser(). Therefore, the change types are 1 (Return statement changed) and 5 (Dependent API changed).","As the called API in return statement has been changed, this change potentially leads to the method returning a different value. Moreover, the early implementation could throw a SettingNotFoundException when certain conditions are reached, but the late version does not specify any exception handling mechanism. It could lead to different exception handling situations between two versions. Therefore, the Compatibility Issue types are 1 (Compatibility Issue caused by potential different return values or types) and 2 (Compatibility Issue caused by potential different exception handlings)."
526,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,16,17,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,<android.app.FragmentManagerImpl: Bundle saveFragmentBasicState(Fragment)>,0,"{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.onSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}","{
    Bundle result = null;
    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }
    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it's not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the implementation of the API, 'f.onSaveInstanceState(mStateBundle);' has been changed to 'f.performSaveInstanceState(mStateBundle);', so the change type is 1,5.","The return value of the method can be influenced by the different behaviour of the the replaced code, thus the CI type is 1."
528,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,16,17,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,<android.speech.tts.TextToSpeechService.SynthesisSpeechItem: boolean isValid()>,0,"{
    if (mText == null) {
        Log.wtf(TAG, ""Got null text"");
        return false;
    }
    if (mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}","{
    if (mText == null) {
        Log.e(TAG, ""null synthesis text"");
        return false;
    }
    if (mText.length() >= MAX_SPEECH_ITEM_CHAR_LENGTH) {
        Log.w(TAG, ""Text too long: "" + mText.length() + "" chars"");
        return false;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The log message in the first 'if' condition has been changed from ""Got null text"" to ""null synthesis text"". Thus, the change type is 4.","This change in the log message does not influence the behavior of the API, hence no compatibility issue is detected."
529,<android.bluetooth.BluetoothSocket: int bindListen()>,16,17,<android.bluetooth.BluetoothSocket: int bindListen()>,<android.bluetooth.BluetoothSocket: int bindListen()>,0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            return EBADFD;
        return bindListenNative();
    } finally {
        mLock.readLock().unlock();
    }
}","{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, ""bindListen fail, reason: bluetooth is off"");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        // TODO(BT) right error code?
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, ""bindListen(), SocketState: "" + mSocketState + "", mPfd: "" + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket "");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, ""bindListen(), new LocalSocket.getInputStream() "");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, ""bindListen(), readInt mSocketIS: "" + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, ""channel: "" + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, ""bindListen, fail to get port number, exception: "" + e);
        return -1;
    }
    return ret;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4,5","1,2","Both the return statements and exception handling structures have been largely modified in the late version implementation. Several new method calls introduced which could significantly impact the behavior of the function, for instance, 'BluetoothAdapter.getDefaultAdapter().getBluetoothService(null)', 'bluetoothProxy.createSocketChannel(...)', 'mPfd.getFileDescriptor()'. Furthermore, there are also changes to assignment, response status handling, and log prompts statements, thus the pred_change is 1,2,4,5.","Due to the major modifications, newly introduced exceptions and changes in return statements, the API could potentially throw different exceptions and return different results. Hence the CI is determined as 1,2."
530,<android.bluetooth.BluetoothAdapter: boolean enable()>,16,17,<android.bluetooth.BluetoothAdapter: boolean enable()>,<android.bluetooth.BluetoothAdapter: boolean enable()>,0,"{
    try {
        return mService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, ""enable(): BT is already enabled..!"");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
","/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class=""caution""><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a ""power manager"" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new conditional 'if' statement has been introduced, and the API (mService.enable()) that the method relied on has changed to (mManagerService.enable()), so the change type is 1,3.","The new 'if' statement and the change of API that the method relies on, both could potentially cause this API to produce different behaviours, so the type of CI is 1."
531,<android.content.res.Configuration: int compareTo(Configuration)>,16,17,<android.content.res.Configuration: int compareTo(Configuration)>,<android.content.res.Configuration: int compareTo(Configuration)>,0,"{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    if (this.locale == null) {
        if (that.locale != null)
            return 1;
    } else if (that.locale == null) {
        return -1;
    } else {
        n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
        if (n != 0)
            return n;
        n = this.locale.getCountry().compareTo(that.locale.getCountry());
        if (n != 0)
            return n;
        n = this.locale.getVariant().compareTo(that.locale.getVariant());
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    // if (n != 0) return n;
    return n;
}","{
    int n;
    float a = this.fontScale;
    float b = that.fontScale;
    if (a < b)
        return -1;
    if (a > b)
        return 1;
    n = this.mcc - that.mcc;
    if (n != 0)
        return n;
    n = this.mnc - that.mnc;
    if (n != 0)
        return n;
    if (this.locale == null) {
        if (that.locale != null)
            return 1;
    } else if (that.locale == null) {
        return -1;
    } else {
        n = this.locale.getLanguage().compareTo(that.locale.getLanguage());
        if (n != 0)
            return n;
        n = this.locale.getCountry().compareTo(that.locale.getCountry());
        if (n != 0)
            return n;
        n = this.locale.getVariant().compareTo(that.locale.getVariant());
        if (n != 0)
            return n;
    }
    n = this.touchscreen - that.touchscreen;
    if (n != 0)
        return n;
    n = this.keyboard - that.keyboard;
    if (n != 0)
        return n;
    n = this.keyboardHidden - that.keyboardHidden;
    if (n != 0)
        return n;
    n = this.hardKeyboardHidden - that.hardKeyboardHidden;
    if (n != 0)
        return n;
    n = this.navigation - that.navigation;
    if (n != 0)
        return n;
    n = this.navigationHidden - that.navigationHidden;
    if (n != 0)
        return n;
    n = this.orientation - that.orientation;
    if (n != 0)
        return n;
    n = this.screenLayout - that.screenLayout;
    if (n != 0)
        return n;
    n = this.uiMode - that.uiMode;
    if (n != 0)
        return n;
    n = this.screenWidthDp - that.screenWidthDp;
    if (n != 0)
        return n;
    n = this.screenHeightDp - that.screenHeightDp;
    if (n != 0)
        return n;
    n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
    if (n != 0)
        return n;
    n = this.densityDpi - that.densityDpi;
    // if (n != 0) return n;
    return n;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The function's implementation changed in several ways. First, a value comparison was added in the form of a return statement (`n = this.densityDpi - that.densityDpi; if (n != 0) return n;`). Second, the control conditions changed, and third, the last line of code (`n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;`) was commented out. This could be classified under the categories 1, 3, and 4.","The code change may potentially lead to different return values of this method, thus it is classified as a type 1 Compatibility Issue."
532,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",16,17,"<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>","<android.app.FragmentManagerImpl: void attachFragment(Fragment,int,int)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            if (mAdded == null) {
                mAdded = new ArrayList<Fragment>();
            }
            mAdded.add(fragment);
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
            moveToState(fragment, mCurState, transition, transitionStyle, false);
        }
    }
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + fragment);
    if (fragment.mDetached) {
        fragment.mDetached = false;
        if (!fragment.mAdded) {
            if (mAdded == null) {
                mAdded = new ArrayList<Fragment>();
            }
            if (mAdded.contains(fragment)) {
                throw new IllegalStateException(""Fragment already added: "" + fragment);
            }
            if (DEBUG)
                Log.v(TAG, ""add from attach: "" + fragment);
            mAdded.add(fragment);
            fragment.mAdded = true;
            if (fragment.mHasMenu && fragment.mMenuVisible) {
                mNeedMenuInvalidate = true;
            }
            moveToState(fragment, mCurState, transition, transitionStyle, false);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","The condition statement ""if(mAdded.contains(fragment))"" and exception throwing statement ""throw new IllegalStateException(""Fragment already added: ""+ fragment);"" is introduced, indicating it's a type 2 and 3 change.","The newly introduced exception throwing statement could potentially throw the exception differently from the previous version, and the newly introduced condition statement ""if(mAdded.contains(fragment))"" could potentially lead to a different control flow and hence different return values, hence the CI type is 1,2."
534,<android.app.ContextImpl: File getCacheDir()>,16,17,<android.app.ContextImpl: File getCacheDir()>,<android.app.ContextImpl: File getCacheDir()>,0,"{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        if (!mCacheDir.exists()) {
            if (!mCacheDir.mkdirs()) {
                Log.w(TAG, ""Unable to create cache directory"");
                return null;
            }
            FileUtils.setPermissions(mCacheDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    }
    return mCacheDir;
}","{
    synchronized (mSync) {
        if (mCacheDir == null) {
            mCacheDir = new File(getDataDirFile(), ""cache"");
        }
        if (!mCacheDir.exists()) {
            if (!mCacheDir.mkdirs()) {
                Log.w(TAG, ""Unable to create cache directory "" + mCacheDir.getAbsolutePath());
                return null;
            }
            FileUtils.setPermissions(mCacheDir.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        }
    }
    return mCacheDir;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The only difference between the early version and the late version lies in the string of the Log.w() method. The late version includes the absolute path of the directory that it failed to create. Thus, the code change type is 4.","The change is only relevant to logging, and it does not change the behavior of the method. Therefore, it does not lead to a Compatibility Issue."
535,<android.view.inputmethod.InputMethodManager: void showInputMethodPicker()>,16,17,<android.view.inputmethod.InputMethodManager: void showInputMethodPicker()>,<android.view.inputmethod.InputMethodManager: void showInputMethodPicker()>,0,"{
    synchronized (mH) {
        try {
            mService.showInputMethodPickerFromClient(mClient);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    synchronized (mH) {
        showInputMethodPickerLocked();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The detailed implementation within the synchronised block has changed, where a new method showInputMethodPickerLocked() is called in the late version, which can be classified as ""Other statement changed"" and ""Dependent API changed"".","The actual behavior of the API is assumed to remain the same since the new method is likely an encapsulation of the previous implementation. Thus, no compatibility issue is predicted here."
536,<android.view.ScaleGestureDetector: long getTimeDelta()>,16,17,<android.view.ScaleGestureDetector: long getTimeDelta()>,<android.view.ScaleGestureDetector: long getTimeDelta()>,0,"{
    return mTimeDelta;
}","{
    return mCurrTime - mPrevTime;
}",1,"/**
 * Return the time difference in milliseconds between the previous
 * accepted scaling event and the current scaling event.
 *
 * @return Time difference since the last scaling event in milliseconds.
 */
","/**
 * Return the time difference in milliseconds between the previous
 * accepted scaling event and the current scaling event.
 *
 * @return Time difference since the last scaling event in milliseconds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement of this method has changed from 'return mTimeDelta' in the early version to 'return mCurrTime - mPrevTime' in the late version, so the code change type is 1.","The change in the return statement could potentially lead to a different returned value in the late version, so the CI type is 1."
537,<android.webkit.AccessibilityInjector: void onPageFinished(String)>,16,17,<android.webkit.AccessibilityInjector: void onPageFinished(String)>,<android.webkit.AccessibilityInjector: void onPageFinished(String)>,0,"{
    if (!isAccessibilityEnabled()) {
        mAccessibilityScriptInjected = false;
        toggleFallbackAccessibilityInjector(false);
        return;
    }
    if (!shouldInjectJavaScript(url)) {
        toggleFallbackAccessibilityInjector(true);
        return;
    }
    toggleFallbackAccessibilityInjector(false);
    final String injectionUrl = getScreenReaderInjectionUrl();
    mWebView.loadUrl(injectionUrl);
    mAccessibilityScriptInjected = true;
}","{
    if (!isAccessibilityEnabled()) {
        toggleFallbackAccessibilityInjector(false);
        return;
    }
    toggleFallbackAccessibilityInjector(true);
    if (shouldInjectJavaScript(url)) {
        // callback to confirm that CallbackHandler is working.
        if (DEBUG) {
            Log.d(TAG, ""["" + mWebView.hashCode() + ""] Request callback "");
        }
        mCallback.requestCallback(mWebView, mInjectScriptRunnable);
    }
}",1,"/**
 * Attempts to inject the accessibility script using a {@code <script>} tag.
 * <p>
 * This should be called after a page has finished loading.
 * </p>
 *
 * @param url The URL that just finished loading.
 */
","/**
 * Attempts to inject the accessibility script using a {@code <script>} tag.
 * <p>
 * This should be called after a page has finished loading.
 * </p>
 *
 * @param url The URL that just finished loading.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The code changes between two versions are about the condition statement 'shouldInjectJavaScript(url)' and its following statements, including a return statement. Therefore, the changes can be categorized as type 1 and 3.","Because of the changes in the return statements, the late version of code might perform different behaviours and have different resulting states comparing with the early version. Therefore the CI type is 1."
538,<android.view.Display: int getDisplayId()>,16,17,<android.view.Display: int getDisplayId()>,<android.view.Display: int getDisplayId()>,0,"{
    return mDisplay;
}","{
    return mDisplayId;
}",1,"/**
 * Returns the index of this display.  This is currently undefined; do
 * not use.
 */
","/**
 * Gets the display id.
 * <p>
 * Each logical display has a unique id.
 * The default display has id {@link #DEFAULT_DISPLAY}.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mDisplay to mDisplayId, so the code change type is 1. ","The change of the return statement potentially makes the API return a different value, so the CI type is 1."
539,<android.view.ViewGroup: boolean dispatchKeyEvent(KeyEvent)>,16,17,<android.view.ViewGroup: boolean dispatchKeyEvent(KeyEvent)>,<android.view.ViewGroup: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 1);
    }
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        if (super.dispatchKeyEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        if (mFocused.dispatchKeyEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 1);
    }
    if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
        if (super.dispatchKeyEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) {
        if (mFocused.dispatchKeyEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is within the variables' names. FOCUSED and HAS_BOUNDS have been replaced by PFLAG_FOCUSED and PFLAG_HAS_BOUNDS respectively in the later implementation. So, the code change type is 4.","This change in the variable names does not cause the method to return different results or throw different exception compared to the early version. Hence, there is no compatibility issue (CI Type: 0)."
540,"<android.provider.Settings.System: float getFloat(ContentResolver,String)>",16,17,"<android.provider.Settings.System: float getFloat(ContentResolver,String)>","<android.provider.Settings.System: float getFloat(ContentResolver,String)>",0,"{
    String v = getString(cr, name);
    if (v == null) {
        throw new SettingNotFoundException(name);
    }
    try {
        return Float.parseFloat(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getFloatForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a float.  Note that internally setting values are always
 * stored as strings; this function converts the string to a float
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not a float.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","In the late version, the return statement has been changed and the method relies on a separate API getFloatForUser(). The parameter of getFloatForUser() also uses the dependent API UserHandle.myUserId(), these changes constitute to classes 1 and 5.","The change in the return statement and the dependent APIs may potentially result in different return values or types, thus category 1 is applicable. Additionally, the removal of the exception handling associated with NumberFormatException in the late version may lead to different exception handling. Hence, CI category 2 is also valid."
544,<android.bluetooth.BluetoothHeadset: int getConnectionState(BluetoothDevice)>,16,17,<android.bluetooth.BluetoothHeadset: int getConnectionState(BluetoothDevice)>,<android.bluetooth.BluetoothHeadset: int getConnectionState(BluetoothDevice)>,0,"{
    if (DBG)
        log(""getConnectionState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}","{
    if (VDBG)
        log(""getConnectionState("" + device + "")"");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, ""Proxy not attached to service"");
    return BluetoothProfile.STATE_DISCONNECTED;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is only in the log level from DBG to VDBG, other functionalities and behaviours of the API remain unchanged, so the code change type is 4.","The log level change won't cause the API to return different values or throw different exceptions, thus no Compatibility Issue exists."
545,"<android.app.NotificationManager: void notify(String,int,Notification)>",16,17,"<android.app.NotificationManager: void notify(String,int,Notification)>","<android.app.NotificationManager: void notify(String,int,Notification)>",0,"{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, tag, id, notification, idOut);
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}","{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
    }
    if (localLOGV)
        Log.v(TAG, pkg + "": notify("" + id + "", "" + notification + "")"");
    try {
        service.enqueueNotificationWithTag(pkg, tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, ""notify: id corrupted: sent "" + id + "", got back "" + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}",1,"/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
","/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"There's the addition of a line 'notification.sound = notification.sound.getCanonicalUri()' which is categorized in the 'other statement change'. The dependent API 'service.enqueueNotificationWithTag' has changed with a new parameter 'UserHandle.myUserId()' being added to it, which leads to a dependent API change. There are also modifications in the try block, which in turns changes the return value of the method, thereby leading to return statement change.","The modification to the dependent API and changes in the try block potentially change the behavior of the method, causing it to potentially return different values, hence the compatibility issue is of type 1."
547,<android.bluetooth.BluetoothSocket: int available()>,16,17,<android.bluetooth.BluetoothSocket: int available()>,<android.bluetooth.BluetoothSocket: int available()>,0,"{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return availableNative();
    } finally {
        mLock.readLock().unlock();
    }
}","{
    if (VDBG)
        Log.d(TAG, ""available: "" + mSocketIS);
    return mSocketIS.available();
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,5","1,2","The method return value has changed and there has also been a dependent API change from availableNative() to mSocketIS.available(). Additionally, the exception handling block has been removed. This leads to changes aligning with categories 1 (Return statement changed) and 5 (Dependent API changed).","Both the return value and exception handling scenarios have changed resulting in potential different behaviours. Adjacently, accompanied with a different return type/value, an exception might no longer be thrown in some scenarios, resulting in CI types 1 and 2. This represents a Compatibility Issue due to potential different return values and Compatibility Issue caused by potential different exception handlings."
549,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",16,17,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>","<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",0,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": (null)"");
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throw new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]);
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: making added #"" + i + "": "" + f);
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding bse #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity, mParent);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throwException(new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: added #"" + i + "": "" + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException(""Already added!"");
            }
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, ""restoreAllState: back stack #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
                LogWriter logw = new LogWriter(Log.VERBOSE, TAG);
                PrintWriter pw = new PrintWriter(logw);
                bse.dump(""  "", pw, false);
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","In the late version, there are a few changes in the method call fs.instantiate(mActivity, mParent). A new parameter 'mParent' is added. Also, the exception handling statement `throw new IllegalStateException(""Already added!"")` is introduced. Other changes to method calls such as `fs.instantiate(mActivity)`, `Log.v(TAG, ""restoreAllState: active #"" + i + "": "" + f)` and the introduction of new objects: LogWriter logw = new LogWriter(Log.VERBOSE, TAG), PrintWriter pw = new PrintWriter(logw) also occurred. Therefore, the code change types are 3 (The change in exception state condition),4 (other statement change, especially in method calls log) and 5 (depending API change with the addition of a new parameter 'mParent' in the dependent API).","The change of return in exception handling state condition and the addition of a new parameter in a method call alongwith method call changes will make the API potentially return different values or throw different exceptions under certain circumstances. Therefore, the Compatibility Issue(CI) types are 1 and 2."
550,<android.app.ContextImpl: void sendBroadcast(Intent)>,16,17,<android.app.ContextImpl: void sendBroadcast(Intent)>,<android.app.ContextImpl: void sendBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"An additional method 'warnIfCallingFromSystemProcess' is invoked in the late version and the parameter of 'ActivityManagerNative.getDefault().broadcastIntent' method call is changed from 'Binder.getOrigCallingUser()' to 'getUserId()'. Therefore, the code change is categorized as type 4,5.","The function 'getUserId()' may return a different user ID than 'Binder.getOrigCallingUser()', which may lead to a change in the behavior of 'broadcastIntent' method. Thus, it could lead to a different return value, so the CI type is 1."
552,<android.provider.Settings.System: Uri getUriFor(String)>,16,17,<android.provider.Settings.System: Uri getUriFor(String)>,<android.provider.Settings.System: Uri getUriFor(String)>,0,"{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, returning Secure URI."");
        return Secure.getUriFor(Secure.CONTENT_URI, name);
    }
    return getUriFor(CONTENT_URI, name);
}","{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, returning Secure URI."");
        return Secure.getUriFor(Secure.CONTENT_URI, name);
    }
    if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Global, returning read-only global URI."");
        return Global.getUriFor(Global.CONTENT_URI, name);
    }
    return getUriFor(CONTENT_URI, name);
}",1,"/**
 * Construct the content URI for a particular name/value pair,
 * useful for monitoring changes with a ContentObserver.
 * @param name to look up in the table
 * @return the corresponding content URI, or null if not present
 */
","/**
 * Construct the content URI for a particular name/value pair,
 * useful for monitoring changes with a ContentObserver.
 * @param name to look up in the table
 * @return the corresponding content URI, or null if not present
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"An additional 'if' condition is introduced in the late version, also, an additional 'return' statement is included inside the newly added 'if' condition block. Therefore, the code change types are 1 and 3.","Due to the introduction of the additional 'if' condition and 'return' statement, the API now potentially returns different values. Thus, the CI type is 1."
553,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",16,17,"<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>","<android.net.VpnService.Builder: Builder addAddress(InetAddress,int)>",0,"{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.append(String.format("" %s/%d"", address.getHostAddress(), prefixLength));
    return this;
}","{
    check(address, prefixLength);
    if (address.isAnyLocalAddress()) {
        throw new IllegalArgumentException(""Bad address"");
    }
    mAddresses.append(' ' + address.getHostAddress() + '/' + prefixLength);
    return this;
}",1,"/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
","/**
 * Add a network address to the VPN interface. Both IPv4 and IPv6
 * addresses are supported. At least one address must be set before
 * calling {@link #establish}.
 *
 * @throws IllegalArgumentException if the address is invalid.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The format of the argument for append method of mAddresses was changed. Therefore, the change category is 'Other statement changed' labeled as 4.","Despite the change in the argument format for the append method of mAddresses, we could not observe that the output of the function is getting affected. The function is still adding the address to the mAddresses and returning the same object. Hence, no compatibility issue exists, labeled as 0."
555,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",16,17,"<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>","<android.widget.RemoteViews.SetOnClickFillInIntent: void apply(View,ViewGroup,OnClickHandler)>",0,"{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(""RemoteViews"", ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (target != null && fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (!(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(""RemoteViews"", ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(""RemoteViews"", ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}","{
    final View target = root.findViewById(viewId);
    if (target == null)
        return;
    if (!mIsWidgetCollectionChild) {
        Log.e(""RemoteViews"", ""The method setOnClickFillInIntent is available "" + ""only from RemoteViewsFactory (ie. on collection items)."");
        return;
    }
    if (target == root) {
        target.setTagInternal(com.android.internal.R.id.fillInIntent, fillInIntent);
    } else if (target != null && fillInIntent != null) {
        OnClickListener listener = new OnClickListener() {

            public void onClick(View v) {
                // Insure that this view is a child of an AdapterView
                View parent = (View) v.getParent();
                while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) {
                    parent = (View) parent.getParent();
                }
                if (parent instanceof AppWidgetHostView || parent == null) {
                    // Somehow they've managed to get this far without having
                    // and AdapterView as a parent.
                    Log.e(""RemoteViews"", ""Collection item doesn't have AdapterView parent"");
                    return;
                }
                // Insure that a template pending intent has been set on an ancestor
                if (!(parent.getTag() instanceof PendingIntent)) {
                    Log.e(""RemoteViews"", ""Attempting setOnClickFillInIntent without"" + "" calling setPendingIntentTemplate on parent."");
                    return;
                }
                PendingIntent pendingIntent = (PendingIntent) parent.getTag();
                final float appScale = v.getContext().getResources().getCompatibilityInfo().applicationScale;
                final int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                final Rect rect = new Rect();
                rect.left = (int) (pos[0] * appScale + 0.5f);
                rect.top = (int) (pos[1] * appScale + 0.5f);
                rect.right = (int) ((pos[0] + v.getWidth()) * appScale + 0.5f);
                rect.bottom = (int) ((pos[1] + v.getHeight()) * appScale + 0.5f);
                fillInIntent.setSourceBounds(rect);
                handler.onClickHandler(v, pendingIntent, fillInIntent);
            }
        };
        target.setOnClickListener(listener);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,The condition while (!(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) in the early implementation has been updated to while (parent != null && !(parent instanceof AdapterView<?>) && !(parent instanceof AppWidgetHostView)) in the later version. This change is categorized as a control dependency change (type 3).,"Although the while condition has been updated, the change doesn't affect the API return value or the potential exception which it could throw. Therefore, there is no compatibility issue (type 0) in this case."
556,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,16,17,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.MediaController: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    int keyCode = event.getKeyCode();
    final boolean uniqueDown = event.getRepeatCount() == 0 && event.getAction() == KeyEvent.ACTION_DOWN;
    if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE) {
        if (uniqueDown) {
            doPauseResume();
            show(sDefaultTimeout);
            if (mPauseButton != null) {
                mPauseButton.requestFocus();
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
        if (uniqueDown && !mPlayer.isPlaying()) {
            mPlayer.start();
            updatePausePlay();
            show(sDefaultTimeout);
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
        if (uniqueDown && mPlayer.isPlaying()) {
            mPlayer.pause();
            updatePausePlay();
            show(sDefaultTimeout);
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        // don't show the controls for volume adjustment
        return super.dispatchKeyEvent(event);
    } else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {
        if (uniqueDown) {
            hide();
        }
        return true;
    }
    show(sDefaultTimeout);
    return super.dispatchKeyEvent(event);
}","{
    int keyCode = event.getKeyCode();
    final boolean uniqueDown = event.getRepeatCount() == 0 && event.getAction() == KeyEvent.ACTION_DOWN;
    if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE || keyCode == KeyEvent.KEYCODE_SPACE) {
        if (uniqueDown) {
            doPauseResume();
            show(sDefaultTimeout);
            if (mPauseButton != null) {
                mPauseButton.requestFocus();
            }
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) {
        if (uniqueDown && !mPlayer.isPlaying()) {
            mPlayer.start();
            updatePausePlay();
            show(sDefaultTimeout);
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) {
        if (uniqueDown && mPlayer.isPlaying()) {
            mPlayer.pause();
            updatePausePlay();
            show(sDefaultTimeout);
        }
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE || keyCode == KeyEvent.KEYCODE_CAMERA) {
        // don't show the controls for volume adjustment
        return super.dispatchKeyEvent(event);
    } else if (keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU) {
        if (uniqueDown) {
            hide();
        }
        return true;
    }
    show(sDefaultTimeout);
    return super.dispatchKeyEvent(event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The condition statement under 'if' has changed with an addition of a new condition (keyCode == KeyEvent.KEYCODE_CAMERA), hence the code change type is 3.","The modification in the condition statement results in handling of an additional keyCode which eventually invokes the same super method without changing the potential behaviour or the return type/value. Hence, there is no Compatibility Issue and CI type is 0."
557,"<android.content.ContentResolver: void registerContentObserver(Uri,boolean,ContentObserver)>",16,17,"<android.content.ContentResolver: void registerContentObserver(Uri,boolean,ContentObserver)>","<android.content.ContentResolver: void registerContentObserver(Uri,boolean,ContentObserver)>",0,"{
    try {
        getContentService().registerContentObserver(uri, notifyForDescendents, observer.getContentObserver());
    } catch (RemoteException e) {
    }
}","{
    registerContentObserver(uri, notifyForDescendents, observer, UserHandle.myUserId());
}",1,"/**
 * Register an observer class that gets callbacks when data identified by a
 * given content URI changes.
 *
 * @param uri The URI to watch for changes. This can be a specific row URI, or a base URI
 * for a whole class of content.
 * @param notifyForDescendents If <code>true</code> changes to URIs beginning with <code>uri</code>
 * will also cause notifications to be sent. If <code>false</code> only changes to the exact URI
 * specified by <em>uri</em> will cause notifications to be sent. If true, than any URI values
 * at or below the specified URI will also trigger a match.
 * @param observer The object that receives callbacks when changes occur.
 * @see #unregisterContentObserver
 */
","/**
 * Register an observer class that gets callbacks when data identified by a
 * given content URI changes.
 *
 * @param uri The URI to watch for changes. This can be a specific row URI, or a base URI
 * for a whole class of content.
 * @param notifyForDescendents If <code>true</code> changes to URIs beginning with <code>uri</code>
 * will also cause notifications to be sent. If <code>false</code> only changes to the exact URI
 * specified by <em>uri</em> will cause notifications to be sent. If true, than any URI values
 * at or below the specified URI will also trigger a match.
 * @param observer The object that receives callbacks when changes occur.
 * @see #unregisterContentObserver
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,The method getContentService().registerContentObserver() has been replaced by the method registerContentObserver(). This is a change in the statement (4) and a change in the dependent API being used (5).,"Although the dependent API has changed, this should not cause a compatibility issue because both versions are essentially performing the same function - registering a content observer. Therefore, the return value and the exception which gets thrown are expected to remain consistent across both versions. The CI type is 0."
558,<android.view.View: boolean destroyLayer(boolean)>,16,17,<android.view.View: boolean destroyLayer(boolean)>,<android.view.View: boolean destroyLayer(boolean)>,0,"{
    if (mHardwareLayer != null) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
            mHardwareLayer.destroy();
            mHardwareLayer = null;
            invalidate(true);
            invalidateParentCaches();
        }
        return true;
    }
    return false;
}","{
    if (mHardwareLayer != null) {
        AttachInfo info = mAttachInfo;
        if (info != null && info.mHardwareRenderer != null && info.mHardwareRenderer.isEnabled() && (valid || info.mHardwareRenderer.validate())) {
            mHardwareLayer.destroy();
            mHardwareLayer = null;
            if (mDisplayList != null) {
                mDisplayList.reset();
            }
            invalidate(true);
            invalidateParentCaches();
        }
        return true;
    }
    return false;
}",1,"/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
","/**
 * Destroys this View's hardware layer if possible.
 *
 * @return True if the layer was destroyed, false otherwise.
 *
 * @see #setLayerType(int, android.graphics.Paint)
 * @see #LAYER_TYPE_HARDWARE
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two new statements are added in the later version (`if (mDisplayList != null)` and `mDisplayList.reset();`). So, the change type is 4 (Other statement changed).","These new lines of code do not impact the returned values or the exception handling. Therefore, no compatibility issue exists; thus the CI type is 0."
560,<android.app.ContextImpl: ComponentName startService(Intent)>,16,17,<android.app.ContextImpl: ComponentName startService(Intent)>,<android.app.ContextImpl: ComponentName startService(Intent)>,0,"{
    try {
        service.setAllowFds(false);
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (cn != null && cn.getPackageName().equals(""!"")) {
            throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}","{
    warnIfCallingFromSystemProcess();
    return startServiceAsUser(service, mUser);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5","1,2","The method has changed significantly - the initial 'try catch' block has been replaced by two new return statements containing different methods and as such different functional pathways. Therefore, this change is categorized as 1 (Return statement changed), 4 (Other statement changed), and 5 (Dependent API changed).","The return value has the potential of being different. The original structure had exception handling that would return null if a RemoteException occurred. This is replaced in the later implementation, causing behaviour changes. Therefore, it can potentially return different values (CI type 1) and handle exceptions differently (CI type 2)."
561,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,<android.app.admin.DevicePolicyManager: int getPasswordMinimumNumeric(ComponentName)>,0,"{
    if (mService != null) {
        try {
            return mService.getPasswordMinimumNumeric(admin);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
    return 0;
}","{
    return getPasswordMinimumNumeric(admin, UserHandle.myUserId());
}",1,"/**
 * Retrieve the current number of numerical digits required in the password
 * for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumNumeric(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of numerical digits required in the password.
 */
","/**
 * Retrieve the current number of numerical digits required in the password
 * for all admins or a particular one. This is the same value as
 * set by {#link {@link #setPasswordMinimumNumeric(ComponentName, int)}
 * and only applies when the password quality is
 * {@link #PASSWORD_QUALITY_COMPLEX}.
 *
 * @param admin The name of the admin component to check, or null to
 * aggregate all admins.
 * @return The minimum number of numerical digits required in the password.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The overall structure of the code has changed. The error handling with catch statement has been removed and replaced by getPasswordMinimumNumeric which takes two parameters instead of one, so the change type is 1,5.","The return statement was changed, which leads to potential change in returned value. Therefore, the CI type is 1."
564,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,16,17,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,0,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    mCurrentDrag.recycle();
                    mCurrentDrag = null;
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    mCurrentDrag.recycle();
                    mCurrentDrag = null;
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}",1,"// TODO: Write real docs
","// TODO: Write real docs
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Only the bitwise operation has been changed from ~View.DRAG_HOVERED to ~View.PFLAG2_DRAG_HOVERED and from |= View.DRAG_HOVERED to |= View.PFLAG2_DRAG_HOVERED, thus classifying it as other statement changed - 4.","This change will not cause any compatibility issues because the changed statements only internal flag configurations for the current view. Therefore, it does not impact the return value nor expected exception behavior of the API. Hence, no compatibility issue exists - 0."
566,<android.view.View: boolean setAlphaNoInvalidation(float)>,16,17,<android.view.View: boolean setAlphaNoInvalidation(float)>,<android.view.View: boolean setAlphaNoInvalidation(float)>,0,"{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(alpha);
            }
        }
    }
    return false;
}","{
    ensureTransformationInfo();
    if (mTransformationInfo.mAlpha != alpha) {
        mTransformationInfo.mAlpha = alpha;
        boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
        if (subclassHandlesAlpha) {
            mPrivateFlags |= PFLAG_ALPHA_SET;
            return true;
        } else {
            mPrivateFlags &= ~PFLAG_ALPHA_SET;
            if (mDisplayList != null) {
                mDisplayList.setAlpha(alpha);
            }
        }
    }
    return false;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha()) and
 * the new value for the alpha property is different from the old value
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,The only change in the code is a name change of the parameter 'ALPHA_SET' to 'PFLAG_ALPHA_SET'. This is therefore classified as a type 4 change 'Other statements changed'.,"Despite the code change, the API's behavior remains the same. Therefore, there is no compatibility issue, CI = 0."
568,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,16,17,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"There is a statement change where Binder.getOrigCallingUser() is replaced with getUserId() in the implementation, so the code change type is 4.","As the function call inside the method has changed from Binder.getOrigCallingUser() to getUserId(), it may potentially change the behavior of the unbroadcastIntent method, which may in turn affect the output of removeStickyBroadcast method. Therefore, the CI type is 1."
570,<android.widget.AdapterViewAnimator: Parcelable onSaveInstanceState()>,16,17,<android.widget.AdapterViewAnimator: Parcelable onSaveInstanceState()>,<android.widget.AdapterViewAnimator: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    return new SavedState(superState, mWhichChild);
}","{
    Parcelable superState = super.onSaveInstanceState();
    if (mRemoteViewsAdapter != null) {
        mRemoteViewsAdapter.saveRemoteViewsCache();
    }
    return new SavedState(superState, mWhichChild);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",0,"There is a change in 'if' statement within the method but the return statement remains unchanged, so the code change type is 3 (control dependency change) and 1 (return statement unchanged but has new control flow for mRemoteViewsAdapter which might affect its state).","Despite the new 'if' statement, the overall functionality (i.e., what is returned) has not changed as the return value is still a new SavedState instance with the same arguments. Hence, no compatibility issues are expected (CI type 0). So, the changes won't affect how the users interact with the API because the return type and behaviour remain the same."
571,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,16,17,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,0,"{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
","/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed (an extra 'synchronized' block), and an 'if' statement was added to the late version (if (mService != null)), qualifying the code change as both type 3 and 4.","The introduction of the additional 'if' statement, (if (mService != null)), means that the late version may not call `mService.isDiscovering()`. So the two versions of this method could potentially return different results, and the Compatibility Issue type is thus 1."
573,"<android.widget.FastScroller: boolean isPointInside(float,float)>",16,17,"<android.widget.FastScroller: boolean isPointInside(float,float)>","<android.widget.FastScroller: boolean isPointInside(float,float)>",0,"{
    boolean inTrack = false;
    switch(mPosition) {
        default:
        case View.SCROLLBAR_POSITION_DEFAULT:
        case View.SCROLLBAR_POSITION_RIGHT:
            inTrack = x > mList.getWidth() - mThumbW;
            break;
        case View.SCROLLBAR_POSITION_LEFT:
            inTrack = x < mThumbW;
            break;
    }
    // Allow taps in the track to start moving.
    return inTrack && (mTrackDrawable != null || y >= mThumbY && y <= mThumbY + mThumbH);
}","{
    boolean inTrack = false;
    switch(mPosition) {
        default:
        case View.SCROLLBAR_POSITION_RIGHT:
            inTrack = x > mList.getWidth() - mThumbW;
            break;
        case View.SCROLLBAR_POSITION_LEFT:
            inTrack = x < mThumbW;
            break;
    }
    // Allow taps in the track to start moving.
    return inTrack && (mTrackDrawable != null || y >= mThumbY && y <= mThumbY + mThumbH);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The switch case statement has a deletion, where 'case View.SCROLLBAR_POSITION_DEFAULT:' has been removed in the Late_Version, which indicates a control dependency change, so the code change type is 3.","Because of the 'case View.SCROLLBAR_POSITION_DEFAULT:' has been removed, it potentially alters the boolean value of 'inTrack' that is being returned by the API. This change in the returned boolean value indicates a Compatibility Issue caused by potential different return values, so the CI type is 1."
574,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>",16,17,"<android.app.ContextImpl: void startActivity(Intent,Bundle)>","<android.app.ContextImpl: void startActivity(Intent,Bundle)>",0,"{
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}","{
    warnIfCallingFromSystemProcess();
    if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
        throw new AndroidRuntimeException(""Calling startActivity() from outside of an Activity "" + "" context requires the FLAG_ACTIVITY_NEW_TASK flag."" + "" Is this really what you want?"");
    }
    mMainThread.getInstrumentation().execStartActivity(getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement, warnIfCallingFromSystemProcess(), is introduced, so the code change type is 4.","The added method, warnIfCallingFromSystemProcess(), is used for warning, which doesn't affect the return value or the exception handling process of the API, Therefore, no Compatibility Issue exists, and the CI type is 0."
575,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumUpperCase(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumUpperCase(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of upper case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of upper case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of upper case letters required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 0.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of upper case letters
 * required in the password. A value of 0 means there is no
 * restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The dependent API ""mService.setPasswordMinimumUpperCase"" introduced an additional parameter, so the code change type is 1, 5.","Although the dependent API call is changed, this change won't affect the return value or exception handling of the current API, as both versions of the API don't have a return statement and they also deal with the exception in the same way. Therefore, no Compatibility Issue exists for this API."
576,"<android.provider.Settings.System: long getLong(ContentResolver,String)>",16,17,"<android.provider.Settings.System: long getLong(ContentResolver,String)>","<android.provider.Settings.System: long getLong(ContentResolver,String)>",0,"{
    String valString = getString(cr, name);
    try {
        return Long.parseLong(valString);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getLongForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @return The setting's current value.
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from returning parsed long value to returning long value for a user, and the method called within the return statement also changed (from getString and Long.parseLong to getLongForUser), so the code change type is 1,5.","The change of return statement and the method within can make the API potentially return a different value, so the CI type is 1."
577,<android.view.View: HardwareLayer getHardwareLayer()>,16,17,<android.view.View: HardwareLayer getHardwareLayer()>,<android.view.View: HardwareLayer getHardwareLayer()>,0,"{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    if (!mAttachInfo.mHardwareRenderer.validate())
        return null;
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.set(0, 0, width, height);
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.set(0, 0, width, height);
        }
        // The layer is not valid if the underlying GPU resources cannot be allocated
        if (!mHardwareLayer.isValid()) {
            return null;
        }
        mHardwareLayer.redraw(getHardwareLayerDisplayList(mHardwareLayer), mLocalDirtyRect);
        mLocalDirtyRect.setEmpty();
    }
    return mHardwareLayer;
}","{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    if (!mAttachInfo.mHardwareRenderer.validate())
        return null;
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.set(0, 0, width, height);
        } else {
            if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
                if (mHardwareLayer.resize(width, height)) {
                    mLocalDirtyRect.set(0, 0, width, height);
                }
            }
            // This should not be necessary but applications that change
            // the parameters of their background drawable without calling
            // this.setBackground(Drawable) can leave the view in a bad state
            // (for instance isOpaque() returns true, but the background is
            // not opaque.)
            computeOpaqueFlags();
            final boolean opaque = isOpaque();
            if (mHardwareLayer.isValid() && mHardwareLayer.isOpaque() != opaque) {
                mHardwareLayer.setOpaque(opaque);
                mLocalDirtyRect.set(0, 0, width, height);
            }
        }
        // The layer is not valid if the underlying GPU resources cannot be allocated
        if (!mHardwareLayer.isValid()) {
            return null;
        }
        mHardwareLayer.setLayerPaint(mLayerPaint);
        mHardwareLayer.redrawLater(getHardwareLayerDisplayList(mHardwareLayer), mLocalDirtyRect);
        ViewRootImpl viewRoot = getViewRootImpl();
        if (viewRoot != null)
            viewRoot.pushHardwareLayerUpdate(mHardwareLayer);
        mLocalDirtyRect.setEmpty();
    }
    return mHardwareLayer;
}",1,"/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
","/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 3, 4, 5",1,"The constant DRAWING_CACHE_VALID is replaced with PFLAG_DRAWING_CACHE_VALID; new statements are added, and an API call (computeOpaqueFlags()) is introduced, so the code change type is 1, 3, 4, 5.","The change may lead to a different return value of the method, so the CI type is 1."
579,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,16,17,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,<android.app.ApplicationPackageManager: List<ApplicationInfo> getInstalledApplications(int)>,0,"{
    int userId = UserId.getUserId(Process.myUid());
    try {
        final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
        ApplicationInfo lastItem = null;
        ParceledListSlice<ApplicationInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledApplications(flags, lastKey, userId);
            lastItem = slice.populateList(applicationInfos, ApplicationInfo.CREATOR);
        } while (!slice.isLastSlice());
        return applicationInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    final int userId = mContext.getUserId();
    try {
        final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
        ApplicationInfo lastItem = null;
        ParceledListSlice<ApplicationInfo> slice;
        do {
            final String lastKey = lastItem != null ? lastItem.packageName : null;
            slice = mPM.getInstalledApplications(flags, lastKey, userId);
            lastItem = slice.populateList(applicationInfos, ApplicationInfo.CREATOR);
        } while (!slice.isLastSlice());
        return applicationInfos;
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}",1,,,-1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",-1,-1,-1,-1,-1,-1,4,1,"The first line on how to get the userId has been changed from UserId.getUserId(Process.myUid()) to mContext.getUserId(), so the code change type is 4.","This change in how the userId is retrieved could potentially cause the API to return a different list of Installed Applications, thus causing a difference in behavior. So the CI type is 1."
580,"<android.provider.Settings.System: long getLong(ContentResolver,String,long)>",16,17,"<android.provider.Settings.System: long getLong(ContentResolver,String,long)>","<android.provider.Settings.System: long getLong(ContentResolver,String,long)>",0,"{
    String valString = getString(cr, name);
    long value;
    try {
        value = valString != null ? Long.parseLong(valString) : def;
    } catch (NumberFormatException e) {
        value = def;
    }
    return value;
}","{
    return getLongForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as a {@code long}.  Note that internally setting values are always
 * stored as strings; this function converts the string to a {@code long}
 * for you.  The default value will be returned if the setting is
 * not defined or not a {@code long}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid {@code long}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"Early implementation code is replaced by calling another API (getLongForUser) with four parameters in the late version. So, I marked 1 (for return statement) and 5 (for dependent API changes).","As the new implementation is relying on a different method (getLongForUser()), this might return a different result, hence potentially leading to Compatibility Issues of type 1."
581,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",16,17,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>","<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",0,"{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null);
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null, getUserId());
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"An additional parameter 'getUserId()' has been added to the function 'startInstrumentation' in the late version without modifying any other code segments, classifying the change under type 4 and 5.","The late version API potentially returns a different value with the added parameter in 'startInstrumentation()', causing a possible compatibility issue. The CI type is 1."
582,<android.view.View: void setHasTransientState(boolean)>,16,17,<android.view.View: void setHasTransientState(boolean)>,<android.view.View: void setHasTransientState(boolean)>,0,"{
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    }
    if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~HAS_TRANSIENT_STATE) | (hasTransientState ? HAS_TRANSIENT_STATE : 0);
        if (mParent != null) {
            try {
                mParent.childHasTransientStateChanged(this, hasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}","{
    mTransientStateCount = hasTransientState ? mTransientStateCount + 1 : mTransientStateCount - 1;
    if (mTransientStateCount < 0) {
        mTransientStateCount = 0;
        Log.e(VIEW_LOG_TAG, ""hasTransientState decremented below 0: "" + ""unmatched pair of setHasTransientState calls"");
    }
    if ((hasTransientState && mTransientStateCount == 1) || (!hasTransientState && mTransientStateCount == 0)) {
        // update flag if we've just incremented up from 0 or decremented down to 0
        mPrivateFlags2 = (mPrivateFlags2 & ~PFLAG2_HAS_TRANSIENT_STATE) | (hasTransientState ? PFLAG2_HAS_TRANSIENT_STATE : 0);
        if (mParent != null) {
            try {
                mParent.childHasTransientStateChanged(this, hasTransientState);
            } catch (AbstractMethodError e) {
                Log.e(VIEW_LOG_TAG, mParent.getClass().getSimpleName() + "" does not fully implement ViewParent"", e);
            }
        }
    }
}",1,"/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
","/**
 * Set whether this view is currently tracking transient state that the
 * framework should attempt to preserve when possible. This flag is reference counted,
 * so every call to setHasTransientState(true) should be paired with a later call
 * to setHasTransientState(false).
 *
 * <p>A view with transient state cannot be trivially rebound from an external
 * data source, such as an adapter binding item views in a list. This may be
 * because the view is performing an animation, tracking user selection
 * of content, or similar.</p>
 *
 * @param hasTransientState true if this view has transient state
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The constant HAS_TRANSIENT_STATE has been renamed to PFLAG2_HAS_TRANSIENT_STATE within the implementation, so the code change type is 4.","This change of a constant name doesn’t affect the functional behavior of the method. Therefore, there is no Compatibility Issue detected, the CI type is 0."
584,<android.view.ScaleGestureDetector: float getPreviousSpanY()>,16,17,<android.view.ScaleGestureDetector: float getPreviousSpanY()>,<android.view.ScaleGestureDetector: float getPreviousSpanY()>,0,"{
    return mPrevFingerDiffY;
}","{
    return mPrevSpanY;
}",1,"/**
 * Return the previous y distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Previous distance between pointers in pixels.
 */
","/**
 * Return the previous average Y distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Previous distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mPrevFingerDiffY' to 'return mPrevSpanY', so the code change type is 1.","The return value is now linked to a different variable in the later version, which will affect the output the method generates. Thus a CI arises due to potentially different return values, leading to a CI type of 1."
585,"<android.webkit.WebViewClassic: void onOverScrolled(int,int,boolean,boolean)>",16,17,"<android.webkit.WebViewClassic: void onOverScrolled(int,int,boolean,boolean)>","<android.webkit.WebViewClassic: void onOverScrolled(int,int,boolean,boolean)>",0,"{
    // updating.
    if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
        scrollEditText(scrollX, scrollY);
        return;
    }
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        scrollLayerTo(scrollX, scrollY);
        return;
    }
    mInOverScrollMode = false;
    int maxX = computeMaxScrollX();
    int maxY = computeMaxScrollY();
    if (maxX == 0) {
        // do not over scroll x if the page just fits the screen
        scrollX = pinLocX(scrollX);
    } else if (scrollX < 0 || scrollX > maxX) {
        mInOverScrollMode = true;
    }
    if (scrollY < 0 || scrollY > maxY) {
        mInOverScrollMode = true;
    }
    int oldX = getScrollX();
    int oldY = getScrollY();
    mWebViewPrivate.super_scrollTo(scrollX, scrollY);
    if (mOverScrollGlow != null) {
        mOverScrollGlow.pullGlow(getScrollX(), getScrollY(), oldX, oldY, maxX, maxY);
    }
}","{
    // updating.
    if (mTouchMode == TOUCH_DRAG_TEXT_MODE) {
        scrollEditText(scrollX, scrollY);
        return;
    }
    if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        scrollLayerTo(scrollX, scrollY);
        animateHandles();
        return;
    }
    mInOverScrollMode = false;
    int maxX = computeMaxScrollX();
    int maxY = computeMaxScrollY();
    if (maxX == 0) {
        // do not over scroll x if the page just fits the screen
        scrollX = pinLocX(scrollX);
    } else if (scrollX < 0 || scrollX > maxX) {
        mInOverScrollMode = true;
    }
    if (scrollY < 0 || scrollY > maxY) {
        mInOverScrollMode = true;
    }
    int oldX = getScrollX();
    int oldY = getScrollY();
    mWebViewPrivate.super_scrollTo(scrollX, scrollY);
    animateHandles();
    if (mOverScrollGlow != null) {
        mOverScrollGlow.pullGlow(getScrollX(), getScrollY(), oldX, oldY, maxX, maxY);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new statement ""animateHandles();"" is added under the condition where ""mTouchMode == TOUCH_DRAG_LAYER_MODE"" and after the ""mWebViewPrivate.super_scrollTo(scrollX, scrollY);"" statement. Therefore, the code change type is 4.","Given that all return statements and exception handlings remain the same, and the variable 'scrollX' and 'scrollY' are locally defined and these values are not altered by the new statement ""animateHandles();"", hence no CI is detected, and the CI type is 0."
586,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,16,17,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,<android.text.format.DateFormat: boolean is24HourFormat(Context)>,0,"{
    String value = Settings.System.getString(context.getContentResolver(), Settings.System.TIME_12_24);
    if (value == null) {
        Locale locale = context.getResources().getConfiguration().locale;
        synchronized (sLocaleLock) {
            if (sIs24HourLocale != null && sIs24HourLocale.equals(locale)) {
                return sIs24Hour;
            }
        }
        java.text.DateFormat natural = java.text.DateFormat.getTimeInstance(java.text.DateFormat.LONG, locale);
        if (natural instanceof SimpleDateFormat) {
            SimpleDateFormat sdf = (SimpleDateFormat) natural;
            String pattern = sdf.toPattern();
            if (pattern.indexOf('H') >= 0) {
                value = ""24"";
            } else {
                value = ""12"";
            }
        } else {
            value = ""12"";
        }
        synchronized (sLocaleLock) {
            sIs24HourLocale = locale;
            sIs24Hour = !value.equals(""12"");
        }
    }
    boolean b24 = !(value == null || value.equals(""12""));
    return b24;
}","{
    String value = Settings.System.getString(context.getContentResolver(), Settings.System.TIME_12_24);
    if (value == null) {
        Locale locale = context.getResources().getConfiguration().locale;
        synchronized (sLocaleLock) {
            if (sIs24HourLocale != null && sIs24HourLocale.equals(locale)) {
                return sIs24Hour;
            }
        }
        java.text.DateFormat natural = java.text.DateFormat.getTimeInstance(java.text.DateFormat.LONG, locale);
        if (natural instanceof SimpleDateFormat) {
            SimpleDateFormat sdf = (SimpleDateFormat) natural;
            String pattern = sdf.toPattern();
            if (pattern.indexOf('H') >= 0) {
                value = ""24"";
            } else {
                value = ""12"";
            }
        } else {
            value = ""12"";
        }
        synchronized (sLocaleLock) {
            sIs24HourLocale = locale;
            sIs24Hour = value.equals(""24"");
        }
        return sIs24Hour;
    }
    return value.equals(""24"");
}",1,"/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
","/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The assignment of sIs24Hour in the synchronization block and the return statement at the end of the function have changed. Moreover, the position of 'return sIs24Hour' has moved, which indicates a control dependency change. Therefore, the change type is 1,3.","The return statements which return 'sIs24Hour' and 'value.equals(""24"")' instead of '!(value == null || value.equals(""12""))' will change the returned values or types of the function. Therefore, the CI type is 1."
589,"<android.os.storage.IMountService.Stub.Proxy: void unmountObb(String,boolean,IObbActionListener,int)>",16,17,"<android.os.storage.IMountService.Stub.Proxy: void unmountObb(String,boolean,IObbActionListener,int)>","<android.os.storage.IMountService.Stub.Proxy: void unmountObb(String,boolean,IObbActionListener,int)>",0,"{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(filename);
        _data.writeInt((force ? 1 : 0));
        _data.writeStrongBinder((token != null ? token.asBinder() : null));
        _data.writeInt(nonce);
        mRemote.transact(Stub.TRANSACTION_unmountObb, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}","{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(rawPath);
        _data.writeInt((force ? 1 : 0));
        _data.writeStrongBinder((token != null ? token.asBinder() : null));
        _data.writeInt(nonce);
        mRemote.transact(Stub.TRANSACTION_unmountObb, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}",1,"/**
 * Unmounts an Opaque Binary Blob (OBB). When the force flag is
 * specified, any program using it will be forcibly killed to
 * unmount the image. MountService will call back to the supplied
 * IObbActionListener to inform it of the terminal state of the
 * call.
 */
","/**
 * Unmounts an Opaque Binary Blob (OBB). When the force flag is
 * specified, any program using it will be forcibly killed to
 * unmount the image. MountService will call back to the supplied
 * IObbActionListener to inform it of the terminal state of the
 * call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the argument variable name used in _data.writeString() has changed from 'filename' to 'rawPath'. It does not change the functionality of the API, so the code change type is 4.","The change is merely a renaming of a local variable. This does not change any of the API's behaviors. Thus, no Compatibility Issues (CI) exist."
590,"<android.widget.CalendarView.WeekView: boolean getDayFromLocation(float,Calendar)>",16,17,"<android.widget.CalendarView.WeekView: boolean getDayFromLocation(float,Calendar)>","<android.widget.CalendarView.WeekView: boolean getDayFromLocation(float,Calendar)>",0,"{
    int dayStart = mShowWeekNumber ? mWidth / mNumCells : 0;
    if (x < dayStart || x > mWidth) {
        outCalendar.clear();
        return false;
    }
    // Selection is (x - start) / (pixels/day) == (x -s) * day / pixels
    int dayPosition = (int) ((x - dayStart) * mDaysPerWeek / (mWidth - dayStart));
    outCalendar.setTimeInMillis(mFirstDay.getTimeInMillis());
    outCalendar.add(Calendar.DAY_OF_MONTH, dayPosition);
    return true;
}","{
    final boolean isLayoutRtl = isLayoutRtl();
    int start;
    int end;
    if (isLayoutRtl) {
        start = 0;
        end = mShowWeekNumber ? mWidth - mWidth / mNumCells : mWidth;
    } else {
        start = mShowWeekNumber ? mWidth / mNumCells : 0;
        end = mWidth;
    }
    if (x < start || x > end) {
        outCalendar.clear();
        return false;
    }
    // Selection is (x - start) / (pixels/day) which is (x - start) * day / pixels
    int dayPosition = (int) ((x - start) * mDaysPerWeek / (end - start));
    if (isLayoutRtl) {
        dayPosition = mDaysPerWeek - 1 - dayPosition;
    }
    outCalendar.setTimeInMillis(mFirstDay.getTimeInMillis());
    outCalendar.add(Calendar.DAY_OF_MONTH, dayPosition);
    return true;
}",1,"/**
 * Calculates the day that the given x position is in, accounting for
 * week number.
 *
 * @param x The x position of the touch event.
 * @return True if a day was found for the given location.
 */
","/**
 * Calculates the day that the given x position is in, accounting for
 * week number.
 *
 * @param x The x position of the touch event.
 * @return True if a day was found for the given location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control flow of the function has changed significantly due to the introduction of the condition based on the 'isLayoutRtl' check. Also, the return statement logic is affected by this change because the calculation of the 'dayPosition' variable has been updated. Therefore, the code change type is 1,3.","The 'dayPosition' calculation in the return statement has been updated. While previously it was calculated similarly, in the later version it undergoes an additional transformation if 'isLayoutRtl' is true. This change could lead to a different return value, hence the CI type is 1."
591,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",16,17,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>","<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int,Bundle)>",0,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].setAllowFds(false);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].setAllowFds(false);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags, options, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The code change in this case involves the parameter of the ""getIntentSender"" API from ActivityManagerNative class, adding a ""UserHandle.myUserId()"" in the late version. Thus, it is classified as Other statement changed (4) and Dependent API changed (5).","This change might possibly affect the return value (PendingIntent object) of the ""getActivities"" API because ""getIntentSender"" is now called with an additional parameter which might influence its behavior. Therefore, there is potentially a compatibility issue caused by a different return value (1)."
592,"<android.webkit.WebViewClassic: boolean onKeyUp(int,KeyEvent)>",16,17,"<android.webkit.WebViewClassic: boolean onKeyUp(int,KeyEvent)>","<android.webkit.WebViewClassic: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && mInitialHitTestResult != null && mInitialHitTestResult.getType() == HitTestResult.PHONE_TYPE) {
        String text = mInitialHitTestResult.getExtra();
        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
        mContext.startActivity(intent);
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // See if the accessibility injector needs to handle this event.
    if (isAccessibilityEnabled() && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
        return true;
    }
    if (isEnterActionKey(keyCode)) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            copySelection();
            selectionDone();
            // discard press if copy in progress
            return true;
        }
    }
    // pass the key to DOM
    sendKeyEvent(event);
    // return true as DOM handles the key
    return true;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && mInitialHitTestResult != null && mInitialHitTestResult.getType() == HitTestResult.PHONE_TYPE) {
        String text = mInitialHitTestResult.getExtra();
        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
        mContext.startActivity(intent);
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // See if the accessibility injector needs to handle this event.
    if (isAccessibilityInjectionEnabled() && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
        return true;
    }
    if (isEnterActionKey(keyCode)) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            copySelection();
            selectionDone();
            // discard press if copy in progress
            return true;
        }
    }
    // pass the key to DOM
    sendKeyEvent(event);
    // return true as DOM handles the key
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The boolean method call has changed from isAccessibilityEnabled() to isAccessibilityInjectionEnabled(). Even though both methods may return a boolean value, their method names differ which means they could have different implementations thus leading to a potential change in return results. Therefore, the changes classify as 1, 5 code change types.","Since the boolean method call providing condition to an if-statement has changed, the return results from the API can vary based on the truth value of the new condition (isAccessibilityInjectionEnabled()). Therefore, there is a potential compatibility issue caused by different return values, classifying as a type 1 CI."
594,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",16,17,"<android.widget.PopupWindow: void update(int,int,int,int,boolean)>","<android.widget.PopupWindow: void update(int,int,int,int,boolean)>",0,"{
    if (width != -1) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height != -1) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}","{
    if (width != -1) {
        mLastWidth = width;
        setWidth(width);
    }
    if (height != -1) {
        mLastHeight = height;
        setHeight(height);
    }
    if (!isShowing() || mContentView == null) {
        return;
    }
    WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
    boolean update = force;
    final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
    if (width != -1 && p.width != finalWidth) {
        p.width = mLastWidth = finalWidth;
        update = true;
    }
    final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
    if (height != -1 && p.height != finalHeight) {
        p.height = mLastHeight = finalHeight;
        update = true;
    }
    if (p.x != x) {
        p.x = x;
        update = true;
    }
    if (p.y != y) {
        p.y = y;
        update = true;
    }
    final int newAnim = computeAnimationResource();
    if (newAnim != p.windowAnimations) {
        p.windowAnimations = newAnim;
        update = true;
    }
    final int newFlags = computeFlags(p.flags);
    if (newFlags != p.flags) {
        p.flags = newFlags;
        update = true;
    }
    if (update) {
        setLayoutDirectionFromAnchor();
        mWindowManager.updateViewLayout(mPopupView, p);
    }
}",1,"/**
 * <p>Updates the position and the dimension of the popup window. Width and
 * height can be set to -1 to update location only.  Calling this function
 * also updates the window with the current popup state as
 * described for {@link #update()}.</p>
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width, can be -1 to ignore
 * @param height the new height, can be -1 to ignore
 * @param force reposition the window even if the specified position
 * already seems to correspond to the LayoutParams
 */
","/**
 * <p>Updates the position and the dimension of the popup window. Width and
 * height can be set to -1 to update location only.  Calling this function
 * also updates the window with the current popup state as
 * described for {@link #update()}.</p>
 *
 * @param x the new x location
 * @param y the new y location
 * @param width the new width, can be -1 to ignore
 * @param height the new height, can be -1 to ignore
 * @param force reposition the window even if the specified position
 * already seems to correspond to the LayoutParams
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The additional method setLayoutDirectionFromAnchor() was invoked in the late version before mWindowManager.updateViewLayout(mPopupView, p), so the change type is 4.","The introduction of the setLayoutDirectionFromAnchor() method has no impact on the return values or exception handling of the current API, so there is no compatibility issue, and the CI type is 0."
595,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>",16,17,"<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>","<android.provider.Settings.Secure: float getFloat(ContentResolver,String,float)>",0,"{
    String v = getString(cr, name);
    try {
        return v != null ? Float.parseFloat(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    return getFloatForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as a floating point number.  Note that internally setting values are
 * always stored as strings; this function converts the string to an
 * float for you. The default value will be returned if the setting
 * is not defined or not a valid float.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid float.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changed from conditionally parsing a float value or returning a default value to invoking getFloatForUser function. In addition, the function that the API relies on has changed to the function getFloatForUser, considering these the change type is 1,5.","Due to the change of return statement, the API will potentially return a different value or type, so the CI type is 1."
596,"<android.view.Display: void getCurrentSizeRange(Point,Point)>",16,17,"<android.view.Display: void getCurrentSizeRange(Point,Point)>","<android.view.Display: void getCurrentSizeRange(Point,Point)>",0,"{
    try {
        IWindowManager wm = getWindowManager();
        wm.getCurrentSizeRange(outSmallestSize, outLargestSize);
    } catch (RemoteException e) {
        Slog.w(""Display"", ""Unable to get display size range"", e);
        outSmallestSize.x = 0;
        outSmallestSize.y = 0;
        outLargestSize.x = 0;
        outLargestSize.y = 0;
    }
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        outSmallestSize.x = mDisplayInfo.smallestNominalAppWidth;
        outSmallestSize.y = mDisplayInfo.smallestNominalAppHeight;
        outLargestSize.x = mDisplayInfo.largestNominalAppWidth;
        outLargestSize.y = mDisplayInfo.largestNominalAppHeight;
    }
}",1,"/**
 * Return the range of display sizes an application can expect to encounter
 * under normal operation, as long as there is no physical change in screen
 * size.  This is basically the sizes you will see as the orientation
 * changes, taking into account whatever screen decoration there is in
 * each rotation.  For example, the status bar is always at the top of the
 * screen, so it will reduce the height both in landscape and portrait, and
 * the smallest height returned here will be the smaller of the two.
 *
 * This is intended for applications to get an idea of the range of sizes
 * they will encounter while going through device rotations, to provide a
 * stable UI through rotation.  The sizes here take into account all standard
 * system decorations that reduce the size actually available to the
 * application: the status bar, navigation bar, system bar, etc.  It does
 * <em>not</em> take into account more transient elements like an IME
 * soft keyboard.
 *
 * @param outSmallestSize Filled in with the smallest width and height
 * that the application will encounter, in pixels (not dp units).  The x
 * (width) dimension here directly corresponds to
 * {@link android.content.res.Configuration#smallestScreenWidthDp
 * Configuration.smallestScreenWidthDp}, except the value here is in raw
 * screen pixels rather than dp units.  Your application may of course
 * still get smaller space yet if, for example, a soft keyboard is
 * being displayed.
 * @param outLargestSize Filled in with the largest width and height
 * that the application will encounter, in pixels (not dp units).  Your
 * application may of course still get larger space than this if,
 * for example, screen decorations like the status bar are being hidden.
 */
","/**
 * Return the range of display sizes an application can expect to encounter
 * under normal operation, as long as there is no physical change in screen
 * size.  This is basically the sizes you will see as the orientation
 * changes, taking into account whatever screen decoration there is in
 * each rotation.  For example, the status bar is always at the top of the
 * screen, so it will reduce the height both in landscape and portrait, and
 * the smallest height returned here will be the smaller of the two.
 *
 * This is intended for applications to get an idea of the range of sizes
 * they will encounter while going through device rotations, to provide a
 * stable UI through rotation.  The sizes here take into account all standard
 * system decorations that reduce the size actually available to the
 * application: the status bar, navigation bar, system bar, etc.  It does
 * <em>not</em> take into account more transient elements like an IME
 * soft keyboard.
 *
 * @param outSmallestSize Filled in with the smallest width and height
 * that the application will encounter, in pixels (not dp units).  The x
 * (width) dimension here directly corresponds to
 * {@link android.content.res.Configuration#smallestScreenWidthDp
 * Configuration.smallestScreenWidthDp}, except the value here is in raw
 * screen pixels rather than dp units.  Your application may of course
 * still get smaller space yet if, for example, a soft keyboard is
 * being displayed.
 * @param outLargestSize Filled in with the largest width and height
 * that the application will encounter, in pixels (not dp units).  Your
 * application may of course still get larger space than this if,
 * for example, screen decorations like the status bar are being hidden.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The interaction with WindowManager to get the display size range is replaced with an internal updateDisplayInfoLocked method and assignments to outSmallestSize and outLargestSize variables. Additionally, newly introduced synchronized block represents a change in control dependency (while loop was removed) and others (updateDisplayInfoLocked method is used). Therefore, the code change type is 1,3,4.","Since the values assigned to outSmallestSize and outLargestSize are fetched in a different way (from mDisplayInfo after calling updateDisplayInfoLocked), the function could potentially return a different value, this constitutes the Compatibility Issue type 1."
597,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordMinimumNumeric(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordMinimumNumeric(admin, length, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * minimum number of numerical digits required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of numerical digits required
 * in the password. A value of 0 means there is no restriction.
 */
","/**
 * Called by an application that is administering the device to set the
 * minimum number of numerical digits required in the password. After
 * setting this, the user will not be able to enter a new password that is
 * not at least as restrictive as what has been set. Note that the current
 * password will remain until the user has set a new one, so the change does
 * not take place immediately. To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value. This
 * constraint is only imposed if the administrator has also requested
 * {@link #PASSWORD_QUALITY_COMPLEX} with {@link #setPasswordQuality}. The
 * default value is 1.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param length The new desired minimum number of numerical digits required
 * in the password. A value of 0 means there is no restriction.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement mService.setPasswordMinimumNumeric(admin, length) changes to mService.setPasswordMinimumNumeric(admin, length, UserHandle.myUserId()), which falls under type 4. Additionally, the additional parameter in the setPasswordMinimumNumeric method in mService indicates a change in the dependent API (Type 5 change).","Despite the changes in method call and dependent API, the function behavior is not changed in terms of return value and exception handling. Hence, no compatibility issue arises from these changes."
598,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",16,17,"<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>","<android.os.storage.StorageManager: boolean unmountObb(String,boolean,OnObbStateChangeListener)>",0,"{
    if (filename == null) {
        throw new IllegalArgumentException(""filename cannot be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""listener cannot be null"");
    }
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.unmountObb(filename, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}","{
    Preconditions.checkNotNull(rawPath, ""rawPath cannot be null"");
    Preconditions.checkNotNull(listener, ""listener cannot be null"");
    try {
        final int nonce = mObbActionListener.addListener(listener);
        mMountService.unmountObb(rawPath, force, mObbActionListener, nonce);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, ""Failed to mount OBB"", e);
    }
    return false;
}",1,"/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param filename path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
","/**
 * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the
 * <code>force</code> flag is true, it will kill any application needed to
 * unmount the given OBB (even the calling application).
 * <p>
 * The {@link OnObbStateChangeListener} registered with this call will
 * receive the success or failure of this operation.
 * <p>
 * <em>Note:</em> you can only mount OBB files for which the OBB tag on the
 * file matches a package ID that is owned by the calling program's UID.
 * That is, shared UID applications can obtain access to any other
 * application's OBB that shares its UID.
 * <p>
 *
 * @param rawPath path to the OBB file
 * @param force whether to kill any programs using this in order to unmount
 * it
 * @param listener will receive the success or failure of the operation
 * @return whether the unmount call was successfully queued or not
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The code change includes adjustments in the exception handling where explicit 'throw new IllegalArgumentException' statements have been replaced by 'Preconditions.checkNotNull' statements. Also, the parameter for 'mMountService.unmountObb' method changed from filename to rawPath, it belongs to type 1,4.","The change in exception statements - from explicit throws to Preconditions.checkNotNull means that the type of exception that the method could throw has been changed from IllegalArgumentException to NullPointerException in case the conditions aren't met (i.e., if either 'rawPath' or 'listener' are null). Not to mention, potential different return value due to the change of parameter in 'mMountService.unmountObb' method. Thus, the CI is type 1."
599,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,16,17,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                if (getChildCount() == 0) {
                    return false;
                }
                if ((mIsBeingDragged = !mScroller.isFinished())) {
                    final ViewParent parent = getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
            if (activePointerIndex == -1) {
                Log.e(TAG, ""Invalid pointerId="" + mActivePointerId + "" in onTouchEvent"");
                break;
            }
            final int y = (int) ev.getY(activePointerIndex);
            int deltaY = mLastMotionY - y;
            if (!mIsBeingDragged && Math.abs(deltaY) > mTouchSlop) {
                final ViewParent parent = getParent();
                if (parent != null) {
                    parent.requestDisallowInterceptTouchEvent(true);
                }
                mIsBeingDragged = true;
                if (deltaY > 0) {
                    deltaY -= mTouchSlop;
                } else {
                    deltaY += mTouchSlop;
                }
            }
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        postInvalidateOnAnimation();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            postInvalidateOnAnimation();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    postInvalidateOnAnimation();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionY = (int) ev.getY(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = (int) ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new piece of checking logic has been added in the new version code under MotionEvent.ACTION_MOVE in the switch case, increasing the value checked for activePointerIndex. So the code change type is 3 (control dependency change).","This new checking logic will affect the sequence of execution and the final output of this method, potentially causing a different behavior, so the CI type is 1 (potential different return values)."
600,"<android.webkit.CallbackProxy: void onReceivedClientCertRequest(ClientCertRequestHandler,String)>",16,17,"<android.webkit.CallbackProxy: void onReceivedClientCertRequest(ClientCertRequestHandler,String)>","<android.webkit.CallbackProxy: void onReceivedClientCertRequest(ClientCertRequestHandler,String)>",0,"{
    // been set.
    if (mWebViewClient == null) {
        handler.cancel();
        return;
    }
    Message msg = obtainMessage(CLIENT_CERT_REQUEST);
    HashMap<String, Object> map = new HashMap();
    map.put(""handler"", handler);
    map.put(""host_and_port"", host_and_port);
    msg.obj = map;
    sendMessage(msg);
}","{
    // been set.
    if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
        handler.cancel();
        return;
    }
    Message msg = obtainMessage(CLIENT_CERT_REQUEST);
    HashMap<String, Object> map = new HashMap();
    map.put(""handler"", handler);
    map.put(""host_and_port"", host_and_port);
    msg.obj = map;
    sendMessage(msg);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control statement on the line 'if (mWebViewClient == null)' has changed - a new check is added to see if 'mWebViewClient' is an instance of 'WebViewClientClassicExt', which classifies as a control dependency change (3).","The change in the 'if' statement could potentially alter the behavior of the method call. Because of the added condition check, 'handler.cancel()' might be executed where it previously wasn't, thus potentially changing the return behavior of the API, causing a compatibility issue of type 1."
601,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",16,17,"<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>","<android.app.ActivityManager: List<RecentTaskInfo> getRecentTasks(int,int)>",0,"{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId());
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}",1,"/**
 * Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 *
 * @throws SecurityException Throws SecurityException if the caller does
 * not hold the {@link android.Manifest.permission#GET_TASKS} permission.
 */
","/**
 * Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 *
 * @throws SecurityException Throws SecurityException if the caller does
 * not hold the {@link android.Manifest.permission#GET_TASKS} permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the API, the dependent method getRecentTasks() has an additional parameter - UserHandle.myUserId() in the later version. The return statement has been changed due to this invocation change. Therefore, the change occurs in both return statement and Dependent API - code change types 1 and 5.","This change might make the API return a different value, as the parameter of the dependent method has been changed. Thus, compatibility issue arises due to the potential different return values - CI type 1."
603,"<android.provider.Settings.System: int getInt(ContentResolver,String)>",16,17,"<android.provider.Settings.System: int getInt(ContentResolver,String)>","<android.provider.Settings.System: int getInt(ContentResolver,String)>",0,"{
    String v = getString(cr, name);
    try {
        return Integer.parseInt(v);
    } catch (NumberFormatException e) {
        throw new SettingNotFoundException(name);
    }
}","{
    return getIntForUser(cr, name, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
","/**
 * Convenience function for retrieving a single system settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.
 * <p>
 * This version does not take a default value.  If the setting has not
 * been set, or the string value is not a number,
 * it throws {@link SettingNotFoundException}.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 *
 * @throws SettingNotFoundException Thrown if a setting by the given
 * name can't be found or the setting value is not an integer.
 *
 * @return The setting's current value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of the function has changed. Instead of parsing an integer from a string, the new implementation directly calls a different method getIntForUser(),  so the code change type is 1,5.","As the return statement has changed, the method could potentially return different values in the new version hence the CI type is 1."
604,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,16,17,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.TabHost: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    final boolean handled = super.dispatchKeyEvent(event);
    // when there is nothing that will take focus from default focus searching
    if (!handled && (event.getAction() == KeyEvent.ACTION_DOWN) && (event.getKeyCode() == KeyEvent.KEYCODE_DPAD_UP) && (mCurrentView != null) && (mCurrentView.isRootNamespace()) && (mCurrentView.hasFocus()) && (mCurrentView.findFocus().focusSearch(View.FOCUS_UP) == null)) {
        mTabWidget.getChildTabViewAt(mCurrentTab).requestFocus();
        playSoundEffect(SoundEffectConstants.NAVIGATION_UP);
        return true;
    }
    return handled;
}","{
    final boolean handled = super.dispatchKeyEvent(event);
    // focus searching
    if (!handled && (event.getAction() == KeyEvent.ACTION_DOWN) && (mCurrentView != null) && (mCurrentView.isRootNamespace()) && (mCurrentView.hasFocus())) {
        int keyCodeShouldChangeFocus = KeyEvent.KEYCODE_DPAD_UP;
        int directionShouldChangeFocus = View.FOCUS_UP;
        int soundEffect = SoundEffectConstants.NAVIGATION_UP;
        switch(getTabWidgetLocation()) {
            case TABWIDGET_LOCATION_LEFT:
                keyCodeShouldChangeFocus = KeyEvent.KEYCODE_DPAD_LEFT;
                directionShouldChangeFocus = View.FOCUS_LEFT;
                soundEffect = SoundEffectConstants.NAVIGATION_LEFT;
                break;
            case TABWIDGET_LOCATION_RIGHT:
                keyCodeShouldChangeFocus = KeyEvent.KEYCODE_DPAD_RIGHT;
                directionShouldChangeFocus = View.FOCUS_RIGHT;
                soundEffect = SoundEffectConstants.NAVIGATION_RIGHT;
                break;
            case TABWIDGET_LOCATION_BOTTOM:
                keyCodeShouldChangeFocus = KeyEvent.KEYCODE_DPAD_DOWN;
                directionShouldChangeFocus = View.FOCUS_DOWN;
                soundEffect = SoundEffectConstants.NAVIGATION_DOWN;
                break;
            case TABWIDGET_LOCATION_TOP:
            default:
                keyCodeShouldChangeFocus = KeyEvent.KEYCODE_DPAD_UP;
                directionShouldChangeFocus = View.FOCUS_UP;
                soundEffect = SoundEffectConstants.NAVIGATION_UP;
                break;
        }
        if (event.getKeyCode() == keyCodeShouldChangeFocus && mCurrentView.findFocus().focusSearch(directionShouldChangeFocus) == null) {
            mTabWidget.getChildTabViewAt(mCurrentTab).requestFocus();
            playSoundEffect(soundEffect);
            return true;
        }
    }
    return handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"The control dependency including 'if' and 'switch' has changed, and the return statement requests different conditions to return 'true'. Therefore, the changes belong to the types 3 and 1.","The changes in control dependency and return statements could possibly lead to a different return value. Therefore, the CI is of type 1."
605,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,16,17,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,<android.bluetooth.BluetoothDevice: BluetoothClass getBluetoothClass()>,0,"{
    try {
        int classInt = sService.getRemoteClass(mAddress);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (sService == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Bluetooth Class"");
        return null;
    }
    try {
        int classInt = sService.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the Bluetooth class of the remote device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return Bluetooth class object, or null on error
 */
","/**
 * Get the Bluetooth class of the remote device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return Bluetooth class object, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"There is a new condition 'if' introduced in the late version. Furthermore, the method getRemoteClass() in the try block has changed it's parameter from 'mAddress' to 'this', which is an other type of statement and a dependent API change. So the code change types are 3,4,5.","As the new introduced 'if' statement could make a return before executing the following 'try' block, and the changed parameter of getRemoteClass() may also lead to different return values of 'new BluetoothClass(classInt)', the CI type is 1."
606,<android.view.View: int[] getDrawableState()>,16,17,<android.view.View: int[] getDrawableState()>,<android.view.View: int[] getDrawableState()>,0,"{
    if ((mDrawableState != null) && ((mPrivateFlags & DRAWABLE_STATE_DIRTY) == 0)) {
        return mDrawableState;
    } else {
        mDrawableState = onCreateDrawableState(0);
        mPrivateFlags &= ~DRAWABLE_STATE_DIRTY;
        return mDrawableState;
    }
}","{
    if ((mDrawableState != null) && ((mPrivateFlags & PFLAG_DRAWABLE_STATE_DIRTY) == 0)) {
        return mDrawableState;
    } else {
        mDrawableState = onCreateDrawableState(0);
        mPrivateFlags &= ~PFLAG_DRAWABLE_STATE_DIRTY;
        return mDrawableState;
    }
}",1,"/**
 * Return an array of resource IDs of the drawable states representing the
 * current state of the view.
 *
 * @return The current drawable state
 *
 * @see Drawable#setState(int[])
 * @see #drawableStateChanged()
 * @see #onCreateDrawableState(int)
 */
","/**
 * Return an array of resource IDs of the drawable states representing the
 * current state of the view.
 *
 * @return The current drawable state
 *
 * @see Drawable#setState(int[])
 * @see #drawableStateChanged()
 * @see #onCreateDrawableState(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5","1,2","The condition statement in the 'if' clause ((mPrivateFlags & DRAWABLE_STATE_DIRTY) changes to (mPrivateFlags & PFLAG_DRAWABLE_STATE_DIRTY)) and the statement 'mPrivateFlags &= ~DRAWABLE_STATE_DIRTY' changes to 'mPrivateFlags &= ~PFLAG_DRAWABLE_STATE_DIRTY' has been modified. The change included the modification in the method name and alterations in the type of parameters. Therefore, the code change type is 4,5. ","The modification in the condition and method could potentially cause this API to return different values or throw exceptions under certain conditions. Therefore, the CI type is 1,2."
608,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,16,17,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,<android.app.FragmentManagerImpl: void makeInactive(Fragment)>,0,"{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mActivity.invalidateFragmentIndex(f.mIndex);
    f.initState();
}","{
    if (f.mIndex < 0) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, ""Freeing fragment index "" + f);
    mActive.set(f.mIndex, null);
    if (mAvailIndices == null) {
        mAvailIndices = new ArrayList<Integer>();
    }
    mAvailIndices.add(f.mIndex);
    mActivity.invalidateFragment(f.mWho);
    f.initState();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is a statement changed from mActivity.invalidateFragmentIndex(f.mIndex) to mActivity.invalidateFragment(f.mWho), so the code change type is 4.","The calling statement changed can potentially make the API behave differently because 'f.mWho' can be different from 'f.mIndex', so the CI type is 1."
609,<android.appwidget.AppWidgetHostView: View getDefaultView()>,16,17,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            defaultView = inflater.inflate(mInfo.initialLayout, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContext(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo + "": "" + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,1",1,"The late version of the code has added more logic to the try block to handle additional scenarios, which doesn't implicate any control dependency change, so it is classified as a ""Other statement change (4)"". The return statement `return defaultView;` remains the same in both versions, however, the process to construct `defaultView` has changed, which causes the ""Return statement changed (1)"".","Since the process to construct `defaultView` has changed in the late version, it could potentially make the API return different values (the `defaultView`). Therefore, it causes the ""Compatibility issue arise potentially from different return values (1)""."
611,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,16,17,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = ViewRootImpl.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = WindowManagerGlobal.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The dependent API (ViewRootImpl.getWindowSession(getMainLooper())) has been changed to a new one (WindowManagerGlobal.getWindowSession(getMainLooper())). Therefore, the code change type is 5.","Even though the dependent API changed, it does not affect the behaviour of the method. The same values or types are returned, and the exception handling isn't different. Therefore, there's no Compatibility Issue. The CI type is 0."
612,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",16,17,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_BROADCAST, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    return getBroadcastAsUser(context, requestCode, intent, flags, new UserHandle(UserHandle.myUserId()));
}",1,"/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In late implementation, method call in the return statement has changed entirely, so the code change type falls under 1(return statement changed) and 5(dependent API changed). ","The return statement shift from multiple steps operation to single API call in late implementation, thus the API could potentially return a different value than the early version and hence the CI type is 1."
613,<android.widget.Toast.TN: void handleShow()>,16,17,<android.widget.Toast.TN: void handleShow()>,<android.widget.Toast.TN: void handleShow()>,0,"{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        mWM = WindowManagerImpl.getDefault();
        final int gravity = mGravity;
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}","{
    if (localLOGV)
        Log.v(TAG, ""HANDLE SHOW: "" + this + "" mView="" + mView + "" mNextView="" + mNextView);
    if (mView != mNextView) {
        // remove the old view if necessary
        handleHide();
        mView = mNextView;
        mWM = (WindowManager) mView.getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        // We can resolve the Gravity here by using the Locale for getting
        // the layout direction
        final Configuration config = mView.getContext().getResources().getConfiguration();
        final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());
        mParams.gravity = gravity;
        if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
            mParams.horizontalWeight = 1.0f;
        }
        if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
            mParams.verticalWeight = 1.0f;
        }
        mParams.x = mX;
        mParams.y = mY;
        mParams.verticalMargin = mVerticalMargin;
        mParams.horizontalMargin = mHorizontalMargin;
        if (mView.getParent() != null) {
            if (localLOGV)
                Log.v(TAG, ""REMOVE! "" + mView + "" in "" + this);
            mWM.removeView(mView);
        }
        if (localLOGV)
            Log.v(TAG, ""ADD! "" + mView + "" in "" + this);
        mWM.addView(mView, mParams);
        trySendAccessibilityEvent();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"Both the initialization of mWM and the calculation of gravity have changed. The initialization is now using the getWindowManager() method and the gravity is getting the absolute gravity now. Both of these methods are from a different dependent API, thus the change categorization is 4,5.","Though there are changes in dependent API and some basic calculations, they do not cause this API to potentially return different values or exceptions. Hence, there are no compatibility issues, Category is 0."
614,<android.app.Activity: void performRestart()>,16,17,<android.app.Activity: void performRestart()>,<android.app.Activity: void performRestart()>,0,"{
    mFragments.noteStateNotSaved();
    if (mStopped) {
        mStopped = false;
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, false);
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}","{
    mFragments.noteStateNotSaved();
    if (mStopped) {
        mStopped = false;
        if (mToken != null && mParent == null) {
            WindowManagerGlobal.getInstance().setStoppedState(mToken, false);
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There's a statement change from WindowManagerImpl.getDefault().setStoppedState(mToken, false) in the early version to WindowManagerGlobal.getInstance().setStoppedState(mToken, false) in the late version. This reflects both an Other statement change (Class 4) and a Dependent API change (class 5) since WindowManagerImpl.getDefault() has changed to WindowManagerGlobal.getInstance().","There is no compatibility issue as this change in the method doesn't cause the API to return a different variable (value or type), nor does it throw the exception differently. Hence, the CI classification is 0."
615,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,16,17,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,<android.bluetooth.BluetoothAdapter: BluetoothAdapter getDefaultAdapter()>,0,"{
    if (sAdapter == null) {
        IBinder b = ServiceManager.getService(BluetoothAdapter.BLUETOOTH_SERVICE);
        if (b != null) {
            IBluetooth service = IBluetooth.Stub.asInterface(b);
            sAdapter = new BluetoothAdapter(service);
        }
    }
    return sAdapter;
}","{
    if (sAdapter == null) {
        IBinder b = ServiceManager.getService(BLUETOOTH_MANAGER_SERVICE);
        if (b != null) {
            IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);
            sAdapter = new BluetoothAdapter(managerService);
        } else {
            Log.e(TAG, ""Bluetooth binder is null"");
        }
    }
    return sAdapter;
}",1,"/**
 * Get a handle to the default local Bluetooth adapter.
 * <p>Currently Android only supports one Bluetooth adapter, but the API
 * could be extended to support more. This will always return the default
 * adapter.
 * @return the default local adapter, or null if Bluetooth is not supported
 * on this hardware platform
 */
","/**
 * Get a handle to the default local Bluetooth adapter.
 * <p>Currently Android only supports one Bluetooth adapter, but the API
 * could be extended to support more. This will always return the default
 * adapter.
 * @return the default local adapter, or null if Bluetooth is not supported
 * on this hardware platform
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has not changed, but the method of getting value for 'sAdapter' variable changed. The DBUS service we are connecting to has changed from BluetoothAdapter.BLUETOOTH_SERVICE to BLUETOOTH_MANAGER_SERVICE and the type of the service interface also changed. Therefore, the statement inside 'if' as well as the dependent API(ServiceManager.getService()) has changed as well. So the code change is 1,4,5.","The 'return sAdapter' value is potentially different due to the changes in how 'sAdapter' gets assigned. This could lead to potential compatibility issues, defined as type 1."
616,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,16,17,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,<android.accounts.AccountManagerService.Session: void onResult(Bundle)>,0,"{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(mAccounts, account));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onError() on response "" + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
                }
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}","{
    mNumResults++;
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(mAccounts, account), new UserHandle(mAccounts.userId));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onError() on response "" + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle returned"");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
                }
                response.onResult(result);
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The function call `cancelNotification()` changes to include more arguments. This is an addition rather than a change in the control, return or exception, hence we consider it as Other statement changed.",No compatibility issues are detected as the additional parameter would not lead to a change in the return value nor the exception handling of the compared APIs.
617,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,16,17,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,<android.view.ViewRootImpl.ViewRootHandler: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.release();
            break;
        case MSG_IME_FINISHED_EVENT:
            handleImeFinishedEvent(msg.arg1, msg.arg2 != 0);
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            ResizedInfo ri = (ResizedInfo) msg.obj;
            if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.contentInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo) msg.obj).newConfig == null) {
                break;
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                Configuration config = ((ResizedInfo) msg.obj).newConfig;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.left = 0;
                mWinFrame.right = msg.arg1;
                mWinFrame.top = 0;
                mWinFrame.bottom = msg.arg2;
                mPendingContentInsets.set(((ResizedInfo) msg.obj).contentInsets);
                mPendingVisibleInsets.set(((ResizedInfo) msg.obj).visibleInsets);
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder);
                            } catch (Surface.OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!sWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_KEY:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_INVALIDATE_DISPLAY_LIST:
            {
                invalidateDisplayLists();
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                invalidateWorld(mView);
            }
            break;
    }
}","{
    switch(msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.release();
            break;
        case MSG_IME_FINISHED_EVENT:
            handleImeFinishedEvent(msg.arg1, msg.arg2 != 0);
            break;
        case MSG_PROCESS_INPUT_EVENTS:
            mProcessInputEventsScheduled = false;
            doProcessInputEvents();
            break;
        case MSG_DISPATCH_APP_VISIBILITY:
            handleAppVisibility(msg.arg1 != 0);
            break;
        case MSG_DISPATCH_GET_NEW_SURFACE:
            handleGetNewSurface();
            break;
        case MSG_RESIZED:
            {
                // Recycled in the fall through...
                SomeArgs args = (SomeArgs) msg.obj;
                if (mWinFrame.equals(args.arg1) && mPendingContentInsets.equals(args.arg2) && mPendingVisibleInsets.equals(args.arg3) && args.arg4 == null) {
                    break;
                }
            }
        // fall through...
        case MSG_RESIZED_REPORT:
            if (mAdded) {
                SomeArgs args = (SomeArgs) msg.obj;
                Configuration config = (Configuration) args.arg4;
                if (config != null) {
                    updateConfiguration(config, false);
                }
                mWinFrame.set((Rect) args.arg1);
                mPendingContentInsets.set((Rect) args.arg2);
                mPendingVisibleInsets.set((Rect) args.arg3);
                args.recycle();
                if (msg.what == MSG_RESIZED_REPORT) {
                    mReportNextDraw = true;
                }
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_MOVED:
            if (mAdded) {
                final int w = mWinFrame.width();
                final int h = mWinFrame.height();
                final int l = msg.arg1;
                final int t = msg.arg2;
                mWinFrame.left = l;
                mWinFrame.right = l + w;
                mWinFrame.top = t;
                mWinFrame.bottom = t + h;
                if (mView != null) {
                    forceLayout(mView);
                }
                requestLayout();
            }
            break;
        case MSG_WINDOW_FOCUS_CHANGED:
            {
                if (mAdded) {
                    boolean hasWindowFocus = msg.arg1 != 0;
                    mAttachInfo.mHasWindowFocus = hasWindowFocus;
                    profileRendering(hasWindowFocus);
                    if (hasWindowFocus) {
                        boolean inTouchMode = msg.arg2 != 0;
                        ensureTouchModeLocally(inTouchMode);
                        if (mAttachInfo.mHardwareRenderer != null && mSurface != null && mSurface.isValid()) {
                            mFullRedrawNeeded = true;
                            try {
                                if (mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth, mHeight, mHolder.getSurface())) {
                                    mFullRedrawNeeded = true;
                                }
                            } catch (Surface.OutOfResourcesException e) {
                                Log.e(TAG, ""OutOfResourcesException locking surface"", e);
                                try {
                                    if (!mWindowSession.outOfMemory(mWindow)) {
                                        Slog.w(TAG, ""No processes killed for memory; killing self"");
                                        Process.killProcess(Process.myPid());
                                    }
                                } catch (RemoteException ex) {
                                }
                                // Retry in a bit.
                                sendMessageDelayed(obtainMessage(msg.what, msg.arg1, msg.arg2), 500);
                                return;
                            }
                        }
                    }
                    mLastWasImTarget = WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (mView != null) {
                        if (hasWindowFocus && imm != null && mLastWasImTarget) {
                            imm.startGettingWindowFocus(mView);
                        }
                        mAttachInfo.mKeyDispatchState.reset();
                        mView.dispatchWindowFocusChanged(hasWindowFocus);
                    }
                    // so all of the view state is set up correctly.
                    if (hasWindowFocus) {
                        if (imm != null && mLastWasImTarget) {
                            imm.onWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags);
                        }
                        // Clear the forward bit.  We can just do this directly, since
                        // the window manager doesn't care about it.
                        mWindowAttributes.softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        ((WindowManager.LayoutParams) mView.getLayoutParams()).softInputMode &= ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
                        mHasHadWindowFocus = true;
                    }
                    setAccessibilityFocus(null, null);
                    if (mView != null && mAccessibilityManager.isEnabled()) {
                        if (hasWindowFocus) {
                            mView.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
                        }
                    }
                }
            }
            break;
        case MSG_DIE:
            doDie();
            break;
        case MSG_DISPATCH_KEY:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                enqueueInputEvent(event, null, 0, true);
            }
            break;
        case MSG_DISPATCH_KEY_FROM_IME:
            {
                if (LOCAL_LOGV)
                    Log.v(TAG, ""Dispatching key "" + msg.obj + "" from IME to "" + mView);
                KeyEvent event = (KeyEvent) msg.obj;
                if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
                    // The IME is trying to say this event is from the
                    // system!  Bad bad bad!
                    // noinspection UnusedAssignment
                    event = KeyEvent.changeFlags(event, event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
                }
                enqueueInputEvent(event, null, QueuedInputEvent.FLAG_DELIVER_POST_IME, true);
            }
            break;
        case MSG_FINISH_INPUT_CONNECTION:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.reportFinishInputConnection((InputConnection) msg.obj);
                }
            }
            break;
        case MSG_CHECK_FOCUS:
            {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    imm.checkFocus();
                }
            }
            break;
        case MSG_CLOSE_SYSTEM_DIALOGS:
            {
                if (mView != null) {
                    mView.onCloseSystemDialogs((String) msg.obj);
                }
            }
            break;
        case MSG_DISPATCH_DRAG_EVENT:
        case MSG_DISPATCH_DRAG_LOCATION_EVENT:
            {
                DragEvent event = (DragEvent) msg.obj;
                // only present when this app called startDrag()
                event.mLocalState = mLocalDragState;
                handleDragEvent(event);
            }
            break;
        case MSG_DISPATCH_SYSTEM_UI_VISIBILITY:
            {
                handleDispatchSystemUiVisibilityChanged((SystemUiVisibilityInfo) msg.obj);
            }
            break;
        case MSG_UPDATE_CONFIGURATION:
            {
                Configuration config = (Configuration) msg.obj;
                if (config.isOtherSeqNewer(mLastConfiguration)) {
                    config = mLastConfiguration;
                }
                updateConfiguration(config, false);
            }
            break;
        case MSG_DISPATCH_SCREEN_STATE:
            {
                if (mView != null) {
                    handleScreenStateChange(msg.arg1 == 1);
                }
            }
            break;
        case MSG_INVALIDATE_DISPLAY_LIST:
            {
                invalidateDisplayLists();
            }
            break;
        case MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST:
            {
                setAccessibilityFocus(null, null);
            }
            break;
        case MSG_DISPATCH_DONE_ANIMATING:
            {
                handleDispatchDoneAnimating();
            }
            break;
        case MSG_INVALIDATE_WORLD:
            {
                if (mView != null) {
                    invalidateWorld(mView);
                }
            }
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
618,<android.content.res.Configuration: int updateFrom(Configuration)>,16,17,<android.content.res.Configuration: int updateFrom(Configuration)>,<android.content.res.Configuration: int updateFrom(Configuration)>,0,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        layoutDirection = LocaleUtil.getLayoutDirectionFromLocale(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        // If locale has changed, then layout direction is also changed ...
        changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION;
        // ... and we need to update the layout direction (represented by the first
        // 2 most significant bits in screenLayout).
        setLayoutDirection(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (getScreenLayoutNoDirection(delta.screenLayout) != (SCREENLAYOUT_SIZE_UNDEFINED | SCREENLAYOUT_LONG_UNDEFINED) && (getScreenLayoutNoDirection(screenLayout) != getScreenLayoutNoDirection(delta.screenLayout))) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        // We need to preserve the previous layout dir bits if they were defined
        if ((delta.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) == 0) {
            screenLayout = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) | delta.screenLayout;
        } else {
            screenLayout = delta.screenLayout;
        }
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.densityDpi != DENSITY_DPI_UNDEFINED) {
        changed |= ActivityInfo.CONFIG_DENSITY;
        densityDpi = delta.densityDpi;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The implementation code has been changed under the condition statement for 'delta.locale' and 'delta.screenLayout'. Also, a new statement about 'delta.densityDpi' has been added in the late version, so the code change type is 3,4.","There are potential changes in controlling dependencies and other statements which could result in a change in output(return). Also, the result 'changed' is generated by bitwise operation, which makes it sensitive to any change in any of its associated conditions. This may cause the API to potentially return different values, thus the CI type is 1."
620,"<android.webkit.WebViewClassic: boolean requestFocus(int,Rect)>",16,17,"<android.webkit.WebViewClassic: boolean requestFocus(int,Rect)>","<android.webkit.WebViewClassic: boolean requestFocus(int,Rect)>",0,"{
    // background window, it can steal focus.
    if (mFindIsUp)
        return false;
    boolean result = false;
    result = mWebViewPrivate.super_requestFocus(direction, previouslyFocusedRect);
    if (mWebViewCore.getSettings().getNeedInitialFocus() && !mWebView.isInTouchMode()) {
        // For cases such as GMail, where we gain focus from a direction,
        // we want to move to the first available link.
        // FIXME: If there are no visible links, we may not want to
        int fakeKeyDirection = 0;
        switch(direction) {
            case View.FOCUS_UP:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                break;
            case View.FOCUS_DOWN:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                break;
            case View.FOCUS_LEFT:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                break;
            case View.FOCUS_RIGHT:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                break;
            default:
                return result;
        }
        mWebViewCore.sendMessage(EventHub.SET_INITIAL_FOCUS, fakeKeyDirection);
    }
    return result;
}","{
    // Check if we are destroyed
    if (mWebViewCore == null)
        return false;
    // background window, it can steal focus.
    if (mFindIsUp)
        return false;
    boolean result = false;
    result = mWebViewPrivate.super_requestFocus(direction, previouslyFocusedRect);
    if (mWebViewCore.getSettings().getNeedInitialFocus() && !mWebView.isInTouchMode()) {
        // For cases such as GMail, where we gain focus from a direction,
        // we want to move to the first available link.
        // FIXME: If there are no visible links, we may not want to
        int fakeKeyDirection = 0;
        switch(direction) {
            case View.FOCUS_UP:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_UP;
                break;
            case View.FOCUS_DOWN:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_DOWN;
                break;
            case View.FOCUS_LEFT:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_LEFT;
                break;
            case View.FOCUS_RIGHT:
                fakeKeyDirection = KeyEvent.KEYCODE_DPAD_RIGHT;
                break;
            default:
                return result;
        }
        mWebViewCore.sendMessage(EventHub.SET_INITIAL_FOCUS, fakeKeyDirection);
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"The condition When check if mWebViewCore is null has been added, and a new return statement 'return false' has been introduced when mWebViewCore is null. Hence, the change type is 3,1.","The newly added return statement inside the conditional block can potentially cause this method to return a different value in the later version. Therefore, the compatibility issue can be caused by potential different return values, resulting in the CI type being 1."
621,<android.bluetooth.BluetoothHeadset: void close()>,16,17,<android.bluetooth.BluetoothHeadset: void close()>,<android.bluetooth.BluetoothHeadset: void close()>,0,"{
    if (DBG)
        log(""close()"");
    if (mConnection != null) {
        mContext.unbindService(mConnection);
        mConnection = null;
    }
    mServiceListener = null;
}","{
    if (VDBG)
        log(""close()"");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, """", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, """", re);
            }
        }
    }
    mServiceListener = null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4",2,"The first thing to note is the change from the check of 'DBG' to 'VDBG' log statement, which falls under ""4) Other statement changed"". Moreover, a new exception handling logic has been introduced and a try-catch block also added, which merits ""2) Exception handling statement changed"". In addition, the control statements associated with the `synchronized (mConnection)` block have changed, constituting a ""3) Control dependency changed"". Furthermore, the final return statement (mServiceListener = null), even though not inherently returning any value, can be interpreted as a form of return statement that has changed when examining both versions of the implementation -  it is not conditional in the early version but is conditional in the late version, hence it can be categorized as ""1) Return statement changed"". ","In the late implementation, a new exception handling mechanism is introduced, causing the method to potentially behave differently when faced with an exception. This can lead to different runtime behavior between the two versions and therefore we can classify it as ""2) Compatibility Issue caused by potential different exception handlings""."
622,<android.view.Display: float getRefreshRate()>,16,17,<android.view.Display: float getRefreshRate()>,<android.view.Display: float getRefreshRate()>,0,"{
    return mRefreshRate;
}","{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.refreshRate;
    }
}",1,"/**
 * Return the refresh rate of this display in frames per second.
 */
","/**
 * Gets the refresh rate of this display in frames per second.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, prior to the return statement, two additional lines of code have been added where the value of mRefreshRate has been updated using updateDisplayInfoLocked() before it gets returned. Also, a synchronization block was introduced so the change type is 1,3,4.","The update of mDisplayInfo.refreshRate implies that the return value in the late version is conditioned to the result of the method updateDisplayInfoLocked(), which makes the two versions possibly return different values. Therefore, the CI type is 1."
623,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",16,17,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>","<android.app.ContextImpl: void sendBroadcast(Intent,String)>",0,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false, Binder.getOrigCallingUser());
    } catch (RemoteException e) {
    }
}","{
    warnIfCallingFromSystemProcess();
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false, getUserId());
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"There's an extra method call `warnIfCallingFromSystemProcess()` in the beginning of the Late_Implementation, which is considered as 'other statement changed'. Moreover, another dependent method call parameter has been changed from `Binder.getOrigCallingUser()` to `getUserId()`, this constitutes a 'Dependent API changed'. Thus, the code change type is 4,5.","The introduction of `warnIfCallingFromSystemProcess()` could potentially alter the API's behavior, leading to different return values. Moreover, the change in `getUserId()` instead of `Binder.getOrigCallingUser()` also affects the eventual output/behavior of the 'sendBroadcast' method, leading to potentially different return values or even exceptions. Hence, the CI type is 1."
624,"<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",16,17,"<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>","<android.app.ContextImpl: Intent registerReceiver(BroadcastReceiver,IntentFilter,String,Handler)>",0,"{
    return registerReceiverInternal(receiver, filter, broadcastPermission, scheduler, getOuterContext());
}","{
    return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The function call in the return statement has changed, with an additional argument 'getUserId()' in the late version. So, the code change type is 1,5.","Due to the addition of the 'getUserId()' argument, the function might return different results between the two versions, resulting in a potential different return value. Therefore, a compatibility issue of type 1 (Return statement changed) exists."
626,<android.view.View: int getImportantForAccessibility()>,16,17,<android.view.View: int getImportantForAccessibility()>,<android.view.View: int getImportantForAccessibility()>,0,"{
    return (mPrivateFlags2 & IMPORTANT_FOR_ACCESSIBILITY_MASK) >> IMPORTANT_FOR_ACCESSIBILITY_SHIFT;
}","{
    return (mPrivateFlags2 & PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_MASK) >> PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT;
}",1,"/**
 * Gets the mode for determining whether this View is important for accessibility
 * which is if it fires accessibility events and if it is reported to
 * accessibility services that query the screen.
 *
 * @return The mode for determining whether a View is important for accessibility.
 *
 * @attr ref android.R.styleable#View_importantForAccessibility
 *
 * @see #IMPORTANT_FOR_ACCESSIBILITY_YES
 * @see #IMPORTANT_FOR_ACCESSIBILITY_NO
 * @see #IMPORTANT_FOR_ACCESSIBILITY_AUTO
 */
","/**
 * Gets the mode for determining whether this View is important for accessibility
 * which is if it fires accessibility events and if it is reported to
 * accessibility services that query the screen.
 *
 * @return The mode for determining whether a View is important for accessibility.
 *
 * @attr ref android.R.styleable#View_importantForAccessibility
 *
 * @see #IMPORTANT_FOR_ACCESSIBILITY_YES
 * @see #IMPORTANT_FOR_ACCESSIBILITY_NO
 * @see #IMPORTANT_FOR_ACCESSIBILITY_AUTO
 */
",-1,"[@ViewDebug.ExportedProperty(category = ""accessibility"", mapping = { @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_AUTO, to = ""auto""), @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_YES, to = ""yes""), @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_NO, to = ""no"") })]","[@ViewDebug.ExportedProperty(category = ""accessibility"", mapping = { @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_AUTO, to = ""auto""), @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_YES, to = ""yes""), @ViewDebug.IntToString(from = IMPORTANT_FOR_ACCESSIBILITY_NO, to = ""no"") })]",-1,-1,-1,-1,-1,-1,"4,5",1,"The variable names in the bitwise operation have changed, and they aren't local variables, so it's classified as 4 and 5.","The variables that the function return value depends on are changed, so it's possible that the return value could be different, therefore, the CI type is 1."
627,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(Context,long,boolean)>",16,17,"<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(Context,long,boolean)>","<android.text.format.DateUtils: CharSequence getRelativeTimeSpanString(Context,long,boolean)>",0,"{
    String result;
    long now = System.currentTimeMillis();
    long span = now - millis;
    synchronized (DateUtils.class) {
        if (sNowTime == null) {
            sNowTime = new Time();
        }
        if (sThenTime == null) {
            sThenTime = new Time();
        }
        sNowTime.set(now);
        sThenTime.set(millis);
        int prepositionId;
        if (span < DAY_IN_MILLIS && sNowTime.weekDay == sThenTime.weekDay) {
            // Same day
            int flags = FORMAT_SHOW_TIME;
            result = formatDateRange(c, millis, millis, flags);
            prepositionId = R.string.preposition_for_time;
        } else if (sNowTime.year != sThenTime.year) {
            // Different years
            int flags = FORMAT_SHOW_DATE | FORMAT_SHOW_YEAR | FORMAT_NUMERIC_DATE;
            result = formatDateRange(c, millis, millis, flags);
            // This is a date (like ""10/31/2008"" so use the date preposition)
            prepositionId = R.string.preposition_for_date;
        } else {
            // Default
            int flags = FORMAT_SHOW_DATE | FORMAT_ABBREV_MONTH;
            result = formatDateRange(c, millis, millis, flags);
            prepositionId = R.string.preposition_for_date;
        }
        if (withPreposition) {
            Resources res = c.getResources();
            result = res.getString(prepositionId, result);
        }
    }
    return result;
}","{
    String result;
    long now = System.currentTimeMillis();
    long span = Math.abs(now - millis);
    synchronized (DateUtils.class) {
        if (sNowTime == null) {
            sNowTime = new Time();
        }
        if (sThenTime == null) {
            sThenTime = new Time();
        }
        sNowTime.set(now);
        sThenTime.set(millis);
        int prepositionId;
        if (span < DAY_IN_MILLIS && sNowTime.weekDay == sThenTime.weekDay) {
            // Same day
            int flags = FORMAT_SHOW_TIME;
            result = formatDateRange(c, millis, millis, flags);
            prepositionId = R.string.preposition_for_time;
        } else if (sNowTime.year != sThenTime.year) {
            // Different years
            int flags = FORMAT_SHOW_DATE | FORMAT_SHOW_YEAR | FORMAT_NUMERIC_DATE;
            result = formatDateRange(c, millis, millis, flags);
            // This is a date (like ""10/31/2008"" so use the date preposition)
            prepositionId = R.string.preposition_for_date;
        } else {
            // Default
            int flags = FORMAT_SHOW_DATE | FORMAT_ABBREV_MONTH;
            result = formatDateRange(c, millis, millis, flags);
            prepositionId = R.string.preposition_for_date;
        }
        if (withPreposition) {
            Resources res = c.getResources();
            result = res.getString(prepositionId, result);
        }
    }
    return result;
}",1,"/**
 * @return a relative time string to display the time expressed by millis.  Times
 * are counted starting at midnight, which means that assuming that the current
 * time is March 31st, 0:30:
 * <ul>
 * <li>""millis=0:10 today"" will be displayed as ""0:10""</li>
 * <li>""millis=11:30pm the day before"" will be displayed as ""Mar 30""</li>
 * </ul>
 * If the given millis is in a different year, then the full date is
 * returned in numeric format (e.g., ""10/12/2008"").
 *
 * @param withPreposition If true, the string returned will include the correct
 * preposition (""at 9:20am"", ""on 10/12/2008"" or ""on May 29"").
 */
","/**
 * @return a relative time string to display the time expressed by millis.  Times
 * are counted starting at midnight, which means that assuming that the current
 * time is March 31st, 0:30:
 * <ul>
 * <li>""millis=0:10 today"" will be displayed as ""0:10""</li>
 * <li>""millis=11:30pm the day before"" will be displayed as ""Mar 30""</li>
 * </ul>
 * If the given millis is in a different year, then the full date is
 * returned in numeric format (e.g., ""10/12/2008"").
 *
 * @param withPreposition If true, the string returned will include the correct
 * preposition (""at 9:20am"", ""on 10/12/2008"" or ""on May 29"").
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The code line 'long span = now - millis;' in the early version implementation has changed to 'long span = Math.abs(now - millis);' in the late version. This represents a change in a mathematical computation, which is classified as a change type 4.","The modification of the manner in which the 'span' variable is being computed could potentially alter the responses of the conditions where the 'span' variable is utilized. Consequently, this adjustment can potentially alter the returned 'result' variable, thereby resulting in a compatibility issue of type 1."
629,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,16,17,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,<android.app.FragmentManagerImpl: Fragment findFragmentByWho(String)>,0,"{
    if (mActive != null && who != null) {
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && who.equals(f.mWho)) {
                return f;
            }
        }
    }
    return null;
}","{
    if (mActive != null && who != null) {
        for (int i = mActive.size() - 1; i >= 0; i--) {
            Fragment f = mActive.get(i);
            if (f != null && (f = f.findFragmentByWho(who)) != null) {
                return f;
            }
        }
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The condition inside the second 'if' statement is changed from 'who.equals(f.mWho)' to '(f = f.findFragmentByWho(who)) != null', indicating a change in a function call within the 'if' condition. Hence, the type of code change is 1,4.","Due to the changes in the 'if' condition, the returned Fragment may potentially vary between two versions, thereby introducing a Compatibility Issue (CI). Consequently, the CI type is 1."
630,"<android.app.ReceiverRestrictedContext: boolean bindService(Intent,ServiceConnection,int)>",16,17,"<android.app.ReceiverRestrictedContext: boolean bindService(Intent,ServiceConnection,int)>","<android.app.ReceiverRestrictedContext: boolean bindService(Intent,ServiceConnection,int)>",0,"{
    throw new ReceiverCallNotAllowedException(""IntentReceiver components are not allowed to bind to services"");
// ex.fillInStackTrace();
// Log.e(""IntentReceiver"", ex.getMessage(), ex);
// return mContext.bindService(service, interfaceName, conn, flags);
}","{
    throw new ReceiverCallNotAllowedException(""BroadcastReceiver components are not allowed to bind to services"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The string message in the throwing exception statement has been modified, leading to a change type of 4.","Despite the text change in the exception message, this code change doesn't lead to a compatibility issue because it doesn't affect the return value type or the type of exception that is thrown, hence the category is 0."
633,<android.app.ContextImpl: AssetManager getAssets()>,16,17,<android.app.ContextImpl: AssetManager getAssets()>,<android.app.ContextImpl: AssetManager getAssets()>,0,"{
    return mResources.getAssets();
}","{
    return getResources().getAssets();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,The method mResources.getAssets() in the early implementation changed to getResources().getAssets() in the late implementation. This change in dependent methods is classified as both an other statement change (4) and a dependent API change (5).,"The dependent API and the method used to return the asset manager has changed. As a result, the return value or type might differ, which leads to a compatibility issue caused by potential different return values or types (1)."
634,"<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>",16,17,"<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>","<android.app.ApplicationPackageManager: void setComponentEnabledSetting(ComponentName,int,int)>",0,"{
    try {
        mPM.setComponentEnabledSetting(componentName, newState, flags, UserId.myUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}","{
    try {
        mPM.setComponentEnabledSetting(componentName, newState, flags, mContext.getUserId());
    } catch (RemoteException e) {
    // Should never happen!
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"In the latest implementation, the method UserId.myUserId() was changed to mContext.getUserId() under mPM.setComponentEnabledSetting method. This classifies as a change in the dependent API thus, the change type is 5.","The change in the dependent API from UserId.myUserId() to mContext.getUserId() may lead to different return values or types when the function mPM.setComponentEnabledSetting is invoked. Therefore, the Compatibility Issue type is 1."
635,<android.app.MediaRouteButton: int[] onCreateDrawableState(int)>,16,17,<android.app.MediaRouteButton: int[] onCreateDrawableState(int)>,<android.app.MediaRouteButton: int[] onCreateDrawableState(int)>,0,"{
    final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
    if (mRemoteActive) {
        mergeDrawableStates(drawableState, ACTIVATED_STATE_SET);
    }
    return drawableState;
}","{
    final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
    // of state selection here.
    if (mIsConnecting) {
        mergeDrawableStates(drawableState, CHECKED_STATE_SET);
    } else if (mRemoteActive) {
        mergeDrawableStates(drawableState, ACTIVATED_STATE_SET);
    }
    return drawableState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"Added a new condition 'mIsConnecting' in the code and also modified the parameters of the 'mergeDrawableStates' method. This is a type 3 change, 'Control dependency change'.","The new statement inside the added condition statement can potentially lead the function to behave differently, especially returning different values. Hence, it is a type 1 CI, 'Compatibility Issue caused by potential different return values or types'."
636,"<android.app.FragmentManagerImpl: void putFragment(Bundle,String,Fragment)>",16,17,"<android.app.FragmentManagerImpl: void putFragment(Bundle,String,Fragment)>","<android.app.FragmentManagerImpl: void putFragment(Bundle,String,Fragment)>",0,"{
    if (fragment.mIndex < 0) {
        throw new IllegalStateException(""Fragment "" + fragment + "" is not currently in the FragmentManager"");
    }
    bundle.putInt(key, fragment.mIndex);
}","{
    if (fragment.mIndex < 0) {
        throwException(new IllegalStateException(""Fragment "" + fragment + "" is not currently in the FragmentManager""));
    }
    bundle.putInt(key, fragment.mIndex);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,2,2,"Only the way of throwing exception has changed. Instead of directly throwing the exception, the updated version throws it through the method throwException, so the code change type is 2.","The updated version added an extra layer of encapsulation to throwing exceptions. This change could lead to different exception handling, so the CI type is 2."
638,"<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>",16,17,"<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>","<android.app.FragmentManagerImpl: void addFragment(Fragment,boolean)>",0,"{
    if (mAdded == null) {
        mAdded = new ArrayList<Fragment>();
    }
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        mAdded.add(fragment);
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}","{
    if (mAdded == null) {
        mAdded = new ArrayList<Fragment>();
    }
    if (DEBUG)
        Log.v(TAG, ""add: "" + fragment);
    makeActive(fragment);
    if (!fragment.mDetached) {
        if (mAdded.contains(fragment)) {
            throw new IllegalStateException(""Fragment already added: "" + fragment);
        }
        mAdded.add(fragment);
        fragment.mAdded = true;
        fragment.mRemoving = false;
        if (fragment.mHasMenu && fragment.mMenuVisible) {
            mNeedMenuInvalidate = true;
        }
        if (moveToStateNow) {
            moveToState(fragment);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3",2,"The control statement has changed with an extra condition check for fragment addition in the late implementation. Moreover, an exception handling statement has been added in the form of a throw statement when a fragment is found already added. In this case, the code change type is 2,3.","As the late implementation throws a new exception which was not present in the early version, this change leads to a potential change in the behavior of the API causing a Compatibility Issue which can be classified under type 2."
639,<android.view.View: boolean isSelected()>,16,17,<android.view.View: boolean isSelected()>,<android.view.View: boolean isSelected()>,0,"{
    return (mPrivateFlags & SELECTED) != 0;
}","{
    return (mPrivateFlags & PFLAG_SELECTED) != 0;
}",1,"/**
 * Indicates the selection state of this view.
 *
 * @return true if the view is selected, false otherwise
 */
","/**
 * Indicates the selection state of this view.
 *
 * @return true if the view is selected, false otherwise
 */
",-1,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],-1,-1,-1,-1,-1,-1,"1,5",1,"The dependent variable inside the return statement changed from SELECTED to PFLAG_SELECTED, so this belongs to Other Statement Changed and Dependent API Changed (1,5).","Since the dependent API has been changed, it is likely that the return value will change when the method is invoked, leading to an incompatibility. Therefore, it is classified as ""Compatibility Issue caused by potential different return values or types"" (1)."
640,<android.os.Environment: boolean isExternalStorageRemovable()>,16,17,<android.os.Environment: boolean isExternalStorageRemovable()>,<android.os.Environment: boolean isExternalStorageRemovable()>,0,"{
    StorageVolume volume = getPrimaryVolume();
    return (volume != null && volume.isRemovable());
}","{
    final StorageVolume primary = getPrimaryVolume();
    return (primary != null && primary.isRemovable());
}",1,"/**
 * Returns whether the primary ""external"" storage device is removable.
 * If true is returned, this device is for example an SD card that the
 * user can remove.  If false is returned, the storage is built into
 * the device and can not be physically removed.
 *
 * <p>See {@link #getExternalStorageDirectory()} for more information.
 */
","/**
 * Returns whether the primary ""external"" storage device is removable.
 * If true is returned, this device is for example an SD card that the
 * user can remove.  If false is returned, the storage is built into
 * the device and can not be physically removed.
 *
 * <p>See {@link #getExternalStorageDirectory()} for more information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,The implementation of the API has not changed significantly between two versions. The only change is the variable name which doesn't affect the result/output of function.,"Since there is no difference between the two versions that could result in a change in the return value or exception, there is no Compatibility Issue."
641,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",16,17,"<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>","<android.view.View: boolean performAccessibilityActionInternal(int,Bundle)>",0,"{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    return performClick();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    return performLongClick();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                final int mode = getAccessibilityFocusable();
                if (!isAccessibilityFocused() && (mode == ACCESSIBILITY_FOCUSABLE_YES || mode == ACCESSIBILITY_FOCUSABLE_AUTO)) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return nextAtGranularity(granularity);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return previousAtGranularity(granularity);
                }
            }
            break;
    }
    return false;
}","{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                if (isClickable()) {
                    performClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_LONG_CLICK:
            {
                if (isLongClickable()) {
                    performLongClick();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_FOCUS:
            {
                if (!hasFocus()) {
                    // Get out of touch mode since accessibility
                    // wants to move focus around.
                    getViewRootImpl().ensureTouchMode(false);
                    return requestFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS:
            {
                if (hasFocus()) {
                    clearFocus();
                    return !isFocused();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_SELECT:
            {
                if (!isSelected()) {
                    setSelected(true);
                    return isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_SELECTION:
            {
                if (isSelected()) {
                    setSelected(false);
                    return !isSelected();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:
            {
                if (!isAccessibilityFocused()) {
                    return requestAccessibilityFocus();
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS:
            {
                if (isAccessibilityFocused()) {
                    clearAccessibilityFocus();
                    return true;
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return nextAtGranularity(granularity);
                }
            }
            break;
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                if (arguments != null) {
                    final int granularity = arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT);
                    return previousAtGranularity(granularity);
                }
            }
            break;
    }
    return false;
}",1,"/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
","/**
 * @see #performAccessibilityAction(int, Bundle)
 *
 * Note: Called from the default {@link AccessibilityDelegate}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,The return statements have changed under two 'case' clauses: ,"Meanwhile, a control dependency (if condition) in ""case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS"" is removed. So the code change types are 1 and 3."
645,"<android.test.AndroidTestCase: void assertWritingContentUriRequiresPermission(Uri,String)>",16,17,"<android.test.AndroidTestCase: void assertWritingContentUriRequiresPermission(Uri,String)>","<android.test.AndroidTestCase: void assertWritingContentUriRequiresPermission(Uri,String)>",0,"{
    try {
        getContext().getContentResolver().insert(uri, new ContentValues());
        fail(""expected SecurityException requiring "" + permission);
    } catch (SecurityException expected) {
        assertNotNull(""security exception's error message."", expected.getMessage());
        assertTrue(""error message should contain "" + permission + ""."", expected.getMessage().contains(permission));
    }
}","{
    try {
        getContext().getContentResolver().insert(uri, new ContentValues());
        fail(""expected SecurityException requiring "" + permission);
    } catch (SecurityException expected) {
        assertNotNull(""security exception's error message."", expected.getMessage());
        assertTrue(""error message should contain \"""" + permission + ""\"". Got: \"""" + expected.getMessage() + ""\""."", expected.getMessage().contains(permission));
    }
}",1,"/**
 * Asserts that writing to the content uri requires a particular permission by inserting into
 * the uri and ensuring a {@link SecurityException} is thrown mentioning the particular
 * permission.
 *
 * @param uri The uri that requires a permission to query.
 * @param permission The permission that should be required.
 */
","/**
 * Asserts that writing to the content uri requires a particular permission by inserting into
 * the uri and ensuring a {@link SecurityException} is thrown mentioning the particular
 * permission.
 *
 * @param uri The uri that requires a permission to query.
 * @param permission The permission that should be required.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The output message in the assertTrue statement's parameter has changed slightly, but the logic and behavior of the method remains unchanged in both versions. So the type is 4 for Other statement changed.","No Compatibility Issue exists for the API. The method asserts that writing to a content URI requires permission and this assertion has not changed. It throws the same exception in both versions, thus it doesn't cause a different behavior in the code. So, the CI type is 0 for No Compatibility Issue exist."
647,<android.view.View: boolean isLayoutRequested()>,16,17,<android.view.View: boolean isLayoutRequested()>,<android.view.View: boolean isLayoutRequested()>,0,"{
    return (mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT;
}","{
    return (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;
}",1,"/**
 * <p>Indicates whether or not this view's layout will be requested during
 * the next hierarchy layout pass.</p>
 *
 * @return true if the layout will be forced during next layout pass
 */
","/**
 * <p>Indicates whether or not this view's layout will be requested during
 * the next hierarchy layout pass.</p>
 *
 * @return true if the layout will be forced during next layout pass
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement changes from `(mPrivateFlags & FORCE_LAYOUT) == FORCE_LAYOUT` to `(mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT`, and the parameter of bit operation has also changed, so the code change type is 1,5.","As the return variable has changed, it might make the API return a different boolean value, so the CI type is 1."
648,<android.view.ScaleGestureDetector: float getScaleFactor()>,16,17,<android.view.ScaleGestureDetector: float getScaleFactor()>,<android.view.ScaleGestureDetector: float getScaleFactor()>,0,"{
    if (mScaleFactor == -1) {
        mScaleFactor = getCurrentSpan() / getPreviousSpan();
    }
    return mScaleFactor;
}","{
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}",1,"/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
","/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The entire implementation of the method has changed in the late version, including the returned variable, so the code change type is 1.","As 'return mScaleFactor' is changed to 'return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1', the returned value might differ from the original, thus the CI type is 1."
650,<android.app.DownloadManager: Long getRecommendedMaxBytesOverMobile(Context)>,16,17,<android.app.DownloadManager: Long getRecommendedMaxBytesOverMobile(Context)>,<android.app.DownloadManager: Long getRecommendedMaxBytesOverMobile(Context)>,0,"{
    try {
        return Settings.Secure.getLong(context.getContentResolver(), Settings.Secure.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
    } catch (SettingNotFoundException exc) {
        return null;
    }
}","{
    try {
        return Settings.Global.getLong(context.getContentResolver(), Settings.Global.DOWNLOAD_RECOMMENDED_MAX_BYTES_OVER_MOBILE);
    } catch (SettingNotFoundException exc) {
        return null;
    }
}",1,"/**
 * Returns recommended maximum size, in bytes, of downloads that may go over a mobile
 * connection; or null if there's no recommended limit.  The user will have the option to bypass
 * this limit.
 *
 * @param context the {@link Context} to use for accessing the {@link ContentResolver}
 * @return recommended maximum size, in bytes, of downloads that may go over a mobile
 * connection; or null if there's no recommended limit.
 */
","/**
 * Returns recommended maximum size, in bytes, of downloads that may go over a mobile
 * connection; or null if there's no recommended limit.  The user will have the option to bypass
 * this limit.
 *
 * @param context the {@link Context} to use for accessing the {@link ContentResolver}
 * @return recommended maximum size, in bytes, of downloads that may go over a mobile
 * connection; or null if there's no recommended limit.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The change is in the return statement of the method, where the API it relies on (Settings.Secure.getLong to Settings.Global.getLong) has changed, so the code change type is 1,5.","The change in the dependent API could potentially cause the method to return a different value. Thus, the CI type is 1."
651,"<android.webkit.WebViewClassic.WebViewInputConnection: boolean setComposingText(CharSequence,int)>",16,17,"<android.webkit.WebViewClassic.WebViewInputConnection: boolean setComposingText(CharSequence,int)>","<android.webkit.WebViewClassic.WebViewInputConnection: boolean setComposingText(CharSequence,int)>",0,"{
    Editable editable = getEditable();
    int start = getComposingSpanStart(editable);
    int end = getComposingSpanEnd(editable);
    if (start < 0 || end < 0) {
        start = Selection.getSelectionStart(editable);
        end = Selection.getSelectionEnd(editable);
    }
    if (end < start) {
        int temp = end;
        end = start;
        start = temp;
    }
    CharSequence limitedText = limitReplaceTextByMaxLength(text, end - start);
    setNewText(start, end, limitedText);
    if (limitedText != text) {
        newCursorPosition -= text.length() - limitedText.length();
    }
    super.setComposingText(limitedText, newCursorPosition);
    updateSelection();
    if (limitedText != text) {
        restartInput();
        int lastCaret = start + limitedText.length();
        finishComposingText();
        setSelection(lastCaret, lastCaret);
    }
    return true;
}","{
    Editable editable = getEditable();
    int start = getComposingSpanStart(editable);
    int end = getComposingSpanEnd(editable);
    if (start < 0 || end < 0) {
        start = Selection.getSelectionStart(editable);
        end = Selection.getSelectionEnd(editable);
    }
    if (end < start) {
        int temp = end;
        end = start;
        start = temp;
    }
    CharSequence limitedText = limitReplaceTextByMaxLength(text, end - start);
    setNewText(start, end, limitedText);
    if (limitedText != text) {
        newCursorPosition -= text.length() - limitedText.length();
    }
    super.setComposingText(limitedText, newCursorPosition);
    updateSelection();
    if (limitedText != text) {
        int lastCaret = start + limitedText.length();
        finishComposingText();
        setSelection(lastCaret, lastCaret);
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The method 'restartInput()' has been removed in the late version, so the code change type is 4.","The removal of 'restartInput()' should not cause a different return value or exception depending on the definition, so no Compatibility Issue exists."
653,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",16,17,"<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>","<android.speech.tts.FileSynthesisCallback: int start(int,int,int)>",0,"{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile != null) {
            cleanUp();
            throw new IllegalArgumentException(""FileSynthesisRequest.start() called twice"");
        }
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        try {
            mFile = new RandomAccessFile(mFileName, ""rw"");
            // Reserve space for WAV header
            mFile.write(new byte[WAV_HEADER_LENGTH]);
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to open "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}","{
    if (DBG) {
        Log.d(TAG, ""FileSynthesisRequest.start("" + sampleRateInHz + "","" + audioFormat + "","" + channelCount + "")"");
    }
    synchronized (mStateLock) {
        if (mStopped) {
            if (DBG)
                Log.d(TAG, ""Request has been aborted."");
            return TextToSpeech.ERROR;
        }
        if (mFile != null) {
            cleanUp();
            throw new IllegalArgumentException(""FileSynthesisRequest.start() called twice"");
        }
        if (!maybeCleanupExistingFile(mFileName)) {
            return TextToSpeech.ERROR;
        }
        mSampleRateInHz = sampleRateInHz;
        mAudioFormat = audioFormat;
        mChannelCount = channelCount;
        try {
            mFile = new RandomAccessFile(mFileName, ""rw"");
            // Reserve space for WAV header
            mFile.write(new byte[WAV_HEADER_LENGTH]);
            return TextToSpeech.SUCCESS;
        } catch (IOException ex) {
            Log.e(TAG, ""Failed to open "" + mFileName + "": "" + ex);
            cleanUp();
            return TextToSpeech.ERROR;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new call to the function maybeCleanupExistingFile(mFileName) has been added in the late version, hence the class type of change is 3 (Control dependency change)","The added call to the function maybeCleanupExistingFile(mFileName) could potentially cause the API to return a different value based on its result. Therefore, the type of compatibility issue is 1 (Compatibility Issue caused by potential different return values)."
654,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>",16,17,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentServices(Intent,int)>",0,"{
    try {
        return mPM.queryIntentServices(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return queryIntentServicesAsUser(intent, flags, mContext.getUserId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement changed, and now depends on the new internal method `queryIntentServicesAsUser()` instead of a remote service (indicated by the removed `try-catch` block). Therefore, the change type is 1,4,5.","In the late version, the used method to return values is different. Hence, the API may return a different value due to changes in internal method implementation. That leads us to a CI type of 1."
655,<android.content.res.Configuration: String toString()>,16,17,<android.content.res.Configuration: String toString()>,<android.content.res.Configuration: String toString()>,0,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    sb.append(mcc);
    sb.append(""mcc"");
    sb.append(mnc);
    sb.append(""mnc"");
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" (no locale)"");
    }
    switch(layoutDirection) {
        case View.LAYOUT_DIRECTION_LTR:
            /* ltr not interesting */
            break;
        case View.LAYOUT_DIRECTION_RTL:
            sb.append("" rtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDirection);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    if (mcc != 0) {
        sb.append(mcc);
        sb.append(""mcc"");
    } else {
        sb.append(""?mcc"");
    }
    if (mnc != 0) {
        sb.append(mnc);
        sb.append(""mnc"");
    } else {
        sb.append(""?mnc"");
    }
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" ?locale"");
    }
    int layoutDir = (screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK);
    switch(layoutDir) {
        case SCREENLAYOUT_LAYOUTDIR_UNDEFINED:
            sb.append("" ?layoutDir"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_LTR:
            sb.append("" ldltr"");
            break;
        case SCREENLAYOUT_LAYOUTDIR_RTL:
            sb.append("" ldrtl"");
            break;
        default:
            sb.append("" layoutDir="");
            sb.append(layoutDir >> SCREENLAYOUT_LAYOUTDIR_SHIFT);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    if (densityDpi != DENSITY_DPI_UNDEFINED) {
        sb.append("" "");
        sb.append(densityDpi);
        sb.append(""dpi"");
    } else {
        sb.append("" ?density"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        case UI_MODE_TYPE_APPLIANCE:
            sb.append("" appliance"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
656,<android.app.Fragment: LoaderManager getLoaderManager()>,16,17,<android.app.Fragment: LoaderManager getLoaderManager()>,<android.app.Fragment: LoaderManager getLoaderManager()>,0,"{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mActivity.getLoaderManager(mIndex, mLoadersStarted, true);
    return mLoaderManager;
}","{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mActivity == null) {
        throw new IllegalStateException(""Fragment "" + this + "" not attached to Activity"");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, true);
    return mLoaderManager;
}",1,"/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
","/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method call mActivity.getLoaderManager has changed its first parameter from mIndex to mWho, so this code change can be classified into type 4 - Other statement changed.","Given that the return type (LoaderManager) depends on the method call mActivity.getLoaderManager(), and the first parameter to mActivity.getLoaderManager() has changed from mIndex to mWho, this could lead to a different return value. Thus, a compatibility issue of type 1 - Compatibility Issue caused by potential different return values, exists."
657,<android.app.Fragment: void performStop()>,16,17,<android.app.Fragment: void performStop()>,<android.app.Fragment: void performStop()>,0,"{
    onStop();
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mActivity.getLoaderManager(mIndex, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mActivity == null || !mActivity.mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
}","{
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchStop();
    }
    mCalled = false;
    onStop();
    if (!mCalled) {
        throw new SuperNotCalledException(""Fragment "" + this + "" did not call through to super.onStop()"");
    }
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            if (mActivity == null || !mActivity.mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","The method conditionally throws a new exception (SuperNotCalledException) that wasn't thrown in the early version. New control flow has been added (if block with mChildFragmentManager.dispatchStop()) and the function call mActivity.getLoaderManager() now gets different parameters. The order of onStop() function was also moved, which can be classified in Other statements changed. Therefore, The code change types are 1, 2, 3, 4 and 5.","In the late version, the throw new SuperNotCalledException() is introduced that could potentially cause a different exception handling. Moreover, the introduction of mChildFragmentManager.dispatchStop() and the changes in method parameters could lead to a potential different return behaviour. Thus, the CI types are 1, 2."
659,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,16,17,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,<android.app.admin.DevicePolicyManager: void removeActiveAdmin(ComponentName)>,0,"{
    if (mService != null) {
        try {
            mService.removeActiveAdmin(who);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.removeActiveAdmin(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 */
","/**
 * Remove a current administration component.  This can only be called
 * by the application that owns the administration component; if you
 * try to remove someone else's component, a security exception will be
 * thrown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The method of dependent API 'mService.removeActiveAdmin(who)' has changed to 'mService.removeActiveAdmin(who, UserHandle.myUserId())', and the parameter number as well as values have changed, so the code change type is 5.","The change in the dependent API could potentially change the behaviour of this API, therefore it may return a different value under certain circumstances. That's why the CI type is 1."
660,<android.view.View: boolean isScrollContainer()>,16,17,<android.view.View: boolean isScrollContainer()>,<android.view.View: boolean isScrollContainer()>,0,"{
    return (mPrivateFlags & SCROLL_CONTAINER_ADDED) != 0;
}","{
    return (mPrivateFlags & PFLAG_SCROLL_CONTAINER_ADDED) != 0;
}",1,"/**
 * Indicates whether this view is one of the set of scrollable containers in
 * its window.
 *
 * @return whether this view is one of the set of scrollable containers in
 * its window
 *
 * @attr ref android.R.styleable#View_isScrollContainer
 */
","/**
 * Indicates whether this view is one of the set of scrollable containers in
 * its window.
 *
 * @return whether this view is one of the set of scrollable containers in
 * its window
 *
 * @attr ref android.R.styleable#View_isScrollContainer
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from evaluating 'mPrivateFlags & SCROLL_CONTAINER_ADDED' to evaluating 'mPrivateFlags & PFLAG_SCROLL_CONTAINER_ADDED'. This change involves the change of a different constant, viewing it as an another API, so the change type is 1,5.","The change in return statement possibly makes the API return different results, hence a compatibility issue in the form of potentially different return values is present. Thus, CI type is 1."
661,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,16,17,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,0,"{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    ManagedEGLContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(createManagedContext(mEglContext));
    }
}","{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            checkEglErrorsForced();
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    ManagedEGLContext managedContext = sEglContextStorage.get();
    mEglContext = managedContext != null ? managedContext.getContext() : null;
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(createManagedContext(mEglContext));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method 'checkEglErrorsForced()' is added in the 'Late_Implementation', hence the code change type is 4.","The added method 'checkEglErrorsForced()' doesn't affect return values or potential exception handling of the API, therefore, no Compatibility Issue exists."
663,"<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>",16,17,"<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>","<android.app.ApplicationPackageManager: ActivityInfo getReceiverInfo(ComponentName,int)>",0,"{
    try {
        ActivityInfo ai = mPM.getReceiverInfo(className, flags, UserId.myUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}","{
    try {
        ActivityInfo ai = mPM.getReceiverInfo(className, flags, mContext.getUserId());
        if (ai != null) {
            return ai;
        }
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
    throw new NameNotFoundException(className.toString());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"The dependent API method expression has changed from UserId.myUserId() to mContext.getUserId(), so the code change type is 4,5.","Since the dependent API method expression has changed, it may return different values and therefore it could potentially make the current API return different values, thus the CI type is 1."
664,<android.view.View: void setBackgroundDrawable(Drawable)>,16,17,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        if (background.getPadding(padding)) {
            switch(background.getResolvedLayoutDirectionSelf()) {
                case LAYOUT_DIRECTION_RTL:
                    setPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    setPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & SKIP_DRAW) != 0) {
            mPrivateFlags &= ~SKIP_DRAW;
            mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,"1, 3, 4",1,"There are multiple changes in the code. First, the sequence of 'computeOpaqueFlags()' and a comparison operation is inverted between two versions; Second, 'resetResolvedDrawables()', 'background.setLayoutDirection(getLayoutDirection())', 'resetResolvedPadding()', 'mUserPaddingLeftInitial = padding.right', 'mUserPaddingRightInitial = padding.left', and 'internalSetPadding(padding.right, padding.top, padding.left, padding.bottom)' etc. have been added; Third, the name of some variables changed (e.g., 'PFLAG_SKIP_DRAW' instead of 'SKIP_DRAW'). The changed types are 1, 3, 4.","The changes in this method can cause the method to return a different value, especially the newly added operations and invocations, leading to a change in behavior. Therefore, the CI type is 1."
665,<android.view.View: int getPaddingLeft()>,16,17,<android.view.View: int getPaddingLeft()>,<android.view.View: int getPaddingLeft()>,0,"{
    return mPaddingLeft;
}","{
    if (!isPaddingResolved()) {
        resolvePadding();
    }
    return mPaddingLeft;
}",1,"/**
 * Returns the left padding of this view. If there are inset and enabled
 * scrollbars, this value may include the space required to display the
 * scrollbars as well.
 *
 * @return the left padding in pixels
 */
","/**
 * Returns the left padding of this view. If there are inset and enabled
 * scrollbars, this value may include the space required to display the
 * scrollbars as well.
 *
 * @return the left padding in pixels
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, two new statements have been added before the return statement which involve a conditional check and a function call. Therefore, the change type is 1,3.","The addition of conditional check and function call potentially leads to a change in the value of mPaddingLeft. Therefore, the API potentially returns a different value which implies a compatibility issue type 1."
666,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,16,17,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,<android.view.ScaleGestureDetector: float getCurrentSpanX()>,0,"{
    return mCurrFingerDiffX;
}","{
    return mCurrSpanX;
}",1,"/**
 * Return the current x distance between the two pointers forming the
 * gesture in progress.
 *
 * @return Distance between pointers in pixels.
 */
","/**
 * Return the average X distance between each of the pointers forming the
 * gesture in progress through the focal point.
 *
 * @return Distance between pointers in pixels.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The original return statement ""return mCurrFingerDiffX;"" has been changed into ""return mCurrSpanX;"". Moreover, the dependent variable 'mCurrFingerDiffX' is replaced by the variable 'mCurrSpanX'. Therefore, the change type would be 1,5.","Since the return statement has changed, this indicates that a different value may be returned, which could potentially lead to compatibility issues. Thus, the CI type is 1."
667,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,16,17,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,<android.speech.tts.SynthesisPlaybackQueueItem: void run()>,0,"{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    mAudioTrack.init();
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mIsError) {
        dispatcher.dispatchOnError();
    } else {
        dispatcher.dispatchOnDone();
    }
    mLogger.onWriteData();
}","{
    final UtteranceProgressDispatcher dispatcher = getDispatcher();
    dispatcher.dispatchOnStart();
    if (!mAudioTrack.init()) {
        dispatcher.dispatchOnError();
        return;
    }
    try {
        byte[] buffer = null;
        // OR (c) done() is called in which case it will return null.
        while ((buffer = take()) != null) {
            mAudioTrack.write(buffer);
            mLogger.onAudioDataWritten();
        }
    } catch (InterruptedException ie) {
        if (DBG)
            Log.d(TAG, ""Interrupted waiting for buffers, cleaning up."");
    }
    mAudioTrack.waitAndRelease();
    if (mIsError) {
        dispatcher.dispatchOnError();
    } else {
        dispatcher.dispatchOnDone();
    }
    mLogger.onWriteData();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the later version, the if condition has been added to evaluate the boolean result of mAudioTrack.init() and if the result is false it immediately returns void after dispatching an error. Therefore, the change types are 1 for new return statement and 3 for added condition-controlled statement.","The newly added return statement can alter the behavior of the code as it might terminate the function prematurely if mAudioTrack.init() returns false, which makes the API potentially return different results. Hence, this is type 1 CI."
668,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",16,17,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>","<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",0,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"In the implementation of 'ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags, null)', a new parameter 'UserHandle.myUserId()' is introduced in the late version. So, the changes include 'method invocation statement change' and 'dependent API change', that is category 4 and 5 of code change.","Due to the introduction of a new parameter in the invocation of the dependent API, a different IIntentSender object may be received. Therefore, the return value of the method, which depends on the obtained IIntentSender object, may be different which leads to compatibility issue. Thus, the compatibility issue type is 1 which corresponds to 'Compatibility issue caused by potential different return values or types'."
669,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,16,17,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,<android.view.inputmethod.InputMethodManager.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case MSG_DUMP:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        return;
                    }
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            checkFocus(mHasBeenInactive);
                        }
                    }
                }
                return;
            }
    }
}","{
    switch(msg.what) {
        case MSG_DUMP:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    doDump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case MSG_BIND:
            {
                final InputBindResult res = (InputBindResult) msg.obj;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_BIND "" + res.sequence + "","" + res.id);
                }
                synchronized (mH) {
                    if (mBindSequence < 0 || mBindSequence != res.sequence) {
                        Log.w(TAG, ""Ignoring onBind: cur seq="" + mBindSequence + "", given seq="" + res.sequence);
                        return;
                    }
                    mCurMethod = res.method;
                    mCurId = res.id;
                    mBindSequence = res.sequence;
                }
                startInputInner(null, 0, 0, 0);
                return;
            }
        case MSG_UNBIND:
            {
                final int sequence = msg.arg1;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_UNBIND "" + sequence);
                }
                boolean startInput = false;
                synchronized (mH) {
                    if (mBindSequence == sequence) {
                        if (false) {
                            // XXX the server has already unbound!
                            if (mCurMethod != null && mCurrentTextBoxAttribute != null) {
                                try {
                                    mCurMethod.finishInput();
                                } catch (RemoteException e) {
                                    Log.w(TAG, ""IME died: "" + mCurId, e);
                                }
                            }
                        }
                        clearBindingLocked();
                        // we would like to re-connect to the next input method.
                        if (mServedView != null && mServedView.isFocused()) {
                            mServedConnecting = true;
                        }
                        if (mActive) {
                            startInput = true;
                        }
                    }
                }
                if (startInput) {
                    startInputInner(null, 0, 0, 0);
                }
                return;
            }
        case MSG_SET_ACTIVE:
            {
                final boolean active = msg.arg1 != 0;
                if (DEBUG) {
                    Log.i(TAG, ""handleMessage: MSG_SET_ACTIVE "" + active + "", was "" + mActive);
                }
                synchronized (mH) {
                    mActive = active;
                    mFullscreenMode = false;
                    if (!active) {
                        // Some other client has starting using the IME, so note
                        // that this happened and make sure our own editor's
                        // state is reset.
                        mHasBeenInactive = true;
                        try {
                            // Note that finishComposingText() is allowed to run
                            // even when we are not active.
                            mIInputContext.finishComposingText();
                        } catch (RemoteException e) {
                        }
                        // handling this message.
                        if (mServedView != null && mServedView.hasWindowFocus()) {
                            // mServedInputConnection.finishComposingText.
                            if (checkFocusNoStartInput(mHasBeenInactive, false)) {
                                startInputInner(null, 0, 0, 0);
                            }
                        }
                    }
                }
                return;
            }
        case MSG_EVENT_TIMEOUT:
            {
                // Even though the message contains both the sequence number
                // and the PendingEvent object itself, we only pass the
                // sequence number to the timeoutEvent function because it's
                // possible for the PendingEvent object to be dequeued and
                // recycled concurrently.  To avoid a possible race, we make
                // a point of always looking up the PendingEvent within the
                // queue given only the sequence number of the event.
                timeoutEvent(msg.arg1);
                return;
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"In the 'case' blocks, several new log statements have been introduced and in the MSG_DUMP case, the function args.recycle() is added. Besides, a new 'case MSG_EVENT_TIMEOUT' block is also introduced. So, the change type is 3,4.","All the changes are related to logging and event handling, but none of them would change the returned values or thrown exceptions of the API. So, there is no Compatibility Issue for this API. Therefore, the CI type is 0."
670,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",16,17,"<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>","<android.app.admin.DevicePolicyManager: void setPasswordQuality(ComponentName,int)>",0,"{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}","{
    if (mService != null) {
        try {
            mService.setPasswordQuality(admin, quality, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed talking with device policy service"", e);
        }
    }
}",1,"/**
 * Called by an application that is administering the device to set the
 * password restrictions it is imposing.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 *
 * <p>Quality constants are ordered so that higher values are more restrictive;
 * thus the highest requested quality constant (between the policy set here,
 * the user's preference, and any other considerations) is the one that
 * is in effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality.  One of
 * {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link #PASSWORD_QUALITY_SOMETHING},
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_ALPHABETIC},
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.
 */
","/**
 * Called by an application that is administering the device to set the
 * password restrictions it is imposing.  After setting this, the user
 * will not be able to enter a new password that is not at least as
 * restrictive as what has been set.  Note that the current password
 * will remain until the user has set a new one, so the change does not
 * take place immediately.  To prompt the user for a new password, use
 * {@link #ACTION_SET_NEW_PASSWORD} after setting this value.
 *
 * <p>Quality constants are ordered so that higher values are more restrictive;
 * thus the highest requested quality constant (between the policy set here,
 * the user's preference, and any other considerations) is the one that
 * is in effect.
 *
 * <p>The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_LIMIT_PASSWORD} to be able to call
 * this method; if it has not, a security exception will be thrown.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated with.
 * @param quality The new desired quality.  One of
 * {@link #PASSWORD_QUALITY_UNSPECIFIED}, {@link #PASSWORD_QUALITY_SOMETHING},
 * {@link #PASSWORD_QUALITY_NUMERIC}, {@link #PASSWORD_QUALITY_ALPHABETIC},
 * {@link #PASSWORD_QUALITY_ALPHANUMERIC} or {@link #PASSWORD_QUALITY_COMPLEX}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"There is a change in the dependent API, mService.setPasswordQuality, with an additional parameter UserHandle.myUserId() being passed in the late version. The return statement has also changed, so the code change types are 1 and 5.","Regardless of the API change, the functionality remains the same because the extra argument being passed (UserHandle.myUserId()) does not change the behaviour of the method. Therefore, there is no compatibility issue."
671,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",16,17,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>","<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",0,"{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method call to `getIntentSender` has been revised with a new parameter `UserHandle.myUserId()`, hence the change belongs to categories 4 and 5.","The change in the parameter list of `getIntentSender` may cause different returns from `getIntentSender`, which would then affect the returned `PendingIntent` from `createPendingResult`. Therefore, it is a compatibility issue of category 1."
673,"<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>",16,17,"<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.Secure: boolean putString(ContentResolver,String,String)>",0,"{
    return putString(resolver, CONTENT_URI, name, value);
}","{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from putString(resolver, CONTENT_URI, name, value) to putStringForUser(resolver, name, value, UserHandle.myUserId()). The method that this method calls has changed, and thus the code change type is 1,5.","By calling a different method in the return statement, the API potentially returns a different value. Thus, the CI type is 1."
674,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,16,17,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,<android.view.accessibility.AccessibilityManager: List<AccessibilityServiceInfo> getInstalledAccessibilityServiceList()>,0,"{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getInstalledAccessibilityServiceList();
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}","{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getInstalledAccessibilityServiceList(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}",1,"/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
","/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The call to 'mService.getInstalledAccessibilityServiceList()' in the early version is changed to 'mService.getInstalledAccessibilityServiceList(mUserId)' in the late version, therefore the code change type is 1,5 (Return statement changed and Dependent API changed).","The introduction of the 'mUserId' argument in the getInstalledAccessibilityServiceList() may affect the returned list of services, potentially causing the API to return different values in the two versions. Therefore, the CI (Compatibility Issue) type is 1 (Compatibility Issue caused by potential different return values or types)."
675,"<android.view.View: void setFlags(int,int)>",16,17,"<android.view.View: void setFlags(int,int)>","<android.view.View: void setFlags(int,int)>",0,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            notifyAccessibilityStateChanged();
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled() && ((changed & FOCUSABLE) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & ENABLED) != 0)) {
        notifyAccessibilityStateChanged();
    }
}","{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & PFLAG_HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & PFLAG_FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            notifyAccessibilityStateChanged();
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            clearAccessibilityFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= PFLAG_DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= PFLAG_DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus and accessibility focus
            if (getRootView() != this) {
                clearFocus();
                clearAccessibilityFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (changed & VISIBILITY_MASK), (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBackground != null) {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= PFLAG_SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled() && ((changed & FOCUSABLE) != 0 || (changed & CLICKABLE) != 0 || (changed & LONG_CLICKABLE) != 0 || (changed & ENABLED) != 0)) {
        notifyAccessibilityStateChanged();
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In this code snippet, the variable names have changed from HAS_BOUNDS, DRAWN, FOCUSED, and similar to PFLAG_HAS_BOUNDS, PFLAG_DRAWN, PFLAG_FOCUSED, and similar. Therefore, the code change type is 4.","Although variable names have changed, their functionality remains unaffected. Thus, the behavior of the method would remain the same. Consequently, No Compatibility Issue exists in this case, and the CI type is 0."
681,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,16,17,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,<android.accounts.AccountManager: Account[] getAccountsByType(String)>,0,"{
    try {
        return mService.getAccounts(type);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}","{
    return getAccountsByTypeAsUser(type, Process.myUserHandle());
}",1,"/**
 * Lists all accounts of a particular type.  The account type is a
 * string token corresponding to the authenticator and useful domain
 * of the account.  For example, there are types corresponding to Google
 * and Facebook.  The exact string token to use will be published somewhere
 * associated with the authenticator in question.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @param type The type of accounts to return, null to retrieve all accounts
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
","/**
 * Lists all accounts of a particular type.  The account type is a
 * string token corresponding to the authenticator and useful domain
 * of the account.  For example, there are types corresponding to Google
 * and Facebook.  The exact string token to use will be published somewhere
 * associated with the authenticator in question.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS}.
 *
 * @param type The type of accounts to return, null to retrieve all accounts
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The API now returns the result of different method calls, from 'mService.getAccounts(type)' to 'getAccountsByTypeAsUser(type, Process.myUserHandle())', and the method calls are different. Thus, the change type is 1,5.","The return value is altered due to the changed method call and hence can potentially lead to a different return value or type, hence the CI type is 1."
682,"<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",16,17,"<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>","<android.view.HardwareRenderer.GlRenderer: boolean draw(View,AttachInfo,HardwareDrawCallbacks,Rect)>",0,"{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.DRAWN;
        final int surfaceState = checkCurrent();
        if (surfaceState != SURFACE_STATE_ERROR) {
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            if (mProfileEnabled) {
                mProfileLock.lock();
            }
            // We had to change the current surface and/or context, redraw everything
            if (surfaceState == SURFACE_STATE_UPDATED) {
                dirty = null;
                beginFrame(null);
            } else {
                int[] size = mSurfaceSize;
                beginFrame(size);
                if (size[1] != mHeight || size[0] != mWidth) {
                    mWidth = size[0];
                    mHeight = size[1];
                    canvas.setViewport(mWidth, mHeight);
                    dirty = null;
                }
            }
            int status = onPreDraw(dirty);
            int saveCount = canvas.save();
            callbacks.onHardwarePreDraw(canvas);
            try {
                view.mRecreateDisplayList = (view.mPrivateFlags & View.INVALIDATED) == View.INVALIDATED;
                view.mPrivateFlags &= ~View.INVALIDATED;
                long getDisplayListStartTime = 0;
                if (mProfileEnabled) {
                    mProfileCurrentFrame += PROFILE_FRAME_DATA_COUNT;
                    if (mProfileCurrentFrame >= mProfileData.length) {
                        mProfileCurrentFrame = 0;
                    }
                    getDisplayListStartTime = System.nanoTime();
                }
                DisplayList displayList;
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""getDisplayList"");
                try {
                    displayList = view.getDisplayList();
                } finally {
                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                }
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - getDisplayListStartTime) * 0.000001f;
                    // noinspection PointlessArithmeticExpression
                    mProfileData[mProfileCurrentFrame] = total;
                }
                if (displayList != null) {
                    long drawDisplayListStartTime = 0;
                    if (mProfileEnabled) {
                        drawDisplayListStartTime = System.nanoTime();
                    }
                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""drawDisplayList"");
                    try {
                        status |= canvas.drawDisplayList(displayList, mRedrawClip, DisplayList.FLAG_CLIP_CHILDREN);
                    } finally {
                        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                    }
                    if (mProfileEnabled) {
                        long now = System.nanoTime();
                        float total = (now - drawDisplayListStartTime) * 0.000001f;
                        mProfileData[mProfileCurrentFrame + 1] = total;
                    }
                    handleFunctorStatus(attachInfo, status);
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
                mFrameCount++;
                if (mDebugDirtyRegions) {
                    if (mDebugPaint == null) {
                        mDebugPaint = new Paint();
                        mDebugPaint.setColor(0x7fff0000);
                    }
                    if (dirty != null && (mFrameCount & 1) == 0) {
                        canvas.drawRect(dirty, mDebugPaint);
                    }
                }
            }
            onPostDraw();
            attachInfo.mIgnoreDirtyState = false;
            if ((status & DisplayList.STATUS_DREW) == DisplayList.STATUS_DREW) {
                long eglSwapBuffersStartTime = 0;
                if (mProfileEnabled) {
                    eglSwapBuffersStartTime = System.nanoTime();
                }
                sEgl.eglSwapBuffers(sEglDisplay, mEglSurface);
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - eglSwapBuffersStartTime) * 0.000001f;
                    mProfileData[mProfileCurrentFrame + 2] = total;
                }
                checkEglErrors();
            }
            if (mProfileEnabled) {
                mProfileLock.unlock();
            }
            return dirty == null;
        }
    }
    return false;
}","{
    if (canDraw()) {
        if (!hasDirtyRegions()) {
            dirty = null;
        }
        attachInfo.mIgnoreDirtyState = true;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        view.mPrivateFlags |= View.PFLAG_DRAWN;
        final int surfaceState = checkCurrent();
        if (surfaceState != SURFACE_STATE_ERROR) {
            HardwareCanvas canvas = mCanvas;
            attachInfo.mHardwareCanvas = canvas;
            if (mProfileEnabled) {
                mProfileLock.lock();
            }
            // We had to change the current surface and/or context, redraw everything
            if (surfaceState == SURFACE_STATE_UPDATED) {
                dirty = null;
                beginFrame(null);
            } else {
                int[] size = mSurfaceSize;
                beginFrame(size);
                if (size[1] != mHeight || size[0] != mWidth) {
                    mWidth = size[0];
                    mHeight = size[1];
                    canvas.setViewport(mWidth, mHeight);
                    dirty = null;
                }
            }
            int saveCount = 0;
            int status = DisplayList.STATUS_DONE;
            try {
                view.mRecreateDisplayList = (view.mPrivateFlags & View.PFLAG_INVALIDATED) == View.PFLAG_INVALIDATED;
                view.mPrivateFlags &= ~View.PFLAG_INVALIDATED;
                long getDisplayListStartTime = 0;
                if (mProfileEnabled) {
                    mProfileCurrentFrame += PROFILE_FRAME_DATA_COUNT;
                    if (mProfileCurrentFrame >= mProfileData.length) {
                        mProfileCurrentFrame = 0;
                    }
                    getDisplayListStartTime = System.nanoTime();
                }
                canvas.clearLayerUpdates();
                DisplayList displayList;
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""getDisplayList"");
                try {
                    displayList = view.getDisplayList();
                } finally {
                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                }
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""prepareFrame"");
                try {
                    status = onPreDraw(dirty);
                } finally {
                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                }
                saveCount = canvas.save();
                callbacks.onHardwarePreDraw(canvas);
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - getDisplayListStartTime) * 0.000001f;
                    // noinspection PointlessArithmeticExpression
                    mProfileData[mProfileCurrentFrame] = total;
                }
                if (displayList != null) {
                    long drawDisplayListStartTime = 0;
                    if (mProfileEnabled) {
                        drawDisplayListStartTime = System.nanoTime();
                    }
                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""drawDisplayList"");
                    try {
                        status |= canvas.drawDisplayList(displayList, mRedrawClip, DisplayList.FLAG_CLIP_CHILDREN);
                    } finally {
                        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
                    }
                    if (mProfileEnabled) {
                        long now = System.nanoTime();
                        float total = (now - drawDisplayListStartTime) * 0.000001f;
                        mProfileData[mProfileCurrentFrame + 1] = total;
                    }
                    handleFunctorStatus(attachInfo, status);
                } else {
                    // Shouldn't reach here
                    view.draw(canvas);
                }
            } finally {
                callbacks.onHardwarePostDraw(canvas);
                canvas.restoreToCount(saveCount);
                view.mRecreateDisplayList = false;
                mFrameCount++;
                if (mDebugDirtyRegions) {
                    if (mDebugPaint == null) {
                        mDebugPaint = new Paint();
                        mDebugPaint.setColor(0x7fff0000);
                    }
                    if (dirty != null && (mFrameCount & 1) == 0) {
                        canvas.drawRect(dirty, mDebugPaint);
                    }
                }
            }
            onPostDraw();
            attachInfo.mIgnoreDirtyState = false;
            if ((status & DisplayList.STATUS_DREW) == DisplayList.STATUS_DREW) {
                long eglSwapBuffersStartTime = 0;
                if (mProfileEnabled) {
                    eglSwapBuffersStartTime = System.nanoTime();
                }
                sEgl.eglSwapBuffers(sEglDisplay, mEglSurface);
                if (mProfileEnabled) {
                    long now = System.nanoTime();
                    float total = (now - eglSwapBuffersStartTime) * 0.000001f;
                    mProfileData[mProfileCurrentFrame + 2] = total;
                }
                checkEglErrors();
            }
            if (mProfileEnabled) {
                mProfileLock.unlock();
            }
            return dirty == null;
        }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"There are mainly two changes: 1) The flag `View.DRAWN` has been changed to `View.PFLAG_DRAWN`. 2) The flag `View.INVALIDATED` has been changed to `View.PFLAG_INVALIDATED`. Both changes are related to constant fields, which are outside of this method. Thus, the change classification is 4.","Even though there were changes in the constant field values, they wouldn't lead to any Compatibility Issue. Therefore, No Compatibility Issue exists."
683,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",16,17,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>","<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",0,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        WindowManagerGlobal.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The methodology used to acquire the window session has changed, from 'ViewRootImpl' to 'WindowManagerGlobal'. Therefore, both an other statement changed (4) and dependent API changed (5) occurred.","Despite the change in the method used to get the window session, the overall functionality of the method remains the same. Thus, as it will not potentially lead to the API returning different values or exceptions, this is classified as no compatibility issue (0)."
685,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",16,17,"<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>","<android.provider.Settings.System: boolean putString(ContentResolver,String,String)>",0,"{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, ""Setting "" + name + "" has moved from android.provider.Settings.System"" + "" to android.provider.Settings.Secure, value is unchanged."");
        return false;
    }
    return putString(resolver, CONTENT_URI, name, value);
}","{
    return putStringForUser(resolver, name, value, UserHandle.myUserId());
}",1,"/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
","/**
 * Store a name/value pair into the database.
 * @param resolver to access the database with
 * @param name to store
 * @param value to associate with the name
 * @return true if the value was set, false on database errors
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"There is a change in the way the returning value is computed. In the initial version, it checks if the 'name' is in 'MOVED_TO_SECURE', which is presumably a set of secure strings. If the 'name' is in that set, it logs a warning and returns false. Otherwise, it calls putString() with the resolver, CONTENT_URI, name, and value and returns its result. In comparison, the later version directly returns the result of putStringForUser() with resolver, name, value, and UserHandle.myUserId(). Thus, it qualifies as a kind of return statement change (1) and dependent API change (5).","The change in the method of how the returning value is computed could potentially make the method return a different value, hence this can be considered a compatibility issue caused by potential different return values or types (1)."
686,<android.os.storage.IMountService.Stub.Proxy: String getMountedObbPath(String)>,16,17,<android.os.storage.IMountService.Stub.Proxy: String getMountedObbPath(String)>,<android.os.storage.IMountService.Stub.Proxy: String getMountedObbPath(String)>,0,"{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    String _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(filename);
        mRemote.transact(Stub.TRANSACTION_getMountedObbPath, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readString();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}","{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    String _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(rawPath);
        mRemote.transact(Stub.TRANSACTION_getMountedObbPath, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readString();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}",1,"/**
 * Gets the path to the mounted Opaque Binary Blob (OBB).
 */
","/**
 * Gets the path to the mounted Opaque Binary Blob (OBB).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement ""_data.writeString(filename)"" has been changed to ""_data.writeString(rawPath)"", so the change type is 4.","The change of variable 'filename' to 'rawPath' will not affect the return value or exception handling behavior of the API, therefore no Compatibility Issue exists. The CI type is 0."
687,<android.text.format.DateUtils: String getAMPMString(int)>,16,17,<android.text.format.DateUtils: String getAMPMString(int)>,<android.text.format.DateUtils: String getAMPMString(int)>,0,"{
    Resources r = Resources.getSystem();
    return r.getString(sAmPm[ampm - Calendar.AM]);
}","{
    return LocaleData.get(Locale.getDefault()).amPm[ampm - Calendar.AM];
}",1,"/**
 * Return a localized string for AM or PM.
 * @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.
 * @throws IndexOutOfBoundsException if the ampm is out of bounds.
 * @return Localized version of ""AM"" or ""PM"".
 */
","/**
 * Return a localized string for AM or PM.
 * @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.
 * @throws IndexOutOfBoundsException if the ampm is out of bounds.
 * @return Localized version of ""AM"" or ""PM"".
 * @deprecated use {@link java.text.SimpleDateFormat} instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from retrieving a string from resources(`r.getString(sAmPm[ampm - Calendar.AM])`) to retrieving a string from locale data(`LocaleData.get(Locale.getDefault()).amPm[ampm - Calendar.AM]`). Also, Initial API(Resources.getSystem() and r.getString()) used in early version has changed to a different API(LocaleData.get() and Locale.getDefault()) in the later version. Therefore, the code change type is 1,5.","Since the value of the returned string in the late version potentially differs from the early version due to the change in data source. Hence, the CI type is 1."
688,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",16,17,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>","<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",0,"{
    if ((mPrivateFlags & DRAWN) == DRAWN || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) != FLAG_CLIP_CHILDREN || dirty.intersect(0, 0, mRight - left, mBottom - top) || (mPrivateFlags & DRAW_ANIMATION) == DRAW_ANIMATION) {
                mPrivateFlags &= ~DRAWING_CACHE_VALID;
                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
                if (mLayerType != LAYER_TYPE_NONE) {
                    mPrivateFlags |= INVALIDATED;
                    mLocalDirtyRect.union(dirty);
                }
                return mParent;
            }
        } else {
            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}","{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control condition statement has been changed, and the constant value in the bitwise operations has been changed, which indicates that the 'if' condition and related statements have been changed, so the code change type is 1,3,4.","Because of the change in 'if' condition and related statements, the calculated 'dirty' may vary, which affects the return value and may lead to potential different behaviours. Thus, CI type is 1."
690,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>",16,17,"<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>","<android.app.ApplicationPackageManager: List<ResolveInfo> queryIntentActivities(Intent,int)>",0,"{
    try {
        return mPM.queryIntentActivities(intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), flags, UserId.myUserId());
    } catch (RemoteException e) {
        throw new RuntimeException(""Package manager has died"", e);
    }
}","{
    return queryIntentActivitiesAsUser(intent, flags, mContext.getUserId());
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"In the late implementation, the API is reliant on another method named ""queryIntentActivitiesAsUser"". Besides, the early implementation and the late implementation have different return statements. Thus, the change can be categorized as types 1 and 5.","Due to the different return statements used in the early and late version, this API may return different values, leading to a potential compatibility issue of type 1."
691,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",16,17,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>","<android.accounts.AccountManager: AccountManagerFuture<Bundle> confirmCredentials(Account,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",0,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.confirmCredentials(mResponse, account, options, activity != null);
        }
    }.start();
}","{
    return confirmCredentialsAsUser(account, options, activity, callback, handler, Process.myUserHandle());
}",1,"/**
 * Confirms that the user knows the password for an account to make extra
 * sure they are the owner of the account.  The user-entered password can
 * be supplied directly, otherwise the authenticator for this account type
 * prompts the user with the appropriate interface.  This method is
 * intended for applications which want extra assurance; for example, the
 * phone lock screen uses this to let the user unlock the phone with an
 * account password if they forget the lock pattern.
 *
 * <p>If the user-entered password matches a saved password for this
 * account, the request is considered valid; otherwise the authenticator
 * verifies the password (usually by contacting the server).
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account to confirm password knowledge for
 * @param options Authenticator-specific options for the request;
 * if the {@link #KEY_PASSWORD} string field is present, the
 * authenticator may use it directly rather than prompting the user;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if activity or password was supplied and
 * the account was successfully verified:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_BOOLEAN_RESULT} - true to indicate success
 * </ul>
 *
 * If no activity or password was specified, the returned Bundle contains
 * only {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
","/**
 * Confirms that the user knows the password for an account to make extra
 * sure they are the owner of the account.  The user-entered password can
 * be supplied directly, otherwise the authenticator for this account type
 * prompts the user with the appropriate interface.  This method is
 * intended for applications which want extra assurance; for example, the
 * phone lock screen uses this to let the user unlock the phone with an
 * account password if they forget the lock pattern.
 *
 * <p>If the user-entered password matches a saved password for this
 * account, the request is considered valid; otherwise the authenticator
 * verifies the password (usually by contacting the server).
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param account The account to confirm password knowledge for
 * @param options Authenticator-specific options for the request;
 * if the {@link #KEY_PASSWORD} string field is present, the
 * authenticator may use it directly rather than prompting the user;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if activity or password was supplied and
 * the account was successfully verified:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_BOOLEAN_RESULT} - true to indicate success
 * </ul>
 *
 * If no activity or password was specified, the returned Bundle contains
 * only {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire method implementation logic has changed, including the return statement and the dependent API. The early version uses AmsTask(activity, handler, callback) and mService.confirmCredentials(mResponse, account, options, activity != null). The late version is using a new dependent API confirmCredentialsAsUser(account, options, activity, callback, handler, Process.myUserHandle()). Therefore, the change types are 1 and 5.","Due to the change of the return statement and the dependent API, the late version of the method may return a different value compared to the early version, which may cause potential compatibility issues. Therefore, the CI type is 1."
692,<android.app.ActivityOptions: void update(ActivityOptions)>,16,17,<android.app.ActivityOptions: void update(ActivityOptions)>,<android.app.ActivityOptions: void update(ActivityOptions)>,0,"{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mAnimationType = otherOptions.mAnimationType;
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mAnimationType = otherOptions.mAnimationType;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mStartWidth = otherOptions.mStartWidth;
            mStartHeight = otherOptions.mStartHeight;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL:
        case ANIM_THUMBNAIL_DELAYED:
            mAnimationType = otherOptions.mAnimationType;
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
    }
}","{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mAnimationType = otherOptions.mAnimationType;
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mAnimationType = otherOptions.mAnimationType;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mStartWidth = otherOptions.mStartWidth;
            mStartHeight = otherOptions.mStartHeight;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            mAnimationType = otherOptions.mAnimationType;
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
    }
}",1,"/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
","/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"The control dependencies relating to switch cases (ANIM_THUMBNAIL, ANIM_THUMBNAIL_DELAYED are replaced with ANIM_THUMBNAIL_SCALE_UP, ANIM_THUMBNAIL_SCALE_DOWN) are changed, which falls under code change type 3. The change in the case constants implies a change in dependent API, which falls under code change type 5.","Although the switch case constants are changed, the usage of these values and the subsequent operations remain the same. Therefore, despite the code change, there is no compatibility issue since the behavior of the function does not change and it does not cause the API to return a different variable or throws an exception differently."
694,"<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>",16,17,"<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>","<android.provider.Settings.Secure: int getInt(ContentResolver,String,int)>",0,"{
    String v = getString(cr, name);
    try {
        return v != null ? Integer.parseInt(v) : def;
    } catch (NumberFormatException e) {
        return def;
    }
}","{
    return getIntForUser(cr, name, def, UserHandle.myUserId());
}",1,"/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
","/**
 * Convenience function for retrieving a single secure settings value
 * as an integer.  Note that internally setting values are always
 * stored as strings; this function converts the string to an integer
 * for you.  The default value will be returned if the setting is
 * not defined or not an integer.
 *
 * @param cr The ContentResolver to access.
 * @param name The name of the setting to retrieve.
 * @param def Value to return if the setting is not defined.
 *
 * @return The setting's current value, or 'def' if it is not defined
 * or not a valid integer.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function call in the return statement has changed from parsing a string and returning a default value in case of NumberFormatException to calling getIntForUser(), thus the change type is 1,5.","Since the return statement has changed, the API can potentially return a different value, leading to a compatibility issue of type 1."
695,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,16,17,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,<android.os.Environment: File getExternalStoragePublicDirectory(String)>,0,"{
    return new File(getExternalStorageDirectory(), type);
}","{
    throwIfSystem();
    return sCurrentUser.getExternalStoragePublicDirectory(type);
}",1,"/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
","/**
 * Get a top-level public external storage directory for placing files of
 * a particular type.  This is where the user will typically place and
 * manage their own files, so you should be careful about what you put here
 * to ensure you don't erase their files or get in the way of their own
 * organization.
 *
 * <p>On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only
 * have access to the external storage for the user they're running as.</p>
 *
 * <p>Here is an example of typical code to manipulate a picture on
 * the public external storage:</p>
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * public_picture}
 *
 * @param type The type of storage directory to return.  Should be one of
 * {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},
 * {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},
 * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},
 * {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS}, or
 * {@link #DIRECTORY_DCIM}.  May not be null.
 *
 * @return Returns the File path for the directory.  Note that this
 * directory may not yet exist, so you must make sure it exists before
 * using it such as with {@link File#mkdirs File.mkdirs()}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,4","1,2","A new 'throw' statement and a new 'return' statement have been introduced in the late version. Also, the expression for creation of the File object has been changed. So, the pred_change categories are 1,2,4.","The new 'throw' statement could potentially cause the API to throw a new exception and the change in 'return' statement could potentially cause the API to return a different value. Hence, the CI categories are 1,2."
696,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,16,17,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,<android.animation.Keyframe.ObjectKeyframe: ObjectKeyframe clone()>,0,"{
    ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mValue);
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}","{
    ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mHasValue ? mValue : null);
    kfClone.setInterpolator(getInterpolator());
    return kfClone;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The constructor of 'ObjectKeyframe' in 'new ObjectKeyframe()' has changed conditions, and a new condition 'mHasValue ?' has been added when creating 'kfClone' object, the changed type is 1,3.","Since 'mHasValue ? mValue : null' introduces a new condition, the return value of the method 'clone()' could change in different situations compared to the early version, thus the CI type is 1."
697,"<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>",16,17,"<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>","<android.appwidget.AppWidgetHost: AppWidgetHostView onCreateView(Context,int,AppWidgetProviderInfo)>",0,"{
    return new AppWidgetHostView(context);
}","{
    return new AppWidgetHostView(context, mOnClickHandler);
}",1,"/**
 * Called to create the AppWidgetHostView.  Override to return a custom subclass if you
 * need it.  {@more}
 */
","/**
 * Called to create the AppWidgetHostView.  Override to return a custom subclass if you
 * need it.  {@more}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'new AppWidgetHostView(context);' to 'new AppWidgetHostView(context, mOnClickHandler);' and the number of parameters of constructor in the return statement changed, so the code change type is 1,5.","Because of the additional parameter mOnClickHandler in the constructor, in the later version, a different instance of AppWidgetHostView might be returned, potentially representing a different state or behaviour of the object. So the CI type is 1."
698,<android.content.pm.ProviderInfo: String toString()>,16,17,<android.content.pm.ProviderInfo: String toString()>,<android.content.pm.ProviderInfo: String toString()>,0,"{
    return ""ContentProviderInfo{name="" + authority + "" className="" + name + "" isSyncable="" + (isSyncable ? ""true"" : ""false"") + ""}"";
}","{
    return ""ContentProviderInfo{name="" + authority + "" className="" + name + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning a string that includes ""isSyncable="" + (isSyncable ? ""true"" : ""false"") to one that does not includes this information, so the code change type is 1.","As the returned string after the API invocation can be different in the late version, the CI type is 1."
699,<android.webkit.CallbackProxy: void onReceivedIcon(Bitmap)>,16,17,<android.webkit.CallbackProxy: void onReceivedIcon(Bitmap)>,<android.webkit.CallbackProxy: void onReceivedIcon(Bitmap)>,0,"{
    // The current item might be null if the icon was already stored in the
    // database and this is a new WebView.
    WebHistoryItem i = mBackForwardList.getCurrentItem();
    if (i != null) {
        i.setFavicon(icon);
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_ICON, icon));
}","{
    // The current item might be null if the icon was already stored in the
    // database and this is a new WebView.
    WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
    if (i != null) {
        i.setFavicon(icon);
    }
    // been set.
    if (mWebChromeClient == null) {
        return;
    }
    sendMessage(obtainMessage(RECEIVED_ICON, icon));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"The type of object 'i' has changed from WebHistoryItem to WebHistoryItemClassic, so the code change type is 5.","Although the dependent class used in the method has changed, it does not impact the behavior of the method. There is no potential difference in return or exception. So, there is no Compatibility Issue."
700,<android.app.AlertDialog.Builder: AlertDialog create()>,16,17,<android.app.AlertDialog.Builder: AlertDialog create()>,<android.app.AlertDialog.Builder: AlertDialog create()>,0,"{
    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    if (P.mCancelable) {
        dialog.setCanceledOnTouchOutside(true);
    }
    dialog.setOnCancelListener(P.mOnCancelListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}","{
    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    if (P.mCancelable) {
        dialog.setCanceledOnTouchOutside(true);
    }
    dialog.setOnCancelListener(P.mOnCancelListener);
    dialog.setOnDismissListener(P.mOnDismissListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}",1,"/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder. It does not
 * {@link Dialog#show()} the dialog. This allows the user to do any extra processing
 * before displaying the dialog. Use {@link #show()} if you don't have any other processing
 * to do and want this to be created and displayed.
 */
","/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder. It does not
 * {@link Dialog#show()} the dialog. This allows the user to do any extra processing
 * before displaying the dialog. Use {@link #show()} if you don't have any other processing
 * to do and want this to be created and displayed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"There is an extra method call, dialog.setOnDismissListener(P.mOnDismissListener), being added in the late version. So the code change type is ""4"".","The addition of dialog.setOnDismissListener(P.mOnDismissListener) in the late version will affect the state of the created AlertDialog object (by potentially setting a dismiss listener), which might affect the behaviour of the returned object from this method. Thus, there is a compatibility issue and the CI type is ""1""."
701,<android.widget.ProgressBar: void onDraw(Canvas)>,16,17,<android.widget.ProgressBar: void onDraw(Canvas)>,<android.widget.ProgressBar: void onDraw(Canvas)>,0,"{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        canvas.translate(mPaddingLeft, mPaddingTop);
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}","{
    super.onDraw(canvas);
    Drawable d = mCurrentDrawable;
    if (d != null) {
        // Translate canvas so a indeterminate circular progress bar with padding
        // rotates properly in its animation
        canvas.save();
        if (isLayoutRtl()) {
            canvas.translate(getWidth() - mPaddingRight, mPaddingTop);
            canvas.scale(-1.0f, 1.0f);
        } else {
            canvas.translate(mPaddingLeft, mPaddingTop);
        }
        long time = getDrawingTime();
        if (mHasAnimation) {
            mAnimation.getTransformation(time, mTransformation);
            float scale = mTransformation.getAlpha();
            try {
                mInDrawing = true;
                d.setLevel((int) (scale * MAX_LEVEL));
            } finally {
                mInDrawing = false;
            }
            postInvalidateOnAnimation();
        }
        d.draw(canvas);
        canvas.restore();
        if (mShouldStartAnimationDrawable && d instanceof Animatable) {
            ((Animatable) d).start();
            mShouldStartAnimationDrawable = false;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control statements and the contents inside if (d != null) block have changed significantly. Therefore, the code change type is 3.","The late version includes additional operations, such as canvas.scale(), which may affect the returned value of onDraw() method and lead to different behavior. Therefore, the CI type is 1."
702,<android.view.ViewGroup: boolean notifyChildOfDrag(View)>,16,17,<android.view.ViewGroup: boolean notifyChildOfDrag(View)>,<android.view.ViewGroup: boolean notifyChildOfDrag(View)>,0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    boolean canAccept = false;
    if (!mDragNotifiedChildren.contains(child)) {
        mDragNotifiedChildren.add(child);
        canAccept = child.dispatchDragEvent(mCurrentDrag);
        if (canAccept && !child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    boolean canAccept = false;
    if (!mDragNotifiedChildren.contains(child)) {
        mDragNotifiedChildren.add(child);
        canAccept = child.dispatchDragEvent(mCurrentDrag);
        if (canAccept && !child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.PFLAG2_DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter in the bitwise OR operation has changed from `View.DRAG_CAN_ACCEPT` to `View.PFLAG2_DRAG_CAN_ACCEPT`, but this internal change does not alter the functionality of the API. Therefore, the classification of the code change is 4.","Although there is a parameter change, it does not affect the return value or the exception handling of the function. Therefore, there is no compatibility issue in this case. The CI type is 0."
705,<android.view.TextureView: HardwareLayer getHardwareLayer()>,16,17,<android.view.TextureView: HardwareLayer getHardwareLayer()>,<android.view.TextureView: HardwareLayer getHardwareLayer()>,0,"{
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // from an arbitrary thread
                synchronized (mLock) {
                    mUpdateLayer = true;
                }
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // parameters are correct (width, height, transform, etc.)
        synchronized (mLock) {
            mUpdateLayer = true;
        }
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}","{
    // NOTE: Maintain these two lines very carefully (see View.java)
    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    if (mLayer == null) {
        if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
            return null;
        }
        mLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(mOpaque);
        if (!mUpdateSurface) {
            // Create a new SurfaceTexture for the layer.
            mSurface = mAttachInfo.mHardwareRenderer.createSurfaceTexture(mLayer);
        }
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
        nCreateNativeWindow(mSurface);
        mUpdateListener = new SurfaceTexture.OnFrameAvailableListener() {

            @Override
            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
                // Per SurfaceTexture's documentation, the callback may be invoked
                // from an arbitrary thread
                updateLayer();
                if (Looper.myLooper() == Looper.getMainLooper()) {
                    invalidate();
                } else {
                    postInvalidate();
                }
            }
        };
        mSurface.setOnFrameAvailableListener(mUpdateListener);
        if (mListener != null && !mUpdateSurface) {
            mListener.onSurfaceTextureAvailable(mSurface, getWidth(), getHeight());
        }
        mLayer.setLayerPaint(mLayerPaint);
    }
    if (mUpdateSurface) {
        // Someone has requested that we use a specific SurfaceTexture, so
        // tell mLayer about it and set the SurfaceTexture to use the
        // current view size.
        mUpdateSurface = false;
        // Since we are updating the layer, force an update to ensure its
        // parameters are correct (width, height, transform, etc.)
        updateLayer();
        mMatrixChanged = true;
        mAttachInfo.mHardwareRenderer.setSurfaceTexture(mLayer, mSurface);
        nSetDefaultBufferSize(mSurface, getWidth(), getHeight());
    }
    applyUpdate();
    applyTransformMatrix();
    return mLayer;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Two new lines mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; and mPrivateFlags &= ~PFLAG_DIRTY_MASK; are introduced at the beginning of the latest implementation. Inside the 'mUpdateListener = new SurfaceTexture.OnFrameAvailableListener()' function, the synchronized block has been replaced by 'updateLayer();'. A new line 'mLayer.setLayerPaint(mLayerPaint);' is added in the latter part of the function, so the code change type is 3,4.","Given the changes introduced, the return variable 'mLayer' might be different due to the added statement 'mLayer.setLayerPaint(mLayerPaint);' and other changes in the code flow, indicating a CI of type 1."
