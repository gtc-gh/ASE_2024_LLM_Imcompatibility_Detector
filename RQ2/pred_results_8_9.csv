Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,8,9,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,<android.database.sqlite.SQLiteCompiledSql: void finalize()>,0,"{
    try {
        if (nStatement == 0)
            return;
        // finalizer should NEVER get called
        if (SQLiteDebug.DEBUG_ACTIVE_CURSOR_FINALIZATION) {
            Log.v(TAG, ""** warning ** Finalized DbObj (id#"" + nStatement + "")"");
        }
        int len = mSqlStmt.length();
        Log.w(TAG, ""Releasing statement in a finalizer. Please ensure "" + ""that you explicitly call close() on your cursor: "" + mSqlStmt.substring(0, (len > 100) ? 100 : len), mStackTrace);
        releaseSqlStatement();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (nStatement == 0)
            return;
        // finalizer should NEVER get called
        if (SQLiteDebug.DEBUG_ACTIVE_CURSOR_FINALIZATION) {
            Log.v(TAG, ""** warning ** Finalized DbObj (id#"" + nStatement + "")"");
        }
        if (StrictMode.vmSqliteObjectLeaksEnabled()) {
            int len = mSqlStmt.length();
            StrictMode.onSqliteObjectLeaked(""Releasing statement in a finalizer. Please ensure "" + ""that you explicitly call close() on your cursor: "" + mSqlStmt.substring(0, (len > 100) ? 100 : len), mStackTrace);
        }
        releaseSqlStatement();
    } finally {
        super.finalize();
    }
}",1,"/**
 * Make sure that the native resource is cleaned up.
 */
","/**
 * Make sure that the native resource is cleaned up.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The API implementation in the late version introduced a new condition statement, ""if (StrictMode.vmSqliteObjectLeaksEnabled())"", and the Log.w() statement was replaced by StrictMode.onSqliteObjectLeaked() within that new condition. So, the code changes involve both return statement changes and other statement changes, resulting in change type 1,4.","Despite the code changes, there is no Compatibility Issue. The API users will only experience a different logging mechanism under certain conditions (StrictMode.vmSqliteObjectLeaksEnabled()), but the API will not return a different value or raise a different exception. Therefore, no CI is created and the CI type is 0."
1,<android.pim.vcard.VCardBuilder: VCardBuilder appendEvents(List<ContentValues>)>,8,9,<android.pim.vcard.VCardBuilder: VCardBuilder appendEvents(List<ContentValues>)>,<android.pim.vcard.VCardBuilder: VCardBuilder appendEvents(List<ContentValues>)>,0,"{
    if (contentValuesList != null) {
        String primaryBirthday = null;
        String secondaryBirthday = null;
        for (final ContentValues contentValues : contentValuesList) {
            if (contentValues == null) {
                continue;
            }
            final Integer eventTypeAsInteger = contentValues.getAsInteger(Event.TYPE);
            final int eventType;
            if (eventTypeAsInteger != null) {
                eventType = eventTypeAsInteger;
            } else {
                eventType = Event.TYPE_OTHER;
            }
            if (eventType == Event.TYPE_BIRTHDAY) {
                final String birthdayCandidate = contentValues.getAsString(Event.START_DATE);
                if (birthdayCandidate == null) {
                    continue;
                }
                final Integer isSuperPrimaryAsInteger = contentValues.getAsInteger(Event.IS_SUPER_PRIMARY);
                final boolean isSuperPrimary = (isSuperPrimaryAsInteger != null ? (isSuperPrimaryAsInteger > 0) : false);
                if (isSuperPrimary) {
                    // ""super primary"" birthday should the prefered one.
                    primaryBirthday = birthdayCandidate;
                    break;
                }
                final Integer isPrimaryAsInteger = contentValues.getAsInteger(Event.IS_PRIMARY);
                final boolean isPrimary = (isPrimaryAsInteger != null ? (isPrimaryAsInteger > 0) : false);
                if (isPrimary) {
                    // We don't break here since ""super primary"" birthday may exist later.
                    primaryBirthday = birthdayCandidate;
                } else if (secondaryBirthday == null) {
                    // First entry is set to the ""secondary"" candidate.
                    secondaryBirthday = birthdayCandidate;
                }
            } else if (mUsesAndroidProperty) {
                // Event types other than Birthday is not supported by vCard.
                appendAndroidSpecificProperty(Event.CONTENT_ITEM_TYPE, contentValues);
            }
        }
        if (primaryBirthday != null) {
            appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_BDAY, primaryBirthday.trim());
        } else if (secondaryBirthday != null) {
            appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_BDAY, secondaryBirthday.trim());
        }
    }
    return this;
}","{
    // is inappropriate. We just build one birthday.
    if (contentValuesList != null) {
        String primaryBirthday = null;
        String secondaryBirthday = null;
        for (final ContentValues contentValues : contentValuesList) {
            if (contentValues == null) {
                continue;
            }
            final Integer eventTypeAsInteger = contentValues.getAsInteger(Event.TYPE);
            final int eventType;
            if (eventTypeAsInteger != null) {
                eventType = eventTypeAsInteger;
            } else {
                eventType = Event.TYPE_OTHER;
            }
            if (eventType == Event.TYPE_BIRTHDAY) {
                final String birthdayCandidate = contentValues.getAsString(Event.START_DATE);
                if (birthdayCandidate == null) {
                    continue;
                }
                final Integer isSuperPrimaryAsInteger = contentValues.getAsInteger(Event.IS_SUPER_PRIMARY);
                final boolean isSuperPrimary = (isSuperPrimaryAsInteger != null ? (isSuperPrimaryAsInteger > 0) : false);
                if (isSuperPrimary) {
                    // ""super primary"" birthday should the prefered one.
                    primaryBirthday = birthdayCandidate;
                    break;
                }
                final Integer isPrimaryAsInteger = contentValues.getAsInteger(Event.IS_PRIMARY);
                final boolean isPrimary = (isPrimaryAsInteger != null ? (isPrimaryAsInteger > 0) : false);
                if (isPrimary) {
                    // We don't break here since ""super primary"" birthday may exist later.
                    primaryBirthday = birthdayCandidate;
                } else if (secondaryBirthday == null) {
                    // First entry is set to the ""secondary"" candidate.
                    secondaryBirthday = birthdayCandidate;
                }
            } else if (mUsesAndroidProperty) {
                // Event types other than Birthday is not supported by vCard.
                appendAndroidSpecificProperty(Event.CONTENT_ITEM_TYPE, contentValues);
            }
        }
        if (primaryBirthday != null) {
            appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_BDAY, primaryBirthday.trim());
        } else if (secondaryBirthday != null) {
            appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_BDAY, secondaryBirthday.trim());
        }
    }
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change within the code between the two versions.,"As there is no change, there is no compatibility issue."
3,<android.database.DatabaseUtils: void readExceptionWithFileNotFoundExceptionFromParcel(Parcel)>,8,9,<android.database.DatabaseUtils: void readExceptionWithFileNotFoundExceptionFromParcel(Parcel)>,<android.database.DatabaseUtils: void readExceptionWithFileNotFoundExceptionFromParcel(Parcel)>,0,"{
    int code = reply.readInt();
    if (code == 0)
        return;
    String msg = reply.readString();
    if (code == 1) {
        throw new FileNotFoundException(msg);
    } else {
        DatabaseUtils.readExceptionFromParcel(reply, msg, code);
    }
}","{
    int code = reply.readExceptionCode();
    if (code == 0)
        return;
    String msg = reply.readString();
    if (code == 1) {
        throw new FileNotFoundException(msg);
    } else {
        DatabaseUtils.readExceptionFromParcel(reply, msg, code);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The method that the current API relies on has been changed from reply.readInt() to reply.readExceptionCode(). Therefore, the code change type is 4,5.","The introduced change in the dependent API (readExceptionCode instead of readInt) might potentially change the value of 'code', therefore affecting subsequent control flows and exception handlings or return values. Thus, the CI type is 1."
4,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",8,9,"<android.webkit.WebView: boolean savePicture(Bundle,File)>","<android.webkit.WebView: boolean savePicture(Bundle,File)>",0,"{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            try {
                FileOutputStream out = new FileOutputStream(temp);
                p.writeToStream(out);
                out.close();
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    b.putFloat(""scale"", mActualScale);
    b.putFloat(""textwrapScale"", mTextWrapScale);
    b.putBoolean(""overview"", mInZoomOverview);
    return true;
}","{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(temp);
                p.writeToStream(out);
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e) {
                    // Can't do anything about that
                    }
                }
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    b.putFloat(""scale"", mActualScale);
    b.putFloat(""textwrapScale"", mTextWrapScale);
    b.putBoolean(""overview"", mInZoomOverview);
    return true;
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
","/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change is related to the close() call to the FileOutputStream object. In the early Implementation, it was directly called inside the try block but in the late implementation, it has been moved to the finally block, checking if the ""out"" is not null then calling close(). This change can be classified as a control dependency change (3) and other statement changed (4).","Though there's a change, the final output of the method or the exception it may throw in the process hasn't changed as the close() call is still there just that it's now in a separate control block. Hence, no Compatibility Issue (0) exists here."
5,<android.pim.vcard.VCardConfig: boolean appendTypeParamName(int)>,8,9,<android.pim.vcard.VCardConfig: boolean appendTypeParamName(int)>,<android.pim.vcard.VCardConfig: boolean appendTypeParamName(int)>,0,"{
    return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}","{
    return (isVersion30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from isV30(vcardType) to isVersion30(vcardType), which signifies a change in the method being called. Therefore, the change types are 1 (Return statement changed), and 5 (Dependent API changed).","The called method in return statement has changed, which means the returning result might differ between the two versions, leading to a compatibility issue. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
6,<android.view.MotionEvent: MotionEvent obtainNoHistory(MotionEvent)>,8,9,<android.view.MotionEvent: MotionEvent obtainNoHistory(MotionEvent)>,<android.view.MotionEvent: MotionEvent obtainNoHistory(MotionEvent)>,0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = o.mDeviceId;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTime = o.mDownTime;
    ev.mEventTimeNano = o.mEventTimeNano;
    ev.mAction = o.mAction;
    ev.mNumPointers = o.mNumPointers;
    ev.mRawX = o.mRawX;
    ev.mRawY = o.mRawY;
    ev.mMetaState = o.mMetaState;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    ev.mNumSamples = 1;
    ev.mTimeSamples[0] = o.mTimeSamples[0];
    final int NP = (ev.mNumPointers = o.mNumPointers);
    if (ev.mPointerIdentifiers.length >= NP) {
        System.arraycopy(o.mPointerIdentifiers, 0, ev.mPointerIdentifiers, 0, NP);
    } else {
        ev.mPointerIdentifiers = (int[]) o.mPointerIdentifiers.clone();
    }
    final int ND = NP * NUM_SAMPLE_DATA;
    if (ev.mDataSamples.length >= ND) {
        System.arraycopy(o.mDataSamples, 0, ev.mDataSamples, 0, ND);
    } else {
        ev.mDataSamples = (float[]) o.mDataSamples.clone();
    }
    return ev;
}","{
    MotionEvent ev = obtain(o.mNumPointers, 1);
    ev.mDeviceId = o.mDeviceId;
    ev.mSource = o.mSource;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTimeNano = o.mDownTimeNano;
    ev.mAction = o.mAction;
    o.mFlags = o.mFlags;
    ev.mMetaState = o.mMetaState;
    ev.mXOffset = o.mXOffset;
    ev.mYOffset = o.mYOffset;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    int numPointers = ev.mNumPointers = o.mNumPointers;
    ev.mNumSamples = 1;
    ev.mLastDataSampleIndex = 0;
    ev.mLastEventTimeNanoSampleIndex = 0;
    System.arraycopy(o.mPointerIdentifiers, 0, ev.mPointerIdentifiers, 0, numPointers);
    ev.mEventTimeNanoSamples[0] = o.mEventTimeNanoSamples[o.mLastEventTimeNanoSampleIndex];
    System.arraycopy(o.mDataSamples, o.mLastDataSampleIndex, ev.mDataSamples, 0, numPointers * NUM_SAMPLE_DATA);
    return ev;
}",1,"/**
 * Create a new MotionEvent, copying from an existing one, but not including
 * any historical point information.
 */
","/**
 * Create a new MotionEvent, copying from an existing one, but not including
 * any historical point information.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Multiple statements in the early version implementation have either been changed or removed and new variable assignments have been introduced in the late implementation. This is a significant change both in the return statement and other IO operations which results in a code change type of 1,4.","While the function of the method remains similar between both versions, the specifics of the return statement have changed significantly, as evidenced by different variable assignments and method calls, making the return variable different. Therefore, the CI type is 1."
8,<android.pim.vcard.VCardEntry: Uri pushIntoContentResolver(ContentResolver)>,8,9,<android.pim.vcard.VCardEntry: Uri pushIntoContentResolver(ContentResolver)>,<android.pim.vcard.VCardEntry: Uri pushIntoContentResolver(ContentResolver)>,0,"{
    ArrayList<ContentProviderOperation> operationList = new ArrayList<ContentProviderOperation>();
    // After applying the batch the first result's Uri is returned so it is important that
    // the RawContact is the first operation that gets inserted into the list
    ContentProviderOperation.Builder builder = ContentProviderOperation.newInsert(RawContacts.CONTENT_URI);
    String myGroupsId = null;
    if (mAccount != null) {
        builder.withValue(RawContacts.ACCOUNT_NAME, mAccount.name);
        builder.withValue(RawContacts.ACCOUNT_TYPE, mAccount.type);
        // Assume that caller side creates this group if it does not exist.
        if (ACCOUNT_TYPE_GOOGLE.equals(mAccount.type)) {
            final Cursor cursor = resolver.query(Groups.CONTENT_URI, new String[] { Groups.SOURCE_ID }, Groups.TITLE + ""=?"", new String[] { GOOGLE_MY_CONTACTS_GROUP }, null);
            try {
                if (cursor != null && cursor.moveToFirst()) {
                    myGroupsId = cursor.getString(0);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
        }
    } else {
        builder.withValue(RawContacts.ACCOUNT_NAME, null);
        builder.withValue(RawContacts.ACCOUNT_TYPE, null);
    }
    operationList.add(builder.build());
    if (!nameFieldsAreEmpty()) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(StructuredName.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
        builder.withValue(StructuredName.GIVEN_NAME, mGivenName);
        builder.withValue(StructuredName.FAMILY_NAME, mFamilyName);
        builder.withValue(StructuredName.MIDDLE_NAME, mMiddleName);
        builder.withValue(StructuredName.PREFIX, mPrefix);
        builder.withValue(StructuredName.SUFFIX, mSuffix);
        if (!(TextUtils.isEmpty(mPhoneticGivenName) && TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName))) {
            builder.withValue(StructuredName.PHONETIC_GIVEN_NAME, mPhoneticGivenName);
            builder.withValue(StructuredName.PHONETIC_FAMILY_NAME, mPhoneticFamilyName);
            builder.withValue(StructuredName.PHONETIC_MIDDLE_NAME, mPhoneticMiddleName);
        } else if (!TextUtils.isEmpty(mPhoneticFullName)) {
            builder.withValue(StructuredName.PHONETIC_GIVEN_NAME, mPhoneticFullName);
        }
        builder.withValue(StructuredName.DISPLAY_NAME, getDisplayName());
        operationList.add(builder.build());
    }
    if (mNickNameList != null && mNickNameList.size() > 0) {
        for (String nickName : mNickNameList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Nickname.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Nickname.CONTENT_ITEM_TYPE);
            builder.withValue(Nickname.TYPE, Nickname.TYPE_DEFAULT);
            builder.withValue(Nickname.NAME, nickName);
            operationList.add(builder.build());
        }
    }
    if (mPhoneList != null) {
        for (PhoneData phoneData : mPhoneList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Phone.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
            builder.withValue(Phone.TYPE, phoneData.type);
            if (phoneData.type == Phone.TYPE_CUSTOM) {
                builder.withValue(Phone.LABEL, phoneData.label);
            }
            builder.withValue(Phone.NUMBER, phoneData.data);
            if (phoneData.isPrimary) {
                builder.withValue(Phone.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mOrganizationList != null) {
        for (OrganizationData organizationData : mOrganizationList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Organization.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Organization.CONTENT_ITEM_TYPE);
            builder.withValue(Organization.TYPE, organizationData.type);
            if (organizationData.companyName != null) {
                builder.withValue(Organization.COMPANY, organizationData.companyName);
            }
            if (organizationData.departmentName != null) {
                builder.withValue(Organization.DEPARTMENT, organizationData.departmentName);
            }
            if (organizationData.titleName != null) {
                builder.withValue(Organization.TITLE, organizationData.titleName);
            }
            if (organizationData.isPrimary) {
                builder.withValue(Organization.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mEmailList != null) {
        for (EmailData emailData : mEmailList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Email.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE);
            builder.withValue(Email.TYPE, emailData.type);
            if (emailData.type == Email.TYPE_CUSTOM) {
                builder.withValue(Email.LABEL, emailData.label);
            }
            builder.withValue(Email.DATA, emailData.data);
            if (emailData.isPrimary) {
                builder.withValue(Data.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mPostalList != null) {
        for (PostalData postalData : mPostalList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            VCardUtils.insertStructuredPostalDataUsingContactsStruct(mVCardType, builder, postalData);
            operationList.add(builder.build());
        }
    }
    if (mImList != null) {
        for (ImData imData : mImList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Im.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Im.CONTENT_ITEM_TYPE);
            builder.withValue(Im.TYPE, imData.type);
            builder.withValue(Im.PROTOCOL, imData.protocol);
            if (imData.protocol == Im.PROTOCOL_CUSTOM) {
                builder.withValue(Im.CUSTOM_PROTOCOL, imData.customProtocol);
            }
            if (imData.isPrimary) {
                builder.withValue(Data.IS_PRIMARY, 1);
            }
        }
    }
    if (mNoteList != null) {
        for (String note : mNoteList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Note.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Note.CONTENT_ITEM_TYPE);
            builder.withValue(Note.NOTE, note);
            operationList.add(builder.build());
        }
    }
    if (mPhotoList != null) {
        for (PhotoData photoData : mPhotoList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Photo.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Photo.CONTENT_ITEM_TYPE);
            builder.withValue(Photo.PHOTO, photoData.photoBytes);
            if (photoData.isPrimary) {
                builder.withValue(Photo.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mWebsiteList != null) {
        for (String website : mWebsiteList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Website.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Website.CONTENT_ITEM_TYPE);
            builder.withValue(Website.URL, website);
            // There's no information about the type of URL in vCard.
            // We use TYPE_HOMEPAGE for safety.
            builder.withValue(Website.TYPE, Website.TYPE_HOMEPAGE);
            operationList.add(builder.build());
        }
    }
    if (!TextUtils.isEmpty(mBirthday)) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(Event.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, Event.CONTENT_ITEM_TYPE);
        builder.withValue(Event.START_DATE, mBirthday);
        builder.withValue(Event.TYPE, Event.TYPE_BIRTHDAY);
        operationList.add(builder.build());
    }
    if (mAndroidCustomPropertyList != null) {
        for (List<String> customPropertyList : mAndroidCustomPropertyList) {
            int size = customPropertyList.size();
            if (size < 2 || TextUtils.isEmpty(customPropertyList.get(0))) {
                continue;
            } else if (size > VCardConstants.MAX_DATA_COLUMN + 1) {
                size = VCardConstants.MAX_DATA_COLUMN + 1;
                customPropertyList = customPropertyList.subList(0, VCardConstants.MAX_DATA_COLUMN + 2);
            }
            int i = 0;
            for (final String customPropertyValue : customPropertyList) {
                if (i == 0) {
                    final String mimeType = customPropertyValue;
                    builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
                    builder.withValueBackReference(GroupMembership.RAW_CONTACT_ID, 0);
                    builder.withValue(Data.MIMETYPE, mimeType);
                } else {
                    // 1 <= i && i <= MAX_DATA_COLUMNS
                    if (!TextUtils.isEmpty(customPropertyValue)) {
                        builder.withValue(""data"" + i, customPropertyValue);
                    }
                }
                i++;
            }
            operationList.add(builder.build());
        }
    }
    if (myGroupsId != null) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(GroupMembership.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, GroupMembership.CONTENT_ITEM_TYPE);
        builder.withValue(GroupMembership.GROUP_SOURCE_ID, myGroupsId);
        operationList.add(builder.build());
    }
    try {
        ContentProviderResult[] results = resolver.applyBatch(ContactsContract.AUTHORITY, operationList);
        // ContentResolvers
        return (results == null || results.length == 0 || results[0] == null) ? null : results[0].uri;
    } catch (RemoteException e) {
        Log.e(LOG_TAG, String.format(""%s: %s"", e.toString(), e.getMessage()));
        return null;
    } catch (OperationApplicationException e) {
        Log.e(LOG_TAG, String.format(""%s: %s"", e.toString(), e.getMessage()));
        return null;
    }
}","{
    ArrayList<ContentProviderOperation> operationList = new ArrayList<ContentProviderOperation>();
    // After applying the batch the first result's Uri is returned so it is important that
    // the RawContact is the first operation that gets inserted into the list
    ContentProviderOperation.Builder builder = ContentProviderOperation.newInsert(RawContacts.CONTENT_URI);
    String myGroupsId = null;
    if (mAccount != null) {
        builder.withValue(RawContacts.ACCOUNT_NAME, mAccount.name);
        builder.withValue(RawContacts.ACCOUNT_TYPE, mAccount.type);
        // Assume that caller side creates this group if it does not exist.
        if (ACCOUNT_TYPE_GOOGLE.equals(mAccount.type)) {
            final Cursor cursor = resolver.query(Groups.CONTENT_URI, new String[] { Groups.SOURCE_ID }, Groups.TITLE + ""=?"", new String[] { GOOGLE_MY_CONTACTS_GROUP }, null);
            try {
                if (cursor != null && cursor.moveToFirst()) {
                    myGroupsId = cursor.getString(0);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
        }
    } else {
        builder.withValue(RawContacts.ACCOUNT_NAME, null);
        builder.withValue(RawContacts.ACCOUNT_TYPE, null);
    }
    operationList.add(builder.build());
    if (!nameFieldsAreEmpty()) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(StructuredName.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
        builder.withValue(StructuredName.GIVEN_NAME, mGivenName);
        builder.withValue(StructuredName.FAMILY_NAME, mFamilyName);
        builder.withValue(StructuredName.MIDDLE_NAME, mMiddleName);
        builder.withValue(StructuredName.PREFIX, mPrefix);
        builder.withValue(StructuredName.SUFFIX, mSuffix);
        if (!(TextUtils.isEmpty(mPhoneticGivenName) && TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName))) {
            builder.withValue(StructuredName.PHONETIC_GIVEN_NAME, mPhoneticGivenName);
            builder.withValue(StructuredName.PHONETIC_FAMILY_NAME, mPhoneticFamilyName);
            builder.withValue(StructuredName.PHONETIC_MIDDLE_NAME, mPhoneticMiddleName);
        } else if (!TextUtils.isEmpty(mPhoneticFullName)) {
            builder.withValue(StructuredName.PHONETIC_GIVEN_NAME, mPhoneticFullName);
        }
        builder.withValue(StructuredName.DISPLAY_NAME, getDisplayName());
        operationList.add(builder.build());
    }
    if (mNickNameList != null && mNickNameList.size() > 0) {
        for (String nickName : mNickNameList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Nickname.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Nickname.CONTENT_ITEM_TYPE);
            builder.withValue(Nickname.TYPE, Nickname.TYPE_DEFAULT);
            builder.withValue(Nickname.NAME, nickName);
            operationList.add(builder.build());
        }
    }
    if (mPhoneList != null) {
        for (PhoneData phoneData : mPhoneList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Phone.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Phone.CONTENT_ITEM_TYPE);
            builder.withValue(Phone.TYPE, phoneData.type);
            if (phoneData.type == Phone.TYPE_CUSTOM) {
                builder.withValue(Phone.LABEL, phoneData.label);
            }
            builder.withValue(Phone.NUMBER, phoneData.data);
            if (phoneData.isPrimary) {
                builder.withValue(Phone.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mOrganizationList != null) {
        for (OrganizationData organizationData : mOrganizationList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Organization.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Organization.CONTENT_ITEM_TYPE);
            builder.withValue(Organization.TYPE, organizationData.type);
            if (organizationData.companyName != null) {
                builder.withValue(Organization.COMPANY, organizationData.companyName);
            }
            if (organizationData.departmentName != null) {
                builder.withValue(Organization.DEPARTMENT, organizationData.departmentName);
            }
            if (organizationData.titleName != null) {
                builder.withValue(Organization.TITLE, organizationData.titleName);
            }
            if (organizationData.phoneticName != null) {
                builder.withValue(Organization.PHONETIC_NAME, organizationData.phoneticName);
            }
            if (organizationData.isPrimary) {
                builder.withValue(Organization.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mEmailList != null) {
        for (EmailData emailData : mEmailList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Email.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Email.CONTENT_ITEM_TYPE);
            builder.withValue(Email.TYPE, emailData.type);
            if (emailData.type == Email.TYPE_CUSTOM) {
                builder.withValue(Email.LABEL, emailData.label);
            }
            builder.withValue(Email.DATA, emailData.data);
            if (emailData.isPrimary) {
                builder.withValue(Data.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mPostalList != null) {
        for (PostalData postalData : mPostalList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            VCardUtils.insertStructuredPostalDataUsingContactsStruct(mVCardType, builder, postalData);
            operationList.add(builder.build());
        }
    }
    if (mImList != null) {
        for (ImData imData : mImList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Im.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Im.CONTENT_ITEM_TYPE);
            builder.withValue(Im.TYPE, imData.type);
            builder.withValue(Im.PROTOCOL, imData.protocol);
            builder.withValue(Im.DATA, imData.data);
            if (imData.protocol == Im.PROTOCOL_CUSTOM) {
                builder.withValue(Im.CUSTOM_PROTOCOL, imData.customProtocol);
            }
            if (imData.isPrimary) {
                builder.withValue(Data.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mNoteList != null) {
        for (String note : mNoteList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Note.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Note.CONTENT_ITEM_TYPE);
            builder.withValue(Note.NOTE, note);
            operationList.add(builder.build());
        }
    }
    if (mPhotoList != null) {
        for (PhotoData photoData : mPhotoList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Photo.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Photo.CONTENT_ITEM_TYPE);
            builder.withValue(Photo.PHOTO, photoData.photoBytes);
            if (photoData.isPrimary) {
                builder.withValue(Photo.IS_PRIMARY, 1);
            }
            operationList.add(builder.build());
        }
    }
    if (mWebsiteList != null) {
        for (String website : mWebsiteList) {
            builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
            builder.withValueBackReference(Website.RAW_CONTACT_ID, 0);
            builder.withValue(Data.MIMETYPE, Website.CONTENT_ITEM_TYPE);
            builder.withValue(Website.URL, website);
            // There's no information about the type of URL in vCard.
            // We use TYPE_HOMEPAGE for safety.
            builder.withValue(Website.TYPE, Website.TYPE_HOMEPAGE);
            operationList.add(builder.build());
        }
    }
    if (!TextUtils.isEmpty(mBirthday)) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(Event.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, Event.CONTENT_ITEM_TYPE);
        builder.withValue(Event.START_DATE, mBirthday);
        builder.withValue(Event.TYPE, Event.TYPE_BIRTHDAY);
        operationList.add(builder.build());
    }
    if (!TextUtils.isEmpty(mAnniversary)) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(Event.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, Event.CONTENT_ITEM_TYPE);
        builder.withValue(Event.START_DATE, mAnniversary);
        builder.withValue(Event.TYPE, Event.TYPE_ANNIVERSARY);
        operationList.add(builder.build());
    }
    if (mAndroidCustomPropertyList != null) {
        for (List<String> customPropertyList : mAndroidCustomPropertyList) {
            int size = customPropertyList.size();
            if (size < 2 || TextUtils.isEmpty(customPropertyList.get(0))) {
                continue;
            } else if (size > VCardConstants.MAX_DATA_COLUMN + 1) {
                size = VCardConstants.MAX_DATA_COLUMN + 1;
                customPropertyList = customPropertyList.subList(0, VCardConstants.MAX_DATA_COLUMN + 2);
            }
            int i = 0;
            for (final String customPropertyValue : customPropertyList) {
                if (i == 0) {
                    final String mimeType = customPropertyValue;
                    builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
                    builder.withValueBackReference(GroupMembership.RAW_CONTACT_ID, 0);
                    builder.withValue(Data.MIMETYPE, mimeType);
                } else {
                    // 1 <= i && i <= MAX_DATA_COLUMNS
                    if (!TextUtils.isEmpty(customPropertyValue)) {
                        builder.withValue(""data"" + i, customPropertyValue);
                    }
                }
                i++;
            }
            operationList.add(builder.build());
        }
    }
    if (myGroupsId != null) {
        builder = ContentProviderOperation.newInsert(Data.CONTENT_URI);
        builder.withValueBackReference(GroupMembership.RAW_CONTACT_ID, 0);
        builder.withValue(Data.MIMETYPE, GroupMembership.CONTENT_ITEM_TYPE);
        builder.withValue(GroupMembership.GROUP_SOURCE_ID, myGroupsId);
        operationList.add(builder.build());
    }
    try {
        ContentProviderResult[] results = resolver.applyBatch(ContactsContract.AUTHORITY, operationList);
        // ContentResolvers
        return (results == null || results.length == 0 || results[0] == null) ? null : results[0].uri;
    } catch (RemoteException e) {
        Log.e(LOG_TAG, String.format(""%s: %s"", e.toString(), e.getMessage()));
        return null;
    } catch (OperationApplicationException e) {
        Log.e(LOG_TAG, String.format(""%s: %s"", e.toString(), e.getMessage()));
        return null;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
9,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,8,9,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,<android.server.BluetoothA2dpService: boolean connectSink(BluetoothDevice)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""connectSink("" + device + "")"");
    if (!mBluetoothService.isEnabled())
        return false;
    // ignore if there are any active sinks
    if (lookupSinksMatchingStates(new int[] { BluetoothA2dp.STATE_CONNECTING, BluetoothA2dp.STATE_CONNECTED, BluetoothA2dp.STATE_PLAYING, BluetoothA2dp.STATE_DISCONNECTING }).size() != 0) {
        return false;
    }
    if (mAudioDevices.get(device) == null && !addAudioSink(device))
        return false;
    int state = mAudioDevices.get(device);
    switch(state) {
        case BluetoothA2dp.STATE_CONNECTED:
        case BluetoothA2dp.STATE_PLAYING:
        case BluetoothA2dp.STATE_DISCONNECTING:
            return false;
        case BluetoothA2dp.STATE_CONNECTING:
            return true;
    }
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null)
        return false;
    // State is DISCONNECTED
    handleSinkStateChange(device, state, BluetoothA2dp.STATE_CONNECTING);
    if (!connectSinkNative(path)) {
        // Restore previous state
        handleSinkStateChange(device, mAudioDevices.get(device), state);
        return false;
    }
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""connectSink("" + device + "")"");
    if (!isConnectSinkFeasible(device))
        return false;
    return mBluetoothService.connectSink(device.getAddress());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The code change involves a significant rewrite of the method where `isConnectSinkFeasible(device)` and `mBluetoothService.connectSink(device.getAddress())` replace multiple statements, which include several return statements and condition checks. Thus, the code change types are 1 (return statements have been modified) and 5 (a new dependent API `isConnectSinkFeasible(device)` and `mBluetoothService.connectSink(device.getAddress())` are introduced).","These changes indicate that the API might return different values. The existence, conditions, and results of multiple return statements in the early version implementation were different from those in the later version, which means potential different outputs or behaviours could be expected, leading to a compatibility issue type 1."
11,<android.os.Parcel: void writeException(Exception)>,8,9,<android.os.Parcel: void writeException(Exception)>,<android.os.Parcel: void writeException(Exception)>,0,"{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    }
    writeInt(code);
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}","{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}",1,"/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
","/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",2,"The code change is as follows: a new statement 'StrictMode.clearGatheredViolations();' is added. On the other hand, the implementation now relies on another method namely 'clearGatheredViolations()' of StrictMode class, so the code change types are 4,5.","The new statement 'StrictMode.clearGatheredViolations();' clears any violations previously gathered by StrictMode. As a result, if the application had previously triggered any violations, these would no longer be present if an exception occurs within this method. Therefore, the change could potentially leads to a different exception handling, which is a compatibility issue of type 2."
12,<android.webkit.WebView: void emulateShiftHeld()>,8,9,<android.webkit.WebView: void emulateShiftHeld()>,<android.webkit.WebView: void emulateShiftHeld()>,0,"{
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    setUpSelectXY();
}","{
    setUpSelect();
}",1,"/**
 * Use this method to put the WebView into text selection mode.
 * Do not rely on this functionality; it will be deprecated in the future.
 */
","/**
 * Use this method to put the WebView into text selection mode.
 * Do not rely on this functionality; it will be deprecated in the future.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4 ",1,"The statements (if statement and its contents, and the invocation of setUpSelectXY() ) removed, and a new statement invoking an entirely different method setUpSelect(), so the code change type is 1,4.","The change of implementation might lead to an entirely different behavior and potential different return situation of the API, thus the CI type is 1."
13,<android.bluetooth.BluetoothAdapter: int getScanMode()>,8,9,<android.bluetooth.BluetoothAdapter: int getScanMode()>,<android.bluetooth.BluetoothAdapter: int getScanMode()>,0,"{
    try {
        return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return SCAN_MODE_NONE;
}","{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return SCAN_MODE_NONE;
}",1,"/**
 * Get the current Bluetooth scan mode of the local Bluetooth adaper.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
","/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new control statement (if (getState() != STATE_ON) return SCAN_MODE_NONE;) has been introduced, so the type of code change is 3.","Because of the new control statement, in the late version, the method can return SCAN_MODE_NONE earlier than in the early version. Thus there exists a compatibility issue of type 1, potential different return values."
14,<android.view.MotionEvent: float getHistoricalPressure(int)>,8,9,<android.view.MotionEvent: float getHistoricalPressure(int)>,<android.view.MotionEvent: float getHistoricalPressure(int)>,0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_PRESSURE];
}","{
    return mDataSamples[pos * mNumPointers * NUM_SAMPLE_DATA + SAMPLE_PRESSURE];
}",1,"/**
 * {@link #getHistoricalPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getHistoricalPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The index calculation rule of array mDataSamples changes, which is categorized as 'other statement changed', so the code change type is 4.","Given the change in the index calculation of the array mDataSamples, the value returned by the method getHistoricalPressure(int) may not be the same between the two versions. Therefore, it may lead to a potential Compatibility Issue with type 1."
15,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>",8,9,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = 0;
    ev.mEdgeFlags = 0;
    ev.mDownTime = downTime;
    ev.mEventTimeNano = eventTime * 1000000;
    ev.mAction = action;
    ev.mNumPointers = 1;
    ev.mMetaState = metaState;
    ev.mXPrecision = 1.0f;
    ev.mYPrecision = 1.0f;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    int[] pointerIds = ev.mPointerIdentifiers;
    pointerIds[0] = 0;
    float[] data = ev.mDataSamples;
    data[SAMPLE_X] = ev.mRawX = x;
    data[SAMPLE_Y] = ev.mRawY = y;
    data[SAMPLE_PRESSURE] = 1.0f;
    data[SAMPLE_SIZE] = 1.0f;
    ev.mTimeSamples[0] = eventTime;
    return ev;
}","{
    return obtain(downTime, eventTime, action, x, y, 1.0f, 1.0f, metaState, 1.0f, 1.0f, 0, 0);
}",1,"/**
 * Create a new MotionEvent, filling in a subset of the basic motion
 * values.  Those not specified here are: device id (always 0), pressure
 * and size (always 1), x and y precision (always 1), and edgeFlags (always 0).
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 */
","/**
 * Create a new MotionEvent, filling in a subset of the basic motion
 * values.  Those not specified here are: device id (always 0), pressure
 * and size (always 1), x and y precision (always 1), and edgeFlags (always 0).
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method of getting a MotionEvent instance has changed from a multiple-step manual setting to using a oneline 'obtain()' method, categorized as return statement change (1) and dependent API change (5).","The new version directly creates a MotionEvent instance by using the 'obtain()' method with parameters, which changes the return statement and might produce a different MotionEvent object. Hence there is a Compatibility Issue due to potentially different return values (1)."
17,<android.view.MotionEvent: float getHistoricalX(int)>,8,9,<android.view.MotionEvent: float getHistoricalX(int)>,<android.view.MotionEvent: float getHistoricalX(int)>,0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_X];
}","{
    return mDataSamples[pos * mNumPointers * NUM_SAMPLE_DATA + SAMPLE_X] + mXOffset;
}",1,"/**
 * {@link #getHistoricalX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getHistoricalX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed. The formula used to derive return value is altered which might render a different return value, so the code change type is 1.","As the return statement has been modified and this could lead to a potential change in the value that the function returns, the CI type is 1."
19,<android.pim.vcard.VCardEntryConstructor: void clear()>,8,9,<android.pim.vcard.VCardEntryConstructor: void clear()>,<android.pim.vcard.VCardEntryConstructor: void clear()>,0,"{
    mCurrentContactStruct = null;
    mCurrentProperty = new VCardEntry.Property();
}","{
    mCurrentVCardEntry = null;
    mCurrentProperty = new VCardEntry.Property();
}",1,"/**
 * Called when the parse failed between {@link #startEntry()} and {@link #endEntry()}.
 */
",,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The statement 'mCurrentContactStruct = null;' in the early version has been replaced by 'mCurrentVCardEntry = null;' in the late version, so the code change type is 4.","Since a different variable is set to null in the later version, the behavior of any subsequent function calls dependent on the state of the variable will differ, thus potentially leading to compatibility issues of type 1."
20,"<android.os.Vibrator: void vibrate(long[],int)>",8,9,"<android.os.Vibrator: void vibrate(long[],int)>","<android.os.Vibrator: void vibrate(long[],int)>",0,"{
    // anyway
    if (repeat < pattern.length) {
        try {
            mService.vibratePattern(pattern, repeat, mToken);
        } catch (RemoteException e) {
        }
    } else {
        throw new ArrayIndexOutOfBoundsException();
    }
}","{
    if (mService == null) {
        Log.w(TAG, ""Failed to vibrate; no vibrator service."");
        return;
    }
    // anyway
    if (repeat < pattern.length) {
        try {
            mService.vibratePattern(pattern, repeat, mToken);
        } catch (RemoteException e) {
            Log.w(TAG, ""Failed to vibrate."", e);
        }
    } else {
        throw new ArrayIndexOutOfBoundsException();
    }
}",1,"/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the times at which to turn on or off
 * the vibrator.  The first one is how long to wait before turning it on,
 * and then after that it alternates.  If you want to repeat, pass the
 * index into the pattern at which to start the repeat.
 *
 * @param pattern an array of longs of times to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 */
","/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the times at which to turn on or off
 * the vibrator.  The first one is how long to wait before turning it on,
 * and then after that it alternates.  If you want to repeat, pass the
 * index into the pattern at which to start the repeat.
 *
 * @param pattern an array of longs of times to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,2,3","1,2","In the late version, a new if statement to check if mService is null and a corresponding return statement have been added. Additionally, there is a change in exception handling as a new log statement has been introduced within the catch block. Therefore, the code change type is 1,2 and 3.","The introduction of the new if statement can cause a different return behavior when mService is null, leading to compatibility issue Type 1. Type 2 of compatibility issue also exists because the new log statement in the catch block can lead to different behavior during exception handling."
21,<android.webkit.WebView: int computeHorizontalScrollRange()>,8,9,<android.webkit.WebView: int computeHorizontalScrollRange()>,<android.webkit.WebView: int computeHorizontalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryWidth;
    } else if (mHorizontalScrollBarMode == SCROLLBAR_ALWAYSOFF && (mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT)) {
        // only honor the scrollbar mode when it is at minimum zoom level
        return computeHorizontalScrollExtent();
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentWidth * mActualScale);
    }
}","{
    int range = computeRealHorizontalScrollRange();
    // Adjust reported range if overscrolled to compress the scroll bars
    final int scrollX = mScrollX;
    final int overscrollRight = computeMaxScrollX();
    if (scrollX < 0) {
        range -= scrollX;
    } else if (scrollX > overscrollRight) {
        range += scrollX - overscrollRight;
    }
    return range;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"There is a significant change in the return statements as well as their conditions. The method in late version has a completely different structure compared to the one in early version hence Change Type is 1,3.","The return statement has completely changed. In early version, it had different return type under different conditions while in late version, the value is being calculated based on some conditions. So the value of result could potentially be different leading to CI Type 1."
22,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,8,9,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mActivePointerId = ev.getPointerId(0);
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                int motionPosition = pointToPosition(x, y);
                if (!mDataChanged) {
                    if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                        // User clicked on an actual view (and was not stopping a fling). It might be a
                        // click or a scroll. Assume it is a click until proven otherwise
                        mTouchMode = TOUCH_MODE_DOWN;
                        // FIXME Debounce
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                            // code in ViewRoot to try to find a nearby view to select
                            return false;
                        }
                        if (mTouchMode == TOUCH_MODE_FLING) {
                            // Stopped a fling. It is a scroll.
                            createScrollingCache();
                            mTouchMode = TOUCH_MODE_SCROLL;
                            mMotionCorrection = 0;
                            motionPosition = findMotionRow(y);
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                        }
                    }
                }
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                }
                mMotionX = x;
                mMotionY = y;
                mMotionPosition = motionPosition;
                mLastY = Integer.MIN_VALUE;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                final int y = (int) ev.getY(pointerIndex);
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            // No need to do all this work if we're not going to move anyway
                            boolean atEdge = false;
                            if (incrementalDeltaY != 0) {
                                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            if (atEdge && getChildCount() > 0) {
                                // Treat this like we're starting a new scroll from the current
                                // position. This will let the user start scrolling back into
                                // content immediately rather than needing to scroll back to the
                                // point where they hit the limit first.
                                int motionPosition = findMotionRow(y);
                                if (motionPosition >= 0) {
                                    final View motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                }
                                mMotionY = y;
                                mMotionPosition = motionPosition;
                                invalidate();
                            }
                            mLastY = y;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                post(performClick);
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                                if (Math.abs(initialVelocity) > mMinimumVelocity) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                }
                setPressed(false);
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                mTouchMode = TOUCH_MODE_REST;
                setPressed(false);
                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                if (motionView != null) {
                    motionView.setPressed(false);
                }
                clearScrollingCache();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling). It might be a
                                    // click or a scroll. Assume it is a click until proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                                        // code in ViewRoot to try to find a nearby view to select
                                        return false;
                                    }
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                final int y = (int) ev.getY(pointerIndex);
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (y != mLastY) {
                            // Make sure that we do so in case we're in a parent that can intercept.
                            if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
                                requestDisallowInterceptTouchEvent(true);
                            }
                            final int rawDeltaY = deltaY;
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            final int motionIndex;
                            if (mMotionPosition >= 0) {
                                motionIndex = mMotionPosition - mFirstPosition;
                            } else {
                                // If we don't have a motion position that we can reliably track,
                                // pick something in the middle to make a best guess at things below.
                                motionIndex = getChildCount() / 2;
                            }
                            int motionViewPrevTop = 0;
                            View motionView = this.getChildAt(motionIndex);
                            if (motionView != null) {
                                motionViewPrevTop = motionView.getTop();
                            }
                            // No need to do all this work if we're not going to move anyway
                            boolean atEdge = false;
                            if (incrementalDeltaY != 0) {
                                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            motionView = this.getChildAt(motionIndex);
                            if (motionView != null) {
                                // Check if the top of the motion view is where it is
                                // supposed to be
                                final int motionViewRealTop = motionView.getTop();
                                if (atEdge) {
                                    // Apply overscroll
                                    int overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
                                    overScrollBy(0, overscroll, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true);
                                    if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
                                        // Don't allow overfling if we're at the edge.
                                        mVelocityTracker.clear();
                                    }
                                    final int overscrollMode = getOverScrollMode();
                                    if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
                                        // Reset when entering overscroll.
                                        mDirection = 0;
                                        mTouchMode = TOUCH_MODE_OVERSCROLL;
                                        if (rawDeltaY > 0) {
                                            mEdgeGlowTop.onPull((float) overscroll / getHeight());
                                            if (!mEdgeGlowBottom.isFinished()) {
                                                mEdgeGlowBottom.onRelease();
                                            }
                                        } else if (rawDeltaY < 0) {
                                            mEdgeGlowBottom.onPull((float) overscroll / getHeight());
                                            if (!mEdgeGlowTop.isFinished()) {
                                                mEdgeGlowTop.onRelease();
                                            }
                                        }
                                    }
                                }
                                mMotionY = y;
                                invalidate();
                            }
                            mLastY = y;
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (y != mLastY) {
                            final int rawDeltaY = deltaY;
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            final int oldScroll = mScrollY;
                            final int newScroll = oldScroll - incrementalDeltaY;
                            int newDirection = y > mLastY ? 1 : -1;
                            if (mDirection == 0) {
                                mDirection = newDirection;
                            }
                            if (mDirection != newDirection) {
                                // Coming back to 'real' list scrolling
                                incrementalDeltaY = -newScroll;
                                mScrollY = 0;
                                // No need to do all this work if we're not going to move anyway
                                if (incrementalDeltaY != 0) {
                                    trackMotionScroll(incrementalDeltaY, incrementalDeltaY);
                                }
                                // Check to see if we are back in
                                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                                if (motionView != null) {
                                    mTouchMode = TOUCH_MODE_SCROLL;
                                    // We did not scroll the full amount. Treat this essentially like the
                                    // start of a new touch scroll
                                    final int motionPosition = findClosestMotionRow(y);
                                    mMotionCorrection = 0;
                                    motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                    mMotionY = y;
                                    mMotionPosition = motionPosition;
                                }
                            } else {
                                overScrollBy(0, -incrementalDeltaY, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true);
                                final int overscrollMode = getOverScrollMode();
                                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
                                    if (rawDeltaY > 0) {
                                        mEdgeGlowTop.onPull((float) -incrementalDeltaY / getHeight());
                                        if (!mEdgeGlowBottom.isFinished()) {
                                            mEdgeGlowBottom.onRelease();
                                        }
                                    } else if (rawDeltaY < 0) {
                                        mEdgeGlowBottom.onPull((float) -incrementalDeltaY / getHeight());
                                        if (!mEdgeGlowTop.isFinished()) {
                                            mEdgeGlowTop.onRelease();
                                        }
                                    }
                                    invalidate();
                                }
                                if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
                                    // Don't allow overfling if we're at the edge.
                                    mVelocityTracker.clear();
                                }
                            }
                            mLastY = y;
                            mDirection = newDirection;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mChild = child;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    postDelayed(new Runnable() {

                                        public void run() {
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                post(performClick);
                                            }
                                            mTouchMode = TOUCH_MODE_REST;
                                        }
                                    }, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                post(performClick);
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        if (mVelocityTracker != null) {
                            mVelocityTracker.recycle();
                            mVelocityTracker = null;
                        }
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
23,<android.os.PowerManager.WakeLock: void acquire()>,8,9,<android.os.PowerManager.WakeLock: void acquire()>,<android.os.PowerManager.WakeLock: void acquire()>,0,"{
    synchronized (mToken) {
        if (!mRefCounted || mCount++ == 0) {
            try {
                mService.acquireWakeLock(mFlags, mToken, mTag);
            } catch (RemoteException e) {
            }
            mHeld = true;
        }
    }
}","{
    synchronized (mToken) {
        if (!mRefCounted || mCount++ == 0) {
            try {
                mService.acquireWakeLock(mFlags, mToken, mTag, mWorkSource);
            } catch (RemoteException e) {
            }
            mHeld = true;
        }
    }
}",1,"/**
 * Makes sure the device is on at the level you asked when you created
 * the wake lock.
 */
","/**
 * Makes sure the device is on at the level you asked when you created
 * the wake lock.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,The dependent API mService.acquireWakeLock method has undergone a change - an extra parameter 'mWorkSource' is introduced in the late version's implementation; this is categorized under change type 5.,"As the dependent API has changed, it may lead to different return behaviors under certain circumstances. This introduces the possibility of the code returning differently than the previous version. Thus, there is a compatibility issue of type 1."
24,<com.google.android.mms.pdu.PduParser: PduHeaders parseHeaders(ByteArrayInputStream)>,8,9,<com.google.android.mms.pdu.PduParser: PduHeaders parseHeaders(ByteArrayInputStream)>,<com.google.android.mms.pdu.PduParser: PduHeaders parseHeaders(ByteArrayInputStream)>,0,"{
    if (pduDataStream == null) {
        return null;
    }
    boolean keepParsing = true;
    PduHeaders headers = new PduHeaders();
    while (keepParsing && (pduDataStream.available() > 0)) {
        int headerField = extractByteValue(pduDataStream);
        switch(headerField) {
            case PduHeaders.MESSAGE_TYPE:
                {
                    int messageType = extractByteValue(pduDataStream);
                    switch(messageType) {
                        // We don't support these kind of messages now.
                        case PduHeaders.MESSAGE_TYPE_FORWARD_REQ:
                        case PduHeaders.MESSAGE_TYPE_FORWARD_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DESCR:
                        case PduHeaders.MESSAGE_TYPE_DELETE_REQ:
                        case PduHeaders.MESSAGE_TYPE_DELETE_CONF:
                        case PduHeaders.MESSAGE_TYPE_CANCEL_REQ:
                        case PduHeaders.MESSAGE_TYPE_CANCEL_CONF:
                            return null;
                    }
                    try {
                        headers.setOctet(messageType, headerField);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + messageType + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            /* Octect value */
            case PduHeaders.REPORT_ALLOWED:
            case PduHeaders.ADAPTATION_ALLOWED:
            case PduHeaders.DELIVERY_REPORT:
            case PduHeaders.DRM_CONTENT:
            case PduHeaders.DISTRIBUTION_INDICATOR:
            case PduHeaders.QUOTAS:
            case PduHeaders.READ_REPORT:
            case PduHeaders.STORE:
            case PduHeaders.STORED:
            case PduHeaders.TOTALS:
            case PduHeaders.SENDER_VISIBILITY:
            case PduHeaders.READ_STATUS:
            case PduHeaders.CANCEL_STATUS:
            case PduHeaders.PRIORITY:
            case PduHeaders.STATUS:
            case PduHeaders.REPLY_CHARGING:
            case PduHeaders.MM_STATE:
            case PduHeaders.RECOMMENDED_RETRIEVAL_MODE:
            case PduHeaders.CONTENT_CLASS:
            case PduHeaders.RETRIEVE_STATUS:
            case PduHeaders.STORE_STATUS:
            /**
             * The following field has a different value when
             * used in the M-Mbox-Delete.conf and M-Delete.conf PDU.
             * For now we ignore this fact, since we do not support these PDUs
             */
            case PduHeaders.RESPONSE_STATUS:
                {
                    int value = extractByteValue(pduDataStream);
                    try {
                        headers.setOctet(value, headerField);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + value + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            /* Long-Integer */
            case PduHeaders.DATE:
            case PduHeaders.REPLY_CHARGING_SIZE:
            case PduHeaders.MESSAGE_SIZE:
                {
                    try {
                        long value = parseLongInteger(pduDataStream);
                        headers.setLongInteger(value, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            /* Integer-Value */
            case PduHeaders.MESSAGE_COUNT:
            case PduHeaders.START:
            case PduHeaders.LIMIT:
                {
                    try {
                        long value = parseIntegerValue(pduDataStream);
                        headers.setLongInteger(value, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            /* Text-String */
            case PduHeaders.TRANSACTION_ID:
            case PduHeaders.REPLY_CHARGING_ID:
            case PduHeaders.AUX_APPLIC_ID:
            case PduHeaders.APPLIC_ID:
            case PduHeaders.REPLY_APPLIC_ID:
            /**
             * The next three header fields are email addresses
             * as defined in RFC2822,
             * not including the characters ""<"" and "">""
             */
            case PduHeaders.MESSAGE_ID:
            case PduHeaders.REPLACE_ID:
            case PduHeaders.CANCEL_ID:
            /**
             * The following field has a different value when
             * used in the M-Mbox-Delete.conf and M-Delete.conf PDU.
             * For now we ignore this fact, since we do not support these PDUs
             */
            case PduHeaders.CONTENT_LOCATION:
                {
                    byte[] value = parseWapString(pduDataStream, TYPE_TEXT_STRING);
                    if (null != value) {
                        try {
                            headers.setTextString(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Encoded-string-value */
            case PduHeaders.SUBJECT:
            case PduHeaders.RECOMMENDED_RETRIEVAL_MODE_TEXT:
            case PduHeaders.RETRIEVE_TEXT:
            case PduHeaders.STATUS_TEXT:
            case PduHeaders.STORE_STATUS_TEXT:
            /* the next one is not support
                     * M-Mbox-Delete.conf and M-Delete.conf now */
            case PduHeaders.RESPONSE_TEXT:
                {
                    EncodedStringValue value = parseEncodedStringValue(pduDataStream);
                    if (null != value) {
                        try {
                            headers.setEncodedStringValue(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Addressing model */
            case PduHeaders.BCC:
            case PduHeaders.CC:
            case PduHeaders.TO:
                {
                    EncodedStringValue value = parseEncodedStringValue(pduDataStream);
                    if (null != value) {
                        byte[] address = value.getTextString();
                        if (null != address) {
                            String str = new String(address);
                            int endIndex = str.indexOf(""/"");
                            if (endIndex > 0) {
                                str = str.substring(0, endIndex);
                            }
                            try {
                                value.setTextString(str.getBytes());
                            } catch (NullPointerException e) {
                                log(""null pointer error!"");
                                return null;
                            }
                        }
                        try {
                            headers.appendEncodedStringValue(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Value-length
                 * (Absolute-token Date-value | Relative-token Delta-seconds-value) */
            case PduHeaders.DELIVERY_TIME:
            case PduHeaders.EXPIRY:
            case PduHeaders.REPLY_CHARGING_DEADLINE:
                {
                    /* parse Value-length */
                    parseValueLength(pduDataStream);
                    /* Absolute-token or Relative-token */
                    int token = extractByteValue(pduDataStream);
                    /* Date-value or Delta-seconds-value */
                    long timeValue;
                    try {
                        timeValue = parseLongInteger(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    if (PduHeaders.VALUE_RELATIVE_TOKEN == token) {
                        /* need to convert the Delta-seconds-value
                         * into Date-value */
                        timeValue = System.currentTimeMillis() / 1000 + timeValue;
                    }
                    try {
                        headers.setLongInteger(timeValue, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.FROM:
                {
                    /* From-value =
                     * Value-length
                     * (Address-present-token Encoded-string-value | Insert-address-token)
                     */
                    EncodedStringValue from = null;
                    parseValueLength(pduDataStream);
                    /* parse value-length */
                    /* Address-present-token or Insert-address-token */
                    int fromToken = extractByteValue(pduDataStream);
                    /* Address-present-token or Insert-address-token */
                    if (PduHeaders.FROM_ADDRESS_PRESENT_TOKEN == fromToken) {
                        /* Encoded-string-value */
                        from = parseEncodedStringValue(pduDataStream);
                        if (null != from) {
                            byte[] address = from.getTextString();
                            if (null != address) {
                                String str = new String(address);
                                int endIndex = str.indexOf(""/"");
                                if (endIndex > 0) {
                                    str = str.substring(0, endIndex);
                                }
                                try {
                                    from.setTextString(str.getBytes());
                                } catch (NullPointerException e) {
                                    log(""null pointer error!"");
                                    return null;
                                }
                            }
                        }
                    } else {
                        try {
                            from = new EncodedStringValue(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR.getBytes());
                        } catch (NullPointerException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    try {
                        headers.setEncodedStringValue(from, PduHeaders.FROM);
                    } catch (NullPointerException e) {
                        log(""null pointer error!"");
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Encoded-String-Value header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.MESSAGE_CLASS:
                {
                    /* Message-class-value = Class-identifier | Token-text */
                    pduDataStream.mark(1);
                    int messageClass = extractByteValue(pduDataStream);
                    if (messageClass >= PduHeaders.MESSAGE_CLASS_PERSONAL) {
                        /* Class-identifier */
                        try {
                            if (PduHeaders.MESSAGE_CLASS_PERSONAL == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_ADVERTISEMENT == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_INFORMATIONAL == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_AUTO == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            }
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    } else {
                        /* Token-text */
                        pduDataStream.reset();
                        byte[] messageClassString = parseWapString(pduDataStream, TYPE_TEXT_STRING);
                        if (null != messageClassString) {
                            try {
                                headers.setTextString(messageClassString, PduHeaders.MESSAGE_CLASS);
                            } catch (NullPointerException e) {
                                log(""null pointer error!"");
                            } catch (RuntimeException e) {
                                log(headerField + ""is not Text-String header field!"");
                                return null;
                            }
                        }
                    }
                    break;
                }
            case PduHeaders.MMS_VERSION:
                {
                    int version = parseShortInteger(pduDataStream);
                    try {
                        headers.setOctet(version, PduHeaders.MMS_VERSION);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + version + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.PREVIOUSLY_SENT_BY:
                {
                    /* Previously-sent-by-value =
                     * Value-length Forwarded-count-value Encoded-string-value */
                    /* parse value-length */
                    parseValueLength(pduDataStream);
                    /* parse Forwarded-count-value */
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* parse Encoded-string-value */
                    EncodedStringValue previouslySentBy = parseEncodedStringValue(pduDataStream);
                    if (null != previouslySentBy) {
                        try {
                            headers.setEncodedStringValue(previouslySentBy, PduHeaders.PREVIOUSLY_SENT_BY);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            case PduHeaders.PREVIOUSLY_SENT_DATE:
                {
                    /* Previously-sent-date-value =
                     * Value-length Forwarded-count-value Date-value */
                    /* parse value-length */
                    parseValueLength(pduDataStream);
                    /* parse Forwarded-count-value */
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* Date-value */
                    try {
                        long perviouslySentDate = parseLongInteger(pduDataStream);
                        headers.setLongInteger(perviouslySentDate, PduHeaders.PREVIOUSLY_SENT_DATE);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.MM_FLAGS:
                {
                    /* MM-flags-value =
                     * Value-length
                     * ( Add-token | Remove-token | Filter-token )
                     * Encoded-string-value
                     */
                    /* parse Value-length */
                    parseValueLength(pduDataStream);
                    /* Add-token | Remove-token | Filter-token */
                    extractByteValue(pduDataStream);
                    /* Encoded-string-value */
                    parseEncodedStringValue(pduDataStream);
                    /* not store this header filed in ""headers"",
                     * because now PduHeaders doesn't support it */
                    break;
                }
            /* Value-length
                 * (Message-total-token | Size-total-token) Integer-Value */
            case PduHeaders.MBOX_TOTALS:
            case PduHeaders.MBOX_QUOTAS:
                {
                    /* Value-length */
                    parseValueLength(pduDataStream);
                    /* Message-total-token | Size-total-token */
                    extractByteValue(pduDataStream);
                    /*Integer-Value*/
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* not store these headers filed in ""headers"",
                    because now PduHeaders doesn't support them */
                    break;
                }
            case PduHeaders.ELEMENT_DESCRIPTOR:
                {
                    parseContentType(pduDataStream, null);
                    /* not store this header filed in ""headers"",
                    because now PduHeaders doesn't support it */
                    break;
                }
            case PduHeaders.CONTENT_TYPE:
                {
                    HashMap<Integer, Object> map = new HashMap<Integer, Object>();
                    byte[] contentType = parseContentType(pduDataStream, map);
                    if (null != contentType) {
                        try {
                            headers.setTextString(contentType, PduHeaders.CONTENT_TYPE);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    }
                    /* get start parameter */
                    mStartParam = (byte[]) map.get(PduPart.P_START);
                    /* get charset parameter */
                    mTypeParam = (byte[]) map.get(PduPart.P_TYPE);
                    keepParsing = false;
                    break;
                }
            case PduHeaders.CONTENT:
            case PduHeaders.ADDITIONAL_HEADERS:
            case PduHeaders.ATTRIBUTES:
            default:
                {
                    log(""Unknown header"");
                }
        }
    }
    return headers;
}","{
    if (pduDataStream == null) {
        return null;
    }
    boolean keepParsing = true;
    PduHeaders headers = new PduHeaders();
    while (keepParsing && (pduDataStream.available() > 0)) {
        pduDataStream.mark(1);
        int headerField = extractByteValue(pduDataStream);
        /* parse custom text header */
        if ((headerField >= TEXT_MIN) && (headerField <= TEXT_MAX)) {
            pduDataStream.reset();
            byte[] bVal = parseWapString(pduDataStream, TYPE_TEXT_STRING);
            if (LOCAL_LOGV) {
                Log.v(LOG_TAG, ""TextHeader: "" + new String(bVal));
            }
            /* we should ignore it at the moment */
            continue;
        }
        switch(headerField) {
            case PduHeaders.MESSAGE_TYPE:
                {
                    int messageType = extractByteValue(pduDataStream);
                    switch(messageType) {
                        // We don't support these kind of messages now.
                        case PduHeaders.MESSAGE_TYPE_FORWARD_REQ:
                        case PduHeaders.MESSAGE_TYPE_FORWARD_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_STORE_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_VIEW_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_UPLOAD_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_REQ:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DELETE_CONF:
                        case PduHeaders.MESSAGE_TYPE_MBOX_DESCR:
                        case PduHeaders.MESSAGE_TYPE_DELETE_REQ:
                        case PduHeaders.MESSAGE_TYPE_DELETE_CONF:
                        case PduHeaders.MESSAGE_TYPE_CANCEL_REQ:
                        case PduHeaders.MESSAGE_TYPE_CANCEL_CONF:
                            return null;
                    }
                    try {
                        headers.setOctet(messageType, headerField);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + messageType + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            /* Octect value */
            case PduHeaders.REPORT_ALLOWED:
            case PduHeaders.ADAPTATION_ALLOWED:
            case PduHeaders.DELIVERY_REPORT:
            case PduHeaders.DRM_CONTENT:
            case PduHeaders.DISTRIBUTION_INDICATOR:
            case PduHeaders.QUOTAS:
            case PduHeaders.READ_REPORT:
            case PduHeaders.STORE:
            case PduHeaders.STORED:
            case PduHeaders.TOTALS:
            case PduHeaders.SENDER_VISIBILITY:
            case PduHeaders.READ_STATUS:
            case PduHeaders.CANCEL_STATUS:
            case PduHeaders.PRIORITY:
            case PduHeaders.STATUS:
            case PduHeaders.REPLY_CHARGING:
            case PduHeaders.MM_STATE:
            case PduHeaders.RECOMMENDED_RETRIEVAL_MODE:
            case PduHeaders.CONTENT_CLASS:
            case PduHeaders.RETRIEVE_STATUS:
            case PduHeaders.STORE_STATUS:
            /**
             * The following field has a different value when
             * used in the M-Mbox-Delete.conf and M-Delete.conf PDU.
             * For now we ignore this fact, since we do not support these PDUs
             */
            case PduHeaders.RESPONSE_STATUS:
                {
                    int value = extractByteValue(pduDataStream);
                    try {
                        headers.setOctet(value, headerField);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + value + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            /* Long-Integer */
            case PduHeaders.DATE:
            case PduHeaders.REPLY_CHARGING_SIZE:
            case PduHeaders.MESSAGE_SIZE:
                {
                    try {
                        long value = parseLongInteger(pduDataStream);
                        headers.setLongInteger(value, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            /* Integer-Value */
            case PduHeaders.MESSAGE_COUNT:
            case PduHeaders.START:
            case PduHeaders.LIMIT:
                {
                    try {
                        long value = parseIntegerValue(pduDataStream);
                        headers.setLongInteger(value, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            /* Text-String */
            case PduHeaders.TRANSACTION_ID:
            case PduHeaders.REPLY_CHARGING_ID:
            case PduHeaders.AUX_APPLIC_ID:
            case PduHeaders.APPLIC_ID:
            case PduHeaders.REPLY_APPLIC_ID:
            /**
             * The next three header fields are email addresses
             * as defined in RFC2822,
             * not including the characters ""<"" and "">""
             */
            case PduHeaders.MESSAGE_ID:
            case PduHeaders.REPLACE_ID:
            case PduHeaders.CANCEL_ID:
            /**
             * The following field has a different value when
             * used in the M-Mbox-Delete.conf and M-Delete.conf PDU.
             * For now we ignore this fact, since we do not support these PDUs
             */
            case PduHeaders.CONTENT_LOCATION:
                {
                    byte[] value = parseWapString(pduDataStream, TYPE_TEXT_STRING);
                    if (null != value) {
                        try {
                            headers.setTextString(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Encoded-string-value */
            case PduHeaders.SUBJECT:
            case PduHeaders.RECOMMENDED_RETRIEVAL_MODE_TEXT:
            case PduHeaders.RETRIEVE_TEXT:
            case PduHeaders.STATUS_TEXT:
            case PduHeaders.STORE_STATUS_TEXT:
            /* the next one is not support
                     * M-Mbox-Delete.conf and M-Delete.conf now */
            case PduHeaders.RESPONSE_TEXT:
                {
                    EncodedStringValue value = parseEncodedStringValue(pduDataStream);
                    if (null != value) {
                        try {
                            headers.setEncodedStringValue(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Addressing model */
            case PduHeaders.BCC:
            case PduHeaders.CC:
            case PduHeaders.TO:
                {
                    EncodedStringValue value = parseEncodedStringValue(pduDataStream);
                    if (null != value) {
                        byte[] address = value.getTextString();
                        if (null != address) {
                            String str = new String(address);
                            int endIndex = str.indexOf(""/"");
                            if (endIndex > 0) {
                                str = str.substring(0, endIndex);
                            }
                            try {
                                value.setTextString(str.getBytes());
                            } catch (NullPointerException e) {
                                log(""null pointer error!"");
                                return null;
                            }
                        }
                        try {
                            headers.appendEncodedStringValue(value, headerField);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            /* Value-length
                 * (Absolute-token Date-value | Relative-token Delta-seconds-value) */
            case PduHeaders.DELIVERY_TIME:
            case PduHeaders.EXPIRY:
            case PduHeaders.REPLY_CHARGING_DEADLINE:
                {
                    /* parse Value-length */
                    parseValueLength(pduDataStream);
                    /* Absolute-token or Relative-token */
                    int token = extractByteValue(pduDataStream);
                    /* Date-value or Delta-seconds-value */
                    long timeValue;
                    try {
                        timeValue = parseLongInteger(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    if (PduHeaders.VALUE_RELATIVE_TOKEN == token) {
                        /* need to convert the Delta-seconds-value
                         * into Date-value */
                        timeValue = System.currentTimeMillis() / 1000 + timeValue;
                    }
                    try {
                        headers.setLongInteger(timeValue, headerField);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.FROM:
                {
                    /* From-value =
                     * Value-length
                     * (Address-present-token Encoded-string-value | Insert-address-token)
                     */
                    EncodedStringValue from = null;
                    parseValueLength(pduDataStream);
                    /* parse value-length */
                    /* Address-present-token or Insert-address-token */
                    int fromToken = extractByteValue(pduDataStream);
                    /* Address-present-token or Insert-address-token */
                    if (PduHeaders.FROM_ADDRESS_PRESENT_TOKEN == fromToken) {
                        /* Encoded-string-value */
                        from = parseEncodedStringValue(pduDataStream);
                        if (null != from) {
                            byte[] address = from.getTextString();
                            if (null != address) {
                                String str = new String(address);
                                int endIndex = str.indexOf(""/"");
                                if (endIndex > 0) {
                                    str = str.substring(0, endIndex);
                                }
                                try {
                                    from.setTextString(str.getBytes());
                                } catch (NullPointerException e) {
                                    log(""null pointer error!"");
                                    return null;
                                }
                            }
                        }
                    } else {
                        try {
                            from = new EncodedStringValue(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR.getBytes());
                        } catch (NullPointerException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    try {
                        headers.setEncodedStringValue(from, PduHeaders.FROM);
                    } catch (NullPointerException e) {
                        log(""null pointer error!"");
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Encoded-String-Value header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.MESSAGE_CLASS:
                {
                    /* Message-class-value = Class-identifier | Token-text */
                    pduDataStream.mark(1);
                    int messageClass = extractByteValue(pduDataStream);
                    if (messageClass >= PduHeaders.MESSAGE_CLASS_PERSONAL) {
                        /* Class-identifier */
                        try {
                            if (PduHeaders.MESSAGE_CLASS_PERSONAL == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_ADVERTISEMENT == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_INFORMATIONAL == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            } else if (PduHeaders.MESSAGE_CLASS_AUTO == messageClass) {
                                headers.setTextString(PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes(), PduHeaders.MESSAGE_CLASS);
                            }
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    } else {
                        /* Token-text */
                        pduDataStream.reset();
                        byte[] messageClassString = parseWapString(pduDataStream, TYPE_TEXT_STRING);
                        if (null != messageClassString) {
                            try {
                                headers.setTextString(messageClassString, PduHeaders.MESSAGE_CLASS);
                            } catch (NullPointerException e) {
                                log(""null pointer error!"");
                            } catch (RuntimeException e) {
                                log(headerField + ""is not Text-String header field!"");
                                return null;
                            }
                        }
                    }
                    break;
                }
            case PduHeaders.MMS_VERSION:
                {
                    int version = parseShortInteger(pduDataStream);
                    try {
                        headers.setOctet(version, PduHeaders.MMS_VERSION);
                    } catch (InvalidHeaderValueException e) {
                        log(""Set invalid Octet value: "" + version + "" into the header filed: "" + headerField);
                        return null;
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Octet header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.PREVIOUSLY_SENT_BY:
                {
                    /* Previously-sent-by-value =
                     * Value-length Forwarded-count-value Encoded-string-value */
                    /* parse value-length */
                    parseValueLength(pduDataStream);
                    /* parse Forwarded-count-value */
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* parse Encoded-string-value */
                    EncodedStringValue previouslySentBy = parseEncodedStringValue(pduDataStream);
                    if (null != previouslySentBy) {
                        try {
                            headers.setEncodedStringValue(previouslySentBy, PduHeaders.PREVIOUSLY_SENT_BY);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Encoded-String-Value header field!"");
                            return null;
                        }
                    }
                    break;
                }
            case PduHeaders.PREVIOUSLY_SENT_DATE:
                {
                    /* Previously-sent-date-value =
                     * Value-length Forwarded-count-value Date-value */
                    /* parse value-length */
                    parseValueLength(pduDataStream);
                    /* parse Forwarded-count-value */
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* Date-value */
                    try {
                        long perviouslySentDate = parseLongInteger(pduDataStream);
                        headers.setLongInteger(perviouslySentDate, PduHeaders.PREVIOUSLY_SENT_DATE);
                    } catch (RuntimeException e) {
                        log(headerField + ""is not Long-Integer header field!"");
                        return null;
                    }
                    break;
                }
            case PduHeaders.MM_FLAGS:
                {
                    /* MM-flags-value =
                     * Value-length
                     * ( Add-token | Remove-token | Filter-token )
                     * Encoded-string-value
                     */
                    /* parse Value-length */
                    parseValueLength(pduDataStream);
                    /* Add-token | Remove-token | Filter-token */
                    extractByteValue(pduDataStream);
                    /* Encoded-string-value */
                    parseEncodedStringValue(pduDataStream);
                    /* not store this header filed in ""headers"",
                     * because now PduHeaders doesn't support it */
                    break;
                }
            /* Value-length
                 * (Message-total-token | Size-total-token) Integer-Value */
            case PduHeaders.MBOX_TOTALS:
            case PduHeaders.MBOX_QUOTAS:
                {
                    /* Value-length */
                    parseValueLength(pduDataStream);
                    /* Message-total-token | Size-total-token */
                    extractByteValue(pduDataStream);
                    /*Integer-Value*/
                    try {
                        parseIntegerValue(pduDataStream);
                    } catch (RuntimeException e) {
                        log(headerField + "" is not Integer-Value"");
                        return null;
                    }
                    /* not store these headers filed in ""headers"",
                    because now PduHeaders doesn't support them */
                    break;
                }
            case PduHeaders.ELEMENT_DESCRIPTOR:
                {
                    parseContentType(pduDataStream, null);
                    /* not store this header filed in ""headers"",
                    because now PduHeaders doesn't support it */
                    break;
                }
            case PduHeaders.CONTENT_TYPE:
                {
                    HashMap<Integer, Object> map = new HashMap<Integer, Object>();
                    byte[] contentType = parseContentType(pduDataStream, map);
                    if (null != contentType) {
                        try {
                            headers.setTextString(contentType, PduHeaders.CONTENT_TYPE);
                        } catch (NullPointerException e) {
                            log(""null pointer error!"");
                        } catch (RuntimeException e) {
                            log(headerField + ""is not Text-String header field!"");
                            return null;
                        }
                    }
                    /* get start parameter */
                    mStartParam = (byte[]) map.get(PduPart.P_START);
                    /* get charset parameter */
                    mTypeParam = (byte[]) map.get(PduPart.P_TYPE);
                    keepParsing = false;
                    break;
                }
            case PduHeaders.CONTENT:
            case PduHeaders.ADDITIONAL_HEADERS:
            case PduHeaders.ATTRIBUTES:
            default:
                {
                    log(""Unknown header"");
                }
        }
    }
    return headers;
}",1,"/**
 * Parse pdu headers.
 *
 * @param pduDataStream pdu data input stream
 * @return headers in PduHeaders structure, null when parse fail
 */
","/**
 * Parse pdu headers.
 *
 * @param pduDataStream pdu data input stream
 * @return headers in PduHeaders structure, null when parse fail
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
27,<android.content.pm.Signature: String toCharsString()>,8,9,<android.content.pm.Signature: String toCharsString()>,<android.content.pm.Signature: String toCharsString()>,0,"{
    if (mString != null)
        return mString;
    String str = new String(toChars());
    mString = str;
    return mString;
}","{
    String str = mStringRef == null ? null : mStringRef.get();
    if (str != null) {
        return str;
    }
    str = new String(toChars());
    mStringRef = new SoftReference<String>(str);
    return str;
}",1,"/**
 * Return the result of {@link #toChars()} as a String.  This result is
 * cached so future calls will return the same String.
 */
","/**
 * Return the result of {@link #toChars()} as a String.  This result is
 * cached so future calls will return the same String.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statements and variable initialization have been significantly modified. Therefore the code change is under category 1,4.","Due to these modifications, the returned value of the method could potentially change. Therefore, the situation falls under category 1 of Compatibility Issue."
30,<android.widget.TextView: boolean hasSelection()>,8,9,<android.widget.TextView: boolean hasSelection()>,<android.widget.TextView: boolean hasSelection()>,0,"{
    return getSelectionStart() != getSelectionEnd();
}","{
    final int selectionStart = getSelectionStart();
    final int selectionEnd = getSelectionEnd();
    return selectionStart >= 0 && selectionStart != selectionEnd;
}",1,"/**
 * Return true iff there is a selection inside this text view.
 */
","/**
 * Return true iff there is a selection inside this text view.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement of 'hasSelection()' API has been changed and the control dependency (logic of how data is obtained) has been modified, so code change type is 1,3. ","The modified return statement can potentially make the late version of this API return a different value. Hence, the Compatibility Issue type is 1."
32,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,8,9,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,0,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    boolean shiftPressed = mShiftIsPressed && (mNativeClass == 0 || !nativeFocusIsPlugin());
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (shiftPressed) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (shiftPressed) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}","{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time);
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) has been removed and the local variable 'shiftPressed' has been replaced with 'mSelectingText'. Also, the two function calls 'commitCopy()' and 'nativeFocusIsPlugin()' are replaced with function calls 'copySelection()' and 'nativeSetExtendSelection()', so the code change type is 3,4.","The changes made in the condition statements and method calls can potentially cause the API to return a different variable. So, the CI type is 1."
33,"<android.view.MotionEvent: float getHistoricalSize(int,int)>",8,9,"<android.view.MotionEvent: float getHistoricalSize(int,int)>","<android.view.MotionEvent: float getHistoricalSize(int,int)>",0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + (pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_SIZE];
}","{
    return mDataSamples[(pos * mNumPointers + pointerIndex) * NUM_SAMPLE_DATA + SAMPLE_SIZE];
}",1,"/**
 * Returns a historical size coordinate, as per {@link #getSize(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getSize
 */
","/**
 * Returns a historical size coordinate, as per {@link #getSize(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getSize
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + (pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_SIZE]; to return mDataSamples[(pos * mNumPointers + pointerIndex) * NUM_SAMPLE_DATA + SAMPLE_SIZE];. Therefore, the code change type is 4 and 1 since the computation within the statement has been altered.","The change in the formula within the return statement will result in the method potentially returning a different value, therefore the Compatibility Issue (CI) type is 1."
34,<android.webkit.WebView: boolean pageDown(boolean)>,8,9,<android.webkit.WebView: boolean pageDown(boolean)>,<android.webkit.WebView: boolean pageDown(boolean)>,0,"{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, computeVerticalScrollRange(), true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, computeRealVerticalScrollRange(), true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    mUserScroll = true;
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}",1,"/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The function that is called in the return statement changed from `computeVerticalScrollRange()` to `computeRealVerticalScrollRange()`, therefore the code change types are 1 and 5.","Due to the change of the function in the returned value, the API potentially returns a different value, causing a compatibility issue of type 1."
36,<android.widget.TextView: boolean onTextContextMenuItem(int)>,8,9,<android.widget.TextView: boolean onTextContextMenuItem(int)>,<android.widget.TextView: boolean onTextContextMenuItem(int)>,0,"{
    int selStart = getSelectionStart();
    int selEnd = getSelectionEnd();
    if (!isFocused()) {
        selStart = 0;
        selEnd = mText.length();
    }
    int min = Math.min(selStart, selEnd);
    int max = Math.max(selStart, selEnd);
    if (min < 0) {
        min = 0;
    }
    if (max < 0) {
        max = 0;
    }
    ClipboardManager clip = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    switch(id) {
        case ID_SELECT_ALL:
            Selection.setSelection((Spannable) mText, 0, mText.length());
            return true;
        case ID_START_SELECTING_TEXT:
            MetaKeyKeyListener.startSelecting(this, (Spannable) mText);
            return true;
        case ID_STOP_SELECTING_TEXT:
            MetaKeyKeyListener.stopSelecting(this, (Spannable) mText);
            Selection.setSelection((Spannable) mText, getSelectionEnd());
            return true;
        case ID_CUT:
            MetaKeyKeyListener.stopSelecting(this, (Spannable) mText);
            if (min == max) {
                min = 0;
                max = mText.length();
            }
            clip.setText(mTransformed.subSequence(min, max));
            ((Editable) mText).delete(min, max);
            return true;
        case ID_COPY:
            MetaKeyKeyListener.stopSelecting(this, (Spannable) mText);
            if (min == max) {
                min = 0;
                max = mText.length();
            }
            clip.setText(mTransformed.subSequence(min, max));
            return true;
        case ID_PASTE:
            MetaKeyKeyListener.stopSelecting(this, (Spannable) mText);
            CharSequence paste = clip.getText();
            if (paste != null) {
                Selection.setSelection((Spannable) mText, max);
                ((Editable) mText).replace(min, max, paste);
            }
            return true;
        case ID_COPY_URL:
            MetaKeyKeyListener.stopSelecting(this, (Spannable) mText);
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length == 1) {
                clip.setText(urls[0].getURL());
            }
            return true;
        case ID_SWITCH_INPUT_METHOD:
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null) {
                imm.showInputMethodPicker();
            }
            return true;
        case ID_ADD_TO_DICTIONARY:
            String word = getWordForDictionary();
            if (word != null) {
                Intent i = new Intent(""com.android.settings.USER_DICTIONARY_INSERT"");
                i.putExtra(""word"", word);
                i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
                getContext().startActivity(i);
            }
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    ClipboardManager clip = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    switch(id) {
        case ID_SELECT_ALL:
            Selection.setSelection((Spannable) mText, 0, mText.length());
            startTextSelectionMode();
            getSelectionController().show();
            return true;
        case ID_START_SELECTING_TEXT:
            startTextSelectionMode();
            getSelectionController().show();
            return true;
        case ID_CUT:
            clip.setText(mTransformed.subSequence(min, max));
            ((Editable) mText).delete(min, max);
            stopTextSelectionMode();
            return true;
        case ID_COPY:
            clip.setText(mTransformed.subSequence(min, max));
            stopTextSelectionMode();
            return true;
        case ID_PASTE:
            CharSequence paste = clip.getText();
            if (paste != null && paste.length() > 0) {
                long minMax = prepareSpacesAroundPaste(min, max, paste);
                min = extractRangeStartFromLong(minMax);
                max = extractRangeEndFromLong(minMax);
                Selection.setSelection((Spannable) mText, max);
                ((Editable) mText).replace(min, max, paste);
                stopTextSelectionMode();
            }
            return true;
        case ID_COPY_URL:
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length == 1) {
                clip.setText(urls[0].getURL());
            }
            return true;
        case ID_SWITCH_INPUT_METHOD:
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null) {
                imm.showInputMethodPicker();
            }
            return true;
        case ID_ADD_TO_DICTIONARY:
            String word = getWordForDictionary();
            if (word != null) {
                Intent i = new Intent(""com.android.settings.USER_DICTIONARY_INSERT"");
                i.putExtra(""word"", word);
                i.setFlags(i.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
                getContext().startActivity(i);
            }
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of: {@link android.R.id#selectAll},
 * {@link android.R.id#startSelectingText}, {@link android.R.id#stopSelectingText},
 * {@link android.R.id#cut}, {@link android.R.id#copy},
 * {@link android.R.id#paste}, {@link android.R.id#copyUrl},
 * or {@link android.R.id#switchInputMethod}.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of: {@link android.R.id#selectAll},
 * {@link android.R.id#startSelectingText},
 * {@link android.R.id#cut}, {@link android.R.id#copy},
 * {@link android.R.id#paste}, {@link android.R.id#copyUrl},
 * or {@link android.R.id#switchInputMethod}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The handling of 'min' and 'max' has changed which will influence the control flow. Moreover, new methods like ""startTextSelectionMode()"", ""getSelectionController().show()"", and ""stopTextSelectionMode()"" are invoked in the late version. Hence, the code change involves Control dependency changed (3) and Other statement changed (4).","The change to the control dependency and added function calls might cause the API to return different values. Therefore, the Compatibility Issue situation is Compatibility Issue caused by potential different return values or types (1)."
37,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,8,9,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,<android.server.BluetoothA2dpService: boolean disconnectSink(BluetoothDevice)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""disconnectSink("" + device + "")"");
    String path = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (path == null) {
        return false;
    }
    int state = getSinkState(device);
    switch(state) {
        case BluetoothA2dp.STATE_DISCONNECTED:
            return false;
        case BluetoothA2dp.STATE_DISCONNECTING:
            return true;
    }
    // State is CONNECTING or CONNECTED or PLAYING
    handleSinkStateChange(device, state, BluetoothA2dp.STATE_DISCONNECTING);
    if (!disconnectSinkNative(path)) {
        // Restore previous state
        handleSinkStateChange(device, mAudioDevices.get(device), state);
        return false;
    }
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (DBG)
        log(""disconnectSink("" + device + "")"");
    if (!isDisconnectSinkFeasible(device))
        return false;
    return mBluetoothService.disconnectSink(device.getAddress());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",1,"The entire implementation of disconnectSink() method has been changed in the late version. In the early version, the method first gets the object's path from its address, then handles the device state changes, and then calls the native function to disconnect the sink. In contrast, the late version checks if disconnecting the sink is feasible, and then calls the mBluetoothService's method to disconnect the sink. Thus, the change types are 1, 3, 4, and 5. ","The change in return statement is potentially making the method return different value. For example, in the early version, the method returns false if the object path is null or if the state is BluetoothA2dp.STATE_DISCONNECTED or if the disconnectSinkNative(path) returns false, whereas, in the late version, the method returns false only if it is not feasible to disconnect sink. Hence, the CI type is 1."
38,<android.widget.ScrollView: int computeVerticalScrollRange()>,8,9,<android.widget.ScrollView: int computeVerticalScrollRange()>,<android.widget.ScrollView: int computeVerticalScrollRange()>,0,"{
    final int count = getChildCount();
    final int contentHeight = getHeight() - mPaddingBottom - mPaddingTop;
    if (count == 0) {
        return contentHeight;
    }
    return getChildAt(0).getBottom();
}","{
    final int count = getChildCount();
    final int contentHeight = getHeight() - mPaddingBottom - mPaddingTop;
    if (count == 0) {
        return contentHeight;
    }
    int scrollRange = getChildAt(0).getBottom();
    final int scrollY = mScrollY;
    final int overscrollBottom = Math.max(0, scrollRange - contentHeight);
    if (scrollY < 0) {
        scrollRange -= scrollY;
    } else if (scrollY > overscrollBottom) {
        scrollRange += scrollY - overscrollBottom;
    }
    return scrollRange;
}",1,"/**
 * <p>The scroll range of a scroll view is the overall height of all of its
 * children.</p>
 */
","/**
 * <p>The scroll range of a scroll view is the overall height of all of its
 * children.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The return statement has changed from ""return getChildAt(0).getBottom();"" to ""return scrollRange;"". A new control block ""if (scrollY < 0) {...} else if (scrollY > overscrollBottom) {...}"" has been added in the latest code version. So the code change type is 1,3.","Due to the change in the return statement and the added control block, different versions of the code may now return different variable values. This results in a CI with type 1."
39,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,float,float,float,float,int,float,float,int,int)>",8,9,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,float,float,float,float,int,float,float,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,float,float,float,float,int,float,float,int,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = deviceId;
    ev.mEdgeFlags = edgeFlags;
    ev.mDownTime = downTime;
    ev.mEventTimeNano = eventTime * 1000000;
    ev.mAction = action;
    ev.mNumPointers = pointers;
    ev.mMetaState = metaState;
    ev.mXPrecision = xPrecision;
    ev.mYPrecision = yPrecision;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    int[] pointerIds = ev.mPointerIdentifiers;
    pointerIds[0] = 0;
    float[] data = ev.mDataSamples;
    data[SAMPLE_X] = ev.mRawX = x;
    data[SAMPLE_Y] = ev.mRawY = y;
    data[SAMPLE_PRESSURE] = pressure;
    data[SAMPLE_SIZE] = size;
    ev.mTimeSamples[0] = eventTime;
    return ev;
}","{
    return obtain(downTime, eventTime, action, x, y, pressure, size, metaState, xPrecision, yPrecision, deviceId, edgeFlags);
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param pointers The number of pointers that are active in this event.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, where touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param pointers The number of pointers that are active in this event.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 *
 * @deprecated Use {@link #obtain(long, long, int, float, float, float, float, int, float, float, int, int)}
 * instead.
 */
",-1,,[@Deprecated],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version of the API does not manually assign values to the properties of MotionEvent as the early version does. Instead, it directly calls another method obtain() with parameters. This can be considered both as a change in return statements and change in other statement types, thus the change is of type 1,4.","The change in return statement will make the API potentially return a different value (even though the properties are set similarly, the internal implementation could be different), so the CI is of type 1."
40,<android.os.Parcel: T readParcelable(ClassLoader)>,8,9,<android.os.Parcel: T readParcelable(ClassLoader)>,<android.os.Parcel: T readParcelable(ClassLoader)>,0,"{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<T> creator;
    synchronized (mCreators) {
        HashMap<String, Parcelable.Creator> map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<String, Parcelable.Creator>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
        if (creator == null) {
            try {
                Class c = loader == null ? Class.forName(name) : Class.forName(name, true, loader);
                Field f = c.getField(""CREATOR"");
                creator = (Parcelable.Creator) f.get(null);
            } catch (IllegalAccessException e) {
                Log.e(""Parcel"", ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name);
            } catch (ClassNotFoundException e) {
                Log.e(""Parcel"", ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name);
            } catch (ClassCastException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            } catch (NoSuchFieldException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            if (creator == null) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            map.put(name, creator);
        }
    }
    return creator.createFromParcel(this);
}","{
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<T> creator;
    synchronized (mCreators) {
        HashMap<String, Parcelable.Creator> map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<String, Parcelable.Creator>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
        if (creator == null) {
            try {
                Class c = loader == null ? Class.forName(name) : Class.forName(name, true, loader);
                Field f = c.getField(""CREATOR"");
                creator = (Parcelable.Creator) f.get(null);
            } catch (IllegalAccessException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""IllegalAccessException when unmarshalling: "" + name);
            } catch (ClassNotFoundException e) {
                Log.e(TAG, ""Class not found when unmarshalling: "" + name + "", e: "" + e);
                throw new BadParcelableException(""ClassNotFoundException when unmarshalling: "" + name);
            } catch (ClassCastException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            } catch (NoSuchFieldException e) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            if (creator == null) {
                throw new BadParcelableException(""Parcelable protocol requires a "" + ""Parcelable.Creator object called "" + "" CREATOR on class "" + name);
            }
            map.put(name, creator);
        }
    }
    return creator.createFromParcel(this);
}",1,"/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
","/**
 * Read and return a new Parcelable from the parcel.  The given class loader
 * will be used to load any enclosed Parcelables.  If it is null, the default
 * class loader will be used.
 * @param loader A ClassLoader from which to instantiate the Parcelable
 * object, or null for the default class loader.
 * @return Returns the newly created Parcelable, or null if a null
 * object has been written.
 * @throws BadParcelableException Throws BadParcelableException if there
 * was an error trying to instantiate the Parcelable.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The Log.e() function call's first parameter has changed in two ""catch"" blocks. In the early version, the parameter was ""Parcel"", while in the late version, it's ""TAG"". So, the code change type is 4.","These changes do not affect the return value or exceptions of the API as they only involve internal log message modification. Hence, no compatibility issue exists, therefore the CI type is 0."
42,<android.pim.vcard.VCardConfig: boolean shouldUseQuotedPrintable(int)>,8,9,<android.pim.vcard.VCardConfig: boolean shouldUseQuotedPrintable(int)>,<android.pim.vcard.VCardConfig: boolean shouldUseQuotedPrintable(int)>,0,"{
    return !isV30(vcardType);
}","{
    return !isVersion30(vcardType);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The function called in the return statement changed from isV30(vcardType) to isVersion30(vcardType), which technically doesn't change the method body but calls a different method, so the code change type is 4, 5.","Since the API used in the return statement has changed, it might result in different return values, so the CI type is 1."
43,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,8,9,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,<android.webkit.HTML5VideoViewProxy: void onCompletion(MediaPlayer)>,0,"{
    // The video ended by itself, so we need to
    // send a message to the UI thread to dismiss
    // the video view and to return to the WebView.
    sendMessage(obtainMessage(ENDED));
}","{
    // The video ended by itself, so we need to
    // send a message to the UI thread to dismiss
    // the video view and to return to the WebView.
    // arg1 == 1 means the video ends by itself.
    sendMessage(obtainMessage(ENDED, 1, 0));
}",1,"// MediaPlayer.OnCompletionListener;
","// MediaPlayer.OnCompletionListener;
",-1,,,-1,-1,-1,-1,-1,-1,1,0,"The sendMessage method call is changed from sendMessage(obtainMessage(ENDED)) to sendMessage(obtainMessage(ENDED, 1, 0)). The embeded parameters in the method call have been updated. Hence the code change type is 1.","Though the sendMessage method has been expanded with additional parameters, it doesn't affect the behavior of the onCompletion method itself. This method still does the same thing, which is sending a message when a video ends. Therefore, there is no compatibility issue, hence the CI type is 0."
44,"<android.pim.vcard.VCardBuilder: void appendPostalLine(int,String,ContentValues,boolean,boolean)>",8,9,"<android.pim.vcard.VCardBuilder: void appendPostalLine(int,String,ContentValues,boolean,boolean)>","<android.pim.vcard.VCardBuilder: void appendPostalLine(int,String,ContentValues,boolean,boolean)>",0,"{
    final boolean reallyUseQuotedPrintable;
    final boolean appendCharset;
    final String addressValue;
    {
        PostalStruct postalStruct = tryConstructPostalStruct(contentValues);
        if (postalStruct == null) {
            if (emitLineEveryTime) {
                reallyUseQuotedPrintable = false;
                appendCharset = false;
                addressValue = """";
            } else {
                return;
            }
        } else {
            reallyUseQuotedPrintable = postalStruct.reallyUseQuotedPrintable;
            appendCharset = postalStruct.appendCharset;
            addressValue = postalStruct.addressData;
        }
    }
    List<String> parameterList = new ArrayList<String>();
    if (isPrimary) {
        parameterList.add(VCardConstants.PARAM_TYPE_PREF);
    }
    switch(type) {
        case StructuredPostal.TYPE_HOME:
            {
                parameterList.add(VCardConstants.PARAM_TYPE_HOME);
                break;
            }
        case StructuredPostal.TYPE_WORK:
            {
                parameterList.add(VCardConstants.PARAM_TYPE_WORK);
                break;
            }
        case StructuredPostal.TYPE_CUSTOM:
            {
                if (!TextUtils.isEmpty(label) && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
                    // We're not sure whether the label is valid in the spec
                    // (""IANA-token"" in the vCard 3.0 is unclear...)
                    // Just  for safety, we add ""X-"" at the beggining of each label.
                    // Also checks the label obeys with vCard 3.0 spec.
                    parameterList.add(""X-"" + label);
                }
                break;
            }
        case StructuredPostal.TYPE_OTHER:
            {
                break;
            }
        default:
            {
                Log.e(LOG_TAG, ""Unknown StructuredPostal type: "" + type);
                break;
            }
    }
    mBuilder.append(VCardConstants.PROPERTY_ADR);
    if (!parameterList.isEmpty()) {
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        appendTypeParameters(parameterList);
    }
    if (appendCharset) {
        // Strictly, vCard 3.0 does not allow exporters to emit charset information,
        // but we will add it since the information should be useful for importers,
        // 
        // Assume no parser does not emit error with this parameter in vCard 3.0.
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        mBuilder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintable) {
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        mBuilder.append(VCARD_PARAM_ENCODING_QP);
    }
    mBuilder.append(VCARD_DATA_SEPARATOR);
    mBuilder.append(addressValue);
    mBuilder.append(VCARD_END_OF_LINE);
}","{
    final boolean reallyUseQuotedPrintable;
    final boolean appendCharset;
    final String addressValue;
    {
        PostalStruct postalStruct = tryConstructPostalStruct(contentValues);
        if (postalStruct == null) {
            if (emitEveryTime) {
                reallyUseQuotedPrintable = false;
                appendCharset = false;
                addressValue = """";
            } else {
                return;
            }
        } else {
            reallyUseQuotedPrintable = postalStruct.reallyUseQuotedPrintable;
            appendCharset = postalStruct.appendCharset;
            addressValue = postalStruct.addressData;
        }
    }
    List<String> parameterList = new ArrayList<String>();
    if (isPrimary) {
        parameterList.add(VCardConstants.PARAM_TYPE_PREF);
    }
    switch(type) {
        case StructuredPostal.TYPE_HOME:
            {
                parameterList.add(VCardConstants.PARAM_TYPE_HOME);
                break;
            }
        case StructuredPostal.TYPE_WORK:
            {
                parameterList.add(VCardConstants.PARAM_TYPE_WORK);
                break;
            }
        case StructuredPostal.TYPE_CUSTOM:
            {
                if (!TextUtils.isEmpty(label) && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
                    // We're not sure whether the label is valid in the spec
                    // (""IANA-token"" in the vCard 3.0 is unclear...)
                    // Just  for safety, we add ""X-"" at the beggining of each label.
                    // Also checks the label obeys with vCard 3.0 spec.
                    parameterList.add(""X-"" + label);
                }
                break;
            }
        case StructuredPostal.TYPE_OTHER:
            {
                break;
            }
        default:
            {
                Log.e(LOG_TAG, ""Unknown StructuredPostal type: "" + type);
                break;
            }
    }
    mBuilder.append(VCardConstants.PROPERTY_ADR);
    if (!parameterList.isEmpty()) {
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        appendTypeParameters(parameterList);
    }
    if (appendCharset) {
        // Strictly, vCard 3.0 does not allow exporters to emit charset information,
        // but we will add it since the information should be useful for importers,
        // 
        // Assume no parser does not emit error with this parameter in vCard 3.0.
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        mBuilder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintable) {
        mBuilder.append(VCARD_PARAM_SEPARATOR);
        mBuilder.append(VCARD_PARAM_ENCODING_QP);
    }
    mBuilder.append(VCARD_DATA_SEPARATOR);
    mBuilder.append(addressValue);
    mBuilder.append(VCARD_END_OF_LINE);
}",1,,"/**
 * @param emitEveryTime If true, builder builds the line even when there's no entry.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The parameter name in the conditional statement has changed from ""emitLineEveryTime"" to ""emitEveryTime"". This case is assigned to the ""Other statement changed"" category.","There is no potential compatibility issue as this change is only a parameter name change, which doesn't affect the program logic or lead to return different types or values, nor throwing different exceptions."
45,<android.view.SurfaceView: void onDetachedFromWindow()>,8,9,<android.view.SurfaceView: void onDetachedFromWindow()>,<android.view.SurfaceView: void onDetachedFromWindow()>,0,"{
    getViewTreeObserver().removeOnScrollChangedListener(mScrollChangedListener);
    mRequestedVisible = false;
    updateWindow(false);
    mHaveFrame = false;
    if (mWindow != null) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException ex) {
        }
        mWindow = null;
    }
    mSession = null;
    mLayout.token = null;
    super.onDetachedFromWindow();
}","{
    getViewTreeObserver().removeOnScrollChangedListener(mScrollChangedListener);
    mRequestedVisible = false;
    updateWindow(false, false);
    mHaveFrame = false;
    if (mWindow != null) {
        try {
            mSession.remove(mWindow);
        } catch (RemoteException ex) {
        }
        mWindow = null;
    }
    mSession = null;
    mLayout.token = null;
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"In function `updateWindow()`, another boolean parameter is added in the latest version, which extendes to be `updateWindow(false, false)`. So the change types are 4 and 5.","Despite the addition of a parameter in the `updateWindow()` function, since this addition doesn't introduce any new return statements, nor potential exception throwings or changes of existing controlling dependencies, no Compatibility Issue exists here."
46,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,8,9,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,0,"{
    // the vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  i'll call this upVector elsewhere.
    float x = event.values[_DATA_X];
    float y = event.values[_DATA_Y];
    float z = event.values[_DATA_Z];
    float magnitude = vectorMagnitude(x, y, z);
    float deviation = Math.abs(magnitude - SensorManager.STANDARD_GRAVITY);
    float tiltAngle = tiltAngle(z, magnitude);
    float alpha = DEFAULT_LOWPASS_ALPHA;
    if (tiltAngle > MAX_TILT) {
        return;
    } else if (deviation > MAX_DEVIATION_FROM_GRAVITY) {
        alpha = ACCELERATING_LOWPASS_ALPHA;
    } else if (tiltAngle > PARTIAL_TILT) {
        alpha = TILTED_LOWPASS_ALPHA;
    }
    x = mFilteredVector[0] = lowpassFilter(x, mFilteredVector[0], alpha);
    y = mFilteredVector[1] = lowpassFilter(y, mFilteredVector[1], alpha);
    z = mFilteredVector[2] = lowpassFilter(z, mFilteredVector[2], alpha);
    magnitude = vectorMagnitude(x, y, z);
    tiltAngle = tiltAngle(z, magnitude);
    // Angle between the x-y projection of upVector and the +y-axis, increasing
    // counter-clockwise.
    // 0 degrees = speaker end towards the sky
    // 90 degrees = left edge of device towards the sky
    float orientationAngle = (float) Math.atan2(-x, y) * RADIANS_TO_DEGREES;
    int orientation = Math.round(orientationAngle);
    // atan2 returns (-180, 180]; normalize to [0, 360)
    if (orientation < 0) {
        orientation += 360;
    }
    calculateNewRotation(orientation, Math.round(tiltAngle));
}","{
    // the vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  i'll call this upVector elsewhere.
    float x = event.values[_DATA_X];
    float y = event.values[_DATA_Y];
    float z = event.values[_DATA_Z];
    float magnitude = vectorMagnitude(x, y, z);
    float deviation = Math.abs(magnitude - SensorManager.STANDARD_GRAVITY);
    handleAccelerationDistrust(deviation);
    // only filter tilt when we're accelerating
    float alpha = 1;
    if (mAccelerationDistrust > 0) {
        alpha = ACCELERATING_LOWPASS_ALPHA;
    }
    float newTiltAngle = tiltAngle(z, magnitude);
    mTiltAngle = lowpassFilter(newTiltAngle, mTiltAngle, alpha);
    float absoluteTilt = Math.abs(mTiltAngle);
    checkFullyTilted(absoluteTilt);
    if (mTiltDistrust > 0) {
        // when fully tilted, ignore orientation entirely
        return;
    }
    float newOrientationAngle = computeNewOrientation(x, y);
    filterOrientation(absoluteTilt, newOrientationAngle);
    calculateNewRotation(mOrientationAngle, absoluteTilt);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Other statements regarding variable calculations have been changed, and several method calls have been introduced (handleAccelerationDistrust(deviation), checkFullyTilted(absoluteTilt), computeNewOrientation(x, y), and filterOrientation(absoluteTilt, newOrientationAngle)). The return statement is still under the same condition, but the condition checking process has changed due to new calculations. So, the code change type is 4.","Though the implementation has changed, the behaviour of the API remains consistent between two versions. The return statement is still triggered by similar conditions, and any exception thrown remains same in both versions, so there is no Compatibility Issue (CI)."
47,"<android.view.MotionEvent: float getHistoricalX(int,int)>",8,9,"<android.view.MotionEvent: float getHistoricalX(int,int)>","<android.view.MotionEvent: float getHistoricalX(int,int)>",0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + (pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_X];
}","{
    return mDataSamples[(pos * mNumPointers + pointerIndex) * NUM_SAMPLE_DATA + SAMPLE_X] + mXOffset;
}",1,"/**
 * Returns a historical X coordinate, as per {@link #getX(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getX
 */
","/**
 * Returns a historical X coordinate, as per {@link #getX(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getX
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement's operand and the calculation logic of the index for mDataSamples[] has been changed. Therefore, the API's returned value will change, classifying it under change types 1 and 4.","Since the calculation logic has been altered and the offset mXOffset has been added, the returned value from the function might differ between the two versions. Thus it could lead to compatibility issues of type 1."
48,<android.database.sqlite.SQLiteStatement: long executeInsert()>,8,9,<android.database.sqlite.SQLiteStatement: long executeInsert()>,<android.database.sqlite.SQLiteStatement: long executeInsert()>,0,"{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
        return (mDatabase.lastChangeCount() > 0) ? mDatabase.lastInsertRow() : -1;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
        return (mDatabase.lastChangeCount() > 0) ? mDatabase.lastInsertRow() : -1;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement 'BlockGuard.getThreadPolicy().onWriteToDisk();' was added in the late version. So, the code change type is 4.","The added statement does not affect the return value or exception handling of this method, thus no Compatibility Issue exists. Therefore, the CI type is 0."
49,<android.webkit.WebView: void onDetachedFromWindow()>,8,9,<android.webkit.WebView: void onDetachedFromWindow()>,<android.webkit.WebView: void onDetachedFromWindow()>,0,"{
    clearTextEntry(false);
    dismissZoomControl();
    if (hasWindowFocus())
        setActive(false);
    super.onDetachedFromWindow();
}","{
    clearHelpers();
    dismissZoomControl();
    if (hasWindowFocus())
        setActive(false);
    super.onDetachedFromWindow();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method invocation has changed from 'clearTextEntry(false)' to 'clearHelpers()', so the code change type is 1,5.","As the invoked method is changed, and this method may have different internal implementation, so these changes could lead the API to potentially return different values, hence the CI type is 1."
51,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",8,9,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>","<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",0,"{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    mShowCursor = SystemClock.uptimeMillis();
    ensureEndedBatchEdit();
    if (focused) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
            boolean selMoved = mSelectionMoved;
            if (mMovement != null) {
                mMovement.onTakeFocus(this, (Spannable) mText, direction);
            }
            if (mSelectAllOnFocus) {
                Selection.setSelection((Spannable) mText, 0, mText.length());
            }
            if (selMoved && selStart >= 0 && selEnd >= 0) {
                /*
                     * Someone intentionally set the selection, so let them
                     * do whatever it is that they wanted to do instead of
                     * the default on-focus behavior.  We reset the selection
                     * here instead of just skipping the onTakeFocus() call
                     * because some movement methods do something other than
                     * just setting the selection in theirs and we still
                     * need to go through that path.
                     */
                Selection.setSelection((Spannable) mText, selStart, selEnd);
            }
            mTouchFocusSelected = true;
        }
        mFrozenWithFocus = false;
        mSelectionMoved = false;
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
        makeBlink();
        if (mError != null) {
            showError();
        }
    } else {
        if (mError != null) {
            hideError();
        }
        // Don't leave us in the middle of a batch edit.
        onEndBatchEdit();
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}","{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    mShowCursor = SystemClock.uptimeMillis();
    ensureEndedBatchEdit();
    if (focused) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
            // If a tap was used to give focus to that view, move cursor at tap position.
            // Has to be done before onTakeFocus, which can be overloaded.
            final int lastTapPosition = getLastTapPosition();
            if (lastTapPosition >= 0) {
                Selection.setSelection((Spannable) mText, lastTapPosition);
            }
            if (mMovement != null) {
                mMovement.onTakeFocus(this, (Spannable) mText, direction);
            }
            if (mSelectAllOnFocus) {
                Selection.setSelection((Spannable) mText, 0, mText.length());
            }
            // It would be better to know why the DecorView does not have focus at that time.
            if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
                /*
                     * Someone intentionally set the selection, so let them
                     * do whatever it is that they wanted to do instead of
                     * the default on-focus behavior.  We reset the selection
                     * here instead of just skipping the onTakeFocus() call
                     * because some movement methods do something other than
                     * just setting the selection in theirs and we still
                     * need to go through that path.
                     */
                Selection.setSelection((Spannable) mText, selStart, selEnd);
            }
            mTouchFocusSelected = true;
        }
        mFrozenWithFocus = false;
        mSelectionMoved = false;
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
        makeBlink();
        if (mError != null) {
            showError();
        }
    } else {
        if (mError != null) {
            hideError();
        }
        // Don't leave us in the middle of a batch edit.
        onEndBatchEdit();
        hideInsertionPointCursorController();
        if (this instanceof ExtractEditText) {
            // terminateTextSelectionMode would remove selection, which we want to keep when
            // ExtractEditText goes out of focus.
            mIsInTextSelectionMode = false;
        } else {
            terminateTextSelectionMode();
        }
        if (mSelectionModifierCursorController != null) {
            ((SelectionModifierCursorController) mSelectionModifierCursorController).resetTouchOffsets();
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"Several new statements are introduced in the 'if' branch and 'else' branch in the late version, and the control statement in if(focused) has changed, so the change type is 3,4.","Although there are changes in the code, none of them change the return value nor exception handling. So there is no compatibility issue, hence the CI type is 0."
52,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,8,9,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean startDiscovery()>,0,"{
    try {
        return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
","/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new condition statement 'if (getState() != STATE_ON)' has been added in the late version, so the code change type is 3.","The newly added condition statement 'if (getState() != STATE_ON)' could potentially change the return values when the state is not on, so the CI type is 1."
53,<android.hardware.SensorManager.ListenerDelegate: int removeSensor(Sensor)>,8,9,<android.hardware.SensorManager.ListenerDelegate: int removeSensor(Sensor)>,<android.hardware.SensorManager.ListenerDelegate: int removeSensor(Sensor)>,0,"{
    mSensors &= ~(1 << sensor.getHandle());
    mSensorList.remove(sensor);
    return mSensors;
}","{
    mSensors.delete(sensor.getHandle());
    mSensorList.remove(sensor);
    return mSensors.size();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Here, the early implementation of API uses bitwise shift operation to update 'mSensors', and returns 'mSensors'. In the later implementation 'mSensors' is updated using a 'delete' operation and 'size of mSensors' is returned. So, the pred_change is 1: 'Return statement changed' and 4: 'Other statement changed'.","The method in the early and late versions return entirely different parameters. What was previously the bitwise updated 'mSensors', is now the 'size of mSensors' in the late version. This makes the output of this function different between the two versions, leading to a compatibility issue under type 1: 'Different return values'."
54,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",8,9,"<android.widget.AbsListView: boolean trackMotionScroll(int,int)>","<android.widget.AbsListView: boolean trackMotionScroll(int,int)>",0,"{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = listPadding.top - firstTop;
    final int end = getHeight() - listPadding.bottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    if (firstPosition == 0 && firstTop >= listPadding.top && deltaY >= 0) {
        // is already visible
        return true;
    }
    if (firstPosition + childCount == mItemCount && lastBottom <= end && deltaY <= 0) {
        // is already visible
        return true;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        final int top = listPadding.top - incrementalDeltaY;
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    } else {
        final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    invalidate();
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(getChildAt(childIndex));
        }
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    awakenScrollBars();
    return false;
}","{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = listPadding.top - firstTop;
    final int end = getHeight() - listPadding.bottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - mListPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + mListPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0) {
        // is already visible
        return incrementalDeltaY != 0;
    }
    if (firstPosition + childCount == mItemCount && lastBottom <= end && incrementalDeltaY <= 0) {
        // is already visible
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        final int top = listPadding.top - incrementalDeltaY;
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    } else {
        final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    mRecycler.addScrapView(child);
                    if (ViewDebug.TRACE_RECYCLER) {
                        ViewDebug.trace(child, ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, firstPosition + i, -1);
                    }
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    invalidate();
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(getChildAt(childIndex));
        }
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    awakenScrollBars();
    return false;
}",1,"/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
","/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"New statements are introduced in the late version to update mFirstPositionDistanceGuess and mLastPositionDistanceGuess based on the condition and incrementalDeltaY. The returned boolean values in two conditional cases are changed from 'true' to 'incrementalDeltaY != 0'. So, the changes are type 3 and 4.","Because the conditional return values are changed and new variables being updated also have an impact on the function's outcome, the changes could cause the function to return a different result, leading to the CI of type 1."
55,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,8,9,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,<android.view.MotionEvent: MotionEvent obtain(MotionEvent)>,0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = o.mDeviceId;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTime = o.mDownTime;
    ev.mEventTimeNano = o.mEventTimeNano;
    ev.mAction = o.mAction;
    ev.mNumPointers = o.mNumPointers;
    ev.mRawX = o.mRawX;
    ev.mRawY = o.mRawY;
    ev.mMetaState = o.mMetaState;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    final int NS = ev.mNumSamples = o.mNumSamples;
    if (ev.mTimeSamples.length >= NS) {
        System.arraycopy(o.mTimeSamples, 0, ev.mTimeSamples, 0, NS);
    } else {
        ev.mTimeSamples = (long[]) o.mTimeSamples.clone();
    }
    final int NP = (ev.mNumPointers = o.mNumPointers);
    if (ev.mPointerIdentifiers.length >= NP) {
        System.arraycopy(o.mPointerIdentifiers, 0, ev.mPointerIdentifiers, 0, NP);
    } else {
        ev.mPointerIdentifiers = (int[]) o.mPointerIdentifiers.clone();
    }
    final int ND = NP * NS * NUM_SAMPLE_DATA;
    if (ev.mDataSamples.length >= ND) {
        System.arraycopy(o.mDataSamples, 0, ev.mDataSamples, 0, ND);
    } else {
        ev.mDataSamples = (float[]) o.mDataSamples.clone();
    }
    return ev;
}","{
    MotionEvent ev = obtain(o.mNumPointers, o.mNumSamples);
    ev.mDeviceId = o.mDeviceId;
    ev.mSource = o.mSource;
    ev.mEdgeFlags = o.mEdgeFlags;
    ev.mDownTimeNano = o.mDownTimeNano;
    ev.mAction = o.mAction;
    ev.mFlags = o.mFlags;
    ev.mMetaState = o.mMetaState;
    ev.mXOffset = o.mXOffset;
    ev.mYOffset = o.mYOffset;
    ev.mXPrecision = o.mXPrecision;
    ev.mYPrecision = o.mYPrecision;
    int numPointers = ev.mNumPointers = o.mNumPointers;
    int numSamples = ev.mNumSamples = o.mNumSamples;
    ev.mLastDataSampleIndex = o.mLastDataSampleIndex;
    ev.mLastEventTimeNanoSampleIndex = o.mLastEventTimeNanoSampleIndex;
    System.arraycopy(o.mPointerIdentifiers, 0, ev.mPointerIdentifiers, 0, numPointers);
    System.arraycopy(o.mEventTimeNanoSamples, 0, ev.mEventTimeNanoSamples, 0, numSamples);
    System.arraycopy(o.mDataSamples, 0, ev.mDataSamples, 0, numPointers * numSamples * NUM_SAMPLE_DATA);
    return ev;
}",1,"/**
 * Create a new MotionEvent, copying from an existing one.
 */
","/**
 * Create a new MotionEvent, copying from an existing one.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In this case, the early version implementation of this method and the late version implementation differ significantly. Several attributes such as mEventTimeNano, mRawX, mRawY, and mTimeSamples in the early version have been replaced by new attributes such as mSource, mDownTimeNano, mFlags, mXOffset, mYOffset, mLastDataSampleIndex, mLastEventTimeNanoSampleIndex, and mEventTimeNanoSamples in the late version. Moreover, the call to the 'obtain()' method has changed to 'obtain(o.mNumPointers, o.mNumSamples)' in the late version. This kind of a significant change type could be classified as 1 & 4 (Return statement changed & Other statement changed).","Given the substantial change in the implementation and the different attributes being set, this could likely result in a change in the return value of the method call, hence leading to Compatibility Issues. Specifically, the data values obtained from the new and modified attributes in the late version could significantly impact the values being returned by the method. Therefore, the Compatibility Issue this change may cause could be classified as type 1 (Compatibility Issue caused by potential different return values or types)."
56,"<android.os.BinderProxy: void dump(FileDescriptor,String[])>",8,9,"<android.os.BinderProxy: void dump(FileDescriptor,String[])>","<android.os.BinderProxy: void dump(FileDescriptor,String[])>",0,"{
    Parcel data = Parcel.obtain();
    data.writeFileDescriptor(fd);
    data.writeStringArray(args);
    try {
        transact(DUMP_TRANSACTION, data, null, 0);
    } finally {
        data.recycle();
    }
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeFileDescriptor(fd);
    data.writeStringArray(args);
    try {
        transact(DUMP_TRANSACTION, data, reply, 0);
        reply.readException();
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"A new statement 'Parcel reply = Parcel.obtain();' is added to the function and the 'transact()' function method parameters have changed from 'transact(DUMP_TRANSACTION, data, null, 0);' to 'transact(DUMP_TRANSACTION, data, reply, 0);'. Meanwhile, the try-catch block has been modified with a method 'reply.readException();', so the change type is 1,4.","Although the function has been modified, none of the modifications affect or change the returned values and exceptions. So the compatibility issue type is 0."
57,<android.pim.vcard.VCardEntryConstructor: void propertyValues(List<String>)>,8,9,<android.pim.vcard.VCardEntryConstructor: void propertyValues(List<String>)>,<android.pim.vcard.VCardEntryConstructor: void propertyValues(List<String>)>,0,"{
    if (values == null || values.isEmpty()) {
        return;
    }
    final Collection<String> charsetCollection = mCurrentProperty.getParameters(""CHARSET"");
    final String charset = ((charsetCollection != null) ? charsetCollection.iterator().next() : null);
    final Collection<String> encodingCollection = mCurrentProperty.getParameters(""ENCODING"");
    final String encoding = ((encodingCollection != null) ? encodingCollection.iterator().next() : null);
    String charsetForDecodedBytes = CharsetUtils.nameForDefaultVendor(charset);
    if (charsetForDecodedBytes == null || charsetForDecodedBytes.length() == 0) {
        charsetForDecodedBytes = mCharsetForDecodedBytes;
    }
    for (final String value : values) {
        mCurrentProperty.addToPropertyValueList(handleOneValue(value, charsetForDecodedBytes, encoding));
    }
}","{
    if (values == null || values.isEmpty()) {
        return;
    }
    final Collection<String> charsetCollection = mCurrentProperty.getParameters(VCardConstants.PARAM_CHARSET);
    final Collection<String> encodingCollection = mCurrentProperty.getParameters(VCardConstants.PARAM_ENCODING);
    final String encoding = ((encodingCollection != null) ? encodingCollection.iterator().next() : null);
    String targetCharset = CharsetUtils.nameForDefaultVendor(((charsetCollection != null) ? charsetCollection.iterator().next() : null));
    if (TextUtils.isEmpty(targetCharset)) {
        targetCharset = VCardConfig.DEFAULT_IMPORT_CHARSET;
    }
    for (final String value : values) {
        mCurrentProperty.addToPropertyValueList(handleOneValue(value, mSourceCharset, targetCharset, encoding));
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"Several variables have been changed including their initializations and usages, and the parameters in methods have also been changed. For example, 'mCharsetForDecodedBytes' in early version has been changed to 'VCardConfig.DEFAULT_IMPORT_CHARSET' in late version, and the method 'handleOneValue()' has one more parameter 'mSourceCharset' in late version. So the code change type is 4.","Changes in variables' initializations and their usages will cause different results when calling the method 'handleOneValue()', which will lead to different behaviours of the API. So the CI type is 1."
58,<android.app.ActivityThread.Idler: boolean queueIdle()>,8,9,<android.app.ActivityThread.Idler: boolean queueIdle()>,<android.app.ActivityThread.Idler: boolean queueIdle()>,0,"{
    ActivityRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    ensureJitEnabled();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    ensureJitEnabled();
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"There is no change on the return statements, exception handling statements, and control dependencies. However, other statements were changed. For example, the variable a, which is also instance of the dependent API ActivityRecord in the early version, was changed to ActivityClientRecord in the late version. Therefore, the code change types are 4 and 5.","The compatibility issues were not caused by these changes. The early and late versions of the API potentially throw the same exceptions and return the same results. All the changes are internal and won't affect the behavior of the API. Therefore, no compatibility issues exist with this given API."
59,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",8,9,"<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.Touch: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    DragState[] ds;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}","{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}",1,"/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
","/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 4",1,"The switch condition statement change from event.getAction() to event.getActionMasked(). This implies a control dependency change (type 3). At the same time, the use of a different method implies an other statement change (type 4).","The change in the switch condition statement can cause the onTouchEvent method to behave differently (returning potentially different results) between the two versions due to the fact that the event.getActionMasked() can return more possible flags than event.getAction(). Therefore, the type of Compatibility Issue is 1 (potential different return values or types)."
60,<android.os.Vibrator: void cancel()>,8,9,<android.os.Vibrator: void cancel()>,<android.os.Vibrator: void cancel()>,0,"{
    try {
        mService.cancelVibrate(mToken);
    } catch (RemoteException e) {
    }
}","{
    if (mService == null) {
        return;
    }
    try {
        mService.cancelVibrate(mToken);
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed to cancel vibration."", e);
    }
}",1,"/**
 * Turn the vibrator off.
 */
","/**
 * Turn the vibrator off.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",1,"In the latest implementation version, a new 'if' condition statement has been introduced and a new exception handling statement inserted (Log.w(TAG, ""Failed to cancel vibration."", e)), so the code change type is 2,3.","In the latest version, the API might not execute the cancelVibrate() method due to the new introduced 'if' condition. Also, the newly introduced 'Log' statement in the exception handling might have different behaviour, this influences the way API reports on encountering exceptions. Thus, the CI type is 1."
62,<android.text.method.ArrowKeyMovementMethod: MovementMethod getInstance()>,8,9,<android.text.method.ArrowKeyMovementMethod: MovementMethod getInstance()>,<android.text.method.ArrowKeyMovementMethod: MovementMethod getInstance()>,0,"{
    if (sInstance == null)
        sInstance = new ArrowKeyMovementMethod();
    return sInstance;
}","{
    if (sInstance == null) {
        sInstance = new ArrowKeyMovementMethod();
    }
    return sInstance;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,0,0,"The two versions of code are logically identical, only the presentation of the code block 'if' has been modified but it doesn't change any statement or controlling dependencies, therefore no code changes have happened.","As there has been no changes to the code, there is no Compatibility Issue."
63,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",8,9,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>","<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",0,"{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20;
            break;
        case SENSOR_DELAY_UI:
            delay = 60;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200;
            break;
        default:
            return false;
    }
    try {
        synchronized (sListeners) {
            ListenerDelegate l = null;
            for (ListenerDelegate i : sListeners) {
                if (i.getListener() == listener) {
                    l = i;
                    break;
                }
            }
            String name = sensor.getName();
            int handle = sensor.getHandle();
            if (l == null) {
                result = false;
                l = new ListenerDelegate(listener, sensor, handler);
                sListeners.add(l);
                if (!sListeners.isEmpty()) {
                    result = sSensorThread.startLocked(mSensorService);
                    if (result) {
                        result = mSensorService.enableSensor(l, name, handle, delay);
                        if (!result) {
                            // there was an error, remove the listeners
                            sListeners.remove(l);
                        }
                    }
                }
            } else {
                result = mSensorService.enableSensor(l, name, handle, delay);
                if (result) {
                    l.addSensor(sensor);
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""RemoteException in registerListener: "", e);
        result = false;
    }
    return result;
}","{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result = true;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 60000;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    synchronized (sListeners) {
        // look for this listener in our list
        ListenerDelegate l = null;
        for (ListenerDelegate i : sListeners) {
            if (i.getListener() == listener) {
                l = i;
                break;
            }
        }
        // if we don't find it, add it to the list
        if (l == null) {
            l = new ListenerDelegate(listener, sensor, handler);
            sListeners.add(l);
            // if the list is not empty, start our main thread
            if (!sListeners.isEmpty()) {
                if (sSensorThread.startLocked()) {
                    if (!enableSensorLocked(sensor, delay)) {
                        // oops. there was an error
                        sListeners.remove(l);
                        result = false;
                    }
                } else {
                    // there was an error, remove the listener
                    sListeners.remove(l);
                    result = false;
                }
            } else {
                // weird, we couldn't add the listener
                result = false;
            }
        } else {
            l.addSensor(sensor);
            if (!enableSensorLocked(sensor, delay)) {
                // oops. there was an error
                l.removeSensor(sensor);
                result = false;
            }
        }
    }
    return result;
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener SensorEventListener}
 * for the given sensor.
 *
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.
 * This is only a hint to the system. Events may be received faster or
 * slower than the specified rate. Usually events are received faster. The value must be one
 * of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI}, {@link #SENSOR_DELAY_GAME}, or
 * {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microsecond.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control structures have changed. For instance, the switch-case construct has a new 'default' case, the 'synchronized' block's contents have been modified significantly. The value assigned to 'result' at the beginning has also changed (from 'false' to 'true') and a new variable assignment ('delay = rate') in the switch construct. The RemoteException handling block is removed in the late version too. So the types 1,3,4 apply.","The modifications within the 'synchronized' block and the change in the initial 'result' value assignment are capable of causing this method to return different outcomes in different versions. There's also a change in the delay calculation for certain sensor delay cases (which impacts the behaviour of enabling the sensor) in the switch construct. Thus, the type 1 applies, indicating a Compatibility Issue due to potentially different return values or types."
64,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,8,9,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event)) {
        return true;
    }
    return onTouchEvent(event);
}","{
    if (!onFilterTouchEventForSecurity(event)) {
        return false;
    }
    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event)) {
        return true;
    }
    return onTouchEvent(event);
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A new condition branch and a return statement have been introduced (if (!onFilterTouchEventForSecurity(event)) return false;), so the code change type is 1,3.","The new control dependency potentially leads the API to return false, which is different from the original version. This could potentially lead to a compatibility issue. Thus, the CI type is 1."
65,<android.app.ActivityThread.H: String codeToString(int)>,8,9,<android.app.ActivityThread.H: String codeToString(int)>,<android.app.ActivityThread.H: String codeToString(int)>,0,"{
    if (localLOGV) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
        }
    }
    return ""(unknown)"";
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
        }
    }
    return ""(unknown)"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The condition of the 'if' statement has changed, and a new 'return' statement has been added under the 'switch' statement, so the code change type is 1,3.","Since a new 'return' statement ""case SCHEDULE_CRASH: return ""SCHEDULE_CRASH"";"" has been introduced in the later version which is not present in the earlier version, the API would return a potentially different value when the 'code' parameter is 'SCHEDULE_CRASH'. Therefore, the CI type is 1."
67,<android.view.MotionEvent: float getX(int)>,8,9,<android.view.MotionEvent: float getX(int)>,<android.view.MotionEvent: float getX(int)>,0,"{
    return mDataSamples[(pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_X];
}","{
    return mDataSamples[mLastDataSampleIndex + pointerIndex * NUM_SAMPLE_DATA + SAMPLE_X] + mXOffset;
}",1,"/**
 * Returns the X coordinate of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
","/**
 * Returns the X coordinate of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The method changes from returning mDataSamples[(pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_X] to returning mDataSamples[mLastDataSampleIndex + pointerIndex * NUM_SAMPLE_DATA + SAMPLE_X] + mXOffset, and it doesn't reference any other APIs. Therefore, the code change type is classified as 1.","As the return statement has changed, it is likely that this method will return a different value when invoked. Therefore, this is a type 1 Compatibility Issue."
68,<android.pim.vcard.VCardEntryCommitter: void onEntryCreated(VCardEntry)>,8,9,<android.pim.vcard.VCardEntryCommitter: void onEntryCreated(VCardEntry)>,<android.pim.vcard.VCardEntryCommitter: void onEntryCreated(VCardEntry)>,0,"{
    long start = System.currentTimeMillis();
    mCreatedUris.add(contactStruct.pushIntoContentResolver(mContentResolver));
    mTimeToCommit += System.currentTimeMillis() - start;
}","{
    long start = System.currentTimeMillis();
    mCreatedUris.add(vcardEntry.pushIntoContentResolver(mContentResolver));
    mTimeToCommit += System.currentTimeMillis() - start;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The parameter of the method pushIntoContentResolver() has changed, so the code change type is 4,5.","The change doesn't affect the return value or the exceptions of the method, so no CI was detected, that is the CI type is 0."
70,<com.google.android.mms.pdu.PduParser: GenericPdu parse()>,8,9,<com.google.android.mms.pdu.PduParser: GenericPdu parse()>,<com.google.android.mms.pdu.PduParser: GenericPdu parse()>,0,"{
    if (mPduDataStream == null) {
        return null;
    }
    /* parse headers */
    mHeaders = parseHeaders(mPduDataStream);
    if (null == mHeaders) {
        // Parse headers failed.
        return null;
    }
    /* get the message type */
    int messageType = mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
    /* check mandatory header fields */
    if (false == checkMandatoryHeader(mHeaders)) {
        log(""check mandatory headers failed!"");
        return null;
    }
    if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
        /* need to parse the parts */
        mBody = parseParts(mPduDataStream);
        if (null == mBody) {
            // Parse parts failed.
            return null;
        }
    }
    switch(messageType) {
        case PduHeaders.MESSAGE_TYPE_SEND_REQ:
            SendReq sendReq = new SendReq(mHeaders, mBody);
            return sendReq;
        case PduHeaders.MESSAGE_TYPE_SEND_CONF:
            SendConf sendConf = new SendConf(mHeaders);
            return sendConf;
        case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            NotificationInd notificationInd = new NotificationInd(mHeaders);
            return notificationInd;
        case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
            NotifyRespInd notifyRespInd = new NotifyRespInd(mHeaders);
            return notifyRespInd;
        case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
            RetrieveConf retrieveConf = new RetrieveConf(mHeaders, mBody);
            byte[] contentType = retrieveConf.getContentType();
            if (null == contentType) {
                return null;
            }
            String ctTypeStr = new String(contentType);
            if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED)) {
                // or ""application/vnd.wap.multipart.related""
                return retrieveConf;
            }
            return null;
        case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
            DeliveryInd deliveryInd = new DeliveryInd(mHeaders);
            return deliveryInd;
        case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
            AcknowledgeInd acknowledgeInd = new AcknowledgeInd(mHeaders);
            return acknowledgeInd;
        case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
            ReadOrigInd readOrigInd = new ReadOrigInd(mHeaders);
            return readOrigInd;
        case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
            ReadRecInd readRecInd = new ReadRecInd(mHeaders);
            return readRecInd;
        default:
            log(""Parser doesn't support this message type in this version!"");
            return null;
    }
}","{
    if (mPduDataStream == null) {
        return null;
    }
    /* parse headers */
    mHeaders = parseHeaders(mPduDataStream);
    if (null == mHeaders) {
        // Parse headers failed.
        return null;
    }
    /* get the message type */
    int messageType = mHeaders.getOctet(PduHeaders.MESSAGE_TYPE);
    /* check mandatory header fields */
    if (false == checkMandatoryHeader(mHeaders)) {
        log(""check mandatory headers failed!"");
        return null;
    }
    if ((PduHeaders.MESSAGE_TYPE_SEND_REQ == messageType) || (PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF == messageType)) {
        /* need to parse the parts */
        mBody = parseParts(mPduDataStream);
        if (null == mBody) {
            // Parse parts failed.
            return null;
        }
    }
    switch(messageType) {
        case PduHeaders.MESSAGE_TYPE_SEND_REQ:
            SendReq sendReq = new SendReq(mHeaders, mBody);
            return sendReq;
        case PduHeaders.MESSAGE_TYPE_SEND_CONF:
            SendConf sendConf = new SendConf(mHeaders);
            return sendConf;
        case PduHeaders.MESSAGE_TYPE_NOTIFICATION_IND:
            NotificationInd notificationInd = new NotificationInd(mHeaders);
            return notificationInd;
        case PduHeaders.MESSAGE_TYPE_NOTIFYRESP_IND:
            NotifyRespInd notifyRespInd = new NotifyRespInd(mHeaders);
            return notifyRespInd;
        case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:
            RetrieveConf retrieveConf = new RetrieveConf(mHeaders, mBody);
            byte[] contentType = retrieveConf.getContentType();
            if (null == contentType) {
                return null;
            }
            String ctTypeStr = new String(contentType);
            if (ctTypeStr.equals(ContentType.MULTIPART_MIXED) || ctTypeStr.equals(ContentType.MULTIPART_RELATED) || ctTypeStr.equals(ContentType.MULTIPART_ALTERNATIVE)) {
                // or ""application/vnd.wap.multipart.alternative""
                return retrieveConf;
            }
            return null;
        case PduHeaders.MESSAGE_TYPE_DELIVERY_IND:
            DeliveryInd deliveryInd = new DeliveryInd(mHeaders);
            return deliveryInd;
        case PduHeaders.MESSAGE_TYPE_ACKNOWLEDGE_IND:
            AcknowledgeInd acknowledgeInd = new AcknowledgeInd(mHeaders);
            return acknowledgeInd;
        case PduHeaders.MESSAGE_TYPE_READ_ORIG_IND:
            ReadOrigInd readOrigInd = new ReadOrigInd(mHeaders);
            return readOrigInd;
        case PduHeaders.MESSAGE_TYPE_READ_REC_IND:
            ReadRecInd readRecInd = new ReadRecInd(mHeaders);
            return readRecInd;
        default:
            log(""Parser doesn't support this message type in this version!"");
            return null;
    }
}",1,"/**
 * Parse the pdu.
 *
 * @return the pdu structure if parsing successfully.
 * null if parsing error happened or mandatory fields are not set.
 */
","/**
 * Parse the pdu.
 *
 * @return the pdu structure if parsing successfully.
 * null if parsing error happened or mandatory fields are not set.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The if condition in the ""case PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF:"" of the switch statement has changed which will return retrieveConf in an additional scenario, so the code change type is 1,3.","The change in the if condition can alter the return value of the function, especially for the case 'PduHeaders.MESSAGE_TYPE_RETRIEVE_CONF', which can potentially return different results in the late version. Therefore, the CI type is 1."
71,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,8,9,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,<android.database.sqlite.SQLiteStatement: String simpleQueryForString()>,0,"{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        String retValue = native_1x1_string();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onReadFromDisk();
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        String retValue = native_1x1_string();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a text value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement BlockGuard.getThreadPolicy().onReadFromDisk() has been added in the code, so the code change type is 4.","The added statement does not modify any possible return values, nor does it introduce any exception handling differences. Therefore, there is no Compatibility Issue, and the CI type is 0."
72,<android.widget.GridView: int computeVerticalScrollRange()>,8,9,<android.widget.GridView: int computeVerticalScrollRange()>,<android.widget.GridView: int computeVerticalScrollRange()>,0,"{
    // TODO: Account for vertical spacing too
    final int numColumns = mNumColumns;
    final int rowCount = (mItemCount + numColumns - 1) / numColumns;
    return Math.max(rowCount * 100, 0);
}","{
    // TODO: Account for vertical spacing too
    final int numColumns = mNumColumns;
    final int rowCount = (mItemCount + numColumns - 1) / numColumns;
    int result = Math.max(rowCount * 100, 0);
    if (mScrollY != 0) {
        // Compensate for overscroll
        result += Math.abs((int) ((float) mScrollY / getHeight() * rowCount * 100));
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduced a new condition statement (if (mScrollY != 0)) and a new assignment statement for 'result'. Therefore, the code change type is 1,3.","The new assignment statement to 'result' inside the condition block introduced in the late version could lead to a different return value in case 'mScrollY' is not zero. So, the CI type is 1."
73,<android.hardware.SensorManager.ListenerDelegate: boolean hasSensor(Sensor)>,8,9,<android.hardware.SensorManager.ListenerDelegate: boolean hasSensor(Sensor)>,<android.hardware.SensorManager.ListenerDelegate: boolean hasSensor(Sensor)>,0,"{
    return ((mSensors & (1 << sensor.getHandle())) != 0);
}","{
    return mSensors.get(sensor.getHandle());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The return statements in both versions are different as well as the method used on mSensors object has changed from a bitwise operation to a get() method. This indicates a change in dependent API.,"The change in the return statement means this API might return different values when invoked in the early and late versions, and thus may cause a compatibility issue of type 1."
74,"<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>",8,9,"<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>","<android.widget.TextView: boolean onKeyShortcut(int,KeyEvent)>",0,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_A:
            if (canSelectAll()) {
                return onTextContextMenuItem(ID_SELECT_ALL);
            }
            break;
        case KeyEvent.KEYCODE_X:
            if (canCut()) {
                return onTextContextMenuItem(ID_CUT);
            }
            break;
        case KeyEvent.KEYCODE_C:
            if (canCopy()) {
                return onTextContextMenuItem(ID_COPY);
            }
            break;
        case KeyEvent.KEYCODE_V:
            if (canPaste()) {
                return onTextContextMenuItem(ID_PASTE);
            }
            break;
    }
    return super.onKeyShortcut(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_A:
            if (canSelectText()) {
                return onTextContextMenuItem(ID_SELECT_ALL);
            }
            break;
        case KeyEvent.KEYCODE_X:
            if (canCut()) {
                return onTextContextMenuItem(ID_CUT);
            }
            break;
        case KeyEvent.KEYCODE_C:
            if (canCopy()) {
                return onTextContextMenuItem(ID_COPY);
            }
            break;
        case KeyEvent.KEYCODE_V:
            if (canPaste()) {
                return onTextContextMenuItem(ID_PASTE);
            }
            break;
    }
    return super.onKeyShortcut(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,5",1,"There is a change in the conditional statement and the method it calls (from canSelectAll() to canSelectText()). So, the types of changes are classified as 1 (return statement changed), 3 (control dependency change), and 5 (dependent API changed).","The change could potentially lead the API to return a different value as the condition and method for the case KeyEvent.KEYCODE_A has changed. Therefore, the type of Compatibility Issue identified is 1 (Compatibility Issue caused by potential different return values or types)."
75,<android.widget.TextView: boolean bringPointIntoView(int)>,8,9,<android.widget.TextView: boolean bringPointIntoView(int)>,<android.widget.TextView: boolean bringPointIntoView(int)>,0,"{
    boolean changed = false;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_NORMAL:
            grav = 1;
            break;
        case ALIGN_OPPOSITE:
            grav = -1;
            break;
        default:
            grav = 0;
    }
    grav *= mLayout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // This offsets because getInterestingRect() is in terms of
        // viewport coordinates, but requestRectangleOnScreen()
        // is in terms of content coordinates.
        Rect r = new Rect();
        getInterestingRect(r, x, top, bottom, line);
        r.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(r)) {
            changed = true;
        }
    }
    return changed;
}","{
    boolean changed = false;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_NORMAL:
            grav = 1;
            break;
        case ALIGN_OPPOSITE:
            grav = -1;
            break;
        default:
            grav = 0;
    }
    grav *= mLayout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // This offsets because getInterestingRect() is in terms of
        // viewport coordinates, but requestRectangleOnScreen()
        // is in terms of content coordinates.
        Rect r = new Rect(x, top, x + 1, bottom);
        getInterestingRect(r, line);
        r.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(r)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The statement ""Rect r = new Rect();"" in the early version has been changed to ""Rect r = new Rect(x, top, x + 1, bottom);"" in the late version. Hence, the code change category is 3 (Control dependency change).","Given that the initialization of the ""Rect r"" object is changed, it may potentially influence the computation of getInterestingRect(r, line) and requestRectangleOnScreen(r), and thereby alter the returned boolean value of the method bringPointIntoView(int). This can cause a Compatibility Issue of type 1 (provoked by potential different return values)."
77,<android.webkit.WebView: void onDraw(Canvas)>,8,9,<android.webkit.WebView: void onDraw(Canvas)>,<android.webkit.WebView: void onDraw(Canvas)>,0,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    int saveCount = canvas.save();
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null) {
        drawContent(canvas);
    } else {
        if (!mDragTrackerHandler.draw(canvas)) {
            // sometimes the tracker doesn't draw, even though its active
            drawContent(canvas);
        }
        if (mDragTrackerHandler.isFinished()) {
            mDragTrackerHandler = null;
        }
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    int titleH = getVisibleTitleHeight();
    if (mTitleBar != null && titleH == 0) {
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, mScrollY, mScrollX + getWidth(), mScrollY + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
}","{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        if (mOverScrollBackground == null) {
            mOverScrollBackground = new Paint();
            Bitmap bm = BitmapFactory.decodeResource(mContext.getResources(), com.android.internal.R.drawable.status_bar_background);
            mOverScrollBackground.setShader(new BitmapShader(bm, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
            mOverScrollBorder = new Paint();
            mOverScrollBorder.setStyle(Paint.Style.STROKE);
            mOverScrollBorder.setStrokeWidth(0);
            mOverScrollBorder.setColor(0xffbbbbbb);
        }
        int top = 0;
        int right = computeRealHorizontalScrollRange();
        int bottom = top + computeRealVerticalScrollRange();
        // first draw the background and anchor to the top of the view
        canvas.save();
        canvas.translate(mScrollX, mScrollY);
        canvas.clipRect(-mScrollX, top - mScrollY, right - mScrollX, bottom - mScrollY, Region.Op.DIFFERENCE);
        canvas.drawPaint(mOverScrollBackground);
        canvas.restore();
        // then draw the border
        canvas.drawRect(-1, top - 1, right, bottom, mOverScrollBorder);
        // next clip the region for the content
        canvas.clipRect(0, top, right, bottom);
    }
    if (mTitleBar != null) {
        canvas.translate(0, (int) mTitleBar.getHeight());
    }
    if (mDragTrackerHandler == null) {
        drawContent(canvas);
    } else {
        if (!mDragTrackerHandler.draw(canvas)) {
            // sometimes the tracker doesn't draw, even though its active
            drawContent(canvas);
        }
        if (mDragTrackerHandler.isFinished()) {
            mDragTrackerHandler = null;
        }
    }
    canvas.restoreToCount(saveCount);
    // Now draw the shadow.
    int titleH = getVisibleTitleHeight();
    if (mTitleBar != null && titleH == 0) {
        int height = (int) (5f * getContext().getResources().getDisplayMetrics().density);
        mTitleShadow.setBounds(mScrollX, mScrollY, mScrollX + getWidth(), mScrollY + height);
        mTitleShadow.draw(canvas);
    }
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    if (inEditingMode()) {
        mWebTextView.onDrawSubstitute();
    }
    mWebViewCore.signalRepaintDone();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The late version of the code has new condition statements and multiple statements about the ""mOverScrollBackground"", ""mOverScrollBorder"" and an additional method call ""mWebTextView.onDrawSubstitute()"". So the change type is 3,4.","While the code changes, it doesn't appear to result in different returns or different exceptions thrown by the API between the two versions and hence there is no compatibility issue (CI type 0). The changes are strictly internal and do not affect the external view of the API behaviour."
78,<android.view.MotionEvent: float getHistoricalY(int)>,8,9,<android.view.MotionEvent: float getHistoricalY(int)>,<android.view.MotionEvent: float getHistoricalY(int)>,0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_Y];
}","{
    return mDataSamples[pos * mNumPointers * NUM_SAMPLE_DATA + SAMPLE_Y] + mYOffset;
}",1,"/**
 * {@link #getHistoricalY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getHistoricalY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The formula used to calculate the return value has been adjusted, hence both the return statement and other statements have changed, resulting in the code change type of 1,4.","The amendment of the formula used in the return statement will cause the API to potentially return a different value, so the CI type is 1."
82,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",8,9,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new ActivityThread.PackageInfo.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true);
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"In both the early and late implementations, there are changes in the class initialization. In the early version, `new ActivityThread.PackageInfo.ReceiverDispatcher` was used, while in the late version, `new LoadedApk.ReceiverDispatcher` was used. However, these instances are used inside the same method `getIIntentReceiver()`, suggesting the changes are classified into class 4 (Other statement changed) and 5 (Dependent API changed).","Although the class from which the object is being created has changed, the method `getIIntentReceiver()` being called on these newly created objects remains the same. Thus, it can be concluded that the behavior and outputs of the API method are likely to remain consistent across versions, meaning there are no compatibility issues (Class 0)."
83,<android.pim.vcard.VCardBuilder: VCardBuilder appendNickNames(List<ContentValues>)>,8,9,<android.pim.vcard.VCardBuilder: VCardBuilder appendNickNames(List<ContentValues>)>,<android.pim.vcard.VCardBuilder: VCardBuilder appendNickNames(List<ContentValues>)>,0,"{
    final boolean useAndroidProperty;
    if (mIsV30) {
        useAndroidProperty = false;
    } else if (mUsesAndroidProperty) {
        useAndroidProperty = true;
    } else {
        // There's no way to add this field.
        return this;
    }
    if (contentValuesList != null) {
        for (ContentValues contentValues : contentValuesList) {
            final String nickname = contentValues.getAsString(Nickname.NAME);
            if (TextUtils.isEmpty(nickname)) {
                continue;
            }
            if (useAndroidProperty) {
                appendAndroidSpecificProperty(Nickname.CONTENT_ITEM_TYPE, contentValues);
            } else {
                appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_NICKNAME, nickname);
            }
        }
    }
    return this;
}","{
    final boolean useAndroidProperty;
    if (mIsV30OrV40) {
        // These specifications have NICKNAME property.
        useAndroidProperty = false;
    } else if (mUsesAndroidProperty) {
        useAndroidProperty = true;
    } else {
        // There's no way to add this field.
        return this;
    }
    if (contentValuesList != null) {
        for (ContentValues contentValues : contentValuesList) {
            final String nickname = contentValues.getAsString(Nickname.NAME);
            if (TextUtils.isEmpty(nickname)) {
                continue;
            }
            if (useAndroidProperty) {
                appendAndroidSpecificProperty(Nickname.CONTENT_ITEM_TYPE, contentValues);
            } else {
                appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_NICKNAME, nickname);
            }
        }
    }
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,The condition for assigning the 'useAndroidProperty' value has changed from 'mIsV30' to 'mIsV30OrV40' which means the control dependency has changed. So the code change type is 3.,"Due to the condition change in assigning the 'useAndroidProperty' value, the variable could be different which could potentially result in a different return 'this' object, so the CI type is 1."
84,<android.util.Base64InputStream: int read()>,8,9,<android.util.Base64InputStream: int read()>,<android.util.Base64InputStream: int read()>,0,"{
    if (outputStart >= outputEnd) {
        refill();
    }
    if (outputStart >= outputEnd) {
        return -1;
    } else {
        return coder.output[outputStart++];
    }
}","{
    if (outputStart >= outputEnd) {
        refill();
    }
    if (outputStart >= outputEnd) {
        return -1;
    } else {
        return coder.output[outputStart++] & 0xff;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement in the 'else' block has been changed with an added bitwise AND operation, so the code change type is 1.",The added operation in the return statement will potentially cause the API to return a different value. Hence the Compatibility Issue (CI) type is 1.
85,<android.view.MotionEvent: long getEventTime()>,8,9,<android.view.MotionEvent: long getEventTime()>,<android.view.MotionEvent: long getEventTime()>,0,"{
    return mTimeSamples[0];
}","{
    return mEventTimeNanoSamples[mLastEventTimeNanoSampleIndex] / MS_PER_NS;
}",1,"/**
 * Returns the time (in ms) when this specific event was generated.
 */
","/**
 * Returns the time (in ms) when this specific event was generated.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from mTimeSamples[0] to mEventTimeNanoSamples[mLastEventTimeNanoSampleIndex] / MS_PER_NS and also the variables on which the return statement relies has also changed, so the code change type is 1,5.","The return statement change will lead the API to return a differnent values. Thus, the CI type is 1."
88,<android.content.ContentResolver: String getType(Uri)>,8,9,<android.content.ContentResolver: String getType(Uri)>,<android.content.ContentResolver: String getType(Uri)>,0,"{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getType(url);
    } catch (RemoteException e) {
        return null;
    } catch (java.lang.Exception e) {
        return null;
    } finally {
        releaseProvider(provider);
    }
}","{
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url);
        return type;
    } catch (RemoteException e) {
        return null;
    }
}",1,"/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
","/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method within the 'try' block has changed from 'acquireProvider(url)' to 'acquireExistingProvider(url)', which is a dependent API change (5). Additionally, a new if statement checking whether '!SCHEME_CONTENT.equals(url.getScheme())' is true or false has been added, this indicates a control dependency change (3). Finally, a new return statement 'return type' is present in the late version within a try-catch block, indicating a return statement changed (1).","Because of the introduced control dependency and the change in the dependent API, the return value of the function 'getType(Uri)' could potentially be different, which means there is a compatibility issue caused by potential different return values (1)."
89,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",8,9,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>","<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",0,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                }
            case TOKEN_CONTACT_LOOKUP_AND_TRIGGER:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(CONTACT_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(CONTACT_LOOKUPKEY_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                        trigger = true;
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger track
        trigger(lookupUri);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_CONTACT_LOOKUP_AND_TRIGGER:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(CONTACT_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(CONTACT_LOOKUPKEY_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                        trigger = true;
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger track
        trigger(lookupUri);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"Only the comment ""// $FALL-THROUGH$"" was introduced in two switch case blocks in the late implementation. This doesn't change the actual code but serves to document the control flow and makes it more explicit that it's intentional for the control flow to fall through from one case block to the next. So the code change type is 3.","However, this code change doesn't change the actual control flow and doesn't lead to a Compatibility Issue, thus the CI type is 0."
90,<android.view.MotionEvent: float getY()>,8,9,<android.view.MotionEvent: float getY()>,<android.view.MotionEvent: float getY()>,0,"{
    return mDataSamples[SAMPLE_Y];
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_Y] + mYOffset;
}",1,"/**
 * {@link #getY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getY(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The computation logic inside the 'return' statement has been modified, which falls under the category of 'Return statement changed', hence code change type is 1.","The change in implementation will lead the API to potentially return a different value, hence Compatibility Issue (CI) type is 1, which is 'Compatibility Issue caused by potential different return values or types'."
91,"<android.util.Log: int wtf(String,String,Throwable)>",8,9,"<android.util.Log: int wtf(String,String,Throwable)>","<android.util.Log: int wtf(String,String,Throwable)>",0,"{
    tr = new TerribleFailure(msg, tr);
    int bytes = println_native(LOG_ID_MAIN, ASSERT, tag, getStackTraceString(tr));
    RuntimeInit.wtf(tag, tr);
    return bytes;
}","{
    TerribleFailure what = new TerribleFailure(msg, tr);
    int bytes = println_native(LOG_ID_MAIN, ASSERT, tag, getStackTraceString(tr));
    sWtfHandler.onTerribleFailure(tag, what);
    return bytes;
}",1,"/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
","/**
 * What a Terrible Failure: Report an exception that should never happen.
 * Similar to {@link #wtf(String, Throwable)}, with a message as well.
 * @param tag Used to identify the source of a log message.
 * @param msg The message you would like logged.
 * @param tr An exception to log.  May be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The name of the variable that is being instantiated from ""TerribleFailure"" class has been changed from ""tr"" to ""what"". The method from ""RuntimeInit"" class, ""wtf"", is replaced with ""onTerribleFailure"" method from ""sWtfHandler"". The parameters passed to these methods also changed. So, the code change types are 1,4,5.","As the return statement does not change, but the way in which it calculates the return value (bytes) has been modified, this could potentially lead to different return values between the two versions, therefore the CI type is 1."
92,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,8,9,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        final int y = (int) ev.getY(pointerIndex);
                        if (startScrollIfNeeded(y - mMotionY)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        final int y = (int) ev.getY(pointerIndex);
                        if (startScrollIfNeeded(y - mMotionY)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"Firstly, in the 'ACTION_DOWN' case within the switch statement, an if block is introduced changing the behavior of the function. Also inside the 'ACTION_DOWN' case, a variable initialization statement 'mMotionCorrection = 0;' is added. Therefore, the change types are 1 (Return statement changed) and 3 (Control dependency changed).","The introduction of the new if block can cause the function to return true instead of proceeding to latter logic, thus changing the output of the function. Therefore, the CI type is 1."
93,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",8,9,"<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>","<android.provider.Settings.Secure: boolean isLocationProviderEnabled(ContentResolver,String)>",0,"{
    String allowedProviders = Settings.Secure.getString(cr, LOCATION_PROVIDERS_ALLOWED);
    if (allowedProviders != null) {
        return (allowedProviders.equals(provider) || allowedProviders.contains("","" + provider + "","") || allowedProviders.startsWith(provider + "","") || allowedProviders.endsWith("","" + provider));
    }
    return false;
}","{
    String allowedProviders = Settings.Secure.getString(cr, LOCATION_PROVIDERS_ALLOWED);
    return TextUtils.delimitedStringContains(allowedProviders, ',', provider);
}",1,"/**
 * Helper method for determining if a location provider is enabled.
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 */
","/**
 * Helper method for determining if a location provider is enabled.
 * @param cr the content resolver to use
 * @param provider the location provider to query
 * @return true if the provider is enabled
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement in the ""if"" condition and the condition itself were deleted, and a new return statement was introduced. Therefore, the change can be classified as 'Return statement changed' and 'Dependent API changed', hence the types 1,5.","The late version has changed the logic of checking whether a provider is available under the set of allowed providers. It now uses the method, TextUtils.delimitedStringContains(). Because this change results in different return results, it can cause compatibility issues, resulting in potential different return values. Hence, this is a 'Compatibility Issue caused by potential different return values or types', i.e., type 1."
94,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,8,9,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,0,"{
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"A new case statement ""DO_FINISH_SESSION"" has been added, and the return statement has been changed in the switch-case block, so the code change type is 3,1.","The additional case ""DO_FINISH_SESSION"" potentially changes the returned value of the switch-case block, causing the API to behave differently, thus the CI type is 1."
95,<android.webkit.WebView: boolean performLongClick()>,8,9,<android.webkit.WebView: boolean performLongClick()>,<android.webkit.WebView: boolean performLongClick()>,0,"{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    }
    if (inEditingMode()) {
        return mWebTextView.performLongClick();
    } else {
        return super.performLongClick();
    }
}","{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    } else {
        clearTextEntry(true);
    }
    if (inEditingMode()) {
        return mWebTextView.performLongClick();
    }
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (super.performLongClick()) {
        return true;
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    int x = viewToContentX((int) mLastTouchX + mScrollX);
    int y = viewToContentY((int) mLastTouchY + mScrollY);
    setUpSelect();
    if (mNativeClass != 0 && nativeWordSelection(x, y)) {
        nativeSetExtendSelection();
        WebChromeClient client = getWebChromeClient();
        if (client != null)
            client.onSelectionStart(this);
        return true;
    }
    notifySelectDialogDismissed();
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control flow within the function implementation has changed. Specifically, the 'if' condition related to nativeCursorIsTextInput() has been altered, with corresponding control blocks added, altered or removed. This points to control dependency changes. Additionally, the new implementation has added several statements related to text selection, which corresponds to other statement changes. Therefore, the code change types are 3 and 4.","The changes in control flow and new code statements potentially affect the returned result of the method. Specifically, whether it returns 'true' or 'false' (returning successful or unsuccessful long click operations) can differ based on the new control flows and added logic in the late implementation. Therefore, the CI type is 1 indicating potential differences in return values."
98,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,8,9,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!(mIsBeingDragged = inChild((int) x, (int) ev.getY()))) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                scrollBy(deltaX, 0);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0 && Math.abs(initialVelocity) > mMinimumVelocity) {
                    fling(-initialVelocity);
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                mIsBeingDragged = true;
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                final int overscrollMode = getOverScrollMode();
                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0)) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        final int right = getScrollRange();
                        if (mScroller.springBack(mScrollX, mScrollY, 0, right, 0, 0)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Several changes happened in this case. The condition of setting 'mIsBeingDragged' is replaced with a direct assignment in case 'MotionEvent.ACTION_DOWN'. Also, few lines of logic have been added under case 'MotionEvent.ACTION_MOVE' and 'MotionEvent.ACTION_UP'. 'mEdgeGlowRight.onRelease()', 'mEdgeGlowLeft.onRelease()', 'mEdgeGlowLeft.onPull((float) deltaX / getWidth())', 'mEdgeGlowRight.onPull((float) deltaX / getWidth())' are added in 'MotionEvent.ACTION_MOVE'. So the code change type is 3,4.","These change, including the added new lines, may lead the API to return a different result or throw a different exception, potentially causing a CI. Thus, the CI type is 1."
99,<android.pim.vcard.VCardComposer.HandlerForOutputStream: void onTerminate()>,8,9,<android.pim.vcard.VCardComposer.HandlerForOutputStream: void onTerminate()>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: void onTerminate()>,0,"{
    mOnTerminateIsCalled = true;
    if (mWriter != null) {
        try {
            // Flush and sync the data so that a user is able to pull
            // the SDCard just after
            // the export.
            mWriter.flush();
            if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
                ((FileOutputStream) mOutputStream).getFD().sync();
            }
        } catch (IOException e) {
            Log.d(LOG_TAG, ""IOException during closing the output stream: "" + e.getMessage());
        } finally {
            try {
                mWriter.close();
            } catch (IOException e) {
            }
        }
    }
}","{
    mOnTerminateIsCalled = true;
    if (mWriter != null) {
        try {
            // Flush and sync the data so that a user is able to pull
            // the SDCard just after
            // the export.
            mWriter.flush();
            if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
                ((FileOutputStream) mOutputStream).getFD().sync();
            }
        } catch (IOException e) {
            Log.d(LOG_TAG, ""IOException during closing the output stream: "" + e.getMessage());
        } finally {
            closeOutputStream();
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change is that the method of 'try mWriter.close();' is replaced by 'closeOutputStream();'. Both methods have the similar purpose, it seems that the try-catch block is encapsulated in closeOutputStream method in the late version.",There is no Compatibility Issue since this change does not lead to return different variables or handle exceptions differently.
101,<android.widget.TextView: boolean onPreDraw()>,8,9,<android.widget.TextView: boolean onPreDraw()>,<android.widget.TextView: boolean onPreDraw()>,0,"{
    if (mPreDrawState != PREDRAW_PENDING) {
        return true;
    }
    if (mLayout == null) {
        assumeLayout();
    }
    boolean changed = false;
    if (mMovement != null) {
        int curs = Selection.getSelectionEnd(mText);
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            changed = bringPointIntoView(curs);
        }
    } else {
        changed = bringTextIntoView();
    }
    mPreDrawState = PREDRAW_DONE;
    return !changed;
}","{
    if (mPreDrawState != PREDRAW_PENDING) {
        return true;
    }
    if (mLayout == null) {
        assumeLayout();
    }
    boolean changed = false;
    SelectionModifierCursorController selectionController = null;
    if (mSelectionModifierCursorController != null) {
        selectionController = (SelectionModifierCursorController) mSelectionModifierCursorController;
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        if (selectionController != null && selectionController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            changed = bringPointIntoView(curs);
        }
    } else {
        changed = bringTextIntoView();
    }
    // startTextSelectionMode here. TODO
    if (this instanceof ExtractEditText && selectionController != null && hasSelection()) {
        startTextSelectionMode();
    }
    mPreDrawState = PREDRAW_DONE;
    return !changed;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There are changes in the control dependencies where the introduced section of codes inside the 'if' checks that involve various operations including getting the SelectionEnd. Also, new statements and conditions that affect the functioning of the API are added, such as initialization of `selectionController`, and startTextSelectionMode(). The code change type is therefore 3, 4.","These new changes and operations could lead to a difference in the final returned value (`return !changed`), potentially resulting in a different return value. Therefore, the CI type is 1."
102,<android.view.View: void buildDrawingCache(boolean)>,8,9,<android.view.View: void buildDrawingCache(boolean)>,<android.view.View: void buildDrawingCache(boolean)>,0,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean translucentWindow = attachInfo != null && attachInfo.mTranslucentWindow;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !translucentWindow ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = translucentWindow ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
                if (opaque && translucentWindow)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        mPrivateFlags |= DRAWING_CACHE_VALID;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? (mDrawingCache == null || mDrawingCache.get() == null) : (mUnscaledDrawingCache == null || mUnscaledDrawingCache.get() == null))) {
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        if (Config.DEBUG && ViewDebug.profileDrawing) {
            EventLog.writeEvent(60002, hashCode());
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? (mDrawingCache == null ? null : mDrawingCache.get()) : (mUnscaledDrawingCache == null ? null : mUnscaledDrawingCache.get());
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_4444;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = new SoftReference<Bitmap>(bitmap);
                } else {
                    mUnscaledDrawingCache = new SoftReference<Bitmap>(bitmap);
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        mPrivateFlags |= DRAWING_CACHE_VALID;
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The variable ""translucentWindow"" was replaced with ""use32BitCache"" in several places. This change completely alters the behavior of the code in these places, since the value of the variable determines the flow of the code. This is classified as other statement change type 4. Additionally, the control dependency is altered with an if condition's evaluation being based on this new variable. Hence, the change type is 3,4.","The introduced changes modify the value of the variable 'bitmap' which is directly involved in multiple return statements. Therefore, it's possible that the function could return different values between early and late versions, causing a compatibility issue of type 1."
103,<android.view.MotionEvent: float getSize()>,8,9,<android.view.MotionEvent: float getSize()>,<android.view.MotionEvent: float getSize()>,0,"{
    return mDataSamples[SAMPLE_SIZE];
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_SIZE];
}",1,"/**
 * {@link #getSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from 'return mDataSamples[SAMPLE_SIZE];' to 'return mDataSamples[mLastDataSampleIndex + SAMPLE_SIZE];' and the statement within the return statement also changed, so the code change type is 1,4.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
104,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",8,9,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>","<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",0,"{
    synchronized (this) {
        if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
            Phone.DataState state = getMobileDataState(intent);
            String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            String apnTypeList = intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
            mApnName = apnName;
            boolean unavailable = intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false);
            // set this regardless of the apnTypeList.  It's all the same radio/network
            // underneath
            mNetworkInfo.setIsAvailable(!unavailable);
            if (isApnTypeIncluded(apnTypeList)) {
                if (mEnabled == false) {
                    // notifications
                    if (state == Phone.DataState.CONNECTED) {
                        if (DBG)
                            Log.d(TAG, ""replacing old mInterfaceName ("" + mInterfaceName + "") with "" + intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY) + "" for "" + mApnType);
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                    }
                    return;
                }
            } else {
                return;
            }
            if (DBG)
                Log.d(TAG, mApnType + "" Received state= "" + state + "", old= "" + mMobileDataState + "", reason= "" + (reason == null ? ""(unspecified)"" : reason) + "", apnTypeList= "" + apnTypeList);
            if (mMobileDataState != state) {
                mMobileDataState = state;
                switch(state) {
                    case DISCONNECTED:
                        if (isTeardownRequested()) {
                            mEnabled = false;
                            setTeardownRequested(false);
                        }
                        setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                        if (mInterfaceName != null) {
                            NetworkUtils.resetConnections(mInterfaceName);
                        }
                        // mDefaultGatewayAddr = 0;
                        break;
                    case CONNECTING:
                        setDetailedState(DetailedState.CONNECTING, reason, apnName);
                        break;
                    case SUSPENDED:
                        setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                        break;
                    case CONNECTED:
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                        if (mInterfaceName == null) {
                            Log.d(TAG, ""CONNECTED event did not supply interface name."");
                        }
                        setDetailedState(DetailedState.CONNECTED, reason, apnName);
                        break;
                }
            }
        } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
            mEnabled = false;
            String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            if (DBG)
                Log.d(TAG, ""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
            setDetailedState(DetailedState.FAILED, reason, apnName);
        }
        TelephonyManager tm = TelephonyManager.getDefault();
        setRoamingStatus(tm.isNetworkRoaming());
        setSubtype(tm.getNetworkType(), tm.getNetworkTypeName());
    }
}","{
    synchronized (this) {
        if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
            Phone.DataState state = getMobileDataState(intent);
            String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            String apnTypeList = intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
            mApnName = apnName;
            boolean unavailable = intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false);
            // set this regardless of the apnTypeList.  It's all the same radio/network
            // underneath
            mNetworkInfo.setIsAvailable(!unavailable);
            if (isApnTypeIncluded(apnTypeList)) {
                if (mEnabled == false) {
                    // notifications
                    if (state == Phone.DataState.CONNECTED) {
                        if (DBG)
                            Log.d(TAG, ""replacing old mInterfaceName ("" + mInterfaceName + "") with "" + intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY) + "" for "" + mApnType);
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                    }
                    return;
                }
            } else {
                return;
            }
            if (DBG)
                Log.d(TAG, mApnType + "" Received state= "" + state + "", old= "" + mMobileDataState + "", reason= "" + (reason == null ? ""(unspecified)"" : reason) + "", apnTypeList= "" + apnTypeList);
            if (mMobileDataState != state) {
                mMobileDataState = state;
                switch(state) {
                    case DISCONNECTED:
                        if (isTeardownRequested()) {
                            mEnabled = false;
                            setTeardownRequested(false);
                        }
                        setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                        boolean doReset = true;
                        if (mIsDefaultOrHipri == true) {
                            // both default and hipri must go down before we reset
                            int typeToCheck = (Phone.APN_TYPE_DEFAULT.equals(mApnType) ? ConnectivityManager.TYPE_MOBILE_HIPRI : ConnectivityManager.TYPE_MOBILE);
                            if (mConnectivityManager == null) {
                                mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                            }
                            if (mConnectivityManager != null) {
                                NetworkInfo info = mConnectivityManager.getNetworkInfo(typeToCheck);
                                if (info != null && info.isConnected() == true) {
                                    doReset = false;
                                }
                            }
                        }
                        if (doReset && mInterfaceName != null) {
                            NetworkUtils.resetConnections(mInterfaceName);
                        }
                        // mDefaultGatewayAddr = 0;
                        break;
                    case CONNECTING:
                        setDetailedState(DetailedState.CONNECTING, reason, apnName);
                        break;
                    case SUSPENDED:
                        setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                        break;
                    case CONNECTED:
                        mInterfaceName = intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
                        if (mInterfaceName == null) {
                            Log.d(TAG, ""CONNECTED event did not supply interface name."");
                        }
                        mDefaultGatewayAddr = intent.getIntExtra(Phone.DATA_GATEWAY_KEY, 0);
                        setDetailedState(DetailedState.CONNECTED, reason, apnName);
                        break;
                }
            }
        } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
            mEnabled = false;
            String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
            String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
            if (DBG)
                Log.d(TAG, ""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
            setDetailedState(DetailedState.FAILED, reason, apnName);
        }
        TelephonyManager tm = TelephonyManager.getDefault();
        setRoamingStatus(tm.isNetworkRoaming());
        setSubtype(tm.getNetworkType(), tm.getNetworkTypeName());
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"There are some new statements inside 'case DISCONNECTED' and 'case CONNECTED'. They are not return or exception handling statements, they are nested under 'switch' statement, and they are not dependent APIs. So, the change type is 3,4.","The changes are only about internal variable state changes, nothing is changed on the return type/values or exception handling, so there is no Compatibility Issue, and the CI type is 0."
106,"<android.os.DropBoxManager: void addFile(String,File,int)>",8,9,"<android.os.DropBoxManager: void addFile(String,File,int)>","<android.os.DropBoxManager: void addFile(String,File,int)>",0,"{
    if (file == null)
        throw new NullPointerException();
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(new Entry(tag, 0, file, flags));
    } catch (RemoteException e) {
    // ignore
    } finally {
        entry.close();
    }
}","{
    if (file == null)
        throw new NullPointerException(""file == null"");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
    // ignore
    } finally {
        entry.close();
    }
}",1,"/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
","/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The changes include adding a string parameter to the NullPointerException and modifying the 'mService.add()' function call with existing variable 'entry' in the 'try' block. So the code change type is ""4: Other statement changed.""","Neither of these changes affect the possible return values or exception handling of the function, so there are no compatibility issues (type 0). Hence, the CI type is 0."
108,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",8,9,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>","<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",0,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new ActivityThread.PackageInfo.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",0,"The instantiation of the `ReceiverDispatcher` has been changed from `ActivityThread.PackageInfo.ReceiverDispatcher` to `LoadedApk.ReceiverDispatcher`. Therefore, the code change type categories is 4,5.","Although the change, the return type and the exception handling still remain the same. Thus, there is no compatibility issue between the two versions."
110,<android.app.Activity: void removeDialog(int)>,8,9,<android.app.Activity: void removeDialog(int)>,<android.app.Activity: void removeDialog(int)>,0,"{
    if (mManagedDialogs == null) {
        return;
    }
    final ManagedDialog md = mManagedDialogs.get(id);
    if (md == null) {
        return;
    }
    md.mDialog.dismiss();
    mManagedDialogs.remove(id);
}","{
    if (mManagedDialogs != null) {
        final ManagedDialog md = mManagedDialogs.get(id);
        if (md != null) {
            md.mDialog.dismiss();
            mManagedDialogs.remove(id);
        }
    }
}",1,"/**
 * Removes any internal references to a dialog managed by this Activity.
 * If the dialog is showing, it will dismiss it as part of the clean up.
 *
 * <p>This can be useful if you know that you will never show a dialog again and
 * want to avoid the overhead of saving and restoring it in the future.
 *
 * @param id The id of the managed dialog.
 *
 * @see #onCreateDialog(int, Bundle)
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int)
 * @see #dismissDialog(int)
 */
","/**
 * Removes any internal references to a dialog managed by this Activity.
 * If the dialog is showing, it will dismiss it as part of the clean up.
 *
 * <p>This can be useful if you know that you will never show a dialog again and
 * want to avoid the overhead of saving and restoring it in the future.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#GINGERBREAD}, this function
 * will not throw an exception if you try to remove an ID that does not
 * currently have an associated dialog.</p>
 *
 * @param id The id of the managed dialog.
 *
 * @see #onCreateDialog(int, Bundle)
 * @see #onPrepareDialog(int, Dialog, Bundle)
 * @see #showDialog(int)
 * @see #dismissDialog(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The condition statements in the early and late versions have been rewritten but they are essentially testing the same conditions. The early version checks if a condition is not met then it returns, while the late version continues the execution if the condition is met. Therefore, the change type is 3.","Although the conditional statements have been slightly restructured, the logic remains essentially the same, and it does not affect the API's return value nor exception thrown, hence there's no Compatibility Issues (CI type=0)."
111,<android.widget.TextView: Parcelable onSaveInstanceState()>,8,9,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = Selection.getSelectionStart(mText);
        end = Selection.getSelectionEnd(mText);
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,5,1,"The method calls 'Selection.getSelectionStart(mText)' and 'Selection.getSelectionEnd(mText)' in the early version have been replaced with 'getSelectionStart()' and 'getSelectionEnd()' in the late version. Hence, this change is classified as type 5 (Dependent API changed).","The dependent methods 'getSelectionStart()' and 'getSelectionEnd()' might have different implementations than the previous 'Selection.getSelectionStart(mText)' and 'Selection.getSelectionEnd(mText)'. If the new methods return different values, the 'start' and 'end' could be different, which would further make the returned object 'ss' differs in the property 'selStart', 'selEnd' and 'frozenWithFocus'. Therefore, the compatibility issue type is 1 (Compatibility Issue caused by potential different return values or types)."
113,<android.app.Notification: String toString()>,8,9,<android.app.Notification: String toString()>,<android.app.Notification: String toString()>,0,"{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("")"");
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder();
    sb.append(""Notification(vibrate="");
    if (this.vibrate != null) {
        int N = this.vibrate.length - 1;
        sb.append(""["");
        for (int i = 0; i < N; i++) {
            sb.append(this.vibrate[i]);
            sb.append(',');
        }
        if (N != -1) {
            sb.append(this.vibrate[N]);
        }
        sb.append(""]"");
    } else if ((this.defaults & DEFAULT_VIBRATE) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",sound="");
    if (this.sound != null) {
        sb.append(this.sound.toString());
    } else if ((this.defaults & DEFAULT_SOUND) != 0) {
        sb.append(""default"");
    } else {
        sb.append(""null"");
    }
    sb.append("",defaults=0x"");
    sb.append(Integer.toHexString(this.defaults));
    sb.append("",flags=0x"");
    sb.append(Integer.toHexString(this.flags));
    sb.append("")"");
    return sb.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"There is an additional string append operation in the late version (sb.append("",flags=0x""); sb.append(Integer.toHexString(this.flags));), which results in a different return value of the toString method, so the code change type is 1.","An additional string is appended to StringBuilder in the late version which changes the final string returned by the toString() method, leading to a compatibility issue. Thus, the compatibility issue type is 1."
116,"<android.database.sqlite.SQLiteDatabase: void logTimeStat(String,long,String)>",8,9,"<android.database.sqlite.SQLiteDatabase: void logTimeStat(String,long,String)>","<android.database.sqlite.SQLiteDatabase: void logTimeStat(String,long,String)>",0,"{
    // Keep track of the last statement executed here, as this is
    // the common funnel through which all methods of hitting
    // libsqlite eventually flow.
    mLastSqlStatement = sql;
    // Sample fast queries in proportion to the time taken.
    // Quantize the % first, so the logged sampling probability
    // exactly equals the actual sampling rate for this query.
    int samplePercent;
    long durationMillis = SystemClock.uptimeMillis() - beginMillis;
    if (durationMillis == 0 && prefix == GET_LOCK_LOG_PREFIX) {
        // even at 1%, which is our default below.
        return;
    }
    if (sQueryLogTimeInMillis == 0) {
        sQueryLogTimeInMillis = SystemProperties.getInt(""db.db_operation.threshold_ms"", 500);
    }
    if (durationMillis >= sQueryLogTimeInMillis) {
        samplePercent = 100;
    } else {
        ;
        samplePercent = (int) (100 * durationMillis / sQueryLogTimeInMillis) + 1;
        if (mRandom.nextInt(100) >= samplePercent)
            return;
    }
    // it here so we avoid allocating in the common case.
    if (prefix != null) {
        sql = prefix + sql;
    }
    if (sql.length() > QUERY_LOG_SQL_LENGTH)
        sql = sql.substring(0, QUERY_LOG_SQL_LENGTH);
    // ActivityThread.currentPackageName() only returns non-null if the
    // current thread is an application main thread.  This parameter tells
    // us whether an event loop is blocked, and if so, which app it is.
    // 
    // Sadly, there's no fast way to determine app name if this is *not* a
    // main thread, or when we are invoked via Binder (e.g. ContentProvider).
    // Hopefully the full path to the database will be informative enough.
    String blockingPackage = ActivityThread.currentPackageName();
    if (blockingPackage == null)
        blockingPackage = """";
    EventLog.writeEvent(EVENT_DB_OPERATION, getPathForLogs(), sql, durationMillis, blockingPackage, samplePercent);
}","{
    // Keep track of the last statement executed here, as this is
    // the common funnel through which all methods of hitting
    // libsqlite eventually flow.
    mLastSqlStatement = sql;
    // Sample fast queries in proportion to the time taken.
    // Quantize the % first, so the logged sampling probability
    // exactly equals the actual sampling rate for this query.
    int samplePercent;
    long durationMillis = SystemClock.uptimeMillis() - beginMillis;
    if (durationMillis == 0 && prefix == GET_LOCK_LOG_PREFIX) {
        // even at 1%, which is our default below.
        return;
    }
    if (sQueryLogTimeInMillis == 0) {
        sQueryLogTimeInMillis = SystemProperties.getInt(""db.db_operation.threshold_ms"", 500);
    }
    if (durationMillis >= sQueryLogTimeInMillis) {
        samplePercent = 100;
    } else {
        ;
        samplePercent = (int) (100 * durationMillis / sQueryLogTimeInMillis) + 1;
        if (mRandom.nextInt(100) >= samplePercent)
            return;
    }
    // it here so we avoid allocating in the common case.
    if (prefix != null) {
        sql = prefix + sql;
    }
    if (sql.length() > QUERY_LOG_SQL_LENGTH)
        sql = sql.substring(0, QUERY_LOG_SQL_LENGTH);
    // ActivityThread.currentPackageName() only returns non-null if the
    // current thread is an application main thread.  This parameter tells
    // us whether an event loop is blocked, and if so, which app it is.
    // 
    // Sadly, there's no fast way to determine app name if this is *not* a
    // main thread, or when we are invoked via Binder (e.g. ContentProvider).
    // Hopefully the full path to the database will be informative enough.
    String blockingPackage = AppGlobals.getInitialPackage();
    if (blockingPackage == null)
        blockingPackage = """";
    EventLog.writeEvent(EVENT_DB_OPERATION, getPathForLogs(), sql, durationMillis, blockingPackage, samplePercent);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,The method AppGlobals.getInitialPackage() has been used instead of ActivityThread.currentPackageName(). So the change types are 4 (Other statement changed) and 5 (Dependent API changed).,"As the method used for getting the package name has changed, this could potentially lead to a different string variable 'blockingPackage'. Therefore, it could potentially cause the API to return a different value. The CI type is 1."
117,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,8,9,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,<android.app.ActivityManager: List<RunningTaskInfo> getRunningTasks(int)>,0,"{
    try {
        return (List<RunningTaskInfo>) ActivityManagerNative.getDefault().getTasks(maxNum, 0, null);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    return getRunningTasks(maxNum, 0, null);
}",1,"/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 *
 * @throws SecurityException Throws SecurityException if the caller does
 * not hold the {@link android.Manifest.permission#GET_TASKS} permission.
 */
","/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * ""running"" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 *
 * @throws SecurityException Throws SecurityException if the caller does
 * not hold the {@link android.Manifest.permission#GET_TASKS} permission.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In the early version, there was a try-catch block where we would try to get default ActivityManagerNative and fetch tasks and if it failed, return statement would return null. In the late version, the try-catch has been removed and it just returns the running tasks. So, code change is of type 1 and 5.","As the return statement is changed from 'null' to the direct value from the method 'getRunningTasks', the return value could be different, so the CI type is 1."
118,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,8,9,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,0,"{
    try {
        mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight precedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The control statement 'if (getState() != STATE_ON)' has been added in the later version of the code. This doesn't affect the return statements or any exception handling statements, therefore the change category is 3 (Control dependency changed).","Although there is a control statement added, in both versions of the methods, the return value stays the same (always returns false) and there is no change in how exceptions are handled. Hence, no Compatibility Issue (CI) is present in this case."
119,"<android.webkit.WebTextView: void onSelectionChanged(int,int)>",8,9,"<android.webkit.WebTextView: void onSelectionChanged(int,int)>","<android.webkit.WebTextView: void onSelectionChanged(int,int)>",0,"{
    if (mInSetTextAndKeepSelection)
        return;
    // This code is copied from TextView.onDraw().  That code does not get
    // executed, however, because the WebTextView does not draw, allowing
    // webkit's drawing to show through.
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        Spannable sp = (Spannable) getText();
        int candStart = EditableInputConnection.getComposingSpanStart(sp);
        int candEnd = EditableInputConnection.getComposingSpanEnd(sp);
        imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
    }
    if (!mFromWebKit && !mFromFocusChange && !mFromSetInputType && mWebView != null) {
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onSelectionChanged selStart="" + selStart + "" selEnd="" + selEnd);
        }
        mWebView.setSelection(selStart, selEnd);
    }
}","{
    if (mInSetTextAndKeepSelection)
        return;
    // This code is copied from TextView.onDraw().  That code does not get
    // executed, however, because the WebTextView does not draw, allowing
    // webkit's drawing to show through.
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        Spannable sp = (Spannable) getText();
        int candStart = EditableInputConnection.getComposingSpanStart(sp);
        int candEnd = EditableInputConnection.getComposingSpanEnd(sp);
        imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
    }
    if (!mFromWebKit && !mFromFocusChange && !mFromSetInputType && mWebView != null) {
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onSelectionChanged selStart="" + selStart + "" selEnd="" + selEnd);
        }
        mWebView.setSelection(selStart, selEnd);
        lineUpScroll();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The method lineUpScroll() has been added in the Update Version after the 'if' statement, so the code change type is 4.","The added statement 'lineUpScroll()' can lead to different behaviors of 'onSelectionChanged', which makes the return value of the Update Version potentially different from the Early Version API, So the CI type is 1."
120,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",8,9,"<android.webkit.WebView: void loadUrl(String,Map<String, String>)>","<android.webkit.WebView: void loadUrl(String,Map<String, String>)>",0,"{
    switchOutDrawHistory();
    WebViewCore.GetUrlData arg = new WebViewCore.GetUrlData();
    arg.mUrl = url;
    arg.mExtraHeaders = extraHeaders;
    mWebViewCore.sendMessage(EventHub.LOAD_URL, arg);
    clearTextEntry(false);
}","{
    switchOutDrawHistory();
    WebViewCore.GetUrlData arg = new WebViewCore.GetUrlData();
    arg.mUrl = url;
    arg.mExtraHeaders = extraHeaders;
    mWebViewCore.sendMessage(EventHub.LOAD_URL, arg);
    clearHelpers();
}",1,"/**
 * Load the given url with the extra headers.
 * @param url The url of the resource to load.
 * @param extraHeaders The extra headers sent with this url. This should not
 * include the common headers like ""user-agent"". If it does, it
 * will be replaced by the intrinsic value of the WebView.
 */
","/**
 * Load the given url with the extra headers.
 * @param url The url of the resource to load.
 * @param extraHeaders The extra headers sent with this url. This should not
 * include the common headers like ""user-agent"". If it does, it
 * will be replaced by the intrinsic value of the WebView.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method call 'clearTextEntry(false);' in early version is replaced with 'clearHelpers();' in the late version. So, the code change type is 4 (Other statement changed).","This change in method call doesn't affect the return value or throw a different exception. Hence, No compatibility issue exists for this API."
121,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,8,9,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,<android.webkit.WebViewDatabase: long getCacheTotalSize()>,0,"{
    long size = 0;
    Cursor cursor = null;
    final String query = ""SELECT SUM(contentlength) as sum FROM cache"";
    try {
        cursor = mCacheDatabase.rawQuery(query, null);
        if (cursor.moveToFirst()) {
            size = cursor.getLong(0);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""getCacheTotalSize"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return size;
}","{
    if (mCacheDatabase == null) {
        return 0;
    }
    long size = 0;
    Cursor cursor = null;
    final String query = ""SELECT SUM(contentlength) as sum FROM cache"";
    try {
        cursor = mCacheDatabase.rawQuery(query, null);
        if (cursor.moveToFirst()) {
            size = cursor.getLong(0);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, ""getCacheTotalSize"", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
    return size;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,3,1,"The code change happens when a 'if' statement has been added at the beginning of the code where it checks if data cache is absent and return 0 directly if it is, so the code change type is 3.","Because the newly added 'if' statement in the late version can potentially make the function return a differnt value, the Compatibility Issue (CI) type is 1."
123,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,8,9,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,<android.database.sqlite.SQLiteStatement: long simpleQueryForLong()>,0,"{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        long retValue = native_1x1_long();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onReadFromDisk();
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        long retValue = native_1x1_long();
        mDatabase.logTimeStat(mSql, timeStart);
        return retValue;
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
","/**
 * Execute a statement that returns a 1 by 1 table with a numeric value.
 * For example, SELECT COUNT(*) FROM table;
 *
 * @return The result of the query.
 *
 * @throws android.database.sqlite.SQLiteDoneException if the query returns zero rows
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement (BlockGuard.getThreadPolicy().onReadFromDisk();) was added at the beginning of the implementation, so the code change type is 4.","The added statement does not affect the return value or the exception handling of the API (the added method does not return a value and does not throw an exception as well), so there is no compatibility issue, and the CI type is 0."
124,"<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>",8,9,"<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>","<android.provider.Telephony.Threads: long getOrCreateThreadId(Context,Set<String>)>",0,"{
    Uri.Builder uriBuilder = THREAD_ID_CONTENT_URI.buildUpon();
    for (String recipient : recipients) {
        if (Mms.isEmailAddress(recipient)) {
            recipient = Mms.extractAddrSpec(recipient);
        }
        uriBuilder.appendQueryParameter(""recipient"", recipient);
    }
    Uri uri = uriBuilder.build();
    if (DEBUG) {
        Log.v(TAG, ""getOrCreateThreadId uri: "" + uri);
    }
    Cursor cursor = SqliteWrapper.query(context, context.getContentResolver(), uri, ID_PROJECTION, null, null, null);
    if (DEBUG) {
        Log.v(TAG, ""getOrCreateThreadId cursor cnt: "" + cursor.getCount());
    }
    if (cursor != null) {
        try {
            if (cursor.moveToFirst()) {
                return cursor.getLong(0);
            } else {
                Log.e(TAG, ""getOrCreateThreadId returned no rows!"");
            }
        } finally {
            cursor.close();
        }
    }
    Log.e(TAG, ""getOrCreateThreadId failed with uri "" + uri.toString());
    throw new IllegalArgumentException(""Unable to find or allocate a thread ID."");
}","{
    Uri.Builder uriBuilder = THREAD_ID_CONTENT_URI.buildUpon();
    for (String recipient : recipients) {
        if (Mms.isEmailAddress(recipient)) {
            recipient = Mms.extractAddrSpec(recipient);
        }
        uriBuilder.appendQueryParameter(""recipient"", recipient);
    }
    Uri uri = uriBuilder.build();
    // if (DEBUG) Log.v(TAG, ""getOrCreateThreadId uri: "" + uri);
    Cursor cursor = SqliteWrapper.query(context, context.getContentResolver(), uri, ID_PROJECTION, null, null, null);
    if (DEBUG) {
        Log.v(TAG, ""getOrCreateThreadId cursor cnt: "" + cursor.getCount());
    }
    if (cursor != null) {
        try {
            if (cursor.moveToFirst()) {
                return cursor.getLong(0);
            } else {
                Log.e(TAG, ""getOrCreateThreadId returned no rows!"");
            }
        } finally {
            cursor.close();
        }
    }
    Log.e(TAG, ""getOrCreateThreadId failed with uri "" + uri.toString());
    throw new IllegalArgumentException(""Unable to find or allocate a thread ID."");
}",1,"/**
 * Given the recipients list and subject of an unsaved message,
 * return its thread ID.  If the message starts a new thread,
 * allocate a new thread ID.  Otherwise, use the appropriate
 * existing thread ID.
 *
 * Find the thread ID of the same set of recipients (in
 * any order, without any additions). If one
 * is found, return it.  Otherwise, return a unique thread ID.
 */
","/**
 * Given the recipients list and subject of an unsaved message,
 * return its thread ID.  If the message starts a new thread,
 * allocate a new thread ID.  Otherwise, use the appropriate
 * existing thread ID.
 *
 * Find the thread ID of the same set of recipients (in
 * any order, without any additions). If one
 * is found, return it.  Otherwise, return a unique thread ID.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, the log printing statement under condition if(DEBUG) is commented out. So, the code change type is classified as 4 (Other statement changed).","This change does not affect the behavior of the method, as it just commented out a log message, hence there is no compatibility issue, class 0 (No Compatibility Issue exist)."
125,<android.server.BluetoothService: boolean removeBond(String)>,8,9,<android.server.BluetoothService: boolean removeBond(String)>,<android.server.BluetoothService: boolean removeBond(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    return removeDeviceNative(getObjectPathFromAddress(address));
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    BluetoothDeviceProfileState state = mDeviceProfileState.get(address);
    if (state != null) {
        state.sendMessage(BluetoothDeviceProfileState.UNPAIR);
        return true;
    } else {
        return false;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"The control dependency statement (if statement) and the return statement are added in late implementation. Therefore, the code changes types are 1 and 3.","The added return statement and the new control dependencies in the late implementation could potentially lead to different return values, Therefore, the Compatibility Issue exists and the CI type is 1."
126,<android.view.MotionEvent: float getPressure(int)>,8,9,<android.view.MotionEvent: float getPressure(int)>,<android.view.MotionEvent: float getPressure(int)>,0,"{
    return mDataSamples[(pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_PRESSURE];
}","{
    return mDataSamples[mLastDataSampleIndex + pointerIndex * NUM_SAMPLE_DATA + SAMPLE_PRESSURE];
}",1,"/**
 * Returns the current pressure of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
","/**
 * Returns the current pressure of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The assignment statement inside the return statement has been changed. The index parameter for mDataSamples[] has been adjusted. Therefore, the code change type is 4.","The change of the index parameter for mDataSamples[] makes the API potentially return a different value, therefore, the CI type is 1."
127,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,8,9,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"In the case MotionEvent.ACTION_CANCEL and MotionEvent.ACTION_UP, additional statements are added to proceed with mScroller.springBack() method and invalidate() method call, so the change type is 3,4.","The additional statements in the late version could potentially change the return behavior of the function (since mIsBeingDragged might take a different value due to mScroller.springBack()), thus creating a Compatibility Issue. Hence the CI type is 1."
128,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",8,9,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>","<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",0,"{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    return PackageParser.generatePackageInfo(pkg, null, flags);
}","{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0);
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement of method 'PackageParser.generatePackageInfo()' has changed from 3 parameters to 5 parameters in Late_version, indicating a difference in function behavior, thus the change type is 1.","The change in the number of parameters in the return method can potentially return a different value or Variable types, hence the CI type is 1."
129,"<android.app.Activity: boolean onCreateThumbnail(Bitmap,Canvas)>",8,9,"<android.app.Activity: boolean onCreateThumbnail(Bitmap,Canvas)>","<android.app.Activity: boolean onCreateThumbnail(Bitmap,Canvas)>",0,"{
    final View view = mDecor;
    if (view == null) {
        return false;
    }
    final int vw = view.getWidth();
    final int vh = view.getHeight();
    final int dw = outBitmap.getWidth();
    final int dh = outBitmap.getHeight();
    canvas.save();
    canvas.scale(((float) dw) / vw, ((float) dh) / vh);
    view.draw(canvas);
    canvas.restore();
    return true;
}","{
    if (mDecor == null) {
        return false;
    }
    int paddingLeft = 0;
    int paddingRight = 0;
    int paddingTop = 0;
    int paddingBottom = 0;
    // Find System window and use padding so we ignore space reserved for decorations
    // like the status bar and such.
    final FrameLayout top = (FrameLayout) mDecor;
    for (int i = 0; i < top.getChildCount(); i++) {
        View child = top.getChildAt(i);
        if (child.isFitsSystemWindowsFlagSet()) {
            paddingLeft = child.getPaddingLeft();
            paddingRight = child.getPaddingRight();
            paddingTop = child.getPaddingTop();
            paddingBottom = child.getPaddingBottom();
            break;
        }
    }
    final int visibleWidth = mDecor.getWidth() - paddingLeft - paddingRight;
    final int visibleHeight = mDecor.getHeight() - paddingTop - paddingBottom;
    canvas.save();
    canvas.scale((float) outBitmap.getWidth() / visibleWidth, (float) outBitmap.getHeight() / visibleHeight);
    canvas.translate(-paddingLeft, -paddingTop);
    mDecor.draw(canvas);
    canvas.restore();
    return true;
}",1,"/**
 * Generate a new thumbnail for this activity.  This method is called before
 * pausing the activity, and should draw into <var>outBitmap</var> the
 * imagery for the desired thumbnail in the dimensions of that bitmap.  It
 * can use the given <var>canvas</var>, which is configured to draw into the
 * bitmap, for rendering if desired.
 *
 * <p>The default implementation renders the Screen's current view
 * hierarchy into the canvas to generate a thumbnail.
 *
 * <p>If you return false, the bitmap will be filled with a default
 * thumbnail.
 *
 * @param outBitmap The bitmap to contain the thumbnail.
 * @param canvas Can be used to render into the bitmap.
 *
 * @return Return true if you have drawn into the bitmap; otherwise after
 * you return it will be filled with a default thumbnail.
 *
 * @see #onCreateDescription
 * @see #onSaveInstanceState
 * @see #onPause
 */
","/**
 * Generate a new thumbnail for this activity.  This method is called before
 * pausing the activity, and should draw into <var>outBitmap</var> the
 * imagery for the desired thumbnail in the dimensions of that bitmap.  It
 * can use the given <var>canvas</var>, which is configured to draw into the
 * bitmap, for rendering if desired.
 *
 * <p>The default implementation renders the Screen's current view
 * hierarchy into the canvas to generate a thumbnail.
 *
 * <p>If you return false, the bitmap will be filled with a default
 * thumbnail.
 *
 * @param outBitmap The bitmap to contain the thumbnail.
 * @param canvas Can be used to render into the bitmap.
 *
 * @return Return true if you have drawn into the bitmap; otherwise after
 * you return it will be filled with a default thumbnail.
 *
 * @see #onCreateDescription
 * @see #onSaveInstanceState
 * @see #onPause
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Both the control dependency and other statements changed. Loop statements and new variables such as 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', and new statements involving these variables are introduced. Therefore, the change type includes 3 and 4.","The change in the control dependency (especially the loop) and the introduction of new variable assignments has a potential impact on the return values of the method, particularly the 'return true' statement can be affected. As such, the type of Compatibility Issue is 1. This is because these changes might potentially impact the final comparison and thus influence the returned boolean value."
130,<android.webkit.WebView: void rebuildWebTextView()>,8,9,<android.webkit.WebView: void rebuildWebTextView()>,<android.webkit.WebView: void rebuildWebTextView()>,0,"{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this);
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, contentToViewDimension(nativeFocusCandidateTextSize()));
    Rect visibleRect = new Rect();
    calcOurContentVisibleRect(visibleRect);
    // Note that sendOurVisibleRect calls viewToContent, so the coordinates
    // should be in content coordinates.
    Rect bounds = nativeFocusCandidateNodeBounds();
    Rect vBox = contentToViewRect(bounds);
    mWebTextView.setRect(vBox.left, vBox.top, vBox.width(), vBox.height());
    if (!Rect.intersects(bounds, visibleRect)) {
        mWebTextView.bringIntoView();
    }
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
        // another update when that text is recognized.
        if (text != null && !text.equals(mWebTextView.getText().toString()) && nativeTextGeneration() == mTextGeneration) {
            mWebTextView.setTextAndKeepSelection(text);
        }
    } else {
        mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
        // This needs to be called before setType, which may call
        // requestFormData, and it needs to have the correct nodePointer.
        mWebTextView.setNodePointer(nodePointer);
        mWebTextView.setType(nativeFocusCandidateType());
        if (null == text) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""rebuildWebTextView null == text"");
            }
            text = """";
        }
        mWebTextView.setTextAndKeepSelection(text);
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(mWebTextView)) {
            imm.restartInput(mWebTextView);
        }
    }
    mWebTextView.requestFocus();
}","{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this);
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, contentToViewDimension(nativeFocusCandidateTextSize()));
    Rect visibleRect = new Rect();
    calcOurContentVisibleRect(visibleRect);
    // Note that sendOurVisibleRect calls viewToContent, so the coordinates
    // should be in content coordinates.
    Rect bounds = nativeFocusCandidateNodeBounds();
    Rect vBox = contentToViewRect(bounds);
    mWebTextView.setRect(vBox.left, vBox.top, vBox.width(), vBox.height());
    if (!Rect.intersects(bounds, visibleRect)) {
        mWebTextView.bringIntoView();
    }
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
        // another update when that text is recognized.
        if (text != null && !text.equals(mWebTextView.getText().toString()) && nativeTextGeneration() == mTextGeneration) {
            mWebTextView.setTextAndKeepSelection(text);
        }
    } else {
        mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
        // This needs to be called before setType, which may call
        // requestFormData, and it needs to have the correct nodePointer.
        mWebTextView.setNodePointer(nodePointer);
        mWebTextView.setType(nativeFocusCandidateType());
        Rect paddingRect = nativeFocusCandidatePaddingRect();
        if (paddingRect != null) {
            // Use contentToViewDimension since these are the dimensions of
            // the padding.
            mWebTextView.setPadding(contentToViewDimension(paddingRect.left), contentToViewDimension(paddingRect.top), contentToViewDimension(paddingRect.right), contentToViewDimension(paddingRect.bottom));
        }
        if (null == text) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""rebuildWebTextView null == text"");
            }
            text = """";
        }
        mWebTextView.setTextAndKeepSelection(text);
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(mWebTextView)) {
            imm.restartInput(mWebTextView);
        }
    }
    mWebTextView.requestFocus();
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late implementation, a new statement has been added where paddingRect is assigned the return value of the method nativeFocusCandidatePaddingRect(). Additionally, a block of code has been added to set the padding for mWebTextView if paddingRect is not null. This change is considered as ""Other statement change"", so the code change type is 4.","These changes do not result in a change in the return value or the exceptions thrown by this method. Therefore, no Compatibility Issue is expected."
131,<android.view.VelocityTracker: float getYVelocity(int)>,8,9,<android.view.VelocityTracker: float getYVelocity(int)>,<android.view.VelocityTracker: float getYVelocity(int)>,0,"{
    return mYVelocity[id];
}","{
    Pointer pointer = getPointer(id);
    return pointer != null ? pointer.yVelocity : 0;
}",1,"/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @param id Which pointer's velocity to return.
 * @return The previously computed Y velocity.
 */
","/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @param id Which pointer's velocity to return.
 * @return The previously computed Y velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been modified and other statements are changed as well. Therefore, the code change type is 1,4.","The change of return statement indicates that the API potentially return different values in two versions, which leads to CI type 1."
132,<android.view.MotionEvent: float getRawY()>,8,9,<android.view.MotionEvent: float getRawY()>,<android.view.MotionEvent: float getRawY()>,0,"{
    return mRawY;
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_Y];
}",1,"/**
 * Returns the original raw Y coordinate of this event.  For touch
 * events on the screen, this is the original location of the event
 * on the screen, before it had been adjusted for the containing window
 * and views.
 */
","/**
 * Returns the original raw Y coordinate of this event.  For touch
 * events on the screen, this is the original location of the event
 * on the screen, before it had been adjusted for the containing window
 * and views.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed, hence the change type is 1 (Return statement changed).","The function is expected to return a different value in the later version as the return statement changed. Thus, there is a Compatibility Issue of type 1 (possible change in return value)."
133,<android.app.ContextImpl.SharedPreferencesImpl.EditorImpl: boolean commit()>,8,9,<android.app.ContextImpl.SharedPreferencesImpl.EditorImpl: boolean commit()>,<android.app.ContextImpl.SharedPreferencesImpl.EditorImpl: boolean commit()>,0,"{
    boolean returnValue;
    boolean hasListeners;
    List<String> keysModified = null;
    Set<OnSharedPreferenceChangeListener> listeners = null;
    synchronized (SharedPreferencesImpl.this) {
        hasListeners = mListeners.size() > 0;
        if (hasListeners) {
            keysModified = new ArrayList<String>();
            listeners = new HashSet<OnSharedPreferenceChangeListener>(mListeners.keySet());
        }
        synchronized (this) {
            if (mClear) {
                mMap.clear();
                mClear = false;
            }
            for (Entry<String, Object> e : mModified.entrySet()) {
                String k = e.getKey();
                Object v = e.getValue();
                if (v == this) {
                    mMap.remove(k);
                } else {
                    mMap.put(k, v);
                }
                if (hasListeners) {
                    keysModified.add(k);
                }
            }
            mModified.clear();
        }
        returnValue = writeFileLocked();
    }
    if (hasListeners) {
        for (int i = keysModified.size() - 1; i >= 0; i--) {
            final String key = keysModified.get(i);
            for (OnSharedPreferenceChangeListener listener : listeners) {
                if (listener != null) {
                    listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, key);
                }
            }
        }
    }
    return returnValue;
}","{
    MemoryCommitResult mcr = commitToMemory();
    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);
    try {
        mcr.writtenToDiskLatch.await();
    } catch (InterruptedException e) {
        return false;
    }
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4,5","1,2","There is a complete overhaul of code between the two versions. The functions used, the control structure, exception handling, and return statement, everything is changed. Therefore, it belongs to all of the change types: 1,2,3,4,5.","As the return statement is changing from returning 'returnValue' to 'mcr.writeToDiskResult', this implies different return values or types, which may cause a compatibility issue of type 1. The introduction of a new exception (InterruptedException) also potentially alters the exception handling of the API, which leads to a compatibility issue of type 2. Thus, the CI type is 1,2."
134,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",8,9,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>","<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",0,"{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearTextEntry(false);
}","{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearHelpers();
}",1,"/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used to resolve any
 * relative URLs. The historyUrl is used for the history entry.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param historyUrl URL to use as the history entry.  Can be null.
 */
","/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used to resolve any
 * relative URLs. The historyUrl is used for the history entry.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param historyUrl URL to use as the history entry.  Can be null.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"Only the method clearTextEntry(false) has changed to clearHelpers(), so the code change type is 4.","The change in method may potentially alter the state of WebView instance, which could result in different outcomes when invoking other methods later. Therefore, the CI type is 1."
135,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int)>",8,9,"<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int)>","<android.text.format.DateUtils: Formatter formatDateRange(Context,Formatter,long,long,int)>",0,"{
    Resources res = Resources.getSystem();
    boolean showTime = (flags & FORMAT_SHOW_TIME) != 0;
    boolean showWeekDay = (flags & FORMAT_SHOW_WEEKDAY) != 0;
    boolean showYear = (flags & FORMAT_SHOW_YEAR) != 0;
    boolean noYear = (flags & FORMAT_NO_YEAR) != 0;
    boolean useUTC = (flags & FORMAT_UTC) != 0;
    boolean abbrevWeekDay = (flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
    boolean abbrevMonth = (flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
    boolean noMonthDay = (flags & FORMAT_NO_MONTH_DAY) != 0;
    boolean numericDate = (flags & FORMAT_NUMERIC_DATE) != 0;
    // If we're getting called with a single instant in time (from
    // e.g. formatDateTime(), below), then we can skip a lot of
    // computation below that'd otherwise be thrown out.
    boolean isInstant = (startMillis == endMillis);
    Time startDate = useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    startDate.set(startMillis);
    Time endDate;
    int dayDistance;
    if (isInstant) {
        endDate = startDate;
        dayDistance = 0;
    } else {
        endDate = useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
        endDate.set(endMillis);
        int startJulianDay = Time.getJulianDay(startMillis, startDate.gmtoff);
        int endJulianDay = Time.getJulianDay(endMillis, endDate.gmtoff);
        dayDistance = endJulianDay - startJulianDay;
    }
    // adjust the date.
    if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
        endDate.monthDay -= 1;
        endDate.normalize(true);
    }
    int startDay = startDate.monthDay;
    int startMonthNum = startDate.month;
    int startYear = startDate.year;
    int endDay = endDate.monthDay;
    int endMonthNum = endDate.month;
    int endYear = endDate.year;
    String startWeekDayString = """";
    String endWeekDayString = """";
    if (showWeekDay) {
        String weekDayFormat = """";
        if (abbrevWeekDay) {
            weekDayFormat = ABBREV_WEEKDAY_FORMAT;
        } else {
            weekDayFormat = WEEKDAY_FORMAT;
        }
        startWeekDayString = startDate.format(weekDayFormat);
        endWeekDayString = isInstant ? startWeekDayString : endDate.format(weekDayFormat);
    }
    String startTimeString = """";
    String endTimeString = """";
    if (showTime) {
        String startTimeFormat = """";
        String endTimeFormat = """";
        boolean force24Hour = (flags & FORMAT_24HOUR) != 0;
        boolean force12Hour = (flags & FORMAT_12HOUR) != 0;
        boolean use24Hour;
        if (force24Hour) {
            use24Hour = true;
        } else if (force12Hour) {
            use24Hour = false;
        } else {
            use24Hour = DateFormat.is24HourFormat(context);
        }
        if (use24Hour) {
            startTimeFormat = endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_24);
        } else {
            boolean abbrevTime = (flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
            boolean capAMPM = (flags & FORMAT_CAP_AMPM) != 0;
            boolean noNoon = (flags & FORMAT_NO_NOON) != 0;
            boolean capNoon = (flags & FORMAT_CAP_NOON) != 0;
            boolean noMidnight = (flags & FORMAT_NO_MIDNIGHT) != 0;
            boolean capMidnight = (flags & FORMAT_CAP_MIDNIGHT) != 0;
            boolean startOnTheHour = startDate.minute == 0 && startDate.second == 0;
            boolean endOnTheHour = endDate.minute == 0 && endDate.second == 0;
            if (abbrevTime && startOnTheHour) {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                }
            } else {
                if (capAMPM) {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                }
            }
            // point)
            if (!isInstant) {
                if (abbrevTime && endOnTheHour) {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_ampm);
                    }
                } else {
                    if (capAMPM) {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.hour_minute_ampm);
                    }
                }
                if (endDate.hour == 12 && endOnTheHour && !noNoon) {
                    if (capNoon) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Noon);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.noon);
                    }
                } else if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
                    if (capMidnight) {
                        endTimeFormat = res.getString(com.android.internal.R.string.Midnight);
                    } else {
                        endTimeFormat = res.getString(com.android.internal.R.string.midnight);
                    }
                }
            }
            if (startDate.hour == 12 && startOnTheHour && !noNoon) {
                if (capNoon) {
                    startTimeFormat = res.getString(com.android.internal.R.string.Noon);
                } else {
                    startTimeFormat = res.getString(com.android.internal.R.string.noon);
                }
            // Don't show the start time starting at midnight.  Show
            // 12am instead.
            }
        }
        startTimeString = startDate.format(startTimeFormat);
        endTimeString = isInstant ? startTimeString : endDate.format(endTimeFormat);
    }
    // user specified FORMAT_NO_YEAR.
    if (showYear) {
    // No code... just a comment for clarity.  Keep showYear
    // on, as they enabled it with FORMAT_SHOW_YEAR.  This
    // takes precedence over them setting FORMAT_NO_YEAR.
    } else if (noYear) {
        // They explicitly didn't want a year.
        showYear = false;
    } else if (startYear != endYear) {
        showYear = true;
    } else {
        // Show the year if it's not equal to the current year.
        Time currentTime = new Time();
        currentTime.setToNow();
        showYear = startYear != currentTime.year;
    }
    String defaultDateFormat, fullFormat, dateRange;
    if (numericDate) {
        defaultDateFormat = res.getString(com.android.internal.R.string.numeric_date);
    } else if (showYear) {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day_year);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_year);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day_year);
            }
        }
    } else {
        if (abbrevMonth) {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.abbrev_month_day);
            }
        } else {
            if (noMonthDay) {
                defaultDateFormat = res.getString(com.android.internal.R.string.month);
            } else {
                defaultDateFormat = res.getString(com.android.internal.R.string.month_day);
            }
        }
    }
    if (showWeekDay) {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
        }
    } else {
        if (showTime) {
            fullFormat = res.getString(com.android.internal.R.string.date1_time1_date2_time2);
        } else {
            fullFormat = res.getString(com.android.internal.R.string.date1_date2);
        }
    }
    if (noMonthDay && startMonthNum == endMonthNum) {
        // Example: ""January, 2008""
        return formatter.format(""%s"", startDate.format(defaultDateFormat));
    }
    if (startYear != endYear || noMonthDay) {
        // Different year or we are not showing the month day number.
        // Example: ""December 31, 2007 - January 1, 2008""
        // Or: ""January - February, 2008""
        String startDateString = startDate.format(defaultDateFormat);
        String endDateString = endDate.format(defaultDateFormat);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startDateString, startTimeString, endWeekDayString, endDateString, endTimeString);
    }
    // Get the month, day, and year strings for the start and end dates
    String monthFormat;
    if (numericDate) {
        monthFormat = NUMERIC_MONTH_FORMAT;
    } else if (abbrevMonth) {
        monthFormat = res.getString(com.android.internal.R.string.short_format_month);
    } else {
        monthFormat = MONTH_FORMAT;
    }
    String startMonthString = startDate.format(monthFormat);
    String startMonthDayString = startDate.format(MONTH_DAY_FORMAT);
    String startYearString = startDate.format(YEAR_FORMAT);
    String endMonthString = isInstant ? null : endDate.format(monthFormat);
    String endMonthDayString = isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
    String endYearString = isInstant ? null : endDate.format(YEAR_FORMAT);
    if (startMonthNum != endMonthNum) {
        // Same year, different month.
        // Example: ""October 28 - November 3""
        // or: ""Wed, Oct 31 - Sat, Nov 3, 2007""
        // or: ""Oct 31, 8am - Sat, Nov 3, 2007, 5pm""
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameYearTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    if (startDay != endDay) {
        // Same month, different day.
        int index = 0;
        if (showWeekDay)
            index = 1;
        if (showYear)
            index += 2;
        if (showTime)
            index += 4;
        if (numericDate)
            index += 8;
        int resId = sameMonthTable[index];
        fullFormat = res.getString(resId);
        // by position.
        return formatter.format(fullFormat, startWeekDayString, startMonthString, startMonthDayString, startYearString, startTimeString, endWeekDayString, endMonthString, endMonthDayString, endYearString, endTimeString);
    }
    // Same start and end day
    boolean showDate = (flags & FORMAT_SHOW_DATE) != 0;
    // If nothing was specified, then show the date.
    if (!showTime && !showDate && !showWeekDay)
        showDate = true;
    // Compute the time string (example: ""10:00 - 11:00 am"")
    String timeString = """";
    if (showTime) {
        // start time.
        if (isInstant) {
            // Same start and end time.
            // Example: ""10:15 AM""
            timeString = startTimeString;
        } else {
            // Example: ""10:00 - 11:00 am""
            String timeFormat = res.getString(com.android.internal.R.string.time1_time2);
            // Don't use the user supplied Formatter because the result will pollute the buffer.
            timeString = String.format(timeFormat, startTimeString, endTimeString);
        }
    }
    // Figure out which full format to use.
    fullFormat = """";
    String dateString = """";
    if (showDate) {
        dateString = startDate.format(defaultDateFormat);
        if (showWeekDay) {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_wday_date);
            } else {
                // Example: ""Tue, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.wday_date);
            }
        } else {
            if (showTime) {
                // Example: ""10:00 - 11:00 am, Oct 9""
                fullFormat = res.getString(com.android.internal.R.string.time_date);
            } else {
                // Example: ""Oct 9""
                return formatter.format(""%s"", dateString);
            }
        }
    } else if (showWeekDay) {
        if (showTime) {
            // Example: ""10:00 - 11:00 am, Tue""
            fullFormat = res.getString(com.android.internal.R.string.time_wday);
        } else {
            // Example: ""Tue""
            return formatter.format(""%s"", startWeekDayString);
        }
    } else if (showTime) {
        return formatter.format(""%s"", timeString);
    }
    // by position.
    return formatter.format(fullFormat, timeString, startWeekDayString, dateString);
}","{
    return formatDateRange(context, formatter, startMillis, endMillis, flags, null);
}",1,"/**
 * Formats a date or a time range according to the local conventions.
 *
 * <p>
 * Example output strings (date formats in these examples are shown using
 * the US date format convention but that may change depending on the
 * local settings):
 * <ul>
 * <li>10:15am</li>
 * <li>3:00pm - 4:00pm</li>
 * <li>3pm - 4pm</li>
 * <li>3PM - 4PM</li>
 * <li>08:00 - 17:00</li>
 * <li>Oct 9</li>
 * <li>Tue, Oct 9</li>
 * <li>October 9, 2007</li>
 * <li>Oct 9 - 10</li>
 * <li>Oct 9 - 10, 2007</li>
 * <li>Oct 28 - Nov 3, 2007</li>
 * <li>Dec 31, 2007 - Jan 1, 2008</li>
 * <li>Oct 9, 8:00am - Oct 10, 5:00pm</li>
 * <li>12/31/2007 - 01/01/2008</li>
 * </ul>
 *
 * <p>
 * The flags argument is a bitmask of options from the following list:
 *
 * <ul>
 * <li>FORMAT_SHOW_TIME</li>
 * <li>FORMAT_SHOW_WEEKDAY</li>
 * <li>FORMAT_SHOW_YEAR</li>
 * <li>FORMAT_NO_YEAR</li>
 * <li>FORMAT_SHOW_DATE</li>
 * <li>FORMAT_NO_MONTH_DAY</li>
 * <li>FORMAT_12HOUR</li>
 * <li>FORMAT_24HOUR</li>
 * <li>FORMAT_CAP_AMPM</li>
 * <li>FORMAT_NO_NOON</li>
 * <li>FORMAT_CAP_NOON</li>
 * <li>FORMAT_NO_MIDNIGHT</li>
 * <li>FORMAT_CAP_MIDNIGHT</li>
 * <li>FORMAT_UTC</li>
 * <li>FORMAT_ABBREV_TIME</li>
 * <li>FORMAT_ABBREV_WEEKDAY</li>
 * <li>FORMAT_ABBREV_MONTH</li>
 * <li>FORMAT_ABBREV_ALL</li>
 * <li>FORMAT_NUMERIC_DATE</li>
 * </ul>
 *
 * <p>
 * If FORMAT_SHOW_TIME is set, the time is shown as part of the date range.
 * If the start and end time are the same, then just the start time is
 * shown.
 *
 * <p>
 * If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown.
 *
 * <p>
 * If FORMAT_SHOW_YEAR is set, then the year is always shown.
 * If FORMAT_NO_YEAR is set, then the year is not shown.
 * If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year
 * is shown only if it is different from the current year, or if the start
 * and end dates fall on different years.  If both are set,
 * FORMAT_SHOW_YEAR takes precedence.
 *
 * <p>
 * Normally the date is shown unless the start and end day are the same.
 * If FORMAT_SHOW_DATE is set, then the date is always shown, even for
 * same day ranges.
 *
 * <p>
 * If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the
 * month name will be shown, not the day of the month.  For example,
 * ""January, 2008"" instead of ""January 6 - 12, 2008"".
 *
 * <p>
 * If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM""
 * and ""PM"" are capitalized.  You should not use this flag
 * because in some locales these terms cannot be capitalized, and in
 * many others it doesn't make sense to do so even though it is possible.
 *
 * <p>
 * If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is
 * shown instead of ""noon"".
 *
 * <p>
 * If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is
 * shown instead of ""noon"".  You should probably not use this flag
 * because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is
 * shown instead of ""midnight"".
 *
 * <p>
 * If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight""
 * is shown instead of ""midnight"".  You should probably not use this
 * flag because in many locales it will not make sense to capitalize
 * the term.
 *
 * <p>
 * If FORMAT_12HOUR is set and the time is shown, then the time is
 * shown in the 12-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_24HOUR is set and the time is shown, then the time is
 * shown in the 24-hour time format. You should not normally set this.
 * Instead, let the time format be chosen automatically according to the
 * system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then
 * FORMAT_24HOUR takes precedence.
 *
 * <p>
 * If FORMAT_UTC is set, then the UTC timezone is used for the start
 * and end milliseconds.
 *
 * <p>
 * If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the
 * start and end times (if shown) are abbreviated by not showing the minutes
 * if they are zero.  For example, instead of ""3:00pm"" the time would be
 * abbreviated to ""3pm"".
 *
 * <p>
 * If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is
 * abbreviated to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated
 * to a 3-letter string.
 *
 * <p>
 * If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown)
 * are abbreviated to 3-letter strings.
 *
 * <p>
 * If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format
 * instead of using the name of the month.  For example, ""12/31/2008""
 * instead of ""December 31, 2008"".
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 *
 * @return the formatter with the formatted date/time range appended to the string buffer.
 */
","/**
 * Formats a date or a time range according to the local conventions.
 * <p>
 * Note that this is a convenience method for formatting the date or
 * time range in the local time zone. If you want to specify the time
 * zone please use
 * {@link #formatDateRange(Context, Formatter, long, long, int, String) formatDateRange}.
 *
 * @param context the context is required only if the time is shown
 * @param formatter the Formatter used for formatting the date range.
 * Note: be sure to call setLength(0) on StringBuilder passed to
 * the Formatter constructor unless you want the results to accumulate.
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options See
 * {@link #formatDateRange(Context, Formatter, long, long, int, String) formatDateRange}
 * @return a string containing the formatted date/time range.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
136,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,8,9,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mNativeClass == 0 || !isClickable() || !isLongClickable()) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action;
    float x, y;
    long eventTime = ev.getEventTime();
    // events later.
    if (mSupportMultiTouch && ev.getPointerCount() > 1) {
        if (mMinZoomScale < mMaxZoomScale) {
            mScaleDetector.onTouchEvent(ev);
            if (mScaleDetector.isInProgress()) {
                mLastTouchTime = eventTime;
                return true;
            }
            x = mScaleDetector.getFocusX();
            y = mScaleDetector.getFocusY();
            action = ev.getAction() & MotionEvent.ACTION_MASK;
            if (action == MotionEvent.ACTION_POINTER_DOWN) {
                cancelTouch();
                action = MotionEvent.ACTION_DOWN;
            } else if (action == MotionEvent.ACTION_POINTER_UP) {
                // set mLastTouchX/Y to the remaining point
                mLastTouchX = x;
                mLastTouchY = y;
            } else if (action == MotionEvent.ACTION_MOVE) {
                // negative x or y indicate it is on the edge, skip it.
                if (x < 0 || y < 0) {
                    return true;
                }
            }
        } else {
            // if the page disallow zoom, skip multi-pointer action
            return true;
        }
    } else {
        action = ev.getAction();
        x = ev.getX();
        y = ev.getY();
    }
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    float fDeltaX = mLastTouchX - x;
    float fDeltaY = mLastTouchY - y;
    int deltaX = (int) fDeltaX;
    int deltaY = (int) fDeltaY;
    int contentX = viewToContentX((int) x + mScrollX);
    int contentY = viewToContentY((int) y + mScrollY);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDefault = PREVENT_DEFAULT_NO;
                mConfirmMove = false;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mConfirmMove = true;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
                } else if (!inFullScreenMode() && mShiftIsPressed) {
                    mSelectX = mScrollX + (int) x;
                    mSelectY = mScrollY + (int) y;
                    mTouchMode = TOUCH_SELECT_MODE;
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""select="" + mSelectX + "","" + mSelectY);
                    }
                    nativeMoveSelection(contentX, contentY, false);
                    mTouchSelection = mExtendSelection = true;
                    // draw the i-beam instead of the arrow
                    invalidate();
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                        mTouchMode = TOUCH_INIT_MODE;
                        mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    }
                } else {
                    // the normal case
                    mPreviewZoomOnly = false;
                    mTouchMode = TOUCH_INIT_MODE;
                    mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS, TAP_TIMEOUT);
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS, LONG_PRESS_TIMEOUT);
                    if (inFullScreenMode() || mDeferTouchProcess) {
                        mPreventDefault = PREVENT_DEFAULT_YES;
                    } else if (mForwardTouchEvents) {
                        mPreventDefault = PREVENT_DEFAULT_MAYBE_YES;
                    } else {
                        mPreventDefault = PREVENT_DEFAULT_NO;
                    }
                    // pass the touch events from UI thread to WebCore thread
                    if (shouldForwardTouchEvent()) {
                        TouchEventData ted = new TouchEventData();
                        ted.mAction = action;
                        ted.mX = contentX;
                        ted.mY = contentY;
                        ted.mMetaState = ev.getMetaState();
                        ted.mReprocess = mDeferTouchProcess;
                        if (mDeferTouchProcess) {
                            // still needs to set them for compute deltaX/Y
                            mLastTouchX = x;
                            mLastTouchY = y;
                            ted.mViewX = x;
                            ted.mViewY = y;
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                            break;
                        }
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        if (!inFullScreenMode()) {
                            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                        }
                    }
                }
                startTouch(x, y, eventTime);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                boolean firstMove = false;
                if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
                    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    mConfirmMove = true;
                    firstMove = true;
                    if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mTouchMode = TOUCH_INIT_MODE;
                    }
                }
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
                    mLastSentTouchTime = eventTime;
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        break;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                    if (firstMove && !inFullScreenMode()) {
                        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                    }
                }
                if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
                    // default is yes
                    break;
                }
                if (mVelocityTracker == null) {
                    Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess + "" mTouchMode = "" + mTouchMode);
                }
                mVelocityTracker.addMovement(ev);
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (mTouchMode == TOUCH_SELECT_MODE) {
                        mSelectX = mScrollX + (int) x;
                        mSelectY = mScrollY + (int) y;
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""xtend="" + mSelectX + "","" + mSelectY);
                        }
                        nativeMoveSelection(contentX, contentY, true);
                        invalidate();
                        break;
                    }
                    if (!mConfirmMove) {
                        break;
                    }
                    if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    // if it starts nearly horizontal or vertical, enforce it
                    int ax = Math.abs(deltaX);
                    int ay = Math.abs(deltaY);
                    if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                        mSnapScrollMode = SNAP_X;
                        mSnapPositive = deltaX > 0;
                    } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                        mSnapScrollMode = SNAP_Y;
                        mSnapPositive = deltaY > 0;
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    mLastTouchX = x;
                    mLastTouchY = y;
                    fDeltaX = 0.0f;
                    fDeltaY = 0.0f;
                    deltaX = 0;
                    deltaY = 0;
                    startDrag();
                }
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.dragTo(x, y);
                }
                // do pan
                int newScrollX = pinLocX(mScrollX + deltaX);
                int newDeltaX = newScrollX - mScrollX;
                if (deltaX != newDeltaX) {
                    deltaX = newDeltaX;
                    fDeltaX = (float) newDeltaX;
                }
                int newScrollY = pinLocY(mScrollY + deltaY);
                int newDeltaY = newScrollY - mScrollY;
                if (deltaY != newDeltaY) {
                    deltaY = newDeltaY;
                    fDeltaY = (float) newDeltaY;
                }
                boolean done = false;
                boolean keepScrollBarsVisible = false;
                if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
                    mLastTouchX = x;
                    mLastTouchY = y;
                    keepScrollBarsVisible = done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode != SNAP_NONE) {
                        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
                            deltaY = 0;
                        } else {
                            deltaX = 0;
                        }
                    }
                    if ((deltaX | deltaY) != 0) {
                        if (deltaX != 0) {
                            mLastTouchX = x;
                        }
                        if (deltaY != 0) {
                            mLastTouchY = y;
                        }
                        mHeldMotionless = MOTIONLESS_FALSE;
                    } else {
                        // keep the scrollbar on the screen even there is no
                        // scroll
                        mLastTouchX = x;
                        mLastTouchY = y;
                        keepScrollBarsVisible = true;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                doDrag(deltaX, deltaY);
                if (keepScrollBarsVisible) {
                    if (mHeldMotionless != MOTIONLESS_TRUE) {
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    }
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return !done;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent()) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                }
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (inFullScreenMode() || mDeferTouchProcess) {
                            TouchEventData ted = new TouchEventData();
                            ted.mAction = WebViewCore.ACTION_DOUBLETAP;
                            ted.mX = contentX;
                            ted.mY = contentY;
                            ted.mMetaState = ev.getMetaState();
                            ted.mReprocess = mDeferTouchProcess;
                            if (mDeferTouchProcess) {
                                ted.mViewX = x;
                                ted.mViewY = y;
                            }
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                            doDoubleTap();
                            mTouchMode = TOUCH_DONE_MODE;
                        }
                        break;
                    case TOUCH_SELECT_MODE:
                        commitCopy();
                        mTouchSelection = false;
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (mConfirmMove) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
                                // UI takes control back, cancel WebCore touch
                                cancelWebCoreTouchEvent(contentX, contentY, true);
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.reducePriority();
                                // to get better performance, pause updating the
                                // picture
                                WebViewCore.pauseUpdatePicture(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                // WebKit may consume the touch event and modify
                                // DOM. drawContentPicture() will be called with
                                // animateSroll as true for better performance.
                                // Force redraw in high-quality.
                                invalidate();
                                break;
                            }
                        } else {
                            if (mTouchMode == TOUCH_INIT_MODE) {
                                mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP, ViewConfiguration.getDoubleTapTimeout());
                            } else {
                                doShortPress();
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
                        mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            if (mVelocityTracker == null) {
                                Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess);
                            }
                            mVelocityTracker.addMovement(ev);
                            // set to MOTIONLESS_IGNORE so that it won't keep
                            // removing and sending message in
                            // drawCoreAndCursorRing()
                            mHeldMotionless = MOTIONLESS_IGNORE;
                            doFling();
                            break;
                        }
                        // redraw in high-quality, as we're done dragging
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    // fall through
                    case TOUCH_DRAG_START_MODE:
                        // TOUCH_DRAG_START_MODE should not happen for the real
                        // device as we almost certain will get a MOVE. But this
                        // is possible on emulator.
                        mLastVelocity = 0;
                        WebViewCore.resumePriority();
                        WebViewCore.resumeUpdatePicture(mWebViewCore);
                        break;
                }
                stopTouch();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    invalidate();
                }
                cancelWebCoreTouchEvent(contentX, contentY, false);
                cancelTouch();
                break;
            }
    }
    return true;
}","{
    if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
        return false;
    }
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode);
    }
    int action;
    float x, y;
    long eventTime = ev.getEventTime();
    // events later.
    if (mSupportMultiTouch && ev.getPointerCount() > 1) {
        if (mAllowPanAndScale || mMinZoomScale < mMaxZoomScale) {
            mScaleDetector.onTouchEvent(ev);
            if (mScaleDetector.isInProgress()) {
                mLastTouchTime = eventTime;
                if (!mAllowPanAndScale) {
                    return true;
                }
                mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
            }
            x = mScaleDetector.getFocusX();
            y = mScaleDetector.getFocusY();
            action = ev.getAction() & MotionEvent.ACTION_MASK;
            if (action == MotionEvent.ACTION_POINTER_DOWN) {
                cancelTouch();
                action = MotionEvent.ACTION_DOWN;
            } else if (action == MotionEvent.ACTION_POINTER_UP) {
                // set mLastTouchX/Y to the remaining point
                mLastTouchX = x;
                mLastTouchY = y;
            } else if (action == MotionEvent.ACTION_MOVE) {
                // negative x or y indicate it is on the edge, skip it.
                if (x < 0 || y < 0) {
                    return true;
                }
            }
        } else {
            // if the page disallow zoom, skip multi-pointer action
            return true;
        }
    } else {
        action = ev.getAction();
        x = ev.getX();
        y = ev.getY();
    }
    // getViewWidth(). Same applied to the height.
    if (x > getViewWidth() - 1) {
        x = getViewWidth() - 1;
    }
    if (y > getViewHeightWithTitle() - 1) {
        y = getViewHeightWithTitle() - 1;
    }
    float fDeltaX = mLastTouchX - x;
    float fDeltaY = mLastTouchY - y;
    int deltaX = (int) fDeltaX;
    int deltaY = (int) fDeltaY;
    int contentX = viewToContentX((int) x + mScrollX);
    int contentY = viewToContentY((int) y + mScrollY);
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                mPreventDefault = PREVENT_DEFAULT_NO;
                mConfirmMove = false;
                if (!mScroller.isFinished()) {
                    // stop the current scroll animation, but if this is
                    // the start of a fling, allow it to add to the current
                    // fling's velocity
                    mScroller.abortAnimation();
                    mTouchMode = TOUCH_DRAG_START_MODE;
                    mConfirmMove = true;
                    mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
                } else if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
                    mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
                    if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
                        mTouchMode = TOUCH_DOUBLE_TAP_MODE;
                    } else {
                        // commit the short press action for the previous tap
                        doShortPress();
                        mTouchMode = TOUCH_INIT_MODE;
                        mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    }
                } else {
                    // the normal case
                    mPreviewZoomOnly = false;
                    mTouchMode = TOUCH_INIT_MODE;
                    mDeferTouchProcess = (!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX, contentY) : false;
                    mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
                    if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
                        EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION, (eventTime - mLastTouchUpTime), eventTime);
                    }
                    if (mSelectingText) {
                        mDrawSelectionPointer = false;
                        mSelectionStarted = nativeStartSelection(contentX, contentY);
                        if (DebugFlags.WEB_VIEW) {
                            Log.v(LOGTAG, ""select="" + contentX + "","" + contentY);
                        }
                        invalidate();
                    }
                }
                // Trigger the link
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS, TAP_TIMEOUT);
                    mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS, LONG_PRESS_TIMEOUT);
                    if (inFullScreenMode() || mDeferTouchProcess) {
                        mPreventDefault = PREVENT_DEFAULT_YES;
                    } else if (mForwardTouchEvents) {
                        mPreventDefault = PREVENT_DEFAULT_MAYBE_YES;
                    } else {
                        mPreventDefault = PREVENT_DEFAULT_NO;
                    }
                    // pass the touch events from UI thread to WebCore thread
                    if (shouldForwardTouchEvent()) {
                        TouchEventData ted = new TouchEventData();
                        ted.mAction = action;
                        ted.mX = contentX;
                        ted.mY = contentY;
                        ted.mMetaState = ev.getMetaState();
                        ted.mReprocess = mDeferTouchProcess;
                        if (mDeferTouchProcess) {
                            // still needs to set them for compute deltaX/Y
                            mLastTouchX = x;
                            mLastTouchY = y;
                            ted.mViewX = x;
                            ted.mViewY = y;
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                            break;
                        }
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        if (!inFullScreenMode()) {
                            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                        }
                    }
                }
                startTouch(x, y, eventTime);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                boolean firstMove = false;
                if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
                    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                    mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                    mConfirmMove = true;
                    firstMove = true;
                    if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                        mTouchMode = TOUCH_INIT_MODE;
                    }
                }
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
                    mLastSentTouchTime = eventTime;
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                        mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        break;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                    if (firstMove && !inFullScreenMode()) {
                        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT, action, 0), TAP_TIMEOUT);
                    }
                }
                if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
                    // default is yes
                    break;
                }
                if (mVelocityTracker == null) {
                    Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess + "" mTouchMode = "" + mTouchMode);
                }
                mVelocityTracker.addMovement(ev);
                if (mSelectingText && mSelectionStarted) {
                    if (DebugFlags.WEB_VIEW) {
                        Log.v(LOGTAG, ""extend="" + contentX + "","" + contentY);
                    }
                    nativeExtendSelection(contentX, contentY);
                    invalidate();
                    break;
                }
                if (mTouchMode != TOUCH_DRAG_MODE) {
                    if (!mConfirmMove) {
                        break;
                    }
                    if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                        // track mLastTouchTime as we may need to do fling at
                        // ACTION_UP
                        mLastTouchTime = eventTime;
                        break;
                    }
                    // if mAllowPanAndScale is true.
                    if (mScaleDetector != null && !mScaleDetector.isInProgress()) {
                        // if it starts nearly horizontal or vertical, enforce it
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
                            mSnapScrollMode = SNAP_X;
                            mSnapPositive = deltaX > 0;
                        } else if (ay > MAX_SLOPE_FOR_DIAG * ax) {
                            mSnapScrollMode = SNAP_Y;
                            mSnapPositive = deltaY > 0;
                        }
                    }
                    mTouchMode = TOUCH_DRAG_MODE;
                    mLastTouchX = x;
                    mLastTouchY = y;
                    fDeltaX = 0.0f;
                    fDeltaY = 0.0f;
                    deltaX = 0;
                    deltaY = 0;
                    startDrag();
                }
                if (mDragTrackerHandler != null) {
                    mDragTrackerHandler.dragTo(x, y);
                }
                // do pan
                boolean done = false;
                boolean keepScrollBarsVisible = false;
                if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
                    mLastTouchX = x;
                    mLastTouchY = y;
                    keepScrollBarsVisible = done = true;
                } else {
                    if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
                        int ax = Math.abs(deltaX);
                        int ay = Math.abs(deltaY);
                        if (mSnapScrollMode == SNAP_X) {
                            // radical change means getting out of snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        } else {
                            // radical change means getting out of snap mode
                            if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
                                mSnapScrollMode = SNAP_NONE;
                            }
                            // reverse direction means lock in the snap mode
                            if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
                                mSnapScrollMode |= SNAP_LOCK;
                            }
                        }
                    }
                    if (mSnapScrollMode != SNAP_NONE) {
                        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
                            deltaY = 0;
                        } else {
                            deltaX = 0;
                        }
                    }
                    if ((deltaX | deltaY) != 0) {
                        if (deltaX != 0) {
                            mLastTouchX = x;
                        }
                        if (deltaY != 0) {
                            mLastTouchY = y;
                        }
                        mHeldMotionless = MOTIONLESS_FALSE;
                    } else {
                        // keep the scrollbar on the screen even there is no
                        // scroll
                        mLastTouchX = x;
                        mLastTouchY = y;
                        keepScrollBarsVisible = true;
                    }
                    mLastTouchTime = eventTime;
                    mUserScroll = true;
                }
                doDrag(deltaX, deltaY);
                if (keepScrollBarsVisible) {
                    if (mHeldMotionless != MOTIONLESS_TRUE) {
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    }
                    // keep the scrollbar on the screen even there is no scroll
                    awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                    // view space
                    return !done;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                // pass the touch events from UI thread to WebCore thread
                if (shouldForwardTouchEvent()) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = action;
                    ted.mX = contentX;
                    ted.mY = contentY;
                    ted.mMetaState = ev.getMetaState();
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = x;
                        ted.mViewY = y;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                }
                mLastTouchUpTime = eventTime;
                switch(mTouchMode) {
                    case // double tap
                    TOUCH_DOUBLE_TAP_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (inFullScreenMode() || mDeferTouchProcess) {
                            TouchEventData ted = new TouchEventData();
                            ted.mAction = WebViewCore.ACTION_DOUBLETAP;
                            ted.mX = contentX;
                            ted.mY = contentY;
                            ted.mMetaState = ev.getMetaState();
                            ted.mReprocess = mDeferTouchProcess;
                            if (mDeferTouchProcess) {
                                ted.mViewX = x;
                                ted.mViewY = y;
                            }
                            mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                        } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                            doDoubleTap();
                            mTouchMode = TOUCH_DONE_MODE;
                        }
                        break;
                    // tap
                    case TOUCH_INIT_MODE:
                    case TOUCH_SHORTPRESS_START_MODE:
                    case TOUCH_SHORTPRESS_MODE:
                        mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
                        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
                        if (mConfirmMove) {
                            Log.w(LOGTAG, ""Miss a drag as we are waiting for"" + "" WebCore's response for touch down."");
                            if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
                                // UI takes control back, cancel WebCore touch
                                cancelWebCoreTouchEvent(contentX, contentY, true);
                                // we will not rewrite drag code here, but we
                                // will try fling if it applies.
                                WebViewCore.reducePriority();
                                // to get better performance, pause updating the
                                // picture
                                WebViewCore.pauseUpdatePicture(mWebViewCore);
                            // fall through to TOUCH_DRAG_MODE
                            } else {
                                // WebKit may consume the touch event and modify
                                // DOM. drawContentPicture() will be called with
                                // animateSroll as true for better performance.
                                // Force redraw in high-quality.
                                invalidate();
                                break;
                            }
                        } else {
                            if (mSelectingText) {
                                if (nativeHitSelection(contentX, contentY)) {
                                    copySelection();
                                }
                                selectionDone();
                                break;
                            }
                            if (mTouchMode == TOUCH_INIT_MODE) {
                                mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP, ViewConfiguration.getDoubleTapTimeout());
                            } else {
                                doShortPress();
                            }
                            break;
                        }
                    case TOUCH_DRAG_MODE:
                        mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
                        mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
                        // up, we don't want to do a fling
                        if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
                            if (mVelocityTracker == null) {
                                Log.e(LOGTAG, ""Got null mVelocityTracker when "" + ""mPreventDefault = "" + mPreventDefault + "" mDeferTouchProcess = "" + mDeferTouchProcess);
                            }
                            mVelocityTracker.addMovement(ev);
                            // set to MOTIONLESS_IGNORE so that it won't keep
                            // removing and sending message in
                            // drawCoreAndCursorRing()
                            mHeldMotionless = MOTIONLESS_IGNORE;
                            doFling();
                            break;
                        } else {
                            if (mScroller.springBack(mScrollX, mScrollY, 0, computeMaxScrollX(), 0, computeMaxScrollY())) {
                                invalidate();
                            }
                        }
                        // redraw in high-quality, as we're done dragging
                        mHeldMotionless = MOTIONLESS_TRUE;
                        invalidate();
                    // fall through
                    case TOUCH_DRAG_START_MODE:
                        // TOUCH_DRAG_START_MODE should not happen for the real
                        // device as we almost certain will get a MOVE. But this
                        // is possible on emulator.
                        mLastVelocity = 0;
                        WebViewCore.resumePriority();
                        WebViewCore.resumeUpdatePicture(mWebViewCore);
                        break;
                }
                stopTouch();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                if (mTouchMode == TOUCH_DRAG_MODE) {
                    mScroller.springBack(mScrollX, mScrollY, 0, computeMaxScrollX(), 0, computeMaxScrollY());
                    invalidate();
                }
                cancelWebCoreTouchEvent(contentX, contentY, false);
                cancelTouch();
                break;
            }
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
137,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",8,9,"<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(Socket,String,int,boolean)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The control dependency has changed since the 'if' statement and 'verifyHostname()' method is added. The 'verifyHostname()' is an additional statement, so the code change type is 3,4.","The added 'verifyHostname()' function may potentially affect the return value of createSocket() function depending on the parameters passed. Hence, the API could return a different value and the CI type is 1."
138,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,8,9,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,0,"{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            result = mITts.isLanguageAvailable(language, country, variant, mCachedParams);
            if (result >= LANG_AVAILABLE) {
                mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] = language;
                if (result >= LANG_COUNTRY_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = country;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = """";
                }
                if (result >= LANG_COUNTRY_VAR_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = variant;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = """";
                }
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        if (loc == null) {
            return result;
        }
        try {
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            result = mITts.isLanguageAvailable(language, country, variant, mCachedParams);
            if (result >= LANG_AVAILABLE) {
                mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] = language;
                if (result >= LANG_COUNTRY_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = country;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = """";
                }
                if (result >= LANG_COUNTRY_VAR_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = variant;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = """";
                }
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}",1,"/**
 * Sets the language for the TextToSpeech engine.
 * The TextToSpeech engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc
 * The locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the language for the TextToSpeech engine.
 * The TextToSpeech engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc
 * The locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"A new condition statement 'if (loc == null)' is added in the late version code, so the change type is 3.","The introduced condition statement could potentially lead to different return values when loc is null, so the CI type is 1."
139,<android.os.DropBoxManager.Entry: String getText(int)>,8,9,<android.os.DropBoxManager.Entry: String getText(int)>,<android.os.DropBoxManager.Entry: String getText(int)>,0,"{
    if ((mFlags & IS_TEXT) == 0)
        return null;
    if (mData != null)
        return new String(mData, 0, Math.min(maxBytes, mData.length));
    InputStream is = null;
    try {
        is = getInputStream();
        byte[] buf = new byte[maxBytes];
        return new String(buf, 0, Math.max(0, is.read(buf)));
    } catch (IOException e) {
        return null;
    } finally {
        try {
            if (is != null)
                is.close();
        } catch (IOException e) {
        }
    }
}","{
    if ((mFlags & IS_TEXT) == 0)
        return null;
    if (mData != null)
        return new String(mData, 0, Math.min(maxBytes, mData.length));
    InputStream is = null;
    try {
        is = getInputStream();
        if (is == null)
            return null;
        byte[] buf = new byte[maxBytes];
        return new String(buf, 0, Math.max(0, is.read(buf)));
    } catch (IOException e) {
        return null;
    } finally {
        try {
            if (is != null)
                is.close();
        } catch (IOException e) {
        }
    }
}",1,"/**
 * @param maxBytes of string to return (will truncate at this length).
 * @return the uncompressed text contents of the entry, null if the entry is not text.
 */
","/**
 * @param maxBytes of string to return (will truncate at this length).
 * @return the uncompressed text contents of the entry, null if the entry is not text.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The implementation has changed slightly with the addition of a new statement 'if (is == null) return null;', so the code change type is 3, as it changes the control dependency.","The CI type is 1 because of the addition of the new control statement 'if (is == null) return null;'. This might lead to a potential different return value in comparison to the previous implementation, depending on the condition of 'is'."
143,<android.os.Parcel: void readException()>,8,9,<android.os.Parcel: void readException()>,<android.os.Parcel: void readException()>,0,"{
    int code = readInt();
    if (code == 0)
        return;
    String msg = readString();
    readException(code, msg);
}","{
    int code = readExceptionCode();
    if (code != 0) {
        String msg = readString();
        readException(code, msg);
    }
}",1,"/**
 * Special function for reading an exception result from the header of
 * a parcel, to be used after receiving the result of a transaction.  This
 * will throw the exception for you if it had been written to the Parcel,
 * otherwise return and let you read the normal result data from the Parcel.
 *
 * @see #writeException
 * @see #writeNoException
 */
","/**
 * Special function for reading an exception result from the header of
 * a parcel, to be used after receiving the result of a transaction.  This
 * will throw the exception for you if it had been written to the Parcel,
 * otherwise return and let you read the normal result data from the Parcel.
 *
 * @see #writeException
 * @see #writeNoException
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,"The method called in the first line of code has changed from readInt() to readExceptionCode(), which now depends on another API. The implementation of readInt and readExceptionCode may vary, leading to changes in the returned 'code' value. The conditional statement has also changed, it was previously 'if (code == 0)' and it is now 'if (code != 0)'. Thus, the change type is 1,3,5.","The change in the method called to fetch 'code', as well as the alteration of the condition under which an exception is read, can potentially lead to a different exception being thrown or none at all in different scenarios. Therefore, a different return behaviour is possible and a Compatibility Issue (CI) of type 1 exists."
144,<android.view.MotionEvent: float getRawX()>,8,9,<android.view.MotionEvent: float getRawX()>,<android.view.MotionEvent: float getRawX()>,0,"{
    return mRawX;
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_X];
}",1,"/**
 * Returns the original raw X coordinate of this event.  For touch
 * events on the screen, this is the original location of the event
 * on the screen, before it had been adjusted for the containing window
 * and views.
 */
","/**
 * Returns the original raw X coordinate of this event.  For touch
 * events on the screen, this is the original location of the event
 * on the screen, before it had been adjusted for the containing window
 * and views.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The code change occurs specifically in the return statement, changing from returning variable 'mRawX' to 'mDataSamples[mLastDataSampleIndex + SAMPLE_X]'. Hence, the change type is categorized into type 1: Return statement changed.","Changing what the API returns ('mRawX' to 'mDataSamples[mLastDataSampleIndex + SAMPLE_X]') could potentially lead to different values which may affect the behavior of programs that depend on the function. Thus, the Compatibility Issue is considered as type 1: Compatibility Issue caused by the potential different return values."
145,<android.inputmethodservice.ExtractEditText: boolean hasFocus()>,8,9,<android.inputmethodservice.ExtractEditText: boolean hasFocus()>,<android.inputmethodservice.ExtractEditText: boolean hasFocus()>,0,"{
    return this.isEnabled() ? true : false;
}","{
    return this.isEnabled();
}",1,"/**
 * Pretend like this view always has focus, so its
 * highlight and cursor will be displayed.
 */
","/**
 * Pretend like this view always has focus, so its
 * highlight and cursor will be displayed.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"The form of the return statement has changed, but no actual behavior is affected. Therefore, the type of code change is 1.","Even though there has been a change in the return statement, it will not lead to a compatibility issue as the actual return value has not changed. So, there is no CI."
147,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,8,9,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","Inside the case for MotionEvent.ACTION_CANCEL and MotionEvent.ACTION_UP, additional lines of code have been added to call the 'mScroller.springBack()' method and 'invalidate()'. This indicates there is a change in the control dependency (change type=3) as well as other statements change (change type=4).","These additional statements could change the behavior of the method potentially causing it to return different values, hence leading to a compatibility issue (CI type=1). Further, the new call to 'mScroller.springBack()' could also potentially throw a different exception, implying another possible compatibility issue (CI type=2)."
149,<android.widget.TextView.Blink: void run()>,8,9,<android.widget.TextView.Blink: void run()>,<android.widget.TextView.Blink: void run()>,0,"{
    if (mCancelled) {
        return;
    }
    removeCallbacks(Blink.this);
    TextView tv = mView.get();
    if (tv != null && tv.isFocused()) {
        int st = Selection.getSelectionStart(tv.mText);
        int en = Selection.getSelectionEnd(tv.mText);
        if (st == en && st >= 0 && en >= 0) {
            if (tv.mLayout != null) {
                tv.invalidateCursorPath();
            }
            postAtTime(this, SystemClock.uptimeMillis() + BLINK);
        }
    }
}","{
    if (mCancelled) {
        return;
    }
    removeCallbacks(Blink.this);
    TextView tv = mView.get();
    if (tv != null && tv.isFocused()) {
        int st = tv.getSelectionStart();
        int en = tv.getSelectionEnd();
        if (st == en && st >= 0 && en >= 0) {
            if (tv.mLayout != null) {
                tv.invalidateCursorPath();
            }
            postAtTime(this, SystemClock.uptimeMillis() + BLINK);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,5,0,"In the Late Implementation, method calls to get 'st' and 'en' have been changed from directly accessing properties on 'tv.mText' to using the methods 'getSelectionStart()' and 'getSelectionEnd()' on 'tv'. This is considered a dependent API change, so the code change type is 5.","Even though there are changes on what methods are being called, the return values for 'st' and 'en' would still be the same since they are just accessing the same information differently. This means there are no new possible return paths or exception handling situations introduced, and so no compatibility issues exist. The CI type, therefore, is 0."
150,<android.view.MotionEvent: long getHistoricalEventTime(int)>,8,9,<android.view.MotionEvent: long getHistoricalEventTime(int)>,<android.view.MotionEvent: long getHistoricalEventTime(int)>,0,"{
    return mTimeSamples[pos + 1];
}","{
    return mEventTimeNanoSamples[pos] / MS_PER_NS;
}",1,"/**
 * Returns the time that a historical movement occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getEventTime
 */
","/**
 * Returns the time that a historical movement occurred between this event
 * and the previous event.  Only applies to ACTION_MOVE events.
 *
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getEventTime
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning mTimeSamples[pos + 1] to returning mEventTimeNanoSamples[pos] / MS_PER_NS. Thus, the code change type is 1.","The change in the return statement means that the API could potentially return different values in the two versions, leading to a compatibility issue of type 1."
151,<android.bluetooth.BluetoothSocket: void close()>,8,9,<android.bluetooth.BluetoothSocket: void close()>,<android.bluetooth.BluetoothSocket: void close()>,0,"{
    // abort blocking operations on the socket
    mLock.readLock().lock();
    try {
        if (mClosed)
            return;
        if (mSdp != null) {
            mSdp.cancel();
        }
        abortNative();
    } finally {
        mLock.readLock().unlock();
    }
    // all native calls are guaranteed to immediately return after
    // abortNative(), so this lock should immediatley acquire
    mLock.writeLock().lock();
    try {
        mClosed = true;
        destroyNative();
    } finally {
        mLock.writeLock().unlock();
    }
}","{
    // abort blocking operations on the socket
    mLock.readLock().lock();
    try {
        if (mClosed)
            return;
        if (mSdp != null) {
            mSdp.cancel();
        }
        abortNative();
    } finally {
        mLock.readLock().unlock();
    }
    // all native calls are guaranteed to immediately return after
    // abortNative(), so this lock should immediately acquire
    mLock.writeLock().lock();
    try {
        mClosed = true;
        destroyNative();
    } finally {
        mLock.writeLock().unlock();
    }
}",1,"/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 */
","/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no code change in the implementation of the method between the early and late versions except for a comment fix.,"Since there is no code change in the method's implementation, no compatibility issue exists."
153,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",8,9,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int,InetAddress,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"A new 'if' statement (if (mSecure) { verifyHostname(s, host); }) has been added to the late version, which refers to the change type of 3.","Since the new 'if' statement calls the method of 'verifyHostname(s, host)', it might change the value of 's'. Therefore, it could potentially return a different value, leading to the compatibility issue of type 1."
155,<android.pim.vcard.VCardUtils: boolean isMobilePhoneLabel(String)>,8,9,<android.pim.vcard.VCardUtils: boolean isMobilePhoneLabel(String)>,<android.pim.vcard.VCardUtils: boolean isMobilePhoneLabel(String)>,0,"{
    // To support mobile type at that time, this custom label had been used.
    return (android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME.equals(label) || sMobilePhoneLabelSet.contains(label));
}","{
    // To support mobile type at that time, this custom label had been used.
    return (""_AUTO_CELL"".equals(label) || sMobilePhoneLabelSet.contains(label));
}",1,,,-1,"[@SuppressWarnings(""deprecation"")]","[@SuppressWarnings(""deprecation"")]",-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from comparing with Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME to ""_AUTO_CELL"". The dependent API (Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME) has been removed in the late version. So the code change type is 1,5.",The return value of method isMobilePhoneLabel(String) potentially changes as the compared string in return statement is different between the two versions. Thus the CI type is 1.
157,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",8,9,"<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>","<android.provider.MediaStore.InternalThumbnails: Bitmap getThumbnail(ContentResolver,long,long,int,Options,Uri,boolean)>",0,"{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = MiniThumbFile.instance(baseUri);
    long magic = thumbFile.getMagic(origId);
    if (magic != 0) {
        if (kind == MICRO_KIND) {
            byte[] data = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
            if (thumbFile.getMiniThumbFromFile(origId, data) != null) {
                bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
                if (bitmap == null) {
                    Log.w(TAG, ""couldn't decode byte array."");
                }
            }
            return bitmap;
        } else if (kind == MINI_KIND) {
            String column = isVideo ? ""video_id="" : ""image_id="";
            Cursor c = null;
            try {
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            } finally {
                if (c != null)
                    c.close();
            }
        }
    }
    Cursor c = null;
    try {
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            byte[] data = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
            if (thumbFile.getMiniThumbFromFile(origId, data) != null) {
                bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
                if (bitmap == null) {
                    Log.w(TAG, ""couldn't decode byte array."");
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
    }
    return bitmap;
}","{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, ""getThumbnail: origId=""+origId+"", kind=""+kind+"", isVideo=""+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = MiniThumbFile.instance(baseUri);
    long magic = thumbFile.getMagic(origId);
    if (magic != 0) {
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
            return bitmap;
        } else if (kind == MINI_KIND) {
            String column = isVideo ? ""video_id="" : ""image_id="";
            Cursor c = null;
            try {
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            } finally {
                if (c != null)
                    c.close();
            }
        }
    }
    Cursor c = null;
    try {
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter(""blocking"", ""1"").appendQueryParameter(""orig_id"", String.valueOf(origId)).appendQueryParameter(""group_id"", String.valueOf(groupId)).build();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, ""couldn't decode byte array."");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException(""Unsupported kind: "" + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, ""Create the thumbnail in memory: origId="" + origId + "", kind="" + kind + "", isVideo="" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst(""thumbnails"", ""media""));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
    }
    return bitmap;
}",1,"/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
","/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The implementation of how a byte array is created and filled has been altered. It is now done inside a new synchronized block, indicating that it potentially involves a lock object sThumbBufLock. Thus the change type is 4 - Other Difference.","The bitmap is created from a byte array, which is now filled differently. Despite this, the bitmap's final value can still differ based on this new byte array creation and filling process. Hence, there might be a Compatibility Issue of type 1 - CI because of potential different return values."
159,"<android.server.BluetoothService.BondState: void setBondState(String,int,int)>",8,9,"<android.server.BluetoothService.BondState: void setBondState(String,int,int)>","<android.server.BluetoothService.BondState: void setBondState(String,int,int)>",0,"{
    int oldState = getBondState(address);
    if (oldState == state) {
        return;
    }
    // If yes, reset the state.
    if (oldState == BluetoothDevice.BOND_BONDING) {
        if (address.equals(mPendingOutgoingBonding)) {
            mPendingOutgoingBonding = null;
        }
    }
    if (DBG)
        log(address + "" bond state "" + oldState + "" -> "" + state + "" ("" + reason + "")"");
    Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
    if (state == BluetoothDevice.BOND_NONE) {
        if (reason <= 0) {
            Log.w(TAG, ""setBondState() called to unbond device, but reason code is "" + ""invalid. Overriding reason code with BOND_RESULT_REMOVED"");
            reason = BluetoothDevice.UNBOND_REASON_REMOVED;
        }
        intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
        mState.remove(address);
    } else {
        mState.put(address, state);
    }
    mContext.sendBroadcast(intent, BLUETOOTH_PERM);
}","{
    int oldState = getBondState(address);
    if (oldState == state) {
        return;
    }
    // If yes, reset the state.
    if (oldState == BluetoothDevice.BOND_BONDING) {
        if (address.equals(mPendingOutgoingBonding)) {
            mPendingOutgoingBonding = null;
        }
    }
    if (state == BluetoothDevice.BOND_BONDED) {
        addProfileState(address);
    } else if (state == BluetoothDevice.BOND_NONE) {
        removeProfileState(address);
    }
    if (DBG)
        log(address + "" bond state "" + oldState + "" -> "" + state + "" ("" + reason + "")"");
    Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mAdapter.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
    if (state == BluetoothDevice.BOND_NONE) {
        if (reason <= 0) {
            Log.w(TAG, ""setBondState() called to unbond device, but reason code is "" + ""invalid. Overriding reason code with BOND_RESULT_REMOVED"");
            reason = BluetoothDevice.UNBOND_REASON_REMOVED;
        }
        intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
        mState.remove(address);
    } else {
        mState.put(address, state);
    }
    mContext.sendBroadcast(intent, BLUETOOTH_PERM);
}",1,"/**
 * reason is ignored unless state == BOND_NOT_BONDED
 */
","/**
 * reason is ignored unless state == BOND_NOT_BONDED
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"Two new control-dependent statements (calls to addProfileState(address) and removeProfileState(address)) under 'if' and 'else' have been introduced, so the code change type is 3,4.","The newly introduced statements (calls to addProfileState(address) and removeProfileState(address)) could potentially modify the behavior of the method and hence cause different return values and actions in the late version, so the CI type is 1."
161,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,8,9,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,<android.database.sqlite.SQLiteOpenHelper: SQLiteDatabase getWritableDatabase()>,0,"{
    if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
        // The database is already open for business
        return mDatabase;
    }
    if (mIsInitializing) {
        throw new IllegalStateException(""getWritableDatabase called recursively"");
    }
    // If we have a read-only database open, someone could be using it
    // (though they shouldn't), which would cause a lock to be held on
    // the file, and our attempts to open the database read-write would
    // fail waiting for the file lock.  To prevent that, we acquire the
    // lock on the read-only database, which shuts out other users.
    boolean success = false;
    SQLiteDatabase db = null;
    if (mDatabase != null)
        mDatabase.lock();
    try {
        mIsInitializing = true;
        if (mName == null) {
            db = SQLiteDatabase.create(null);
        } else {
            db = mContext.openOrCreateDatabase(mName, 0, mFactory);
        }
        int version = db.getVersion();
        if (version != mNewVersion) {
            db.beginTransaction();
            try {
                if (version == 0) {
                    onCreate(db);
                } else {
                    onUpgrade(db, version, mNewVersion);
                }
                db.setVersion(mNewVersion);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        }
        onOpen(db);
        success = true;
        return db;
    } finally {
        mIsInitializing = false;
        if (success) {
            if (mDatabase != null) {
                try {
                    mDatabase.close();
                } catch (Exception e) {
                }
                mDatabase.unlock();
            }
            mDatabase = db;
        } else {
            if (mDatabase != null)
                mDatabase.unlock();
            if (db != null)
                db.close();
        }
    }
}","{
    if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
        // The database is already open for business
        return mDatabase;
    }
    if (mIsInitializing) {
        throw new IllegalStateException(""getWritableDatabase called recursively"");
    }
    // If we have a read-only database open, someone could be using it
    // (though they shouldn't), which would cause a lock to be held on
    // the file, and our attempts to open the database read-write would
    // fail waiting for the file lock.  To prevent that, we acquire the
    // lock on the read-only database, which shuts out other users.
    boolean success = false;
    SQLiteDatabase db = null;
    if (mDatabase != null)
        mDatabase.lock();
    try {
        mIsInitializing = true;
        if (mName == null) {
            db = SQLiteDatabase.create(null);
        } else {
            db = mContext.openOrCreateDatabase(mName, 0, mFactory);
        }
        int version = db.getVersion();
        if (version != mNewVersion) {
            db.beginTransaction();
            try {
                if (version == 0) {
                    onCreate(db);
                } else {
                    if (version > mNewVersion) {
                        Log.wtf(TAG, ""Can't downgrade read-only database from version "" + version + "" to "" + mNewVersion + "": "" + db.getPath());
                    }
                    onUpgrade(db, version, mNewVersion);
                }
                db.setVersion(mNewVersion);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        }
        onOpen(db);
        success = true;
        return db;
    } finally {
        mIsInitializing = false;
        if (success) {
            if (mDatabase != null) {
                try {
                    mDatabase.close();
                } catch (Exception e) {
                }
                mDatabase.unlock();
            }
            mDatabase = db;
        } else {
            if (mDatabase != null)
                mDatabase.unlock();
            if (db != null)
                db.close();
        }
    }
}",1,"/**
 * Create and/or open a database that will be used for reading and writing.
 * Once opened successfully, the database is cached, so you can call this
 * method every time you need to write to the database.  Make sure to call
 * {@link #close} when you no longer need it.
 *
 * <p>Errors such as bad permissions or a full disk may cause this operation
 * to fail, but future attempts may succeed if the problem is fixed.</p>
 *
 * @throws SQLiteException if the database cannot be opened for writing
 * @return a read/write database object valid until {@link #close} is called
 */
","/**
 * Create and/or open a database that will be used for reading and writing.
 * The first time this is called, the database will be opened and
 * {@link #onCreate}, {@link #onUpgrade} and/or {@link #onOpen} will be
 * called.
 *
 * <p>Once opened successfully, the database is cached, so you can
 * call this method every time you need to write to the database.
 * (Make sure to call {@link #close} when you no longer need the database.)
 * Errors such as bad permissions or a full disk may cause this method
 * to fail, but future attempts may succeed if the problem is fixed.</p>
 *
 * <p class=""caution"">Database upgrade may take a long time, you
 * should not call this method from the application main thread, including
 * from {@link android.content.ContentProvider#onCreate ContentProvider.onCreate()}.
 *
 * @throws SQLiteException if the database cannot be opened for writing
 * @return a read/write database object valid until {@link #close} is called
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has changed within a statement under control dependency (if statement), specifically the introduction of an extra logging statement. So the change types are 3,4.","Despite the changes in the logging part of the code, there are no changes to the potential return values or exceptions thrown by the API comparing between the two versions. Hence, no Compatibility Issue is detected for this API."
163,<android.view.MotionEvent: float getHistoricalSize(int)>,8,9,<android.view.MotionEvent: float getHistoricalSize(int)>,<android.view.MotionEvent: float getHistoricalSize(int)>,0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + SAMPLE_SIZE];
}","{
    return mDataSamples[pos * mNumPointers * NUM_SAMPLE_DATA + SAMPLE_SIZE];
}",1,"/**
 * {@link #getHistoricalSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getHistoricalSize(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"There is a modification in the calculation result of the index used to access mDataSamples array, hence code change type is 1 and 4. ","The change in index calculation result can potentially lead to different return values. Hence, there is a compatibility issue of type 1."
165,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,8,9,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,<android.bluetooth.BluetoothAdapter: Set<BluetoothDevice> getBondedDevices()>,0,"{
    try {
        return toDeviceSet(mService.listBonds());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    if (getState() != STATE_ON) {
        return toDeviceSet(new String[0]);
    }
    try {
        return toDeviceSet(mService.listBonds());
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
","/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"A return statement and a conditional control statement are added in the late implementation. Thus, the code change types include Return Statement Changed (1) and Control Dependency Changed (3).","The newly added return statement return toDeviceSet(new String[0]); is under a new condition if(getState() != STATE_ON), thus potentially making the method return a different value when the condition is met. Hence, the CI type is Change in Potential Return Value or Type (1)."
166,"<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>",8,9,"<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>","<android.app.ApplicationLoaders: ClassLoader getClassLoader(String,String,ClassLoader)>",0,"{
    /*
         * This is the parent we use if they pass ""null"" in.  In theory
         * this should be the ""system"" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = (ClassLoader) mLoaders.get(zip);
            if (loader != null) {
                return loader;
            }
            PathClassLoader pathClassloader = new PathClassLoader(zip, appDataDir + ""/lib"", parent);
            mLoaders.put(zip, pathClassloader);
            return pathClassloader;
        }
        return new PathClassLoader(zip, parent);
    }
}","{
    /*
         * This is the parent we use if they pass ""null"" in.  In theory
         * this should be the ""system"" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = mLoaders.get(zip);
            if (loader != null) {
                return loader;
            }
            PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent);
            mLoaders.put(zip, pathClassloader);
            return pathClassloader;
        }
        return new PathClassLoader(zip, parent);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The parameter passed to the constructor of PathClassLoader has changed from 'appDataDir + ""/lib""' to 'libPath'. This constitutes a type 4 change (Other statement changed).","The change in the parameter that's passed to the PathClassLoader constructor can lead to a different return type from the getClassLoader method, depending on the value of 'libPath'. This constitutes a type 1 CI (Compatibility Issue caused by potential different return values or types)."
167,<android.pim.vcard.VCardComposer: boolean isAfterLast()>,8,9,<android.pim.vcard.VCardComposer: boolean isAfterLast()>,<android.pim.vcard.VCardComposer: boolean isAfterLast()>,0,"{
    if (mCursor == null) {
        return false;
    }
    return mCursor.isAfterLast();
}","{
    if (mCursor == null) {
        Log.w(LOG_TAG, ""This object is not ready yet."");
        return false;
    }
    return mCursor.isAfterLast();
}",1,,"/**
 * @return true when there's no entity to be built. The return value is undefined
 * when this object is not ready yet.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement 'Log.w(LOG_TAG, ""This object is not ready yet."");' added in the late version. So the code change type is 4.","The new added statement is just a log warning statement. It doesn't affect the behaviour of the API, there is no Compatibility Issue (class 0)."
168,<android.webkit.WebView: int computeVerticalScrollRange()>,8,9,<android.webkit.WebView: int computeVerticalScrollRange()>,<android.webkit.WebView: int computeVerticalScrollRange()>,0,"{
    if (mDrawHistory) {
        return mHistoryHeight;
    } else if (mVerticalScrollBarMode == SCROLLBAR_ALWAYSOFF && (mActualScale - mMinZoomScale <= MINIMUM_SCALE_INCREMENT)) {
        // only honor the scrollbar mode when it is at minimum zoom level
        return computeVerticalScrollExtent();
    } else {
        // to avoid rounding error caused unnecessary scrollbar, use floor
        return (int) Math.floor(mContentHeight * mActualScale);
    }
}","{
    int range = computeRealVerticalScrollRange();
    // Adjust reported range if overscrolled to compress the scroll bars
    final int scrollY = mScrollY;
    final int overscrollBottom = computeMaxScrollY();
    if (scrollY < 0) {
        range -= scrollY;
    } else if (scrollY > overscrollBottom) {
        range += scrollY - overscrollBottom;
    }
    return range;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The whole logic in processing block and return statements have all changed and a control dependency (if-else statement) is removed, so the code change type is 1,3.","Since the entire method logic has changed, it will potentially return a different value in the late version. Therefore, the CI type is 1."
169,<android.webkit.WebView: void destroy()>,8,9,<android.webkit.WebView: void destroy()>,<android.webkit.WebView: void destroy()>,0,"{
    clearTextEntry(false);
    if (mWebViewCore != null) {
        // Set the handlers to null before destroying WebViewCore so no
        // more messages will be posted.
        mCallbackProxy.setWebViewClient(null);
        mCallbackProxy.setWebChromeClient(null);
        // Tell WebViewCore to destroy itself
        synchronized (this) {
            WebViewCore webViewCore = mWebViewCore;
            // prevent using partial webViewCore
            mWebViewCore = null;
            webViewCore.destroy();
        }
        // Remove any pending messages that might not be serviced yet.
        mPrivateHandler.removeCallbacksAndMessages(null);
        mCallbackProxy.removeCallbacksAndMessages(null);
        // javascript dialog.
        synchronized (mCallbackProxy) {
            mCallbackProxy.notify();
        }
    }
    if (mNativeClass != 0) {
        nativeDestroy();
        mNativeClass = 0;
    }
}","{
    clearHelpers();
    if (mWebViewCore != null) {
        // Set the handlers to null before destroying WebViewCore so no
        // more messages will be posted.
        mCallbackProxy.setWebViewClient(null);
        mCallbackProxy.setWebChromeClient(null);
        // Tell WebViewCore to destroy itself
        synchronized (this) {
            WebViewCore webViewCore = mWebViewCore;
            // prevent using partial webViewCore
            mWebViewCore = null;
            webViewCore.destroy();
        }
        // Remove any pending messages that might not be serviced yet.
        mPrivateHandler.removeCallbacksAndMessages(null);
        mCallbackProxy.removeCallbacksAndMessages(null);
        // javascript dialog.
        synchronized (mCallbackProxy) {
            mCallbackProxy.notify();
        }
    }
    if (mNativeClass != 0) {
        nativeDestroy();
        mNativeClass = 0;
    }
}",1,"/**
 * Destroy the internal state of the WebView. This method should be called
 * after the WebView has been removed from the view system. No other
 * methods may be called on a WebView after destroy.
 */
","/**
 * Destroy the internal state of the WebView. This method should be called
 * after the WebView has been removed from the view system. No other
 * methods may be called on a WebView after destroy.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement changed from 'clearTextEntry(false);' to 'clearHelpers();', so the change type is 4.","While the 'clearTextEntry(false);' is replaced by 'clearHelpers();', it doesn't make the API return a different value or throw a different exception, thus no compatibility issue exists in this case."
171,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,8,9,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,<android.webkit.WebTextView: boolean onTouchEvent(MotionEvent)>,0,"{
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            super.onTouchEvent(event);
            // This event may be the start of a drag, so store it to pass to the
            // WebView if it is.
            mDragStartX = event.getX();
            mDragStartY = event.getY();
            mDragStartTime = event.getEventTime();
            mDragSent = false;
            mScrolled = false;
            mGotTouchDown = true;
            mHasPerformedLongClick = false;
            break;
        case MotionEvent.ACTION_MOVE:
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            int slop = ViewConfiguration.get(mContext).getScaledTouchSlop();
            Spannable buffer = getText();
            int initialScrollX = Touch.getInitialScrollX(this, buffer);
            int initialScrollY = Touch.getInitialScrollY(this, buffer);
            super.onTouchEvent(event);
            int dx = Math.abs(mScrollX - initialScrollX);
            int dy = Math.abs(mScrollY - initialScrollY);
            // Use a smaller slop when checking to see if we've moved far enough
            // to scroll the text, because experimentally, slop has shown to be
            // to big for the case of a small textfield.
            int smallerSlop = slop / 2;
            if (dx > smallerSlop || dy > smallerSlop) {
                if (mWebView != null) {
                    float maxScrollX = (float) Touch.getMaxScrollX(this, getLayout(), mScrollY);
                    if (DebugFlags.WEB_TEXT_VIEW) {
                        Log.v(LOGTAG, ""onTouchEvent x="" + mScrollX + "" y="" + mScrollY + "" maxX="" + maxScrollX);
                    }
                    mWebView.scrollFocusedTextInput(maxScrollX > 0 ? mScrollX / maxScrollX : 0, mScrollY);
                }
                mScrolled = true;
                cancelLongPress();
                return true;
            }
            if (Math.abs((int) event.getX() - mDragStartX) < slop && Math.abs((int) event.getY() - mDragStartY) < slop) {
                // their finger, we will change the selection.
                return true;
            }
            if (mWebView != null) {
                // Only want to set the initial state once.
                if (!mDragSent) {
                    mWebView.initiateTextFieldDrag(mDragStartX, mDragStartY, mDragStartTime);
                    mDragSent = true;
                }
                boolean scrolled = mWebView.textFieldDrag(event);
                if (scrolled) {
                    mScrolled = true;
                    cancelLongPress();
                    return true;
                }
            }
            return false;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            if (!mScrolled) {
                // If the page scrolled, or the TextView scrolled, we do not
                // want to change the selection
                cancelLongPress();
                if (mGotTouchDown && mWebView != null) {
                    mWebView.touchUpOnTextField(event);
                }
            }
            // Necessary for the WebView to reset its state
            if (mWebView != null && mDragSent) {
                mWebView.onTouchEvent(event);
            }
            mGotTouchDown = false;
            break;
        default:
            break;
    }
    return true;
}","{
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            super.onTouchEvent(event);
            // This event may be the start of a drag, so store it to pass to the
            // WebView if it is.
            mDragStartX = event.getX();
            mDragStartY = event.getY();
            mDragStartTime = event.getEventTime();
            mDragSent = false;
            mScrolled = false;
            mGotTouchDown = true;
            mHasPerformedLongClick = false;
            break;
        case MotionEvent.ACTION_MOVE:
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            int slop = ViewConfiguration.get(mContext).getScaledTouchSlop();
            Spannable buffer = getText();
            int initialScrollX = Touch.getInitialScrollX(this, buffer);
            int initialScrollY = Touch.getInitialScrollY(this, buffer);
            super.onTouchEvent(event);
            int dx = Math.abs(mScrollX - initialScrollX);
            int dy = Math.abs(mScrollY - initialScrollY);
            // Use a smaller slop when checking to see if we've moved far enough
            // to scroll the text, because experimentally, slop has shown to be
            // to big for the case of a small textfield.
            int smallerSlop = slop / 2;
            if (dx > smallerSlop || dy > smallerSlop) {
                // Scrolling is handled in onScrollChanged.
                mScrolled = true;
                cancelLongPress();
                return true;
            }
            if (Math.abs((int) event.getX() - mDragStartX) < slop && Math.abs((int) event.getY() - mDragStartY) < slop) {
                // their finger, we will change the selection.
                return true;
            }
            if (mWebView != null) {
                // Only want to set the initial state once.
                if (!mDragSent) {
                    mWebView.initiateTextFieldDrag(mDragStartX, mDragStartY, mDragStartTime);
                    mDragSent = true;
                }
                boolean scrolled = mWebView.textFieldDrag(event);
                if (scrolled) {
                    mScrolled = true;
                    cancelLongPress();
                    return true;
                }
            }
            return false;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            super.onTouchEvent(event);
            if (mHasPerformedLongClick) {
                mGotTouchDown = false;
                return false;
            }
            if (!mScrolled) {
                // If the page scrolled, or the TextView scrolled, we do not
                // want to change the selection
                cancelLongPress();
                if (mGotTouchDown && mWebView != null) {
                    mWebView.touchUpOnTextField(event);
                }
            }
            // Necessary for the WebView to reset its state
            if (mWebView != null && mDragSent) {
                mWebView.onTouchEvent(event);
            }
            mGotTouchDown = false;
            break;
        default:
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"There were changes in the case MotionEvent.ACTION_MOVE and case MotionEvent.ACTION_UP of the switch statement, which caused the control dependency to change (category 3). Also, some statements were removed in both cases, and the 'super.onTouchEvent(event);' was added in the 'case MotionEvent.ACTION_UP' (category 4).","Given those changes, it's likely that the method might result in different return values in certain conditions (CI category 1)."
172,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhones(List<ContentValues>)>,8,9,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhones(List<ContentValues>)>,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhones(List<ContentValues>)>,0,"{
    boolean phoneLineExists = false;
    if (contentValuesList != null) {
        Set<String> phoneSet = new HashSet<String>();
        for (ContentValues contentValues : contentValuesList) {
            final Integer typeAsObject = contentValues.getAsInteger(Phone.TYPE);
            final String label = contentValues.getAsString(Phone.LABEL);
            final Integer isPrimaryAsInteger = contentValues.getAsInteger(Phone.IS_PRIMARY);
            final boolean isPrimary = (isPrimaryAsInteger != null ? (isPrimaryAsInteger > 0) : false);
            String phoneNumber = contentValues.getAsString(Phone.NUMBER);
            if (phoneNumber != null) {
                phoneNumber = phoneNumber.trim();
            }
            if (TextUtils.isEmpty(phoneNumber)) {
                continue;
            }
            int type = (typeAsObject != null ? typeAsObject : DEFAULT_PHONE_TYPE);
            if (type == Phone.TYPE_PAGER) {
                phoneLineExists = true;
                if (!phoneSet.contains(phoneNumber)) {
                    phoneSet.add(phoneNumber);
                    appendTelLine(type, label, phoneNumber, isPrimary);
                }
            } else {
                // The entry ""may"" have several phone numbers when the contact entry is
                // corrupted because of its original source.
                // 
                // e.g. I encountered the entry like the following.
                // ""111-222-3333 (Miami)\n444-555-6666 (Broward; 305-653-6796 (Miami); ...""
                // This kind of entry is not able to be inserted via Android devices, but
                // possible if the source of the data is already corrupted.
                List<String> phoneNumberList = splitIfSeveralPhoneNumbersExist(phoneNumber);
                if (phoneNumberList.isEmpty()) {
                    continue;
                }
                phoneLineExists = true;
                for (String actualPhoneNumber : phoneNumberList) {
                    if (!phoneSet.contains(actualPhoneNumber)) {
                        final int format = VCardUtils.getPhoneNumberFormat(mVCardType);
                        final String formattedPhoneNumber = PhoneNumberUtils.formatNumber(actualPhoneNumber, format);
                        phoneSet.add(actualPhoneNumber);
                        appendTelLine(type, label, formattedPhoneNumber, isPrimary);
                    }
                }
            }
        }
    }
    if (!phoneLineExists && mIsDoCoMo) {
        appendTelLine(Phone.TYPE_HOME, """", """", false);
    }
    return this;
}","{
    boolean phoneLineExists = false;
    if (contentValuesList != null) {
        Set<String> phoneSet = new HashSet<String>();
        for (ContentValues contentValues : contentValuesList) {
            final Integer typeAsObject = contentValues.getAsInteger(Phone.TYPE);
            final String label = contentValues.getAsString(Phone.LABEL);
            final Integer isPrimaryAsInteger = contentValues.getAsInteger(Phone.IS_PRIMARY);
            final boolean isPrimary = (isPrimaryAsInteger != null ? (isPrimaryAsInteger > 0) : false);
            String phoneNumber = contentValues.getAsString(Phone.NUMBER);
            if (phoneNumber != null) {
                phoneNumber = phoneNumber.trim();
            }
            if (TextUtils.isEmpty(phoneNumber)) {
                continue;
            }
            // PAGER number needs unformatted ""phone number"".
            final int type = (typeAsObject != null ? typeAsObject : DEFAULT_PHONE_TYPE);
            if (type == Phone.TYPE_PAGER || VCardConfig.refrainPhoneNumberFormatting(mVCardType)) {
                phoneLineExists = true;
                if (!phoneSet.contains(phoneNumber)) {
                    phoneSet.add(phoneNumber);
                    appendTelLine(type, label, phoneNumber, isPrimary);
                }
            } else {
                final List<String> phoneNumberList = splitAndTrimPhoneNumbers(phoneNumber);
                if (phoneNumberList.isEmpty()) {
                    continue;
                }
                phoneLineExists = true;
                for (String actualPhoneNumber : phoneNumberList) {
                    if (!phoneSet.contains(actualPhoneNumber)) {
                        final int format = VCardUtils.getPhoneNumberFormat(mVCardType);
                        final String formattedPhoneNumber = PhoneNumberUtils.formatNumber(actualPhoneNumber, format);
                        phoneSet.add(actualPhoneNumber);
                        appendTelLine(type, label, formattedPhoneNumber, isPrimary);
                    }
                }
            // for (String actualPhoneNumber : phoneNumberList) {
            }
        }
    }
    if (!phoneLineExists && mIsDoCoMo) {
        appendTelLine(Phone.TYPE_HOME, """", """", false);
    }
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The change is in the form of how the phoneNumber is handled. In the early version, phone numbers are split if they contain multiple numbers. However, in the late version, the phone numbers are split and trimmed. Additionally, in the late version, there is a new if condition added that checks specific configurations of 'VCardConfig.refrainPhoneNumberFormatting(mVCardType)'. Hence, the change types are 4 (other statement changed) and 5 (dependent API changed).","These changes could potentially alter the returned value of the method, contributing to a compatibility issue of type 1 (caused by potential different return values or types). Especially, the new condition checking 'VCardConfig.refrainPhoneNumberFormatting(mVCardType)' can further alter the behaviour of the method, causing it to return a different value or type. Hence, the compatibility issue type is 1."
174,<android.view.VelocityTracker: float getXVelocity()>,8,9,<android.view.VelocityTracker: float getXVelocity()>,<android.view.VelocityTracker: float getXVelocity()>,0,"{
    return mXVelocity[0];
}","{
    Pointer pointer = getPointer(0);
    return pointer != null ? pointer.xVelocity : 0;
}",1,"/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed X velocity.
 */
","/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed X velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"In this case, the return statement is changed from 'mXVelocity[0]' to the dependent API call 'getPointer(0)'. Therefore, the code change type is 1 and 5.","As the dependent API 'getPointer(0)' is introduced in the return statement, it could potentially lead to a different returned value by the 'getXVelocity()' method. Hence, the compatibility issue type should be 1."
175,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,8,9,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    switch(msg.what) {
        case DO_DUMP:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    mTarget.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                mInputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                mInputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            mInputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                mInputMethod.startInput(ic, (EditorInfo) args.arg2);
                return;
            }
        case DO_RESTART_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                mInputMethod.restartInput(ic, (EditorInfo) args.arg2);
                return;
            }
        case DO_CREATE_SESSION:
            {
                mInputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (IInputMethodCallback) msg.obj));
                return;
            }
        case DO_SET_SESSION_ENABLED:
            mInputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            mInputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            mInputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            mInputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                return;
            }
        case DO_ATTACH_TOKEN:
            {
                inputMethod.attachToken((IBinder) msg.obj);
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                inputMethod.startInput(ic, (EditorInfo) args.arg2);
                return;
            }
        case DO_RESTART_INPUT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                IInputContext inputContext = (IInputContext) args.arg1;
                InputConnection ic = inputContext != null ? new InputConnectionWrapper(inputContext) : null;
                inputMethod.restartInput(ic, (EditorInfo) args.arg2);
                return;
            }
        case DO_CREATE_SESSION:
            {
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mCaller.mContext, (IInputMethodCallback) msg.obj));
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            inputMethod.showSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
        case DO_HIDE_SOFT_INPUT:
            inputMethod.hideSoftInput(msg.arg1, (ResultReceiver) msg.obj);
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"In the late implementation, a new block of if condition to check if `inputMethod` is null is added at the start of the function which didn't exist in the early implementation. There are also changes in the switch cases. For instance, `mTarget.dump` changes to `target.dump` in `DO_DUMP` case and `mInputMethod.attachToken` changes to `inputMethod.attachToken` in `DO_ATTACH_TOKEN` case. Thus the change type is 3,4.","Since all new statements or changes are doing similar tasks and have similar control dependencies as their corresponding statements in the early version, the function should work in a similar fashion in both versions. Thus, the CI type is 0."
176,"<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>",8,9,"<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>","<android.app.ActivityThread.ApplicationThread: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    long nativeMax = Debug.getNativeHeapSize() / 1024;
    long nativeAllocated = Debug.getNativeHeapAllocatedSize() / 1024;
    long nativeFree = Debug.getNativeHeapFreeSize() / 1024;
    Debug.MemoryInfo memInfo = new Debug.MemoryInfo();
    Debug.getMemoryInfo(memInfo);
    final int nativeShared = memInfo.nativeSharedDirty;
    final int dalvikShared = memInfo.dalvikSharedDirty;
    final int otherShared = memInfo.otherSharedDirty;
    final int nativePrivate = memInfo.nativePrivateDirty;
    final int dalvikPrivate = memInfo.dalvikPrivateDirty;
    final int otherPrivate = memInfo.otherPrivateDirty;
    Runtime runtime = Runtime.getRuntime();
    long dalvikMax = runtime.totalMemory() / 1024;
    long dalvikFree = runtime.freeMemory() / 1024;
    long dalvikAllocated = dalvikMax - dalvikFree;
    long viewInstanceCount = ViewDebug.getViewInstanceCount();
    long viewRootInstanceCount = ViewDebug.getViewRootInstanceCount();
    long appContextInstanceCount = ContextImpl.getInstanceCount();
    long activityInstanceCount = Activity.getInstanceCount();
    int globalAssetCount = AssetManager.getGlobalAssetCount();
    int globalAssetManagerCount = AssetManager.getGlobalAssetManagerCount();
    int binderLocalObjectCount = Debug.getBinderLocalObjectCount();
    int binderProxyObjectCount = Debug.getBinderProxyObjectCount();
    int binderDeathObjectCount = Debug.getBinderDeathObjectCount();
    int openSslSocketCount = OpenSSLSocketImpl.getInstanceCount();
    long sqliteAllocated = SQLiteDebug.getHeapAllocatedSize() / 1024;
    SQLiteDebug.PagerStats stats = SQLiteDebug.getDatabaseInfo();
    // Check to see if we were called by checkin server. If so, print terse format.
    boolean doCheckinFormat = false;
    if (args != null) {
        for (String arg : args) {
            if (""-c"".equals(arg))
                doCheckinFormat = true;
        }
    }
    // For checkin, we print one long comma-separated list of values
    if (doCheckinFormat) {
        // NOTE: if you change anything significant below, also consider changing
        // ACTIVITY_THREAD_CHECKIN_VERSION.
        String processName = (mBoundApplication != null) ? mBoundApplication.processName : ""unknown"";
        // Header
        pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
        pw.print(',');
        pw.print(Process.myPid());
        pw.print(',');
        pw.print(processName);
        pw.print(',');
        // Heap info - max
        pw.print(nativeMax);
        pw.print(',');
        pw.print(dalvikMax);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeMax + dalvikMax);
        pw.print(',');
        // Heap info - allocated
        pw.print(nativeAllocated);
        pw.print(',');
        pw.print(dalvikAllocated);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeAllocated + dalvikAllocated);
        pw.print(',');
        // Heap info - free
        pw.print(nativeFree);
        pw.print(',');
        pw.print(dalvikFree);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeFree + dalvikFree);
        pw.print(',');
        // Heap info - proportional set size
        pw.print(memInfo.nativePss);
        pw.print(',');
        pw.print(memInfo.dalvikPss);
        pw.print(',');
        pw.print(memInfo.otherPss);
        pw.print(',');
        pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
        pw.print(',');
        // Heap info - shared
        pw.print(nativeShared);
        pw.print(',');
        pw.print(dalvikShared);
        pw.print(',');
        pw.print(otherShared);
        pw.print(',');
        pw.print(nativeShared + dalvikShared + otherShared);
        pw.print(',');
        // Heap info - private
        pw.print(nativePrivate);
        pw.print(',');
        pw.print(dalvikPrivate);
        pw.print(',');
        pw.print(otherPrivate);
        pw.print(',');
        pw.print(nativePrivate + dalvikPrivate + otherPrivate);
        pw.print(',');
        // Object counts
        pw.print(viewInstanceCount);
        pw.print(',');
        pw.print(viewRootInstanceCount);
        pw.print(',');
        pw.print(appContextInstanceCount);
        pw.print(',');
        pw.print(activityInstanceCount);
        pw.print(',');
        pw.print(globalAssetCount);
        pw.print(',');
        pw.print(globalAssetManagerCount);
        pw.print(',');
        pw.print(binderLocalObjectCount);
        pw.print(',');
        pw.print(binderProxyObjectCount);
        pw.print(',');
        pw.print(binderDeathObjectCount);
        pw.print(',');
        pw.print(openSslSocketCount);
        pw.print(',');
        // SQL
        pw.print(sqliteAllocated);
        pw.print(',');
        pw.print(stats.memoryUsed / 1024);
        pw.print(',');
        pw.print(stats.pageCacheOverflo / 1024);
        pw.print(',');
        pw.print(stats.largestMemAlloc / 1024);
        pw.print(',');
        for (int i = 0; i < stats.dbStats.size(); i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
            pw.print(',');
        }
        return;
    }
    // otherwise, show human-readable format
    printRow(pw, HEAP_COLUMN, """", ""native"", ""dalvik"", ""other"", ""total"");
    printRow(pw, HEAP_COLUMN, ""size:"", nativeMax, dalvikMax, ""N/A"", nativeMax + dalvikMax);
    printRow(pw, HEAP_COLUMN, ""allocated:"", nativeAllocated, dalvikAllocated, ""N/A"", nativeAllocated + dalvikAllocated);
    printRow(pw, HEAP_COLUMN, ""free:"", nativeFree, dalvikFree, ""N/A"", nativeFree + dalvikFree);
    printRow(pw, HEAP_COLUMN, ""(Pss):"", memInfo.nativePss, memInfo.dalvikPss, memInfo.otherPss, memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    printRow(pw, HEAP_COLUMN, ""(shared dirty):"", nativeShared, dalvikShared, otherShared, nativeShared + dalvikShared + otherShared);
    printRow(pw, HEAP_COLUMN, ""(priv dirty):"", nativePrivate, dalvikPrivate, otherPrivate, nativePrivate + dalvikPrivate + otherPrivate);
    pw.println("" "");
    pw.println("" Objects"");
    printRow(pw, TWO_COUNT_COLUMNS, ""Views:"", viewInstanceCount, ""ViewRoots:"", viewRootInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""AppContexts:"", appContextInstanceCount, ""Activities:"", activityInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Assets:"", globalAssetCount, ""AssetManagers:"", globalAssetManagerCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Local Binders:"", binderLocalObjectCount, ""Proxy Binders:"", binderProxyObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""Death Recipients:"", binderDeathObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""OpenSSL Sockets:"", openSslSocketCount);
    // SQLite mem info
    pw.println("" "");
    pw.println("" SQL"");
    printRow(pw, TWO_COUNT_COLUMNS, ""heap:"", sqliteAllocated, ""memoryUsed:"", stats.memoryUsed / 1024);
    printRow(pw, TWO_COUNT_COLUMNS, ""pageCacheOverflo:"", stats.pageCacheOverflo / 1024, ""largestMemAlloc:"", stats.largestMemAlloc / 1024);
    pw.println("" "");
    int N = stats.dbStats.size();
    if (N > 0) {
        pw.println("" DATABASES"");
        printRow(pw, ""  %8s %8s %10s  %s"", ""Pagesize"", ""Dbsize"", ""Lookaside"", ""Dbname"");
        for (int i = 0; i < N; i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
        }
    }
    // Asset details.
    String assetAlloc = AssetManager.getAssetAllocations();
    if (assetAlloc != null) {
        pw.println("" "");
        pw.println("" Asset Allocations"");
        pw.print(assetAlloc);
    }
}","{
    long nativeMax = Debug.getNativeHeapSize() / 1024;
    long nativeAllocated = Debug.getNativeHeapAllocatedSize() / 1024;
    long nativeFree = Debug.getNativeHeapFreeSize() / 1024;
    Debug.MemoryInfo memInfo = new Debug.MemoryInfo();
    Debug.getMemoryInfo(memInfo);
    final int nativeShared = memInfo.nativeSharedDirty;
    final int dalvikShared = memInfo.dalvikSharedDirty;
    final int otherShared = memInfo.otherSharedDirty;
    final int nativePrivate = memInfo.nativePrivateDirty;
    final int dalvikPrivate = memInfo.dalvikPrivateDirty;
    final int otherPrivate = memInfo.otherPrivateDirty;
    Runtime runtime = Runtime.getRuntime();
    long dalvikMax = runtime.totalMemory() / 1024;
    long dalvikFree = runtime.freeMemory() / 1024;
    long dalvikAllocated = dalvikMax - dalvikFree;
    long viewInstanceCount = ViewDebug.getViewInstanceCount();
    long viewRootInstanceCount = ViewDebug.getViewRootInstanceCount();
    long appContextInstanceCount = ContextImpl.getInstanceCount();
    long activityInstanceCount = Activity.getInstanceCount();
    int globalAssetCount = AssetManager.getGlobalAssetCount();
    int globalAssetManagerCount = AssetManager.getGlobalAssetManagerCount();
    int binderLocalObjectCount = Debug.getBinderLocalObjectCount();
    int binderProxyObjectCount = Debug.getBinderProxyObjectCount();
    int binderDeathObjectCount = Debug.getBinderDeathObjectCount();
    int openSslSocketCount = OpenSSLSocketImpl.getInstanceCount();
    long sqliteAllocated = SQLiteDebug.getHeapAllocatedSize() / 1024;
    SQLiteDebug.PagerStats stats = SQLiteDebug.getDatabaseInfo();
    // Check to see if we were called by checkin server. If so, print terse format.
    boolean doCheckinFormat = false;
    if (args != null) {
        for (String arg : args) {
            if (""-c"".equals(arg))
                doCheckinFormat = true;
        }
    }
    // For checkin, we print one long comma-separated list of values
    if (doCheckinFormat) {
        // NOTE: if you change anything significant below, also consider changing
        // ACTIVITY_THREAD_CHECKIN_VERSION.
        String processName = (mBoundApplication != null) ? mBoundApplication.processName : ""unknown"";
        // Header
        pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
        pw.print(',');
        pw.print(Process.myPid());
        pw.print(',');
        pw.print(processName);
        pw.print(',');
        // Heap info - max
        pw.print(nativeMax);
        pw.print(',');
        pw.print(dalvikMax);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeMax + dalvikMax);
        pw.print(',');
        // Heap info - allocated
        pw.print(nativeAllocated);
        pw.print(',');
        pw.print(dalvikAllocated);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeAllocated + dalvikAllocated);
        pw.print(',');
        // Heap info - free
        pw.print(nativeFree);
        pw.print(',');
        pw.print(dalvikFree);
        pw.print(',');
        pw.print(""N/A,"");
        pw.print(nativeFree + dalvikFree);
        pw.print(',');
        // Heap info - proportional set size
        pw.print(memInfo.nativePss);
        pw.print(',');
        pw.print(memInfo.dalvikPss);
        pw.print(',');
        pw.print(memInfo.otherPss);
        pw.print(',');
        pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
        pw.print(',');
        // Heap info - shared
        pw.print(nativeShared);
        pw.print(',');
        pw.print(dalvikShared);
        pw.print(',');
        pw.print(otherShared);
        pw.print(',');
        pw.print(nativeShared + dalvikShared + otherShared);
        pw.print(',');
        // Heap info - private
        pw.print(nativePrivate);
        pw.print(',');
        pw.print(dalvikPrivate);
        pw.print(',');
        pw.print(otherPrivate);
        pw.print(',');
        pw.print(nativePrivate + dalvikPrivate + otherPrivate);
        pw.print(',');
        // Object counts
        pw.print(viewInstanceCount);
        pw.print(',');
        pw.print(viewRootInstanceCount);
        pw.print(',');
        pw.print(appContextInstanceCount);
        pw.print(',');
        pw.print(activityInstanceCount);
        pw.print(',');
        pw.print(globalAssetCount);
        pw.print(',');
        pw.print(globalAssetManagerCount);
        pw.print(',');
        pw.print(binderLocalObjectCount);
        pw.print(',');
        pw.print(binderProxyObjectCount);
        pw.print(',');
        pw.print(binderDeathObjectCount);
        pw.print(',');
        pw.print(openSslSocketCount);
        pw.print(',');
        // SQL
        pw.print(sqliteAllocated);
        pw.print(',');
        pw.print(stats.memoryUsed / 1024);
        pw.print(',');
        pw.print(stats.pageCacheOverflo / 1024);
        pw.print(',');
        pw.print(stats.largestMemAlloc / 1024);
        pw.print(',');
        for (int i = 0; i < stats.dbStats.size(); i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
            pw.print(',');
        }
        return;
    }
    // otherwise, show human-readable format
    printRow(pw, HEAP_COLUMN, """", ""native"", ""dalvik"", ""other"", ""total"");
    printRow(pw, HEAP_COLUMN, ""size:"", nativeMax, dalvikMax, ""N/A"", nativeMax + dalvikMax);
    printRow(pw, HEAP_COLUMN, ""allocated:"", nativeAllocated, dalvikAllocated, ""N/A"", nativeAllocated + dalvikAllocated);
    printRow(pw, HEAP_COLUMN, ""free:"", nativeFree, dalvikFree, ""N/A"", nativeFree + dalvikFree);
    printRow(pw, HEAP_COLUMN, ""(Pss):"", memInfo.nativePss, memInfo.dalvikPss, memInfo.otherPss, memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    printRow(pw, HEAP_COLUMN, ""(shared dirty):"", nativeShared, dalvikShared, otherShared, nativeShared + dalvikShared + otherShared);
    printRow(pw, HEAP_COLUMN, ""(priv dirty):"", nativePrivate, dalvikPrivate, otherPrivate, nativePrivate + dalvikPrivate + otherPrivate);
    pw.println("" "");
    pw.println("" Objects"");
    printRow(pw, TWO_COUNT_COLUMNS, ""Views:"", viewInstanceCount, ""ViewRoots:"", viewRootInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""AppContexts:"", appContextInstanceCount, ""Activities:"", activityInstanceCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Assets:"", globalAssetCount, ""AssetManagers:"", globalAssetManagerCount);
    printRow(pw, TWO_COUNT_COLUMNS, ""Local Binders:"", binderLocalObjectCount, ""Proxy Binders:"", binderProxyObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""Death Recipients:"", binderDeathObjectCount);
    printRow(pw, ONE_COUNT_COLUMN, ""OpenSSL Sockets:"", openSslSocketCount);
    // SQLite mem info
    pw.println("" "");
    pw.println("" SQL"");
    printRow(pw, TWO_COUNT_COLUMNS_DB, ""heap:"", sqliteAllocated, ""MEMORY_USED:"", stats.memoryUsed / 1024);
    printRow(pw, TWO_COUNT_COLUMNS_DB, ""PAGECACHE_OVERFLOW:"", stats.pageCacheOverflo / 1024, ""MALLOC_SIZE:"", stats.largestMemAlloc / 1024);
    pw.println("" "");
    int N = stats.dbStats.size();
    if (N > 0) {
        pw.println("" DATABASES"");
        printRow(pw, ""  %8s %8s %14s  %s"", ""pgsz"", ""dbsz"", ""Lookaside(b)"", ""Dbname"");
        for (int i = 0; i < N; i++) {
            DbStats dbStats = stats.dbStats.get(i);
            printRow(pw, DB_INFO_FORMAT, dbStats.pageSize, dbStats.dbSize, dbStats.lookaside, dbStats.dbName);
        }
    }
    // Asset details.
    String assetAlloc = AssetManager.getAssetAllocations();
    if (assetAlloc != null) {
        pw.println("" "");
        pw.println("" Asset Allocations"");
        pw.print(assetAlloc);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
177,<android.view.MotionEvent: void recycle()>,8,9,<android.view.MotionEvent: void recycle()>,<android.view.MotionEvent: void recycle()>,0,"{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + "" recycled twice!"", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException(""Last recycled here"");
    } else if (mRecycled) {
        throw new RuntimeException(toString() + "" recycled twice!"");
    }
    // Log.w(""MotionEvent"", ""Recycling event "" + this, mRecycledLocation);
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNumSamples = 0;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}","{
    // Ensure recycle is only called once!
    if (TRACK_RECYCLED_LOCATION) {
        if (mRecycledLocation != null) {
            throw new RuntimeException(toString() + "" recycled twice!"", mRecycledLocation);
        }
        mRecycledLocation = new RuntimeException(""Last recycled here"");
    // Log.w(""MotionEvent"", ""Recycling event "" + this, mRecycledLocation);
    } else {
        if (mRecycled) {
            throw new RuntimeException(toString() + "" recycled twice!"");
        }
        mRecycled = true;
    }
    synchronized (gRecyclerLock) {
        if (gRecyclerUsed < MAX_RECYCLED) {
            gRecyclerUsed++;
            mNumSamples = 0;
            mNext = gRecyclerTop;
            gRecyclerTop = this;
        }
    }
}",1,"/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
","/**
 * Recycle the MotionEvent, to be re-used by a later caller.  After calling
 * this function you must not ever touch the event again.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The change in code is related to control dependency and other statements. In particular, mRecycled = true; was added to the late version under the else condition, and the assignment of mRecycled = true; is a change of statement. Therefore, the change type is 3,4.","The change does not affect the behavior of the initial method. The function of the method is still to recycle the event. Therefore, no Compatibility Issue exists, so the CI type is 0."
178,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",8,9,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>","<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            /*
                 * If there is a click listener, just call through to
                 * super, which will invoke it.
                 *
                 * If there isn't a click listener, try to show the soft
                 * input method.  (It will also
                 * call performClick(), but that won't do anything in
                 * this case.)
                 */
            if (mOnClickListener == null) {
                if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                    InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                    imm.showSoftInput(this, 0);
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                mInputContentType.enterDown = false;
                if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                    return true;
                }
            }
            if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to advance focus,
                     * but still call through to super, which will reset the
                     * pressed state and longpress state.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (mOnClickListener == null) {
                    View v = focusSearch(FOCUS_DOWN);
                    if (v != null) {
                        if (!v.requestFocus(FOCUS_DOWN)) {
                            throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                        }
                        /*
                             * Return true because we handled the key; super
                             * will return false because there was no click
                             * listener.
                             */
                        super.onKeyUp(keyCode, event);
                        return true;
                    } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                        // No target for next focus, but make sure the IME
                        // if this came from it.
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        if (imm != null) {
                            imm.hideSoftInputFromWindow(getWindowToken(), 0);
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    hideControllers();
    stopTextSelectionMode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            mDPadCenterIsDown = false;
            /*
                 * If there is a click listener, just call through to
                 * super, which will invoke it.
                 *
                 * If there isn't a click listener, try to show the soft
                 * input method.  (It will also
                 * call performClick(), but that won't do anything in
                 * this case.)
                 */
            if (mOnClickListener == null) {
                if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                    InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                    imm.showSoftInput(this, 0);
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            mEnterKeyIsDown = false;
            if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                mInputContentType.enterDown = false;
                if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                    return true;
                }
            }
            if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to advance focus,
                     * but still call through to super, which will reset the
                     * pressed state and longpress state.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (mOnClickListener == null) {
                    View v = focusSearch(FOCUS_DOWN);
                    if (v != null) {
                        if (!v.requestFocus(FOCUS_DOWN)) {
                            throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                        }
                        /*
                             * Return true because we handled the key; super
                             * will return false because there was no click
                             * listener.
                             */
                        super.onKeyUp(keyCode, event);
                        return true;
                    } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                        // No target for next focus, but make sure the IME
                        // if this came from it.
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        if (imm != null) {
                            imm.hideSoftInputFromWindow(getWindowToken(), 0);
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"Several new function calls (hideControllers() and stopTextSelectionMode()) have been added, and two assignments(mDPadCenterIsDown = false; mEnterKeyIsDown = false;) have been introduced in the 'late' version, which do not affect the control dependency, but are classified as a change in the other statement, hence change type is 3,4.","Newly introduced function calls (hideControllers() and stopTextSelectionMode()) might modify the internal state or properties of the object which potentially lead to different return values in some conditions. Therefore, CI type is 1."
180,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,8,9,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,<android.widget.HorizontalScrollView: int computeHorizontalScrollRange()>,0,"{
    final int count = getChildCount();
    final int contentWidth = getWidth() - mPaddingLeft - mPaddingRight;
    if (count == 0) {
        return contentWidth;
    }
    return getChildAt(0).getRight();
}","{
    final int count = getChildCount();
    final int contentWidth = getWidth() - mPaddingLeft - mPaddingRight;
    if (count == 0) {
        return contentWidth;
    }
    int scrollRange = getChildAt(0).getRight();
    final int scrollX = mScrollX;
    final int overscrollRight = Math.max(0, scrollRange - contentWidth);
    if (scrollX < 0) {
        scrollRange -= scrollX;
    } else if (scrollX > overscrollRight) {
        scrollRange += scrollX - overscrollRight;
    }
    return scrollRange;
}",1,"/**
 * <p>The scroll range of a scroll view is the overall width of all of its
 * children.</p>
 */
","/**
 * <p>The scroll range of a scroll view is the overall width of all of its
 * children.</p>
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 3",1,"In addition to the return statements changes, control dependency also changed because some new statements that could affect the program flow were added after the `if (count == 0)` branch, so the code change type is 1,3.","The changed return statement now returns a variable scrollRange, which is modified in a more complex way in the late version. Thus, it could lead to potentially different return types and values when invoked, so the code change class is 1."
181,<android.webkit.JWebCoreJavaBridge: void removeActiveWebView(WebView)>,8,9,<android.webkit.JWebCoreJavaBridge: void removeActiveWebView(WebView)>,<android.webkit.JWebCoreJavaBridge: void removeActiveWebView(WebView)>,0,"{
    if (mCurrentMainWebView != webview) {
        // it is possible if there is a sub-WebView. Do nothing.
        return;
    }
    mCurrentMainWebView = null;
}","{
    if (sCurrentMainWebView.get() != webview) {
        // it is possible if there is a sub-WebView. Do nothing.
        return;
    }
    sCurrentMainWebView.clear();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The variable used in the if statement and the statement after it has changed in the later version. The 'if' condition has changed and the 'return' and 'clear' statements are different than the original implementation. So, the code change type is 1,3,4.","The change of return statement and the change in the method called for the variable can cause the API to behave differently, hence the CI type is 1."
182,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",8,9,"<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>","<android.database.sqlite.SQLiteDatabase: long insertWithOnConflict(String,String,ContentValues,int)>",0,"{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    // Measurements show most sql lengths <= 152
    StringBuilder sql = new StringBuilder(152);
    sql.append(""INSERT"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append("" INTO "");
    sql.append(table);
    // Measurements show most values lengths < 40
    StringBuilder values = new StringBuilder(40);
    Set<Map.Entry<String, Object>> entrySet = null;
    if (initialValues != null && initialValues.size() > 0) {
        entrySet = initialValues.valueSet();
        Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
        sql.append('(');
        boolean needSeparator = false;
        while (entriesIter.hasNext()) {
            if (needSeparator) {
                sql.append("", "");
                values.append("", "");
            }
            needSeparator = true;
            Map.Entry<String, Object> entry = entriesIter.next();
            sql.append(entry.getKey());
            values.append('?');
        }
        sql.append(')');
    } else {
        sql.append(""("" + nullColumnHack + "") "");
        values.append(""NULL"");
    }
    sql.append("" VALUES("");
    sql.append(values);
    sql.append("");"");
    lock();
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql.toString());
        // Bind the values
        if (entrySet != null) {
            int size = entrySet.size();
            Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
            for (int i = 0; i < size; i++) {
                Map.Entry<String, Object> entry = entriesIter.next();
                DatabaseUtils.bindObjectToProgram(statement, i + 1, entry.getValue());
            }
        }
        // Run the program and then cleanup
        statement.execute();
        long insertedRowId = lastInsertRow();
        if (insertedRowId == -1) {
            Log.e(TAG, ""Error inserting "" + initialValues + "" using "" + sql);
        } else {
            if (Config.LOGD && Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""Inserting row "" + insertedRowId + "" from "" + initialValues + "" using "" + sql);
            }
        }
        return insertedRowId;
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    // Measurements show most sql lengths <= 152
    StringBuilder sql = new StringBuilder(152);
    sql.append(""INSERT"");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append("" INTO "");
    sql.append(table);
    // Measurements show most values lengths < 40
    StringBuilder values = new StringBuilder(40);
    Set<Map.Entry<String, Object>> entrySet = null;
    if (initialValues != null && initialValues.size() > 0) {
        entrySet = initialValues.valueSet();
        Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
        sql.append('(');
        boolean needSeparator = false;
        while (entriesIter.hasNext()) {
            if (needSeparator) {
                sql.append("", "");
                values.append("", "");
            }
            needSeparator = true;
            Map.Entry<String, Object> entry = entriesIter.next();
            sql.append(entry.getKey());
            values.append('?');
        }
        sql.append(')');
    } else {
        sql.append(""("" + nullColumnHack + "") "");
        values.append(""NULL"");
    }
    sql.append("" VALUES("");
    sql.append(values);
    sql.append("");"");
    lock();
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql.toString());
        // Bind the values
        if (entrySet != null) {
            int size = entrySet.size();
            Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
            for (int i = 0; i < size; i++) {
                Map.Entry<String, Object> entry = entriesIter.next();
                DatabaseUtils.bindObjectToProgram(statement, i + 1, entry.getValue());
            }
        }
        // Run the program and then cleanup
        statement.execute();
        long insertedRowId = lastInsertRow();
        if (insertedRowId == -1) {
            Log.e(TAG, ""Error inserting "" + initialValues + "" using "" + sql);
        } else {
            if (Config.LOGD && Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""Inserting row "" + insertedRowId + "" from "" + initialValues + "" using "" + sql);
            }
        }
        return insertedRowId;
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}",1,"/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row
 * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
 * {@link #CONFLICT_IGNORE}
 * OR -1 if any error
 */
","/**
 * General method for inserting a row into the database.
 *
 * @param table the table to insert the row into
 * @param nullColumnHack SQL doesn't allow inserting a completely empty row,
 * so if initialValues is empty this column will explicitly be
 * assigned a NULL value
 * @param initialValues this map contains the initial column values for the
 * row. The keys should be the column names and the values the
 * column values
 * @param conflictAlgorithm for insert conflict resolver
 * @return the row ID of the newly inserted row
 * OR the primary key of the existing row if the input param 'conflictAlgorithm' =
 * {@link #CONFLICT_IGNORE}
 * OR -1 if any error
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement, 'BlockGuard.getThreadPolicy().onWriteToDisk();', has been added at the beginning of the Late_Implementation but the core functionality of the method remains unchanged. This change is peripheral and does not belong in any of the key change categories. Therefore, the code change type is 4.","Despite the added function, the return type and potential exception throwing in this method haven't been changed. Therefore, this code change would not lead to a compatibility issue based on our definitions so pred_CI is 0."
183,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,8,9,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,0,"{
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mScrolled = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEatTouchRelease && action == MotionEvent.ACTION_UP) {
        mEatTouchRelease = false;
        return superResult;
    }
    if ((mMovement != null || onCheckIsTextEditor()) && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        int oldSelStart = Selection.getSelectionStart(mText);
        int oldSelEnd = Selection.getSelectionEnd(mText);
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (mText instanceof Editable && onCheckIsTextEditor()) {
            if (action == MotionEvent.ACTION_UP && isFocused() && !mScrolled) {
                InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                // This is going to be gross...  if tapping on the text view
                // causes the IME to be displayed, we don't want the selection
                // to change.  But the selection has already changed, and
                // we won't know right away whether the IME is getting
                // displayed, so...
                int newSelStart = Selection.getSelectionStart(mText);
                int newSelEnd = Selection.getSelectionEnd(mText);
                CommitSelectionReceiver csr = null;
                if (newSelStart != oldSelStart || newSelEnd != oldSelEnd) {
                    csr = new CommitSelectionReceiver();
                    csr.mNewStart = newSelStart;
                    csr.mNewEnd = newSelEnd;
                }
                if (imm.showSoftInput(this, 0, csr) && csr != null) {
                    // The IME might get shown -- revert to the old
                    // selection, and change to the new when we finally
                    // find out of it is okay.
                    Selection.setSelection((Spannable) mText, oldSelStart, oldSelEnd);
                    handled = true;
                }
            }
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        if (hasInsertionController()) {
            getInsertionController().onTouchEvent(event);
        }
        if (hasSelectionController()) {
            getSelectionController().onTouchEvent(event);
        }
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mScrolled = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mEatTouchRelease && action == MotionEvent.ACTION_UP) {
        mEatTouchRelease = false;
        return superResult;
    }
    if ((mMovement != null || onCheckIsTextEditor()) && mText instanceof Spannable && mLayout != null) {
        if (hasInsertionController()) {
            getInsertionController().onTouchEvent(event);
        }
        if (hasSelectionController()) {
            getSelectionController().onTouchEvent(event);
        }
        boolean handled = false;
        // Save previous selection, in case this event is used to show the IME.
        int oldSelStart = getSelectionStart();
        int oldSelEnd = getSelectionEnd();
        final int oldScrollX = mScrollX;
        final int oldScrollY = mScrollY;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (isTextEditable()) {
            if (mScrollX != oldScrollX || mScrollY != oldScrollY) {
                // Hide insertion anchor while scrolling. Leave selection.
                hideInsertionPointCursorController();
                if (mSelectionModifierCursorController != null && mSelectionModifierCursorController.isShowing()) {
                    mSelectionModifierCursorController.updatePosition();
                }
            }
            if (action == MotionEvent.ACTION_UP && isFocused() && !mScrolled) {
                InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                CommitSelectionReceiver csr = null;
                if (getSelectionStart() != oldSelStart || getSelectionEnd() != oldSelEnd || didTouchFocusSelect()) {
                    csr = new CommitSelectionReceiver(oldSelStart, oldSelEnd);
                }
                handled |= imm.showSoftInput(this, 0, csr) && (csr != null);
                // Cannot be done by CommitSelectionReceiver, which might not always be called,
                // for instance when dealing with an ExtractEditText.
                onTapUpEvent(oldSelStart, oldSelEnd);
            }
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The early version uses event.getAction() while the late version uses event.getActionMasked() in the first line of code. The late version also introduced new lines of code that invoke hasInsertionController(), getInsertionController().onTouchEvent(), hasSelectionController(), and getSelectionController().onTouchEvent(). Additionally, some parts of the method have been refactored. Therefore, the code change types are 1,3,4.","Due to the differences in actions retrieved by event.getAction() vs event.getActionMasked() and the extra touch events handled in the late version, the potential behavior of the API could change. Hence, the compatibility issue type is 1."
185,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,8,9,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,<android.server.BluetoothService: String getAddressFromObjectPath(String)>,0,"{
    String adapterObjectPath = getPropertyInternal(""ObjectPath"");
    if (adapterObjectPath == null || objectPath == null) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  or deviceObjectPath:"" + objectPath + "" is null"");
        return null;
    }
    if (!objectPath.startsWith(adapterObjectPath)) {
        Log.e(TAG, ""getAddressFromObjectPath: AdpaterObjectPath:"" + adapterObjectPath + ""  is not a prefix of deviceObjectPath:"" + objectPath + ""bluetoothd crashed ?"");
        return null;
    }
    String address = objectPath.substring(adapterObjectPath.length());
    if (address != null)
        return address.replace('_', ':');
    Log.e(TAG, ""getAddressFromObjectPath: Address being returned is null"");
    return null;
}","{
    String adapterObjectPath = getPropertyInternal(""ObjectPath"");
    if (adapterObjectPath == null || objectPath == null) {
        Log.e(TAG, ""getAddressFromObjectPath: AdapterObjectPath:"" + adapterObjectPath + ""  or deviceObjectPath:"" + objectPath + "" is null"");
        return null;
    }
    if (!objectPath.startsWith(adapterObjectPath)) {
        Log.e(TAG, ""getAddressFromObjectPath: AdapterObjectPath:"" + adapterObjectPath + ""  is not a prefix of deviceObjectPath:"" + objectPath + ""bluetoothd crashed ?"");
        return null;
    }
    String address = objectPath.substring(adapterObjectPath.length());
    if (address != null)
        return address.replace('_', ':');
    Log.e(TAG, ""getAddressFromObjectPath: Address being returned is null"");
    return null;
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,0,0,"There is no code change between the two versions of this API, only the spelling mistake in the log message was corrected.",There is no compatibility issue because there is no code change between the two versions of this API. The spelling mistake in the log message does not have an effect on the functionality of the method.
186,<android.database.DatabaseUtils: void readExceptionWithOperationApplicationExceptionFromParcel(Parcel)>,8,9,<android.database.DatabaseUtils: void readExceptionWithOperationApplicationExceptionFromParcel(Parcel)>,<android.database.DatabaseUtils: void readExceptionWithOperationApplicationExceptionFromParcel(Parcel)>,0,"{
    int code = reply.readInt();
    if (code == 0)
        return;
    String msg = reply.readString();
    if (code == 10) {
        throw new OperationApplicationException(msg);
    } else {
        DatabaseUtils.readExceptionFromParcel(reply, msg, code);
    }
}","{
    int code = reply.readExceptionCode();
    if (code == 0)
        return;
    String msg = reply.readString();
    if (code == 10) {
        throw new OperationApplicationException(msg);
    } else {
        DatabaseUtils.readExceptionFromParcel(reply, msg, code);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The method that is being called to assign a value to the variable 'code' has changed from readInt() to readExceptionCode(). Therefore, the change type is 4,5.","In spite of the change in the method used to assign a value to the 'code' variable, the behaviours of the API remain the same in both versions since the conditions of if statements and the processing of variables 'msg' and 'code' have not changed. Therefore, there is no Compatibility Issue (CI)."
187,<android.widget.AbsListView: int computeVerticalScrollRange()>,8,9,<android.widget.AbsListView: int computeVerticalScrollRange()>,<android.widget.AbsListView: int computeVerticalScrollRange()>,0,"{
    int result;
    if (mSmoothScrollbarEnabled) {
        result = Math.max(mItemCount * 100, 0);
    } else {
        result = mItemCount;
    }
    return result;
}","{
    int result;
    if (mSmoothScrollbarEnabled) {
        result = Math.max(mItemCount * 100, 0);
        if (mScrollY != 0) {
            // Compensate for overscroll
            result += Math.abs((int) ((float) mScrollY / getHeight() * mItemCount * 100));
        }
    } else {
        result = mItemCount;
    }
    return result;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the 'if' branch, a new code block is added to calculate the 'result' when 'mScrollY' is not equal to 0. Therefore, the code change type is 1 (Return statement changed) and 3 (Control dependency changed).","The modification in the 'if' branch potentially changes the return value 'result'. Hence, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
189,<android.service.wallpaper.WallpaperService.Engine: void detach()>,8,9,<android.service.wallpaper.WallpaperService.Engine: void detach()>,<android.service.wallpaper.WallpaperService.Engine: void detach()>,0,"{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
    }
}","{
    if (mDestroyed) {
        return;
    }
    mDestroyed = true;
    if (mVisible) {
        mVisible = false;
        if (DEBUG)
            Log.v(TAG, ""onVisibilityChanged(false): "" + this);
        onVisibilityChanged(false);
    }
    reportSurfaceDestroyed();
    if (DEBUG)
        Log.v(TAG, ""onDestroy(): "" + this);
    onDestroy();
    unregisterReceiver(mReceiver);
    if (mCreated) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Removing window and destroying surface "" + mSurfaceHolder.getSurface() + "" of: "" + this);
            if (mInputChannel != null) {
                InputQueue.unregisterInputChannel(mInputChannel);
            }
            mSession.remove(mWindow);
        } catch (RemoteException e) {
        }
        mSurfaceHolder.mSurface.release();
        mCreated = false;
        // doesn't interpret the input channel being closed as an abnormal termination.
        if (mInputChannel != null) {
            mInputChannel.dispose();
            mInputChannel = null;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the late version, new code has been introduced to check if mInputChannel is not null, unregister it and later dispose it. This constitutes an ""Other statement changed"".","Although there were changes, these changes do not affect the return value nor the exception handling of the API, hence, there is no compatibility issue."
190,"<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>",8,9,"<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>","<android.content.res.Resources: void updateConfiguration(Configuration,DisplayMetrics)>",0,"{
    synchronized (mTmpValue) {
        int configChanges = 0xfffffff;
        if (config != null) {
            configChanges = mConfiguration.updateFrom(config);
        }
        if (mConfiguration.locale == null) {
            mConfiguration.locale = Locale.getDefault();
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
            mMetrics.updateMetrics(mCompatibilityInfo, mConfiguration.orientation, mConfiguration.screenLayout);
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = mConfiguration.locale.getLanguage();
            if (mConfiguration.locale.getCountry() != null) {
                locale += ""-"" + mConfiguration.locale.getCountry();
            }
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, (int) (mMetrics.density * 160), mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.screenLayout, mConfiguration.uiMode, sSdkVersion);
        int N = mDrawableCache.size();
        if (DEBUG_CONFIG) {
            Log.d(TAG, ""Cleaning up drawables config changes: 0x"" + Integer.toHexString(configChanges));
        }
        for (int i = 0; i < N; i++) {
            WeakReference<Drawable.ConstantState> ref = mDrawableCache.valueAt(i);
            if (ref != null) {
                Drawable.ConstantState cs = ref.get();
                if (cs != null) {
                    if (Configuration.needNewResources(configChanges, cs.getChangingConfigurations())) {
                        if (DEBUG_CONFIG) {
                            Log.d(TAG, ""FLUSHING #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()));
                        }
                        mDrawableCache.setValueAt(i, null);
                    } else if (DEBUG_CONFIG) {
                        Log.d(TAG, ""(Keeping #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()) + "")"");
                    }
                }
            }
        }
        mDrawableCache.clear();
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (mSync) {
        if (mPluralRule != null) {
            mPluralRule = PluralRules.ruleForLocale(config.locale);
        }
    }
}","{
    synchronized (mTmpValue) {
        int configChanges = 0xfffffff;
        if (config != null) {
            configChanges = mConfiguration.updateFrom(config);
        }
        if (mConfiguration.locale == null) {
            mConfiguration.locale = Locale.getDefault();
        }
        if (metrics != null) {
            mMetrics.setTo(metrics);
            mMetrics.updateMetrics(mCompatibilityInfo, mConfiguration.orientation, mConfiguration.screenLayout);
        }
        mMetrics.scaledDensity = mMetrics.density * mConfiguration.fontScale;
        String locale = null;
        if (mConfiguration.locale != null) {
            locale = mConfiguration.locale.getLanguage();
            if (mConfiguration.locale.getCountry() != null) {
                locale += ""-"" + mConfiguration.locale.getCountry();
            }
        }
        int width, height;
        if (mMetrics.widthPixels >= mMetrics.heightPixels) {
            width = mMetrics.widthPixels;
            height = mMetrics.heightPixels;
        } else {
            // noinspection SuspiciousNameCombination
            width = mMetrics.heightPixels;
            // noinspection SuspiciousNameCombination
            height = mMetrics.widthPixels;
        }
        int keyboardHidden = mConfiguration.keyboardHidden;
        if (keyboardHidden == Configuration.KEYBOARDHIDDEN_NO && mConfiguration.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
            keyboardHidden = Configuration.KEYBOARDHIDDEN_SOFT;
        }
        mAssets.setConfiguration(mConfiguration.mcc, mConfiguration.mnc, locale, mConfiguration.orientation, mConfiguration.touchscreen, (int) (mMetrics.density * 160), mConfiguration.keyboard, keyboardHidden, mConfiguration.navigation, width, height, mConfiguration.screenLayout, mConfiguration.uiMode, sSdkVersion);
        int N = mDrawableCache.size();
        if (DEBUG_CONFIG) {
            Log.d(TAG, ""Cleaning up drawables config changes: 0x"" + Integer.toHexString(configChanges));
        }
        for (int i = 0; i < N; i++) {
            WeakReference<Drawable.ConstantState> ref = mDrawableCache.valueAt(i);
            if (ref != null) {
                Drawable.ConstantState cs = ref.get();
                if (cs != null) {
                    if (Configuration.needNewResources(configChanges, cs.getChangingConfigurations())) {
                        if (DEBUG_CONFIG) {
                            Log.d(TAG, ""FLUSHING #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()));
                        }
                        mDrawableCache.setValueAt(i, null);
                    } else if (DEBUG_CONFIG) {
                        Log.d(TAG, ""(Keeping #0x"" + Long.toHexString(mDrawableCache.keyAt(i)) + "" / "" + cs + "" with changes: 0x"" + Integer.toHexString(cs.getChangingConfigurations()) + "")"");
                    }
                }
            }
        }
        mDrawableCache.clear();
        mColorStateListCache.clear();
        flushLayoutCache();
    }
    synchronized (mSync) {
        if (mPluralRule != null) {
            mPluralRule = PluralRules.ruleForLocale(config.locale);
        }
    }
}",1,"/**
 * Store the newly updated configuration.
 */
","/**
 * Store the newly updated configuration.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change found between the early version and the late version of the implementation.,"As the code remains the same, there is no potential compatibility issue between the two versions."
193,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,8,9,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,<android.pim.vcard.VCardComposer.HandlerForOutputStream: boolean onInit(Context)>,0,"{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharsetString));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharsetString);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharsetString;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1"", null));
        } catch (VCardException e) {
            Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage());
            return false;
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}","{
    try {
        mWriter = new BufferedWriter(new OutputStreamWriter(mOutputStream, mCharset));
    } catch (UnsupportedEncodingException e1) {
        Log.e(LOG_TAG, ""Unsupported charset: "" + mCharset);
        mErrorReason = ""Encoding is not supported (usually this does not happen!): "" + mCharset;
        return false;
    }
    if (mIsDoCoMo) {
        try {
            // Create one empty entry.
            mWriter.write(createOneEntryInternal(""-1"", null));
        } catch (VCardException e) {
            Log.e(LOG_TAG, ""VCardException has been thrown during on Init(): "" + e.getMessage());
            return false;
        } catch (IOException e) {
            Log.e(LOG_TAG, ""IOException occurred during exportOneContactData: "" + e.getMessage());
            mErrorReason = ""IOException occurred: "" + e.getMessage();
            return false;
        }
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable name has changed from `mCharsetString` to `mCharset`. Therefore, the code change type is 4 - Other statement changed.","There is no new behavior, no new exception, and the variable type did not change, just the variable name changed from `mCharsetString` to `mCharset`, hence no Compatibility Issue exists."
194,<android.pim.vcard.VCardBuilder: VCardBuilder appendNameProperties(List<ContentValues>)>,8,9,<android.pim.vcard.VCardBuilder: VCardBuilder appendNameProperties(List<ContentValues>)>,<android.pim.vcard.VCardBuilder: VCardBuilder appendNameProperties(List<ContentValues>)>,0,"{
    if (contentValuesList == null || contentValuesList.isEmpty()) {
        if (mIsDoCoMo) {
            appendLine(VCardConstants.PROPERTY_N, """");
        } else if (mIsV30) {
            // vCard 3.0 requires ""N"" and ""FN"" properties.
            appendLine(VCardConstants.PROPERTY_N, """");
            appendLine(VCardConstants.PROPERTY_FN, """");
        }
        return this;
    }
    final ContentValues contentValues = getPrimaryContentValue(contentValuesList);
    final String familyName = contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName = contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName = contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix = contentValues.getAsString(StructuredName.PREFIX);
    final String suffix = contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName = contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
        final boolean reallyAppendCharsetParameterToName = shouldAppendCharsetParam(familyName, givenName, middleName, prefix, suffix);
        final boolean reallyUseQuotedPrintableToName = (!mRefrainsQPToNameProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix) && VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
        final String formattedName;
        if (!TextUtils.isEmpty(displayName)) {
            formattedName = displayName;
        } else {
            formattedName = VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType), familyName, middleName, givenName, prefix, suffix);
        }
        final boolean reallyAppendCharsetParameterToFN = shouldAppendCharsetParam(formattedName);
        final boolean reallyUseQuotedPrintableToFN = !mRefrainsQPToNameProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
        final String encodedFamily;
        final String encodedGiven;
        final String encodedMiddle;
        final String encodedPrefix;
        final String encodedSuffix;
        if (reallyUseQuotedPrintableToName) {
            encodedFamily = encodeQuotedPrintable(familyName);
            encodedGiven = encodeQuotedPrintable(givenName);
            encodedMiddle = encodeQuotedPrintable(middleName);
            encodedPrefix = encodeQuotedPrintable(prefix);
            encodedSuffix = encodeQuotedPrintable(suffix);
        } else {
            encodedFamily = escapeCharacters(familyName);
            encodedGiven = escapeCharacters(givenName);
            encodedMiddle = escapeCharacters(middleName);
            encodedPrefix = escapeCharacters(prefix);
            encodedSuffix = escapeCharacters(suffix);
        }
        final String encodedFormattedname = (reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
        mBuilder.append(VCardConstants.PROPERTY_N);
        if (mIsDoCoMo) {
            if (reallyAppendCharsetParameterToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(mVCardCharsetParameter);
            }
            if (reallyUseQuotedPrintableToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(VCARD_PARAM_ENCODING_QP);
            }
            mBuilder.append(VCARD_DATA_SEPARATOR);
            // DoCoMo phones require that all the elements in the ""family name"" field.
            mBuilder.append(formattedName);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
        } else {
            if (reallyAppendCharsetParameterToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(mVCardCharsetParameter);
            }
            if (reallyUseQuotedPrintableToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(VCARD_PARAM_ENCODING_QP);
            }
            mBuilder.append(VCARD_DATA_SEPARATOR);
            mBuilder.append(encodedFamily);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedGiven);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedMiddle);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedPrefix);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedSuffix);
        }
        mBuilder.append(VCARD_END_OF_LINE);
        // FN property
        mBuilder.append(VCardConstants.PROPERTY_FN);
        if (reallyAppendCharsetParameterToFN) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        if (reallyUseQuotedPrintableToFN) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(VCARD_PARAM_ENCODING_QP);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedFormattedname);
        mBuilder.append(VCARD_END_OF_LINE);
    } else if (!TextUtils.isEmpty(displayName)) {
        final boolean reallyUseQuotedPrintableToDisplayName = (!mRefrainsQPToNameProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
        final String encodedDisplayName = reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
        mBuilder.append(VCardConstants.PROPERTY_N);
        if (shouldAppendCharsetParam(displayName)) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        if (reallyUseQuotedPrintableToDisplayName) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(VCARD_PARAM_ENCODING_QP);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedDisplayName);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_END_OF_LINE);
        mBuilder.append(VCardConstants.PROPERTY_FN);
        // importer allows this vioration.
        if (shouldAppendCharsetParam(displayName)) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedDisplayName);
        mBuilder.append(VCARD_END_OF_LINE);
    } else if (mIsV30) {
        // vCard 3.0 specification requires these fields.
        appendLine(VCardConstants.PROPERTY_N, """");
        appendLine(VCardConstants.PROPERTY_FN, """");
    } else if (mIsDoCoMo) {
        appendLine(VCardConstants.PROPERTY_N, """");
    }
    appendPhoneticNameFields(contentValues);
    return this;
}","{
    if (VCardConfig.isVersion40(mVCardType)) {
        return appendNamePropertiesV40(contentValuesList);
    }
    if (contentValuesList == null || contentValuesList.isEmpty()) {
        if (VCardConfig.isVersion30(mVCardType)) {
            // vCard 3.0 requires ""N"" and ""FN"" properties.
            // vCard 4.0 does NOT require N, but we take care of possible backward
            // compatibility issues.
            appendLine(VCardConstants.PROPERTY_N, """");
            appendLine(VCardConstants.PROPERTY_FN, """");
        } else if (mIsDoCoMo) {
            appendLine(VCardConstants.PROPERTY_N, """");
        }
        return this;
    }
    final ContentValues contentValues = getPrimaryContentValue(contentValuesList);
    final String familyName = contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName = contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName = contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix = contentValues.getAsString(StructuredName.PREFIX);
    final String suffix = contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName = contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
        final boolean reallyAppendCharsetParameterToName = shouldAppendCharsetParam(familyName, givenName, middleName, prefix, suffix);
        final boolean reallyUseQuotedPrintableToName = (!mRefrainsQPToNameProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix) && VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
        final String formattedName;
        if (!TextUtils.isEmpty(displayName)) {
            formattedName = displayName;
        } else {
            formattedName = VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType), familyName, middleName, givenName, prefix, suffix);
        }
        final boolean reallyAppendCharsetParameterToFN = shouldAppendCharsetParam(formattedName);
        final boolean reallyUseQuotedPrintableToFN = !mRefrainsQPToNameProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
        final String encodedFamily;
        final String encodedGiven;
        final String encodedMiddle;
        final String encodedPrefix;
        final String encodedSuffix;
        if (reallyUseQuotedPrintableToName) {
            encodedFamily = encodeQuotedPrintable(familyName);
            encodedGiven = encodeQuotedPrintable(givenName);
            encodedMiddle = encodeQuotedPrintable(middleName);
            encodedPrefix = encodeQuotedPrintable(prefix);
            encodedSuffix = encodeQuotedPrintable(suffix);
        } else {
            encodedFamily = escapeCharacters(familyName);
            encodedGiven = escapeCharacters(givenName);
            encodedMiddle = escapeCharacters(middleName);
            encodedPrefix = escapeCharacters(prefix);
            encodedSuffix = escapeCharacters(suffix);
        }
        final String encodedFormattedname = (reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
        mBuilder.append(VCardConstants.PROPERTY_N);
        if (mIsDoCoMo) {
            if (reallyAppendCharsetParameterToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(mVCardCharsetParameter);
            }
            if (reallyUseQuotedPrintableToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(VCARD_PARAM_ENCODING_QP);
            }
            mBuilder.append(VCARD_DATA_SEPARATOR);
            // DoCoMo phones require that all the elements in the ""family name"" field.
            mBuilder.append(formattedName);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
        } else {
            if (reallyAppendCharsetParameterToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(mVCardCharsetParameter);
            }
            if (reallyUseQuotedPrintableToName) {
                mBuilder.append(VCARD_PARAM_SEPARATOR);
                mBuilder.append(VCARD_PARAM_ENCODING_QP);
            }
            mBuilder.append(VCARD_DATA_SEPARATOR);
            mBuilder.append(encodedFamily);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedGiven);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedMiddle);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedPrefix);
            mBuilder.append(VCARD_ITEM_SEPARATOR);
            mBuilder.append(encodedSuffix);
        }
        mBuilder.append(VCARD_END_OF_LINE);
        // FN property
        mBuilder.append(VCardConstants.PROPERTY_FN);
        if (reallyAppendCharsetParameterToFN) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        if (reallyUseQuotedPrintableToFN) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(VCARD_PARAM_ENCODING_QP);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedFormattedname);
        mBuilder.append(VCARD_END_OF_LINE);
    } else if (!TextUtils.isEmpty(displayName)) {
        final boolean reallyUseQuotedPrintableToDisplayName = (!mRefrainsQPToNameProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
        final String encodedDisplayName = reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
        // N
        mBuilder.append(VCardConstants.PROPERTY_N);
        if (shouldAppendCharsetParam(displayName)) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        if (reallyUseQuotedPrintableToDisplayName) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(VCARD_PARAM_ENCODING_QP);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedDisplayName);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_ITEM_SEPARATOR);
        mBuilder.append(VCARD_END_OF_LINE);
        // FN
        mBuilder.append(VCardConstants.PROPERTY_FN);
        // assuming the external importer allows this vioration of the spec.
        if (shouldAppendCharsetParam(displayName)) {
            mBuilder.append(VCARD_PARAM_SEPARATOR);
            mBuilder.append(mVCardCharsetParameter);
        }
        mBuilder.append(VCARD_DATA_SEPARATOR);
        mBuilder.append(encodedDisplayName);
        mBuilder.append(VCARD_END_OF_LINE);
    } else if (VCardConfig.isVersion30(mVCardType)) {
        appendLine(VCardConstants.PROPERTY_N, """");
        appendLine(VCardConstants.PROPERTY_FN, """");
    } else if (mIsDoCoMo) {
        appendLine(VCardConstants.PROPERTY_N, """");
    }
    appendPhoneticNameFields(contentValues);
    return this;
}",1,"/**
 * For safety, we'll emit just one value around StructuredName, as external importers
 * may get confused with multiple ""N"", ""FN"", etc. properties, though it is valid in
 * vCard spec.
 */
","/**
 * For safety, we'll emit just one value around StructuredName, as external importers
 * may get confused with multiple ""N"", ""FN"", etc. properties, though it is valid in
 * vCard spec.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
195,<android.server.BluetoothService: void getAllProperties()>,8,9,<android.server.BluetoothService: void getAllProperties()>,<android.server.BluetoothService: void getAllProperties()>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    mAdapterProperties.clear();
    String[] properties = (String[]) getAdapterPropertiesNative();
    // The String Array consists of key-value pairs.
    if (properties == null) {
        Log.e(TAG, ""*Error*: GetAdapterProperties returned NULL"");
        return;
    }
    for (int i = 0; i < properties.length; i++) {
        String name = properties[i];
        String newValue = null;
        int len;
        if (name == null) {
            Log.e(TAG, ""Error:Adapter Property at index"" + i + ""is null"");
            continue;
        }
        if (name.equals(""Devices"")) {
            StringBuilder str = new StringBuilder();
            len = Integer.valueOf(properties[++i]);
            for (int j = 0; j < len; j++) {
                str.append(properties[++i]);
                str.append("","");
            }
            if (len > 0) {
                newValue = str.toString();
            }
        } else {
            newValue = properties[++i];
        }
        mAdapterProperties.put(name, newValue);
    }
    // Add adapter object path property.
    String adapterPath = getAdapterPathNative();
    if (adapterPath != null)
        mAdapterProperties.put(""ObjectPath"", adapterPath + ""/dev_"");
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    mAdapterProperties.clear();
    String[] properties = (String[]) getAdapterPropertiesNative();
    // The String Array consists of key-value pairs.
    if (properties == null) {
        Log.e(TAG, ""*Error*: GetAdapterProperties returned NULL"");
        return;
    }
    for (int i = 0; i < properties.length; i++) {
        String name = properties[i];
        String newValue = null;
        int len;
        if (name == null) {
            Log.e(TAG, ""Error:Adapter Property at index"" + i + ""is null"");
            continue;
        }
        if (name.equals(""Devices"") || name.equals(""UUIDs"")) {
            StringBuilder str = new StringBuilder();
            len = Integer.valueOf(properties[++i]);
            for (int j = 0; j < len; j++) {
                str.append(properties[++i]);
                str.append("","");
            }
            if (len > 0) {
                newValue = str.toString();
            }
        } else {
            newValue = properties[++i];
        }
        mAdapterProperties.put(name, newValue);
    }
    // Add adapter object path property.
    String adapterPath = getAdapterPathNative();
    if (adapterPath != null)
        mAdapterProperties.put(""ObjectPath"", adapterPath + ""/dev_"");
}",1,"/*package*/
","/*package*/
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"In the ""if"" condition statement, a new condition ""name.equals(""UUIDs"")"" has been added. So, the code change type is 3 (Control dependency changed).","Although the condition statement has been changed, this change does not lead to different return values or exception handlings. It only impacts the intermediate statements (the way to generate 'newValue'), but does not affect the actual return result of the function. Hence, no compatibility issue exists in this case (code change type: 0)."
196,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",8,9,"<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>","<android.app.ContextImpl: SharedPreferences getSharedPreferences(String,int)>",0,"{
    SharedPreferencesImpl sp;
    File f = getSharedPrefsFile(name);
    synchronized (sSharedPrefs) {
        sp = sSharedPrefs.get(f);
        if (sp != null && !sp.hasFileChanged()) {
            // Log.i(TAG, ""Returning existing prefs "" + name + "": "" + sp);
            return sp;
        }
    }
    FileInputStream str = null;
    File backup = makeBackupFile(f);
    if (backup.exists()) {
        f.delete();
        backup.renameTo(f);
    }
    // Debugging
    if (f.exists() && !f.canRead()) {
        Log.w(TAG, ""Attempt to read preferences file "" + f + "" without permission"");
    }
    Map map = null;
    if (f.exists() && f.canRead()) {
        try {
            str = new FileInputStream(f);
            map = XmlUtils.readMapXml(str);
            str.close();
        } catch (org.xmlpull.v1.XmlPullParserException e) {
            Log.w(TAG, ""getSharedPreferences"", e);
        } catch (FileNotFoundException e) {
            Log.w(TAG, ""getSharedPreferences"", e);
        } catch (IOException e) {
            Log.w(TAG, ""getSharedPreferences"", e);
        }
    }
    synchronized (sSharedPrefs) {
        if (sp != null) {
            // Log.i(TAG, ""Updating existing prefs "" + name + "" "" + sp + "": "" + map);
            sp.replace(map);
        } else {
            sp = sSharedPrefs.get(f);
            if (sp == null) {
                sp = new SharedPreferencesImpl(f, mode, map);
                sSharedPrefs.put(f, sp);
            }
        }
        return sp;
    }
}","{
    SharedPreferencesImpl sp;
    File prefsFile;
    boolean needInitialLoad = false;
    synchronized (sSharedPrefs) {
        sp = sSharedPrefs.get(name);
        if (sp != null && !sp.hasFileChangedUnexpectedly()) {
            return sp;
        }
        prefsFile = getSharedPrefsFile(name);
        if (sp == null) {
            sp = new SharedPreferencesImpl(prefsFile, mode, null);
            sSharedPrefs.put(name, sp);
            needInitialLoad = true;
        }
    }
    synchronized (sp) {
        if (needInitialLoad && sp.isLoaded()) {
            // lost the race to load; another thread handled it
            return sp;
        }
        File backup = makeBackupFile(prefsFile);
        if (backup.exists()) {
            prefsFile.delete();
            backup.renameTo(prefsFile);
        }
        // Debugging
        if (prefsFile.exists() && !prefsFile.canRead()) {
            Log.w(TAG, ""Attempt to read preferences file "" + prefsFile + "" without permission"");
        }
        Map map = null;
        if (prefsFile.exists() && prefsFile.canRead()) {
            try {
                FileInputStream str = new FileInputStream(prefsFile);
                map = XmlUtils.readMapXml(str);
                str.close();
            } catch (org.xmlpull.v1.XmlPullParserException e) {
                Log.w(TAG, ""getSharedPreferences"", e);
            } catch (FileNotFoundException e) {
                Log.w(TAG, ""getSharedPreferences"", e);
            } catch (IOException e) {
                Log.w(TAG, ""getSharedPreferences"", e);
            }
        }
        sp.replace(map);
    }
    return sp;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The control dependency related to the ""synchronized"" blocks has been changed significantly. The structure of the decision tree inside the ""synchronized"" block was changed and some of the return statements inside the block were removed. Therefore, the code change type is 1,3,4.","The removal of some return statements inside the ""synchronized"" block and changes in control stems can lead the API to return different values when invoked, because flow of execution may be different between the two code versions. Therefore, the CI type is 1."
197,<android.view.MotionEvent: float getPressure()>,8,9,<android.view.MotionEvent: float getPressure()>,<android.view.MotionEvent: float getPressure()>,0,"{
    return mDataSamples[SAMPLE_PRESSURE];
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_PRESSURE];
}",1,"/**
 * {@link #getPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getPressure(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,The statement that retrieves an element from the mDataSamples array has been modified. The index in the array changed from SAMPLE_PRESSURE to mLastDataSampleIndex + SAMPLE_PRESSURE. ,The modification to the array index could potentially result in a different return value. Hence a compatibility issue is present as the behavioural change would cause the API to return a different value.
198,<android.widget.TextView: void onCreateContextMenu(ContextMenu)>,8,9,<android.widget.TextView: void onCreateContextMenu(ContextMenu)>,<android.widget.TextView: void onCreateContextMenu(ContextMenu)>,0,"{
    super.onCreateContextMenu(menu);
    boolean added = false;
    if (!isFocused()) {
        if (isFocusable() && mInput != null) {
            if (canCopy()) {
                MenuHandler handler = new MenuHandler();
                int name = com.android.internal.R.string.copyAll;
                menu.add(0, ID_COPY, 0, name).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
                menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
            }
        }
        return;
    }
    MenuHandler handler = new MenuHandler();
    if (canSelectAll()) {
        menu.add(0, ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
        added = true;
    }
    boolean selection = getSelectionStart() != getSelectionEnd();
    if (canSelectText()) {
        if (MetaKeyKeyListener.getMetaState(mText, MetaKeyKeyListener.META_SELECTING) != 0) {
            menu.add(0, ID_STOP_SELECTING_TEXT, 0, com.android.internal.R.string.stopSelectingText).setOnMenuItemClickListener(handler);
            added = true;
        } else {
            menu.add(0, ID_START_SELECTING_TEXT, 0, com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
            added = true;
        }
    }
    if (canCut()) {
        int name;
        if (selection) {
            name = com.android.internal.R.string.cut;
        } else {
            name = com.android.internal.R.string.cutAll;
        }
        menu.add(0, ID_CUT, 0, name).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
        added = true;
    }
    if (canCopy()) {
        int name;
        if (selection) {
            name = com.android.internal.R.string.copy;
        } else {
            name = com.android.internal.R.string.copyAll;
        }
        menu.add(0, ID_COPY, 0, name).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
        added = true;
    }
    if (canPaste()) {
        menu.add(0, ID_PASTE, 0, com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
        added = true;
    }
    if (mText instanceof Spanned) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        int min = Math.min(selStart, selEnd);
        int max = Math.max(selStart, selEnd);
        URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
        if (urls.length == 1) {
            menu.add(0, ID_COPY_URL, 0, com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
            added = true;
        }
    }
    if (isInputMethodTarget()) {
        menu.add(1, ID_SWITCH_INPUT_METHOD, 0, com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
        added = true;
    }
    String word = getWordForDictionary();
    if (word != null) {
        menu.add(1, ID_ADD_TO_DICTIONARY, 0, getContext().getString(com.android.internal.R.string.addToDictionary, word)).setOnMenuItemClickListener(handler);
        added = true;
    }
    if (added) {
        menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
    }
}","{
    super.onCreateContextMenu(menu);
    boolean added = false;
    mContextMenuTriggeredByKey = mDPadCenterIsDown || mEnterKeyIsDown;
    // Problem with context menu on long press: the menu appears while the key in down and when
    // the key is released, the view does not receive the key_up event. This ensures that the
    // state is reset whenever the context menu action is displayed.
    // mContextMenuTriggeredByKey saved that state so that it is available in
    // onTextContextMenuItem. We cannot simply clear these flags in onTextContextMenuItem since
    // it may not be called (if the user/ discards the context menu with the back key).
    mDPadCenterIsDown = mEnterKeyIsDown = false;
    if (mIsInTextSelectionMode) {
        MenuHandler handler = new MenuHandler();
        if (canCut()) {
            menu.add(0, ID_CUT, 0, com.android.internal.R.string.cut).setOnMenuItemClickListener(handler).setAlphabeticShortcut('x');
            added = true;
        }
        if (canCopy()) {
            menu.add(0, ID_COPY, 0, com.android.internal.R.string.copy).setOnMenuItemClickListener(handler).setAlphabeticShortcut('c');
            added = true;
        }
        if (canPaste()) {
            menu.add(0, ID_PASTE, 0, com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
            added = true;
        }
    } else {
        MenuHandler handler = new MenuHandler();
        if (canSelectText()) {
            if (!hasPasswordTransformationMethod()) {
                // selectCurrentWord is not available on a password field and would return an
                // arbitrary 10-charater selection around pressed position. Discard it.
                // SelectAll is still useful to be able to clear the field using the delete key.
                menu.add(0, ID_START_SELECTING_TEXT, 0, com.android.internal.R.string.selectText).setOnMenuItemClickListener(handler);
            }
            menu.add(0, ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setOnMenuItemClickListener(handler).setAlphabeticShortcut('a');
            added = true;
        }
        if (mText instanceof Spanned) {
            int selStart = getSelectionStart();
            int selEnd = getSelectionEnd();
            int min = Math.min(selStart, selEnd);
            int max = Math.max(selStart, selEnd);
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length == 1) {
                menu.add(0, ID_COPY_URL, 0, com.android.internal.R.string.copyUrl).setOnMenuItemClickListener(handler);
                added = true;
            }
        }
        if (canPaste()) {
            menu.add(0, ID_PASTE, 0, com.android.internal.R.string.paste).setOnMenuItemClickListener(handler).setAlphabeticShortcut('v');
            added = true;
        }
        if (isInputMethodTarget()) {
            menu.add(1, ID_SWITCH_INPUT_METHOD, 0, com.android.internal.R.string.inputMethod).setOnMenuItemClickListener(handler);
            added = true;
        }
        String word = getWordForDictionary();
        if (word != null) {
            menu.add(1, ID_ADD_TO_DICTIONARY, 0, getContext().getString(com.android.internal.R.string.addToDictionary, word)).setOnMenuItemClickListener(handler);
            added = true;
        }
    }
    if (added) {
        menu.setHeaderTitle(com.android.internal.R.string.editTextMenuTitle);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"There are substantial changes in control statements (`if` conditions), and additional statements have been added (`mContextMenuTriggeredByKey = mDPadCenterIsDown || mEnterKeyIsDown;` and `mDPadCenterIsDown = mEnterKeyIsDown = false;`), so the change type is 3,4.","Although there are changes in the implementation, both versions of the API still ultimately return the same data type and there doesn't appear to be any exception handling changes. Therefore, there are no compatibility issues."
199,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,8,9,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,<android.inputmethodservice.InputMethodService: void onUpdateExtractingViews(EditorInfo)>,0,"{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (ei.actionLabel != null) {
            mExtractAction.setText(ei.actionLabel);
        } else {
            mExtractAction.setText(getTextForImeAction(ei.imeOptions));
        }
        mExtractAction.setOnClickListener(mActionClickListener);
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        mExtractAction.setOnClickListener(null);
    }
}","{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (mExtractAction != null) {
            if (ei.actionLabel != null) {
                mExtractAction.setText(ei.actionLabel);
            } else {
                mExtractAction.setText(getTextForImeAction(ei.imeOptions));
            }
            mExtractAction.setOnClickListener(mActionClickListener);
        }
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        if (mExtractAction != null) {
            mExtractAction.setOnClickListener(null);
        }
    }
}",1,"/**
 * Called when the fullscreen-mode extracting editor info has changed,
 * to update the state of its UI such as the action buttons shown.
 * You do not need to deal with this if you are using the standard
 * full screen extract UI.  If replacing it, you will need to re-implement
 * this to put the appropriate action button in your own UI and handle it,
 * and perform any other changes.
 *
 * <p>The standard implementation turns on or off its accessory area
 * depending on whether there is an action button, and hides or shows
 * the entire extract area depending on whether it makes sense for the
 * current editor.  In particular, a {@link InputType#TYPE_NULL} or
 * {@link InputType#TYPE_TEXT_VARIATION_FILTER} input type will turn off the
 * extract area since there is no text to be shown.
 */
","/**
 * Called when the fullscreen-mode extracting editor info has changed,
 * to update the state of its UI such as the action buttons shown.
 * You do not need to deal with this if you are using the standard
 * full screen extract UI.  If replacing it, you will need to re-implement
 * this to put the appropriate action button in your own UI and handle it,
 * and perform any other changes.
 *
 * <p>The standard implementation turns on or off its accessory area
 * depending on whether there is an action button, and hides or shows
 * the entire extract area depending on whether it makes sense for the
 * current editor.  In particular, a {@link InputType#TYPE_NULL} or
 * {@link InputType#TYPE_TEXT_VARIATION_FILTER} input type will turn off the
 * extract area since there is no text to be shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The new condition 'if (mExtractAction != null)' is added in the late implementation, so the code change type is 3.","The change 'if (mExtractAction != null)' only adds new judgments for 'mExtractAction'. Since 'mExtractAction' is made null-check here, it just eliminates potential null pointer exceptions which doesn't change the functional behaviour of this method. Therefore, the compatinbility issue type is 0."
200,<android.widget.Gallery: boolean dispatchKeyEvent(KeyEvent)>,8,9,<android.widget.Gallery: boolean dispatchKeyEvent(KeyEvent)>,<android.widget.Gallery: boolean dispatchKeyEvent(KeyEvent)>,0,"{
    // Gallery steals all key events
    return event.dispatch(this);
}","{
    // Gallery steals all key events
    return event.dispatch(this, null, null);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from event.dispatch(this) to event.dispatch(this, null, null). This API also relies on the function dispatch() from the class of KeyEvent, and the dependent API has undergone changes, including alterations in the number of parameters. So the code change type is 1,5.","The change of return statement will make the API potentially return a different result, so the CI type is 1."
202,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",8,9,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = false;
        } else if (commitCopy()) {
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), false);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mShiftIsPressed && !nativeFocusIsPlugin()) {
            if (mExtendSelection) {
                commitCopy();
            } else {
                mExtendSelection = true;
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry(true);
        nativeSetFollowedLink(true);
        if (!mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
        }
        return true;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = false;
        } else if (copySelection()) {
            selectionDone();
            return true;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), false);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry(true);
        nativeSetFollowedLink(true);
        if (!mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
        }
        return true;
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The methods 'commitCopy()' and 'selectionDone()' were replaced by 'copySelection()' in conditions 'if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT)' and 'if (mExtendSelection)', so the code change type is 1,5.","The change of 'commitCopy()' and 'selectionDone()' methods to 'copySelection()' can make the API potentially return a different value, so the Compatibility Issue exists and its type is 1."
203,<android.pim.vcard.VCardEntryConstructor: void startEntry()>,8,9,<android.pim.vcard.VCardEntryConstructor: void startEntry()>,<android.pim.vcard.VCardEntryConstructor: void startEntry()>,0,"{
    if (mCurrentContactStruct != null) {
        Log.e(LOG_TAG, ""Nested VCard code is not supported now."");
    }
    mCurrentContactStruct = new VCardEntry(mVCardType, mAccount);
}","{
    if (mCurrentVCardEntry != null) {
        Log.e(LOG_TAG, ""Nested VCard code is not supported now."");
    }
    mCurrentVCardEntry = new VCardEntry(mVCardType, mAccount);
}",1,"/**
 * Assume that VCard is not nested. In other words, this code does not accept
 */
",,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from 'mCurrentContactStruct = new VCardEntry(mVCardType, mAccount)' to 'mCurrentVCardEntry = new VCardEntry(mVCardType, mAccount)'. Also, the if condition checking statement has been changed, so the code change type is 1,4.","Since the statement has changed to create a new instance of a different variable, this could potentially return a different value, so the CI type is 1."
205,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",8,9,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>","<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",0,"{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            int x = (int) event.getX();
            int y = (int) event.getY();
            int offset = getOffset(x, y, widget);
            if (cap) {
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            } else {
                OnePointFiveTapState[] tap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
                if (tap.length > 0) {
                    if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout() && sameWord(buffer, offset, Selection.getSelectionEnd(buffer))) {
                        tap[0].active = true;
                        MetaKeyKeyListener.startSelecting(widget, buffer);
                        widget.getParent().requestDisallowInterceptTouchEvent(true);
                        buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                    }
                    tap[0].mWhen = event.getEventTime();
                } else {
                    OnePointFiveTapState newtap = new OnePointFiveTapState();
                    newtap.mWhen = event.getEventTime();
                    newtap.active = false;
                    buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
                }
            }
        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            if (cap && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable longpress
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int x = (int) event.getX();
                int y = (int) event.getY();
                int offset = getOffset(x, y, widget);
                final OnePointFiveTapState[] tap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
                if (tap.length > 0 && tap[0].active) {
                    // Get the last down touch position (the position at which the
                    // user started the selection)
                    int lastDownOffset = buffer.getSpanStart(LAST_TAP_DOWN);
                    // Compute the selection boundaries
                    int spanstart;
                    int spanend;
                    if (offset >= lastDownOffset) {
                        // Expand from word start of the original tap to new word
                        // end, since we are selecting ""forwards""
                        spanstart = findWordStart(buffer, lastDownOffset);
                        spanend = findWordEnd(buffer, offset);
                    } else {
                        // Expand to from new word start to word end of the original
                        // tap since we are selecting ""backwards"".
                        // The spanend will always need to be associated with the touch
                        // up position, so that refining the selection with the
                        // trackball will work as expected.
                        spanstart = findWordEnd(buffer, lastDownOffset);
                        spanend = findWordStart(buffer, offset);
                    }
                    Selection.setSelection(buffer, spanstart, spanend);
                } else {
                    Selection.extendSelection(buffer, offset);
                }
                return true;
            }
        } else if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int x = (int) event.getX();
            int y = (int) event.getY();
            int off = getOffset(x, y, widget);
            // XXX should do the same adjust for x as we do for the line.
            OnePointFiveTapState[] onepointfivetap = buffer.getSpans(0, buffer.length(), OnePointFiveTapState.class);
            if (onepointfivetap.length > 0 && onepointfivetap[0].active && Selection.getSelectionStart(buffer) == Selection.getSelectionEnd(buffer)) {
                // If we've set select mode, because there was a onepointfivetap,
                // but there was no ensuing swipe gesture, undo the select mode
                // and remove reference to the last onepointfivetap.
                MetaKeyKeyListener.stopSelecting(widget, buffer);
                for (int i = 0; i < onepointfivetap.length; i++) {
                    buffer.removeSpan(onepointfivetap[i]);
                }
                buffer.removeSpan(LAST_TAP_DOWN);
            }
            boolean cap = (MetaKeyKeyListener.getMetaState(buffer, KeyEvent.META_SHIFT_ON) == 1) || (MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0);
            DoubleTapState[] tap = buffer.getSpans(0, buffer.length(), DoubleTapState.class);
            boolean doubletap = false;
            if (tap.length > 0) {
                if (event.getEventTime() - tap[0].mWhen <= ViewConfiguration.getDoubleTapTimeout() && sameWord(buffer, off, Selection.getSelectionEnd(buffer))) {
                    doubletap = true;
                }
                tap[0].mWhen = event.getEventTime();
            } else {
                DoubleTapState newtap = new DoubleTapState();
                newtap.mWhen = event.getEventTime();
                buffer.setSpan(newtap, 0, buffer.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
            }
            if (cap) {
                buffer.removeSpan(LAST_TAP_DOWN);
                if (onepointfivetap.length > 0 && onepointfivetap[0].active) {
                    // If we selecting something with the onepointfivetap-and
                    // swipe gesture, stop it on finger up.
                    MetaKeyKeyListener.stopSelecting(widget, buffer);
                } else {
                    Selection.extendSelection(buffer, off);
                }
            } else if (doubletap) {
                Selection.setSelection(buffer, findWordStart(buffer, off), findWordEnd(buffer, off));
            } else {
                Selection.setSelection(buffer, off);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1, initialScrollY = -1;
    if (event.getAction() == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            boolean cap = isCap(buffer);
            if (cap) {
                int offset = widget.getOffset((int) event.getX(), (int) event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
            boolean cap = isCap(buffer);
            if (cap && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffset((int) event.getX(), (int) event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (event.getAction() == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffset((int) event.getX(), (int) event.getY());
            if (isCap(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            } else {
                Selection.setSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A certain part of the code logic has been changed that includes control dependency changes and other statement changes, such as removal of certain conditions and corresponding blocks of code like creating a new instance of 'OnePointFiveTapState' etc., so the code change type is 3,4.","Since the control dependency chain and several other statements have been modified, this has a potential to alter the behaviour of the method and consequently, the method might return different values when executed. Therefore, it poses a compatibility issue of type 1."
207,"<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>",8,9,"<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>","<android.inputmethodservice.IInputMethodWrapper: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    if (mTarget.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.executeOrSendMessage(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}","{
    AbstractInputMethodService target = mTarget.get();
    if (target == null) {
        return;
    }
    if (target.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        fout.println(""Permission Denial: can't dump InputMethodManager from from pid="" + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid());
        return;
    }
    CountDownLatch latch = new CountDownLatch(1);
    mCaller.executeOrSendMessage(mCaller.obtainMessageOOOO(DO_DUMP, fd, fout, args, latch));
    try {
        if (!latch.await(5, TimeUnit.SECONDS)) {
            fout.println(""Timeout waiting for dump"");
        }
    } catch (InterruptedException e) {
        fout.println(""Interrupted waiting for dump"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"Two new lines of code were introduced, initializing the target variable and another return statement was added. This results in two types of changes: A new return statement was introduced (change type 1) and control dependency was changed due to the addition of a new 'if' condition (change type 3).","Due to the introduction of a new return statement, this method can potentially return at a different point than in the early version. Thus it can lead to having a compatibility issue of type 1, which is caused by potential different return values or types."
210,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,8,9,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,<android.bluetooth.BluetoothAdapter: boolean isDiscovering()>,0,"{
    try {
        return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
","/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3, 3",1,"The condition statement 'if (getState() != STATE_ON) return false;' has been added, so the code change class is 3.","Because of the added condition 'if (getState() != STATE_ON) return false;' in the late version, the output of the API can potentially be different, leading to a Compatibility Issue with type 1."
213,<android.view.MotionEvent: long getDownTime()>,8,9,<android.view.MotionEvent: long getDownTime()>,<android.view.MotionEvent: long getDownTime()>,0,"{
    return mDownTime;
}","{
    return mDownTimeNano / MS_PER_NS;
}",1,"/**
 * Returns the time (in ms) when the user originally pressed down to start
 * a stream of position events.
 */
","/**
 * Returns the time (in ms) when the user originally pressed down to start
 * a stream of position events.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has been changed from 'return mDownTime' to 'return mDownTimeNano / MS_PER_NS', so the code change type is 1.","The change of return statement could make the API return a different value, so the CI type is 1."
214,"<android.webkit.WebView: void postUrl(String,byte[])>",8,9,"<android.webkit.WebView: void postUrl(String,byte[])>","<android.webkit.WebView: void postUrl(String,byte[])>",0,"{
    if (URLUtil.isNetworkUrl(url)) {
        switchOutDrawHistory();
        WebViewCore.PostUrlData arg = new WebViewCore.PostUrlData();
        arg.mUrl = url;
        arg.mPostData = postData;
        mWebViewCore.sendMessage(EventHub.POST_URL, arg);
        clearTextEntry(false);
    } else {
        loadUrl(url);
    }
}","{
    if (URLUtil.isNetworkUrl(url)) {
        switchOutDrawHistory();
        WebViewCore.PostUrlData arg = new WebViewCore.PostUrlData();
        arg.mUrl = url;
        arg.mPostData = postData;
        mWebViewCore.sendMessage(EventHub.POST_URL, arg);
        clearHelpers();
    } else {
        loadUrl(url);
    }
}",1,"/**
 * Load the url with postData using ""POST"" method into the WebView. If url
 * is not a network url, it will be loaded with {link
 * {@link #loadUrl(String)} instead.
 *
 * @param url The url of the resource to load.
 * @param postData The data will be passed to ""POST"" request.
 */
","/**
 * Load the url with postData using ""POST"" method into the WebView. If url
 * is not a network url, it will be loaded with {link
 * {@link #loadUrl(String)} instead.
 *
 * @param url The url of the resource to load.
 * @param postData The data will be passed to ""POST"" request.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method clearTextEntry is replaced by the method clearHelpers. This represents a change in other statements that does not affect the return type, exception handling, control dependencies or dependent API. Therefore, the change type is classified as 4.","There is no compatibility issue since the both versions of the API do not return any value and do not throw any exceptions. And the change of clearTextEntry to clearHelpers does not affect the output or the behavior of the API. Therefore, the CI type is 0."
215,<android.pim.vcard.VCardEntryConstructor: void endEntry()>,8,9,<android.pim.vcard.VCardEntryConstructor: void endEntry()>,<android.pim.vcard.VCardEntryConstructor: void endEntry()>,0,"{
    mCurrentContactStruct.consolidateFields();
    for (VCardEntryHandler entryHandler : mEntryHandlers) {
        entryHandler.onEntryCreated(mCurrentContactStruct);
    }
    mCurrentContactStruct = null;
}","{
    mCurrentVCardEntry.consolidateFields();
    for (VCardEntryHandler entryHandler : mEntryHandlers) {
        entryHandler.onEntryCreated(mCurrentVCardEntry);
    }
    mCurrentVCardEntry = null;
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,"1,4",0,"The name of the variable being consolidated and passed to the onEntryCreated() method has changed from mCurrentContactStruct to mCurrentVCardEntry. So, the code change types are Return statement changed (1) and Other statement changed (4).","Even though there is a change in the variable name, it is expected to behave similarly as the old version because it is just a renaming of the object reference. So, there is no compatibility issue (0) occurring here."
217,<android.pim.vcard.VCardEntryConstructor: void endProperty()>,8,9,<android.pim.vcard.VCardEntryConstructor: void endProperty()>,<android.pim.vcard.VCardEntryConstructor: void endProperty()>,0,"{
    mCurrentContactStruct.addProperty(mCurrentProperty);
}","{
    mCurrentVCardEntry.addProperty(mCurrentProperty);
}",1,,,-1,,[@Override],-1,-1,-1,-1,-1,-1,4,1,The class member mCurrentContactStruct has been replaced with mCurrentVCardEntry. This can be classified as Other statement change.,"The outcome of addProperty method could potentially be different because it's called on a different object, therefore it can cause a Compatibility Issue where the API potentially returns different values. The CI type is 1."
220,<android.inputmethodservice.IInputMethodWrapper: InputMethod getInternalInputMethod()>,8,9,<android.inputmethodservice.IInputMethodWrapper: InputMethod getInternalInputMethod()>,<android.inputmethodservice.IInputMethodWrapper: InputMethod getInternalInputMethod()>,0,"{
    return mInputMethod;
}","{
    return mInputMethod.get();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mInputMethod;' to 'return mInputMethod.get();', so the code change type is 1.","The return statement change may lead to the method returning a different value, hence the CI type is 1."
221,"<android.os.RecoverySystem: void installPackage(Context,File)>",8,9,"<android.os.RecoverySystem: void installPackage(Context,File)>","<android.os.RecoverySystem: void installPackage(Context,File)>",0,"{
    String filename = packageFile.getCanonicalPath();
    if (filename.startsWith(""/cache/"")) {
        filename = ""CACHE:"" + filename.substring(7);
    } else if (filename.startsWith(""/data/"")) {
        filename = ""DATA:"" + filename.substring(6);
    } else {
        throw new IllegalArgumentException(""Must start with /cache or /data: "" + filename);
    }
    Log.w(TAG, ""!!! REBOOTING TO INSTALL "" + filename + "" !!!"");
    String arg = ""--update_package="" + filename;
    bootCommand(context, arg);
}","{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, ""!!! REBOOTING TO INSTALL "" + filename + "" !!!"");
    String arg = ""--update_package="" + filename;
    bootCommand(context, arg);
}",1,"/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Currently
 * must be on the /cache or /data partitions.
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
","/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4","1,2","The condition statement (if, else if) and exception handling statement (throw) has been deleted, so the code change type is 3,4.","The deletion of the condition statement and exception handling may alter the behavior of the API. It is therefore possible that the value returned by the function bootCommand() might change or the method may no longer throw IllegalArgumentException. Hence, the Compatibility Issue type is 1,2."
223,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,8,9,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,<android.database.sqlite.SQLiteDatabase: void execSQL(String)>,0,"{
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    logTimeStat(mLastSqlStatement, timeStart, GET_LOCK_LOG_PREFIX);
    try {
        native_execSQL(sql);
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        unlock();
    }
    // equality to COMMIT_SQL is safe here.
    if (sql == COMMIT_SQL) {
        logTimeStat(mLastSqlStatement, timeStart, COMMIT_SQL);
    } else {
        logTimeStat(sql, timeStart, null);
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    logTimeStat(mLastSqlStatement, timeStart, GET_LOCK_LOG_PREFIX);
    try {
        native_execSQL(sql);
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        unlock();
    }
    // equality to COMMIT_SQL is safe here.
    if (sql == COMMIT_SQL) {
        logTimeStat(mLastSqlStatement, timeStart, COMMIT_SQL);
    } else {
        logTimeStat(sql, timeStart, null);
    }
}",1,"/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock
 *
 * @throws SQLException If the SQL string is invalid for some reason
 */
","/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock
 *
 * @throws SQLException If the SQL string is invalid for some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"In the newer version of the API, a new statement 'BlockGuard.getThreadPolicy().onWriteToDisk();' has been added at the start. This is an operation related to disk write and does not affect the control flow, return value, exception handling, or dependent APIs. Therefore, the code change belongs to category 4.","Although there is a change in the late version, this newly added statement will not affect the implementation logic, return variables, or exception handling of the API, and thus will not lead to a compatibility issue. So, the CI type is 0."
225,"<android.pim.RecurrenceSet: boolean populateContentValues(Component,ContentValues)>",8,9,"<android.pim.RecurrenceSet: boolean populateContentValues(Component,ContentValues)>","<android.pim.RecurrenceSet: boolean populateContentValues(Component,ContentValues)>",0,"{
    ICalendar.Property dtstartProperty = component.getFirstProperty(""DTSTART"");
    String dtstart = dtstartProperty.getValue();
    ICalendar.Parameter tzidParam = dtstartProperty.getFirstParameter(""TZID"");
    // NOTE: the timezone may be null, if this is a floating time.
    String tzid = tzidParam == null ? null : tzidParam.value;
    Time start = new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
    boolean inUtc = start.parse(dtstart);
    boolean allDay = start.allDay;
    if (inUtc) {
        tzid = Time.TIMEZONE_UTC;
    }
    String duration = computeDuration(start, component);
    String rrule = flattenProperties(component, ""RRULE"");
    String rdate = extractDates(component.getFirstProperty(""RDATE""));
    String exrule = flattenProperties(component, ""EXRULE"");
    String exdate = extractDates(component.getFirstProperty(""EXDATE""));
    if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
        if (Config.LOGD) {
            Log.d(TAG, ""Recurrence missing DTSTART, DTEND/DURATION, "" + ""or RRULE/RDATE: "" + component.toString());
        }
        return false;
    }
    if (allDay) {
        // TODO: also change tzid to be UTC?  that would be consistent, but
        // that would not reflect the original timezone value back to the
        // server.
        start.timezone = Time.TIMEZONE_UTC;
    }
    long millis = start.toMillis(false);
    values.put(Calendar.Events.DTSTART, millis);
    if (millis == -1) {
        if (Config.LOGD) {
            Log.d(TAG, ""DTSTART is out of range: "" + component.toString());
        }
        return false;
    }
    values.put(Calendar.Events.RRULE, rrule);
    values.put(Calendar.Events.RDATE, rdate);
    values.put(Calendar.Events.EXRULE, exrule);
    values.put(Calendar.Events.EXDATE, exdate);
    values.put(Calendar.Events.EVENT_TIMEZONE, tzid);
    values.put(Calendar.Events.DURATION, duration);
    values.put(Calendar.Events.ALL_DAY, allDay ? 1 : 0);
    return true;
}","{
    ICalendar.Property dtstartProperty = component.getFirstProperty(""DTSTART"");
    String dtstart = dtstartProperty.getValue();
    ICalendar.Parameter tzidParam = dtstartProperty.getFirstParameter(""TZID"");
    // NOTE: the timezone may be null, if this is a floating time.
    String tzid = tzidParam == null ? null : tzidParam.value;
    Time start = new Time(tzidParam == null ? Time.TIMEZONE_UTC : tzid);
    boolean inUtc = start.parse(dtstart);
    boolean allDay = start.allDay;
    // TimeZone in DTSTART for them
    if (inUtc || allDay) {
        tzid = Time.TIMEZONE_UTC;
    }
    String duration = computeDuration(start, component);
    String rrule = flattenProperties(component, ""RRULE"");
    String rdate = extractDates(component.getFirstProperty(""RDATE""));
    String exrule = flattenProperties(component, ""EXRULE"");
    String exdate = extractDates(component.getFirstProperty(""EXDATE""));
    if ((TextUtils.isEmpty(dtstart)) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rrule)) && (TextUtils.isEmpty(rdate)))) {
        if (Config.LOGD) {
            Log.d(TAG, ""Recurrence missing DTSTART, DTEND/DURATION, "" + ""or RRULE/RDATE: "" + component.toString());
        }
        return false;
    }
    if (allDay) {
        // TODO: also change tzid to be UTC?  that would be consistent, but
        // that would not reflect the original timezone value back to the
        // server.
        start.timezone = Time.TIMEZONE_UTC;
    }
    long millis = start.toMillis(false);
    values.put(Calendar.Events.DTSTART, millis);
    if (millis == -1) {
        if (Config.LOGD) {
            Log.d(TAG, ""DTSTART is out of range: "" + component.toString());
        }
        return false;
    }
    values.put(Calendar.Events.RRULE, rrule);
    values.put(Calendar.Events.RDATE, rdate);
    values.put(Calendar.Events.EXRULE, exrule);
    values.put(Calendar.Events.EXDATE, exdate);
    values.put(Calendar.Events.EVENT_TIMEZONE, tzid);
    values.put(Calendar.Events.DURATION, duration);
    values.put(Calendar.Events.ALL_DAY, allDay ? 1 : 0);
    return true;
}",1,"/**
 * Populates the database map of values with the appropriate RRULE, RDATE,
 * EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desired
 * recurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary information
 * to specify a recurrence.  The required fields are DTSTART,
 * one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if
 * there was an error, including if the date is out of range.
 */
","/**
 * Populates the database map of values with the appropriate RRULE, RDATE,
 * EXRULE, and EXDATE values extracted from the parsed iCalendar component.
 * @param component The iCalendar component containing the desired
 * recurrence specification.
 * @param values The db values that should be updated.
 * @return true if the component contained the necessary information
 * to specify a recurrence.  The required fields are DTSTART,
 * one of DTEND/DURATION, and one of RRULE/RDATE.  Returns false if
 * there was an error, including if the date is out of range.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The condition statement 'if (inUtc)' has been changed to 'if (inUtc || allDay)', so the code change type is 3.","The changed condition in the 'if' statement could potentially lead to different values being assigned to the variable 'tzid'. Therefore, this could potentially lead to a different return value, causing a CI of type 1."
227,<android.view.MotionEvent: float getX()>,8,9,<android.view.MotionEvent: float getX()>,<android.view.MotionEvent: float getX()>,0,"{
    return mDataSamples[SAMPLE_X];
}","{
    return mDataSamples[mLastDataSampleIndex + SAMPLE_X] + mXOffset;
}",1,"/**
 * {@link #getX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
","/**
 * {@link #getX(int)} for the first pointer index (may be an
 * arbitrary pointer identifier).
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"In the late version, the method of calculating the returned float value has been changed, which may lead to a different result being returned. The change type is marked as 1 (return statement changed) and 4 (other statement changed).","Because of the changed calculation method, the latest version may return a different value. The Compatibility Issue type is 1 (potential different return values)."
231,<android.database.DatabaseUtils: void readExceptionFromParcel(Parcel)>,8,9,<android.database.DatabaseUtils: void readExceptionFromParcel(Parcel)>,<android.database.DatabaseUtils: void readExceptionFromParcel(Parcel)>,0,"{
    int code = reply.readInt();
    if (code == 0)
        return;
    String msg = reply.readString();
    DatabaseUtils.readExceptionFromParcel(reply, msg, code);
}","{
    int code = reply.readExceptionCode();
    if (code == 0)
        return;
    String msg = reply.readString();
    DatabaseUtils.readExceptionFromParcel(reply, msg, code);
}",1,"/**
 * Special function for reading an exception result from the header of
 * a parcel, to be used after receiving the result of a transaction.  This
 * will throw the exception for you if it had been written to the Parcel,
 * otherwise return and let you read the normal result data from the Parcel.
 * @param reply Parcel to read from
 * @see Parcel#writeNoException
 * @see Parcel#readException
 */
","/**
 * Special function for reading an exception result from the header of
 * a parcel, to be used after receiving the result of a transaction.  This
 * will throw the exception for you if it had been written to the Parcel,
 * otherwise return and let you read the normal result data from the Parcel.
 * @param reply Parcel to read from
 * @see Parcel#writeNoException
 * @see Parcel#readException
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The variable 'code' has changed from reply.readInt() to reply.readExceptionCode(). This is not a return, control dependency or exception handling statement. Nor is it a dependent API change, the change type is thus 4.","The change in how the variable 'code' is assigned doesn't impact the behaviour of the API. It doesn't affect what is returned or any thrown exceptions. Thus, no compatibility issue (CI) exists, and the type is 0."
232,<android.os.Vibrator: void vibrate(long)>,8,9,<android.os.Vibrator: void vibrate(long)>,<android.os.Vibrator: void vibrate(long)>,0,"{
    try {
        mService.vibrate(milliseconds, mToken);
    } catch (RemoteException e) {
    }
}","{
    if (mService == null) {
        Log.w(TAG, ""Failed to vibrate; no vibrator service."");
        return;
    }
    try {
        mService.vibrate(milliseconds, mToken);
    } catch (RemoteException e) {
        Log.w(TAG, ""Failed to vibrate."", e);
    }
}",1,"/**
 * Turn the vibrator on.
 *
 * @param milliseconds How long to vibrate for.
 */
","/**
 * Turn the vibrator on.
 *
 * @param milliseconds How long to vibrate for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"A new control statement ""if (mService == null)"" and a return statement as well as a log message are introduced in the late version, so the code change type is 3,4.","The new 'return' statement in the control statement could lead to the function terminates without invoking 'mService.vibrate(milliseconds, mToken);', thus the function behaves differently and the the CI type is 1."
234,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,8,9,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,0,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!(mIsBeingDragged = inChild((int) ev.getX(), (int) y))) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                scrollBy(0, deltaY);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0 && Math.abs(initialVelocity) > mMinimumVelocity) {
                    fling(-initialVelocity);
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                mIsBeingDragged = true;
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                final int overscrollMode = getOverScrollMode();
                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0)) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        final int bottom = getScrollRange();
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, bottom)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,The method has several change points: ,"3) in the 'MotionEvent.ACTION_UP' and 'MotionEvent.ACTION_CANCEL' handling cases, the actions for finishing scroll and releasing the edge glow are added or changed."
235,<android.app.ActivityThread.H: void handleMessage(Message)>,8,9,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                ActivityRecord r = (ActivityRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo);
                handleLaunchActivity(r, null);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                ActivityRecord r = (ActivityRecord) msg.obj;
                handleRelaunchActivity(r, msg.arg1);
            }
            break;
        case PAUSE_ACTIVITY:
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            break;
        case PAUSE_ACTIVITY_FINISHING:
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            break;
        case STOP_ACTIVITY_SHOW:
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            break;
        case STOP_ACTIVITY_HIDE:
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            break;
        case SHOW_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, true);
            break;
        case HIDE_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, false);
            break;
        case RESUME_ACTIVITY:
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            break;
        case SEND_RESULT:
            handleSendResult((ResultData) msg.obj);
            break;
        case DESTROY_ACTIVITY:
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            break;
        case BIND_APPLICATION:
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            handleNewIntent((NewIntentData) msg.obj);
            break;
        case RECEIVER:
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            break;
        case CREATE_SERVICE:
            handleCreateService((CreateServiceData) msg.obj);
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData) msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData) msg.obj);
            break;
        case SERVICE_ARGS:
            handleServiceArgs((ServiceArgsData) msg.obj);
            break;
        case STOP_SERVICE:
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            break;
        case REQUEST_THUMBNAIL:
            handleRequestThumbnail((IBinder) msg.obj);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpServiceInfo) msg.obj);
            break;
        case LOW_MEMORY:
            handleLowMemory();
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            handleActivityConfigurationChanged((IBinder) msg.obj);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj);
            break;
        case CREATE_BACKUP_AGENT:
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case DESTROY_BACKUP_AGENT:
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            completeRemoveProvider((IContentProvider) msg.obj);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            break;
    }
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + msg.what);
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo);
                handleLaunchActivity(r, null);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r, msg.arg1);
            }
            break;
        case PAUSE_ACTIVITY:
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            break;
        case PAUSE_ACTIVITY_FINISHING:
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            break;
        case STOP_ACTIVITY_SHOW:
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            break;
        case STOP_ACTIVITY_HIDE:
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            break;
        case SHOW_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, true);
            break;
        case HIDE_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, false);
            break;
        case RESUME_ACTIVITY:
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            break;
        case SEND_RESULT:
            handleSendResult((ResultData) msg.obj);
            break;
        case DESTROY_ACTIVITY:
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            break;
        case BIND_APPLICATION:
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            handleNewIntent((NewIntentData) msg.obj);
            break;
        case RECEIVER:
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            break;
        case CREATE_SERVICE:
            handleCreateService((CreateServiceData) msg.obj);
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData) msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData) msg.obj);
            break;
        case SERVICE_ARGS:
            handleServiceArgs((ServiceArgsData) msg.obj);
            break;
        case STOP_SERVICE:
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            break;
        case REQUEST_THUMBNAIL:
            handleRequestThumbnail((IBinder) msg.obj);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpServiceInfo) msg.obj);
            break;
        case LOW_MEMORY:
            handleLowMemory();
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            handleActivityConfigurationChanged((IBinder) msg.obj);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj);
            break;
        case CREATE_BACKUP_AGENT:
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case DESTROY_BACKUP_AGENT:
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            completeRemoveProvider((IContentProvider) msg.obj);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + msg.what);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The major changes between the early and late versions include the introduction of a new logging statement, a change in the type of the ActivityRecord to ActivityClientRecord, and an additional switch case 'SCHEDULE_CRASH'. Therefore, the code change type should be 2 (Exception handling statement changed), 3 (Control dependency change), and 4 (Other statement change).","The introduction of a new switch case 'SCHEDULE_CRASH' might lead to potential different exception handlings and hence a Compatibility Issue type 2. Also, the type change from ActivityRecord to ActivityClientRecord might alter the return value of this function affecting the behavior, leading to Compatibility Issue type 1."
236,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,8,9,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,<android.widget.TextView: InputConnection onCreateInputConnection(EditorInfo)>,0,"{
    if (onCheckIsTextEditor()) {
        if (mInputMethodState == null) {
            mInputMethodState = new InputMethodState();
        }
        outAttrs.inputType = mInputType;
        if (mInputContentType != null) {
            outAttrs.imeOptions = mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mInputContentType.imeActionLabel;
            outAttrs.actionId = mInputContentType.imeActionId;
            outAttrs.extras = mInputContentType.extras;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if (focusSearch(FOCUS_DOWN) != null) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if ((outAttrs.inputType & (InputType.TYPE_MASK_CLASS | InputType.TYPE_TEXT_FLAG_MULTI_LINE)) == (InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = Selection.getSelectionStart(mText);
            outAttrs.initialSelEnd = Selection.getSelectionEnd(mText);
            outAttrs.initialCapsMode = ic.getCursorCapsMode(mInputType);
            return ic;
        }
    }
    return null;
}","{
    if (onCheckIsTextEditor()) {
        if (mInputMethodState == null) {
            mInputMethodState = new InputMethodState();
        }
        outAttrs.inputType = mInputType;
        if (mInputContentType != null) {
            outAttrs.imeOptions = mInputContentType.imeOptions;
            outAttrs.privateImeOptions = mInputContentType.privateImeOptions;
            outAttrs.actionLabel = mInputContentType.imeActionLabel;
            outAttrs.actionId = mInputContentType.imeActionId;
            outAttrs.extras = mInputContentType.extras;
        } else {
            outAttrs.imeOptions = EditorInfo.IME_NULL;
        }
        if ((outAttrs.imeOptions & EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) {
            if (focusSearch(FOCUS_DOWN) != null) {
                // An action has not been set, but the enter key will move to
                // the next focus, so set the action to that.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT;
            } else {
                // An action has not been set, and there is no focus to move
                // to, so let's just supply a ""done"" action.
                outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE;
            }
            if (!shouldAdvanceFocusOnEnter()) {
                outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
            }
        }
        if ((outAttrs.inputType & (InputType.TYPE_MASK_CLASS | InputType.TYPE_TEXT_FLAG_MULTI_LINE)) == (InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE)) {
            // Multi-line text editors should always show an enter key.
            outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION;
        }
        outAttrs.hintText = mHint;
        if (mText instanceof Editable) {
            InputConnection ic = new EditableInputConnection(this);
            outAttrs.initialSelStart = getSelectionStart();
            outAttrs.initialSelEnd = getSelectionEnd();
            outAttrs.initialCapsMode = ic.getCursorCapsMode(mInputType);
            return ic;
        }
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"In the given API, two lines of code outAttrs.initialSelStart = getSelectionStart(); and outAttrs.initialSelEnd = getSelectionEnd(); are changed from Selection.getSelectionStart(mText) and Selection.getSelectionEnd(mText) compared to the previous version code. The change type is 4, 'Other statement changed'.","The getSelectionStart() and getSelectionEnd() may return a different value from Selection.getSelectionStart(mText) and Selection.getSelectionEnd(mText) respectively and could affect the returned InputConnection object from this method in the newer version, which characterizes 'Compatibility issues caused by potential different return values or types' - type 1 CI."
238,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,8,9,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,0,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = ViewRoot.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    updateSurface(false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = ViewRoot.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    updateSurface(false, false, false);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,The function call updateSurface() at the last but one line in the Early_Implementation got a new boolean parameter in the Late_Implementation so the code change type is 4.,"The boolean parameter of the updateSurface() function might change the behavior of the function, which could lead to a different return, resulting in the Compatibility Issue of type 1."
239,"<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>",8,9,"<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>","<android.database.sqlite.SQLiteDatabase: void execSQL(String,Object[])>",0,"{
    if (bindArgs == null) {
        throw new IllegalArgumentException(""Empty bindArgs"");
    }
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql);
        if (bindArgs != null) {
            int numArgs = bindArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, bindArgs[i]);
            }
        }
        statement.execute();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
    logTimeStat(sql, timeStart);
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    if (bindArgs == null) {
        throw new IllegalArgumentException(""Empty bindArgs"");
    }
    long timeStart = SystemClock.uptimeMillis();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql);
        if (bindArgs != null) {
            int numArgs = bindArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, bindArgs[i]);
            }
        }
        statement.execute();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
    logTimeStat(sql, timeStart);
}",1,"/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock,
 *
 * @param sql
 * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
 * @throws SQLException If the SQL string is invalid for some reason
 */
","/**
 * Execute a single SQL statement that is not a query. For example, CREATE
 * TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not
 * supported. it takes a write lock,
 *
 * @param sql
 * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.
 * @throws SQLException If the SQL string is invalid for some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement ""BlockGuard.getThreadPolicy().onWriteToDisk();"" is added at the beginning of the implementation which isn't related to return statement, control dependency or exception handling, so the code change type is 4.","The new statement introduced does not affect the behavioral results of the method, hence it doesn't cause a Compatibility Issue."
240,<android.widget.AbsListView.FlingRunnable: void run()>,8,9,<android.widget.AbsListView.FlingRunnable: void run()>,<android.widget.AbsListView.FlingRunnable: void run()>,0,"{
    switch(mTouchMode) {
        default:
            return;
        case TOUCH_MODE_FLING:
            {
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final Scroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                final boolean atEnd = trackMotionScroll(delta, delta);
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                    }
                }
                break;
            }
    }
}","{
    switch(mTouchMode) {
        default:
            return;
        case TOUCH_MODE_FLING:
            {
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final OverScroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                // Check to see if we have bumped into the scroll limit
                View motionView = getChildAt(mMotionPosition - mFirstPosition);
                int oldTop = 0;
                if (motionView != null) {
                    oldTop = motionView.getTop();
                }
                final boolean atEnd = trackMotionScroll(delta, delta);
                if (atEnd) {
                    if (motionView != null) {
                        // Tweak the scroll for how far we overshot
                        int overshoot = -(delta - (motionView.getTop() - oldTop));
                        overScrollBy(0, overshoot, 0, mScrollY, 0, 0, 0, mOverflingDistance, false);
                    }
                    if (more) {
                        edgeReached(delta);
                    }
                    break;
                }
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                    }
                }
                break;
            }
        case TOUCH_MODE_OVERFLING:
            {
                final OverScroller scroller = mScroller;
                if (scroller.computeScrollOffset()) {
                    final int scrollY = mScrollY;
                    final int deltaY = scroller.getCurrY() - scrollY;
                    if (overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, mOverflingDistance, false)) {
                        startSpringback();
                    } else {
                        invalidate();
                        post(this);
                    }
                } else {
                    endFling();
                }
                break;
            }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The change involves the modification of the control statement 'switch', and other statement changes like modifying types of the object 'scroller' from Scroller to OverScroller, and adding new statement blocks, so the code change type is 3,4,5.","The changes in control statements could potentially lead to different executions of the API, especially with the modifications in the invocation of methods on 'scroller' object due to type changes, thus the CI type is 1."
241,"<android.app.ContextImpl.SharedPreferencesImpl: Map<String, ?> getAll()>",8,9,"<android.app.ContextImpl.SharedPreferencesImpl: Map<String, ?> getAll()>","<android.app.ContextImpl.SharedPreferencesImpl: Map<String, ?> getAll()>",0,"{
    synchronized (this) {
        // noinspection unchecked
        return new HashMap(mMap);
    }
}","{
    synchronized (this) {
        // noinspection unchecked
        return new HashMap<String, Object>(mMap);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The method of creating HashMap instance in the return statement changed from 'new HashMap(mMap)' to 'new HashMap<String, Object>(mMap)', which is a change of other statement and not classified into 1,2,3. So the code change type is 4.","This modification potentially affects the type of object that is returned by this method which could potentially lead to a different value or type to be returned hence, the CI type is 1."
242,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhotos(List<ContentValues>)>,8,9,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhotos(List<ContentValues>)>,<android.pim.vcard.VCardBuilder: VCardBuilder appendPhotos(List<ContentValues>)>,0,"{
    if (contentValuesList != null) {
        for (ContentValues contentValues : contentValuesList) {
            if (contentValues == null) {
                continue;
            }
            byte[] data = contentValues.getAsByteArray(Photo.PHOTO);
            if (data == null) {
                continue;
            }
            final String photoType = VCardUtils.guessImageType(data);
            if (photoType == null) {
                Log.d(LOG_TAG, ""Unknown photo type. Ignored."");
                continue;
            }
            final String photoString = new String(Base64.encodeBase64(data));
            if (!TextUtils.isEmpty(photoString)) {
                appendPhotoLine(photoString, photoType);
            }
        }
    }
    return this;
}","{
    if (contentValuesList != null) {
        for (ContentValues contentValues : contentValuesList) {
            if (contentValues == null) {
                continue;
            }
            byte[] data = contentValues.getAsByteArray(Photo.PHOTO);
            if (data == null) {
                continue;
            }
            final String photoType = VCardUtils.guessImageType(data);
            if (photoType == null) {
                Log.d(LOG_TAG, ""Unknown photo type. Ignored."");
                continue;
            }
            // TODO: check this works fine.
            final String photoString = new String(Base64.encode(data, Base64.NO_WRAP));
            if (!TextUtils.isEmpty(photoString)) {
                appendPhotoLine(photoString, photoType);
            }
        }
    }
    return this;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The statement calling the 'Base64.encodeBase64(data)' in early version has been replaced by 'Base64.encode(data, Base64.NO_WRAP)' in later version, so the code change type is 4,5 .","This change will not cause the API to return a different value or throw a different exception, hence, it does not cause a Compatibility Issue."
245,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",8,9,"<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>","<android.database.sqlite.SQLiteDatabase: int delete(String,String,String[])>",0,"{
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"));
        if (whereArgs != null) {
            int numArgs = whereArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, whereArgs[i]);
            }
        }
        statement.execute();
        return lastChangeCount();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(""DELETE FROM "" + table + (!TextUtils.isEmpty(whereClause) ? "" WHERE "" + whereClause : """"));
        if (whereArgs != null) {
            int numArgs = whereArgs.length;
            for (int i = 0; i < numArgs; i++) {
                DatabaseUtils.bindObjectToProgram(statement, i + 1, whereArgs[i]);
            }
        }
        statement.execute();
        return lastChangeCount();
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}",1,"/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
","/**
 * Convenience method for deleting rows in the database.
 *
 * @param table the table to delete from
 * @param whereClause the optional WHERE clause to apply when deleting.
 * Passing null will delete all rows.
 * @return the number of rows affected if a whereClause is passed in, 0
 * otherwise. To remove all rows and get a count pass ""1"" as the
 * whereClause.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new statement 'BlockGuard.getThreadPolicy().onWriteToDisk();' has been added in the late version which is not a control dependency, return statement or exception handling statement. Therefore, the code change type is 4.","The addition of 'BlockGuard.getThreadPolicy().onWriteToDisk();' does not cause the API to return a different variable or throw a different exception. Thus, no Compatibility Issue exists. CI type is 0."
247,<android.view.KeyEvent: boolean isSystem()>,8,9,<android.view.KeyEvent: boolean isSystem()>,<android.view.KeyEvent: boolean isSystem()>,0,"{
    switch(mKeyCode) {
        case KEYCODE_MENU:
        case KEYCODE_SOFT_RIGHT:
        case KEYCODE_HOME:
        case KEYCODE_BACK:
        case KEYCODE_CALL:
        case KEYCODE_ENDCALL:
        case KEYCODE_VOLUME_UP:
        case KEYCODE_VOLUME_DOWN:
        case KEYCODE_MUTE:
        case KEYCODE_POWER:
        case KEYCODE_HEADSETHOOK:
        case KEYCODE_MEDIA_PLAY_PAUSE:
        case KEYCODE_MEDIA_STOP:
        case KEYCODE_MEDIA_NEXT:
        case KEYCODE_MEDIA_PREVIOUS:
        case KEYCODE_MEDIA_REWIND:
        case KEYCODE_MEDIA_FAST_FORWARD:
        case KEYCODE_CAMERA:
        case KEYCODE_FOCUS:
        case KEYCODE_SEARCH:
            return true;
        default:
            return false;
    }
}","{
    return native_isSystemKey(mKeyCode);
}",1,"/**
 * Is this a system key?  System keys can not be used for menu shortcuts.
 *
 * TODO: this information should come from a table somewhere.
 * TODO: should the dpad keys be here?  arguably, because they also shouldn't be menu shortcuts
 */
","/**
 * Is this a system key?  System keys can not be used for menu shortcuts.
 *
 * TODO: this information should come from a table somewhere.
 * TODO: should the dpad keys be here?  arguably, because they also shouldn't be menu shortcuts
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The switch case statement has been replaced by the function native_isSystemKey(mKeyCode), which directly returns a value. There have been additions of a new API method native_isSystemKey and removal of the old statements, making the code change type 1,4.","The replacement of the switch case with a native function results in a potential change in the return values of the API, hence classifying the CI type as 1."
249,<android.widget.CursorTreeAdapter.MyCursorHelper: void deactivate()>,8,9,<android.widget.CursorTreeAdapter.MyCursorHelper: void deactivate()>,<android.widget.CursorTreeAdapter.MyCursorHelper: void deactivate()>,0,"{
    if (mCursor == null) {
        return;
    }
    mCursor.unregisterContentObserver(mContentObserver);
    mCursor.unregisterDataSetObserver(mDataSetObserver);
    mCursor.deactivate();
    mCursor = null;
}","{
    if (mCursor == null) {
        return;
    }
    mCursor.unregisterContentObserver(mContentObserver);
    mCursor.unregisterDataSetObserver(mDataSetObserver);
    mCursor.close();
    mCursor = null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The statement ""mCursor.deactivate();"" in the early version has changed to ""mCursor.close();"" in the late version. Thus, the change types are 1 (Return statement changed) and 5 (Dependent API changed).","Given the change ""mCursor.deactivate();"" to ""mCursor.close();"", these two methods may behave differently and lead to differing outcomes. Thus, this is a compatibility issue caused by a potential difference in return values or types (CI type 1)."
250,<android.view.KeyEvent: String toString()>,8,9,<android.view.KeyEvent: String toString()>,<android.view.KeyEvent: String toString()>,0,"{
    return ""KeyEvent{action="" + mAction + "" code="" + mKeyCode + "" repeat="" + mRepeatCount + "" meta="" + mMetaState + "" scancode="" + mScancode + "" mFlags="" + mFlags + ""}"";
}","{
    return ""KeyEvent{action="" + mAction + "" code="" + mKeyCode + "" repeat="" + mRepeatCount + "" meta="" + mMetaState + "" scancode="" + mScanCode + "" mFlags="" + mFlags + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The spell of 'mScancode' changed to 'mScanCode', which results in a different String output.","Due to the different value returned in the later version (because of the spelling change), the API behavior can be considered as changed, hence CI type 1."
252,<android.database.sqlite.SQLiteStatement: void execute()>,8,9,<android.database.sqlite.SQLiteStatement: void execute()>,<android.database.sqlite.SQLiteStatement: void execute()>,0,"{
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    if (!mDatabase.isOpen()) {
        throw new IllegalStateException(""database "" + mDatabase.getPath() + "" already closed"");
    }
    long timeStart = SystemClock.uptimeMillis();
    mDatabase.lock();
    acquireReference();
    try {
        native_execute();
        mDatabase.logTimeStat(mSql, timeStart);
    } finally {
        releaseReference();
        mDatabase.unlock();
    }
}",1,"/**
 * Execute this SQL statement, if it is not a query. For example,
 * CREATE TABLE, DELTE, INSERT, etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement, if it is not a query. For example,
 * CREATE TABLE, DELTE, INSERT, etc.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,2,"There is a new statement being added in the beginning of the late version (BlockGuard.getThreadPolicy().onWriteToDisk();), so the code change type is 4.","The new added statement onWriteToDisk() can lead to the DiskWriteViolation exception, so the CI type is 2."
253,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",8,9,"<android.os.MessageQueue: boolean enqueueMessage(Message,long)>","<android.os.MessageQueue: boolean enqueueMessage(Message,long)>",0,"{
    if (msg.when != 0) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null && !mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit"");
    }
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        } else if (msg.target == null) {
            mQuiting = true;
        }
        msg.when = when;
        // Log.d(""MessageQueue"", ""Enqueing: "" + msg);
        Message p = mMessages;
        if (p == null || when == 0 || when < p.when) {
            msg.next = p;
            mMessages = msg;
            this.notify();
        } else {
            Message prev = null;
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
            msg.next = prev.next;
            prev.next = msg;
            this.notify();
        }
    }
    return true;
}","{
    if (msg.when != 0) {
        throw new AndroidRuntimeException(msg + "" This message is already in use."");
    }
    if (msg.target == null && !mQuitAllowed) {
        throw new RuntimeException(""Main thread not allowed to quit"");
    }
    final boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(msg.target + "" sending message to a Handler on a dead thread"");
            Log.w(""MessageQueue"", e.getMessage(), e);
            return false;
        } else if (msg.target == null) {
            mQuiting = true;
        }
        msg.when = when;
        // Log.d(""MessageQueue"", ""Enqueing: "" + msg);
        Message p = mMessages;
        if (p == null || when == 0 || when < p.when) {
            msg.next = p;
            mMessages = msg;
            // new head, might need to wake up
            needWake = mBlocked;
        } else {
            Message prev = null;
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
            msg.next = prev.next;
            prev.next = msg;
            // still waiting on head, no need to wake up
            needWake = false;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The statement involving the variable ""needWake"" and an extra native method call ""nativeWake(mPtr)"" have been added, which are categorized as Other statement changed (4) and Control dependency changed (3).","The introduction of the new statements may influence the return statement's execution, as it adds a condition involving waking up threads, introducing possible changes in the behaviour. Hence, it is a Compatibility Issue caused by potential different return values or types (1)."
254,<android.view.VelocityTracker: float getYVelocity()>,8,9,<android.view.VelocityTracker: float getYVelocity()>,<android.view.VelocityTracker: float getYVelocity()>,0,"{
    return mYVelocity[0];
}","{
    Pointer pointer = getPointer(0);
    return pointer != null ? pointer.yVelocity : 0;
}",1,"/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed Y velocity.
 */
","/**
 * Retrieve the last computed Y velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @return The previously computed Y velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has been changed from 'return mYVelocity[0];' to 'return pointer != null ? pointer.yVelocity : 0;', which also involves the change in the dependent API getPointer(0). So, the code change type is 1,5.","The change in return statement can potentially lead to different returned values because different conditions are taken into consideration in the late version, indicating a CI type of 1."
255,<android.webkit.BrowserFrame: void handleMessage(Message)>,8,9,<android.webkit.BrowserFrame: void handleMessage(Message)>,<android.webkit.BrowserFrame: void handleMessage(Message)>,0,"{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.mScheme + uri.mHost;
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_TRIM_CACHE);
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                nativeOrientationChanged(msg.arg1);
                break;
            }
        default:
            break;
    }
}","{
    if (mBlockMessages) {
        return;
    }
    switch(msg.what) {
        case FRAME_COMPLETED:
            {
                if (mSettings.getSavePassword() && hasPasswordField()) {
                    WebHistoryItem item = mCallbackProxy.getBackForwardList().getCurrentItem();
                    if (item != null) {
                        WebAddress uri = new WebAddress(item.getUrl());
                        String schemePlusHost = uri.mScheme + uri.mHost;
                        String[] up = mDatabase.getUsernamePassword(schemePlusHost);
                        if (up != null && up[0] != null) {
                            setUsernamePassword(up[0], up[1]);
                        }
                    }
                }
                WebViewWorker.getHandler().sendEmptyMessage(WebViewWorker.MSG_TRIM_CACHE);
                break;
            }
        case POLICY_FUNCTION:
            {
                nativeCallPolicyFunction(msg.arg1, msg.arg2);
                break;
            }
        case ORIENTATION_CHANGED:
            {
                if (mOrientation != msg.arg1) {
                    mOrientation = msg.arg1;
                    nativeOrientationChanged(msg.arg1);
                }
                break;
            }
        default:
            break;
    }
}",1,"/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
","/**
 * Handle messages posted to us.
 * @param msg The message to handle.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3, 4",1,"In the case ORIENTATION_CHANGED block of the switch statement, a new if condition is introduced along with setting the mOrientation variable. This corresponds to both a control dependency change (3) and other statement change (4).","The introduction of a new if statement and assignment of mOrientation within it could potentially alter the behavior of the API, leading to a different return value depending on the mOrientation and msg values. Hence, there is a compatibility issue due to potentially different return values (1)."
256,<android.hardware.Camera: Camera open()>,8,9,<android.hardware.Camera: Camera open()>,<android.hardware.Camera: Camera open()>,0,"{
    return new Camera();
}","{
    int numberOfCameras = getNumberOfCameras();
    CameraInfo cameraInfo = new CameraInfo();
    for (int i = 0; i < numberOfCameras; i++) {
        getCameraInfo(i, cameraInfo);
        if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
            return new Camera(i);
        }
    }
    return null;
}",1,"/**
 * Returns a new Camera object.
 */
","/**
 * Creates a new Camera object to access the first back-facing camera on the
 * device. If the device does not have a back-facing camera, this returns
 * null.
 * @see #open(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,1,5",1,"The late version of the API introduced new control statements (3) to iterate over the number of cameras and find the one with the attribute of 'CAMERA_FACING_BACK'. In addition, a new return statement 'return null' has been added (1). Also, the parameter of 'Camera' constructor has changed, which suggests a change in the dependent APIs (5).","The modified return statements could lead to two drastically different return types, it could either return a 'Camera' object or 'null' in the late version. Hence, it gives rise to compatibility issues of variable return type and value (1)."
257,"<android.pim.vcard.VCardComposer: boolean init(Uri,String,String[],String)>",8,9,"<android.pim.vcard.VCardComposer: boolean init(Uri,String,String[],String)>","<android.pim.vcard.VCardComposer: boolean init(Uri,String,String[],String)>",0,"{
    if (contentUri == null) {
        return false;
    }
    if (mCareHandlerErrors) {
        List<OneEntryHandler> finishedList = new ArrayList<OneEntryHandler>(mHandlerList.size());
        for (OneEntryHandler handler : mHandlerList) {
            if (!handler.onInit(mContext)) {
                for (OneEntryHandler finished : finishedList) {
                    finished.onTerminate();
                }
                return false;
            }
        }
    } else {
        // Just ignore the false returned from onInit().
        for (OneEntryHandler handler : mHandlerList) {
            handler.onInit(mContext);
        }
    }
    final String[] projection;
    if (Contacts.CONTENT_URI.equals(contentUri) || CONTACTS_TEST_CONTENT_URI.equals(contentUri)) {
        projection = sContactsProjection;
    } else {
        mErrorReason = FAILURE_REASON_UNSUPPORTED_URI;
        return false;
    }
    mCursor = mContentResolver.query(contentUri, projection, selection, selectionArgs, sortOrder);
    if (mCursor == null) {
        mErrorReason = FAILURE_REASON_FAILED_TO_GET_DATABASE_INFO;
        return false;
    }
    if (getCount() == 0 || !mCursor.moveToFirst()) {
        try {
            mCursor.close();
        } catch (SQLiteException e) {
            Log.e(LOG_TAG, ""SQLiteException on Cursor#close(): "" + e.getMessage());
        } finally {
            mCursor = null;
            mErrorReason = FAILURE_REASON_NO_ENTRY;
        }
        return false;
    }
    mIdColumn = mCursor.getColumnIndex(Contacts._ID);
    return true;
}","{
    if (contentUri == null) {
        return false;
    }
    if (mCareHandlerErrors) {
        final List<OneEntryHandler> finishedList = new ArrayList<OneEntryHandler>(mHandlerList.size());
        for (OneEntryHandler handler : mHandlerList) {
            if (!handler.onInit(mContext)) {
                for (OneEntryHandler finished : finishedList) {
                    finished.onTerminate();
                }
                return false;
            }
        }
    } else {
        // Just ignore the false returned from onInit().
        for (OneEntryHandler handler : mHandlerList) {
            handler.onInit(mContext);
        }
    }
    final String[] projection;
    if (Contacts.CONTENT_URI.equals(contentUri) || CONTACTS_TEST_CONTENT_URI.equals(contentUri)) {
        projection = sContactsProjection;
    } else {
        mErrorReason = FAILURE_REASON_UNSUPPORTED_URI;
        return false;
    }
    mCursor = mContentResolver.query(contentUri, projection, selection, selectionArgs, sortOrder);
    if (mCursor == null) {
        mErrorReason = FAILURE_REASON_FAILED_TO_GET_DATABASE_INFO;
        return false;
    }
    if (getCount() == 0 || !mCursor.moveToFirst()) {
        try {
            mCursor.close();
        } catch (SQLiteException e) {
            Log.e(LOG_TAG, ""SQLiteException on Cursor#close(): "" + e.getMessage());
        } finally {
            mCursor = null;
            mErrorReason = FAILURE_REASON_NO_ENTRY;
        }
        return false;
    }
    mIdColumn = mCursor.getColumnIndex(Contacts._ID);
    return true;
}",1,"/**
 * Note that this is unstable interface, may be deleted in the future.
 */
","/**
 * Note that this is unstable interface, may be deleted in the future.
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There seems to be no changes in the method implementation from the early version to the late version. All the operations performed and their sequence remains the same.,"No codes were changed between the two versions, hence no Compatibility Issue arises."
258,<android.app.Activity: void performPause()>,8,9,<android.app.Activity: void performPause()>,<android.app.Activity: void performPause()>,0,"{
    onPause();
}","{
    mCalled = false;
    onPause();
    if (!mCalled && getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.GINGERBREAD) {
        throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onPause()"");
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,2","1,2","In the later version, a conditional statement is introduced and a ""throw new Exception()"" clause is added inside this conditional statement, making the change types 3 and 2.","Because of the added conditional statement (control dependency) and the new ""throw"" statement, the behavior of the API could potentially change, leading to different return values and exception handling. Therefore, the types of compatibility issues are 1 and 2."
259,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",8,9,"<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>","<android.os.Binder: boolean onTransact(int,Parcel,Parcel,int)>",0,"{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                try {
                    fd.close();
                } catch (IOException e) {
                }
            }
        }
        return true;
    }
    return false;
}","{
    if (code == INTERFACE_TRANSACTION) {
        reply.writeString(getInterfaceDescriptor());
        return true;
    } else if (code == DUMP_TRANSACTION) {
        ParcelFileDescriptor fd = data.readFileDescriptor();
        String[] args = data.readStringArray();
        if (fd != null) {
            try {
                dump(fd.getFileDescriptor(), args);
            } finally {
                try {
                    fd.close();
                } catch (IOException e) {
                // swallowed, not propagated back to the caller
                }
            }
        }
        // Write the StrictMode header.
        if (reply != null) {
            reply.writeNoException();
        } else {
            StrictMode.clearGatheredViolations();
        }
        return true;
    }
    return false;
}",1,"/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
","/**
 * Default implementation is a stub that returns false.  You will want
 * to override this to do the appropriate unmarshalling of transactions.
 *
 * <p>If you want to call this, call transact().
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the DUMP_TRANSACTION conditional block, statements to handle reply and StrictMode are added in the late version, so the code change type is 1 and 3.","The added code will alter the returned data in the Parcel reply, leading to potential different return data (even the overall return value may remain consistent - 'true'). Therefore, there is a compatibility issue of type 1."
260,<android.inputmethodservice.ExtractEditText: boolean isFocused()>,8,9,<android.inputmethodservice.ExtractEditText: boolean isFocused()>,<android.inputmethodservice.ExtractEditText: boolean isFocused()>,0,"{
    return this.isEnabled() ? true : false;
}","{
    return this.isEnabled();
}",1,"/**
 * Pretend like this view always has focus, so its
 * highlight and cursor will be displayed.
 */
","/**
 * Pretend like this view always has focus, so its
 * highlight and cursor will be displayed.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"Even though the return statement has simplified from 'return this.isEnabled() ? true : false' to 'return this.isEnabled();', since the return type and value did not change, the type of code change is just 1.","The simplification in the return statement does not change the functional behavior of the method. As such, no compatibility issues are present. Therefore, the CI type is 0."
263,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",8,9,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>","<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",0,"{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
    }
    return cursor;
}","{
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    BlockGuard.getThreadPolicy().onReadFromDisk();
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
    }
    return cursor;
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement ‘BlockGuard.getThreadPolicy().onReadFromDisk();’ that doesn't alter the control flow nor the return statements of the code. Hence, the code change type is 4.","The new statement 'BlockGuard.getThreadPolicy().onReadFromDisk();' doesn't affect the return value or exception handling of the method. Therefore, there is no Compatibility Issue, so CI type is 0."
264,"<android.preference.PreferenceManager: void setDefaultValues(Context,String,int,int,boolean)>",8,9,"<android.preference.PreferenceManager: void setDefaultValues(Context,String,int,int,boolean)>","<android.preference.PreferenceManager: void setDefaultValues(Context,String,int,int,boolean)>",0,"{
    final SharedPreferences defaultValueSp = context.getSharedPreferences(KEY_HAS_SET_DEFAULT_VALUES, Context.MODE_PRIVATE);
    if (readAgain || !defaultValueSp.getBoolean(KEY_HAS_SET_DEFAULT_VALUES, false)) {
        final PreferenceManager pm = new PreferenceManager(context);
        pm.setSharedPreferencesName(sharedPreferencesName);
        pm.setSharedPreferencesMode(sharedPreferencesMode);
        pm.inflateFromResource(context, resId, null);
        defaultValueSp.edit().putBoolean(KEY_HAS_SET_DEFAULT_VALUES, true).commit();
    }
}","{
    final SharedPreferences defaultValueSp = context.getSharedPreferences(KEY_HAS_SET_DEFAULT_VALUES, Context.MODE_PRIVATE);
    if (readAgain || !defaultValueSp.getBoolean(KEY_HAS_SET_DEFAULT_VALUES, false)) {
        final PreferenceManager pm = new PreferenceManager(context);
        pm.setSharedPreferencesName(sharedPreferencesName);
        pm.setSharedPreferencesMode(sharedPreferencesMode);
        pm.inflateFromResource(context, resId, null);
        SharedPreferences.Editor editor = defaultValueSp.edit().putBoolean(KEY_HAS_SET_DEFAULT_VALUES, true);
        try {
            editor.apply();
        } catch (AbstractMethodError unused) {
            // The app injected its own pre-Gingerbread
            // SharedPreferences.Editor implementation without
            // an apply method.
            editor.commit();
        }
    }
}",1,"/**
 * Similar to {@link #setDefaultValues(Context, int, boolean)} but allows
 * the client to provide the filename and mode of the shared preferences
 * file.
 *
 * @see #setDefaultValues(Context, int, boolean)
 * @see #setSharedPreferencesName(String)
 * @see #setSharedPreferencesMode(int)
 */
","/**
 * Similar to {@link #setDefaultValues(Context, int, boolean)} but allows
 * the client to provide the filename and mode of the shared preferences
 * file.
 *
 * @see #setDefaultValues(Context, int, boolean)
 * @see #setSharedPreferencesName(String)
 * @see #setSharedPreferencesMode(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,4",2,"There are two main changes here. First, an exception handling statement has been added, dealing with potential AbstractMethodError. Second, a new statement was created, where an editor object was initialized.","The addition of a new exception handling could potentially change how the function behaves when an exception occurs. Therefore, a Compatibility Issue could arise due to the potential different exception handlings."
265,"<android.hardware.SensorManager: float[] getOrientation(float[],float[])>",8,9,"<android.hardware.SensorManager: float[] getOrientation(float[],float[])>","<android.hardware.SensorManager: float[] getOrientation(float[],float[])>",0,"{
    /*
         * 4x4 (length=16) case:
         *   /  R[ 0]   R[ 1]   R[ 2]   0  \
         *   |  R[ 4]   R[ 5]   R[ 6]   0  |
         *   |  R[ 8]   R[ 9]   R[10]   0  |
         *   \      0       0       0   1  /
         *   
         * 3x3 (length=9) case:
         *   /  R[ 0]   R[ 1]   R[ 2]  \
         *   |  R[ 3]   R[ 4]   R[ 5]  |
         *   \  R[ 6]   R[ 7]   R[ 8]  /
         * 
         */
    if (R.length == 9) {
        values[0] = (float) Math.atan2(R[1], R[4]);
        values[1] = (float) Math.asin(-R[7]);
        values[2] = (float) Math.atan2(-R[6], R[8]);
    } else {
        values[0] = (float) Math.atan2(R[1], R[5]);
        values[1] = (float) Math.asin(-R[9]);
        values[2] = (float) Math.atan2(-R[8], R[10]);
    }
    return values;
}","{
    /*
         * 4x4 (length=16) case:
         *   /  R[ 0]   R[ 1]   R[ 2]   0  \
         *   |  R[ 4]   R[ 5]   R[ 6]   0  |
         *   |  R[ 8]   R[ 9]   R[10]   0  |
         *   \      0       0       0   1  /
         *
         * 3x3 (length=9) case:
         *   /  R[ 0]   R[ 1]   R[ 2]  \
         *   |  R[ 3]   R[ 4]   R[ 5]  |
         *   \  R[ 6]   R[ 7]   R[ 8]  /
         *
         */
    if (R.length == 9) {
        values[0] = (float) Math.atan2(R[1], R[4]);
        values[1] = (float) Math.asin(-R[7]);
        values[2] = (float) Math.atan2(-R[6], R[8]);
    } else {
        values[0] = (float) Math.atan2(R[1], R[5]);
        values[1] = (float) Math.asin(-R[9]);
        values[2] = (float) Math.atan2(-R[8], R[10]);
    }
    return values;
}",1,"/**
 * Computes the device's orientation based on the rotation matrix.
 * <p> When it returns, the array values is filled with the result:
 * <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li>
 * <li>values[1]: <i>pitch</i>, rotation around the X axis.</li>
 * <li>values[2]: <i>roll</i>, rotation around the Y axis.</li>
 * <p>
 * All three angles above are in <b>radians</b> and <b>positive</b> in the
 * <b>counter-clockwise</b> direction.
 *
 * @param R rotation matrix see {@link #getRotationMatrix}.
 * @param values an array of 3 floats to hold the result.
 * @return The array values passed as argument.
 */
","/**
 * Computes the device's orientation based on the rotation matrix.
 * <p>
 * When it returns, the array values is filled with the result:
 * <ul>
 * <li>values[0]: <i>azimuth</i>, rotation around the Z axis.</li>
 * <li>values[1]: <i>pitch</i>, rotation around the X axis.</li>
 * <li>values[2]: <i>roll</i>, rotation around the Y axis.</li>
 * </ul>
 * <p>
 * <center><img src=""../../../images/axis_device.png""
 * alt=""Sensors coordinate-system diagram."" border=""0"" /></center>
 * </p>
 * <p>
 * All three angles above are in <b>radians</b> and <b>positive</b> in the
 * <b>counter-clockwise</b> direction.
 *
 * @param R
 * rotation matrix see {@link #getRotationMatrix}.
 *
 * @param values
 * an array of 3 floats to hold the result.
 *
 * @return The array values passed as argument.
 *
 * @see #getRotationMatrix(float[], float[], float[], float[])
 * @see GeomagneticField
 */
",-1,,,-1,-1,-1,-1,-1,-1,0,0,There is no change at all when comparing the Early_Version to the Late_Version.,"Since there is no change in the API's implementation or annotation, there is no compatibility issue at all."
266,<android.webkit.WebView: void reload()>,8,9,<android.webkit.WebView: void reload()>,<android.webkit.WebView: void reload()>,0,"{
    clearTextEntry(false);
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}","{
    clearHelpers();
    switchOutDrawHistory();
    mWebViewCore.sendMessage(EventHub.RELOAD);
}",1,"/**
 * Reload the current url.
 */
","/**
 * Reload the current url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The statement 'clearTextEntry(false);' was replaced with 'clearHelpers();', which is considered as an other statement change. Therefore, the code change type is 4.","As the change of the implementation will not likely to affect the return values or the exceptions thrown by this void method, there are no compatibility issues."
268,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",8,9,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>","<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",0,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = true;
        } else if (!nativeCursorWantsKeyEvents() && !mShiftIsPressed) {
            setUpSelectXY();
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), true);
            return true;
        }
        if (mShiftIsPressed) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            if (mShiftIsPressed && !nativeFocusIsPlugin()) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode != KeyEvent.KEYCODE_SHIFT_LEFT && keyCode != KeyEvent.KEYCODE_SHIFT_RIGHT) {
        // turn off copy select if a shift-key combo is pressed
        mExtendSelection = mShiftIsPressed = false;
        if (mTouchMode == TOUCH_SELECT_MODE) {
            mTouchMode = TOUCH_INIT_MODE;
        }
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus, and make the focuscontroller active
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_SHIFT_LEFT || keyCode == KeyEvent.KEYCODE_SHIFT_RIGHT) {
        if (nativeFocusIsPlugin()) {
            mShiftIsPressed = true;
        } else if (!nativeCursorWantsKeyEvents() && !mSelectingText) {
            setUpSelect();
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativeFocusIsPlugin()) {
            letPluginHandleNavKey(keyCode, event.getEventTime(), true);
            return true;
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode != KeyEvent.KEYCODE_SHIFT_LEFT && keyCode != KeyEvent.KEYCODE_SHIFT_RIGHT) {
        // turn off copy select if a shift-key combo is pressed
        selectionDone();
        mShiftIsPressed = false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus, and make the focuscontroller active
        mWebViewCore.sendMessage(EventHub.CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition statement in the segment where 'KeyCode' is 'KeyEvent.KEYCODE_SHIFT_LEFT' or 'KeyEvent.KEYCODE_SHIFT_RIGHT' has been changed. Also, some statements inside condition blocks in other parts of the code have changed (e.g., the switch from 'mShiftIsPressed' to 'mSelectingText', the replacement of 'setUpSelectXY()' with 'setUpSelect()', and the introduction of 'selectionDone()' function). Therefore, the change type is categorized as 3, denoting Control dependency change.","Even though the high-level function of the API remains unchanged, the modification to the control dependency of the code might potentially alter the behavior of the code under certain conditions, hence it could make the API return different results. Therefore, the compatibility issue is identified as type 1, pointing towards the potential different return values or types. On the other hand, the API doesn't add or remove any exception handling statement; thus, it's not categorized under type 2 compatibility issue."
269,<android.os.Message: String toString()>,8,9,<android.os.Message: String toString()>,<android.os.Message: String toString()>,0,"{
    StringBuilder b = new StringBuilder();
    b.append(""{ what="");
    b.append(what);
    b.append("" when="");
    b.append(when);
    if (arg1 != 0) {
        b.append("" arg1="");
        b.append(arg1);
    }
    if (arg2 != 0) {
        b.append("" arg2="");
        b.append(arg2);
    }
    if (obj != null) {
        b.append("" obj="");
        b.append(obj);
    }
    b.append("" }"");
    return b.toString();
}","{
    return toString(SystemClock.uptimeMillis());
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The whole method implementation has been completely changed from constructing a string based on certain conditions to simply calling the toString() method of SystemClock. Both return statements and dependent APIs changed (SystemClock.uptimeMillis() API is introduced), so the code change type is 1,5.","The change in the return statement certainly leads to different return values between the two versions, hence a compatibility issue of type 1 exists."
272,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",8,9,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>","<android.webkit.WebView: boolean restorePicture(Bundle,File)>",0,"{
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                final Picture p = Picture.createFromStream(in);
                if (p != null) {
                    // Post a runnable on the main thread to update the
                    // history picture fields.
                    mPrivateHandler.post(new Runnable() {

                        public void run() {
                            restoreHistoryPictureFields(p, copy);
                        }
                    });
                }
                try {
                    in.close();
                } catch (Exception e) {
                // Nothing we can do now.
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}","{
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                try {
                    final Picture p = Picture.createFromStream(in);
                    if (p != null) {
                        // Post a runnable on the main thread to update the
                        // history picture fields.
                        mPrivateHandler.post(new Runnable() {

                            public void run() {
                                restoreHistoryPictureFields(p, copy);
                            }
                        });
                    }
                } finally {
                    try {
                        in.close();
                    } catch (Exception e) {
                    // Nothing we can do now.
                    }
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
","/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3",0,"The control dependency of statement 'final Picture p = Picture.createFromStream(in);' has changed. In the late version, it is within a try-block that wasn't there in the early version. Also, an exception handling statement (a new 'finally' block) has been added. Therefore, the code change type is 2,3.","Despite these code changes, neither the return value nor the exceptions this API throws have been affected, so there is no Compatibility Issue (CI_type is 0)."
273,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",8,9,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>","<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",0,"{
    synchronized (mConstructorArgs) {
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs);
            } else {
                // Temp is the root view that was found in the xml
                View temp = createViewFromTag(name, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        }
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs);
            } else {
                // Temp is the root view that was found in the xml
                View temp = createViewFromTag(name, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"In the code, a new statement 'Context lastContext = (Context) mConstructorArgs[0];' is added, 'finally' statement is introduced, and also there are changes in the control statements. Thus the code changes are of type 3 (Control dependency changed) and 4 (Other statement changed).","The introduced 'finally' block changes the behaviour of the method. Now, this part will always execute regardless if an exception is thrown or not, which could potentially alter the return value and thus, it results in the Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
274,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,8,9,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,<android.widget.TextView: boolean moveCursorToVisibleOffset()>,0,"{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = Selection.getSelectionStart(mText);
    int end = Selection.getSelectionEnd(mText);
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    int newStart = start;
    if (newStart < leftChar) {
        newStart = leftChar;
    } else if (newStart > rightChar) {
        newStart = rightChar;
    }
    if (newStart != start) {
        Selection.setSelection((Spannable) mText, newStart);
        return true;
    }
    return false;
}","{
    if (!(mText instanceof Spannable)) {
        return false;
    }
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if (start != end) {
        return false;
    }
    // First: make sure the line is visible on screen:
    int line = mLayout.getLineForOffset(start);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    final int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int vslack = (bottom - top) / 2;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    final int vs = mScrollY;
    if (top < (vs + vslack)) {
        line = mLayout.getLineForVertical(vs + vslack + (bottom - top));
    } else if (bottom > (vspace + vs - vslack)) {
        line = mLayout.getLineForVertical(vspace + vs - vslack - (bottom - top));
    }
    // Next: make sure the character is visible on screen:
    final int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    final int hs = mScrollX;
    final int leftChar = mLayout.getOffsetForHorizontal(line, hs);
    final int rightChar = mLayout.getOffsetForHorizontal(line, hspace + hs);
    int newStart = start;
    if (newStart < leftChar) {
        newStart = leftChar;
    } else if (newStart > rightChar) {
        newStart = rightChar;
    }
    if (newStart != start) {
        Selection.setSelection((Spannable) mText, newStart);
        return true;
    }
    return false;
}",1,"/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 */
","/**
 * Move the cursor, if needed, so that it is at an offset that is visible
 * to the user.  This will not move the cursor if it represents more than
 * one character (a selection range).  This will only work if the
 * TextView contains spannable text; otherwise it will do nothing.
 *
 * @return True if the cursor was actually moved, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The way to get the 'start' and 'end' variables has changed, which are directly utilized inside the code, so the code change type is 4.","Despite the change in the way 'start' and 'end' values are fetched, the overall behavior of the function remains the same and no exceptions are thrown differently, so no compatibility issue exists."
275,<android.view.MotionEvent: int getHistorySize()>,8,9,<android.view.MotionEvent: int getHistorySize()>,<android.view.MotionEvent: int getHistorySize()>,0,"{
    return mNumSamples - 1;
}","{
    return mLastEventTimeNanoSampleIndex;
}",1,"/**
 * Returns the number of historical points in this event.  These are
 * movements that have occurred between this event and the previous event.
 * This only applies to ACTION_MOVE events -- all other actions will have
 * a size of 0.
 *
 * @return Returns the number of historical points in the event.
 */
","/**
 * Returns the number of historical points in this event.  These are
 * movements that have occurred between this event and the previous event.
 * This only applies to ACTION_MOVE events -- all other actions will have
 * a size of 0.
 *
 * @return Returns the number of historical points in the event.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from 'return mNumSamples - 1;' to 'return mLastEventTimeNanoSampleIndex;', so the code change type is 1.","The change of return statement will make the API potentially return a different value, so the CI type is 1."
276,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,8,9,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,<android.hardware.SensorManager.SensorThread.SensorThreadRunnable: void run()>,0,"{
    // Log.d(TAG, ""entering main sensor thread"");
    final float[] values = new float[3];
    final int[] status = new int[1];
    final long[] timestamp = new long[1];
    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    if (!open()) {
        return;
    }
    synchronized (this) {
        // we've open the driver, we're ready to open the sensors
        mSensorsReady = true;
        this.notify();
    }
    while (true) {
        // wait for an event
        final int sensor = sensors_data_poll(values, status, timestamp);
        int accuracy = status[0];
        synchronized (sListeners) {
            if (sensor == -1 || sListeners.isEmpty()) {
                if (sensor == -1) {
                    // we lost the connection to the event stream. this happens
                    // when the last listener is removed.
                    Log.d(TAG, ""_sensors_data_poll() failed, we bail out."");
                }
                // we have no more listeners or polling failed, terminate the thread
                sensors_data_close();
                mThread = null;
                break;
            }
            final Sensor sensorObject = sHandleToSensor.get(sensor);
            if (sensorObject != null) {
                // report the sensor event to all listeners that
                // care about it.
                final int size = sListeners.size();
                for (int i = 0; i < size; i++) {
                    ListenerDelegate listener = sListeners.get(i);
                    if (listener.hasSensor(sensorObject)) {
                        // this is asynchronous (okay to call
                        // with sListeners lock held).
                        listener.onSensorChangedLocked(sensorObject, values, timestamp, accuracy);
                    }
                }
            }
        }
    }
// Log.d(TAG, ""exiting main sensor thread"");
}","{
    // Log.d(TAG, ""entering main sensor thread"");
    final float[] values = new float[3];
    final int[] status = new int[1];
    final long[] timestamp = new long[1];
    Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    if (!open()) {
        return;
    }
    synchronized (this) {
        // we've open the driver, we're ready to open the sensors
        mSensorsReady = true;
        this.notify();
    }
    while (true) {
        // wait for an event
        final int sensor = sensors_data_poll(sQueue, values, status, timestamp);
        int accuracy = status[0];
        synchronized (sListeners) {
            if (sensor == -1 || sListeners.isEmpty()) {
                // when the last listener is removed or if there is an error
                if (sensor == -1 && !sListeners.isEmpty()) {
                    // log a warning in case of abnormal termination
                    Log.e(TAG, ""_sensors_data_poll() failed, we bail out: sensors="" + sensor);
                }
                // we have no more listeners or polling failed, terminate the thread
                sensors_destroy_queue(sQueue);
                sQueue = 0;
                mThread = null;
                break;
            }
            final Sensor sensorObject = sHandleToSensor.get(sensor);
            if (sensorObject != null) {
                // report the sensor event to all listeners that
                // care about it.
                final int size = sListeners.size();
                for (int i = 0; i < size; i++) {
                    ListenerDelegate listener = sListeners.get(i);
                    if (listener.hasSensor(sensorObject)) {
                        // this is asynchronous (okay to call
                        // with sListeners lock held).
                        listener.onSensorChangedLocked(sensorObject, values, timestamp, accuracy);
                    }
                }
            }
        }
    }
// Log.d(TAG, ""exiting main sensor thread"");
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The method invocation inside the while loop has changed with an extra parameter sQueue, and there are more changes in if conditions inside the synchronized block, including modification of logging and a new method call to sensors_destroy_queue(sQueue). Therefore, the code change type is 1,4,5.","The changed if condition and the new method call can impact the returned values of this method, leading to potential different behaviors. Hence CI type is 1."
277,"<android.webkit.WebView: void moveSelection(float,float)>",8,9,"<android.webkit.WebView: void moveSelection(float,float)>","<android.webkit.WebView: void moveSelection(float,float)>",0,"{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += xRate;
    mSelectY += yRate;
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY), mExtendSelection);
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}","{
    if (mNativeClass == 0)
        return;
    int width = getViewWidth();
    int height = getViewHeight();
    mSelectX += xRate;
    mSelectY += yRate;
    int maxX = width + mScrollX;
    int maxY = height + mScrollY;
    mSelectX = Math.min(maxX, Math.max(mScrollX - SELECT_CURSOR_OFFSET, mSelectX));
    mSelectY = Math.min(maxY, Math.max(mScrollY - SELECT_CURSOR_OFFSET, mSelectY));
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""moveSelection"" + "" mSelectX="" + mSelectX + "" mSelectY="" + mSelectY + "" mScrollX="" + mScrollX + "" mScrollY="" + mScrollY + "" xRate="" + xRate + "" yRate="" + yRate);
    }
    nativeMoveSelection(viewToContentX(mSelectX), viewToContentY(mSelectY));
    int scrollX = mSelectX < mScrollX ? -SELECT_CURSOR_OFFSET : mSelectX > maxX - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    int scrollY = mSelectY < mScrollY ? -SELECT_CURSOR_OFFSET : mSelectY > maxY - SELECT_CURSOR_OFFSET ? SELECT_CURSOR_OFFSET : 0;
    pinScrollBy(scrollX, scrollY, true, 0);
    Rect select = new Rect(mSelectX, mSelectY, mSelectX + 1, mSelectY + 1);
    requestRectangleOnScreen(select);
    invalidate();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"The API method nativeMoveSelection() changed its signature by removal of the third parameter 'mExtendSelection' in the late version, so the code change type is 4.","As the signature of dependent method changed, the behavior of the method may be affected, which may lead to return different values or results when invoking the main method. So the CI type is 1."
279,<com.google.android.mms.pdu.PduParser: PduBody parseParts(ByteArrayInputStream)>,8,9,<com.google.android.mms.pdu.PduParser: PduBody parseParts(ByteArrayInputStream)>,<com.google.android.mms.pdu.PduParser: PduBody parseParts(ByteArrayInputStream)>,0,"{
    if (pduDataStream == null) {
        return null;
    }
    // get the number of parts
    int count = parseUnsignedInt(pduDataStream);
    PduBody body = new PduBody();
    for (int i = 0; i < count; i++) {
        int headerLength = parseUnsignedInt(pduDataStream);
        int dataLength = parseUnsignedInt(pduDataStream);
        PduPart part = new PduPart();
        int startPos = pduDataStream.available();
        if (startPos <= 0) {
            // Invalid part.
            return null;
        }
        /* parse part's content-type */
        HashMap<Integer, Object> map = new HashMap<Integer, Object>();
        byte[] contentType = parseContentType(pduDataStream, map);
        if (null != contentType) {
            part.setContentType(contentType);
        } else {
            // ""*/*""
            part.setContentType((PduContentTypes.contentTypes[0]).getBytes());
        }
        /* get name parameter */
        byte[] name = (byte[]) map.get(PduPart.P_NAME);
        if (null != name) {
            part.setName(name);
        }
        /* get charset parameter */
        Integer charset = (Integer) map.get(PduPart.P_CHARSET);
        if (null != charset) {
            part.setCharset(charset);
        }
        /* parse part's headers */
        int endPos = pduDataStream.available();
        int partHeaderLen = headerLength - (startPos - endPos);
        if (partHeaderLen > 0) {
            if (false == parsePartHeaders(pduDataStream, part, partHeaderLen)) {
                // Parse part header faild.
                return null;
            }
        } else if (partHeaderLen < 0) {
            // Invalid length of content-type.
            return null;
        }
        /* FIXME: check content-id, name, filename and content location,
             * if not set anyone of them, generate a default content-location
             */
        if ((null == part.getContentLocation()) && (null == part.getName()) && (null == part.getFilename()) && (null == part.getContentId())) {
            part.setContentLocation(Long.toOctalString(System.currentTimeMillis()).getBytes());
        }
        /* get part's data */
        if (dataLength > 0) {
            byte[] partData = new byte[dataLength];
            pduDataStream.read(partData, 0, dataLength);
            // Check Content-Transfer-Encoding.
            byte[] partDataEncoding = part.getContentTransferEncoding();
            if (null != partDataEncoding) {
                String encoding = new String(partDataEncoding);
                if (encoding.equalsIgnoreCase(PduPart.P_BASE64)) {
                    // Decode ""base64"" into ""binary"".
                    partData = Base64.decodeBase64(partData);
                } else if (encoding.equalsIgnoreCase(PduPart.P_QUOTED_PRINTABLE)) {
                    // Decode ""quoted-printable"" into ""binary"".
                    partData = QuotedPrintable.decodeQuotedPrintable(partData);
                } else {
                // ""binary"" is the default encoding.
                }
            }
            if (null == partData) {
                log(""Decode part data error!"");
                return null;
            }
            part.setData(partData);
        }
        /* add this part to body */
        if (THE_FIRST_PART == checkPartPosition(part)) {
            /* this is the first part */
            body.addPart(0, part);
        } else {
            /* add the part to the end */
            body.addPart(part);
        }
    }
    return body;
}","{
    if (pduDataStream == null) {
        return null;
    }
    // get the number of parts
    int count = parseUnsignedInt(pduDataStream);
    PduBody body = new PduBody();
    for (int i = 0; i < count; i++) {
        int headerLength = parseUnsignedInt(pduDataStream);
        int dataLength = parseUnsignedInt(pduDataStream);
        PduPart part = new PduPart();
        int startPos = pduDataStream.available();
        if (startPos <= 0) {
            // Invalid part.
            return null;
        }
        /* parse part's content-type */
        HashMap<Integer, Object> map = new HashMap<Integer, Object>();
        byte[] contentType = parseContentType(pduDataStream, map);
        if (null != contentType) {
            part.setContentType(contentType);
        } else {
            // ""*/*""
            part.setContentType((PduContentTypes.contentTypes[0]).getBytes());
        }
        /* get name parameter */
        byte[] name = (byte[]) map.get(PduPart.P_NAME);
        if (null != name) {
            part.setName(name);
        }
        /* get charset parameter */
        Integer charset = (Integer) map.get(PduPart.P_CHARSET);
        if (null != charset) {
            part.setCharset(charset);
        }
        /* parse part's headers */
        int endPos = pduDataStream.available();
        int partHeaderLen = headerLength - (startPos - endPos);
        if (partHeaderLen > 0) {
            if (false == parsePartHeaders(pduDataStream, part, partHeaderLen)) {
                // Parse part header faild.
                return null;
            }
        } else if (partHeaderLen < 0) {
            // Invalid length of content-type.
            return null;
        }
        /* FIXME: check content-id, name, filename and content location,
             * if not set anyone of them, generate a default content-location
             */
        if ((null == part.getContentLocation()) && (null == part.getName()) && (null == part.getFilename()) && (null == part.getContentId())) {
            part.setContentLocation(Long.toOctalString(System.currentTimeMillis()).getBytes());
        }
        /* get part's data */
        if (dataLength > 0) {
            byte[] partData = new byte[dataLength];
            String partContentType = new String(part.getContentType());
            pduDataStream.read(partData, 0, dataLength);
            if (partContentType.equalsIgnoreCase(ContentType.MULTIPART_ALTERNATIVE)) {
                // parse ""multipart/vnd.wap.multipart.alternative"".
                PduBody childBody = parseParts(new ByteArrayInputStream(partData));
                // take the first part of children.
                part = childBody.getPart(0);
            } else {
                // Check Content-Transfer-Encoding.
                byte[] partDataEncoding = part.getContentTransferEncoding();
                if (null != partDataEncoding) {
                    String encoding = new String(partDataEncoding);
                    if (encoding.equalsIgnoreCase(PduPart.P_BASE64)) {
                        // Decode ""base64"" into ""binary"".
                        partData = Base64.decodeBase64(partData);
                    } else if (encoding.equalsIgnoreCase(PduPart.P_QUOTED_PRINTABLE)) {
                        // Decode ""quoted-printable"" into ""binary"".
                        partData = QuotedPrintable.decodeQuotedPrintable(partData);
                    } else {
                    // ""binary"" is the default encoding.
                    }
                }
                if (null == partData) {
                    log(""Decode part data error!"");
                    return null;
                }
                part.setData(partData);
            }
        }
        /* add this part to body */
        if (THE_FIRST_PART == checkPartPosition(part)) {
            /* this is the first part */
            body.addPart(0, part);
        } else {
            /* add the part to the end */
            body.addPart(part);
        }
    }
    return body;
}",1,"/**
 * Parse pdu parts.
 *
 * @param pduDataStream pdu data input stream
 * @return parts in PduBody structure
 */
","/**
 * Parse pdu parts.
 *
 * @param pduDataStream pdu data input stream
 * @return parts in PduBody structure
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"In the late implementation, a new block of 'if' condition statement was added. Inside this new block, the existing 'read' and 'decode' methods have been changed causing the new block to behave differently compared to the early implementation. So, the code change type is 4.","The newly added 'if' block potentially changes the return type by altering how the part data is processed and added to the body. Hence, the CI type is 1."
280,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,8,9,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,<android.bluetooth.BluetoothAdapter: boolean setName(String)>,0,"{
    try {
        return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Set the friendly Bluetooth name of the local Bluetoth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 UTF-8 characters, however
 * many remote devices can only display the first 40 characters, and some
 * may be limited to just 20.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
","/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The control dependency has changed, specifically, a new 'if' condition statement has been added to check if the state is not 'STATE_ON'. Therefore, the code change type is 3.",The added 'if' statement has introduced a new possible scenario where the API could return a 'false' without executing the 'mService.setName(name)'. This potential difference in return value makes the CI type 1.
281,<android.server.BluetoothService.EnableThread: void run()>,8,9,<android.server.BluetoothService.EnableThread: void run()>,<android.server.BluetoothService.EnableThread: void run()>,0,"{
    boolean res = (enableNative() == 0);
    if (res) {
        int retryCount = 2;
        boolean running = false;
        while ((retryCount-- > 0) && !running) {
            mEventLoop.start();
            // it may take a momement for the other thread to do its
            // thing.  Check periodically for a while.
            int pollCount = 5;
            while ((pollCount-- > 0) && !running) {
                if (mEventLoop.isEventLoopRunning()) {
                    running = true;
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
        }
        if (!running) {
            log(""bt EnableThread giving up"");
            res = false;
            disableNative();
        }
    }
    if (res) {
        if (!setupNativeDataNative()) {
            return;
        }
        if (mSaveSetting) {
            persistBluetoothOnSetting(true);
        }
        mIsDiscovering = false;
        mBondState.readAutoPairingData();
        mBondState.loadBondState();
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_REGISTER_SDP_RECORDS, 1, -1), 3000);
        // Log bluetooth on to battery stats.
        long ident = Binder.clearCallingIdentity();
        try {
            mBatteryStats.noteBluetoothOn();
        } catch (RemoteException e) {
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    mEnableThread = null;
    setBluetoothState(res ? BluetoothAdapter.STATE_ON : BluetoothAdapter.STATE_OFF);
    if (res) {
        // Update mode
        String[] propVal = { ""Pairable"", getProperty(""Pairable"") };
        mEventLoop.onPropertyChanged(propVal);
    }
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        disable(false);
    }
}","{
    boolean res = (enableNative() == 0);
    if (res) {
        int retryCount = 2;
        boolean running = false;
        while ((retryCount-- > 0) && !running) {
            mEventLoop.start();
            // it may take a momement for the other thread to do its
            // thing.  Check periodically for a while.
            int pollCount = 5;
            while ((pollCount-- > 0) && !running) {
                if (mEventLoop.isEventLoopRunning()) {
                    running = true;
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
        }
        if (!running) {
            log(""bt EnableThread giving up"");
            res = false;
            disableNative();
        }
    }
    if (res) {
        if (!setupNativeDataNative()) {
            return;
        }
        if (mSaveSetting) {
            persistBluetoothOnSetting(true);
        }
        mIsDiscovering = false;
        mBondState.readAutoPairingData();
        mBondState.loadBondState();
        initProfileState();
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_REGISTER_SDP_RECORDS, 1, -1), 3000);
        // Log bluetooth on to battery stats.
        long ident = Binder.clearCallingIdentity();
        try {
            mBatteryStats.noteBluetoothOn();
        } catch (RemoteException e) {
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    mEnableThread = null;
    setBluetoothState(res ? BluetoothAdapter.STATE_ON : BluetoothAdapter.STATE_OFF);
    if (res) {
        // Update mode
        String[] propVal = { ""Pairable"", getProperty(""Pairable"") };
        mEventLoop.onPropertyChanged(propVal);
    }
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        disable(false);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,1,"There's an extra method call 'initProfileState()' in the late version which doesn't exist in the early version, so the code change type is 4.","The invocation of the new method 'initProfileState()' may potentially lead to a different behaviour of the API in the late version as compared to the early version, therefore the Compatibility Issue type is 1."
282,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,8,9,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false);
                mEngine.doOffsetsChanged();
                if (reportDraw) {
                    try {
                        mEngine.mSession.finishDrawing(mEngine.mWindow);
                    } catch (RemoteException e) {
                    }
                }
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                MotionEvent ev = (MotionEvent) message.obj;
                synchronized (mEngine.mLock) {
                    if (mEngine.mPendingMove == ev) {
                        mEngine.mPendingMove = null;
                    }
                }
                if (DEBUG)
                    Log.v(TAG, ""Delivering touch event: "" + ev);
                mEngine.onTouchEvent(ev);
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"In the switch cases for 'MSG_UPDATE_SURFACE', 'MSG_WINDOW_RESIZED', and 'MSG_TOUCH_EVENT', there are changes in the method parameters, addition of code for new condition handling, and minor code modification, these constitute code change classes 3, 4 and 5.","Because of the changes made in the method parameters or conditional statements, there could be different return results based on the call to 'mEngine.updateSurface()' and the invocation of 'mEngine.onTouchEvent(ev)'. So the CI type is 1."
283,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,8,9,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,0,"{
    final int action = ev.getAction();
    final float xf = ev.getX();
    final float yf = ev.getY();
    final float scrolledXFloat = xf + mScrollX;
    final float scrolledYFloat = yf + mScrollY;
    final Rect frame = mTempRect;
    boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
    if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
            // this is weird, we got a pen down, but we thought it was
            // already down!
            // XXX: We should probably send an ACTION_UP to the current
            // target.
            mMotionTarget = null;
        }
        // intercept
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {
            // reset this event's action (just to protect ourselves)
            ev.setAction(MotionEvent.ACTION_DOWN);
            // We know we want to dispatch the event down, find a child
            // who can handle it, start with the front-most child.
            final int scrolledXInt = (int) scrolledXFloat;
            final int scrolledYInt = (int) scrolledYFloat;
            final View[] children = mChildren;
            final int count = mChildrenCount;
            for (int i = count - 1; i >= 0; i--) {
                final View child = children[i];
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    child.getHitRect(frame);
                    if (frame.contains(scrolledXInt, scrolledYInt)) {
                        // offset the event to the view's coordinate system
                        final float xc = scrolledXFloat - child.mLeft;
                        final float yc = scrolledYFloat - child.mTop;
                        ev.setLocation(xc, yc);
                        child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
                        if (child.dispatchTouchEvent(ev)) {
                            // Event handled, we have a target now.
                            mMotionTarget = child;
                            return true;
                        }
                    // The event didn't get handled, try the next view.
                    // Don't reset the event's location, it's not
                    // necessary here.
                    }
                }
            }
        }
    }
    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL);
    if (isUpOrCancel) {
        // Note, we've already copied the previous state to our local
        // variable, so this takes effect on the next event
        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    }
    // The event wasn't an ACTION_DOWN, dispatch it to our target if
    // we have one.
    final View target = mMotionTarget;
    if (target == null) {
        // We don't have a target, this means we're handling the
        // event as a regular view.
        ev.setLocation(xf, yf);
        if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
            ev.setAction(MotionEvent.ACTION_CANCEL);
            mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        }
        return super.dispatchTouchEvent(ev);
    }
    // events
    if (!disallowIntercept && onInterceptTouchEvent(ev)) {
        final float xc = scrolledXFloat - (float) target.mLeft;
        final float yc = scrolledYFloat - (float) target.mTop;
        mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        ev.setAction(MotionEvent.ACTION_CANCEL);
        ev.setLocation(xc, yc);
        if (!target.dispatchTouchEvent(ev)) {
        // target didn't handle ACTION_CANCEL. not much we can do
        // but they should have.
        }
        // clear the target
        mMotionTarget = null;
        // event to the normal onTouchEvent().
        return true;
    }
    if (isUpOrCancel) {
        mMotionTarget = null;
    }
    // finally offset the event to the target's coordinate system and
    // dispatch the event.
    final float xc = scrolledXFloat - (float) target.mLeft;
    final float yc = scrolledYFloat - (float) target.mTop;
    ev.setLocation(xc, yc);
    if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
        ev.setAction(MotionEvent.ACTION_CANCEL);
        target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        mMotionTarget = null;
    }
    return target.dispatchTouchEvent(ev);
}","{
    if (!onFilterTouchEventForSecurity(ev)) {
        return false;
    }
    final int action = ev.getAction();
    final float xf = ev.getX();
    final float yf = ev.getY();
    final float scrolledXFloat = xf + mScrollX;
    final float scrolledYFloat = yf + mScrollY;
    final Rect frame = mTempRect;
    boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
    if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
            // this is weird, we got a pen down, but we thought it was
            // already down!
            // XXX: We should probably send an ACTION_UP to the current
            // target.
            mMotionTarget = null;
        }
        // intercept
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {
            // reset this event's action (just to protect ourselves)
            ev.setAction(MotionEvent.ACTION_DOWN);
            // We know we want to dispatch the event down, find a child
            // who can handle it, start with the front-most child.
            final int scrolledXInt = (int) scrolledXFloat;
            final int scrolledYInt = (int) scrolledYFloat;
            final View[] children = mChildren;
            final int count = mChildrenCount;
            for (int i = count - 1; i >= 0; i--) {
                final View child = children[i];
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    child.getHitRect(frame);
                    if (frame.contains(scrolledXInt, scrolledYInt)) {
                        // offset the event to the view's coordinate system
                        final float xc = scrolledXFloat - child.mLeft;
                        final float yc = scrolledYFloat - child.mTop;
                        ev.setLocation(xc, yc);
                        child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
                        if (child.dispatchTouchEvent(ev)) {
                            // Event handled, we have a target now.
                            mMotionTarget = child;
                            return true;
                        }
                    // The event didn't get handled, try the next view.
                    // Don't reset the event's location, it's not
                    // necessary here.
                    }
                }
            }
        }
    }
    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL);
    if (isUpOrCancel) {
        // Note, we've already copied the previous state to our local
        // variable, so this takes effect on the next event
        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    }
    // The event wasn't an ACTION_DOWN, dispatch it to our target if
    // we have one.
    final View target = mMotionTarget;
    if (target == null) {
        // We don't have a target, this means we're handling the
        // event as a regular view.
        ev.setLocation(xf, yf);
        if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
            ev.setAction(MotionEvent.ACTION_CANCEL);
            mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        }
        return super.dispatchTouchEvent(ev);
    }
    // events
    if (!disallowIntercept && onInterceptTouchEvent(ev)) {
        final float xc = scrolledXFloat - (float) target.mLeft;
        final float yc = scrolledYFloat - (float) target.mTop;
        mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        ev.setAction(MotionEvent.ACTION_CANCEL);
        ev.setLocation(xc, yc);
        if (!target.dispatchTouchEvent(ev)) {
        // target didn't handle ACTION_CANCEL. not much we can do
        // but they should have.
        }
        // clear the target
        mMotionTarget = null;
        // event to the normal onTouchEvent().
        return true;
    }
    if (isUpOrCancel) {
        mMotionTarget = null;
    }
    // finally offset the event to the target's coordinate system and
    // dispatch the event.
    final float xc = scrolledXFloat - (float) target.mLeft;
    final float yc = scrolledYFloat - (float) target.mTop;
    ev.setLocation(xc, yc);
    if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {
        ev.setAction(MotionEvent.ACTION_CANCEL);
        target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;
        mMotionTarget = null;
    }
    return target.dispatchTouchEvent(ev);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"Other code statement ""if (!onFilterTouchEventForSecurity(ev)) { return false; }"" has been introduced and the return statement changed, so the code change type is 1,4.","Due to the added statement, the API could potentially return a different value in the later version when onFilterTouchEventForSecurity(ev) is false, thus generating compatibility issue type 1."
284,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,8,9,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,0,"{
    if (mIME != null) {
        if (mIME.onExtractTextContextMenuItem(id)) {
            return true;
        }
    }
    return super.onTextContextMenuItem(id);
}","{
    // Horrible hack: select word option has to be handled by original view to work.
    if (mIME != null && id != android.R.id.startSelectingText) {
        if (mIME.onExtractTextContextMenuItem(id)) {
            return true;
        }
    }
    return super.onTextContextMenuItem(id);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The control dependency 'if' condition has changed (an additional condition 'id != android.R.id.startSelectingText' has added), so the change type is 3.","Due to the added condition in 'if', the execution of 'mIME.onExtractTextContextMenuItem(id)' is affected, which could influence the return value of the API, thus the CI type is 1."
285,<android.os.MessageQueue: Message next()>,8,9,<android.os.MessageQueue: Message next()>,<android.os.MessageQueue: Message next()>,0,"{
    boolean tryIdle = true;
    while (true) {
        long now;
        Object[] idlers = null;
        // Try to retrieve the next message, returning if found.
        synchronized (this) {
            now = SystemClock.uptimeMillis();
            Message msg = pullNextLocked(now);
            if (msg != null)
                return msg;
            if (tryIdle && mIdleHandlers.size() > 0) {
                idlers = mIdleHandlers.toArray();
            }
        }
        // There was no message so we are going to wait...  but first,
        // if there are any idle handlers let them know.
        boolean didIdle = false;
        if (idlers != null) {
            for (Object idler : idlers) {
                boolean keep = false;
                try {
                    didIdle = true;
                    keep = ((IdleHandler) idler).queueIdle();
                } catch (Throwable t) {
                    Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
                }
                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
        }
        // delivered...  so go back and look again for a pending message.
        if (didIdle) {
            tryIdle = false;
            continue;
        }
        synchronized (this) {
            // No messages, nobody to tell about it...  time to wait!
            try {
                if (mMessages != null) {
                    if (mMessages.when - now > 0) {
                        Binder.flushPendingCommands();
                        this.wait(mMessages.when - now);
                    }
                } else {
                    Binder.flushPendingCommands();
                    this.wait();
                }
            } catch (InterruptedException e) {
            }
        }
    }
}","{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            final Message msg = mMessages;
            if (msg != null) {
                final long when = msg.when;
                if (now >= when) {
                    mBlocked = false;
                    mMessages = msg.next;
                    msg.next = null;
                    if (Config.LOGV)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    return msg;
                } else {
                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
                }
            } else {
                nextPollTimeoutMillis = -1;
            }
            // If first time, then get the number of idlers to run.
            if (pendingIdleHandlerCount < 0) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount == 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The whole method structure has been rewritten with changes in variables, control statements and how messages get processed and returned, so the code change type is 3 and 4.","Since the mechanism of returning message and control statements has been changed, these can affect the output of the method in different conditions. The result of calling this method could potentially be different. So, it belongs to CI type 1."
286,<android.webkit.JWebCoreJavaBridge: void setActiveWebView(WebView)>,8,9,<android.webkit.JWebCoreJavaBridge: void setActiveWebView(WebView)>,<android.webkit.JWebCoreJavaBridge: void setActiveWebView(WebView)>,0,"{
    if (mCurrentMainWebView != null) {
        // it is possible if there is a sub-WebView. Do nothing.
        return;
    }
    mCurrentMainWebView = webview;
}","{
    if (sCurrentMainWebView.get() != null) {
        // it is possible if there is a sub-WebView. Do nothing.
        return;
    }
    sCurrentMainWebView = new WeakReference<WebView>(webview);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",0,"The if-condition statement has changed from checking 'mCurrentMainWebView' to checking 'sCurrentMainWebView.get()', and also the assignment statement also changed, so the change type is 1,4.","Although the assignment statement and the if-condition statement have changed, both versions of the code return nothing and the difference in state changes does not introduce a compatibility issue. So, there is no compatibility issue, and the CI type is 0."
287,<android.pim.vcard.VCardComposer: int getCount()>,8,9,<android.pim.vcard.VCardComposer: int getCount()>,<android.pim.vcard.VCardComposer: int getCount()>,0,"{
    if (mCursor == null) {
        return 0;
    }
    return mCursor.getCount();
}","{
    if (mCursor == null) {
        Log.w(LOG_TAG, ""This object is not ready yet."");
        return 0;
    }
    return mCursor.getCount();
}",1,,"/**
 * @return returns the number of available entities. The return value is undefined
 * when this object is not ready yet (typically when {{@link #init()} is not called
 * or when {@link #terminate()} is already called).
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"An additional log message ""Log.w(LOG_TAG, ""This object is not ready yet."");"" has been added between the condition check ""if (mCursor == null)"" and return statement ""return 0;"", thus, the code change type is 4 (Other statement changed).","Although there's been an addition of a log message, it doesn't change the functional behavior of the API, neither the return value of the function nor the exceptions potentially thrown by the function are affected, thus, no Compatibility Issue exists, CI type is 0."
288,"<android.os.DropBoxManager: void addData(String,byte[],int)>",8,9,"<android.os.DropBoxManager: void addData(String,byte[],int)>","<android.os.DropBoxManager: void addData(String,byte[],int)>",0,"{
    if (data == null)
        throw new NullPointerException();
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
    }
}","{
    if (data == null)
        throw new NullPointerException(""data == null"");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
    }
}",1,"/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
","/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */
",-1,,,-1,-1,-1,-1,-1,-1,2,2,"The exception statement changed from throwing a general NullPointerException() to throwing a specific NullPointerException(""data == null""), therefore, the code change type is 2.","This change in exception handling may lead the application to process the exception differently, which could cause a compatibility issue. Therefore, the CI type is 2."
289,<android.view.VelocityTracker: float getXVelocity(int)>,8,9,<android.view.VelocityTracker: float getXVelocity(int)>,<android.view.VelocityTracker: float getXVelocity(int)>,0,"{
    return mXVelocity[id];
}","{
    Pointer pointer = getPointer(id);
    return pointer != null ? pointer.xVelocity : 0;
}",1,"/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @param id Which pointer's velocity to return.
 * @return The previously computed X velocity.
 */
","/**
 * Retrieve the last computed X velocity.  You must first call
 * {@link #computeCurrentVelocity(int)} before calling this function.
 *
 * @param id Which pointer's velocity to return.
 * @return The previously computed X velocity.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has been completely replaced, and the code to retrieve the required value (getXVelocity) has been changed, which forms a change of type 1,4.","Since the return statement has been changed, the value returned by getXVelocity may be different in the late version, and thus the CI is of type 1."
291,<android.app.ContextImpl: Object getSystemService(String)>,8,9,<android.app.ContextImpl: Object getSystemService(String)>,<android.app.ContextImpl: Object getSystemService(String)>,0,"{
    if (WINDOW_SERVICE.equals(name)) {
        return WindowManagerImpl.getDefault();
    } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        synchronized (mSync) {
            LayoutInflater inflater = mLayoutInflater;
            if (inflater != null) {
                return inflater;
            }
            mLayoutInflater = inflater = PolicyManager.makeNewLayoutInflater(getOuterContext());
            return inflater;
        }
    } else if (ACTIVITY_SERVICE.equals(name)) {
        return getActivityManager();
    } else if (INPUT_METHOD_SERVICE.equals(name)) {
        return InputMethodManager.getInstance(this);
    } else if (ALARM_SERVICE.equals(name)) {
        return getAlarmManager();
    } else if (ACCOUNT_SERVICE.equals(name)) {
        return getAccountManager();
    } else if (POWER_SERVICE.equals(name)) {
        return getPowerManager();
    } else if (CONNECTIVITY_SERVICE.equals(name)) {
        return getConnectivityManager();
    } else if (THROTTLE_SERVICE.equals(name)) {
        return getThrottleManager();
    } else if (WIFI_SERVICE.equals(name)) {
        return getWifiManager();
    } else if (NOTIFICATION_SERVICE.equals(name)) {
        return getNotificationManager();
    } else if (KEYGUARD_SERVICE.equals(name)) {
        return new KeyguardManager();
    } else if (ACCESSIBILITY_SERVICE.equals(name)) {
        return AccessibilityManager.getInstance(this);
    } else if (LOCATION_SERVICE.equals(name)) {
        return getLocationManager();
    } else if (SEARCH_SERVICE.equals(name)) {
        return getSearchManager();
    } else if (SENSOR_SERVICE.equals(name)) {
        return getSensorManager();
    } else if (STORAGE_SERVICE.equals(name)) {
        return getStorageManager();
    } else if (VIBRATOR_SERVICE.equals(name)) {
        return getVibrator();
    } else if (STATUS_BAR_SERVICE.equals(name)) {
        synchronized (mSync) {
            if (mStatusBarManager == null) {
                mStatusBarManager = new StatusBarManager(getOuterContext());
            }
            return mStatusBarManager;
        }
    } else if (AUDIO_SERVICE.equals(name)) {
        return getAudioManager();
    } else if (TELEPHONY_SERVICE.equals(name)) {
        return getTelephonyManager();
    } else if (CLIPBOARD_SERVICE.equals(name)) {
        return getClipboardManager();
    } else if (WALLPAPER_SERVICE.equals(name)) {
        return getWallpaperManager();
    } else if (DROPBOX_SERVICE.equals(name)) {
        return getDropBoxManager();
    } else if (DEVICE_POLICY_SERVICE.equals(name)) {
        return getDevicePolicyManager();
    } else if (UI_MODE_SERVICE.equals(name)) {
        return getUiModeManager();
    }
    return null;
}","{
    if (WINDOW_SERVICE.equals(name)) {
        return WindowManagerImpl.getDefault();
    } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        synchronized (mSync) {
            LayoutInflater inflater = mLayoutInflater;
            if (inflater != null) {
                return inflater;
            }
            mLayoutInflater = inflater = PolicyManager.makeNewLayoutInflater(getOuterContext());
            return inflater;
        }
    } else if (ACTIVITY_SERVICE.equals(name)) {
        return getActivityManager();
    } else if (INPUT_METHOD_SERVICE.equals(name)) {
        return InputMethodManager.getInstance(this);
    } else if (ALARM_SERVICE.equals(name)) {
        return getAlarmManager();
    } else if (ACCOUNT_SERVICE.equals(name)) {
        return getAccountManager();
    } else if (POWER_SERVICE.equals(name)) {
        return getPowerManager();
    } else if (CONNECTIVITY_SERVICE.equals(name)) {
        return getConnectivityManager();
    } else if (THROTTLE_SERVICE.equals(name)) {
        return getThrottleManager();
    } else if (WIFI_SERVICE.equals(name)) {
        return getWifiManager();
    } else if (NOTIFICATION_SERVICE.equals(name)) {
        return getNotificationManager();
    } else if (KEYGUARD_SERVICE.equals(name)) {
        return new KeyguardManager();
    } else if (ACCESSIBILITY_SERVICE.equals(name)) {
        return AccessibilityManager.getInstance(this);
    } else if (LOCATION_SERVICE.equals(name)) {
        return getLocationManager();
    } else if (SEARCH_SERVICE.equals(name)) {
        return getSearchManager();
    } else if (SENSOR_SERVICE.equals(name)) {
        return getSensorManager();
    } else if (STORAGE_SERVICE.equals(name)) {
        return getStorageManager();
    } else if (VIBRATOR_SERVICE.equals(name)) {
        return getVibrator();
    } else if (STATUS_BAR_SERVICE.equals(name)) {
        synchronized (mSync) {
            if (mStatusBarManager == null) {
                mStatusBarManager = new StatusBarManager(getOuterContext());
            }
            return mStatusBarManager;
        }
    } else if (AUDIO_SERVICE.equals(name)) {
        return getAudioManager();
    } else if (TELEPHONY_SERVICE.equals(name)) {
        return getTelephonyManager();
    } else if (CLIPBOARD_SERVICE.equals(name)) {
        return getClipboardManager();
    } else if (WALLPAPER_SERVICE.equals(name)) {
        return getWallpaperManager();
    } else if (DROPBOX_SERVICE.equals(name)) {
        return getDropBoxManager();
    } else if (DEVICE_POLICY_SERVICE.equals(name)) {
        return getDevicePolicyManager();
    } else if (UI_MODE_SERVICE.equals(name)) {
        return getUiModeManager();
    } else if (DOWNLOAD_SERVICE.equals(name)) {
        return getDownloadManager();
    }
    return null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"A new if statement (if (DOWNLOAD_SERVICE.equals(name))) has been introduced, so the code change type is 4.","As a new if statement has been introduced, the return value of the method can potentially change. Hence, the CI type is 1."
292,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,8,9,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,<android.appwidget.AppWidgetHostView: void updateAppWidget(RemoteViews)>,0,"{
    updateAppWidget(remoteViews, 0);
}","{
    if (LOGD)
        Log.d(TAG, ""updateAppWidget called mOld="" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, ""was able to recycled existing layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this);
                if (LOGD)
                    Log.d(TAG, ""had to inflate new layout"");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, ""updateAppWidget couldn't find any view, using error view"", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}",1,"/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
","/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation of the method changed completely - from a single statement invoking another method to a comprehensive set of instructions performing various tasks. This includes changes in control dependencies, return statements (addition of return; statements) and introduction of other different statements. So, the change type is 1,3,4.","The extensive changes can influence the behaviour of this method, including potentially returning different values (e.g., in case of exceptions or certain conditions not being fulfilled), hence, the CI type is 1."
293,<android.view.MotionEvent: float getY(int)>,8,9,<android.view.MotionEvent: float getY(int)>,<android.view.MotionEvent: float getY(int)>,0,"{
    return mDataSamples[(pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_Y];
}","{
    return mDataSamples[mLastDataSampleIndex + pointerIndex * NUM_SAMPLE_DATA + SAMPLE_Y] + mYOffset;
}",1,"/**
 * Returns the Y coordinate of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
","/**
 * Returns the Y coordinate of this event for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * Whole numbers are pixels; the
 * value may have a fraction for input devices that are sub-pixel precise.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is changed from returning just indexed mDataSamples to adding some extra logic and also using mYOffset variable. Therefore, code change type is 1.","As the return statement has jumped from simply returning indexed data to one that also includes additional logic and uses an extra variable. Therefore, this will lead to potentially different types or values being returned and hence, the CI type is 1."
294,<android.inputmethodservice.ExtractEditText: boolean hasWindowFocus()>,8,9,<android.inputmethodservice.ExtractEditText: boolean hasWindowFocus()>,<android.inputmethodservice.ExtractEditText: boolean hasWindowFocus()>,0,"{
    return this.isEnabled() ? true : false;
}","{
    return this.isEnabled();
}",1,"/**
 * Pretend like the window this view is in always has focus, so its
 * highlight and cursor will be displayed.
 */
","/**
 * Pretend like the window this view is in always has focus, so its
 * highlight and cursor will be displayed.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,0,"The ternary conditional operator in the return statement has been simplified, but the logic remains the same. Therefore, the code change type is 1.","Although the return statement has been changed, it does not affect the final returned value or type. The method returns the same boolean as a result of 'isEnabled()'. Thus, there is no compatibility issue (CI type is 0)."
295,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",8,9,"<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>","<android.net.SSLCertificateSocketFactory: Socket createSocket(String,int)>",0,"{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    return s;
}","{
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}",1,,"/**
 * {@inheritDoc}
 *
 * <p>This method verifies the peer's certificate hostname after connecting
 * (unless created with {@link #getInsecure(int, SSLSessionCache)}).
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the method introduced a new conditional statement for a new method call 'verifyHostname(s, host);'. Thus, the changes that occurred are under categories 1 for 'Return statement changed' and 3 for 'Control dependency changed'.","The addition of the method 'verifyHostname(s, host);' could potentially change the behavior of the return object, as it introduces a new verification process for the host of the socket. This means the code change falls under the category 'Compatibility Issue caused by potential different return values or types', which is category 1."
296,<android.database.sqlite.SQLiteCursor: void finalize()>,8,9,<android.database.sqlite.SQLiteCursor: void finalize()>,<android.database.sqlite.SQLiteCursor: void finalize()>,0,"{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            int len = mQuery.mSql.length();
            Log.e(TAG, ""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 100) ? 100 : len), mStackTrace);
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (Config.LOGV) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 100) ? 100 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (Config.LOGV) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The change happens in the Log.e() and the addition of the StrictMode.vmSqliteObjectLeaksEnabled() condition statement under the 'if (mWindow != null)'. The Log.e() change is an other statement change (4), and the addition of a new condition is a control dependency change (3).","The changes in the code do not affect the returned value or the exceptions that could be thrown by the method. Therefore, no compatibility issue exists in this case."
297,<android.pim.vcard.VCardEntry: String getFullName()>,8,9,<android.pim.vcard.VCardEntry: String getFullName()>,<android.pim.vcard.VCardEntry: String getFullName()>,0,"{
    return mFullName;
}","{
    return mFormattedName;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from ""return mFullName"" to ""return mFormattedName"", so the code change being classified as 1 - Return statement changed.","The change of return statement will make the API potentially return a different value (as it's now returning a different variable), hence it causes a Compatibility Issue of type 1 - Compatibility Issue caused by potential different return values."
298,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",8,9,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",0,"{
    MotionEvent ev = obtain();
    ev.mDeviceId = deviceId;
    ev.mEdgeFlags = edgeFlags;
    ev.mDownTime = downTime;
    ev.mEventTimeNano = eventTime * 1000000;
    ev.mAction = action;
    ev.mMetaState = metaState;
    ev.mXPrecision = xPrecision;
    ev.mYPrecision = yPrecision;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    int[] pointerIds = ev.mPointerIdentifiers;
    pointerIds[0] = 0;
    float[] data = ev.mDataSamples;
    data[SAMPLE_X] = ev.mRawX = x;
    data[SAMPLE_Y] = ev.mRawY = y;
    data[SAMPLE_PRESSURE] = pressure;
    data[SAMPLE_SIZE] = size;
    ev.mTimeSamples[0] = eventTime;
    return ev;
}","{
    MotionEvent ev = obtain(1, 1);
    ev.mDeviceId = deviceId;
    ev.mSource = InputDevice.SOURCE_UNKNOWN;
    ev.mEdgeFlags = edgeFlags;
    ev.mDownTimeNano = downTime * MS_PER_NS;
    ev.mAction = action;
    ev.mFlags = 0;
    ev.mMetaState = metaState;
    ev.mXOffset = 0;
    ev.mYOffset = 0;
    ev.mXPrecision = xPrecision;
    ev.mYPrecision = yPrecision;
    ev.mNumPointers = 1;
    ev.mNumSamples = 1;
    ev.mLastDataSampleIndex = 0;
    ev.mLastEventTimeNanoSampleIndex = 0;
    ev.mPointerIdentifiers[0] = 0;
    ev.mEventTimeNanoSamples[0] = eventTime * MS_PER_NS;
    ev.setPointerCoordsAtSampleIndex(0, x, y, pressure, size);
    return ev;
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, where touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed -- one of either
 * {@link #ACTION_DOWN}, {@link #ACTION_MOVE}, {@link #ACTION_UP}, or
 * {@link #ACTION_CANCEL}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"Both return statements still return 'ev' in both versions but the value of the variable 'ev' is initialized and modified differently in the two versions. The functional parameters of obtain() have changed from obtain() to obtain(1, 1), and other statements involving changes in types or quantity of parameters were modified as well. Hence, the change can be classified into 1 and 4.","The modifications including the values assignment and obtain() method could potentially affect the returned variable 'ev' and cause the API to return different values, leading to a compatibility issue of type 1."
300,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,8,9,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,<android.webkit.MimeTypeMap: String getFileExtensionFromUrl(String)>,0,"{
    if (url != null && url.length() > 0) {
        int query = url.lastIndexOf('?');
        if (query > 0) {
            url = url.substring(0, query);
        }
        int filenamePos = url.lastIndexOf('/');
        String filename = 0 <= filenamePos ? url.substring(filenamePos + 1) : url;
        // consider it valid for our matching purposes:
        if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)]+"", filename)) {
            int dotPos = filename.lastIndexOf('.');
            if (0 <= dotPos) {
                return filename.substring(dotPos + 1);
            }
        }
    }
    return """";
}","{
    if (url != null && url.length() > 0) {
        int query = url.lastIndexOf('?');
        if (query > 0) {
            url = url.substring(0, query);
        }
        int filenamePos = url.lastIndexOf('/');
        String filename = 0 <= filenamePos ? url.substring(filenamePos + 1) : url;
        // consider it valid for our matching purposes:
        if (filename.length() > 0 && Pattern.matches(""[a-zA-Z_0-9\\.\\-\\(\\)\\%]+"", filename)) {
            int dotPos = filename.lastIndexOf('.');
            if (0 <= dotPos) {
                return filename.substring(dotPos + 1);
            }
        }
    }
    return """";
}",1,"/**
 * Returns the file extension or an empty string iff there is no
 * extension. This method is a convenience method for obtaining the
 * extension of a url and has undefined results for other Strings.
 * @param url
 * @return The file extension of the given url.
 */
","/**
 * Returns the file extension or an empty string iff there is no
 * extension. This method is a convenience method for obtaining the
 * extension of a url and has undefined results for other Strings.
 * @param url
 * @return The file extension of the given url.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,1,"The regular expression used in the Pattern.matches() method has changed from ""[a-zA-Z_0-9\\.\\-\\(\\)]+"" to ""[a-zA-Z_0-9\\.\\-\\(\\)\\%]+"". So the code change type is 3.","Due to the change in the regular expression, the behavior of the if condition with Pattern.matches() might change. As a result, the method might potentially return a different value. Therefore, the Compatibility Issue type is 1."
301,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,8,9,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,0,"{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX((int) mLastTouchX + mScrollX), viewToContentY((int) mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mX = viewToContentX((int) mLastTouchX + mScrollX);
                    ted.mY = viewToContentY((int) mLastTouchY + mScrollY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = mLastTouchX;
                        ted.mViewY = mLastTouchY;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.RestoreState restoreState = (WebViewCore.RestoreState) msg.obj;
                // mScrollX contains the new minPrefWidth
                updateZoomRange(restoreState, getViewWidth(), restoreState.mScrollX, false);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // layer, do it now.
                if (mDelayedDeleteRootLayer) {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(0);
                }
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                boolean hasRestoreState = restoreState != null;
                if (hasRestoreState) {
                    updateZoomRange(restoreState, viewSize.x, draw.mMinPrefWidth, true);
                    if (!mDrawHistory) {
                        mInZoomOverview = false;
                        if (mInitialScaleInPercent > 0) {
                            setNewZoomScale(mInitialScaleInPercent / 100.0f, mInitialScaleInPercent != mTextWrapScale * 100, false);
                        } else if (restoreState.mViewScale > 0) {
                            mTextWrapScale = restoreState.mTextWrapScale;
                            setNewZoomScale(restoreState.mViewScale, false, false);
                        } else {
                            mInZoomOverview = useWideViewport && settings.getLoadWithOverviewMode();
                            float scale;
                            if (mInZoomOverview) {
                                scale = (float) viewWidth / DEFAULT_VIEWPORT_WIDTH;
                            } else {
                                scale = restoreState.mTextWrapScale;
                            }
                            setNewZoomScale(scale, Math.abs(scale - mTextWrapScale) >= MINIMUM_SCALE_INCREMENT, false);
                        }
                        setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                        // As we are on a new page, remove the WebTextView. This
                        // is necessary for page loads driven by webkit, and in
                        // particular when the user was on a password field, so
                        // the WebTextView was visible.
                        clearTextEntry(false);
                        // update the zoom buttons as the scale can be changed
                        if (getSettings().getBuiltInZoomControls()) {
                            updateZoomButtonsEnabled();
                        }
                    }
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    // limit mZoomOverviewWidth upper bound to
                    // sMaxViewportWidth so that if the page doesn't behave
                    // well, the WebView won't go insane. limit the lower
                    // bound to match the default scale for mobile sites.
                    mZoomOverviewWidth = Math.min(sMaxViewportWidth, Math.max((int) (viewWidth / mDefaultScale), Math.max(draw.mMinPrefWidth, draw.mViewPoint.x)));
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, Math.abs(mActualScale - mTextWrapScale) < MINIMUM_SCALE_INCREMENT, false);
                    }
                }
                if (draw.mFocusSizeChanged && inEditingMode()) {
                    mFocusSizeChanged = true;
                }
                if (hasRestoreState) {
                    mViewManager.postReadyToDrawAll();
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            // If no textfield was in focus, and the user touched one,
            // causing it to send this message, then WebTextView has not
            // been set up yet.  Rebuild it so it can set its selection.
            rebuildWebTextView();
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry(false);
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case IMMEDIATE_REPAINT_MSG_ID:
            {
                invalidate();
                break;
            }
        case SET_ROOT_LAYER_MSG_ID:
            {
                if (0 == msg.arg1) {
                    // Null indicates deleting the old layer, but
                    // don't actually do so until we've got the
                    // new page to display.
                    mDelayedDeleteRootLayer = true;
                } else {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(msg.arg1);
                    invalidate();
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            if (msg.obj == null) {
                if (msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) {
                    // if prevent default is called from WebCore, UI
                    // will not handle the rest of the touch events any
                    // more.
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN;
                } else if (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                    // the return for the first ACTION_MOVE will decide
                    // whether UI will handle touch or not. Currently no
                    // support for alternating prevent default
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO;
                }
            } else if (msg.arg2 == 0) {
                // prevent default is not called in WebCore, so the
                // message needs to be reprocessed in UI
                TouchEventData ted = (TouchEventData) msg.obj;
                switch(ted.mAction) {
                    case MotionEvent.ACTION_DOWN:
                        mLastDeferTouchX = ted.mViewX;
                        mLastDeferTouchY = ted.mViewY;
                        mDeferTouchMode = TOUCH_INIT_MODE;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        {
                            // no snapping in defer process
                            if (mDeferTouchMode != TOUCH_DRAG_MODE) {
                                mDeferTouchMode = TOUCH_DRAG_MODE;
                                mLastDeferTouchX = ted.mViewX;
                                mLastDeferTouchY = ted.mViewY;
                                startDrag();
                            }
                            int deltaX = pinLocX((int) (mScrollX + mLastDeferTouchX - ted.mViewX)) - mScrollX;
                            int deltaY = pinLocY((int) (mScrollY + mLastDeferTouchY - ted.mViewY)) - mScrollY;
                            doDrag(deltaX, deltaY);
                            if (deltaX != 0)
                                mLastDeferTouchX = ted.mViewX;
                            if (deltaY != 0)
                                mLastDeferTouchY = ted.mViewY;
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_CANCEL:
                        if (mDeferTouchMode == TOUCH_DRAG_MODE) {
                            // no fling in defer process
                            WebViewCore.resumePriority();
                            WebViewCore.resumeUpdatePicture(mWebViewCore);
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_DOUBLETAP:
                        // doDoubleTap() needs mLastTouchX/Y as anchor
                        mLastTouchX = ted.mViewX;
                        mLastTouchY = ted.mViewY;
                        doDoubleTap();
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_LONGPRESS:
                        HitTestResult hitTest = getHitTestResult();
                        if (hitTest != null && hitTest.mType != HitTestResult.UNKNOWN_TYPE) {
                            performLongClick();
                            rebuildWebTextView();
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp) {
                findAll(mLastFind);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int npp = msg.arg1;
                if (mFullScreenHolder != null) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    mFullScreenHolder.dismiss();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.setCancelable(false);
                mFullScreenHolder.setCanceledOnTouchOutside(false);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            if (inFullScreenMode()) {
                mFullScreenHolder.dismiss();
                mFullScreenHolder = null;
            }
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeight());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            Rect r = (Rect) msg.obj;
            mInZoomOverview = false;
            centerFitRect(r.left, r.top, r.width(), r.height());
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX((int) mLastTouchX + mScrollX), viewToContentY((int) mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mX = viewToContentX((int) mLastTouchX + mScrollX);
                    ted.mY = viewToContentY((int) mLastTouchY + mScrollY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    if (mDeferTouchProcess) {
                        ted.mViewX = mLastTouchX;
                        ted.mViewY = mLastTouchY;
                    }
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                    rebuildWebTextView();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_BY_MSG_ID:
            setContentScrollBy(msg.arg1, msg.arg2, (Boolean) msg.obj);
            break;
        case SYNC_SCROLL_TO_MSG_ID:
            if (mUserScroll) {
                // if user has scrolled explicitly, don't sync the
                // scroll position any more
                mUserScroll = false;
                break;
            }
        // fall through
        case SCROLL_TO_MSG_ID:
            if (setContentScrollTo(msg.arg1, msg.arg2)) {
                // if we can't scroll to the exact position due to pin,
                // send a message to WebCore to re-scroll when we get a
                // new picture
                mUserScroll = false;
                mWebViewCore.sendMessage(EventHub.SYNC_SCROLL, msg.arg1, msg.arg2);
            }
            break;
        case SPAWN_SCROLL_TO_MSG_ID:
            spawnContentScrollTo(msg.arg1, msg.arg2);
            break;
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.RestoreState restoreState = (WebViewCore.RestoreState) msg.obj;
                // mScrollX contains the new minPrefWidth
                updateZoomRange(restoreState, getViewWidth(), restoreState.mScrollX, false);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // layer, do it now.
                if (mDelayedDeleteRootLayer) {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(0);
                }
                WebSettings settings = mWebViewCore.getSettings();
                // called for new content
                final int viewWidth = getViewWidth();
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                final Point viewSize = draw.mViewPoint;
                boolean useWideViewport = settings.getUseWideViewPort();
                WebViewCore.RestoreState restoreState = draw.mRestoreState;
                boolean hasRestoreState = restoreState != null;
                if (hasRestoreState) {
                    updateZoomRange(restoreState, viewSize.x, draw.mMinPrefWidth, true);
                    if (!mDrawHistory) {
                        mInZoomOverview = false;
                        if (mInitialScaleInPercent > 0) {
                            setNewZoomScale(mInitialScaleInPercent / 100.0f, mInitialScaleInPercent != mTextWrapScale * 100, false);
                        } else if (restoreState.mViewScale > 0) {
                            mTextWrapScale = restoreState.mTextWrapScale;
                            setNewZoomScale(restoreState.mViewScale, false, false);
                        } else {
                            mInZoomOverview = useWideViewport && settings.getLoadWithOverviewMode();
                            float scale;
                            if (mInZoomOverview) {
                                scale = (float) viewWidth / DEFAULT_VIEWPORT_WIDTH;
                            } else {
                                scale = restoreState.mTextWrapScale;
                            }
                            setNewZoomScale(scale, Math.abs(scale - mTextWrapScale) >= MINIMUM_SCALE_INCREMENT, false);
                        }
                        setContentScrollTo(restoreState.mScrollX, restoreState.mScrollY);
                        // As we are on a new page, remove the WebTextView. This
                        // is necessary for page loads driven by webkit, and in
                        // particular when the user was on a password field, so
                        // the WebTextView was visible.
                        clearTextEntry(false);
                        // update the zoom buttons as the scale can be changed
                        if (getSettings().getBuiltInZoomControls()) {
                            updateZoomButtonsEnabled();
                        }
                    }
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                recordNewContentSize(draw.mWidthHeight.x, draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0), updateLayout);
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                if (useWideViewport) {
                    // limit mZoomOverviewWidth upper bound to
                    // sMaxViewportWidth so that if the page doesn't behave
                    // well, the WebView won't go insane. limit the lower
                    // bound to match the default scale for mobile sites.
                    mZoomOverviewWidth = Math.min(sMaxViewportWidth, Math.max((int) (viewWidth / mDefaultScale), Math.max(draw.mMinPrefWidth, draw.mViewPoint.x)));
                }
                if (!mMinZoomScaleFixed) {
                    mMinZoomScale = (float) viewWidth / mZoomOverviewWidth;
                }
                if (!mDrawHistory && mInZoomOverview) {
                    // the rounding error case.
                    if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
                        setNewZoomScale((float) viewWidth / mZoomOverviewWidth, Math.abs(mActualScale - mTextWrapScale) < MINIMUM_SCALE_INCREMENT, false);
                    }
                }
                if (draw.mFocusSizeChanged && inEditingMode()) {
                    mFocusSizeChanged = true;
                }
                if (hasRestoreState) {
                    mViewManager.postReadyToDrawAll();
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    mWebTextView.setTextAndKeepSelection((String) msg.obj);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case UPDATE_TEXT_SELECTION_MSG_ID:
            // If no textfield was in focus, and the user touched one,
            // causing it to send this message, then WebTextView has not
            // been set up yet.  Rebuild it so it can set its selection.
            rebuildWebTextView();
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case MOVE_OUT_OF_PLUGIN:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // this is sent after finishing resize in WebViewCore. Make
            // sure the text edit box is still on the  screen.
            selectionDone();
            if (inEditingMode() && nativeCursorIsTextInput()) {
                mWebTextView.bringIntoView();
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry(false);
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case IMMEDIATE_REPAINT_MSG_ID:
            {
                invalidate();
                break;
            }
        case SET_ROOT_LAYER_MSG_ID:
            {
                if (0 == msg.arg1) {
                    // Null indicates deleting the old layer, but
                    // don't actually do so until we've got the
                    // new page to display.
                    mDelayedDeleteRootLayer = true;
                } else {
                    mDelayedDeleteRootLayer = false;
                    nativeSetRootLayer(msg.arg1);
                    invalidate();
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            if (msg.obj == null) {
                if (msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) {
                    // if prevent default is called from WebCore, UI
                    // will not handle the rest of the touch events any
                    // more.
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN;
                } else if (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
                    // the return for the first ACTION_MOVE will decide
                    // whether UI will handle touch or not. Currently no
                    // support for alternating prevent default
                    mPreventDefault = msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO;
                }
            } else if (msg.arg2 == 0) {
                // prevent default is not called in WebCore, so the
                // message needs to be reprocessed in UI
                TouchEventData ted = (TouchEventData) msg.obj;
                switch(ted.mAction) {
                    case MotionEvent.ACTION_DOWN:
                        mLastDeferTouchX = ted.mViewX;
                        mLastDeferTouchY = ted.mViewY;
                        mDeferTouchMode = TOUCH_INIT_MODE;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        {
                            // no snapping in defer process
                            if (mDeferTouchMode != TOUCH_DRAG_MODE) {
                                mDeferTouchMode = TOUCH_DRAG_MODE;
                                mLastDeferTouchX = ted.mViewX;
                                mLastDeferTouchY = ted.mViewY;
                                startDrag();
                            }
                            int deltaX = pinLocX((int) (mScrollX + mLastDeferTouchX - ted.mViewX)) - mScrollX;
                            int deltaY = pinLocY((int) (mScrollY + mLastDeferTouchY - ted.mViewY)) - mScrollY;
                            doDrag(deltaX, deltaY);
                            if (deltaX != 0)
                                mLastDeferTouchX = ted.mViewX;
                            if (deltaY != 0)
                                mLastDeferTouchY = ted.mViewY;
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_CANCEL:
                        if (mDeferTouchMode == TOUCH_DRAG_MODE) {
                            // no fling in defer process
                            mScroller.springBack(mScrollX, mScrollY, 0, computeMaxScrollX(), 0, computeMaxScrollY());
                            invalidate();
                            WebViewCore.resumePriority();
                            WebViewCore.resumeUpdatePicture(mWebViewCore);
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_DOUBLETAP:
                        // doDoubleTap() needs mLastTouchX/Y as anchor
                        mLastTouchX = ted.mViewX;
                        mLastTouchY = ted.mViewY;
                        doDoubleTap();
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                    case WebViewCore.ACTION_LONGPRESS:
                        HitTestResult hitTest = getHitTestResult();
                        if (hitTest != null && hitTest.mType != HitTestResult.UNKNOWN_TYPE) {
                            performLongClick();
                            rebuildWebTextView();
                        }
                        mDeferTouchMode = TOUCH_DONE_MODE;
                        break;
                }
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp) {
                findAll(mLastFind);
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int npp = msg.arg1;
                if (mFullScreenHolder != null) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    mFullScreenHolder.dismiss();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.setCancelable(false);
                mFullScreenHolder.setCanceledOnTouchOutside(false);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            if (inFullScreenMode()) {
                mFullScreenHolder.dismiss();
                mFullScreenHolder = null;
            }
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeight());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            Rect r = (Rect) msg.obj;
            mInZoomOverview = false;
            centerFitRect(r.left, r.top, r.width(), r.height());
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
302,"<android.view.MotionEvent: float getHistoricalY(int,int)>",8,9,"<android.view.MotionEvent: float getHistoricalY(int,int)>","<android.view.MotionEvent: float getHistoricalY(int,int)>",0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + (pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_Y];
}","{
    return mDataSamples[(pos * mNumPointers + pointerIndex) * NUM_SAMPLE_DATA + SAMPLE_Y] + mYOffset;
}",1,"/**
 * Returns a historical Y coordinate, as per {@link #getY(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getY
 */
","/**
 * Returns a historical Y coordinate, as per {@link #getY(int)}, that
 * occurred between this event and the previous event for the given pointer.
 * Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getY
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1, 4",1,"The return statement has been updated due to the change in computation using mDataSamples. Hence, both the 'return statement change (1)' and 'other statement changed (4)' categories apply to this code change.","The change in return statement leads to different return values between the two versions potentially. Thus, the changes cause a 'Compatibility Issue due to potential different return values or types (1)'."
303,"<android.app.ContextImpl: Context createPackageContext(String,int)>",8,9,"<android.app.ContextImpl: Context createPackageContext(String,int)>","<android.app.ContextImpl: Context createPackageContext(String,int)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(mMainThread.getSystemContext());
    }
    ActivityThread.PackageInfo pi = mMainThread.getPackageInfo(packageName, flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(mMainThread.getSystemContext());
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"4,5",1,"Type of pi has been changed from `ActivityThread.PackageInfo` to `LoadedApk`, and the initiation of c context (c.init) is dependent upon pi, this changes are classified as type 4 (Other statement changed) and 5 (Dependent API changed).","As the type of dependent API (pi) used in the invocation of `c.init(pi, null, mMainThread, mResources)` has changed, it may result in different initialization of the context `c`. Therefore, the return type `c` can potentially be different, thus it causes Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
304,"<android.view.MotionEvent: float getHistoricalPressure(int,int)>",8,9,"<android.view.MotionEvent: float getHistoricalPressure(int,int)>","<android.view.MotionEvent: float getHistoricalPressure(int,int)>",0,"{
    return mDataSamples[((pos + 1) * NUM_SAMPLE_DATA * mNumPointers) + (pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_PRESSURE];
}","{
    return mDataSamples[(pos * mNumPointers + pointerIndex) * NUM_SAMPLE_DATA + SAMPLE_PRESSURE];
}",1,"/**
 * Returns a historical pressure coordinate, as per {@link #getPressure(int)},
 * that occurred between this event and the previous event for the given
 * pointer.  Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getPressure
 */
","/**
 * Returns a historical pressure coordinate, as per {@link #getPressure(int)},
 * that occurred between this event and the previous event for the given
 * pointer.  Only applies to ACTION_MOVE events.
 *
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 * @param pos Which historical value to return; must be less than
 * {@link #getHistorySize}
 *
 * @see #getHistorySize
 * @see #getPressure
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The formula used to calculate the index for accessing the mDataSamples array has changed. So, the code change type is 4.","The change in the index calculation logic can result in a different value being returned by the API depending on the input 'pos' and 'pointerIndex'. So, the CI type is 1."
306,<android.view.KeyEvent: int getScanCode()>,8,9,<android.view.KeyEvent: int getScanCode()>,<android.view.KeyEvent: int getScanCode()>,0,"{
    return mScancode;
}","{
    return mScanCode;
}",1,"/**
 * Retrieve the hardware key id of this key event.  These values are not
 * reliable and vary from device to device.
 *
 * {@more}
 * Mostly this is here for debugging purposes.
 */
","/**
 * Retrieve the hardware key id of this key event.  These values are not
 * reliable and vary from device to device.
 *
 * {@more}
 * Mostly this is here for debugging purposes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The variable name for returning value has changed from 'mScancode' to 'mScanCode', which can be classified as both return statement change and other statement change. So, the code change type is 1,4.","The change of variable name for return statement can potentially make the API return a different value. Therefore, this code change can lead to a Compatibility Issue caused by potential different return values, so the CI type is 1."
309,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,8,9,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,<android.widget.TextView: void onRestoreInstanceState(Parcelable)>,0,"{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(""TextView"", ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                setError(error);
            }
        });
    }
}","{
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    // XXX restore buffer type too, as well as lots of other stuff
    if (ss.text != null) {
        setText(ss.text);
    }
    if (ss.selStart >= 0 && ss.selEnd >= 0) {
        if (mText instanceof Spannable) {
            int len = mText.length();
            if (ss.selStart > len || ss.selEnd > len) {
                String restored = """";
                if (ss.text != null) {
                    restored = ""(restored) "";
                }
                Log.e(LOG_TAG, ""Saved cursor position "" + ss.selStart + ""/"" + ss.selEnd + "" out of range for "" + restored + ""text "" + mText);
            } else {
                Selection.setSelection((Spannable) mText, ss.selStart, ss.selEnd);
                if (ss.frozenWithFocus) {
                    mFrozenWithFocus = true;
                }
            }
        }
    }
    if (ss.error != null) {
        final CharSequence error = ss.error;
        // Display the error later, after the first layout pass
        post(new Runnable() {

            public void run() {
                setError(error);
            }
        });
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is only on the parameter of 'Log.e()' call where the tag string changed from 'TextView' to 'LOG_TAG', so this falls under change type 4.","This change does not introduce any potential behavioural changes that will cause the API to return a different value or throw a different exception, so no compatibility issue exists."
311,<android.widget.TextView: boolean reportExtractedText()>,8,9,<android.widget.TextView: boolean reportExtractedText()>,<android.widget.TextView: boolean reportExtractedText()>,0,"{
    final InputMethodState ims = mInputMethodState;
    if (ims != null) {
        final boolean contentChanged = ims.mContentChanged;
        if (contentChanged || ims.mSelectionModeChanged) {
            ims.mContentChanged = false;
            ims.mSelectionModeChanged = false;
            final ExtractedTextRequest req = mInputMethodState.mExtracting;
            if (req != null) {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    if (DEBUG_EXTRACT)
                        Log.v(TAG, ""Retrieving extracted start="" + ims.mChangedStart + "" end="" + ims.mChangedEnd + "" delta="" + ims.mChangedDelta);
                    if (ims.mChangedStart < 0 && !contentChanged) {
                        ims.mChangedStart = EXTRACT_NOTHING;
                    }
                    if (extractTextInternal(req, ims.mChangedStart, ims.mChangedEnd, ims.mChangedDelta, ims.mTmpExtracted)) {
                        if (DEBUG_EXTRACT)
                            Log.v(TAG, ""Reporting extracted start="" + ims.mTmpExtracted.partialStartOffset + "" end="" + ims.mTmpExtracted.partialEndOffset + "": "" + ims.mTmpExtracted.text);
                        imm.updateExtractedText(this, req.token, mInputMethodState.mTmpExtracted);
                        return true;
                    }
                }
            }
        }
    }
    return false;
}","{
    final InputMethodState ims = mInputMethodState;
    if (ims != null) {
        final boolean contentChanged = ims.mContentChanged;
        if (contentChanged || ims.mSelectionModeChanged) {
            ims.mContentChanged = false;
            ims.mSelectionModeChanged = false;
            final ExtractedTextRequest req = mInputMethodState.mExtracting;
            if (req != null) {
                InputMethodManager imm = InputMethodManager.peekInstance();
                if (imm != null) {
                    if (DEBUG_EXTRACT)
                        Log.v(LOG_TAG, ""Retrieving extracted start="" + ims.mChangedStart + "" end="" + ims.mChangedEnd + "" delta="" + ims.mChangedDelta);
                    if (ims.mChangedStart < 0 && !contentChanged) {
                        ims.mChangedStart = EXTRACT_NOTHING;
                    }
                    if (extractTextInternal(req, ims.mChangedStart, ims.mChangedEnd, ims.mChangedDelta, ims.mTmpExtracted)) {
                        if (DEBUG_EXTRACT)
                            Log.v(LOG_TAG, ""Reporting extracted start="" + ims.mTmpExtracted.partialStartOffset + "" end="" + ims.mTmpExtracted.partialEndOffset + "": "" + ims.mTmpExtracted.text);
                        imm.updateExtractedText(this, req.token, mInputMethodState.mTmpExtracted);
                        return true;
                    }
                }
            }
        }
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"Only the log tag in the 'Log.v' statement has changed from 'TAG' to 'LOG_TAG', which is categorized as 'other statement changed' type.","As the change only involves a log statement, it does not change the behavior of the API or lead to any compatibility issue, thus it is categorized as 'no compatibility issue' type."
313,<android.widget.Scroller: boolean computeScrollOffset()>,8,9,<android.widget.Scroller: boolean computeScrollOffset()>,<android.widget.Scroller: boolean computeScrollOffset()>,0,"{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = (float) timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                float timePassedSeconds = timePassed / 1000.0f;
                float distance = (mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
                mCurrX = mStartX + Math.round(distance * mCoeffX);
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distance * mCoeffY);
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}","{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = (float) timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                float timePassedSeconds = timePassed / 1000.0f;
                float distance = (mVelocity * timePassedSeconds) - (mDeceleration * timePassedSeconds * timePassedSeconds / 2.0f);
                mCurrX = mStartX + Math.round(distance * mCoeffX);
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distance * mCoeffY);
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}",1,"/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
","/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.  loc will be altered to provide the
 * new location.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The code change is just a condition check statement 'if (mCurrX == mFinalX && mCurrY == mFinalY)' that has been added within the FLING_MODE case in the switch statement. This falls under code change type 3, i.e. change in control dependency.",This code change doesn't lead to any compatibility issues. The added condition check doesn't change the behavior of the code in a way that could lead to different return value or exception being thrown. The function return either 'true' or 'false' regardless of the version. So the Compatibility Issue (CI) type is 0.
314,"<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>",8,9,"<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>","<android.widget.TextView: boolean extractTextInternal(ExtractedTextRequest,int,int,int,ExtractedText)>",0,"{
    final CharSequence content = mText;
    if (content != null) {
        if (partialStartOffset != EXTRACT_NOTHING) {
            final int N = content.length();
            if (partialStartOffset < 0) {
                outText.partialStartOffset = outText.partialEndOffset = -1;
                partialStartOffset = 0;
                partialEndOffset = N;
            } else {
                // Adjust offsets to ensure we contain full spans.
                if (content instanceof Spanned) {
                    Spanned spanned = (Spanned) content;
                    Object[] spans = spanned.getSpans(partialStartOffset, partialEndOffset, ParcelableSpan.class);
                    int i = spans.length;
                    while (i > 0) {
                        i--;
                        int j = spanned.getSpanStart(spans[i]);
                        if (j < partialStartOffset)
                            partialStartOffset = j;
                        j = spanned.getSpanEnd(spans[i]);
                        if (j > partialEndOffset)
                            partialEndOffset = j;
                    }
                }
                outText.partialStartOffset = partialStartOffset;
                outText.partialEndOffset = partialEndOffset;
                // Now use the delta to determine the actual amount of text
                // we need.
                partialEndOffset += delta;
                if (partialStartOffset > N) {
                    partialStartOffset = N;
                } else if (partialStartOffset < 0) {
                    partialStartOffset = 0;
                }
                if (partialEndOffset > N) {
                    partialEndOffset = N;
                } else if (partialEndOffset < 0) {
                    partialEndOffset = 0;
                }
            }
            if ((request.flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) {
                outText.text = content.subSequence(partialStartOffset, partialEndOffset);
            } else {
                outText.text = TextUtils.substring(content, partialStartOffset, partialEndOffset);
            }
        }
        outText.flags = 0;
        if (MetaKeyKeyListener.getMetaState(mText, MetaKeyKeyListener.META_SELECTING) != 0) {
            outText.flags |= ExtractedText.FLAG_SELECTING;
        }
        if (mSingleLine) {
            outText.flags |= ExtractedText.FLAG_SINGLE_LINE;
        }
        outText.startOffset = 0;
        outText.selectionStart = Selection.getSelectionStart(content);
        outText.selectionEnd = Selection.getSelectionEnd(content);
        return true;
    }
    return false;
}","{
    final CharSequence content = mText;
    if (content != null) {
        if (partialStartOffset != EXTRACT_NOTHING) {
            final int N = content.length();
            if (partialStartOffset < 0) {
                outText.partialStartOffset = outText.partialEndOffset = -1;
                partialStartOffset = 0;
                partialEndOffset = N;
            } else {
                // Adjust offsets to ensure we contain full spans.
                if (content instanceof Spanned) {
                    Spanned spanned = (Spanned) content;
                    Object[] spans = spanned.getSpans(partialStartOffset, partialEndOffset, ParcelableSpan.class);
                    int i = spans.length;
                    while (i > 0) {
                        i--;
                        int j = spanned.getSpanStart(spans[i]);
                        if (j < partialStartOffset)
                            partialStartOffset = j;
                        j = spanned.getSpanEnd(spans[i]);
                        if (j > partialEndOffset)
                            partialEndOffset = j;
                    }
                }
                outText.partialStartOffset = partialStartOffset;
                outText.partialEndOffset = partialEndOffset;
                // Now use the delta to determine the actual amount of text
                // we need.
                partialEndOffset += delta;
                if (partialStartOffset > N) {
                    partialStartOffset = N;
                } else if (partialStartOffset < 0) {
                    partialStartOffset = 0;
                }
                if (partialEndOffset > N) {
                    partialEndOffset = N;
                } else if (partialEndOffset < 0) {
                    partialEndOffset = 0;
                }
            }
            if ((request.flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) {
                outText.text = content.subSequence(partialStartOffset, partialEndOffset);
            } else {
                outText.text = TextUtils.substring(content, partialStartOffset, partialEndOffset);
            }
        } else {
            outText.partialStartOffset = 0;
            outText.partialEndOffset = 0;
            outText.text = """";
        }
        outText.flags = 0;
        if (MetaKeyKeyListener.getMetaState(mText, MetaKeyKeyListener.META_SELECTING) != 0) {
            outText.flags |= ExtractedText.FLAG_SELECTING;
        }
        if (mSingleLine) {
            outText.flags |= ExtractedText.FLAG_SINGLE_LINE;
        }
        outText.startOffset = 0;
        outText.selectionStart = getSelectionStart();
        outText.selectionEnd = getSelectionEnd();
        return true;
    }
    return false;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"An else statement is introduced in the late version of the implementation. Also, two methods Selection.getSelectionStart(content) and Selection.getSelectionEnd(content) have been replaced with getSelectionStart() and getSelectionEnd(), so the code change type is 1,4.","The change of return statements (introduction of the else statement) and the other statement changes will make the API potentially return a different value and behavior, so the CI type is 1."
315,<android.server.BluetoothService: boolean createBond(String)>,8,9,<android.server.BluetoothService: boolean createBond(String)>,<android.server.BluetoothService: boolean createBond(String)>,0,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    address = address.toUpperCase();
    if (mBondState.getPendingOutgoingBonding() != null) {
        log(""Ignoring createBond(): another device is bonding"");
        // a different device is currently bonding, fail
        return false;
    }
    // pairing exponential back-off attempts.
    if (!mBondState.isAutoPairingAttemptsInProgress(address) && mBondState.getBondState(address) != BluetoothDevice.BOND_NONE) {
        log(""Ignoring createBond(): this device is already bonding or bonded"");
        return false;
    }
    if (address.equals(mDockAddress)) {
        if (!writeDockPin()) {
            log(""Error while writing Pin for the dock"");
            return false;
        }
    }
    if (!createPairedDeviceNative(address, 60000)) {
        return false;
    }
    mBondState.setPendingOutgoingBonding(address);
    mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
    return true;
}","{
    if (!isBondingFeasible(address))
        return false;
    if (!createPairedDeviceNative(address, 60000)) {
        return false;
    }
    mBondState.setPendingOutgoingBonding(address);
    mBondState.setBondState(address, BluetoothDevice.BOND_BONDING);
    return true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, an early checks and logics to Raspberry Pi are replaced by a call to 'isBondingFeasible' function. Additionally, the condition check 'if (address.equals(mDockAddress))' is removed. The change type is 1,3,4.","The new function 'isBondingFeasible' and the removal of early checks and logics can lead to different return values or types. Therefore, the CI type is 1."
317,<android.pim.vcard.VCardEntry: void addProperty(Property)>,8,9,<android.pim.vcard.VCardEntry: void addProperty(Property)>,<android.pim.vcard.VCardEntry: void addProperty(Property)>,0,"{
    final String propName = property.mPropertyName;
    final Map<String, Collection<String>> paramMap = property.mParameterMap;
    final List<String> propValueList = property.mPropertyValueList;
    byte[] propBytes = property.mPropertyBytes;
    if (propValueList.size() == 0) {
        return;
    }
    final String propValue = listToString(propValueList).trim();
    if (propName.equals(VCardConstants.PROPERTY_VERSION)) {
    // vCard version. Ignore this.
    } else if (propName.equals(VCardConstants.PROPERTY_FN)) {
        mFullName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_NAME) && mFullName == null) {
        // Only in vCard 3.0. Use this if FN, which must exist in vCard 3.0 but may not
        // actually exist in the real vCard data, does not exist.
        mFullName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_N)) {
        handleNProperty(propValueList);
    } else if (propName.equals(VCardConstants.PROPERTY_SORT_STRING)) {
        mPhoneticFullName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_NICKNAME) || propName.equals(VCardConstants.ImportOnly.PROPERTY_X_NICKNAME)) {
        addNickName(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_SOUND)) {
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_X_IRMC_N)) {
            // As of 2009-10-08, Parser side does not split a property value into separated
            // values using ';' (in other words, propValueList.size() == 1),
            // which is correct behavior from the view of vCard 2.1.
            // But we want it to be separated, so do the separation here.
            final List<String> phoneticNameList = VCardUtils.constructListFromValue(propValue, VCardConfig.isV30(mVCardType));
            handlePhoneticNameFromSound(phoneticNameList);
        } else {
        // Ignore this field since Android cannot understand what it is.
        }
    } else if (propName.equals(VCardConstants.PROPERTY_ADR)) {
        boolean valuesAreAllEmpty = true;
        for (String value : propValueList) {
            if (value.length() > 0) {
                valuesAreAllEmpty = false;
                break;
            }
        }
        if (valuesAreAllEmpty) {
            return;
        }
        int type = -1;
        String label = """";
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                typeString = typeString.toUpperCase();
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_HOME)) {
                    type = StructuredPostal.TYPE_HOME;
                    label = """";
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_WORK) || typeString.equalsIgnoreCase(VCardConstants.PARAM_EXTRA_TYPE_COMPANY)) {
                    // ""COMPANY"" seems emitted by Windows Mobile, which is not
                    // specifically supported by vCard 2.1. We assume this is same
                    // as ""WORK"".
                    type = StructuredPostal.TYPE_WORK;
                    label = """";
                } else if (typeString.equals(VCardConstants.PARAM_ADR_TYPE_PARCEL) || typeString.equals(VCardConstants.PARAM_ADR_TYPE_DOM) || typeString.equals(VCardConstants.PARAM_ADR_TYPE_INTL)) {
                // We do not have any appropriate way to store this information.
                } else {
                    if (typeString.startsWith(""X-"") && type < 0) {
                        typeString = typeString.substring(2);
                    }
                    // vCard 3.0 allows iana-token. Also some vCard 2.1 exporters
                    // emit non-standard types. We do not handle their values now.
                    type = StructuredPostal.TYPE_CUSTOM;
                    label = typeString;
                }
            }
        }
        // We use ""HOME"" as default
        if (type < 0) {
            type = StructuredPostal.TYPE_HOME;
        }
        addPostal(type, propValueList, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_EMAIL)) {
        int type = -1;
        String label = null;
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                typeString = typeString.toUpperCase();
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_HOME)) {
                    type = Email.TYPE_HOME;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_WORK)) {
                    type = Email.TYPE_WORK;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_CELL)) {
                    type = Email.TYPE_MOBILE;
                } else {
                    if (typeString.startsWith(""X-"") && type < 0) {
                        typeString = typeString.substring(2);
                    }
                    // vCard 3.0 allows iana-token.
                    // We may have INTERNET (specified in vCard spec),
                    // SCHOOL, etc.
                    type = Email.TYPE_CUSTOM;
                    label = typeString;
                }
            }
        }
        if (type < 0) {
            type = Email.TYPE_OTHER;
        }
        addEmail(type, propValue, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_ORG)) {
        // vCard specification does not specify other types.
        final int type = Organization.TYPE_WORK;
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                }
            }
        }
        handleOrgValue(type, propValueList, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_TITLE)) {
        handleTitleValue(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_ROLE)) {
    // This conflicts with TITLE. Ignore for now...
    // handleTitleValue(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_PHOTO) || propName.equals(VCardConstants.PROPERTY_LOGO)) {
        Collection<String> paramMapValue = paramMap.get(""VALUE"");
        if (paramMapValue != null && paramMapValue.contains(""URL"")) {
        // Currently we do not have appropriate example for testing this case.
        } else {
            final Collection<String> typeCollection = paramMap.get(""TYPE"");
            String formatName = null;
            boolean isPrimary = false;
            if (typeCollection != null) {
                for (String typeValue : typeCollection) {
                    if (VCardConstants.PARAM_TYPE_PREF.equals(typeValue)) {
                        isPrimary = true;
                    } else if (formatName == null) {
                        formatName = typeValue;
                    }
                }
            }
            addPhotoBytes(formatName, propBytes, isPrimary);
        }
    } else if (propName.equals(VCardConstants.PROPERTY_TEL)) {
        final Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        final Object typeObject = VCardUtils.getPhoneTypeFromStrings(typeCollection, propValue);
        final int type;
        final String label;
        if (typeObject instanceof Integer) {
            type = (Integer) typeObject;
            label = null;
        } else {
            type = Phone.TYPE_CUSTOM;
            label = typeObject.toString();
        }
        final boolean isPrimary;
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_PREF)) {
            isPrimary = true;
        } else {
            isPrimary = false;
        }
        addPhone(type, propValue, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_X_SKYPE_PSTNNUMBER)) {
        // The phone number available via Skype.
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        final int type = Phone.TYPE_OTHER;
        final boolean isPrimary;
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_PREF)) {
            isPrimary = true;
        } else {
            isPrimary = false;
        }
        addPhone(type, propValue, null, isPrimary);
    } else if (sImMap.containsKey(propName)) {
        final int protocol = sImMap.get(propName);
        boolean isPrimary = false;
        int type = -1;
        final Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (type < 0) {
                    if (typeString.equalsIgnoreCase(VCardConstants.PARAM_TYPE_HOME)) {
                        type = Im.TYPE_HOME;
                    } else if (typeString.equalsIgnoreCase(VCardConstants.PARAM_TYPE_WORK)) {
                        type = Im.TYPE_WORK;
                    }
                }
            }
        }
        if (type < 0) {
            type = Phone.TYPE_HOME;
        }
        addIm(protocol, null, type, propValue, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_NOTE)) {
        addNote(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_URL)) {
        if (mWebsiteList == null) {
            mWebsiteList = new ArrayList<String>(1);
        }
        mWebsiteList.add(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_BDAY)) {
        mBirthday = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_FIRST_NAME)) {
        mPhoneticGivenName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_MIDDLE_NAME)) {
        mPhoneticMiddleName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_LAST_NAME)) {
        mPhoneticFamilyName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_ANDROID_CUSTOM)) {
        final List<String> customPropertyList = VCardUtils.constructListFromValue(propValue, VCardConfig.isV30(mVCardType));
        handleAndroidCustomProperty(customPropertyList);
    /*} else if (propName.equals(""REV"")) {
            // Revision of this VCard entry. I think we can ignore this.
        } else if (propName.equals(""UID"")) {
        } else if (propName.equals(""KEY"")) {
            // Type is X509 or PGP? I don't know how to handle this...
        } else if (propName.equals(""MAILER"")) {
        } else if (propName.equals(""TZ"")) {
        } else if (propName.equals(""GEO"")) {
        } else if (propName.equals(""CLASS"")) {
            // vCard 3.0 only.
            // e.g. CLASS:CONFIDENTIAL
        } else if (propName.equals(""PROFILE"")) {
            // VCard 3.0 only. Must be ""VCARD"". I think we can ignore this.
        } else if (propName.equals(""CATEGORIES"")) {
            // VCard 3.0 only.
            // e.g. CATEGORIES:INTERNET,IETF,INDUSTRY,INFORMATION TECHNOLOGY
        } else if (propName.equals(""SOURCE"")) {
            // VCard 3.0 only.
        } else if (propName.equals(""PRODID"")) {
            // VCard 3.0 only.
            // To specify the identifier for the product that created
            // the vCard object.*/
    } else {
    // Unknown X- words and IANA token.
    }
}","{
    final String propName = property.mPropertyName;
    final Map<String, Collection<String>> paramMap = property.mParameterMap;
    final List<String> propValueList = property.mPropertyValueList;
    byte[] propBytes = property.mPropertyBytes;
    if (propValueList.size() == 0) {
        return;
    }
    final String propValue = listToString(propValueList).trim();
    if (propName.equals(VCardConstants.PROPERTY_VERSION)) {
    // vCard version. Ignore this.
    } else if (propName.equals(VCardConstants.PROPERTY_FN)) {
        mFormattedName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_NAME) && mFormattedName == null) {
        // Only in vCard 3.0. Use this if FN, which must exist in vCard 3.0 but may not
        // actually exist in the real vCard data, does not exist.
        mFormattedName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_N)) {
        handleNProperty(propValueList, paramMap);
    } else if (propName.equals(VCardConstants.PROPERTY_SORT_STRING)) {
        mPhoneticFullName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_NICKNAME) || propName.equals(VCardConstants.ImportOnly.PROPERTY_X_NICKNAME)) {
        addNickName(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_SOUND)) {
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_X_IRMC_N)) {
            // As of 2009-10-08, Parser side does not split a property value into separated
            // values using ';' (in other words, propValueList.size() == 1),
            // which is correct behavior from the view of vCard 2.1.
            // But we want it to be separated, so do the separation here.
            final List<String> phoneticNameList = VCardUtils.constructListFromValue(propValue, mVCardType);
            handlePhoneticNameFromSound(phoneticNameList);
        } else {
        // Ignore this field since Android cannot understand what it is.
        }
    } else if (propName.equals(VCardConstants.PROPERTY_ADR)) {
        boolean valuesAreAllEmpty = true;
        for (String value : propValueList) {
            if (value.length() > 0) {
                valuesAreAllEmpty = false;
                break;
            }
        }
        if (valuesAreAllEmpty) {
            return;
        }
        int type = -1;
        String label = """";
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                typeString = typeString.toUpperCase();
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_HOME)) {
                    type = StructuredPostal.TYPE_HOME;
                    label = """";
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_WORK) || typeString.equalsIgnoreCase(VCardConstants.PARAM_EXTRA_TYPE_COMPANY)) {
                    // ""COMPANY"" seems emitted by Windows Mobile, which is not
                    // specifically supported by vCard 2.1. We assume this is same
                    // as ""WORK"".
                    type = StructuredPostal.TYPE_WORK;
                    label = """";
                } else if (typeString.equals(VCardConstants.PARAM_ADR_TYPE_PARCEL) || typeString.equals(VCardConstants.PARAM_ADR_TYPE_DOM) || typeString.equals(VCardConstants.PARAM_ADR_TYPE_INTL)) {
                // We do not have any appropriate way to store this information.
                } else {
                    if (typeString.startsWith(""X-"") && type < 0) {
                        typeString = typeString.substring(2);
                    }
                    // vCard 3.0 allows iana-token. Also some vCard 2.1 exporters
                    // emit non-standard types. We do not handle their values now.
                    type = StructuredPostal.TYPE_CUSTOM;
                    label = typeString;
                }
            }
        }
        // We use ""HOME"" as default
        if (type < 0) {
            type = StructuredPostal.TYPE_HOME;
        }
        addPostal(type, propValueList, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_EMAIL)) {
        int type = -1;
        String label = null;
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                typeString = typeString.toUpperCase();
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_HOME)) {
                    type = Email.TYPE_HOME;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_WORK)) {
                    type = Email.TYPE_WORK;
                } else if (typeString.equals(VCardConstants.PARAM_TYPE_CELL)) {
                    type = Email.TYPE_MOBILE;
                } else {
                    if (typeString.startsWith(""X-"") && type < 0) {
                        typeString = typeString.substring(2);
                    }
                    // vCard 3.0 allows iana-token.
                    // We may have INTERNET (specified in vCard spec),
                    // SCHOOL, etc.
                    type = Email.TYPE_CUSTOM;
                    label = typeString;
                }
            }
        }
        if (type < 0) {
            type = Email.TYPE_OTHER;
        }
        addEmail(type, propValue, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_ORG)) {
        // vCard specification does not specify other types.
        final int type = Organization.TYPE_WORK;
        boolean isPrimary = false;
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                }
            }
        }
        handleOrgValue(type, propValueList, paramMap, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_TITLE)) {
        handleTitleValue(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_ROLE)) {
    // This conflicts with TITLE. Ignore for now...
    // handleTitleValue(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_PHOTO) || propName.equals(VCardConstants.PROPERTY_LOGO)) {
        Collection<String> paramMapValue = paramMap.get(""VALUE"");
        if (paramMapValue != null && paramMapValue.contains(""URL"")) {
        // Currently we do not have appropriate example for testing this case.
        } else {
            final Collection<String> typeCollection = paramMap.get(""TYPE"");
            String formatName = null;
            boolean isPrimary = false;
            if (typeCollection != null) {
                for (String typeValue : typeCollection) {
                    if (VCardConstants.PARAM_TYPE_PREF.equals(typeValue)) {
                        isPrimary = true;
                    } else if (formatName == null) {
                        formatName = typeValue;
                    }
                }
            }
            addPhotoBytes(formatName, propBytes, isPrimary);
        }
    } else if (propName.equals(VCardConstants.PROPERTY_TEL)) {
        final Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        final Object typeObject = VCardUtils.getPhoneTypeFromStrings(typeCollection, propValue);
        final int type;
        final String label;
        if (typeObject instanceof Integer) {
            type = (Integer) typeObject;
            label = null;
        } else {
            type = Phone.TYPE_CUSTOM;
            label = typeObject.toString();
        }
        final boolean isPrimary;
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_PREF)) {
            isPrimary = true;
        } else {
            isPrimary = false;
        }
        addPhone(type, propValue, label, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_X_SKYPE_PSTNNUMBER)) {
        // The phone number available via Skype.
        Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        final int type = Phone.TYPE_OTHER;
        final boolean isPrimary;
        if (typeCollection != null && typeCollection.contains(VCardConstants.PARAM_TYPE_PREF)) {
            isPrimary = true;
        } else {
            isPrimary = false;
        }
        addPhone(type, propValue, null, isPrimary);
    } else if (sImMap.containsKey(propName)) {
        final int protocol = sImMap.get(propName);
        boolean isPrimary = false;
        int type = -1;
        final Collection<String> typeCollection = paramMap.get(VCardConstants.PARAM_TYPE);
        if (typeCollection != null) {
            for (String typeString : typeCollection) {
                if (typeString.equals(VCardConstants.PARAM_TYPE_PREF)) {
                    isPrimary = true;
                } else if (type < 0) {
                    if (typeString.equalsIgnoreCase(VCardConstants.PARAM_TYPE_HOME)) {
                        type = Im.TYPE_HOME;
                    } else if (typeString.equalsIgnoreCase(VCardConstants.PARAM_TYPE_WORK)) {
                        type = Im.TYPE_WORK;
                    }
                }
            }
        }
        if (type < 0) {
            type = Im.TYPE_HOME;
        }
        addIm(protocol, null, type, propValue, isPrimary);
    } else if (propName.equals(VCardConstants.PROPERTY_NOTE)) {
        addNote(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_URL)) {
        if (mWebsiteList == null) {
            mWebsiteList = new ArrayList<String>(1);
        }
        mWebsiteList.add(propValue);
    } else if (propName.equals(VCardConstants.PROPERTY_BDAY)) {
        mBirthday = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_ANNIVERSARY)) {
        mAnniversary = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_FIRST_NAME)) {
        mPhoneticGivenName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_MIDDLE_NAME)) {
        mPhoneticMiddleName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_PHONETIC_LAST_NAME)) {
        mPhoneticFamilyName = propValue;
    } else if (propName.equals(VCardConstants.PROPERTY_X_ANDROID_CUSTOM)) {
        final List<String> customPropertyList = VCardUtils.constructListFromValue(propValue, mVCardType);
        handleAndroidCustomProperty(customPropertyList);
    } else {
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
318,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",8,9,"<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>","<android.database.sqlite.SQLiteDatabase: int updateWithOnConflict(String,ContentValues,String,String[],int)>",0,"{
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException(""Empty values"");
    }
    StringBuilder sql = new StringBuilder(120);
    sql.append(""UPDATE "");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(table);
    sql.append("" SET "");
    Set<Map.Entry<String, Object>> entrySet = values.valueSet();
    Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
    while (entriesIter.hasNext()) {
        Map.Entry<String, Object> entry = entriesIter.next();
        sql.append(entry.getKey());
        sql.append(""=?"");
        if (entriesIter.hasNext()) {
            sql.append("", "");
        }
    }
    if (!TextUtils.isEmpty(whereClause)) {
        sql.append("" WHERE "");
        sql.append(whereClause);
    }
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql.toString());
        // Bind the values
        int size = entrySet.size();
        entriesIter = entrySet.iterator();
        int bindArg = 1;
        for (int i = 0; i < size; i++) {
            Map.Entry<String, Object> entry = entriesIter.next();
            DatabaseUtils.bindObjectToProgram(statement, bindArg, entry.getValue());
            bindArg++;
        }
        if (whereArgs != null) {
            size = whereArgs.length;
            for (int i = 0; i < size; i++) {
                statement.bindString(bindArg, whereArgs[i]);
                bindArg++;
            }
        }
        // Run the program and then cleanup
        statement.execute();
        int numChangedRows = lastChangeCount();
        if (Config.LOGD && Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""Updated "" + numChangedRows + "" using "" + values + "" and "" + sql);
        }
        return numChangedRows;
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } catch (SQLException e) {
        Log.e(TAG, ""Error updating "" + values + "" using "" + sql);
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}","{
    BlockGuard.getThreadPolicy().onWriteToDisk();
    if (values == null || values.size() == 0) {
        throw new IllegalArgumentException(""Empty values"");
    }
    StringBuilder sql = new StringBuilder(120);
    sql.append(""UPDATE "");
    sql.append(CONFLICT_VALUES[conflictAlgorithm]);
    sql.append(table);
    sql.append("" SET "");
    Set<Map.Entry<String, Object>> entrySet = values.valueSet();
    Iterator<Map.Entry<String, Object>> entriesIter = entrySet.iterator();
    while (entriesIter.hasNext()) {
        Map.Entry<String, Object> entry = entriesIter.next();
        sql.append(entry.getKey());
        sql.append(""=?"");
        if (entriesIter.hasNext()) {
            sql.append("", "");
        }
    }
    if (!TextUtils.isEmpty(whereClause)) {
        sql.append("" WHERE "");
        sql.append(whereClause);
    }
    lock();
    if (!isOpen()) {
        throw new IllegalStateException(""database not open"");
    }
    SQLiteStatement statement = null;
    try {
        statement = compileStatement(sql.toString());
        // Bind the values
        int size = entrySet.size();
        entriesIter = entrySet.iterator();
        int bindArg = 1;
        for (int i = 0; i < size; i++) {
            Map.Entry<String, Object> entry = entriesIter.next();
            DatabaseUtils.bindObjectToProgram(statement, bindArg, entry.getValue());
            bindArg++;
        }
        if (whereArgs != null) {
            size = whereArgs.length;
            for (int i = 0; i < size; i++) {
                statement.bindString(bindArg, whereArgs[i]);
                bindArg++;
            }
        }
        // Run the program and then cleanup
        statement.execute();
        int numChangedRows = lastChangeCount();
        if (Config.LOGD && Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""Updated "" + numChangedRows + "" using "" + values + "" and "" + sql);
        }
        return numChangedRows;
    } catch (SQLiteDatabaseCorruptException e) {
        onCorruption();
        throw e;
    } catch (SQLException e) {
        Log.e(TAG, ""Error updating "" + values + "" using "" + sql);
        throw e;
    } finally {
        if (statement != null) {
            statement.close();
        }
        unlock();
    }
}",1,"/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
","/**
 * Convenience method for updating rows in the database.
 *
 * @param table the table to update in
 * @param values a map from column names to new column values. null is a
 * valid value that will be translated to NULL.
 * @param whereClause the optional WHERE clause to apply when updating.
 * Passing null will update all rows.
 * @param conflictAlgorithm for update conflict resolver
 * @return the number of rows affected
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"A new statement, BlockGuard.getThreadPolicy().onWriteToDisk(), has been introduced at the beginning of the method, and the code depending on this BlockGuard API has changed, so the code change type is 4,5.","Since the introduced method BlockGuard.getThreadPolicy().onWriteToDisk() does not affect the return value or exception handling, the Compatibility Issue type is 0."
319,<android.view.MotionEvent: float getSize(int)>,8,9,<android.view.MotionEvent: float getSize(int)>,<android.view.MotionEvent: float getSize(int)>,0,"{
    return mDataSamples[(pointerIndex * NUM_SAMPLE_DATA) + SAMPLE_SIZE];
}","{
    return mDataSamples[mLastDataSampleIndex + pointerIndex * NUM_SAMPLE_DATA + SAMPLE_SIZE];
}",1,"/**
 * Returns a scaled value of the approximate size for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * This represents some approximation of the area of the screen being
 * pressed; the actual value in pixels corresponding to the
 * touch is normalized with the device specific range of values
 * and scaled to a value between 0 and 1. The value of size can be used to
 * determine fat touch events.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
","/**
 * Returns a scaled value of the approximate size for the given pointer
 * <em>index</em> (use {@link #getPointerId(int)} to find the pointer
 * identifier for this index).
 * This represents some approximation of the area of the screen being
 * pressed; the actual value in pixels corresponding to the
 * touch is normalized with the device specific range of values
 * and scaled to a value between 0 and 1. The value of size can be used to
 * determine fat touch events.
 * @param pointerIndex Raw index of pointer to retrieve.  Value may be from 0
 * (the first pointer that is down) to {@link #getPointerCount()}-1.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement in this method has changed from returning the value at an index of the mDataSamples array to returning the value at a different index. This involves a new computation for the index hence classifying this as both 'Return statement changed' and 'Other statement changed'. So, the code change type is 1,4.","Since the change in the logic leading to a new computation for the index will affect the eventual value returned by the method, it could lead to compatibility issues for applications assuming the behavior of the previous version. Therefore, the CI type is 1."
321,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",8,9,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>","<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",0,"{
    switch(mBluetoothState) {
        case BluetoothAdapter.STATE_OFF:
            pw.println(""Bluetooth OFF\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_ON:
            pw.println(""Bluetooth TURNING ON\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_OFF:
            pw.println(""Bluetooth TURNING OFF\n"");
            return;
        case BluetoothAdapter.STATE_ON:
            pw.println(""Bluetooth ON\n"");
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    BluetoothHeadset headset = new BluetoothHeadset(mContext, null);
    pw.println(""\n--Known devices--"");
    for (String address : mDeviceProperties.keySet()) {
        int bondState = mBondState.getBondState(address);
        pw.printf(""%s %10s (%d) %s\n"", address, toBondStateString(bondState), mBondState.getAttempt(address), getRemoteName(address));
        Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
        if (uuidChannels == null) {
            pw.println(""\tuuids = null"");
        } else {
            for (ParcelUuid uuid : uuidChannels.keySet()) {
                Integer channel = uuidChannels.get(uuid);
                if (channel == null) {
                    pw.println(""\t"" + uuid);
                } else {
                    pw.println(""\t"" + uuid + "" RFCOMM channel = "" + channel);
                }
            }
        }
        for (RemoteService service : mUuidCallbackTracker.keySet()) {
            if (service.address.equals(address)) {
                pw.println(""\tPENDING CALLBACK: "" + service.uuid);
            }
        }
    }
    String value = getProperty(""Devices"");
    String[] devicesObjectPath = null;
    if (value != null) {
        devicesObjectPath = value.split("","");
    }
    pw.println(""\n--ACL connected devices--"");
    if (devicesObjectPath != null) {
        for (String device : devicesObjectPath) {
            pw.println(getAddressFromObjectPath(device));
        }
    }
    // Rather not do this from here, but no-where else and I need this
    // dump
    pw.println(""\n--Headset Service--"");
    switch(headset.getState()) {
        case BluetoothHeadset.STATE_DISCONNECTED:
            pw.println(""getState() = STATE_DISCONNECTED"");
            break;
        case BluetoothHeadset.STATE_CONNECTING:
            pw.println(""getState() = STATE_CONNECTING"");
            break;
        case BluetoothHeadset.STATE_CONNECTED:
            pw.println(""getState() = STATE_CONNECTED"");
            break;
        case BluetoothHeadset.STATE_ERROR:
            pw.println(""getState() = STATE_ERROR"");
            break;
    }
    pw.println(""\ngetCurrentHeadset() = "" + headset.getCurrentHeadset());
    pw.println(""getBatteryUsageHint() = "" + headset.getBatteryUsageHint());
    headset.close();
    pw.println(""\n--Application Service Records--"");
    for (Integer handle : mServiceRecordToPid.keySet()) {
        Integer pid = mServiceRecordToPid.get(handle);
        pw.println(""\tpid "" + pid + "" handle "" + Integer.toHexString(handle));
    }
}","{
    switch(mBluetoothState) {
        case BluetoothAdapter.STATE_OFF:
            pw.println(""Bluetooth OFF\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_ON:
            pw.println(""Bluetooth TURNING ON\n"");
            return;
        case BluetoothAdapter.STATE_TURNING_OFF:
            pw.println(""Bluetooth TURNING OFF\n"");
            return;
        case BluetoothAdapter.STATE_ON:
            pw.println(""Bluetooth ON\n"");
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    BluetoothHeadset headset = new BluetoothHeadset(mContext, null);
    pw.println(""\n--Known devices--"");
    for (String address : mDeviceProperties.keySet()) {
        int bondState = mBondState.getBondState(address);
        pw.printf(""%s %10s (%d) %s\n"", address, toBondStateString(bondState), mBondState.getAttempt(address), getRemoteName(address));
        Map<ParcelUuid, Integer> uuidChannels = mDeviceServiceChannelCache.get(address);
        if (uuidChannels == null) {
            pw.println(""\tuuids = null"");
        } else {
            for (ParcelUuid uuid : uuidChannels.keySet()) {
                Integer channel = uuidChannels.get(uuid);
                if (channel == null) {
                    pw.println(""\t"" + uuid);
                } else {
                    pw.println(""\t"" + uuid + "" RFCOMM channel = "" + channel);
                }
            }
        }
        for (RemoteService service : mUuidCallbackTracker.keySet()) {
            if (service.address.equals(address)) {
                pw.println(""\tPENDING CALLBACK: "" + service.uuid);
            }
        }
    }
    String value = getProperty(""Devices"");
    String[] devicesObjectPath = null;
    if (value != null) {
        devicesObjectPath = value.split("","");
    }
    pw.println(""\n--ACL connected devices--"");
    if (devicesObjectPath != null) {
        for (String device : devicesObjectPath) {
            pw.println(getAddressFromObjectPath(device));
        }
    }
    // Rather not do this from here, but no-where else and I need this
    // dump
    pw.println(""\n--Headset Service--"");
    switch(headset.getState(headset.getCurrentHeadset())) {
        case BluetoothHeadset.STATE_DISCONNECTED:
            pw.println(""getState() = STATE_DISCONNECTED"");
            break;
        case BluetoothHeadset.STATE_CONNECTING:
            pw.println(""getState() = STATE_CONNECTING"");
            break;
        case BluetoothHeadset.STATE_CONNECTED:
            pw.println(""getState() = STATE_CONNECTED"");
            break;
        case BluetoothHeadset.STATE_ERROR:
            pw.println(""getState() = STATE_ERROR"");
            break;
    }
    pw.println(""\ngetCurrentHeadset() = "" + headset.getCurrentHeadset());
    pw.println(""getBatteryUsageHint() = "" + headset.getBatteryUsageHint());
    headset.close();
    pw.println(""\n--Application Service Records--"");
    for (Integer handle : mServiceRecordToPid.keySet()) {
        Integer pid = mServiceRecordToPid.get(handle);
        pw.println(""\tpid "" + pid + "" handle "" + Integer.toHexString(handle));
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,5",1,"The method invocation in the switch-case statements has changed from ""headset.getState()"" to ""headset.getState(headset.getCurrentHeadset())"". This change reflects changes in control dependencies and the change in dependent APIs, hence the code change type is 3,5.","As the condition in the switch case changes due to the change in dependent API invocation, the switch-case statements could run differently. Moreover, the late version API could potentially return different values in 'println' and different print represents different operating status of the devices. Therefore, the CI type is 1."
