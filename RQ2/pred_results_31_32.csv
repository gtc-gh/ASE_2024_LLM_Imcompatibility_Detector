Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
0,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",31,32,"<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>","<android.hardware.camera2.impl.CameraMetadataNative: void set(Key<T>,T)>",0,"{
    set(key.getNativeKey(), value);
}","{
    SetCommand s = sSetCommandMap.get(key);
    if (s != null) {
        s.setValue(this, value);
        return;
    }
    setBase(key, value);
}",1,,"/**
 * Set a camera metadata field to a value. The field definitions can be
 * found in {@link CameraCharacteristics}, {@link CaptureResult}, and
 * {@link CaptureRequest}.
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5",1,"The early version calls set() directly, while the late version checks the sSetCommandMap for a SetCommand associated with the key and conditionally calls a different method (otherwise falls back to setBase()). This means there is a change in control dependency, other statements are added, and the implementation relies on a new or modified dependent API (sSetCommandMap and SetCommand.setValue). Therefore, the code change types are 3, 4, and 5.","There's a potential for a different behavior due to the new control flow and different method being called for setting the value. Depending on whether the SetCommand exists in sSetCommandMap, a different method (setValue or setBase) might be used, potentially leading to different side effects, validation, or processing. Consequently, the change could lead to a different result (e.g., different internal state, errors, etc.), which signifies a Compatibility Issue of type 1."
1,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",31,32,"<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>","<android.view.View: boolean startDragAndDrop(ClipData,DragShadowBuilder,Object,int)>",0,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        // repurpose 'shadowSize' for the last touch point
        root.getLastTouchPoint(shadowSize);
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDragAndDrop: data="" + data + "" flags="" + flags);
    }
    if (mAttachInfo == null) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called on a detached view."");
        return false;
    }
    if (!mAttachInfo.mViewRootImpl.mSurface.isValid()) {
        Log.w(VIEW_LOG_TAG, ""startDragAndDrop called with an invalid surface."");
        return false;
    }
    if (data != null) {
        data.prepareToLeaveProcess((flags & View.DRAG_FLAG_GLOBAL) != 0);
    }
    Rect bounds = new Rect();
    getBoundsOnScreen(bounds, true);
    Point lastTouchPoint = new Point();
    mAttachInfo.mViewRootImpl.getLastTouchPoint(lastTouchPoint);
    final ViewRootImpl root = mAttachInfo.mViewRootImpl;
    // Skip surface logic since shadows and animation are not required during the a11y drag
    final boolean a11yEnabled = AccessibilityManager.getInstance(mContext).isEnabled();
    if (a11yEnabled && (flags & View.DRAG_FLAG_ACCESSIBILITY_ACTION) != 0) {
        try {
            IBinder token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, null, mAttachInfo.mViewRootImpl.getLastTouchSource(), 0f, 0f, 0f, 0f, data);
            if (ViewDebug.DEBUG_DRAG) {
                Log.d(VIEW_LOG_TAG, ""startDragAndDrop via a11y action returned "" + token);
            }
            if (token != null) {
                root.setLocalDragState(myLocalState);
                mAttachInfo.mDragToken = token;
                mAttachInfo.mViewRootImpl.setDragStartedViewForAccessibility(this);
                setAccessibilityDragStarted(true);
            }
            return token != null;
        } catch (Exception e) {
            Log.e(VIEW_LOG_TAG, ""Unable to initiate a11y drag"", e);
            return false;
        }
    }
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    // does not accept zero size surface.
    if (shadowSize.x == 0 || shadowSize.y == 0) {
        if (!sAcceptZeroSizeDragShadow) {
            throw new IllegalStateException(""Drag shadow dimensions must be positive"");
        }
        shadowSize.x = 1;
        shadowSize.y = 1;
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    final SurfaceSession session = new SurfaceSession();
    final SurfaceControl surfaceControl = new SurfaceControl.Builder(session).setName(""drag surface"").setParent(root.getSurfaceControl()).setBufferSize(shadowSize.x, shadowSize.y).setFormat(PixelFormat.TRANSLUCENT).setCallsite(""View.startDragAndDrop"").build();
    final Surface surface = new Surface();
    surface.copyFrom(surfaceControl);
    IBinder token = null;
    try {
        final Canvas canvas = isHardwareAccelerated() ? surface.lockHardwareCanvas() : surface.lockCanvas(null);
        try {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
            shadowBuilder.onDrawShadow(canvas);
        } finally {
            surface.unlockCanvasAndPost(canvas);
        }
        token = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, flags, surfaceControl, root.getLastTouchSource(), lastTouchPoint.x, lastTouchPoint.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
        if (ViewDebug.DEBUG_DRAG) {
            Log.d(VIEW_LOG_TAG, ""performDrag returned "" + token);
        }
        if (token != null) {
            if (mAttachInfo.mDragSurface != null) {
                mAttachInfo.mDragSurface.release();
            }
            mAttachInfo.mDragSurface = surface;
            mAttachInfo.mDragToken = token;
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            if (a11yEnabled) {
                // Set for AccessibilityEvents
                mAttachInfo.mViewRootImpl.setDragStartedViewForAccessibility(this);
            }
        }
        return token != null;
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        return false;
    } finally {
        if (token == null) {
            surface.destroy();
        }
        session.kill();
    }
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke {@link #startDragAndDrop(ClipData, DragShadowBuilder, Object,
 * int) startDragAndDrop()} on any attached View object. The View object does not need to be
 * the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to be related
 * to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. When dispatching drag events to views in the same activity this object
 * will be available through {@link android.view.DragEvent#getLocalState()}. Views in other
 * activities will not have access to this data ({@link android.view.DragEvent#getLocalState()}
 * will return null).
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. This can be set to 0 for no
 * flags, or any combination of the following:
 * <ul>
 * <li>{@link #DRAG_FLAG_GLOBAL}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_READ}</li>
 * <li>{@link #DRAG_FLAG_GLOBAL_URI_WRITE}</li>
 * <li>{@link #DRAG_FLAG_OPAQUE}</li>
 * <li>{@link #DRAG_FLAG_ACCESSIBILITY_ACTION}</li>
 * </ul>
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag because of another ongoing operation or some other reasons.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
3,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,31,32,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,<android.hardware.camera2.CameraCharacteristics: T get(Key<T>)>,0,"{
    return mProperties.get(key);
}","{
    T propertyOverride = overrideProperty(key);
    return (propertyOverride != null) ? propertyOverride : mProperties.get(key);
}",1,"/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
","/**
 * Get a camera characteristics field value.
 *
 * <p>The field definitions can be
 * found in {@link CameraCharacteristics}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The characteristics field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */
",-1,[@Nullable],[@Nullable],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version of the implementation has a new method call and conditional statement that checks for property override, so code change types are 1 for the return statement changed due to the ternary operator and 3 for the new control dependency introduced by the conditional statement.","The addition of conditional logic to check for a potentially overridden property means the API may return a different value in the new version, leading to a Compatibility Issue of type 1 for differing return values."
4,<android.view.View: View getRootView()>,31,32,<android.view.View: View getRootView()>,<android.view.View: View getRootView()>,0,"{
    if (mAttachInfo != null) {
        final View v = mAttachInfo.mRootView;
        if (v != null) {
            return v;
        }
    }
    View parent = this;
    while (parent.mParent != null && parent.mParent instanceof View) {
        parent = (View) parent.mParent;
    }
    return parent;
}","{
    if (mAttachInfo != null) {
        final View v = mAttachInfo.mRootView;
        if (v != null) {
            return v;
        }
    }
    View parent = this;
    while (parent.mParent instanceof View) {
        parent = (View) parent.mParent;
    }
    return parent;
}",1,"/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
","/**
 * <p>Finds the topmost view in the current view hierarchy.</p>
 *
 * @return the topmost view containing this view
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change is seen in the condition within the while loop, which was previously checking both that the parent is not null and that it is an instance of View, whereas the latter version only checks if the parent is an instance of View. The control dependency has changed as this potentially affects the loop's execution.","Despite the change in the control loop condition, there is no Compatibility Issue since in Java null is not an instance of any class, and therefore the condition 'parent.mParent instanceof View' inherently checks for non-nullity. As such, the loop will have the same behavior, iterating until 'parent' is the root View, just as in the former version."
5,"<android.window.SplashScreenView: void initIconAnimation(Drawable,long)>",31,32,"<android.window.SplashScreenView: void initIconAnimation(Drawable,long)>","<android.window.SplashScreenView: void initIconAnimation(Drawable,long)>",0,"{
    if (!(iconDrawable instanceof IconAnimateListener)) {
        return;
    }
    IconAnimateListener aniDrawable = (IconAnimateListener) iconDrawable;
    aniDrawable.prepareAnimate(duration, this::animationStartCallback);
}","{
    if (!(iconDrawable instanceof IconAnimateListener)) {
        return;
    }
    IconAnimateListener aniDrawable = (IconAnimateListener) iconDrawable;
    aniDrawable.prepareAnimate(duration, this::animationStartCallback);
    aniDrawable.setAnimationJankMonitoring(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationCancel(Animator animation) {
            InteractionJankMonitor.getInstance().cancel(CUJ_SPLASHSCREEN_AVD);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            InteractionJankMonitor.getInstance().end(CUJ_SPLASHSCREEN_AVD);
        }

        @Override
        public void onAnimationStart(Animator animation) {
            InteractionJankMonitor.getInstance().begin(SplashScreenView.this, CUJ_SPLASHSCREEN_AVD);
        }
    });
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method implementation in the late version added additional calls to set up animation jank monitoring with onAnimationCancel, onAnimationEnd, and onAnimationStart methods, so the code change type is 4.","The added code is related to monitoring animations and does not affect the existing functionality or behavior of the return values or exception handling of the method, therefore, there are no Compatibility Issues expected from this change."
6,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",31,32,"<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>","<android.app.ContextImpl: ContextImpl createSystemUiContext(ContextImpl,int)>",0,"{
    final LoadedApk packageInfo = systemContext.mPackageInfo;
    ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, null);
    context.setResources(createResources(null, packageInfo, null, displayId, null, packageInfo.getCompatibilityInfo(), null));
    context.updateDisplay(displayId);
    context.mContextType = CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI;
    return context;
}","{
    final WindowTokenClient token = new WindowTokenClient();
    final ContextImpl context = systemContext.createWindowContextBase(token, displayId);
    token.attachContext(context);
    token.attachToDisplayContent(displayId);
    context.mContextType = CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI;
    context.mOwnsToken = true;
    return context;
}",1,"/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
","/**
 * System Context to be used for UI. This Context has resources that can be themed.
 * Make sure that the created system UI context shares the same LoadedApk as the system context.
 * @param systemContext The system context which created by
 * {@link #createSystemContext(ActivityThread)}.
 * @param displayId The ID of the display where the UI is shown.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The late implementation changed by introducing new method calls (new WindowTokenClient(), createWindowContextBase(), token.attachContext(), token.attachToDisplayContent()) and setting additional properties on the context (context.mOwnsToken = true). Control structures have not changed, but the method of constructing the ContextImpl as well as its initialization significantly differs, reflecting both a control dependency change due to the new object and method invocations as well as other statement changes.","Due to the introduction of a new way to create and initialize the ContextImpl, there is a potential for the returned ContextImpl object to behave differently, thus leading to a Compatibility Issue type 1."
7,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int submitBurst(List<Request>,IRequestCallback)>",31,32,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int submitBurst(List<Request>,IRequestCallback)>","<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int submitBurst(List<Request>,IRequestCallback)>",0,"{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        try {
            CaptureCallbackHandler captureCallback = new CaptureCallbackHandler(callback);
            ArrayList<CaptureRequest> captureRequests = new ArrayList<>();
            for (Request request : requests) {
                captureRequests.add(initializeCaptureRequest(mCameraDevice, request, mCameraConfigMap));
            }
            seqId = mCaptureSession.captureBurstRequests(captureRequests, new CameraExtensionUtils.HandlerExecutor(mHandler), captureCallback);
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed to submit capture requests!"");
        } catch (IllegalStateException e) {
            Log.e(TAG, ""Capture session closed!"");
        }
    }
    return seqId;
}","{
    int seqId = -1;
    try {
        CaptureCallbackHandler captureCallback = new CaptureCallbackHandler(callback);
        ArrayList<CaptureRequest> captureRequests = new ArrayList<>();
        for (Request request : requests) {
            captureRequests.add(initializeCaptureRequest(mCameraDevice, request, mCameraConfigMap));
        }
        seqId = mCaptureSession.captureBurstRequests(captureRequests, new CameraExtensionUtils.HandlerExecutor(mHandler), captureCallback);
    } catch (CameraAccessException e) {
        Log.e(TAG, ""Failed to submit capture requests!"");
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Capture session closed!"");
    }
    return seqId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,The synchronized block around the try-catch block has been removed so the code change type is 3.,"The removal of the `synchronized` statement does not directly affect the control flow related to the return values or the exceptions being thrown. It only affects the thread-safety of the method but does not result in a change in behavior in terms of the API contract. Therefore, there is no Compatibility Issue (CI type is 0) arising from this change in a single-threaded context or if the callers always synchronize externally. Compatibility issues related to thread-safety are not considered here as per the given definitions."
8,"<android.app.Service: void startForeground(int,Notification)>",31,32,"<android.app.Service: void startForeground(int,Notification)>","<android.app.Service: void startForeground(int,Notification)>",0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0, FOREGROUND_SERVICE_TYPE_MANIFEST);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0, FOREGROUND_SERVICE_TYPE_MANIFEST);
        clearStartForegroundServiceStackTrace();
    } catch (RemoteException ex) {
    }
}",1,"/**
 * If your service is started (running through {@link Context#startService(Intent)}), then
 * also make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default started services are background, meaning that their process won't be given
 * foreground CPU scheduling (unless something else in that process is foreground) and,
 * if the system needs to kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You use
 * {@link #startForeground} if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>Note that calling this method does <em>not</em> put the service in the started state
 * itself, even though the name sounds like it.  You must always call
 * {@link #startService(Intent)} first to tell the system it should keep the service running,
 * and then use this method to tell it to keep it running harder.</p>
 *
 * <p>Apps targeting API {@link android.os.Build.VERSION_CODES#P} or later must request
 * the permission {@link android.Manifest.permission#FOREGROUND_SERVICE} in order to use
 * this API.</p>
 *
 * <p>Apps built with SDK version {@link android.os.Build.VERSION_CODES#Q} or later can specify
 * the foreground service types using attribute {@link android.R.attr#foregroundServiceType} in
 * service element of manifest file. The value of attribute
 * {@link android.R.attr#foregroundServiceType} can be multiple flags ORed together.</p>
 *
 * <div class=""caution"">
 * <p><strong>Note:</strong>
 * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},
 * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}
 * or higher are not allowed to start foreground services from the background.
 * See
 * <a href=""{@docRoot}/about/versions/12/behavior-changes-12"">
 * Behavior changes: Apps targeting Android 12
 * </a>
 * for more details.
 * </div>
 *
 * @throws ForegroundServiceStartNotAllowedException
 * If the app targeting API is
 * {@link android.os.Build.VERSION_CODES#S} or later, and the service is restricted from
 * becoming foreground service due to background restriction.
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
","/**
 * If your service is started (running through {@link Context#startService(Intent)}), then
 * also make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default started services are background, meaning that their process won't be given
 * foreground CPU scheduling (unless something else in that process is foreground) and,
 * if the system needs to kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You use
 * {@link #startForeground} if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>Note that calling this method does <em>not</em> put the service in the started state
 * itself, even though the name sounds like it.  You must always call
 * {@link #startService(Intent)} first to tell the system it should keep the service running,
 * and then use this method to tell it to keep it running harder.</p>
 *
 * <p>Apps targeting API {@link android.os.Build.VERSION_CODES#P} or later must request
 * the permission {@link android.Manifest.permission#FOREGROUND_SERVICE} in order to use
 * this API.</p>
 *
 * <p>Apps built with SDK version {@link android.os.Build.VERSION_CODES#Q} or later can specify
 * the foreground service types using attribute {@link android.R.attr#foregroundServiceType} in
 * service element of manifest file. The value of attribute
 * {@link android.R.attr#foregroundServiceType} can be multiple flags ORed together.</p>
 *
 * <div class=""caution"">
 * <p><strong>Note:</strong>
 * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},
 * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}
 * or higher are not allowed to start foreground services from the background.
 * See
 * <a href=""{@docRoot}/about/versions/12/behavior-changes-12"">
 * Behavior changes: Apps targeting Android 12
 * </a>
 * for more details.
 * </div>
 *
 * @throws ForegroundServiceStartNotAllowedException
 * If the app targeting API is
 * {@link android.os.Build.VERSION_CODES#S} or later, and the service is restricted from
 * becoming foreground service due to background restriction.
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The change consists of the addition of a new method call clearStartForegroundServiceStackTrace() after the existing method call to setServiceForeground() inside the try block. This falls under ""Other statement changed,"" which is 4.","Since the newly introduced method call doesn't affect the behavior of the API in terms of returned values or exceptions (it seems additional internal state management or cleanup), there are no Compatibility Issues with respect to different returns or exception handling, so the CI type is 0."
10,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void abortCaptures()>,31,32,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void abortCaptures()>,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void abortCaptures()>,0,"{
    synchronized (mInterfaceLock) {
        try {
            mCaptureSession.abortCaptures();
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed during capture abort!"");
        } catch (IllegalStateException e) {
            Log.e(TAG, ""Capture session closed!"");
        }
    }
}","{
    try {
        mCaptureSession.abortCaptures();
    } catch (CameraAccessException e) {
        Log.e(TAG, ""Failed during capture abort!"");
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Capture session closed!"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The 'synchronized' block has been removed in the late implementation which is a control dependency change, so the code change type is 3. Removal of synchronization does not directly affect the functional behavior of abortCaptures() in terms of the outcome of the method call which still handles the exceptions in the same way as before.","There is no change in the potential behavior of return values or the exceptions thrown, thus no Compatibility Issue arises and the CI type is 0. The change does not affect what the method returns nor the exceptions it may throw, it only affects the synchronization of threads when calling this method."
16,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,31,32,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,<android.view.MotionEvent.PointerCoords: float getAxisValue(int)>,0,"{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                return mPackedAxisValues[index];
            }
    }
}","{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        case AXIS_RELATIVE_X:
            return relativeX;
        case AXIS_RELATIVE_Y:
            return relativeY;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                return mPackedAxisValues[index];
            }
    }
}",1,"/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
","/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"Two additional case statements for AXIS_RELATIVE_X and AXIS_RELATIVE_Y are added to the switch construct, which accounts for other statement changes (code change type 4).","The introduction of new case statements for handling additional axes does not change the behavior for any previously supported axes; it merely extends support to new types of axes. This means existing code that does not make use of the new axes will behave identically before and after the change, and hence there is no compatibility issue (CI type 0) for the already supported axes."
19,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,31,32,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,<android.hardware.camera2.CameraManager: CameraCharacteristics getCameraCharacteristics(String)>,0,"{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId, mContext.getApplicationInfo().targetSdkVersion);
            try {
                info.setCameraId(Integer.parseInt(cameraId));
            } catch (NumberFormatException e) {
                Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
            }
            boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
            info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
            info.setDisplaySize(displaySize);
            Map<String, StreamConfiguration[]> multiResolutionSizeMap = getPhysicalCameraMultiResolutionConfigs(cameraId, info, cameraService);
            if (multiResolutionSizeMap.size() > 0) {
                info.setMultiResolutionStreamConfigurationMap(multiResolutionSizeMap);
            }
            characteristics = new CameraCharacteristics(info);
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    return characteristics;
}","{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException(""No cameras available on device"");
    }
    synchronized (mLock) {
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"");
        }
        try {
            Size displaySize = getDisplaySize();
            CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId, mContext.getApplicationInfo().targetSdkVersion);
            try {
                info.setCameraId(Integer.parseInt(cameraId));
            } catch (NumberFormatException e) {
                Log.v(TAG, ""Failed to parse camera Id "" + cameraId + "" to integer"");
            }
            boolean hasConcurrentStreams = CameraManagerGlobal.get().cameraIdHasConcurrentStreamsLocked(cameraId);
            info.setHasMandatoryConcurrentStreams(hasConcurrentStreams);
            info.setDisplaySize(displaySize);
            Map<String, StreamConfiguration[]> multiResolutionSizeMap = getPhysicalCameraMultiResolutionConfigs(cameraId, info, cameraService);
            if (multiResolutionSizeMap.size() > 0) {
                info.setMultiResolutionStreamConfigurationMap(multiResolutionSizeMap);
            }
            characteristics = new CameraCharacteristics(info);
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, ""Camera service is currently unavailable"", e);
        }
    }
    registerDeviceStateListener(characteristics);
    return characteristics;
}",1,"/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
","/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * <p>From API level 29, this function can also be used to query the capabilities of physical
 * cameras that can only be used as part of logical multi-camera. These cameras cannot be
 * opened directly via {@link #openCamera}</p>
 *
 * <p>Also starting with API level 29, while most basic camera information is still available
 * even without the CAMERA permission, some values are not available to apps that do not hold
 * that permission. The keys not available are listed by
 * {@link CameraCharacteristics#getKeysNeedingPermission}.</p>
 *
 * @param cameraId The id of the camera device to query. This could be either a standalone
 * camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 * can only used as part of a logical multi-camera.
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,4,0,"The new method call registerDeviceStateListener(characteristics) has been added before the return statement, which is classified as other statement change, code change type 4.","The addition of the method call registerDeviceStateListener(characteristics) does not affect the return value nor does it change exception handling. Thus, there is no Compatibility Issue, so the CI type is 0."
20,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,31,32,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,<android.inputmethodservice.IInputMethodWrapper: void executeMessage(Message)>,0,"{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, msg.arg1, (IInputMethodPrivilegedOperations) args.arg2, (int) args.arg3);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    InputMethod inputMethod = mInputMethod.get();
    // Need a valid reference to the inputMethod for everything except a dump.
    if (inputMethod == null && msg.what != DO_DUMP) {
        Log.w(TAG, ""Input method reference was null, ignoring message: "" + msg.what);
        return;
    }
    switch(msg.what) {
        case DO_DUMP:
            {
                AbstractInputMethodService target = mTarget.get();
                if (target == null) {
                    return;
                }
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    target.dump((FileDescriptor) args.arg1, (PrintWriter) args.arg2, (String[]) args.arg3);
                } catch (RuntimeException e) {
                    ((PrintWriter) args.arg2).println(""Exception: "" + e);
                }
                synchronized (args.arg4) {
                    ((CountDownLatch) args.arg4).countDown();
                }
                args.recycle();
                return;
            }
        case DO_INITIALIZE_INTERNAL:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    inputMethod.initializeInternal((IBinder) args.arg1, (IInputMethodPrivilegedOperations) args.arg2, msg.arg1);
                } finally {
                    args.recycle();
                }
                return;
            }
        case DO_SET_INPUT_CONTEXT:
            {
                inputMethod.bindInput((InputBinding) msg.obj);
                return;
            }
        case DO_UNSET_INPUT_CONTEXT:
            inputMethod.unbindInput();
            return;
        case DO_START_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                final IBinder startInputToken = (IBinder) args.arg1;
                final IInputContext inputContext = (IInputContext) args.arg2;
                final EditorInfo info = (EditorInfo) args.arg3;
                final CancellationGroup cancellationGroup = (CancellationGroup) args.arg4;
                SomeArgs moreArgs = (SomeArgs) args.arg5;
                final InputConnection ic = inputContext != null ? new InputConnectionWrapper(mTarget, inputContext, moreArgs.argi3, cancellationGroup) : null;
                info.makeCompatible(mTargetSdkVersion);
                inputMethod.dispatchStartInputWithToken(ic, info, moreArgs.argi1 == 1, /* restarting */
                startInputToken);
                args.recycle();
                moreArgs.recycle();
                return;
            }
        case DO_CREATE_SESSION:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.createSession(new InputMethodSessionCallbackWrapper(mContext, (InputChannel) args.arg1, (IInputSessionCallback) args.arg2));
                args.recycle();
                return;
            }
        case DO_SET_SESSION_ENABLED:
            inputMethod.setSessionEnabled((InputMethodSession) msg.obj, msg.arg1 != 0);
            return;
        case DO_REVOKE_SESSION:
            inputMethod.revokeSession((InputMethodSession) msg.obj);
            return;
        case DO_SHOW_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.showSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_HIDE_SOFT_INPUT:
            {
                final SomeArgs args = (SomeArgs) msg.obj;
                inputMethod.hideSoftInputWithToken(msg.arg1, (ResultReceiver) args.arg2, (IBinder) args.arg1);
                args.recycle();
                return;
            }
        case DO_CHANGE_INPUTMETHOD_SUBTYPE:
            inputMethod.changeInputMethodSubtype((InputMethodSubtype) msg.obj);
            return;
        case DO_CREATE_INLINE_SUGGESTIONS_REQUEST:
            final SomeArgs args = (SomeArgs) msg.obj;
            inputMethod.onCreateInlineSuggestionsRequest((InlineSuggestionsRequestInfo) args.arg1, (IInlineSuggestionsRequestCallback) args.arg2);
            args.recycle();
            return;
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,,,,
22,<android.app.ActivityThread.ProviderKey: int hashCode()>,31,32,<android.app.ActivityThread.ProviderKey: int hashCode()>,<android.app.ActivityThread.ProviderKey: int hashCode()>,0,"{
    return hashCode(authority, userId);
}","{
    return ((authority != null) ? authority.hashCode() : 0) ^ userId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The implementation of the hashCode() method has been changed from invoking a method call with the parameters (authority, userId) to directly computing the hash code within the method body using a ternary operator and bitwise XOR. Since this change affects how the hash code is calculated, this is classified under ""Other statement changed"" and ""Return statement changed.""","The hash code computation logic has been altered, which means that the same input (authority, userId) could result in a different hash code value being returned in the late version as compared to the early version. Consequently, this change is a potential Compatibility Issue caused by potential different return values (type 1)."
23,<android.accessibilityservice.AccessibilityService: Object getSystemService(String)>,31,32,<android.accessibilityservice.AccessibilityService: Object getSystemService(String)>,<android.accessibilityservice.AccessibilityService: Object getSystemService(String)>,0,"{
    if (getBaseContext() == null) {
        throw new IllegalStateException(""System services not available to Activities before onCreate()"");
    }
    // Guarantee that we always return the same window manager instance.
    if (WINDOW_SERVICE.equals(name)) {
        if (mWindowManager == null) {
            mWindowManager = (WindowManager) getBaseContext().getSystemService(name);
        }
        return mWindowManager;
    }
    return super.getSystemService(name);
}","{
    if (getBaseContext() == null) {
        throw new IllegalStateException(""System services not available to Activities before onCreate()"");
    }
    // Guarantee that we always return the same window manager instance.
    if (WINDOW_SERVICE.equals(name)) {
        if (mWindowManager == null) {
            mWindowManager = (WindowManager) getBaseContext().getSystemService(name);
            final WindowManagerImpl wm = (WindowManagerImpl) mWindowManager;
            // Set e default token obtained from the connection to ensure client could use
            // accessibility overlay.
            wm.setDefaultToken(mWindowToken);
        }
        return mWindowManager;
    }
    return super.getSystemService(name);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"A new assignment statement (`wm.setDefaultToken(mWindowToken);`) is introduced, but it does not alter the type or value of the returned object, `mWindowManager`, thus the code change type is 4.","As the additional statement (`wm.setDefaultToken(mWindowToken);`) does not affect the return value or throw a new exception, there is no Compatibility Issue introduced with this change."
24,<android.app.ActivityThread.H: void handleMessage(Message)>,31,32,<android.app.ActivityThread.H: void handleMessage(Message)>,<android.app.ActivityThread.H: void handleMessage(Message)>,0,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            mConfigurationController.handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case DUMP_GFXINFO:
            handleDumpGfxInfo((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            throwRemoteServiceException((String) msg.obj, msg.arg1);
            break;
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
        case UPDATE_UI_TRANSLATION_STATE:
            final SomeArgs args = (SomeArgs) msg.obj;
            updateUiTranslationState((IBinder) args.arg1, (int) args.arg2, (TranslationSpec) args.arg3, (TranslationSpec) args.arg4, (List<AutofillId>) args.arg5, (UiTranslationSpec) args.arg6);
            break;
        case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
            handleSetContentCaptureOptionsCallback((String) msg.obj);
            break;
        case INSTRUMENT_WITHOUT_RESTART:
            handleInstrumentWithoutRestart((AppBindData) msg.obj);
            break;
        case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
            handleFinishInstrumentationWithoutRestart();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + codeToString(msg.what));
    switch(msg.what) {
        case BIND_APPLICATION:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""bindApplication"");
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case RECEIVER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastReceiveComp"");
            handleReceiver((ReceiverData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CREATE_SERVICE:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceCreate: "" + String.valueOf(msg.obj)));
            }
            handleCreateService((CreateServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case BIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceBind"");
            handleBindService((BindServiceData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UNBIND_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceUnbind"");
            handleUnbindService((BindServiceData) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SERVICE_ARGS:
            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (""serviceStart: "" + String.valueOf(msg.obj)));
            }
            handleServiceArgs((ServiceArgsData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case STOP_SERVICE:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""serviceStop"");
            handleStopService((IBinder) msg.obj);
            schedulePurgeIdler();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case CONFIGURATION_CHANGED:
            mConfigurationController.handleConfigurationChanged((Configuration) msg.obj);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case DUMP_GFXINFO:
            handleDumpGfxInfo((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""lowMemory"");
            handleLowMemory();
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerInfo) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupCreateAgent"");
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DESTROY_BACKUP_AGENT:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""backupDestroyAgent"");
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""providerRemove"");
            completeRemoveProvider((ProviderRefCount) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""broadcastPackage"");
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case SCHEDULE_CRASH:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                String message = (String) args.arg1;
                Bundle extras = (Bundle) args.arg2;
                args.recycle();
                throwRemoteServiceException(message, msg.arg1, extras);
                break;
            }
        case DUMP_HEAP:
            handleDumpHeap((DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case DUMP_PROVIDER:
            handleDumpProvider((DumpComponentInfo) msg.obj);
            break;
        case SET_CORE_SETTINGS:
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""setCoreSettings"");
            handleSetCoreSettings((Bundle) msg.obj);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case UNSTABLE_PROVIDER_DIED:
            handleUnstableProviderDied((IBinder) msg.obj, false);
            break;
        case REQUEST_ASSIST_CONTEXT_EXTRAS:
            handleRequestAssistContextExtras((RequestAssistContextExtras) msg.obj);
            break;
        case TRANSLUCENT_CONVERSION_COMPLETE:
            handleTranslucentConversionComplete((IBinder) msg.obj, msg.arg1 == 1);
            break;
        case INSTALL_PROVIDER:
            handleInstallProvider((ProviderInfo) msg.obj);
            break;
        case ON_NEW_ACTIVITY_OPTIONS:
            Pair<IBinder, ActivityOptions> pair = (Pair<IBinder, ActivityOptions>) msg.obj;
            onNewActivityOptions(pair.first, pair.second);
            break;
        case ENTER_ANIMATION_COMPLETE:
            handleEnterAnimationComplete((IBinder) msg.obj);
            break;
        case START_BINDER_TRACKING:
            handleStartBinderTracking();
            break;
        case STOP_BINDER_TRACKING_AND_DUMP:
            handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);
            break;
        case LOCAL_VOICE_INTERACTION_STARTED:
            handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);
            break;
        case ATTACH_AGENT:
            {
                Application app = getApplication();
                handleAttachAgent((String) msg.obj, app != null ? app.mLoadedApk : null);
                break;
            }
        case APPLICATION_INFO_CHANGED:
            handleApplicationInfoChanged((ApplicationInfo) msg.obj);
            break;
        case RUN_ISOLATED_ENTRY_POINT:
            handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1, (String[]) ((SomeArgs) msg.obj).arg2);
            break;
        case EXECUTE_TRANSACTION:
            final ClientTransaction transaction = (ClientTransaction) msg.obj;
            mTransactionExecutor.execute(transaction);
            if (isSystem()) {
                // Client transactions inside system process are recycled on the client side
                // instead of ClientLifecycleManager to avoid being cleared before this
                // message is handled.
                transaction.recycle();
            }
            // TODO(lifecycler): Recycle locally scheduled transactions.
            break;
        case RELAUNCH_ACTIVITY:
            handleRelaunchActivityLocally((IBinder) msg.obj);
            break;
        case PURGE_RESOURCES:
            schedulePurgeIdler();
            break;
        case ATTACH_STARTUP_AGENTS:
            handleAttachStartupAgents((String) msg.obj);
            break;
        case UPDATE_UI_TRANSLATION_STATE:
            final SomeArgs args = (SomeArgs) msg.obj;
            updateUiTranslationState((IBinder) args.arg1, (int) args.arg2, (TranslationSpec) args.arg3, (TranslationSpec) args.arg4, (List<AutofillId>) args.arg5, (UiTranslationSpec) args.arg6);
            break;
        case SET_CONTENT_CAPTURE_OPTIONS_CALLBACK:
            handleSetContentCaptureOptionsCallback((String) msg.obj);
            break;
        case INSTRUMENT_WITHOUT_RESTART:
            handleInstrumentWithoutRestart((AppBindData) msg.obj);
            break;
        case FINISH_INSTRUMENTATION_WITHOUT_RESTART:
            handleFinishInstrumentationWithoutRestart();
            break;
    }
    Object obj = msg.obj;
    if (obj instanceof SomeArgs) {
        ((SomeArgs) obj).recycle();
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + codeToString(msg.what));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
25,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,31,32,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,<android.service.wallpaper.WallpaperService.Engine: void notifyColorsChanged()>,0,"{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors, mDisplay.getDisplayId());
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
        resetWindowPages();
        processLocalColors(mPendingXOffset, mPendingXOffsetStep);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}","{
    final long now = mClockFunction.get();
    if (now - mLastColorInvalidation < NOTIFY_COLORS_RATE_LIMIT_MS) {
        Log.w(TAG, ""This call has been deferred. You should only call "" + ""notifyColorsChanged() once every "" + (NOTIFY_COLORS_RATE_LIMIT_MS / 1000f) + "" seconds."");
        if (!mHandler.hasCallbacks(mNotifyColorsChanged)) {
            mHandler.postDelayed(mNotifyColorsChanged, NOTIFY_COLORS_RATE_LIMIT_MS);
        }
        return;
    }
    mLastColorInvalidation = now;
    mHandler.removeCallbacks(mNotifyColorsChanged);
    try {
        final WallpaperColors newColors = onComputeColors();
        if (mConnection != null) {
            mConnection.onWallpaperColorsChanged(newColors, mDisplay.getDisplayId());
        } else {
            Log.w(TAG, ""Can't notify system because wallpaper connection "" + ""was not established."");
        }
        mResetWindowPages = true;
        processLocalColors(mPendingXOffset, mPendingXOffsetStep);
    } catch (RemoteException e) {
        Log.w(TAG, ""Can't notify system because wallpaper connection was lost."", e);
    }
}",1,"/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
","/**
 * Notifies the engine that wallpaper colors changed significantly.
 * This will trigger a {@link #onComputeColors()} call.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The method `resetWindowPages()` is replaced by setting `mResetWindowPages` flag to `true`. This is an internal state change and does not affect the external behavior of the API. There is no change in return types, thrown exceptions, or control flow. Thus, the change type is 4.","There are no changes in the API's external behavior, such as return values, control flow, or the thrown exceptions. The implementation detail changed, but this does not lead to a Compatibility Issue according to the abstract behavior contract of the method. Hence, there is no Compatibility Issue."
26,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,31,32,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,0,"{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                Engine engine = onCreateEngine();
                mEngine = engine;
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    engine.detach();
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_ZOOM:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_SCALE_PREVIEW:
            mEngine.scalePreview((Rect) message.obj);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    WallpaperColors colors = mEngine.onComputeColors();
                    mEngine.setPrimaryWallpaperColors(colors);
                    mConnection.onWallpaperColorsChanged(colors, mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    if (mDetached.get()) {
        if (mActiveEngines.contains(mEngine)) {
            doDetachEngine();
        }
        return;
    }
    switch(message.what) {
        case DO_ATTACH:
            {
                Engine engine = onCreateEngine();
                mEngine = engine;
                try {
                    mConnection.attachEngine(this, mDisplayId);
                } catch (RemoteException e) {
                    engine.detach();
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                doDetachEngine();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case DO_SET_DISPLAY_PADDING:
            {
                mEngine.doDisplayPaddingChanged((Rect) message.obj);
                return;
            }
        case DO_IN_AMBIENT_MODE:
            {
                mEngine.doAmbientModeChanged(message.arg1 != 0, (Long) message.obj);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_ZOOM:
            mEngine.setZoom(Float.intBitsToFloat(message.arg1));
            break;
        case MSG_SCALE_PREVIEW:
            mEngine.scalePreview((Rect) message.obj);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
                mEngine.scaleAndCropScreenshot();
            }
            break;
        case MSG_WINDOW_MOVED:
            {
            // Do nothing. What does it mean for a Wallpaper to move?
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        case MSG_REQUEST_WALLPAPER_COLORS:
            {
                if (mConnection == null) {
                    break;
                }
                try {
                    WallpaperColors colors = mEngine.onComputeColors();
                    mEngine.setPrimaryWallpaperColors(colors);
                    mConnection.onWallpaperColorsChanged(colors, mDisplayId);
                } catch (RemoteException e) {
                // Connection went away, nothing to do in here.
                }
            }
            break;
        case MSG_REPORT_SHOWN:
            {
                reportShown();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
31,<android.service.wallpaper.WallpaperService.Engine: void doCommand(WallpaperCommand)>,31,32,<android.service.wallpaper.WallpaperService.Engine: void doCommand(WallpaperCommand)>,<android.service.wallpaper.WallpaperService.Engine: void doCommand(WallpaperCommand)>,0,"{
    Bundle result;
    if (!mDestroyed) {
        result = onCommand(cmd.action, cmd.x, cmd.y, cmd.z, cmd.extras, cmd.sync);
    } else {
        result = null;
    }
    if (cmd.sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting command complete"");
            mSession.wallpaperCommandComplete(mWindow.asBinder(), result);
        } catch (RemoteException e) {
        }
    }
}","{
    Bundle result;
    if (!mDestroyed) {
        if (COMMAND_FREEZE.equals(cmd.action) || COMMAND_UNFREEZE.equals(cmd.action)) {
            updateFrozenState(/* frozenRequested= */
            !COMMAND_UNFREEZE.equals(cmd.action));
        }
        result = onCommand(cmd.action, cmd.x, cmd.y, cmd.z, cmd.extras, cmd.sync);
    } else {
        result = null;
    }
    if (cmd.sync) {
        try {
            if (DEBUG)
                Log.v(TAG, ""Reporting command complete"");
            mSession.wallpaperCommandComplete(mWindow.asBinder(), result);
        } catch (RemoteException e) {
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"A new block with an if statement and a method call (updateFrozenState(...)) has been introduced for certain command actions (COMMAND_FREEZE and COMMAND_UNFREEZE). Also, the method onCommand(...) is always called unless `mDestroyed` is true, which is an ""Other statement changed"" scenario though logically related to the new if condition. Therefore, the code change types are 3,4.","There is no Compatibility Issue introduced since the changes don't affect the API's return value or exception handling in a way that external code would observe. The control flow change only introduces internal state handling and does not alter the control flow in relation to the return value or exception propagation. Hence, no CI is detected, and the CI type is 0."
32,<android.bluetooth.BluetoothDevice: String getAlias()>,31,32,<android.bluetooth.BluetoothDevice: String getAlias()>,<android.bluetooth.BluetoothDevice: String getAlias()>,0,"{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device Alias"");
        return null;
    }
    try {
        String alias = service.getRemoteAliasWithAttribution(this, mAttributionSource);
        if (alias == null) {
            return getName();
        }
        return alias;
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}","{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, ""BT not enabled. Cannot get Remote Device Alias"");
        return null;
    }
    try {
        String alias = service.getRemoteAliasWithAttribution(this, mAttributionSource);
        if (alias == null) {
            return getName();
        }
        return alias.replace('\t', ' ').replace('\n', ' ').replace('\r', ' ');
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return null;
}",1,"/**
 * Get the locally modifiable name (alias) of the remote Bluetooth device.
 *
 * @return the Bluetooth alias, the friendly device name if no alias, or
 * null if there was a problem
 */
","/**
 * Get the locally modifiable name (alias) of the remote Bluetooth device.
 *
 * @return the Bluetooth alias, the friendly device name if no alias, or
 * null if there was a problem
 */
",-1,"[@Nullable, @RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]","[@Nullable, @RequiresLegacyBluetoothPermission, @RequiresBluetoothConnectPermission, @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)]",-1,-1,-1,-1,-1,-1,4,0,"The change involves an additional method call on the variable `alias` to replace certain characters with a space before it is returned. This change falls under the 'Other statement changed' category as it is not a change in the return statement structure, exception handling, control dependency, or a dependent API.","There is no Compatibility Issue detected because the type and conditions under which a value is returned have not changed, and the method still handles exceptions in the same manner. The returned value is still a valid String representation of the alias, even though its format may be altered to remove specific characters. The change is an internal string formatting adjustment with the same return type and does not affect how the method behaves when interacting with other parts of the system (it does not throw a new exception nor changes the value returned in a way that would affect execution flow). Therefore, the method continues to exhibit consistent behavior with respect to its signature and contracts between the early and late versions."
33,"<android.app.WallpaperManager.Globals: void addOnColorsChangedListener(LocalWallpaperColorConsumer,List<RectF>,int,int,int)>",31,32,"<android.app.WallpaperManager.Globals: void addOnColorsChangedListener(LocalWallpaperColorConsumer,List<RectF>,int,int,int)>","<android.app.WallpaperManager.Globals: void addOnColorsChangedListener(LocalWallpaperColorConsumer,List<RectF>,int,int,int)>",0,"{
    for (RectF area : regions) {
        ArraySet<LocalWallpaperColorConsumer> callbacks = mLocalColorAreas.get(area);
        if (callbacks == null) {
            callbacks = new ArraySet<>();
            mLocalColorAreas.put(area, callbacks);
        }
        callbacks.add(callback);
    }
    try {
        mService.addOnLocalColorsChangedListener(mLocalColorCallback, regions, which, userId, displayId);
    } catch (RemoteException e) {
        // Can't get colors, connection lost.
        Log.e(TAG, ""Can't register for local color updates"", e);
    }
}","{
    synchronized (this) {
        for (RectF area : regions) {
            ArraySet<RectF> areas = mLocalColorCallbackAreas.get(callback);
            if (areas == null) {
                areas = new ArraySet<>();
                mLocalColorCallbackAreas.put(callback, areas);
            }
            areas.add(area);
        }
        try {
            // one way returns immediately
            mService.addOnLocalColorsChangedListener(mLocalColorCallback, regions, which, userId, displayId);
        } catch (RemoteException e) {
            // Can't get colors, connection lost.
            Log.e(TAG, ""Can't register for local color updates"", e);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The code has changed with the addition of `synchronized` block and the modification of data structure and the associated logic from `mLocalColorAreas` to `mLocalColorCallbackAreas`. Thus, the changes are related to control dependency and other statements, with types 3 and 4.","Despite these changes, the observable behavior of the API from an external perspective remains the same. The method still registers a callback and there are no changes to the return type, thrown exceptions, or control flow that would affect the outward behavior. The change in internal data structures and synchronization does not alter how the method behaves in terms of its contract with the caller, hence there is no compatibility issue, represented by 0."
34,<android.window.TransitionFilter.Requirement: boolean matches(TransitionRequestInfo)>,31,32,<android.window.TransitionFilter.Requirement: boolean matches(TransitionRequestInfo)>,<android.window.TransitionFilter.Requirement: boolean matches(TransitionRequestInfo)>,0,"{
    // Can't check modes since the transition hasn't been built at this point.
    if (mActivityType == ACTIVITY_TYPE_UNDEFINED)
        return true;
    return request.getTriggerTask() != null && request.getTriggerTask().getActivityType() == mActivityType;
}","{
    // Can't check modes/order since the transition hasn't been built at this point.
    if (mActivityType == ACTIVITY_TYPE_UNDEFINED)
        return true;
    return request.getTriggerTask() != null && request.getTriggerTask().getActivityType() == mActivityType && matchesTopActivity(request.getTriggerTask());
}",1,"/**
 * Check if the request matches this filter. It may generate false positives
 */
","/**
 * Check if the request matches this filter. It may generate false positives
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In addition to the comment change, the late implementation introduces another condition within the return statement, specifically, `&& matchesTopActivity(request.getTriggerTask())`. This additional condition changes the control dependency and introduces a new clause that affects the result of the return value. Thus, the code change type is 3 (Control dependency changed) and 1 (Return statement changed), because there is a new condition that can change the return value.","The late version adds a new condition (`matchesTopActivity(request.getTriggerTask()`), which means the method can potentially return different results based on this additional condition check. Thus, there is a Compatibility Issue relating to a potential different return value, which is CI type 1."
35,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,31,32,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,<android.window.TaskSnapshot.Builder: TaskSnapshot build()>,0,"{
    return new TaskSnapshot(mId, mTopActivity, mSnapshot, mColorSpace, mOrientation, mRotation, mTaskSize, mContentInsets, // disk.
    false, /* isLowResolution */
    mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface);
}","{
    return new TaskSnapshot(mId, mTopActivity, mSnapshot, mColorSpace, mOrientation, mRotation, mTaskSize, mContentInsets, mLetterboxInsets, // disk.
    false, /* isLowResolution */
    mIsRealSnapshot, mWindowingMode, mAppearance, mIsTranslucent, mHasImeSurface);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The constructor of TaskSnapshot has an additional parameter (mLetterboxInsets) in the late version, which indicates that the dependent API (TaskSnapshot constructor) has changed (the number of parameters increased). Therefore, the change type is 1,5.","The constructor call in the `build()` method includes a new parameter, which means different instances of `TaskSnapshot` will be created between the two versions with potentially different data (due to the new parameter), thus this leads to a compatibility issue type 1."
36,<android.app.ActivityOptions: Bundle toBundle()>,31,32,<android.app.ActivityOptions: Bundle toBundle()>,<android.app.ActivityOptions: Bundle toBundle()>,0,"{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putBinder(KEY_REMOTE_TRANSITION, mRemoteTransition.asBinder());
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    return b;
}","{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, ""Failed to copy thumbnail"");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchTaskFragmentToken != null) {
        b.putBinder(KEY_LAUNCH_TASK_FRAGMENT_TOKEN, mLaunchTaskFragmentToken);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putParcelable(KEY_REMOTE_TRANSITION, mRemoteTransition);
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    return b;
}",1,"/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
","/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */
",-1,,,-1,-1,-1,-1,-1,-1,,,,
37,<android.window.TransitionInfo.Change: String toString()>,31,32,<android.window.TransitionInfo.Change: String toString()>,<android.window.TransitionInfo.Change: String toString()>,0,"{
    return ""{"" + mContainer + ""("" + mParent + "") leash="" + mLeash + "" m="" + modeToString(mMode) + "" f="" + flagsToString(mFlags) + "" sb="" + mStartAbsBounds + "" eb="" + mEndAbsBounds + "" eo="" + mEndRelOffset + "" r="" + mStartRotation + ""->"" + mEndRotation + ""}"";
}","{
    return ""{"" + mContainer + ""("" + mParent + "") leash="" + mLeash + "" m="" + modeToString(mMode) + "" f="" + flagsToString(mFlags) + "" sb="" + mStartAbsBounds + "" eb="" + mEndAbsBounds + "" eo="" + mEndRelOffset + "" r="" + mStartRotation + ""->"" + mEndRotation + "":"" + mRotationAnimation + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The return statement in the late version has an additional concatenation ("":"" + mRotationAnimation), so the returned string will be different, thus the code change type is 1.","As the returned string in the late version includes additional information (mRotationAnimation), the API will return a different value, which constitutes a Compatibility Issue, so the CI type is 1."
40,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",31,32,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onRepeatingRequestError(long,int)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            // Camera already closed
            return;
        }
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
            return;
        }
        checkEarlyTriggerSequenceCompleteLocked(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}","{
    if (DEBUG) {
        Log.d(TAG, ""Repeating request error received. Last frame number is "" + lastFrameNumber);
    }
    synchronized (mInterfaceLock) {
        // Camera is already closed or no repeating request is present.
        if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE) {
            if ((mFailedRepeatingRequestId == repeatingRequestId) && (mFailedRepeatingRequestTypes != null) && (mRemoteDevice != null)) {
                Log.v(TAG, ""Resuming stop of failed repeating request with id: "" + mFailedRepeatingRequestId);
                checkEarlyTriggerSequenceCompleteLocked(mFailedRepeatingRequestId, lastFrameNumber, mFailedRepeatingRequestTypes);
                mFailedRepeatingRequestId = REQUEST_ID_NONE;
                mFailedRepeatingRequestTypes = null;
            }
            return;
        }
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onRepeatingRequestError(lastFrameNumber, repeatingRequestId);
            return;
        }
        checkEarlyTriggerSequenceCompleteLocked(mRepeatingRequestId, lastFrameNumber, mRepeatingRequestTypes);
        // Check if there is already a new repeating request
        if (mRepeatingRequestId == repeatingRequestId) {
            mRepeatingRequestId = REQUEST_ID_NONE;
            mRepeatingRequestTypes = null;
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The if condition `if (mRemoteDevice == null || mRepeatingRequestId == REQUEST_ID_NONE)` now contains additional nested checks, altering the control flow of the method.",#CI_description
41,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,31,32,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,<android.accessibilityservice.AccessibilityService: IBinder onBind(Intent)>,0,"{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(AccessibilityGestureEvent gestureEvent) {
            return AccessibilityService.this.onGesture(gestureEvent);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked(int displayId) {
            AccessibilityService.this.onAccessibilityButtonClicked(displayId);
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }

        @Override
        public void onSystemActionsChanged() {
            AccessibilityService.this.onSystemActionsChanged();
        }
    });
}","{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.dispatchServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // update the default token on whatever manager we gave them.
            if (mWindowManager != null) {
                final WindowManagerImpl wm = (WindowManagerImpl) mWindowManager;
                wm.setDefaultToken(mWindowToken);
            }
        }

        @Override
        public boolean onGesture(AccessibilityGestureEvent gestureEvent) {
            return AccessibilityService.this.onGesture(gestureEvent);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }

        @Override
        public void onMagnificationChanged(int displayId, @NonNull Region region, float scale, float centerX, float centerY) {
            AccessibilityService.this.onMagnificationChanged(displayId, region, scale, centerX, centerY);
        }

        @Override
        public void onSoftKeyboardShowModeChanged(int showMode) {
            AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
        }

        @Override
        public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
            AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
        }

        @Override
        public void onFingerprintCapturingGesturesChanged(boolean active) {
            AccessibilityService.this.onFingerprintCapturingGesturesChanged(active);
        }

        @Override
        public void onFingerprintGesture(int gesture) {
            AccessibilityService.this.onFingerprintGesture(gesture);
        }

        @Override
        public void onAccessibilityButtonClicked(int displayId) {
            AccessibilityService.this.onAccessibilityButtonClicked(displayId);
        }

        @Override
        public void onAccessibilityButtonAvailabilityChanged(boolean available) {
            AccessibilityService.this.onAccessibilityButtonAvailabilityChanged(available);
        }

        @Override
        public void onSystemActionsChanged() {
            AccessibilityService.this.onSystemActionsChanged();
        }
    });
}",1,"/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
","/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation change is located within the `init` method definition inside the `IAccessibilityServiceClientWrapper` instantiation. The early version directly retrieves a `WindowManagerImpl` from the system service and calls `setDefaultToken(windowToken)` on it, while the late version first checks if an instance of a window manager is available through the `mWindowManager` field and, if so, uses that instance to call `setDefaultToken`. This qualifies as an ""Other statement changed"" situation.","No Compatibility Issue arises from this modification because the change does not affect any return statement or exception handling mechanism. Instead, it alters the internal flow of how the window token is set on a window manager - this is an internal behavior change that does not have an outward impact on the method's contract. The onBind method still returns an `IBinder` object, and the manner in which an exception could be thrown does not change. Therefore, even with a logic change, the method's behavior as perceived by the caller remains the same."
42,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",31,32,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>","<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,The method's body was changed from a single return statement calling `unsupported()` to calling `unsupported()` followed by `return 0;`. This is both a change in the other statement (type 4) as the call to the method `unsupported()` is now a standalone statement and a change in the return statement (type 1).,"Since the original implementation provided no specific return value (it likely threw an exception or had an undefined return due to `unsupported()`), and the new implementation explicitly returns an integer with value `0`, the changes between the two versions can lead to the API returning a different value. Thus, the CI type is 1."
43,<android.app.ContextImpl: Context createDisplayContext(Display)>,31,32,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    // Ensure the resources display metrics are adjusted to match the provided display.
    Configuration overrideConfig = new Configuration();
    overrideConfig.setTo(display.getDisplayAdjustments().getConfiguration(), ActivityInfo.CONFIG_WINDOW_CONFIGURATION, 1);
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, overrideConfig, display.getDisplayAdjustments().getCompatibilityInfo(), mResources.getLoaders()));
    context.mDisplay = display;
    context.mContextType = CONTEXT_TYPE_DISPLAY_CONTEXT;
    // Display contexts and any context derived from a display context should always override
    // the display that would otherwise be inherited from mToken (or the global configuration if
    // mToken is null).
    context.mForceDisplayOverrideInResources = true;
    // The configuration is overridden by display adjustments' configuration and won't receive
    // configuration changes. This context won't be regarded as having the proper configuration
    // anymore.
    context.mIsConfigurationBasedContext = false;
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mParams, mAttributionSource.getAttributionTag(), mAttributionSource.getNext(), mSplitName, mToken, mUser, mFlags, mClassLoader, null);
    final int displayId = display.getDisplayId();
    // Ensure the resources display metrics are adjusted to match the provided display.
    Configuration overrideConfig = new Configuration();
    overrideConfig.setTo(display.getDisplayAdjustments().getConfiguration(), ActivityInfo.CONFIG_WINDOW_CONFIGURATION, 1);
    context.setResources(createResources(mToken, mPackageInfo, mSplitName, displayId, overrideConfig, display.getDisplayAdjustments().getCompatibilityInfo(), mResources.getLoaders()));
    context.mDisplay = display;
    // Inherit context type if the container is from System or System UI context to bypass
    // UI context check.
    context.mContextType = mContextType == CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI : CONTEXT_TYPE_DISPLAY_CONTEXT;
    // Display contexts and any context derived from a display context should always override
    // the display that would otherwise be inherited from mToken (or the global configuration if
    // mToken is null).
    context.mForceDisplayOverrideInResources = true;
    // The configuration is overridden by display adjustments' configuration and won't receive
    // configuration changes. This context won't be regarded as having the proper configuration
    // anymore.
    context.mIsConfigurationBasedContext = false;
    return context;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The assignment to 'context.mContextType' has been changed, configuration conditions for assigning the 'CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI' or 'CONTEXT_TYPE_DISPLAY_CONTEXT' have been introduced, so the code change type is 4.","The behavior modification due to the assignment change in 'context.mContextType' variable does not lead to an incompatible change. This is because the value still gets assigned to 'context.mContextType' but with modified conditions that account for the context type of the container. There is no return type or exception handling affected, so the CI type is 0."
44,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,31,32,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,<android.app.ActivityTransitionCoordinator: void moveSharedElementsToOverlay()>,0,"{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        Matrix tempMatrix = new Matrix();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            if (view.isAttachedToWindow()) {
                tempMatrix.reset();
                mSharedElementParentMatrices.get(i).invert(tempMatrix);
                GhostView.addGhost(view, decor, tempMatrix);
                ViewGroup parent = (ViewGroup) view.getParent();
                if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                    GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                    parent.getViewTreeObserver().addOnPreDrawListener(listener);
                    parent.addOnAttachStateChangeListener(listener);
                    mGhostViewListeners.add(listener);
                }
            }
        }
    }
}","{
    if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
        return;
    }
    setSharedElementMatrices();
    int numSharedElements = mSharedElements.size();
    ViewGroup decor = getDecor();
    if (decor != null) {
        boolean moveWithParent = moveSharedElementWithParent();
        Matrix tempMatrix = new Matrix();
        for (int i = 0; i < numSharedElements; i++) {
            View view = mSharedElements.get(i);
            if (view.isAttachedToWindow()) {
                tempMatrix.reset();
                mSharedElementParentMatrices.get(i).invert(tempMatrix);
                decor.transformMatrixToLocal(tempMatrix);
                GhostView.addGhost(view, decor, tempMatrix);
                ViewGroup parent = (ViewGroup) view.getParent();
                if (moveWithParent && !isInTransitionGroup(parent, decor)) {
                    GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                    parent.getViewTreeObserver().addOnPreDrawListener(listener);
                    parent.addOnAttachStateChangeListener(listener);
                    mGhostViewListeners.add(listener);
                }
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"One additional statement `decor.transformMatrixToLocal(tempMatrix);` has been introduced inside the for loop, so the code change type is 4.","The change made doesn't affect the method's control flow or the potential exceptions that might be thrown, nor does it change the return value (since the method is void and uses no return statements). The change only affects the internal transformation of the matrix, which should not cause a Compatibility Issue as it is an internal calculation detail not affecting the API's contract. Therefore, there is no Compatibility Issue in this scenario."
45,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,31,32,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,<android.inputmethodservice.InputMethodService: boolean onEvaluateFullscreenMode()>,0,"{
    Configuration config = getResources().getConfiguration();
    if (config.orientation != Configuration.ORIENTATION_LANDSCAPE) {
        return false;
    }
    if ((mInputEditorInfo != null && (mInputEditorInfo.imeOptions & EditorInfo.IME_FLAG_NO_FULLSCREEN) != 0) || // is, IME shouldn't use fullscreen-mode.
    (mInputEditorInfo.internalImeOptions & EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT) != 0) {
        return false;
    }
    return true;
}","{
    Configuration config = getResources().getConfiguration();
    if (config.orientation != Configuration.ORIENTATION_LANDSCAPE) {
        return false;
    }
    if (mInputEditorInfo != null && ((mInputEditorInfo.imeOptions & EditorInfo.IME_FLAG_NO_FULLSCREEN) != 0 || // is, IME shouldn't use fullscreen-mode.
    (mInputEditorInfo.internalImeOptions & EditorInfo.IME_INTERNAL_FLAG_APP_WINDOW_PORTRAIT) != 0)) {
        return false;
    }
    return true;
}",1,"/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
","/**
 * Override this to control when the input method should run in
 * fullscreen mode.  The default implementation runs in fullsceen only
 * when the screen is in landscape mode.  If you change what
 * this returns, you will need to call {@link #updateFullscreenMode()}
 * yourself whenever the returned value may have changed to have it
 * re-evaluated and applied.
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The change between the versions is the reordering of parentheses in the conditional statement which checks multiple conditions. The execution of logical operations is altered by changing the scope of conditions within parentheses, but the logical outcome remains the same; hence, the change type is 3.","Although the parentheses have been restructured, the logic of the conditional expression has not changed. Therefore, this change should not result in any difference in the API's behavior, no matter the version used. As such, there is no compatibility issue, marking the CI type as 0."
46,"<android.app.DisabledWallpaperManager: int getWallpaperIdForUser(int,int)>",31,32,"<android.app.DisabledWallpaperManager: int getWallpaperIdForUser(int,int)>","<android.app.DisabledWallpaperManager: int getWallpaperIdForUser(int,int)>",0,"{
    return unsupported();
}","{
    return unsupportedInt();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement is calling a different method from unsupported() to unsupportedInt(). This indicates that the dependent API has changed which is indicated as the code change type 1,5.","Since the dependent API is called with a different name, it is possible that the function returns a different value, and hence, the compatibility issue type is 1."
47,"<android.app.WallpaperManager.Globals: void removeOnColorsChangedListener(LocalWallpaperColorConsumer,int,int,int)>",31,32,"<android.app.WallpaperManager.Globals: void removeOnColorsChangedListener(LocalWallpaperColorConsumer,int,int,int)>","<android.app.WallpaperManager.Globals: void removeOnColorsChangedListener(LocalWallpaperColorConsumer,int,int,int)>",0,"{
    final ArrayList<RectF> removeAreas = new ArrayList<>();
    for (RectF area : mLocalColorAreas.keySet()) {
        ArraySet<LocalWallpaperColorConsumer> callbacks = mLocalColorAreas.get(area);
        if (callbacks == null)
            continue;
        callbacks.remove(callback);
        if (callbacks.size() == 0) {
            mLocalColorAreas.remove(area);
            removeAreas.add(area);
        }
    }
    try {
        if (removeAreas.size() > 0) {
            mService.removeOnLocalColorsChangedListener(mLocalColorCallback, removeAreas, which, userId, displayId);
        }
    } catch (RemoteException e) {
        // Can't get colors, connection lost.
        Log.e(TAG, ""Can't unregister for local color updates"", e);
    }
}","{
    synchronized (this) {
        final ArraySet<RectF> removeAreas = mLocalColorCallbackAreas.remove(callback);
        if (removeAreas == null || removeAreas.size() == 0) {
            return;
        }
        for (LocalWallpaperColorConsumer cb : mLocalColorCallbackAreas.keySet()) {
            ArraySet<RectF> areas = mLocalColorCallbackAreas.get(cb);
            if (areas != null && cb != callback)
                removeAreas.removeAll(areas);
        }
        try {
            if (removeAreas.size() > 0) {
                // one way returns immediately
                mService.removeOnLocalColorsChangedListener(mLocalColorCallback, new ArrayList(removeAreas), which, userId, displayId);
            }
        } catch (RemoteException e) {
            // Can't get colors, connection lost.
            Log.e(TAG, ""Can't unregister for local color updates"", e);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,2,3,4","1,2","The return statement (`return;`), several other statements (use of `synchronized`, and the new way of removing entries from `mLocalColorCallbackAreas`), and the exception handling statement have all changed from the early version to the late version. Control flow logic has also changed as it now returns early if `removeAreas` is null or size 0. Thus, types 1,2,3,4 are all applicable.","The addition of the `return;` statement for an early exit might cause the method to return without making a service call, which, if the conditions are met, would not have occurred in the early version, causing a potential CI of type 1. The changed exception handling does not handle exceptions with a different strategy (still logs the exception), so there is no CI of type 2 due to exception handling changes. However, the way in which the conditions for the service call are checked has changed such that different behavior might occur (previous version performs action per area and now returns immediately), which could be a source of CI type 1."
49,"<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionChanged(long,int,int,int,int)>",31,32,"<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionChanged(long,int,int,int,int)>","<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionChanged(long,int,int,int,int)>",0,"{
    if (mSurfaceControl == null) {
        return;
    }
    // a single-frame desync is therefore preferable for now.
    synchronized (mSurfaceControlLock) {
        mRtHandlingPositionUpdates = true;
    }
    if (mRTLastReportedPosition.left == left && mRTLastReportedPosition.top == top && mRTLastReportedPosition.right == right && mRTLastReportedPosition.bottom == bottom && mRTLastReportedSurfaceSize.x == mRtSurfaceWidth && mRTLastReportedSurfaceSize.y == mRtSurfaceHeight && !mPendingTransaction) {
        return;
    }
    try {
        if (DEBUG_POSITION) {
            Log.d(TAG, String.format(""%d updateSurfacePosition RenderWorker, frameNr = %d, "" + ""position = [%d, %d, %d, %d] surfaceSize = %dx%d"", System.identityHashCode(SurfaceView.this), frameNumber, left, top, right, bottom, mRtSurfaceWidth, mRtSurfaceHeight));
        }
        mRTLastReportedPosition.set(left, top, right, bottom);
        mRTLastReportedSurfaceSize.set(mRtSurfaceWidth, mRtSurfaceHeight);
        onSetSurfacePositionAndScaleRT(mPositionChangedTransaction, mSurfaceControl, mRTLastReportedPosition.left, /*positionLeft*/
        mRTLastReportedPosition.top, /*positionTop*/
        mRTLastReportedPosition.width() / (float) mRtSurfaceWidth, /*postScaleX*/
        mRTLastReportedPosition.height() / (float) mRtSurfaceHeight);
        if (mViewVisibility) {
            mPositionChangedTransaction.show(mSurfaceControl);
        }
        applyChildSurfaceTransaction_renderWorker(mPositionChangedTransaction, getViewRootImpl().mSurface, frameNumber);
        applyOrMergeTransaction(mPositionChangedTransaction, frameNumber);
        mPendingTransaction = false;
    } catch (Exception ex) {
        Log.e(TAG, ""Exception from repositionChild"", ex);
    }
}","{
    synchronized (mSurfaceControlLock) {
        if (mSurfaceControl == null) {
            return;
        }
        if (mRTLastReportedPosition.left == left && mRTLastReportedPosition.top == top && mRTLastReportedPosition.right == right && mRTLastReportedPosition.bottom == bottom && mRTLastReportedSurfaceSize.x == mRtSurfaceWidth && mRTLastReportedSurfaceSize.y == mRtSurfaceHeight && !mPendingTransaction) {
            return;
        }
        try {
            if (DEBUG_POSITION) {
                Log.d(TAG, String.format(""%d updateSurfacePosition RenderWorker, frameNr = %d, "" + ""position = [%d, %d, %d, %d] surfaceSize = %dx%d"", System.identityHashCode(SurfaceView.this), frameNumber, left, top, right, bottom, mRtSurfaceWidth, mRtSurfaceHeight));
            }
            mRTLastReportedPosition.set(left, top, right, bottom);
            mRTLastReportedSurfaceSize.set(mRtSurfaceWidth, mRtSurfaceHeight);
            onSetSurfacePositionAndScaleRT(mPositionChangedTransaction, mSurfaceControl, mRTLastReportedPosition.left, /*positionLeft*/
            mRTLastReportedPosition.top, /*positionTop*/
            mRTLastReportedPosition.width() / (float) mRtSurfaceWidth, /*postScaleX*/
            mRTLastReportedPosition.height() / (float) mRtSurfaceHeight);
            if (mViewVisibility) {
                mPositionChangedTransaction.show(mSurfaceControl);
            }
            final ViewRootImpl viewRoot = getViewRootImpl();
            if (viewRoot != null) {
                applyChildSurfaceTransaction_renderWorker(mPositionChangedTransaction, viewRoot.mSurface, frameNumber);
            }
            applyOrMergeTransaction(mPositionChangedTransaction, frameNumber);
            mPendingTransaction = false;
        } catch (Exception ex) {
            Log.e(TAG, ""Exception from repositionChild"", ex);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The control dependency has changed due to moving the first return statement inside the `synchronized` block and adding a null check for `getViewRootImpl()`. However, since both changes do not affect the API's behavior concerning the return value or exceptions that it might throw, they are only control dependency changes, which is type 3.","There is no Compatibility Issue because these changes do not affect the API's external behavior in terms of the values it returns or the exceptions it throws; the change concerns only internal restructuring of the checks and method calls within the control flow. Thus, the result is 0 for No Compatibility Issue."
52,<android.app.DisabledWallpaperManager: int getDesiredMinimumWidth()>,31,32,<android.app.DisabledWallpaperManager: int getDesiredMinimumWidth()>,<android.app.DisabledWallpaperManager: int getDesiredMinimumWidth()>,0,"{
    return unsupported();
}","{
    return unsupportedInt();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The method call within the return statement has changed from unsupported() to unsupportedInt(), which implies that the dependent API called within this method has changed; thus, it falls under the categories of return statement changed (1) and dependent API changed (5).","Considering that the method call has changed from unsupported() to unsupportedInt(), it could potentially return a different value, especially if the behavior or the return type of the new method is different. This presents a Compatibility Issue due to a potential difference in the returned values (1)."
53,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int,int)>",31,32,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int,int)>","<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean,int,int)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The early implementation calls unsupported() and directly returns its result, while the late implementation calls unsupported() but then always returns 0. Hence, structurally, there is a change in other statements because unsupported() is no longer the return value.","Despite the change in the implementation, there is no Compatibility Issue because the behavior of both methods will be the same from the caller's perspective, which is to call unsupported() and return a constant value. Regardless of the version, callers cannot rely on the return value because of the semantics of an ""unsupported"" operation."
54,<android.hardware.display.VirtualDisplayConfig.Builder: VirtualDisplayConfig build()>,31,32,<android.hardware.display.VirtualDisplayConfig.Builder: VirtualDisplayConfig build()>,<android.hardware.display.VirtualDisplayConfig.Builder: VirtualDisplayConfig build()>,0,"{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x100;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror);
    return o;
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x200;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    if ((mBuilderFieldsSet & 0x100) == 0) {
        mWindowTokenClientToMirror = null;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror, mWindowTokenClientToMirror);
    return o;
}",1,"/**
 * Builds the instance. This builder should not be touched after calling this!
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,4",0,"The bitmask for marking builder fields used has changed from 0x100 to 0x200. Additionally, there is a new field initialization (`mWindowTokenClientToMirror`) with a new conditional statement checking if this field is set, and the constructor of 'VirtualDisplayConfig' in the late version has an additional parameter (`mWindowTokenClientToMirror`). This accounts for the code change types 1 (return statement changed, as the constructor being used has an additional parameter) and 4 (other statement changed).","There is no Compatibility Issue detected as the newly added field (`mWindowTokenClientToMirror`) is initialized with a default null value if it is not already set, preserving old behavior. Clients who do not use the new field will receive a `VirtualDisplayConfig` object as before, and those who set the new field will properly have its value included. The API behavior remains consistent for existing client code."
55,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,31,32,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,<android.accessibilityservice.AccessibilityService: Context createDisplayContext(Display)>,0,"{
    final Context context = super.createDisplayContext(display);
    final int displayId = display.getDisplayId();
    setDefaultTokenInternal(context, displayId);
    return context;
}","{
    return new AccessibilityContext(super.createDisplayContext(display), mConnectionId);
}",1,,,-1,[@Override],"[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation has been completely changed from calling setDefaultTokenInternal and returning the context obtained from super.createDisplayContext to creating and returning a new instance of AccessibilityContext with different arguments. Additionally, a new dependent API is utilized, AccessibilityContext constructor, which was not present in the early version. Thus, the code change types are 1 and 5.","The change in return type from a generic Context to a specific new instance of AccessibilityContext will result in the API returning a different value. Therefore, there is a compatibility issue of type 1 caused by potentially different return values."
56,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,31,32,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,<android.inputmethodservice.InputMethodService.InputMethodImpl: void attachToken(IBinder)>,0,"{
    if (mToken != null) {
        throw new IllegalStateException(""attachToken() must be called at most once. token="" + token);
    }
    mToken = token;
    mWindow.setToken(token);
}","{
    if (mToken != null) {
        throw new IllegalStateException(""attachToken() must be called at most once. token="" + token);
    }
    attachToWindowToken(token);
    mToken = token;
    mWindow.setToken(token);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,"4,5",0,"There is an addition of the method call attachToWindowToken(token) before the mToken assignment and mWindow.setToken(token) call, which reflects an 'Other statement changed' situation. Additionally, since attachToWindowToken(token) is a new call, this could be classified as a 'Dependent API changed' if the implementation of attachToWindowToken() has changed its behavior.","Based on the information given, there is no indication that the additional code (attachToWindowToken(token)) or change in implementation order will lead to a different return value or exception behavior from the API, because the method's body still enforces that attachToken() must be called once and assigns the token to mToken and mWindow.setToken(token). The change made is internal and does not seem to affect the API's contract regarding its return type or exception handling. Thus, there are no CIs detected in this alteration."
57,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",31,32,"<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>","<android.inputmethodservice.InputMethodService.InputMethodImpl: void showSoftInput(int,ResultReceiver)>",0,"{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    if (Trace.isEnabled()) {
        Binder.enableTracing();
    } else {
        Binder.disableTracing();
    }
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showSoftInput"");
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#showSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        showWindow(true);
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}","{
    if (DEBUG)
        Log.v(TAG, ""showSoftInput()"");
    // TODO(b/148086656): Disallow IME developers from calling InputMethodImpl methods.
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R && !mSystemCallingShowSoftInput) {
        Log.e(TAG, "" IME shouldn't call showSoftInput on itself."" + "" Use requestShowSelf(int) itself"");
        return;
    }
    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, ""IMS.showSoftInput"");
    ImeTracing.getInstance().triggerServiceDump(""InputMethodService.InputMethodImpl#showSoftInput"", InputMethodService.this, null);
    final boolean wasVisible = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        showWindow(true);
        applyVisibilityInInsetsConsumerIfNecessary(true);
    }
    setImeWindowStatus(mapToImeWindowStatus(), mBackDisposition);
    final boolean isVisible = isInputViewShown();
    final boolean visibilityChanged = isVisible != wasVisible;
    if (resultReceiver != null) {
        resultReceiver.send(visibilityChanged ? InputMethodManager.RESULT_SHOWN : (wasVisible ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",-1,"[@MainThread, @Override]","[@MainThread, @Override]",-1,-1,-1,-1,-1,-1,4,0,"The statements related to Binder tracing, i.e. Binder.enableTracing(); and Binder.disableTracing(); are removed in the late version, resulting in a change type of 4.","These changes are related to debug tracing and do not affect the actual execution flow responsible for showing the soft input. They neither alter the return value nor the exception handling of the API. Therefore, there is no Compatibility Issue, as the beneficiary logic of the method is unchanged."
58,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,31,32,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,<android.hardware.camera2.impl.CameraDeviceImpl: void stopRepeating()>,0,"{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            int[] requestTypes = mRepeatingRequestTypes;
            mRepeatingRequestTypes = null;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceCompleteLocked(requestId, lastFrameNumber, requestTypes);
        }
    }
}","{
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            mFailedRepeatingRequestId = REQUEST_ID_NONE;
            int[] requestTypes = mRepeatingRequestTypes;
            mRepeatingRequestTypes = null;
            mFailedRepeatingRequestTypes = null;
            long lastFrameNumber;
            try {
                lastFrameNumber = mRemoteDevice.cancelRequest(requestId);
            } catch (IllegalArgumentException e) {
                if (DEBUG) {
                    Log.v(TAG, ""Repeating request was already stopped for request "" + requestId);
                }
                // Cache request id and request types in case of a race with
                // ""onRepeatingRequestError"" which may no yet be scheduled on another thread
                // or blocked by us.
                mFailedRepeatingRequestId = requestId;
                mFailedRepeatingRequestTypes = requestTypes;
                // Repeating request was already stopped. Nothing more to do.
                return;
            }
            checkEarlyTriggerSequenceCompleteLocked(requestId, lastFrameNumber, requestTypes);
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The late version includes two new assignment statements (`mFailedRepeatingRequestId = REQUEST_ID_NONE;` and `mFailedRepeatingRequestTypes = null;`) within the `if` block, and inside the `catch` block, the assignment statements (`mFailedRepeatingRequestId = requestId;` and `mFailedRepeatingRequestTypes = requestTypes;`) are added. This does not affect what is returned from the method itself or what the method throws. So, the changes are related to control dependency and other statements, which is types 3,4.",There is no Compatibility Issue because there is no change to what the method returns nor any changes to the thrown exceptions that would affect the external behavior of the method. The changes are internal state adjustments which don't impact the method's interface with the calling code.
59,<android.hardware.camera2.CaptureFailure: boolean wasImageCaptured()>,31,32,<android.hardware.camera2.CaptureFailure: boolean wasImageCaptured()>,<android.hardware.camera2.CaptureFailure: boolean wasImageCaptured()>,0,"{
    return !mDropped;
}","{
    return mWasImageCaptured;
}",1,"/**
 * Determine if the image was captured from the camera.
 *
 * <p>If the image was not captured, no image buffers will be available.
 * If the image was captured, then image buffers may be available.</p>
 *
 * @return boolean True if the image was captured, false otherwise.
 */
","/**
 * Determine if the image was captured from the camera.
 *
 * <p>If the image was not captured, no image buffers will be available.
 * If the image was captured, then image buffers may be available.</p>
 *
 * @return boolean True if the image was captured, false otherwise.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from `return !mDropped;` to `return mWasImageCaptured;`, so the code change type is 1.","This modification can cause the method to return a different value because previously it was the negation of `mDropped`, and now it directly returns the value of `mWasImageCaptured`. The method's behavior has changed and that will affect the return value, so the CI type is 1."
61,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,31,32,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,<android.service.notification.NotificationListenerService.Ranking: boolean equals(Object)>,0,"{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble) && Objects.equals(mVisuallyInterruptive, other.mVisuallyInterruptive) && Objects.equals(mIsConversation, other.mIsConversation) && // Shortcutinfo doesn't have equals either; use id
    Objects.equals((mShortcutInfo == null ? 0 : mShortcutInfo.getId()), (other.mShortcutInfo == null ? 0 : other.mShortcutInfo.getId())) && Objects.equals(mRankingAdjustment, other.mRankingAdjustment) && Objects.equals(mIsBubble, other.mIsBubble);
}","{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    Ranking other = (Ranking) o;
    return Objects.equals(mKey, other.mKey) && Objects.equals(mRank, other.mRank) && Objects.equals(mMatchesInterruptionFilter, other.mMatchesInterruptionFilter) && Objects.equals(mVisibilityOverride, other.mVisibilityOverride) && Objects.equals(mSuppressedVisualEffects, other.mSuppressedVisualEffects) && Objects.equals(mImportance, other.mImportance) && Objects.equals(mImportanceExplanation, other.mImportanceExplanation) && Objects.equals(mOverrideGroupKey, other.mOverrideGroupKey) && Objects.equals(mChannel, other.mChannel) && Objects.equals(mOverridePeople, other.mOverridePeople) && Objects.equals(mSnoozeCriteria, other.mSnoozeCriteria) && Objects.equals(mShowBadge, other.mShowBadge) && Objects.equals(mUserSentiment, other.mUserSentiment) && Objects.equals(mHidden, other.mHidden) && Objects.equals(mLastAudiblyAlertedMs, other.mLastAudiblyAlertedMs) && Objects.equals(mNoisy, other.mNoisy) && // Action.equals() doesn't exist so let's just compare list lengths
    ((mSmartActions == null ? 0 : mSmartActions.size()) == (other.mSmartActions == null ? 0 : other.mSmartActions.size())) && Objects.equals(mSmartReplies, other.mSmartReplies) && Objects.equals(mCanBubble, other.mCanBubble) && Objects.equals(mIsTextChanged, other.mIsTextChanged) && Objects.equals(mIsConversation, other.mIsConversation) && // Shortcutinfo doesn't have equals either; use id
    Objects.equals((mShortcutInfo == null ? 0 : mShortcutInfo.getId()), (other.mShortcutInfo == null ? 0 : other.mShortcutInfo.getId())) && Objects.equals(mRankingAdjustment, other.mRankingAdjustment) && Objects.equals(mIsBubble, other.mIsBubble);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"An 'Objects.equals' call has been replaced with a different one in the comparison, involving 'mVisuallyInterruptive' with 'mIsTextChanged', so the code change type is 1,4 due to a modified return statement and an other statement being altered.","The change in the equals method implementation will cause it to compare a different field, which could result in a different outcome when the method is invoked with the same parameters as before. Therefore, the CI type is 1."
63,<android.view.View: boolean callDragEventHandler(DragEvent)>,31,32,<android.view.View: boolean callDragEventHandler(DragEvent)>,<android.view.View: boolean callDragEventHandler(DragEvent)>,0,"{
    final boolean result;
    ListenerInfo li = mListenerInfo;
    // noinspection SimplifiableIfStatement
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        result = true;
    } else {
        result = onDragEvent(event);
    }
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_ENTERED:
            {
                mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                refreshDrawableState();
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                refreshDrawableState();
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                mPrivateFlags2 &= ~View.DRAG_MASK;
                refreshDrawableState();
            }
            break;
    }
    return result;
}","{
    final boolean result;
    ListenerInfo li = mListenerInfo;
    // noinspection SimplifiableIfStatement
    if (li != null && li.mOnDragListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnDragListener.onDrag(this, event)) {
        result = true;
    } else {
        result = onDragEvent(event);
    }
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                if (result && li != null && li.mOnDragListener != null) {
                    sendWindowContentChangedAccessibilityEvent(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENTERED:
            {
                mPrivateFlags2 |= View.PFLAG2_DRAG_HOVERED;
                refreshDrawableState();
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                mPrivateFlags2 &= ~View.PFLAG2_DRAG_HOVERED;
                refreshDrawableState();
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (result && li != null && (li.mOnDragListener != null || li.mOnReceiveContentListener != null)) {
                    sendWindowContentChangedAccessibilityEvent(AccessibilityEvent.CONTENT_CHANGE_TYPE_DRAG_DROPPED);
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                sendWindowContentChangedAccessibilityEvent(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
                mPrivateFlags2 &= ~View.DRAG_MASK;
                refreshDrawableState();
            }
            break;
    }
    return result;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3, 4",0,The control structure of the method has changed with the addition of a case 'DragEvent.ACTION_DRAG_STARTED' and 'DragEvent.ACTION_DROP' in a switch statement and modifications to the action taken in the 'DragEvent.ACTION_DRAG_ENDED' case. There are also new calls to `sendWindowContentChangedAccessibilityEvent` within these cases. This accounts for changes in control dependency (3) and other statements (4).,"Despite the changes in the control flow structure and new statements, none of them affect the returned result of the method, which is determined before entering the switch statement. The result variable is assigned based on a condition that has not changed between versions and all the cases in the switch statement only execute side operations. Therefore, there is no Compatibility Issue since these changes do not cause the API to return different values or types and do not throw new exceptions. The predicted CI type is 0."
64,"<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean)>",31,32,"<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean)>","<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The implementation has changed by adding an explicit ""return 0;"" after calling the unsupported() method. This is an 'other statement changed' since it's not changing how control flows, what exceptions might be thrown, or the value returned from the method; it's essentially a no-op because the 'unsupported()' method is expected to not return normally (presumably throws an exception).","There is no potential compatibility issue since the 'unsupported()' method is very likely to throw an exception and the return statement will not be reached in both versions. The behavior remains the same as 'unsupported()' presumably throws an exception and terminates the method execution. Hence, the clients of this API should not observe any change in the behavior."
65,"<android.service.wallpaper.WallpaperService.Engine: void updatePage(EngineWindowPage,int,int,float)>",31,32,"<android.service.wallpaper.WallpaperService.Engine: void updatePage(EngineWindowPage,int,int,float)>","<android.service.wallpaper.WallpaperService.Engine: void updatePage(EngineWindowPage,int,int,float)>",0,"{
    // to save creating a runnable, check twice
    long current = SystemClock.elapsedRealtime();
    long lapsed = current - currentPage.getLastUpdateTime();
    // This is important especially when the device first boots
    if (lapsed < DEFAULT_UPDATE_SCREENSHOT_DURATION && currentPage.getLastUpdateTime() > 0) {
        return;
    }
    Surface surface = mSurfaceHolder.getSurface();
    boolean widthIsLarger = mSurfaceSize.x > mSurfaceSize.y;
    int smaller = widthIsLarger ? mSurfaceSize.x : mSurfaceSize.y;
    float ratio = (float) MIN_BITMAP_SCREENSHOT_WIDTH / (float) smaller;
    int width = (int) (ratio * mSurfaceSize.x);
    int height = (int) (ratio * mSurfaceSize.y);
    if (width <= 0 || height <= 0) {
        Log.e(TAG, ""wrong width and height values of bitmap "" + width + "" "" + height);
        return;
    }
    Bitmap screenShot = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Bitmap finalScreenShot = screenShot;
    Trace.beginSection(""WallpaperService#pixelCopy"");
    PixelCopy.request(surface, screenShot, (res) -> {
        Trace.endSection();
        if (DEBUG)
            Log.d(TAG, ""result of pixel copy is "" + res);
        if (res != PixelCopy.SUCCESS) {
            Bitmap lastBitmap = currentPage.getBitmap();
            currentPage.execSync((p) -> {
                // assign the last bitmap taken for now
                p.setBitmap(mLastScreenshot);
            });
            Bitmap lastScreenshot = mLastScreenshot;
            if (lastScreenshot != null && !lastScreenshot.isRecycled() && !Objects.equals(lastBitmap, lastScreenshot)) {
                updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
            }
        } else {
            mLastScreenshot = finalScreenShot;
            // going to hold this lock for a while
            currentPage.execSync((p) -> {
                p.setBitmap(finalScreenShot);
                p.setLastUpdateTime(current);
            });
            updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
        }
    }, mHandler);
}","{
    // to save creating a runnable, check twice
    long current = System.currentTimeMillis();
    long lapsed = current - currentPage.getLastUpdateTime();
    // This is important especially when the device first boots
    if (lapsed < DEFAULT_UPDATE_SCREENSHOT_DURATION && currentPage.getLastUpdateTime() > 0) {
        return;
    }
    Surface surface = mSurfaceHolder.getSurface();
    boolean widthIsLarger = mSurfaceSize.x > mSurfaceSize.y;
    int smaller = widthIsLarger ? mSurfaceSize.x : mSurfaceSize.y;
    float ratio = (float) MIN_BITMAP_SCREENSHOT_WIDTH / (float) smaller;
    int width = (int) (ratio * mSurfaceSize.x);
    int height = (int) (ratio * mSurfaceSize.y);
    if (width <= 0 || height <= 0) {
        Log.e(TAG, ""wrong width and height values of bitmap "" + width + "" "" + height);
        return;
    }
    Bitmap screenShot = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Bitmap finalScreenShot = screenShot;
    Trace.beginSection(""WallpaperService#pixelCopy"");
    PixelCopy.request(surface, screenShot, (res) -> {
        Trace.endSection();
        if (DEBUG)
            Log.d(TAG, ""result of pixel copy is "" + res);
        if (res != PixelCopy.SUCCESS) {
            Bitmap lastBitmap = currentPage.getBitmap();
            // assign the last bitmap taken for now
            currentPage.setBitmap(mLastScreenshot);
            Bitmap lastScreenshot = mLastScreenshot;
            if (lastScreenshot != null && !lastScreenshot.isRecycled() && !Objects.equals(lastBitmap, lastScreenshot)) {
                updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
            }
        } else {
            mLastScreenshot = finalScreenShot;
            // going to hold this lock for a while
            currentPage.setBitmap(finalScreenShot);
            currentPage.setLastUpdateTime(current);
            updatePageColors(currentPage, pageIndx, numPages, xOffsetStep);
        }
    }, mHandler);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4,5",0,"The initial line that acquires the ‘current’ time has changed the method from `SystemClock.elapsedRealtime()` to `System.currentTimeMillis()`. This reflects both a change in the dependent API and in other statements. Additionally, the method invocation of `execSync()` on `currentPage` has been replaced with direct method calls setting the bitmap and last update time, which changes control dependency, since the `execSync()` likely managed synchronization and execution flow. Also, other statements have been changed or removed, for instance, the removal of the lambda expression passed into `execSync()` and no longer using a runnable for checking conditions. ","The change from `SystemClock.elapsedRealtime()` to `System.currentTimeMillis()` typically should not cause a compatibility issue as both methods are used for getting time, but they serve different purposes, `elapsedRealtime()` is for measuring elapsed time and is not affected by time corrections while `currentTimeMillis()` gets the current time with potential adjustments from the network or the user, which potentially could cause behavior differences if the method is used for time interval checking. However, as long as the intent is to simply get a timestamp for the `getLastUpdateTime()` and the elapsed time calculation, it might not necessarily cause a Difference in behavior resulting from timing. The replacement of `execSync()` with direct method calls is unlikely to cause a compatibility issue either if the behavior of the code still correctly updates the bitmap and the last update time in a synchronous manner, which appears to be preserved in the change. Since the change does not seem to inherently result in different return values/types or exception behavior, it's classified as no compatibility issue."
68,<android.app.Notification.Builder: Notification build()>,31,32,<android.app.Notification.Builder: Notification build()>,<android.app.Notification.Builder: Notification build()>,0,"{
    // Check shortcut id matches
    if (mN.mShortcutId != null && mN.mBubbleMetadata != null && mN.mBubbleMetadata.getShortcutId() != null && !mN.mShortcutId.equals(mN.mBubbleMetadata.getShortcutId())) {
        throw new IllegalArgumentException(""Notification and BubbleMetadata shortcut id's don't match,"" + "" notification: "" + mN.mShortcutId + "" vs bubble: "" + mN.mBubbleMetadata.getShortcutId());
    }
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && !styleDisplaysCustomViewInline()) {
        if (mN.contentView == null) {
            mN.contentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, mN.contentView.getSequenceNumber());
        }
        if (mN.bigContentView == null) {
            mN.bigContentView = createBigContentView();
            if (mN.bigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, mN.bigContentView.getSequenceNumber());
            }
        }
        if (mN.headsUpContentView == null) {
            mN.headsUpContentView = createHeadsUpContentView();
            if (mN.headsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, mN.headsUpContentView.getSequenceNumber());
            }
        }
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}","{
    // Check shortcut id matches
    if (mN.mShortcutId != null && mN.mBubbleMetadata != null && mN.mBubbleMetadata.getShortcutId() != null && !mN.mShortcutId.equals(mN.mBubbleMetadata.getShortcutId())) {
        throw new IllegalArgumentException(""Notification and BubbleMetadata shortcut id's don't match,"" + "" notification: "" + mN.mShortcutId + "" vs bubble: "" + mN.mBubbleMetadata.getShortcutId());
    }
    // first, add any extras from the calling code
    if (mUserExtras != null) {
        mN.extras = getAllExtras();
    }
    mN.creationTime = System.currentTimeMillis();
    // lazy stuff from mContext; see comment in Builder(Context, Notification)
    Notification.addFieldsFromContext(mContext, mN);
    buildUnstyled();
    if (mStyle != null) {
        mStyle.reduceImageSizes(mContext);
        mStyle.purgeResources();
        mStyle.validate(mContext);
        mStyle.buildStyled(mN);
    }
    mN.reduceImageSizes(mContext);
    if (mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N && !styleDisplaysCustomViewInline()) {
        RemoteViews newContentView = mN.contentView;
        RemoteViews newBigContentView = mN.bigContentView;
        RemoteViews newHeadsUpContentView = mN.headsUpContentView;
        if (newContentView == null) {
            newContentView = createContentView();
            mN.extras.putInt(EXTRA_REBUILD_CONTENT_VIEW_ACTION_COUNT, newContentView.getSequenceNumber());
        }
        if (newBigContentView == null) {
            newBigContentView = createBigContentView();
            if (newBigContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_BIG_CONTENT_VIEW_ACTION_COUNT, newBigContentView.getSequenceNumber());
            }
        }
        if (newHeadsUpContentView == null) {
            newHeadsUpContentView = createHeadsUpContentView();
            if (newHeadsUpContentView != null) {
                mN.extras.putInt(EXTRA_REBUILD_HEADS_UP_CONTENT_VIEW_ACTION_COUNT, newHeadsUpContentView.getSequenceNumber());
            }
        }
        // Don't set any of the content views until after they have all been generated,
        // to avoid the generated .contentView triggering the logic which skips generating
        // the .bigContentView.
        mN.contentView = newContentView;
        mN.bigContentView = newBigContentView;
        mN.headsUpContentView = newHeadsUpContentView;
    }
    if ((mN.defaults & DEFAULT_LIGHTS) != 0) {
        mN.flags |= FLAG_SHOW_LIGHTS;
    }
    mN.allPendingIntents = null;
    return mN;
}",1,"/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 *
 * If this notification has {@link BubbleMetadata} attached that was created with
 * a shortcutId a check will be performed to ensure the shortcutId supplied to bubble
 * metadata matches the shortcutId set on the  notification builder, if one was set.
 * If the shortcutId's were specified but do not match, an exception is thrown here.
 *
 * @see BubbleMetadata.Builder#Builder(String)
 * @see #setShortcutId(String)
 */
","/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 *
 * If this notification has {@link BubbleMetadata} attached that was created with
 * a shortcutId a check will be performed to ensure the shortcutId supplied to bubble
 * metadata matches the shortcutId set on the  notification builder, if one was set.
 * If the shortcutId's were specified but do not match, an exception is thrown here.
 *
 * @see BubbleMetadata.Builder#Builder(String)
 * @see #setShortcutId(String)
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,,,,
71,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",31,32,"<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>","<android.hardware.camera2.impl.CameraDeviceImpl.CameraDeviceCallbacks: void onResultReceived(CameraMetadataNative,CaptureResultExtras,PhysicalCaptureResultInfo[])>",0,"{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onResultReceived(result, resultExtras, physicalResults);
            return;
        }
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            mFrameNumberTracker.updateTracker(frameNumber, /*result*/
            null, isPartialResult, requestType);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(getId(), result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(getId(), result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        // Collect the partials for a total result; or mark the frame as totally completed
        mFrameNumberTracker.updateTracker(frameNumber, finalResult, isPartialResult, requestType);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}","{
    int requestId = resultExtras.getRequestId();
    long frameNumber = resultExtras.getFrameNumber();
    if (DEBUG) {
        Log.v(TAG, ""Received result frame "" + frameNumber + "" for id "" + requestId);
    }
    synchronized (mInterfaceLock) {
        // Camera already closed
        if (mRemoteDevice == null)
            return;
        // of an offline switch
        if (mOfflineSessionImpl != null) {
            mOfflineSessionImpl.getCallbacks().onResultReceived(result, resultExtras, physicalResults);
            return;
        }
        // TODO: Handle CameraCharacteristics access from CaptureResult correctly.
        result.set(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE, getCharacteristics().get(CameraCharacteristics.LENS_INFO_SHADING_MAP_SIZE));
        final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId);
        final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId());
        boolean isPartialResult = (resultExtras.getPartialResultCount() < mTotalPartialCount);
        int requestType = request.getRequestType();
        // Check if we have a callback for this
        if (holder == null) {
            if (DEBUG) {
                Log.d(TAG, ""holder is null, early return at frame "" + frameNumber);
            }
            updateTracker(requestId, frameNumber, requestType, /*result*/
            null, isPartialResult);
            return;
        }
        if (isClosed()) {
            if (DEBUG) {
                Log.d(TAG, ""camera is closed, early return at frame "" + frameNumber);
            }
            updateTracker(requestId, frameNumber, requestType, /*result*/
            null, isPartialResult);
            return;
        }
        Runnable resultDispatch = null;
        CaptureResult finalResult;
        // Make a copy of the native metadata before it gets moved to a CaptureResult
        // object.
        final CameraMetadataNative resultCopy;
        if (holder.hasBatchedOutputs()) {
            resultCopy = new CameraMetadataNative(result);
        } else {
            resultCopy = null;
        }
        // Either send a partial result or the final capture completed result
        if (isPartialResult) {
            final CaptureResult resultAsCapture = new CaptureResult(getId(), result, request, resultExtras);
            // Partial result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                CaptureResult resultInBatch = new CaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras);
                                holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureProgressed(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        } else {
            List<CaptureResult> partialResults = mFrameNumberTracker.popPartialResults(frameNumber);
            final long sensorTimestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);
            final Range<Integer> fpsRange = request.get(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE);
            final int subsequenceId = resultExtras.getSubsequenceId();
            final TotalCaptureResult resultAsCapture = new TotalCaptureResult(getId(), result, request, resultExtras, partialResults, holder.getSessionId(), physicalResults);
            // Final capture result
            resultDispatch = new Runnable() {

                @Override
                public void run() {
                    if (!CameraDeviceImpl.this.isClosed()) {
                        if (holder.hasBatchedOutputs()) {
                            // the batch.
                            for (int i = 0; i < holder.getRequestCount(); i++) {
                                resultCopy.set(CaptureResult.SENSOR_TIMESTAMP, sensorTimestamp - (subsequenceId - i) * NANO_PER_SECOND / fpsRange.getUpper());
                                CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy);
                                // No logical multi-camera support for batched output mode.
                                TotalCaptureResult resultInBatch = new TotalCaptureResult(getId(), resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId(), new PhysicalCaptureResultInfo[0]);
                                holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, holder.getRequest(i), resultInBatch);
                            }
                        } else {
                            holder.getCallback().onCaptureCompleted(CameraDeviceImpl.this, request, resultAsCapture);
                        }
                    }
                }
            };
            finalResult = resultAsCapture;
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            holder.getExecutor().execute(resultDispatch);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        updateTracker(requestId, frameNumber, requestType, finalResult, isPartialResult);
        // Fire onCaptureSequenceCompleted
        if (!isPartialResult) {
            checkAndFireSequenceComplete();
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
73,<android.app.DisabledWallpaperManager: int getDesiredMinimumHeight()>,31,32,<android.app.DisabledWallpaperManager: int getDesiredMinimumHeight()>,<android.app.DisabledWallpaperManager: int getDesiredMinimumHeight()>,0,"{
    return unsupported();
}","{
    return unsupportedInt();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The implementation calls a different method - from unsupported() to unsupportedInt(), so the change types are 1 (return statement changed) and 5 (dependent API changed).","Since the return statement invokes a different method which can potentially return a different variable type or value, the CI type is 1 (Compatibility Issue caused by potential different return values or types)."
74,<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionLost(long)>,31,32,<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionLost(long)>,<android.view.SurfaceView.SurfaceViewPositionUpdateListener: void positionLost(long)>,0,"{
    if (DEBUG) {
        Log.d(TAG, String.format(""%d windowPositionLost, frameNr = %d"", System.identityHashCode(this), frameNumber));
    }
    mRTLastReportedPosition.setEmpty();
    mRTLastReportedSurfaceSize.set(-1, -1);
    if (mPendingTransaction) {
        Log.w(TAG, System.identityHashCode(SurfaceView.this) + ""Pending transaction cleared."");
        mPositionChangedTransaction.clear();
        mPendingTransaction = false;
    }
    if (mSurfaceControl == null) {
        return;
    }
    /**
     * positionLost can be called while UI thread is un-paused so we
     * need to hold the lock here.
     */
    synchronized (mSurfaceControlLock) {
        mRtTransaction.hide(mSurfaceControl);
        if (mRtReleaseSurfaces) {
            mRtReleaseSurfaces = false;
            releaseSurfaces(mRtTransaction);
        }
        applyOrMergeTransaction(mRtTransaction, frameNumber);
        mRtHandlingPositionUpdates = false;
    }
}","{
    if (DEBUG_POSITION) {
        Log.d(TAG, String.format(""%d windowPositionLost, frameNr = %d"", System.identityHashCode(this), frameNumber));
    }
    mRTLastReportedPosition.setEmpty();
    mRTLastReportedSurfaceSize.set(-1, -1);
    /**
     * positionLost can be called while UI thread is un-paused so we
     * need to hold the lock here.
     */
    synchronized (mSurfaceControlLock) {
        if (mPendingTransaction) {
            Log.w(TAG, System.identityHashCode(SurfaceView.this) + ""Pending transaction cleared."");
            mPositionChangedTransaction.clear();
            mPendingTransaction = false;
        }
        if (mSurfaceControl == null) {
            return;
        }
        mRtTransaction.hide(mSurfaceControl);
        applyOrMergeTransaction(mRtTransaction, frameNumber);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",0,"The DEBUG flag was renamed to DEBUG_POSITION and the control flow of the method was altered by moving the check for ""mPendingTransaction"" and ""mSurfaceControl == null"" inside the synchronized block, which constitutes a control dependency change. Additionally, the mRtReleaseSurfaces related code was removed, which is considered an other statement change.","Even though there are changes in the implementation, none of these changes introduce a new return statement, remove an existing return statement, introduce a new exception, or handle an exception differently. The execution path within the synchronized block has been altered, but the behavior observed by the calling code remains consistent: when the method completes, either it has executed certain actions or has simply returned without taking action depending on the conditions. Hence, there is no compatibility issue, as the method's external behavior does not change in a way that would cause different return values or exceptions."
75,<android.os.SharedMemory.Closer: void run()>,31,32,<android.os.SharedMemory.Closer: void run()>,<android.os.SharedMemory.Closer: void run()>,0,"{
    try {
        Os.close(mFd);
    } catch (ErrnoException e) {
    /* swallow error */
    }
    mMemoryReference.release();
    mMemoryReference = null;
}","{
    try {
        FileDescriptor fd = new FileDescriptor();
        fd.setInt$(mFd);
        Os.close(fd);
    } catch (ErrnoException e) {
    /* swallow error */
    }
    mMemoryReference.release();
    mMemoryReference = null;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The code change is introducing a new local variable `fd` and creating it using a new method `fd.setInt$(mFd)` before calling Os.close(fd). This does not change the control flow or the external behavior of the method, so the code change type is 4.","There is no Compatibility Issue because the modification does not alter the method's behavior from an API consumer's perspective. The method's contract and the exceptions it may throw remain the same, as does the eventual releasing of `mMemoryReference`. The internal implementation details have changed, but these do not affect compatibility."
76,"<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean,int)>",31,32,"<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean,int)>","<android.app.DisabledWallpaperManager: int setStream(InputStream,Rect,boolean,int)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,The statement 'unsupported();' has been added and 'return 0;' statement replaced previous 'return unsupported();'. The change in the statement within the function body and its return type makes it both a change type 1 and 4.,"The original method returned the result of 'unsupported()', which we don't explicitly see but can imply is not '0'. In the late implementation, they've separated the call to 'unsupported()' and hardcoded 'return 0;'. This is a fundamental change in the value being returned, therefore, the CI type is 1."
77,<android.inputmethodservice.InputMethodService: void onDestroy()>,31,32,<android.inputmethodservice.InputMethodService: void onDestroy()>,<android.inputmethodservice.InputMethodService: void onDestroy()>,0,"{
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    mWindow.dismissForDestroyIfNecessary();
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
    if (mToken != null) {
        // This is completely optional, but allows us to show more explicit error messages
        // when IME developers are doing something unsupported.
        InputMethodPrivilegedOperationsRegistry.remove(mToken);
    }
}","{
    mDestroyed = true;
    super.onDestroy();
    mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
    doFinishInput();
    mWindow.dismissForDestroyIfNecessary();
    if (mSettingsObserver != null) {
        mSettingsObserver.unregister();
        mSettingsObserver = null;
    }
    if (mToken != null) {
        // This is completely optional, but allows us to show more explicit error messages
        // when IME developers are doing something unsupported.
        InputMethodPrivilegedOperationsRegistry.remove(mToken);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The new line of code `mDestroyed = true;` is simply setting a variable without affecting return values, exceptions, or control flow, so the code change type is 4.","Since the method does not return any value and this added line does not introduce any new behavior in terms of changing the method's return type, value, or exceptions thrown, there is no Compatibility Issue; thus the CI type is 0."
79,<android.window.TransitionFilter.Requirement: String toString()>,31,32,<android.window.TransitionFilter.Requirement: String toString()>,<android.window.TransitionFilter.Requirement: String toString()>,0,"{
    StringBuilder out = new StringBuilder();
    out.append(""{atype="" + WindowConfiguration.activityTypeToString(mActivityType));
    out.append("" modes=["");
    if (mModes != null) {
        for (int i = 0; i < mModes.length; ++i) {
            out.append((i == 0 ? """" : "","") + TransitionInfo.modeToString(mModes[i]));
        }
    }
    return out.append(""]}"").toString();
}","{
    StringBuilder out = new StringBuilder();
    out.append('{');
    if (mNot)
        out.append(""NOT "");
    out.append(""atype="" + WindowConfiguration.activityTypeToString(mActivityType));
    out.append("" independent="" + mMustBeIndependent);
    out.append("" modes=["");
    if (mModes != null) {
        for (int i = 0; i < mModes.length; ++i) {
            out.append((i == 0 ? """" : "","") + TransitionInfo.modeToString(mModes[i]));
        }
    }
    out.append(""]"").toString();
    out.append("" flags="" + TransitionInfo.flagsToString(mFlags));
    out.append("" mustBeTask="" + mMustBeTask);
    out.append("" order="" + containerOrderToString(mOrder));
    out.append("" topActivity="").append(mTopActivity);
    out.append(""}"");
    return out.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"Various parts of the string being built have changed: new elements added (mNot, mMustBeIndependent, mFlags, mMustBeTask, mOrder, mTopActivity), and the structure of the string is modified which is evident in the rearrangement of the closing brackets and the toString() call. There are additions to the string being constructed, which includes control dependency changes, and other statement changes. Therefore, the change types are 1, 3, 4.","Given that the output of the toString() method has been altered significantly with additional conditional checks and appended strings, the return value of this method will be different, which dictates the CI type is 1."
80,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,31,32,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,0,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (mWindowContextToken == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        mWindowContextToken = o.mWindowContextToken;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (preferredMinDisplayRefreshRate != o.preferredMinDisplayRefreshRate) {
        preferredMinDisplayRefreshRate = o.preferredMinDisplayRefreshRate;
        changes |= PREFERRED_MIN_DISPLAY_REFRESH_RATE;
    }
    if (preferredMaxDisplayRefreshRate != o.preferredMaxDisplayRefreshRate) {
        preferredMaxDisplayRefreshRate = o.preferredMaxDisplayRefreshRate;
        changes |= PREFERRED_MAX_DISPLAY_REFRESH_RATE;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (receiveInsetsIgnoringZOrder != o.receiveInsetsIgnoringZOrder) {
        receiveInsetsIgnoringZOrder = o.receiveInsetsIgnoringZOrder;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    if (mBlurBehindRadius != o.mBlurBehindRadius) {
        mBlurBehindRadius = o.mBlurBehindRadius;
        changes |= BLUR_BEHIND_RADIUS_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        final int diff = flags ^ o.flags;
        if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
            changes |= TRANSLUCENT_FLAGS_CHANGED;
        }
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (layoutInDisplayCutoutMode != o.layoutInDisplayCutoutMode) {
        layoutInDisplayCutoutMode = o.layoutInDisplayCutoutMode;
        changes |= LAYOUT_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (mWindowContextToken == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        mWindowContextToken = o.mWindowContextToken;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!Objects.equals(mTitle, o.mTitle) && o.mTitle != null) {
        // NOTE: mTitle only copied if the originator set one.
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (rotationAnimation != o.rotationAnimation) {
        rotationAnimation = o.rotationAnimation;
        changes |= ROTATION_ANIMATION_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (preferredRefreshRate != o.preferredRefreshRate) {
        preferredRefreshRate = o.preferredRefreshRate;
        changes |= PREFERRED_REFRESH_RATE_CHANGED;
    }
    if (preferredDisplayModeId != o.preferredDisplayModeId) {
        preferredDisplayModeId = o.preferredDisplayModeId;
        changes |= PREFERRED_DISPLAY_MODE_ID;
    }
    if (preferredMinDisplayRefreshRate != o.preferredMinDisplayRefreshRate) {
        preferredMinDisplayRefreshRate = o.preferredMinDisplayRefreshRate;
        changes |= PREFERRED_MIN_DISPLAY_REFRESH_RATE;
    }
    if (preferredMaxDisplayRefreshRate != o.preferredMaxDisplayRefreshRate) {
        preferredMaxDisplayRefreshRate = o.preferredMaxDisplayRefreshRate;
        changes |= PREFERRED_MAX_DISPLAY_REFRESH_RATE;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    if (userActivityTimeout != o.userActivityTimeout) {
        userActivityTimeout = o.userActivityTimeout;
        changes |= USER_ACTIVITY_TIMEOUT_CHANGED;
    }
    if (!surfaceInsets.equals(o.surfaceInsets)) {
        surfaceInsets.set(o.surfaceInsets);
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
        hasManualSurfaceInsets = o.hasManualSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (receiveInsetsIgnoringZOrder != o.receiveInsetsIgnoringZOrder) {
        receiveInsetsIgnoringZOrder = o.receiveInsetsIgnoringZOrder;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (preservePreviousSurfaceInsets != o.preservePreviousSurfaceInsets) {
        preservePreviousSurfaceInsets = o.preservePreviousSurfaceInsets;
        changes |= SURFACE_INSETS_CHANGED;
    }
    if (accessibilityIdOfAnchor != o.accessibilityIdOfAnchor) {
        accessibilityIdOfAnchor = o.accessibilityIdOfAnchor;
        changes |= ACCESSIBILITY_ANCHOR_CHANGED;
    }
    if (!Objects.equals(accessibilityTitle, o.accessibilityTitle) && o.accessibilityTitle != null) {
        // NOTE: accessibilityTitle only copied if the originator set one.
        accessibilityTitle = o.accessibilityTitle;
        changes |= ACCESSIBILITY_TITLE_CHANGED;
    }
    if (mColorMode != o.mColorMode) {
        mColorMode = o.mColorMode;
        changes |= COLOR_MODE_CHANGED;
    }
    if (preferMinimalPostProcessing != o.preferMinimalPostProcessing) {
        preferMinimalPostProcessing = o.preferMinimalPostProcessing;
        changes |= MINIMAL_POST_PROCESSING_PREFERENCE_CHANGED;
    }
    if (mBlurBehindRadius != o.mBlurBehindRadius) {
        mBlurBehindRadius = o.mBlurBehindRadius;
        changes |= BLUR_BEHIND_RADIUS_CHANGED;
    }
    // This can't change, it's only set at window creation time.
    hideTimeoutMilliseconds = o.hideTimeoutMilliseconds;
    if (insetsFlags.appearance != o.insetsFlags.appearance) {
        insetsFlags.appearance = o.insetsFlags.appearance;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (insetsFlags.behavior != o.insetsFlags.behavior) {
        insetsFlags.behavior = o.insetsFlags.behavior;
        changes |= INSET_FLAGS_CHANGED;
    }
    if (mFitInsetsTypes != o.mFitInsetsTypes) {
        mFitInsetsTypes = o.mFitInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsSides != o.mFitInsetsSides) {
        mFitInsetsSides = o.mFitInsetsSides;
        changes |= LAYOUT_CHANGED;
    }
    if (mFitInsetsIgnoringVisibility != o.mFitInsetsIgnoringVisibility) {
        mFitInsetsIgnoringVisibility = o.mFitInsetsIgnoringVisibility;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(providesInsetsTypes, o.providesInsetsTypes)) {
        providesInsetsTypes = o.providesInsetsTypes;
        changes |= LAYOUT_CHANGED;
    }
    if (!providedInternalInsets.equals(o.providedInternalInsets)) {
        providedInternalInsets = o.providedInternalInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (!providedInternalImeInsets.equals(o.providedInternalImeInsets)) {
        providedInternalImeInsets = o.providedInternalImeInsets;
        changes |= LAYOUT_CHANGED;
    }
    if (!Arrays.equals(paramsForRotation, o.paramsForRotation)) {
        paramsForRotation = o.paramsForRotation;
        checkNonRecursiveParams();
        changes |= LAYOUT_CHANGED;
    }
    return changes;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
82,<android.app.ContextImpl: IBinder getWindowContextToken()>,31,32,<android.app.ContextImpl: IBinder getWindowContextToken()>,<android.app.ContextImpl: IBinder getWindowContextToken()>,0,"{
    return mContextType == CONTEXT_TYPE_WINDOW_CONTEXT ? mToken : null;
}","{
    switch(mContextType) {
        case CONTEXT_TYPE_WINDOW_CONTEXT:
        case CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI:
            return mToken;
        default:
            return null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4",1,"The early version uses a conditional operator to return either 'mToken' or null based on a check of 'mContextType'. The late version has introduced a 'switch' statement controlling the behavior based on different 'mContextType' values, and a new case has been added (CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI). The change type includes a control dependency change (3), and an other statement changed due to the structure transformation between the two versions (4).","The addition of a new case (CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI) in the late version means that where it would have previously returned null, it will now return 'mToken'. Therefore, the late version could potentially return a different value causing the CI type to be 1."
83,"<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>",31,32,"<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>","<android.view.MotionEvent.PointerCoords: void setAxisValue(int,float)>",0,"{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}","{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        case AXIS_RELATIVE_X:
            relativeX = value;
            break;
        case AXIS_RELATIVE_Y:
            relativeY = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException(""Axis out of range."");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}",1,"/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
","/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,5",0,"Two case statements (AXIS_RELATIVE_X and AXIS_RELATIVE_Y) are added to the switch statement for handling more axis values. This is a control dependency change as the control flow of the program might be affected. Furthermore, this is also a type 5 change since this extends the set of accepted axis values potentially modifying the behavior of dependent APIs which utilize this method. ","Although the behavior of the API has been extended to support additional axis values (AXIS_RELATIVE_X and AXIS_RELATIVE_Y), these changes are backward compatible as they enhance the API functionality without altering its existing behavior. No existing valid input would return a different value or throw a different exception as a result of this change. Therefore, there is no Compatibility Issue."
84,"<android.app.DisabledWallpaperManager: int setResource(int,int)>",31,32,"<android.app.DisabledWallpaperManager: int setResource(int,int)>","<android.app.DisabledWallpaperManager: int setResource(int,int)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The late version introduces an explicitly separate call to unsupported() and a direct return of 0. In the early version, the return statement is directly returning the result of unsupported(). This change involves both a return value change and another statement (method call) altered before the return. Hence, this results in a type 1 (Return statement changed) and type 4 (Other statement changed) classification.","Since the early version returned whatever value was provided by the unsupported() method, and the late version always returns 0 regardless of the behavior of unsupported(), there is a potential Compatibility Issue due to different returned values, categorized as type 1."
85,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",31,32,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>","<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",0,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mInsetsState, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrames, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize);
            if (mSurfaceControl.isValid()) {
                if (mBbqSurfaceControl == null) {
                    mBbqSurfaceControl = new SurfaceControl.Builder().setName(""Wallpaper BBQ wrapper"").setHidden(false).setMetadata(METADATA_WINDOW_TYPE, TYPE_WALLPAPER).setBLASTLayer().setParent(mSurfaceControl).setCallsite(""Wallpaper#relayout"").build();
                    updateSurfaceDimming();
                }
                // Propagate transform hint from WM so we can use the right hint for the
                // first frame.
                mBbqSurfaceControl.setTransformHint(mSurfaceControl.getTransformHint());
                Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x, mSurfaceSize.y, mFormat);
                // would then inc the generation ID and cause EGL resources to be recreated.
                if (blastSurface != null) {
                    mSurfaceHolder.mSurface.transferFrom(blastSurface);
                }
            }
            if (!mLastSurfaceSize.equals(mSurfaceSize)) {
                mLastSurfaceSize.set(mSurfaceSize.x, mSurfaceSize.y);
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrames);
            int w = mWinFrames.frame.width();
            int h = mWinFrames.frame.height();
            final DisplayCutout rawCutout = mInsetsState.getDisplayCutout();
            final Configuration config = getResources().getConfiguration();
            final Rect visibleFrame = new Rect(mWinFrames.frame);
            visibleFrame.intersect(mInsetsState.getDisplayFrame());
            WindowInsets windowInsets = mInsetsState.calculateInsets(visibleFrame, null, /* ignoringVisibilityState */
            config.isScreenRound(), false, /* alwaysConsumeSystemBars */
            mLayout.softInputMode, mLayout.flags, SYSTEM_UI_FLAG_VISIBLE, mLayout.type, config.windowConfiguration.getWindowingMode(), null);
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                windowInsets = windowInsets.insetUnchecked(-padding.left, -padding.top, -padding.right, -padding.bottom);
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            final Rect contentInsets = windowInsets.getSystemWindowInsets().toRect();
            final Rect stableInsets = windowInsets.getStableInsets().toRect();
            final DisplayCutout displayCutout = windowInsets.getDisplayCutout() != null ? windowInsets.getDisplayCutout() : rawCutout;
            insetsChanged |= !mDispatchedContentInsets.equals(contentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(stableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(displayCutout);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(contentInsets);
                    mDispatchedStableInsets.set(stableInsets);
                    mDispatchedDisplayCutout = displayCutout;
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + windowInsets);
                    }
                    onApplyWindowInsets(windowInsets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    resetWindowPages();
                    mSession.finishDrawing(mWindow, null);
                    processLocalColors(mPendingXOffset, mPendingXOffsetStep);
                }
                reposition();
                mIWallpaperEngine.reportShown();
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface due to destroyed"");
        return;
    }
    boolean fixedSize = false;
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    else
        fixedSize = true;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    boolean insetsChanged = !mCreated;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags || mCurWindowPrivateFlags != mWindowPrivateFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded || !mIWallpaperEngine.mShownReported) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mCurWindowPrivateFlags = mWindowPrivateFlags;
            mLayout.privateFlags = mWindowPrivateFlags;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                // Retrieve watch round info
                TypedArray windowStyle = obtainStyledAttributes(com.android.internal.R.styleable.Window);
                windowStyle.recycle();
                // Add window
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mLayout.setFitInsetsTypes(0);
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                InputChannel inputChannel = new InputChannel();
                if (mSession.addToDisplay(mWindow, mLayout, View.VISIBLE, mDisplay.getDisplayId(), mRequestedVisibilities, inputChannel, mInsetsState, mTempControls) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mSession.setShouldZoomOutWallpaper(mWindow, shouldZoomOutWallpaper());
                mCreated = true;
                mInputEventReceiver = new WallpaperInputEventReceiver(inputChannel, Looper.myLooper());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            if (!fixedSize) {
                mLayout.surfaceInsets.set(mIWallpaperEngine.mDisplayPadding);
            } else {
                mLayout.surfaceInsets.set(0, 0, 0, 0);
            }
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, 0, -1, mWinFrames, mMergedConfiguration, mSurfaceControl, mInsetsState, mTempControls, mSurfaceSize);
            if (mSurfaceControl.isValid()) {
                if (mBbqSurfaceControl == null) {
                    mBbqSurfaceControl = new SurfaceControl.Builder().setName(""Wallpaper BBQ wrapper"").setHidden(false).setMetadata(METADATA_WINDOW_TYPE, TYPE_WALLPAPER).setBLASTLayer().setParent(mSurfaceControl).setCallsite(""Wallpaper#relayout"").build();
                    updateSurfaceDimming();
                }
                // Propagate transform hint from WM so we can use the right hint for the
                // first frame.
                mBbqSurfaceControl.setTransformHint(mSurfaceControl.getTransformHint());
                Surface blastSurface = getOrCreateBLASTSurface(mSurfaceSize.x, mSurfaceSize.y, mFormat);
                // would then inc the generation ID and cause EGL resources to be recreated.
                if (blastSurface != null) {
                    mSurfaceHolder.mSurface.transferFrom(blastSurface);
                }
            }
            if (!mLastSurfaceSize.equals(mSurfaceSize)) {
                mLastSurfaceSize.set(mSurfaceSize.x, mSurfaceSize.y);
            }
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrames);
            int w = mWinFrames.frame.width();
            int h = mWinFrames.frame.height();
            final DisplayCutout rawCutout = mInsetsState.getDisplayCutout();
            final Configuration config = getResources().getConfiguration();
            final Rect visibleFrame = new Rect(mWinFrames.frame);
            visibleFrame.intersect(mInsetsState.getDisplayFrame());
            WindowInsets windowInsets = mInsetsState.calculateInsets(visibleFrame, null, /* ignoringVisibilityState */
            config.isScreenRound(), false, /* alwaysConsumeSystemBars */
            mLayout.softInputMode, mLayout.flags, SYSTEM_UI_FLAG_VISIBLE, mLayout.type, config.windowConfiguration.getWindowingMode(), null);
            if (!fixedSize) {
                final Rect padding = mIWallpaperEngine.mDisplayPadding;
                w += padding.left + padding.right;
                h += padding.top + padding.bottom;
                windowInsets = windowInsets.insetUnchecked(-padding.left, -padding.top, -padding.right, -padding.bottom);
            } else {
                w = myWidth;
                h = myHeight;
            }
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            if (DEBUG) {
                Log.v(TAG, ""Wallpaper size has changed: ("" + mCurWidth + "", "" + mCurHeight);
            }
            final Rect contentInsets = windowInsets.getSystemWindowInsets().toRect();
            final Rect stableInsets = windowInsets.getStableInsets().toRect();
            final DisplayCutout displayCutout = windowInsets.getDisplayCutout() != null ? windowInsets.getDisplayCutout() : rawCutout;
            insetsChanged |= !mDispatchedContentInsets.equals(contentInsets);
            insetsChanged |= !mDispatchedStableInsets.equals(stableInsets);
            insetsChanged |= !mDispatchedDisplayCutout.equals(displayCutout);
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (insetsChanged) {
                    mDispatchedContentInsets.set(contentInsets);
                    mDispatchedStableInsets.set(stableInsets);
                    mDispatchedDisplayCutout = displayCutout;
                    if (DEBUG) {
                        Log.v(TAG, ""dispatching insets="" + windowInsets);
                    }
                    onApplyWindowInsets(windowInsets);
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    resetWindowPages();
                    mSession.finishDrawing(mWindow, null);
                    processLocalColors(mPendingXOffset, mPendingXOffsetStep);
                }
                reposition();
                reportEngineShown(shouldWaitForEngineShown());
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
86,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean)>",31,32,"<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean)>","<android.app.DisabledWallpaperManager: int setBitmap(Bitmap,Rect,boolean)>",0,"{
    return unsupported();
}","{
    unsupported();
    return 0;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change is that the implementation now explicitly calls `unsupported()` and then returns 0, whereas previously it returned the result of `unsupported()` directly. There is no direct change in behavior because both implementations essentially do the same thing which is calling `unsupported()` and eventually returning 0, so the code change type is 4.","There is no Compatibility Issue because the behavior of the method did not change from one version to the next. The method still does not support the operation and returns a constant value (0). Hence, no CI type is applicable."
88,"<android.hardware.camera2.impl.CameraDeviceImpl: CameraOfflineSession switchToOffline(Collection<Surface>,Executor,CameraOfflineSessionCallback)>",31,32,"<android.hardware.camera2.impl.CameraDeviceImpl: CameraOfflineSession switchToOffline(Collection<Surface>,Executor,CameraOfflineSessionCallback)>","<android.hardware.camera2.impl.CameraDeviceImpl: CameraOfflineSession switchToOffline(Collection<Surface>,Executor,CameraOfflineSessionCallback)>",0,"{
    if (offlineOutputs.isEmpty()) {
        throw new IllegalArgumentException(""Invalid offline surfaces!"");
    }
    HashSet<Integer> offlineStreamIds = new HashSet<Integer>();
    SparseArray<OutputConfiguration> offlineConfiguredOutputs = new SparseArray<OutputConfiguration>();
    CameraOfflineSession ret;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mOfflineSessionImpl != null) {
            throw new IllegalStateException(""Switch to offline mode already in progress"");
        }
        for (Surface surface : offlineOutputs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    offlineConfiguredOutputs.append(streamId, mConfiguredOutputs.valueAt(i));
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Offline surface is not part of this"" + "" session"");
            }
            if (!mOfflineSupport.contains(streamId)) {
                throw new IllegalArgumentException(""Surface: "" + surface + "" does not "" + "" support offline mode"");
            }
            offlineStreamIds.add(streamId);
        }
        stopRepeating();
        mOfflineSessionImpl = new CameraOfflineSessionImpl(mCameraId, mCharacteristics, executor, listener, offlineConfiguredOutputs, mConfiguredInput, mConfiguredOutputs, mFrameNumberTracker, mCaptureCallbackMap, mRequestLastFrameNumbersList);
        ret = mOfflineSessionImpl;
        mOfflineSwitchService = Executors.newSingleThreadExecutor();
        mConfiguredOutputs.clear();
        mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
        mIdle = true;
        mCaptureCallbackMap = new SparseArray<CaptureCallbackHolder>();
        mFrameNumberTracker = new FrameNumberTracker();
        mCurrentSession.closeWithoutDraining();
        mCurrentSession = null;
    }
    mOfflineSwitchService.execute(new Runnable() {

        @Override
        public void run() {
            // on 'mInterfaceLock'.
            try {
                ICameraOfflineSession remoteOfflineSession = mRemoteDevice.switchToOffline(mOfflineSessionImpl.getCallbacks(), Arrays.stream(offlineStreamIds.toArray(new Integer[offlineStreamIds.size()])).mapToInt(Integer::intValue).toArray());
                mOfflineSessionImpl.setRemoteSession(remoteOfflineSession);
            } catch (CameraAccessException e) {
                mOfflineSessionImpl.notifyFailedSwitch();
            } finally {
                mOfflineSessionImpl = null;
            }
        }
    });
    return ret;
}","{
    if (offlineOutputs.isEmpty()) {
        throw new IllegalArgumentException(""Invalid offline surfaces!"");
    }
    HashSet<Integer> offlineStreamIds = new HashSet<Integer>();
    SparseArray<OutputConfiguration> offlineConfiguredOutputs = new SparseArray<OutputConfiguration>();
    CameraOfflineSession ret;
    synchronized (mInterfaceLock) {
        checkIfCameraClosedOrInError();
        if (mOfflineSessionImpl != null) {
            throw new IllegalStateException(""Switch to offline mode already in progress"");
        }
        for (Surface surface : offlineOutputs) {
            int streamId = -1;
            for (int i = 0; i < mConfiguredOutputs.size(); i++) {
                if (surface == mConfiguredOutputs.valueAt(i).getSurface()) {
                    streamId = mConfiguredOutputs.keyAt(i);
                    offlineConfiguredOutputs.append(streamId, mConfiguredOutputs.valueAt(i));
                    break;
                }
            }
            if (streamId == -1) {
                throw new IllegalArgumentException(""Offline surface is not part of this"" + "" session"");
            }
            if (!mOfflineSupport.contains(streamId)) {
                throw new IllegalArgumentException(""Surface: "" + surface + "" does not "" + "" support offline mode"");
            }
            offlineStreamIds.add(streamId);
        }
        stopRepeating();
        mOfflineSessionImpl = new CameraOfflineSessionImpl(mCameraId, mCharacteristics, executor, listener, offlineConfiguredOutputs, mConfiguredInput, mConfiguredOutputs, mFrameNumberTracker, mCaptureCallbackMap, mRequestLastFrameNumbersList);
        ret = mOfflineSessionImpl;
        mOfflineSwitchService = Executors.newSingleThreadExecutor();
        mConfiguredOutputs.clear();
        mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(REQUEST_ID_NONE, null);
        mIdle = true;
        mCaptureCallbackMap = new SparseArray<CaptureCallbackHolder>();
        mBatchOutputMap = new HashMap<>();
        mFrameNumberTracker = new FrameNumberTracker();
        mCurrentSession.closeWithoutDraining();
        mCurrentSession = null;
    }
    mOfflineSwitchService.execute(new Runnable() {

        @Override
        public void run() {
            // on 'mInterfaceLock'.
            try {
                ICameraOfflineSession remoteOfflineSession = mRemoteDevice.switchToOffline(mOfflineSessionImpl.getCallbacks(), Arrays.stream(offlineStreamIds.toArray(new Integer[offlineStreamIds.size()])).mapToInt(Integer::intValue).toArray());
                mOfflineSessionImpl.setRemoteSession(remoteOfflineSession);
            } catch (CameraAccessException e) {
                mOfflineSessionImpl.notifyFailedSwitch();
            } finally {
                mOfflineSessionImpl = null;
            }
        }
    });
    return ret;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
90,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int,boolean,ColorManagementProxy)>",31,32,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int,boolean,ColorManagementProxy)>","<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean,int,int,boolean,ColorManagementProxy)>",0,"{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId && !mCachedWallpaper.isRecycled()) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(context, userId, hardware, cmProxy);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""Out of memory loading the current wallpaper: "" + e);
        } catch (SecurityException e) {
            if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.O_MR1) {
                Log.w(TAG, ""No permission to access wallpaper, suppressing"" + "" exception to avoid crashing legacy app."");
            } else {
                // Post-O apps really most sincerely need the permission.
                throw e;
            }
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}","{
    if (mService != null) {
        try {
            if (!mService.isWallpaperSupported(context.getOpPackageName())) {
                return null;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    synchronized (this) {
        if (mCachedWallpaper != null && mCachedWallpaperUserId == userId && !mCachedWallpaper.isRecycled()) {
            return mCachedWallpaper;
        }
        mCachedWallpaper = null;
        mCachedWallpaperUserId = 0;
        try {
            mCachedWallpaper = getCurrentWallpaperLocked(context, userId, hardware, cmProxy);
            mCachedWallpaperUserId = userId;
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""Out of memory loading the current wallpaper: "" + e);
        } catch (SecurityException e) {
            if (context.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.O_MR1) {
                Log.w(TAG, ""No permission to access wallpaper, suppressing"" + "" exception to avoid crashing legacy app."");
            } else {
                // Post-O apps really most sincerely need the permission.
                throw e;
            }
        }
        if (mCachedWallpaper != null) {
            return mCachedWallpaper;
        }
    }
    if (returnDefault) {
        Bitmap defaultWallpaper = mDefaultWallpaper;
        if (defaultWallpaper == null || defaultWallpaper.isRecycled()) {
            defaultWallpaper = getDefaultWallpaper(context, which);
            synchronized (this) {
                mDefaultWallpaper = defaultWallpaper;
            }
        }
        return defaultWallpaper;
    }
    return null;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"There is a change in the condition to verify if the default wallpaper is non-null or is recycled. In the late version, the condition includes || defaultWallpaper.isRecycled(). This is a control dependency change, and other statement change as it affects the logic of whether the cached wallpaper is returned or a new one is obtained. The change type is thus 3,4.","Due to the added check for defaultWallpaper.isRecycled(), the late version could potentially return a different wallpaper bitmap than the early version for the same conditions, therefore introducing a Compatibility Issue of type 1 due to different potential return values."
91,<android.view.ScrollCaptureResponse.Builder: ScrollCaptureResponse build()>,31,32,<android.view.ScrollCaptureResponse.Builder: ScrollCaptureResponse build()>,<android.view.ScrollCaptureResponse.Builder: ScrollCaptureResponse build()>,0,"{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x40;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mDescription = """";
    }
    if ((mBuilderFieldsSet & 0x2) == 0) {
        mConnection = null;
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mWindowBounds = null;
    }
    if ((mBuilderFieldsSet & 0x8) == 0) {
        mBoundsInWindow = null;
    }
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mWindowTitle = null;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mMessages = new ArrayList<>();
    }
    ScrollCaptureResponse o = new ScrollCaptureResponse(mDescription, mConnection, mWindowBounds, mBoundsInWindow, mWindowTitle, mMessages);
    return o;
}","{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x80;
    if ((mBuilderFieldsSet & 0x1) == 0) {
        mDescription = """";
    }
    if ((mBuilderFieldsSet & 0x2) == 0) {
        mConnection = null;
    }
    if ((mBuilderFieldsSet & 0x4) == 0) {
        mWindowBounds = null;
    }
    if ((mBuilderFieldsSet & 0x8) == 0) {
        mBoundsInWindow = null;
    }
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mWindowTitle = null;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mPackageName = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mMessages = new ArrayList<>();
    }
    ScrollCaptureResponse o = new ScrollCaptureResponse(mDescription, mConnection, mWindowBounds, mBoundsInWindow, mWindowTitle, mPackageName, mMessages);
    return o;
}",1,"/**
 * Builds the instance. This builder should not be touched after calling this!
 */
","/**
 * Builds the instance. This builder should not be touched after calling this!
 */
",-1,[@NonNull],[@NonNull],-1,-1,-1,-1,-1,-1,"1,3,5","1,5","The bitmask change, with 'mBuilderFieldsSet |= 0x40' modificated to 'mBuilderFieldsSet |= 0x80', indicate a control dependency change, and additional checks on new bitmask values have been added, so the change type is 3. The 'if' conditionals for setting default values has been amended with an additional condition and the instantiation of `ScrollCaptureResponse` has also gained a new parameter, which reflects a change in return statement and a dependent API change, so the change type is 1,5.","The dependent API of ScrollCaptureResponse constructor has changed, which could lead to a different value returned due to the extra parameter mPackageName. Since there's an additional bitmask condition and an additional field being set to a default value when the condition is false, these changes potentially lead to a different value being returned in the late version. Therefore, the CI types are 1 and 5 due to the return statement changed and dependent API changed."
94,<android.window.TransitionFilter.Requirement: boolean matches(TransitionInfo)>,31,32,<android.window.TransitionFilter.Requirement: boolean matches(TransitionInfo)>,<android.window.TransitionFilter.Requirement: boolean matches(TransitionInfo)>,0,"{
    for (int i = info.getChanges().size() - 1; i >= 0; --i) {
        final TransitionInfo.Change change = info.getChanges().get(i);
        if (!TransitionInfo.isIndependent(change, info)) {
            // Only look at independent animating windows.
            continue;
        }
        if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {
            if (change.getTaskInfo() == null || change.getTaskInfo().getActivityType() != mActivityType) {
                continue;
            }
        }
        if (mModes != null) {
            boolean pass = false;
            for (int m = 0; m < mModes.length; ++m) {
                if (mModes[m] == change.getMode()) {
                    pass = true;
                    break;
                }
            }
            if (!pass)
                continue;
        }
        return true;
    }
    return false;
}","{
    for (int i = info.getChanges().size() - 1; i >= 0; --i) {
        final TransitionInfo.Change change = info.getChanges().get(i);
        if (mMustBeIndependent && !TransitionInfo.isIndependent(change, info)) {
            // Only look at independent animating windows.
            continue;
        }
        if (mOrder == CONTAINER_ORDER_TOP && i > 0) {
            continue;
        }
        if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {
            if (change.getTaskInfo() == null || change.getTaskInfo().getActivityType() != mActivityType) {
                continue;
            }
        }
        if (!matchesTopActivity(change.getTaskInfo()))
            continue;
        if (mModes != null) {
            boolean pass = false;
            for (int m = 0; m < mModes.length; ++m) {
                if (mModes[m] == change.getMode()) {
                    pass = true;
                    break;
                }
            }
            if (!pass)
                continue;
        }
        if ((change.getFlags() & mFlags) != mFlags) {
            continue;
        }
        if (mMustBeTask && change.getTaskInfo() == null) {
            continue;
        }
        return true;
    }
    return false;
}",1,"/**
 * Go through changes and find if at-least one change matches this filter
 */
","/**
 * Go through changes and find if at-least one change matches this filter
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,5",1,The late version has several code changes:,- `matchesTopActivity(change.getTaskInfo())` condition is added.
95,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int setRepeating(Request,IRequestCallback)>",31,32,"<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int setRepeating(Request,IRequestCallback)>","<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: int setRepeating(Request,IRequestCallback)>",0,"{
    int seqId = -1;
    synchronized (mInterfaceLock) {
        try {
            CaptureRequest repeatingRequest = initializeCaptureRequest(mCameraDevice, request, mCameraConfigMap);
            CaptureCallbackHandler captureCallback = new CaptureCallbackHandler(callback);
            seqId = mCaptureSession.setSingleRepeatingRequest(repeatingRequest, new CameraExtensionUtils.HandlerExecutor(mHandler), captureCallback);
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed to enable repeating request!"");
        } catch (IllegalStateException e) {
            Log.e(TAG, ""Capture session closed!"");
        }
    }
    return seqId;
}","{
    int seqId = -1;
    try {
        CaptureRequest repeatingRequest = initializeCaptureRequest(mCameraDevice, request, mCameraConfigMap);
        CaptureCallbackHandler captureCallback = new CaptureCallbackHandler(callback);
        seqId = mCaptureSession.setSingleRepeatingRequest(repeatingRequest, new CameraExtensionUtils.HandlerExecutor(mHandler), captureCallback);
    } catch (CameraAccessException e) {
        Log.e(TAG, ""Failed to enable repeating request!"");
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Capture session closed!"");
    }
    return seqId;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The synchronization block (`synchronized (mInterfaceLock) { ... }`) has been removed, so the code change type is 3, as it alters a control dependency (the locking mechanism).","The removal of a synchronization block may affect the thread safety of the method if it's accessed concurrently, but it does not inherently cause a change in the method's behavior with respect to its return values or the exceptions it throws. Therefore, this does not constitute a compatibility issue concerning returns or exceptions; thus, no CI is detected."
96,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,31,32,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,0,"{
    final int actionMasked = ev.getActionMasked();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroll != null && mFastScroll.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (isGlowActive()) {
                    // Pressed during edge effect, so this is considered the same as a fling catch.
                    touchMode = mTouchMode = TOUCH_MODE_FLING;
                } else if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                mNestedYOffset = 0;
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, null)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                stopNestedScroll();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    final int actionMasked = ev.getActionMasked();
    View v;
    if (mPositionScroller != null) {
        mPositionScroller.stop();
    }
    if (mIsDetaching || !isAttachedToWindow()) {
        // in a bogus state.
        return false;
    }
    if (mFastScroll != null && mFastScroll.onInterceptTouchEvent(ev)) {
        return true;
    }
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (doesTouchStopStretch()) {
                    // Pressed during edge effect, so this is considered the same as a fling catch.
                    touchMode = mTouchMode = TOUCH_MODE_FLING;
                } else if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                mNestedYOffset = 0;
                startNestedScroll(SCROLL_AXIS_VERTICAL);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, null)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                stopNestedScroll();
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,,,,
99,<android.window.SplashScreenView: void remove()>,31,32,<android.window.SplashScreenView: void remove()>,<android.window.SplashScreenView: void remove()>,0,"{
    if (mHasRemoved) {
        return;
    }
    setVisibility(GONE);
    if (mParceledIconBitmap != null) {
        if (mIconView instanceof ImageView) {
            ((ImageView) mIconView).setImageDrawable(null);
        } else if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBitmap.recycle();
        mParceledIconBitmap = null;
    }
    if (mParceledBrandingBitmap != null) {
        mBrandingImageView.setBackground(null);
        mParceledBrandingBitmap.recycle();
        mParceledBrandingBitmap = null;
    }
    if (mParceledIconBackgroundBitmap != null) {
        if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBackgroundBitmap.recycle();
        mParceledIconBackgroundBitmap = null;
    }
    if (mWindow != null) {
        final DecorView decorView = (DecorView) mWindow.peekDecorView();
        if (DEBUG) {
            Log.d(TAG, ""remove starting view"");
        }
        if (decorView != null) {
            decorView.removeView(this);
        }
        restoreSystemUIColors();
        mWindow = null;
    }
    if (mHostActivity != null) {
        mHostActivity.setSplashScreenView(null);
        mHostActivity = null;
    }
    mHasRemoved = true;
}","{
    if (mHasRemoved) {
        return;
    }
    setVisibility(GONE);
    if (mParceledIconBitmap != null) {
        if (mIconView instanceof ImageView) {
            ((ImageView) mIconView).setImageDrawable(null);
        } else if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBitmap.recycle();
        mParceledIconBitmap = null;
    }
    if (mParceledBrandingBitmap != null) {
        mBrandingImageView.setBackground(null);
        mParceledBrandingBitmap.recycle();
        mParceledBrandingBitmap = null;
    }
    if (mParceledIconBackgroundBitmap != null) {
        if (mIconView != null) {
            mIconView.setBackground(null);
        }
        mParceledIconBackgroundBitmap.recycle();
        mParceledIconBackgroundBitmap = null;
    }
    if (mWindow != null) {
        final DecorView decorView = (DecorView) mWindow.peekDecorView();
        if (DEBUG) {
            Log.d(TAG, ""remove starting view"");
        }
        if (decorView != null) {
            decorView.removeView(this);
        }
        restoreSystemUIColors();
        mWindow = null;
    }
    mHasRemoved = true;
}",1,"/**
 * <p>Remove this view and release its resource. </p>
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 */
","/**
 * <p>Remove this view and release its resource. </p>
 * <p><strong>Do not</strong> invoke this method from a drawing method
 * ({@link #onDraw(android.graphics.Canvas)} for instance).</p>
 */
",-1,[@UiThread],[@UiThread],-1,-1,-1,-1,-1,-1,0,0,There are no code changes between the early and late versions of the implementation.,"Since there are no changes in the implementation, no Compatibility Issue could arise for this API."
100,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void stopRepeating()>,31,32,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void stopRepeating()>,<android.hardware.camera2.impl.CameraAdvancedExtensionSessionImpl.RequestProcessor: void stopRepeating()>,0,"{
    synchronized (mInterfaceLock) {
        try {
            mCaptureSession.stopRepeating();
        } catch (CameraAccessException e) {
            Log.e(TAG, ""Failed during repeating capture stop!"");
        } catch (IllegalStateException e) {
            Log.e(TAG, ""Capture session closed!"");
        }
    }
}","{
    try {
        mCaptureSession.stopRepeating();
    } catch (CameraAccessException e) {
        Log.e(TAG, ""Failed during repeating capture stop!"");
    } catch (IllegalStateException e) {
        Log.e(TAG, ""Capture session closed!"");
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The synchronized block (synchronized (mInterfaceLock)) has been removed, so this change affects the threading behavior of the method but does not alter the control flow related to returns or exceptions directly, hence the change type is 4.","The removal of the synchronized block affects thread-safety and may affect when the method is allowed to run in multi-threaded environments, but this does not inherently cause the API to return a different value or throw a new/different exception as the internal logic and exception handling have not changed. Thus, there is no direct Compatibility Issue, and the CI type is 0."
102,"<android.app.Service: void startForeground(int,Notification,int)>",31,32,"<android.app.Service: void startForeground(int,Notification,int)>","<android.app.Service: void startForeground(int,Notification,int)>",0,"{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0, foregroundServiceType);
    } catch (RemoteException ex) {
    }
}","{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0, foregroundServiceType);
        clearStartForegroundServiceStackTrace();
    } catch (RemoteException ex) {
    }
}",1,"/**
 * An overloaded version of {@link #startForeground(int, Notification)} with additional
 * foregroundServiceType parameter.
 *
 * <p>Apps built with SDK version {@link android.os.Build.VERSION_CODES#Q} or later can specify
 * the foreground service types using attribute {@link android.R.attr#foregroundServiceType} in
 * service element of manifest file. The value of attribute
 * {@link android.R.attr#foregroundServiceType} can be multiple flags ORed together.</p>
 *
 * <p>The foregroundServiceType parameter must be a subset flags of what is specified in manifest
 * attribute {@link android.R.attr#foregroundServiceType}, if not, an IllegalArgumentException is
 * thrown. Specify foregroundServiceType parameter as
 * {@link android.content.pm.ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST} to use all flags that
 * is specified in manifest attribute foregroundServiceType.</p>
 *
 * <div class=""caution"">
 * <p><strong>Note:</strong>
 * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},
 * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}
 * or higher are not allowed to start foreground services from the background.
 * See
 * <a href=""{@docRoot}/about/versions/12/behavior-changes-12"">
 * Behavior changes: Apps targeting Android 12
 * </a>
 * for more details.
 * </div>
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 * @param foregroundServiceType must be a subset flags of manifest attribute
 * {@link android.R.attr#foregroundServiceType} flags.
 *
 * @throws IllegalArgumentException if param foregroundServiceType is not subset of manifest
 * attribute {@link android.R.attr#foregroundServiceType}.
 * @throws ForegroundServiceStartNotAllowedException
 * If the app targeting API is
 * {@link android.os.Build.VERSION_CODES#S} or later, and the service is restricted from
 * becoming foreground service due to background restriction.
 *
 * @see android.content.pm.ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST
 */
","/**
 * An overloaded version of {@link #startForeground(int, Notification)} with additional
 * foregroundServiceType parameter.
 *
 * <p>Apps built with SDK version {@link android.os.Build.VERSION_CODES#Q} or later can specify
 * the foreground service types using attribute {@link android.R.attr#foregroundServiceType} in
 * service element of manifest file. The value of attribute
 * {@link android.R.attr#foregroundServiceType} can be multiple flags ORed together.</p>
 *
 * <p>The foregroundServiceType parameter must be a subset flags of what is specified in manifest
 * attribute {@link android.R.attr#foregroundServiceType}, if not, an IllegalArgumentException is
 * thrown. Specify foregroundServiceType parameter as
 * {@link android.content.pm.ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST} to use all flags that
 * is specified in manifest attribute foregroundServiceType.</p>
 *
 * <div class=""caution"">
 * <p><strong>Note:</strong>
 * Beginning with SDK Version {@link android.os.Build.VERSION_CODES#S},
 * apps targeting SDK Version {@link android.os.Build.VERSION_CODES#S}
 * or higher are not allowed to start foreground services from the background.
 * See
 * <a href=""{@docRoot}/about/versions/12/behavior-changes-12"">
 * Behavior changes: Apps targeting Android 12
 * </a>
 * for more details.
 * </div>
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 * @param foregroundServiceType must be a subset flags of manifest attribute
 * {@link android.R.attr#foregroundServiceType} flags.
 *
 * @throws IllegalArgumentException if param foregroundServiceType is not subset of manifest
 * attribute {@link android.R.attr#foregroundServiceType}.
 * @throws ForegroundServiceStartNotAllowedException
 * If the app targeting API is
 * {@link android.os.Build.VERSION_CODES#S} or later, and the service is restricted from
 * becoming foreground service due to background restriction.
 *
 * @see android.content.pm.ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There is a new statement 'clearStartForegroundServiceStackTrace();' that has been added to the try block but it does not alter the return type or exception handling, so the code change type is 4.","The added statement is a cleanup method and does not affect the value that the API returns nor does it change the exception handling behavior, thus there is no Compatibility Issue; the CI type is 0."
103,"<android.app.ContextImpl: Context createTokenContext(IBinder,Display)>",31,32,"<android.app.ContextImpl: Context createTokenContext(IBinder,Display)>","<android.app.ContextImpl: Context createTokenContext(IBinder,Display)>",0,"{
    if (display == null) {
        throw new IllegalArgumentException(""Display must not be null"");
    }
    final ContextImpl tokenContext = createWindowContextBase(token, display);
    tokenContext.setResources(createWindowContextResources(tokenContext));
    return tokenContext;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""Display must not be null"");
    }
    return createWindowContextBase(token, display.getDisplayId());
}",1,,,-1,"[@NonNull, @Override]","[@NonNull, @Override]",-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed, removing the calls to tokenContext.setResources() and replacing createWindowContextBase(token, display) with createWindowContextBase(token, display.getDisplayId()), and this implies that the dependent API createWindowContextBase has changed to accept a display ID instead of a display object. Additionally, there has been the deletion of a method call to setResources, which is an other statement changed. Therefore, the code change types are 1, 4, and 5.","The change in the return statement could potentially lead to a different returned object because the method createWindowContextBase when invoked with different parameters (display vs display.getDisplayId()) could create a context with different resources or properties. Moreover, the deletion of the setResources call means that the resources of the tokenContext might not be set in the new implementation as they were in the old implementation, which can also lead to different behavior. Hence, the CI type is 1."
104,<android.service.wallpaper.WallpaperService.Engine: void reportVisibility()>,31,32,<android.service.wallpaper.WallpaperService.Engine: void reportVisibility()>,<android.service.wallpaper.WallpaperService.Engine: void reportVisibility()>,0,"{
    if (!mDestroyed) {
        mDisplayState = mDisplay == null ? Display.STATE_UNKNOWN : mDisplay.getState();
        boolean visible = mVisible && mDisplayState != Display.STATE_OFF;
        if (mReportedVisible != visible) {
            mReportedVisible = visible;
            if (DEBUG)
                Log.v(TAG, ""onVisibilityChanged("" + visible + ""): "" + this);
            if (visible) {
                // If becoming visible, in preview mode the surface
                // may have been destroyed so now we need to make
                // sure it is re-created.
                doOffsetsChanged(false);
                // force relayout to get new surface
                updateSurface(true, false, false);
            }
            onVisibilityChanged(visible);
        }
    }
}","{
    if (mScreenshotSurfaceControl != null && mVisible) {
        if (DEBUG)
            Log.v(TAG, ""Frozen so don't report visibility change"");
        return;
    }
    if (!mDestroyed) {
        mDisplayState = mDisplay == null ? Display.STATE_UNKNOWN : mDisplay.getState();
        boolean visible = mVisible && mDisplayState != Display.STATE_OFF;
        if (mReportedVisible != visible) {
            mReportedVisible = visible;
            if (DEBUG)
                Log.v(TAG, ""onVisibilityChanged("" + visible + ""): "" + this);
            if (visible) {
                // If becoming visible, in preview mode the surface
                // may have been destroyed so now we need to make
                // sure it is re-created.
                doOffsetsChanged(false);
                // force relayout to get new surface
                updateSurface(true, false, false);
            }
            onVisibilityChanged(visible);
            if (mReportedVisible && mFrozenRequested) {
                if (DEBUG)
                    Log.v(TAG, ""Freezing wallpaper after visibility update"");
                freeze();
            }
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The method implementation has introduced a new control flow checking if `mScreenshotSurfaceControl` is not null and `mVisible` is true, which leads to an early return statement. New debug log statements have been added, and also a new conditional block checking `mReportedVisible` and `mFrozenRequested`, then calling `freeze()`. Hence, the changes include a new return statement, control flow dependency, and other statements, so the code change types are 1, 3, and 4.","The introduced early return and new control flow can result in the method exiting before it previously would, and also a potentially new behavior is introduced with the call to `freeze()`. This could potentially cause different behavior for callers of the method who expect `onVisibilityChanged(visible)` to be called, which may no longer happen in certain circumstances. Therefore, a CI is present due to the potential for a different return value or flow, and the type is 1."
105,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,31,32,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,<android.view.accessibility.AccessibilityWindowInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append("", displayId="").append(mDisplayId);
    builder.append("", id="").append(mId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", region="").append(mRegionInScreen);
    builder.append("", bounds="").append(mRegionInScreen.getBounds());
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(isInPictureInPictureMode());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != AccessibilityNodeInfo.UNDEFINED_NODE_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""AccessibilityWindowInfo["");
    builder.append(""title="").append(mTitle);
    builder.append("", displayId="").append(mDisplayId);
    builder.append("", id="").append(mId);
    builder.append("", taskId="").append(mTaskId);
    builder.append("", type="").append(typeToString(mType));
    builder.append("", layer="").append(mLayer);
    builder.append("", region="").append(mRegionInScreen);
    builder.append("", bounds="").append(mRegionInScreen.getBounds());
    builder.append("", focused="").append(isFocused());
    builder.append("", active="").append(isActive());
    builder.append("", pictureInPicture="").append(isInPictureInPictureMode());
    if (DEBUG) {
        builder.append("", parent="").append(mParentId);
        builder.append("", children=["");
        if (mChildIds != null) {
            final int childCount = mChildIds.size();
            for (int i = 0; i < childCount; i++) {
                builder.append(mChildIds.get(i));
                if (i < childCount - 1) {
                    builder.append(',');
                }
            }
        } else {
            builder.append(""null"");
        }
        builder.append(']');
    } else {
        builder.append("", hasParent="").append(mParentId != UNDEFINED_WINDOW_ID);
        builder.append("", isAnchored="").append(mAnchorId != AccessibilityNodeInfo.UNDEFINED_NODE_ID);
        builder.append("", hasChildren="").append(mChildIds != null && mChildIds.size() > 0);
    }
    builder.append(']');
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The change is that a new string append operation ""builder.append("", taskId="").append(mTaskId);"" has been added to the StringBuilder operations, which does not affect any control structures, exception handling, return type, or dependent API changes. Therefore, it classifies as 'Other statement changed'.","The addition of task ID information changes the string returned by the method, thus affecting the output of the method and leading to a potential Compatibility Issue due to different return values. The CI type is 1."
106,<android.app.Dialog: void dismiss()>,31,32,<android.app.Dialog: void dismiss()>,<android.app.Dialog: void dismiss()>,0,"{
    if (Looper.myLooper() == mHandler.getLooper()) {
        dismissDialog();
    } else {
        mHandler.post(mDismissAction);
    }
}","{
    if (mDismissOverride != null) {
        mDismissOverride.run();
        return;
    }
    if (Looper.myLooper() == mHandler.getLooper()) {
        dismissDialog();
    } else {
        mHandler.post(mDismissAction);
    }
}",1,"/**
 * Dismiss this dialog, removing it from the screen. This method can be
 * invoked safely from any thread.  Note that you should not override this
 * method to do cleanup when the dialog is dismissed, instead implement
 * that in {@link #onStop}.
 */
","/**
 * Dismiss this dialog, removing it from the screen. This method can be
 * invoked safely from any thread.  Note that you should not override this
 * method to do cleanup when the dialog is dismissed, instead implement
 * that in {@link #onStop}.
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,0,"The late version introduces a new if-statement check for 'mDismissOverride' and return immediately if it is not null. Since this is an additional condition introduced at the beginning of the function, the code change type is 3.","While a new if-statement and corresponding action were added in the late version, they are designed to be overriding extensions of behavior. If the 'mDismissOverride' is not set (null), the method's behavior is unchanged compared to the early version. The added code only provides a way to customize the dismiss behavior and will not affect existing behavior if not used. Hence, no Compatibility Issue arises from functional perspective, the CI type is 0."
107,<android.appwidget.AppWidgetHostView: View getDefaultView()>,31,32,<android.appwidget.AppWidgetHostView: View getDefaultView()>,<android.appwidget.AppWidgetHostView: View getDefaultView()>,0,"{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            if (!(defaultView instanceof AdapterView)) {
                // AdapterView does not support onClickListener
                defaultView.setOnClickListener(this::onDefaultViewClicked);
            }
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo, exception);
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}","{
    if (LOGD) {
        Log.d(TAG, ""getDefaultView"");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContextEnsuringCorrectCachedApkPath();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(INFLATER_FILTER);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
            if (!(defaultView instanceof AdapterView)) {
                // AdapterView does not support onClickListener
                defaultView.setOnClickListener(this::onDefaultViewClicked);
            }
        } else {
            Log.w(TAG, ""can't inflate defaultView because mInfo is missing"");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, ""Error inflating AppWidget "" + mInfo, exception);
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, ""getDefaultView couldn't find any view, so inflating error"");
        defaultView = getErrorView();
    }
    return defaultView;
}",1,"/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
","/**
 * Inflate and return the default layout requested by AppWidget provider.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method `getRemoteContext()` was changed to `getRemoteContextEnsuringCorrectCachedApkPath()` in the implementation, which indicates a dependent API has changed. The change type is 5.","Although there has been a change in the dependent API, there is no indication from the given change that it will lead to a different return value or exception thrown. The method body and logic remain effectively unchanged, and the method ends with the same return value in both versions, so the CI type is 0."
108,<android.view.contentcapture.ContentCaptureContext: String toString()>,31,32,<android.view.contentcapture.ContentCaptureContext: String toString()>,<android.view.contentcapture.ContentCaptureContext: String toString()>,0,"{
    final StringBuilder builder = new StringBuilder(""Context["");
    if (fromServer()) {
        builder.append(""act="").append(ComponentName.flattenToShortString(mComponentName)).append("", activityId="").append(mActivityId).append("", displayId="").append(mDisplayId).append("", flags="").append(mFlags);
    } else {
        builder.append(""id="").append(mId);
        if (mExtras != null) {
            // NOTE: cannot print because it could contain PII
            builder.append("", hasExtras"");
        }
    }
    if (mParentSessionId != NO_SESSION_ID) {
        builder.append("", parentId="").append(mParentSessionId);
    }
    return builder.append(']').toString();
}","{
    final StringBuilder builder = new StringBuilder(""Context["");
    if (fromServer()) {
        builder.append(""act="").append(ComponentName.flattenToShortString(mComponentName)).append("", activityId="").append(mActivityId).append("", displayId="").append(mDisplayId).append("", windowToken="").append(mWindowToken).append("", flags="").append(mFlags);
    } else {
        builder.append(""id="").append(mId);
        if (mExtras != null) {
            // NOTE: cannot print because it could contain PII
            builder.append("", hasExtras"");
        }
    }
    if (mParentSessionId != NO_SESSION_ID) {
        builder.append("", parentId="").append(mParentSessionId);
    }
    return builder.append(']').toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"The change from appending "", flags="" to "", windowToken="" followed by appending the variable mFlags or mWindowToken when building the string representation in the fromServer() condition is a change that does not affect the method contract; it simply alters some content that is built into the string. The method still returns a string, and this is an internal detail of the string content. Thus, the change type is 4.","Even though there is a change in the content of the string representation, the return type is still a String, and no change has been made that affects how the method behaves from an API perspective (i.e., the method does not return a different type, nor does it throw a new exception). Therefore, there is no compatibility issue; the change is only in the internal details of what the String contains, not in the API's contract or its external behavior. The CI type is 0."
109,<android.app.TaskInfo: String toString()>,31,32,<android.app.TaskInfo: String toString()>,<android.app.TaskInfo: String toString()>,0,"{
    return ""TaskInfo{userId="" + userId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" supportsMultiWindow="" + supportsMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" displayCutoutSafeInsets="" + displayCutoutInsets + "" topActivityInfo="" + topActivityInfo + "" launchCookies="" + launchCookies + "" positionInParent="" + positionInParent + "" parentTaskId="" + parentTaskId + "" isFocused="" + isFocused + "" isVisible="" + isVisible + "" topActivityInSizeCompat="" + topActivityInSizeCompat + "" locusId= "" + mTopActivityLocusId + ""}"";
}","{
    return ""TaskInfo{userId="" + userId + "" taskId="" + taskId + "" displayId="" + displayId + "" isRunning="" + isRunning + "" baseIntent="" + baseIntent + "" baseActivity="" + baseActivity + "" topActivity="" + topActivity + "" origActivity="" + origActivity + "" realActivity="" + realActivity + "" numActivities="" + numActivities + "" lastActiveTime="" + lastActiveTime + "" supportsSplitScreenMultiWindow="" + supportsSplitScreenMultiWindow + "" supportsMultiWindow="" + supportsMultiWindow + "" resizeMode="" + resizeMode + "" isResizeable="" + isResizeable + "" token="" + token + "" topActivityType="" + topActivityType + "" pictureInPictureParams="" + pictureInPictureParams + "" displayCutoutSafeInsets="" + displayCutoutInsets + "" topActivityInfo="" + topActivityInfo + "" launchCookies="" + launchCookies + "" positionInParent="" + positionInParent + "" parentTaskId="" + parentTaskId + "" isFocused="" + isFocused + "" isVisible="" + isVisible + "" isSleeping="" + isSleeping + "" topActivityInSizeCompat="" + topActivityInSizeCompat + "" locusId="" + mTopActivityLocusId + "" displayAreaFeatureId="" + displayAreaFeatureId + ""}"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,1,1,"The method implementation in the late version has added additional information to the returned String, specifically ""isSleeping="" and ""displayAreaFeatureId="". This means the return statement has changed.","The inclusion of new data in the returned String from the `toString()` method will change the output of the method between the early and late versions, making the returned value different. Therefore, the CI type is 1."
110,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,31,32,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,<android.companion.CompanionDeviceManager.CallbackProxy: void onActivityDestroyed(Activity)>,0,"{
    synchronized (mLock) {
        if (activity != getActivity())
            return;
        try {
            mService.stopScan(mRequest, this, getCallingPackage());
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        getActivity().getApplication().unregisterActivityLifecycleCallbacks(this);
        mCallback = null;
        mHandler = null;
        mRequest = null;
    }
}","{
    synchronized (mLock) {
        if (activity != getActivity())
            return;
        try {
            mService.stopScan(mRequest, this, getCallingPackage());
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        getActivity().getApplication().unregisterActivityLifecycleCallbacks(this);
        mCallback = null;
        mHandler = null;
        mRequest = null;
        mContext = null;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,The only change between the two versions is the addition of `mContext = null;` in the late implementation. This is considered an 'Other statement changed'.,"The added statement `mContext = null;` only clears a reference and does not affect the method's behavior in terms of exception throwing or returned values. Consequently, there is no Compatibility Issue."
111,<android.view.ScrollCaptureResponse.Builder: Builder setMessages(ArrayList<String>)>,31,32,<android.view.ScrollCaptureResponse.Builder: Builder setMessages(ArrayList<String>)>,<android.view.ScrollCaptureResponse.Builder: Builder setMessages(ArrayList<String>)>,0,"{
    checkNotUsed();
    mBuilderFieldsSet |= 0x20;
    mMessages = value;
    return this;
}","{
    checkNotUsed();
    mBuilderFieldsSet |= 0x40;
    mMessages = value;
    return this;
}",1,"/**
 * Carries additional logging and debugging information when enabled.
 */
","/**
 * Carries additional logging and debugging information when enabled.
 */
",-1,"[@DataClass.Generated.Member, @NonNull]","[@DataClass.Generated.Member, @NonNull]",-1,-1,-1,-1,-1,-1,4,0,"The only change here is the value assigned to the bit field `mBuilderFieldsSet`, which has been changed from 0x20 to 0x40. This change doesn't affect the return type, the value, or the exception thrown, so it's classified as 4.","There is no compatibility issue since the change doesn't affect the behavior of the API that is visible or impacting the caller; the value and type of the returned object (`this`), along with potential exceptions that could be thrown, remain unchanged. The API will still work the same way from the perspective of a caller."
112,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",31,32,"<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>","<android.hardware.display.DisplayManager: VirtualDisplay createVirtualDisplay(String,int,int,int,Surface,int,Callback,Handler)>",0,"{
    final VirtualDisplayConfig.Builder builder = new VirtualDisplayConfig.Builder(name, width, height, densityDpi);
    builder.setFlags(flags);
    if (surface != null) {
        builder.setSurface(surface);
    }
    return createVirtualDisplay(null, /* projection */
    builder.build(), callback, handler);
}","{
    final VirtualDisplayConfig.Builder builder = new VirtualDisplayConfig.Builder(name, width, height, densityDpi);
    builder.setFlags(flags);
    if (surface != null) {
        builder.setSurface(surface);
    }
    return createVirtualDisplay(null, /* projection */
    builder.build(), callback, handler, null);
}",1,"/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
","/**
 * Creates a virtual display.
 * <p>
 * The content of a virtual display is rendered to a {@link Surface} provided
 * by the application.
 * </p><p>
 * The virtual display should be {@link VirtualDisplay#release released}
 * when no longer needed.  Because a virtual display renders to a surface
 * provided by the application, it will be released automatically when the
 * process terminates and all remaining windows on it will be forcibly removed.
 * </p><p>
 * The behavior of the virtual display depends on the flags that are provided
 * to this method.  By default, virtual displays are created to be private,
 * non-presentation and unsecure.  Permissions may be required to use certain flags.
 * </p><p>
 * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may
 * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.
 * Previously, the surface had to be non-null when {@link #createVirtualDisplay}
 * was called and could not be changed for the lifetime of the display.
 * </p><p>
 * Detaching the surface that backs a virtual display has a similar effect to
 * turning off the screen.
 * </p>
 *
 * @param name The name of the virtual display, must be non-empty.
 * @param width The width of the virtual display in pixels, must be greater than 0.
 * @param height The height of the virtual display in pixels, must be greater than 0.
 * @param densityDpi The density of the virtual display in dpi, must be greater than 0.
 * @param surface The surface to which the content of the virtual display should
 * be rendered, or null if there is none initially.
 * @param flags A combination of virtual display flags:
 * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},
 * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},
 * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.
 * @param callback Callback to call when the state of the {@link VirtualDisplay} changes
 * @param handler The handler on which the listener should be invoked, or null
 * if the listener should be invoked on the calling thread's looper.
 * @return The newly created virtual display, or null if the application could
 * not create the virtual display.
 *
 * @throws SecurityException if the caller does not have permission to create
 * a virtual display with the specified flags.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The call to the method createVirtualDisplay has changed by adding an additional null parameter in the late version. This indicates a change in the dependent API, hence the change types are 1,5.","The change in the parameters of the method createVirtualDisplay suggests that there is a different version of this method being called, which likely has a different implementation. This could potentially lead to the API returning different values, therefore the CI type is 1."
113,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void reportShown()>,31,32,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void reportShown()>,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void reportShown()>,0,"{
    if (!mShownReported) {
        mShownReported = true;
        try {
            mConnection.engineShown(this);
        } catch (RemoteException e) {
            Log.w(TAG, ""Wallpaper host disappeared"", e);
            return;
        }
    }
}","{
    if (!mShownReported) {
        mShownReported = true;
        try {
            mConnection.engineShown(this);
            Log.d(TAG, ""Wallpaper has updated the surface:"" + mWallpaperManager.getWallpaperInfo());
        } catch (RemoteException e) {
            Log.w(TAG, ""Wallpaper host disappeared"", e);
            return;
        }
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new logging statement (Log.d(...)) has been added inside the try block. This change does not affect the control flow or the return value of the method. Therefore, the code change type is 4.","The added log does not change the actual behavior regarding the return value or exception handling of the method; it is merely for debugging or informational purposes. Thus, there's no compatibility issue (CI type is 0)."
114,<android.hardware.devicestate.DeviceStateManagerGlobal.DeviceStateRequestWrapper: void notifyRequestCanceled()>,31,32,<android.hardware.devicestate.DeviceStateManagerGlobal.DeviceStateRequestWrapper: void notifyRequestCanceled()>,<android.hardware.devicestate.DeviceStateManagerGlobal.DeviceStateRequestWrapper: void notifyRequestCanceled()>,0,"{
    if (mCallback == null) {
        return;
    }
    mExecutor.execute(() -> mCallback.onRequestSuspended(mRequest));
}","{
    if (mCallback == null) {
        return;
    }
    mExecutor.execute(() -> mCallback.onRequestCanceled(mRequest));
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The implementation changes the method call within the lambda expression from mCallback.onRequestSuspended(mRequest) to mCallback.onRequestCanceled(mRequest), hence the change type is 4.","There's no compatibility issue as there is no change in the control flow, exception handling, or return statements; the method will still execute a callback on the same executor with the same mRequest parameter, merely invoking a different callback method. Since this is an internal callback execution and doesn't alter the behavior of the public-facing 'notifyRequestCanceled()' method, it does not constitute a compatibility issue."
115,<android.appwidget.AppWidgetHostView: void setColorResources(SparseIntArray)>,31,32,<android.appwidget.AppWidgetHostView: void setColorResources(SparseIntArray)>,<android.appwidget.AppWidgetHostView: void setColorResources(SparseIntArray)>,0,"{
    if (mColorMapping != null && isSameColorMapping(mColorMapping, colorMapping)) {
        return;
    }
    mColorMapping = colorMapping.clone();
    mColorResources = RemoteViews.ColorResources.create(mContext, mColorMapping);
    mLayoutId = -1;
    mViewMode = VIEW_MODE_NOINIT;
    reapplyLastRemoteViews();
}","{
    if (mColorMapping != null && isSameColorMapping(mColorMapping, colorMapping)) {
        return;
    }
    mColorMapping = colorMapping.clone();
    mColorResources = RemoteViews.ColorResources.create(mContext, mColorMapping);
    mColorMappingChanged = true;
    mViewMode = VIEW_MODE_NOINIT;
    reapplyLastRemoteViews();
}",1,"/**
 * Set the dynamically overloaded color resources.
 *
 * {@code colorMapping} maps a predefined set of color resources to their ARGB
 * representation. Any entry not in the predefined set of colors will be ignored.
 *
 * Calling this method will trigger a full re-inflation of the App Widget.
 *
 * The color resources that can be overloaded are the ones whose name is prefixed with
 * {@code system_neutral} or {@code system_accent}, for example
 * {@link android.R.color#system_neutral1_500}.
 */
","/**
 * Set the dynamically overloaded color resources.
 *
 * {@code colorMapping} maps a predefined set of color resources to their ARGB
 * representation. Any entry not in the predefined set of colors will be ignored.
 *
 * Calling this method will trigger a full re-inflation of the App Widget.
 *
 * The color resources that can be overloaded are the ones whose name is prefixed with
 * {@code system_neutral} or {@code system_accent}, for example
 * {@link android.R.color#system_neutral1_500}.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The assignment statement to mLayoutId is deleted, and a new assignment statement for mColorMappingChanged is added, which constitutes an other statement change, so the code change type is 4.","The changes don't affect the return values or the exceptions that could be raised, since mLayoutId is no longer set to -1 and it doesn't seem to affect the behavior of the method's execution as far as return values or exception handling is concerned. The new variable `mColorMappingChanged` is set to true, but it doesn't indicate a return value change or an exception behavior change. Therefore, there is no Compatibility Issue, and the CI type is 0."
116,<android.app.DisabledWallpaperManager: int getWallpaperId(int)>,31,32,<android.app.DisabledWallpaperManager: int getWallpaperId(int)>,<android.app.DisabledWallpaperManager: int getWallpaperId(int)>,0,"{
    return unsupported();
}","{
    return unsupportedInt();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from calling unsupported() to calling unsupportedInt(). There is also a dependency change since a different method is being called, which could potentially be an API with different behavior or return type.","The change in the dependent method called (from unsupported() to unsupportedInt()) could lead to the API returning a different value or type, so the CI type is 1."
117,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",31,32,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>","<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",0,"{
    return obtain(downTime, eventTime, action, x, y, pressure, size, metaState, xPrecision, yPrecision, deviceId, edgeFlags, InputDevice.SOURCE_UNKNOWN, DEFAULT_DISPLAY);
}","{
    return obtain(downTime, eventTime, action, x, y, pressure, size, metaState, xPrecision, yPrecision, deviceId, edgeFlags, InputDevice.SOURCE_CLASS_POINTER, DEFAULT_DISPLAY);
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed by modifying the value from InputDevice.SOURCE_UNKNOWN to InputDevice.SOURCE_CLASS_POINTER. This represents a dependent API change because it alters the value passed to another method, so the code change types are 1,5.","The changed return statement can possibly lead to a different return value due to the change in the parameter passed to the 'obtain' method. This could impact how the MotionEvent is constructed and its behavior, hence the CI type is 1."
