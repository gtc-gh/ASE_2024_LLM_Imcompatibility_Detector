Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_Change_Type,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
6,"<android.content.BroadcastReceiver: IBinder peekService(Context,Intent)>",13,14,,,,"{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}","{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.setAllowFds(false);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}",1,"/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
","/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */
",0,,,0,,,,,,,4,0,"The code addition of `service.setAllowFds(false);` before calling `am.peekService(...)` is considered as an 'Other statement changed' (4), since it modifies the behavior of the `Intent` object but does not fundamentally alter the control flow or return type/values.","This change does not appear to introduce a Compatibility Issue, as it primarily prevents file descriptors from being included in the `Intent`. The fundamental behavior of the existing method call remains the same, so it falls under 'No Compatibility Issue' (0)."
7,"<android.app.ContextImpl: void startIntentSender(IntentSender,Intent,int,int,int)>",13,14,,,,"{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues);
        if (result == IActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}","{
    try {
        String resolvedType = null;
        if (fillInIntent != null) {
            fillInIntent.setAllowFds(false);
            resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivityIntentSender(mMainThread.getApplicationThread(), intent, fillInIntent, resolvedType, null, null, 0, flagsMask, flagsValues);
        if (result == IActivityManager.START_CANCELED) {
            throw new IntentSender.SendIntentException();
        }
        Instrumentation.checkStartActivityResult(result, null);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is an additional method call (fillInIntent.setAllowFds(false);) in the late version that is not present in the early version, so the code change type is 4.","The added statement (fillInIntent.setAllowFds(false);) does not alter the flow or output of the method because it does not change the return value, nor does it affect the exception handling. Therefore, it does not cause a Compatibility Issue, and the CI type is 0."
8,<android.server.BluetoothService: boolean connectInputDevice(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
    return mBluetoothInputProfileHandler.connectInputDevice(device, state);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.connectInputDevice(device, state);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"There is a new 'synchronized' block introduced around the return statement, which is a control dependency change (type 3), and it modifies the synchronization of the method, but not the logic itself, thus a change type 4 also applies.","The addition of a synchronized block does not change the behavior related to what the API returns or the exceptions it might throw. Since it only changes how the code is executed concurrently without affecting the API's output or exception handling, there is no compatibility issue (type 0)."
9,<android.database.CursorWindow: boolean allocRow()>,13,14,,,,"{
    acquireReference();
    try {
        return allocRow_native();
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeAllocRow(mWindowPtr);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Allocate a row in cursor window
 * @return false if cursor window is out of memory
 */
","/**
 * Allocates a new row at the end of this cursor window.
 *
 * @return True if successful, false if the cursor window is out of memory.
 */
",1,,,0,,,,,,,5,0,"The change is in the dependent API call from allocRow_native() to nativeAllocRow(mWindowPtr), which means the dependent API changed, hence the code change type is 5.","No Compatibility Issue is detected as the change in the dependent API does not necessarily lead to a different behavior. The acquisition and release of resources, along with return statements, appear equivalent in functionality despite the change in the method being called."
10,<android.view.View: Object getTag(int)>,13,14,,,,"{
    SparseArray<Object> tags = null;
    synchronized (sTagsLock) {
        if (sTags != null) {
            tags = sTags.get(this);
        }
    }
    if (tags != null)
        return tags.get(key);
    return null;
}","{
    if (mKeyedTags != null)
        return mKeyedTags.get(key);
    return null;
}",1,"/**
 * Returns the tag associated with this view and the specified key.
 *
 * @param key The key identifying the tag
 *
 * @return the Object stored in this view as a tag
 *
 * @see #setTag(int, Object)
 * @see #getTag()
 */
","/**
 * Returns the tag associated with this view and the specified key.
 *
 * @param key The key identifying the tag
 *
 * @return the Object stored in this view as a tag
 *
 * @see #setTag(int, Object)
 * @see #getTag()
 */
",0,,,0,,,,,,,"4,5",0,"The implementation for getting the tag from the View has been completely changed, switching from using a static synchronized lock and shared SparseArray (sTags) within the class to using instance variable (mKeyedTags). Therefore, the dependent API 'sTags' is no longer used; instead, 'mKeyedTags' is referred directly. So, the code change type is 4,5.","Despite the significant change in how tags are accessed, there is no compatibility issue with respect to the return type/value or exception thrown because the operation's intention remains unchanged: it still returns the object associated with the specified key or null if no object is found. Both versions behave consistently for the same input (given the tag exists or not), hence no compatibility issue is detected: 0."
13,"<android.app.FragmentManagerImpl: void moveToState(int,int,int,boolean)>",13,14,,,,"{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle);
            }
        }
        if (mNeedMenuInvalidate && mActivity != null) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}","{
    if (mActivity == null && newState != Fragment.INITIALIZING) {
        throw new IllegalStateException(""No activity"");
    }
    if (!always && mCurState == newState) {
        return;
    }
    mCurState = newState;
    if (mActive != null) {
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null) {
                moveToState(f, newState, transit, transitStyle);
            }
        }
        if (mNeedMenuInvalidate && mActivity != null && mCurState == Fragment.RESUMED) {
            mActivity.invalidateOptionsMenu();
            mNeedMenuInvalidate = false;
        }
    }
}",1,,,0,,,0,,,,,,,3,0,"The control flow has been modified by adding an additional condition to an if statement (`mCurState == Fragment.RESUMED`) to the later code when calling `invalidateOptionsMenu()`. There are no changes in return statement or in the exception handling, so the code change type is 3.","The additional condition in the if statement is a control dependency change that affects when `invalidateOptionsMenu()` is called. As this change does not alter the method's return value or the exceptions it might throw, but instead controls the side-effect of invalidating the options menu, there is no compatibility issue with respect to return value or exception handling. Therefore, the CI type is 0."
15,<android.widget.AbsListView: boolean resurrectSelectionIfNeeded()>,13,14,,,,"{
    if (mSelectedPosition < 0) {
        return resurrectSelection();
    }
    return false;
}","{
    if (mSelectedPosition < 0 && resurrectSelection()) {
        updateSelectorState();
        return true;
    }
    return false;
}",1,"/**
 * If there is a selection returns false.
 * Otherwise resurrects the selection and returns true if resurrected.
 */
","/**
 * If there is a selection returns false.
 * Otherwise resurrects the selection and returns true if resurrected.
 */
",0,,,0,,,,,,,"3,4",1,"The control dependency and a method call have been added within the if condition, and also the execution of updateSelectorState() method, which wasn't present before, represents an other statement change. Hence, the code change type is 3,4.","The introduction of the new condition resurrectSelection() within the if statement and returning true only when resurrectSelection() returns true represents a change in the behavior of the method when the mSelectedPosition is less than 0. This change will potentially lead to a different return value (true instead of false in some cases), so the CI type is 1."
18,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String)>",13,14,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is the introduction of the method call intent.setAllowFds(false); before the existing call to broadcastIntent(). Since this is neither a return statement, exception handling statement, nor a control dependency change, the change type is 4 (Other statement changed).","As the method intent.setAllowFds(false) relates to the internal behavior of the Intent by disallowing file descriptor passing which does not alter the return type or value, nor the exception handling of the API, it does not introduce a compatibility issue. Therefore, the CI type is 0 (No Compatibility Issue)."
19,<android.widget.TabWidget: View getChildTabViewAt(int)>,13,14,,,,"{
    // we have tab views at 0, 2, 4, ...
    if (mDividerDrawable != null) {
        index *= 2;
    }
    return getChildAt(index);
}","{
    return getChildAt(index);
}",1,"/**
 * Returns the tab indicator view at the given index.
 *
 * @param index the zero-based index of the tab indicator view to return
 * @return the tab indicator view at the given index
 */
","/**
 * Returns the tab indicator view at the given index.
 *
 * @param index the zero-based index of the tab indicator view to return
 * @return the tab indicator view at the given index
 */
",0,,,0,,,,,,,"3,4",1,"The early implementation contains a conditional check and multiplication statement which modifies the index based on whether 'mDividerDrawable' is not null. These statements have been removed in the late implementation. This is both a change within a control dependency (conditional statement) and an other statement (arithmetic operation), so the change types are 3,4.","As a result of the removed 'if' condition and the related index modification, the API could potentially return a different child view in version 14 than it would in version 13. This can lead to different behaviors in client code. Therefore, the compatibility issue type is 1."
20,"<android.webkit.WebView: boolean savePicture(Bundle,File)>",13,14,,,,"{
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(temp);
                p.writeToStream(out);
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e) {
                    // Can't do anything about that
                    }
                }
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    mZoomManager.saveZoomState(b);
    return true;
}","{
    checkThread();
    if (dest == null || b == null) {
        return false;
    }
    final Picture p = capturePicture();
    // Use a temporary file while writing to ensure the destination file
    // contains valid data.
    final File temp = new File(dest.getPath() + "".writing"");
    new Thread(new Runnable() {

        public void run() {
            FileOutputStream out = null;
            try {
                out = new FileOutputStream(temp);
                p.writeToStream(out);
                // Writing the picture succeeded, rename the temporary file
                // to the destination.
                temp.renameTo(dest);
            } catch (Exception e) {
            // too late to do anything about it.
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e) {
                    // Can't do anything about that
                    }
                }
                temp.delete();
            }
        }
    }).start();
    // now update the bundle
    b.putInt(""scrollX"", mScrollX);
    b.putInt(""scrollY"", mScrollY);
    mZoomManager.saveZoomState(b);
    return true;
}",1,"/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 * @deprecated This method is now obsolete.
 */
","/**
 * Save the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b A Bundle to store the display data.
 * @param dest The file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return True if the picture was successfully saved.
 * @deprecated This method is now obsolete.
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,4,0,"The only change in the method's body is the addition of the checkThread() call at the beginning of the Late_Implementation. This change falls under the ""Other statement changed"" category.","As the method's return values, exception throwing behavior, and control flow have not been changed by the addition of checkThread(), no Compatibility Issue is introduced. The newly added checkThread() call is used to verify that the method is being called on the correct thread, but it does not alter the method's output or its exception handling behavior. Hence, there is no Compatibility Issue."
21,<android.webkit.WebView: boolean pageUp(boolean)>,13,14,,,,"{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (top) {
        // go to the top of the document
        return pinScrollTo(mScrollX, 0, true, 0);
    }
    // Page up
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = -h + PAGE_SCROLL_OVERLAP;
    } else {
        y = -h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    checkThread();
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (top) {
        // go to the top of the document
        return pinScrollTo(mScrollX, 0, true, 0);
    }
    // Page up
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = -h + PAGE_SCROLL_OVERLAP;
    } else {
        y = -h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}",1,"/**
 * Scroll the contents of the view up by half the view size
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
","/**
 * Scroll the contents of the view up by half the view size
 * @param top true to jump to the top of the page
 * @return true if the page was scrolled
 */
",0,,,0,,,,,,,4,0,"The addition of checkThread() as the first line in the late implementation does not affect the return values or exceptions this method may produce, so the code change type is 4.","Since checkThread() only ensures that the WebView's methods are being called on the correct thread and does not lead to a change in behavior regarding the return values or exceptions thrown by the method, this does not cause a Compatibility Issue."
22,"<android.app.FragmentManagerImpl: void moveToState(Fragment,int,int,int)>",13,14,,,,"{
    // Fragments that are not currently added will sit in the onCreate() state.
    if (!f.mAdded && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                }
                f.mActivity = mActivity;
                f.mFragmentManager = mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                mActivity.onAttachFragment(f);
                if (!f.mRetaining) {
                    f.mCalled = false;
                    f.onCreate(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onCreate()"");
                    }
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mActivity.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throw new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" for fragment "" + f);
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.mCalled = false;
                    f.onActivityCreated(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onActivityCreated()"");
                    }
                    if (f.mView != null) {
                        f.restoreViewState();
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.mCalled = false;
                    f.performStart();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStart()"");
                    }
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mCalled = false;
                    f.mResumed = true;
                    f.onResume();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onResume()"");
                    }
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.mCalled = false;
                    f.onPause();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onPause()"");
                    }
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.mCalled = false;
                    f.performStop();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStop()"");
                    }
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.mCalled = false;
                    f.performDestroyView();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroyView()"");
                    }
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.mCalled = false;
                            f.onDestroy();
                            if (!f.mCalled) {
                                throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroy()"");
                            }
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!f.mRetaining) {
                            makeInactive(f);
                        } else {
                            f.mImmediateActivity = null;
                            f.mActivity = null;
                            f.mFragmentManager = null;
                        }
                    }
                }
        }
    }
    f.mState = newState;
}","{
    // Fragments that are not currently added will sit in the onCreate() state.
    if (!f.mAdded && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        // While removing a fragment, we can't change it to a higher state.
        newState = f.mState;
    }
    if (f.mState < newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.mAnimatingAway != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.mAnimatingAway = null;
            moveToState(f, f.mStateAfterAnimating, 0, 0);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (DEBUG)
                    Log.v(TAG, ""moveto CREATED: "" + f);
                if (f.mSavedFragmentState != null) {
                    f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                    f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                    if (f.mTarget != null) {
                        f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                    }
                }
                f.mActivity = mActivity;
                f.mFragmentManager = mActivity.mFragments;
                f.mCalled = false;
                f.onAttach(mActivity);
                if (!f.mCalled) {
                    throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onAttach()"");
                }
                mActivity.onAttachFragment(f);
                if (!f.mRetaining) {
                    f.mCalled = false;
                    f.onCreate(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onCreate()"");
                    }
                }
                f.mRetaining = false;
                if (f.mFromLayout) {
                    // For fragments that are part of the content view
                    // layout, we need to instantiate the view immediately
                    // and the inflater will take care of adding it.
                    f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), null, f.mSavedFragmentState);
                    if (f.mView != null) {
                        f.mView.setSaveFromParentEnabled(false);
                        if (f.mHidden)
                            f.mView.setVisibility(View.GONE);
                        f.onViewCreated(f.mView, f.mSavedFragmentState);
                    }
                }
            case Fragment.CREATED:
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto ACTIVITY_CREATED: "" + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            container = (ViewGroup) mActivity.findViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                throw new IllegalArgumentException(""No view found for id 0x"" + Integer.toHexString(f.mContainerId) + "" for fragment "" + f);
                            }
                        }
                        f.mContainer = container;
                        f.mView = f.onCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                Animator anim = loadAnimator(f, transit, true, transitionStyle);
                                if (anim != null) {
                                    anim.setTarget(f.mView);
                                    anim.start();
                                }
                                container.addView(f.mView);
                            }
                            if (f.mHidden)
                                f.mView.setVisibility(View.GONE);
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                        }
                    }
                    f.mCalled = false;
                    f.onActivityCreated(f.mSavedFragmentState);
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onActivityCreated()"");
                    }
                    if (f.mView != null) {
                        f.restoreViewState();
                    }
                    f.mSavedFragmentState = null;
                }
            case Fragment.ACTIVITY_CREATED:
            case Fragment.STOPPED:
                if (newState > Fragment.STOPPED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto STARTED: "" + f);
                    f.mCalled = false;
                    f.performStart();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStart()"");
                    }
                }
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""moveto RESUMED: "" + f);
                    f.mCalled = false;
                    f.mResumed = true;
                    f.onResume();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onResume()"");
                    }
                    // Get rid of this in case we saved it and never needed it.
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom RESUMED: "" + f);
                    f.mCalled = false;
                    f.onPause();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onPause()"");
                    }
                    f.mResumed = false;
                }
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom STARTED: "" + f);
                    f.mCalled = false;
                    f.performStop();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onStop()"");
                    }
                }
            case Fragment.STOPPED:
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, ""movefrom ACTIVITY_CREATED: "" + f);
                    if (f.mView != null) {
                        // done already.
                        if (!mActivity.isFinishing() && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.mCalled = false;
                    f.performDestroyView();
                    if (!f.mCalled) {
                        throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroyView()"");
                    }
                    if (f.mView != null && f.mContainer != null) {
                        Animator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed) {
                            anim = loadAnimator(f, transit, false, transitionStyle);
                        }
                        if (anim != null) {
                            final ViewGroup container = f.mContainer;
                            final View view = f.mView;
                            final Fragment fragment = f;
                            container.startViewTransition(view);
                            f.mAnimatingAway = anim;
                            f.mStateAfterAnimating = newState;
                            anim.addListener(new AnimatorListenerAdapter() {

                                @Override
                                public void onAnimationEnd(Animator anim) {
                                    container.endViewTransition(view);
                                    if (fragment.mAnimatingAway != null) {
                                        fragment.mAnimatingAway = null;
                                        moveToState(fragment, fragment.mStateAfterAnimating, 0, 0);
                                    }
                                }
                            });
                            anim.setTarget(f.mView);
                            anim.start();
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                }
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        if (f.mAnimatingAway != null) {
                            // The fragment's containing activity is
                            // being destroyed, but this fragment is
                            // currently animating away.  Stop the
                            // animation right now -- it is not needed,
                            // and we can't wait any more on destroying
                            // the fragment.
                            Animator anim = f.mAnimatingAway;
                            f.mAnimatingAway = null;
                            anim.cancel();
                        }
                    }
                    if (f.mAnimatingAway != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.mStateAfterAnimating = newState;
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, ""movefrom CREATED: "" + f);
                        if (!f.mRetaining) {
                            f.mCalled = false;
                            f.onDestroy();
                            if (!f.mCalled) {
                                throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDestroy()"");
                            }
                        }
                        f.mCalled = false;
                        f.onDetach();
                        if (!f.mCalled) {
                            throw new SuperNotCalledException(""Fragment "" + f + "" did not call through to super.onDetach()"");
                        }
                        if (!f.mRetaining) {
                            makeInactive(f);
                        } else {
                            f.mActivity = null;
                            f.mFragmentManager = null;
                        }
                    }
                }
        }
    }
    f.mState = newState;
}",1,,,0,,,0,,,,,,,,,,
23,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    final int action = event.getActionMasked();
    boolean handled = true;
    if (action == MotionEvent.ACTION_DOWN) {
        // Start fresh
        reset();
    }
    if (mInvalidGesture)
        return false;
    if (!mGestureInProgress) {
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                {
                    mActiveId0 = event.getPointerId(0);
                    mActive0MostRecent = true;
                }
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // We have a new multi-finger gesture
                    // as orientation can change, query the metrics in touch down
                    DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
                    mRightSlopEdge = metrics.widthPixels - mEdgeSlop;
                    mBottomSlopEdge = metrics.heightPixels - mEdgeSlop;
                    if (mPrevEvent != null)
                        mPrevEvent.recycle();
                    mPrevEvent = MotionEvent.obtain(event);
                    mTimeDelta = 0;
                    int index1 = event.getActionIndex();
                    int index0 = event.findPointerIndex(mActiveId0);
                    mActiveId1 = event.getPointerId(index1);
                    if (index0 < 0 || index0 == index1) {
                        // Probably someone sending us a broken event stream.
                        index0 = findNewActiveIndex(event, index0 == index1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    mActive0MostRecent = false;
                    setContext(event);
                    // Check if we have a sloppy gesture. If so, delay
                    // the beginning of the gesture until we're sure that's
                    // what the user wanted. Sloppy gestures can happen if the
                    // edge of the user's hand is touching the screen, for example.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                        mSloppyGesture = true;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                        mSloppyGesture = true;
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                        mSloppyGesture = true;
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_MOVE:
                if (mSloppyGesture) {
                    // Initiate sloppy gestures if we've moved outside of the slop area.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    int index0 = event.findPointerIndex(mActiveId0);
                    int index1 = event.findPointerIndex(mActiveId1);
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId1, index0);
                        if (index >= 0) {
                            index0 = index;
                            mActiveId0 = event.getPointerId(index);
                            x0 = getRawX(event, index);
                            y0 = getRawY(event, index);
                            p0sloppy = false;
                        }
                    }
                    if (p1sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId0, index1);
                        if (index >= 0) {
                            index1 = index;
                            mActiveId1 = event.getPointerId(index);
                            x1 = getRawX(event, index);
                            y1 = getRawY(event, index);
                            p1sloppy = false;
                        }
                    }
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                if (mSloppyGesture) {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0)
                                mActiveId0 = event.getPointerId(newIndex);
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0)
                                mActiveId1 = event.getPointerId(newIndex);
                        }
                    } else {
                        // Set focus point to the remaining finger
                        final int index = event.findPointerIndex(actionId == mActiveId0 ? mActiveId1 : mActiveId0);
                        if (index < 0) {
                            mInvalidGesture = true;
                            Log.e(TAG, ""Invalid MotionEvent stream detected."", new Throwable());
                            if (mGestureInProgress) {
                                mListener.onScaleEnd(this);
                            }
                            return false;
                        }
                        mActiveId0 = event.getPointerId(index);
                        mActive0MostRecent = true;
                        mActiveId1 = -1;
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                    }
                }
                break;
        }
    } else {
        // Transform gesture in progress - attempt to handle it
        switch(action) {
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // End the old gesture and begin a new one with the most recent two fingers.
                    mListener.onScaleEnd(this);
                    final int oldActive0 = mActiveId0;
                    final int oldActive1 = mActiveId1;
                    reset();
                    mPrevEvent = MotionEvent.obtain(event);
                    mActiveId0 = mActive0MostRecent ? oldActive0 : oldActive1;
                    mActiveId1 = event.getPointerId(event.getActionIndex());
                    mActive0MostRecent = false;
                    int index0 = event.findPointerIndex(mActiveId0);
                    if (index0 < 0 || mActiveId0 == mActiveId1) {
                        // Probably someone sending us a broken event stream.
                        Log.e(TAG, ""Got "" + MotionEvent.actionToString(action) + "" with bad state while a gesture was in progress. "" + ""Did you forget to pass an event to "" + ""ScaleGestureDetector#onTouchEvent?"");
                        index0 = findNewActiveIndex(event, mActiveId0 == mActiveId1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    boolean gestureEnded = false;
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId0 = event.getPointerId(newIndex);
                                mActive0MostRecent = true;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId1 = event.getPointerId(newIndex);
                                mActive0MostRecent = false;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        }
                        mPrevEvent.recycle();
                        mPrevEvent = MotionEvent.obtain(event);
                        setContext(event);
                    } else {
                        gestureEnded = true;
                    }
                    if (gestureEnded) {
                        // Gesture ended
                        setContext(event);
                        // Set focus point to the remaining finger
                        final int activeId = actionId == mActiveId0 ? mActiveId1 : mActiveId0;
                        final int index = event.findPointerIndex(activeId);
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                        mListener.onScaleEnd(this);
                        reset();
                        mActiveId0 = activeId;
                        mActive0MostRecent = true;
                    }
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mListener.onScaleEnd(this);
                reset();
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_MOVE:
                {
                    setContext(event);
                    // finger is lifted.
                    if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
                        final boolean updatePrevious = mListener.onScale(this);
                        if (updatePrevious) {
                            mPrevEvent.recycle();
                            mPrevEvent = MotionEvent.obtain(event);
                        }
                    }
                }
                break;
        }
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        // Start fresh
        reset();
    }
    boolean handled = true;
    if (mInvalidGesture) {
        handled = false;
    } else if (!mGestureInProgress) {
        switch(action) {
            case MotionEvent.ACTION_DOWN:
                {
                    mActiveId0 = event.getPointerId(0);
                    mActive0MostRecent = true;
                }
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // We have a new multi-finger gesture
                    // as orientation can change, query the metrics in touch down
                    DisplayMetrics metrics = mContext.getResources().getDisplayMetrics();
                    mRightSlopEdge = metrics.widthPixels - mEdgeSlop;
                    mBottomSlopEdge = metrics.heightPixels - mEdgeSlop;
                    if (mPrevEvent != null)
                        mPrevEvent.recycle();
                    mPrevEvent = MotionEvent.obtain(event);
                    mTimeDelta = 0;
                    int index1 = event.getActionIndex();
                    int index0 = event.findPointerIndex(mActiveId0);
                    mActiveId1 = event.getPointerId(index1);
                    if (index0 < 0 || index0 == index1) {
                        // Probably someone sending us a broken event stream.
                        index0 = findNewActiveIndex(event, index0 == index1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    mActive0MostRecent = false;
                    setContext(event);
                    // Check if we have a sloppy gesture. If so, delay
                    // the beginning of the gesture until we're sure that's
                    // what the user wanted. Sloppy gestures can happen if the
                    // edge of the user's hand is touching the screen, for example.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                        mSloppyGesture = true;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                        mSloppyGesture = true;
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                        mSloppyGesture = true;
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_MOVE:
                if (mSloppyGesture) {
                    // Initiate sloppy gestures if we've moved outside of the slop area.
                    final float edgeSlop = mEdgeSlop;
                    final float rightSlop = mRightSlopEdge;
                    final float bottomSlop = mBottomSlopEdge;
                    int index0 = event.findPointerIndex(mActiveId0);
                    int index1 = event.findPointerIndex(mActiveId1);
                    float x0 = getRawX(event, index0);
                    float y0 = getRawY(event, index0);
                    float x1 = getRawX(event, index1);
                    float y1 = getRawY(event, index1);
                    boolean p0sloppy = x0 < edgeSlop || y0 < edgeSlop || x0 > rightSlop || y0 > bottomSlop;
                    boolean p1sloppy = x1 < edgeSlop || y1 < edgeSlop || x1 > rightSlop || y1 > bottomSlop;
                    if (p0sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId1, index0);
                        if (index >= 0) {
                            index0 = index;
                            mActiveId0 = event.getPointerId(index);
                            x0 = getRawX(event, index);
                            y0 = getRawY(event, index);
                            p0sloppy = false;
                        }
                    }
                    if (p1sloppy) {
                        // Do we have a different pointer that isn't sloppy?
                        int index = findNewActiveIndex(event, mActiveId0, index1);
                        if (index >= 0) {
                            index1 = index;
                            mActiveId1 = event.getPointerId(index);
                            x1 = getRawX(event, index);
                            y1 = getRawY(event, index);
                            p1sloppy = false;
                        }
                    }
                    if (p0sloppy && p1sloppy) {
                        mFocusX = -1;
                        mFocusY = -1;
                    } else if (p0sloppy) {
                        mFocusX = event.getX(index1);
                        mFocusY = event.getY(index1);
                    } else if (p1sloppy) {
                        mFocusX = event.getX(index0);
                        mFocusY = event.getY(index0);
                    } else {
                        mSloppyGesture = false;
                        mGestureInProgress = mListener.onScaleBegin(this);
                    }
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                if (mSloppyGesture) {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0)
                                mActiveId0 = event.getPointerId(newIndex);
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0)
                                mActiveId1 = event.getPointerId(newIndex);
                        }
                    } else {
                        // Set focus point to the remaining finger
                        final int index = event.findPointerIndex(actionId == mActiveId0 ? mActiveId1 : mActiveId0);
                        if (index < 0) {
                            mInvalidGesture = true;
                            Log.e(TAG, ""Invalid MotionEvent stream detected."", new Throwable());
                            if (mGestureInProgress) {
                                mListener.onScaleEnd(this);
                            }
                            return false;
                        }
                        mActiveId0 = event.getPointerId(index);
                        mActive0MostRecent = true;
                        mActiveId1 = -1;
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                    }
                }
                break;
        }
    } else {
        // Transform gesture in progress - attempt to handle it
        switch(action) {
            case MotionEvent.ACTION_POINTER_DOWN:
                {
                    // End the old gesture and begin a new one with the most recent two fingers.
                    mListener.onScaleEnd(this);
                    final int oldActive0 = mActiveId0;
                    final int oldActive1 = mActiveId1;
                    reset();
                    mPrevEvent = MotionEvent.obtain(event);
                    mActiveId0 = mActive0MostRecent ? oldActive0 : oldActive1;
                    mActiveId1 = event.getPointerId(event.getActionIndex());
                    mActive0MostRecent = false;
                    int index0 = event.findPointerIndex(mActiveId0);
                    if (index0 < 0 || mActiveId0 == mActiveId1) {
                        // Probably someone sending us a broken event stream.
                        Log.e(TAG, ""Got "" + MotionEvent.actionToString(action) + "" with bad state while a gesture was in progress. "" + ""Did you forget to pass an event to "" + ""ScaleGestureDetector#onTouchEvent?"");
                        index0 = findNewActiveIndex(event, mActiveId0 == mActiveId1 ? -1 : mActiveId1, index0);
                        mActiveId0 = event.getPointerId(index0);
                    }
                    setContext(event);
                    mGestureInProgress = mListener.onScaleBegin(this);
                }
                break;
            case MotionEvent.ACTION_POINTER_UP:
                {
                    final int pointerCount = event.getPointerCount();
                    final int actionIndex = event.getActionIndex();
                    final int actionId = event.getPointerId(actionIndex);
                    boolean gestureEnded = false;
                    if (pointerCount > 2) {
                        if (actionId == mActiveId0) {
                            final int newIndex = findNewActiveIndex(event, mActiveId1, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId0 = event.getPointerId(newIndex);
                                mActive0MostRecent = true;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        } else if (actionId == mActiveId1) {
                            final int newIndex = findNewActiveIndex(event, mActiveId0, actionIndex);
                            if (newIndex >= 0) {
                                mListener.onScaleEnd(this);
                                mActiveId1 = event.getPointerId(newIndex);
                                mActive0MostRecent = false;
                                mPrevEvent = MotionEvent.obtain(event);
                                setContext(event);
                                mGestureInProgress = mListener.onScaleBegin(this);
                            } else {
                                gestureEnded = true;
                            }
                        }
                        mPrevEvent.recycle();
                        mPrevEvent = MotionEvent.obtain(event);
                        setContext(event);
                    } else {
                        gestureEnded = true;
                    }
                    if (gestureEnded) {
                        // Gesture ended
                        setContext(event);
                        // Set focus point to the remaining finger
                        final int activeId = actionId == mActiveId0 ? mActiveId1 : mActiveId0;
                        final int index = event.findPointerIndex(activeId);
                        mFocusX = event.getX(index);
                        mFocusY = event.getY(index);
                        mListener.onScaleEnd(this);
                        reset();
                        mActiveId0 = activeId;
                        mActive0MostRecent = true;
                    }
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mListener.onScaleEnd(this);
                reset();
                break;
            case MotionEvent.ACTION_UP:
                reset();
                break;
            case MotionEvent.ACTION_MOVE:
                {
                    setContext(event);
                    // finger is lifted.
                    if (mCurrPressure / mPrevPressure > PRESSURE_THRESHOLD) {
                        final boolean updatePrevious = mListener.onScale(this);
                        if (updatePrevious) {
                            mPrevEvent.recycle();
                            mPrevEvent = MotionEvent.obtain(event);
                        }
                    }
                }
                break;
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return handled;
}",1,,,0,,,0,,,,,,,,,,
26,"<android.view.GLES20Canvas: void drawLines(float[],int,int,Paint)>",13,14,,,,"{
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    boolean hasModifier = setupModifiers(paint);
    nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    if (hasModifier)
        nResetModifiers(mRenderer);
}","{
    if ((offset | count) < 0 || offset + count > pts.length) {
        throw new IllegalArgumentException(""The lines array must contain 4 elements per line."");
    }
    int modifiers = setupModifiers(paint);
    nDrawLines(mRenderer, pts, offset, count, paint.mNativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is in the type of the variable 'hasModifier'. It was a boolean and now it's an int with a check against a constant 'MODIFIER_NONE'. The statement inside the if condition has also changed to include the 'modifiers' variable as an argument to the method call 'nResetModifiers(mRenderer, modifiers)'. Therefore, the code change type is 4.","There seems to be no Compatibility Issue since the logic of the method has not been altered in a way that would lead to a different behavior visible to the caller. The method still throws the same exception under the same condition, and the flow of the method remains unchanged. The modified variable and the change in the method call argument are internal to the method's functioning and do not affect the method's contract or behavior from an external perspective."
27,<android.webkit.WebView: String getOriginalUrl()>,13,14,,,,"{
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getOriginalUrl() : null;
}","{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getOriginalUrl() : null;
}",1,"/**
 * Get the original url for the current page. This is not always the same
 * as the url passed to WebViewClient.onPageStarted because although the
 * load for that url has begun, the current page may not have changed.
 * Also, there may have been redirects resulting in a different url to that
 * originally requested.
 * @return The url that was originally requested for the current page.
 */
","/**
 * Get the original url for the current page. This is not always the same
 * as the url passed to WebViewClient.onPageStarted because although the
 * load for that url has begun, the current page may not have changed.
 * Also, there may have been redirects resulting in a different url to that
 * originally requested.
 * @return The url that was originally requested for the current page.
 */
",0,,,0,,,,,,,4,0,"An additional method call (checkThread()) has been introduced at the beginning of the method which does not affect the return value or the exception handling, so the code change type is 4.","There is no Compatibility Issue as the change does not affect the return value or the exceptions that could be thrown by the method, so CI type is 0."
28,<android.widget.TabHost.LabelAndIconIndicatorStrategy: View createIndicatorView()>,13,14,,,,"{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    tv.setText(mLabel);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    if (mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}","{
    final Context context = getContext();
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View tabIndicator = inflater.inflate(mTabLayoutId, // tab widget is the parent
    mTabWidget, // no inflate params
    false);
    final TextView tv = (TextView) tabIndicator.findViewById(R.id.title);
    final ImageView iconView = (ImageView) tabIndicator.findViewById(R.id.icon);
    // when icon is gone by default, we're in exclusive mode
    final boolean exclusive = iconView.getVisibility() == View.GONE;
    final boolean bindIcon = !exclusive || TextUtils.isEmpty(mLabel);
    tv.setText(mLabel);
    if (bindIcon && mIcon != null) {
        iconView.setImageDrawable(mIcon);
        iconView.setVisibility(VISIBLE);
    }
    if (context.getApplicationInfo().targetSdkVersion <= Build.VERSION_CODES.DONUT) {
        // Donut apps get old color scheme
        tabIndicator.setBackgroundResource(R.drawable.tab_indicator_v4);
        tv.setTextColor(context.getResources().getColorStateList(R.color.tab_indicator_text_v4));
    }
    return tabIndicator;
}",1,,,0,,,0,,,,,,,"1,3",1,"The creation of the 'exclusive' and 'bindIcon' variables introduce a change in control dependency, as well as the condition for setting the visibility of 'iconView'. This leads to a change in the 'if' statement's condition (from `if (mIcon != null)` to `if (bindIcon && mIcon != null)`), which is a control dependency change. The new logic also changes the return statement output because the icon might not be set even when mIcon is not null depending on the value of bindIcon. The code change type is 1,3 due to the additional conditional logic affecting the behavior of setting an ImageView.","The new conditional logic could potentially affect the image visibility and display on the 'tabIndicator', which is the return value for this method. If 'exclusive' is true and 'mLabel' is not empty, 'iconView' will no longer show the icon even if 'mIcon' is set, which differs from the early version where it will always show if 'mIcon' is available. This introduces a Compatibility Issue based on the potential for varying return contents. The CI type is 1 due to the potential difference in return values."
29,"<android.app.FragmentManagerImpl: boolean dispatchCreateOptionsMenu(Menu,MenuInflater)>",13,14,,,,"{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu) {
                show = true;
                f.onCreateOptionsMenu(menu, inflater);
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}","{
    boolean show = false;
    ArrayList<Fragment> newMenus = null;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onCreateOptionsMenu(menu, inflater);
                if (newMenus == null) {
                    newMenus = new ArrayList<Fragment>();
                }
                newMenus.add(f);
            }
        }
    }
    if (mCreatedMenus != null) {
        for (int i = 0; i < mCreatedMenus.size(); i++) {
            Fragment f = mCreatedMenus.get(i);
            if (newMenus == null || !newMenus.contains(f)) {
                f.onDestroyOptionsMenu();
            }
        }
    }
    mCreatedMenus = newMenus;
    return show;
}",1,,,0,,,0,,,,,,,3,1,"The condition in the if statement has an additional check for f.mMenuVisible, so this is a control dependency change (3).","The additional check for f.mMenuVisible affects which fragments are included in newMenus and therefore changes whether the 'show' variable may be set to 'true'. This change in the condition could potentially lead to a different return value as 'show' is used as the return variable, resulting in a CI type of 1."
30,<android.ddm.DdmHandleExit: Chunk handleChunk(Chunk)>,13,14,,,,"{
    if (Config.LOGV)
        Log.v(""ddm-exit"", ""Handling "" + name(request.type) + "" chunk"");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int statusCode = in.getInt();
    Runtime.getRuntime().halt(statusCode);
    // if that doesn't work, return an empty message
    return null;
}","{
    if (false)
        Log.v(""ddm-exit"", ""Handling "" + name(request.type) + "" chunk"");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int statusCode = in.getInt();
    Runtime.getRuntime().halt(statusCode);
    // if that doesn't work, return an empty message
    return null;
}",1,"/**
 * Handle a chunk of data.  We're only registered for ""EXIT"".
 */
","/**
 * Handle a chunk of data.  We're only registered for ""EXIT"".
 */
",0,,,0,,,,,,,4,0,"The change is purely in a logging condition that does not affect the API's behavior; the condition for the log statement has changed from Config.LOGV to false, so the code change type is 4.","Since the change does not affect how the method processes the input or the output returned, there is no Compatibility Issue; the method still performs the same operations and returns the same result."
33,<android.webkit.WebView: void clearMatches()>,13,14,,,,"{
    if (mNativeClass == 0)
        return;
    nativeSetFindIsEmpty();
    invalidate();
}","{
    checkThread();
    if (mNativeClass == 0)
        return;
    nativeSetFindIsEmpty();
    invalidate();
}",1,"/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
","/*
     * Clear the highlighting surrounding text matches created by findAll.
     */
",0,,,0,,,,,,,4,0,"The introduction of the statement checkThread(); represents a type 4 change (Other statement changed), which is neither a return, exception handling, nor control dependency change.","There is no Compatibility Issue because the new code only includes an additional check to ensure that the web view's methods are being called on the correct thread, without changing the method's return value, its exceptions, or the functional control flow."
34,<android.widget.AdapterView: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    boolean populated = false;
    // events so we change the event type here.
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_FOCUSED) {
        event.setEventType(AccessibilityEvent.TYPE_VIEW_SELECTED);
    }
    // we send selection events only from AdapterView to avoid
    // generation of such event for each child
    View selectedView = getSelectedView();
    if (selectedView != null) {
        populated = selectedView.dispatchPopulateAccessibilityEvent(event);
    }
    if (!populated) {
        if (selectedView != null) {
            event.setEnabled(selectedView.isEnabled());
        }
        event.setItemCount(getCount());
        event.setCurrentItemIndex(getSelectedItemPosition());
    }
    return populated;
}","{
    View selectedView = getSelectedView();
    if (selectedView != null && selectedView.getVisibility() == VISIBLE && selectedView.dispatchPopulateAccessibilityEvent(event)) {
        return true;
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",0,"The control flow of the method has been simplified, by removing the initial event type check and adjustment, changing the if-else structure, and removing the assignment of selected view's enabled state and the item count and current item index of `AccessibilityEvent`. The statements within the method have changed including the control flow statements, therefore the code change types are 1,3, and 4.","Even though the implementation has changed, these changes do not constitute a compatibility issue. The late implementation still attempts to dispatch an accessibility event to the selected view, and the method returns 'true' if the event is populated and 'false' otherwise. The purpose of the method remains the same, and the modified structure achieves the same outcome in a different way. There is no different return value nor exception handling introduced by these changes; thus, no compatibility issue is detected here."
35,<android.webkit.WebView: boolean canGoBackOrForward(int)>,13,14,,,,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            int newIndex = l.getCurrentIndex() + steps;
            return newIndex >= 0 && newIndex < l.getSize();
        }
    }
}","{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            int newIndex = l.getCurrentIndex() + steps;
            return newIndex >= 0 && newIndex < l.getSize();
        }
    }
}",1,"/**
 * Return true if the page can go back or forward the given
 * number of steps.
 * @param steps The negative or positive number of steps to move the
 * history.
 */
","/**
 * Return true if the page can go back or forward the given
 * number of steps.
 * @param steps The negative or positive number of steps to move the
 * history.
 */
",0,,,0,,,,,,,4,0,"A new statement checkThread(); is introduced at the beginning of the method, which is to make sure the method is called from the correct thread. This change is not directly affecting the return value or the exception handling mechanism of the method, so the code change type is 4.","The additional call to checkThread(); does not change the behavior of canGoBackOrForward(int) in terms of the values it returns or the exceptions it may throw. It's a check to ensure thread safety, which doesn't introduce a compatibility issue. Therefore, there's no Compatibility Issue."
38,<android.widget.ListView: boolean removeFooterView(View)>,13,14,,,,"{
    if (mFooterViewInfos.size() > 0) {
        boolean result = false;
        if (((HeaderViewListAdapter) mAdapter).removeFooter(v)) {
            mDataSetObserver.onChanged();
            result = true;
        }
        removeFixedViewInfo(v, mFooterViewInfos);
        return result;
    }
    return false;
}","{
    if (mFooterViewInfos.size() > 0) {
        boolean result = false;
        if (mAdapter != null && ((HeaderViewListAdapter) mAdapter).removeFooter(v)) {
            if (mDataSetObserver != null) {
                mDataSetObserver.onChanged();
            }
            result = true;
        }
        removeFixedViewInfo(v, mFooterViewInfos);
        return result;
    }
    return false;
}",1,"/**
 * Removes a previously-added footer view.
 *
 * @param v The view to remove
 * @return
 * true if the view was removed, false if the view was not a footer view
 */
","/**
 * Removes a previously-added footer view.
 *
 * @param v The view to remove
 * @return
 * true if the view was removed, false if the view was not a footer view
 */
",0,,,0,,,,,,,3,0,"There is a control dependency change as the condition checking `mAdapter != null` has been added, and another nested `if ` condition checking `mDataSetObserver != null` has also been introduced. Therefore, the code change type is 3.","Despite the additional checks for `null`, the behavior of the API does not change in terms of the kinds of exceptions thrown or the value returned. The method still returns `true` if a footer is removed and `false` otherwise. Null checks have been added for defensive programming but do not introduce compatibility issues on their own. Therefore, there is no compatibility issue, i.e., CI type is 0."
39,<android.widget.NumberPicker: boolean onInterceptTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!isEnabled() || !mFlingable) {
        return false;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastMotionEventY = mLastDownEventY = event.getY();
            removeAllCallbacks();
            mShowInputControlsAnimator.cancel();
            mBeginEditOnUpEvent = false;
            mAdjustScrollerOnUpEvent = true;
            if (mDrawSelectorWheel) {
                boolean scrollersFinished = mFlingScroller.isFinished() && mAdjustScroller.isFinished();
                if (!scrollersFinished) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mBeginEditOnUpEvent = scrollersFinished;
                mAdjustScrollerOnUpEvent = true;
                hideInputControls();
                return true;
            }
            if (isEventInViewHitRect(event, mInputText) || (!mIncrementButton.isShown() && isEventInViewHitRect(event, mIncrementButton)) || (!mDecrementButton.isShown() && isEventInViewHitRect(event, mDecrementButton))) {
                mAdjustScrollerOnUpEvent = false;
                setDrawSelectorWheel(true);
                hideInputControls();
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = event.getY();
            int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
            if (deltaDownY > mTouchSlop) {
                mBeginEditOnUpEvent = false;
                onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                setDrawSelectorWheel(true);
                hideInputControls();
                return true;
            }
            break;
    }
    return false;
}","{
    if (!isEnabled() || !mFlingable) {
        return false;
    }
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mLastMotionEventY = mLastDownEventY = event.getY();
            removeAllCallbacks();
            mShowInputControlsAnimator.cancel();
            mDimSelectorWheelAnimator.cancel();
            mBeginEditOnUpEvent = false;
            mAdjustScrollerOnUpEvent = true;
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                boolean scrollersFinished = mFlingScroller.isFinished() && mAdjustScroller.isFinished();
                if (!scrollersFinished) {
                    mFlingScroller.forceFinished(true);
                    mAdjustScroller.forceFinished(true);
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                }
                mBeginEditOnUpEvent = scrollersFinished;
                mAdjustScrollerOnUpEvent = true;
                hideInputControls();
                return true;
            }
            if (isEventInViewHitRect(event, mInputText) || (!mIncrementButton.isShown() && isEventInViewHitRect(event, mIncrementButton)) || (!mDecrementButton.isShown() && isEventInViewHitRect(event, mDecrementButton))) {
                mAdjustScrollerOnUpEvent = false;
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = event.getY();
            int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
            if (deltaDownY > mTouchSlop) {
                mBeginEditOnUpEvent = false;
                onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE);
                hideInputControls();
                return true;
            }
            break;
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3, 4",1,"In the late implementation, there is an additional call to `mDimSelectorWheelAnimator.cancel();` and the condition `if (mDrawSelectorWheel)` was replaced with `if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE)` and a call to `setDrawSelectorWheel(true)` was replaced with `setSelectorWheelState(SELECTOR_WHEEL_STATE_LARGE)`. These are other statements and control statements that have been changed, which correspond to change classes 3 and 4.","These changes in the control statements and conditions can potentially lead to different behaviors of the method. For example, the state of `mSelectorWheelState` determining the behavior instead of `mDrawSelectorWheel` could result in a different logic flow, and hence a different return value. Consequently, there is a Compatibility Issue of type 1."
41,"<android.app.WallpaperManager.Globals: Bitmap peekWallpaperBitmap(Context,boolean)>",13,14,,,,"{
    synchronized (this) {
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked(context);
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (mWallpaper == null && returnDefault) {
            mDefaultWallpaper = getDefaultWallpaperLocked(context);
            return mDefaultWallpaper;
        }
        return mWallpaper;
    }
}","{
    synchronized (this) {
        if (mWallpaper != null) {
            return mWallpaper;
        }
        if (mDefaultWallpaper != null) {
            return mDefaultWallpaper;
        }
        mWallpaper = null;
        try {
            mWallpaper = getCurrentWallpaperLocked();
        } catch (OutOfMemoryError e) {
            Log.w(TAG, ""No memory load current wallpaper"", e);
        }
        if (returnDefault) {
            if (mWallpaper == null) {
                mDefaultWallpaper = getDefaultWallpaperLocked(context);
                return mDefaultWallpaper;
            } else {
                mDefaultWallpaper = null;
            }
        }
        return mWallpaper;
    }
}",1,,,0,,,0,,,,,,,"3,5",1,"The control dependency has changed with the reordering of the conditional check from if(mWallpaper == null && returnDefault) to if(returnDefault), introducing an additional nested branch if(mWallpaper == null). The method getCurrentWallpaperLocked() no longer takes 'context' as an argument, indicating a dependent API has changed. Hence, the changes are classified as type 3 and 5.","Since the control flow has been altered and the dependent API getCurrentWallpaperLocked() is called with different arguments, there's potential for a different code execution path which can result in the method returning a different bitmap or 'null'. Therefore, it is a compatibility issue type 1."
42,<android.server.BluetoothService: List<BluetoothDevice> getPanDevicesMatchingConnectionStates(int[])>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothPanProfileHandler.getPanDevicesMatchingConnectionStates(states);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.getPanDevicesMatchingConnectionStates(states);
    }
}",1,,,0,,,0,,,,,,,3,0,"The change from the early to the late version is the introduction of a synchronized block around the existing return statement. There is no change in the actual logic of the API itself, so the control dependency has changed, making it type 3.","The addition of the synchronized block does not change the API's behavior in terms of its return value or exception handling. This change is to ensure thread safety when accessing `mBluetoothPanProfileHandler`. Therefore, it doesn't introduce a compatibility issue, so the CI type is 0."
43,<android.speech.tts.TextToSpeech: boolean areDefaultsEnforced()>,13,14,,,,"{
    synchronized (mStartLock) {
        boolean defaultsEnforced = false;
        if (!mStarted) {
            return defaultsEnforced;
        }
        try {
            defaultsEnforced = mITts.areDefaultsEnforced();
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - areDefaultsEnforced"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - areDefaultsEnforced"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - areDefaultsEnforced"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return defaultsEnforced;
        }
    }
}","{
    return false;
}",1,"/**
 * Returns whether or not the user is forcing their defaults to override the
 * Text-To-Speech settings set by applications.
 *
 * @return Whether or not defaults are enforced.
 */
","/**
 * Checks whether the user's settings should override settings requested
 * by the calling application. As of the Ice cream sandwich release,
 * user settings never forcibly override the app's settings.
 */
",1,,,0,,,,,,,1,0,"The return statement has been simplified to always return false in the late version of the API. The whole logic, including exception handling and conditional checks, has been removed. Therefore, the change type is 1.","Although the return statement has changed, the late version of the method always returns `false`, which is a definitive constant value. Therefore, it does not pose a compatibility issue regarding potential differences in return value assuming that the early version always returned the same constant value (which is `false` here) as well. Since the actual behavior when calling this method will not change (it always returns false), there is no Compatibility Issue, hence the CI type is 0."
49,"<android.provider.SyncStateContract.Helpers: Pair<Uri, byte[]> getWithUri(ContentProviderClient,Uri,Account)>",13,14,,,,"{
    Cursor c = provider.query(uri, DATA_PROJECTION, SELECT_BY_ACCOUNT, new String[] { account.name, account.type }, null);
    try {
        if (c.moveToNext()) {
            long rowId = c.getLong(1);
            byte[] blob = c.getBlob(c.getColumnIndexOrThrow(Columns.DATA));
            return Pair.create(ContentUris.withAppendedId(uri, rowId), blob);
        }
    } finally {
        c.close();
    }
    return null;
}","{
    Cursor c = provider.query(uri, DATA_PROJECTION, SELECT_BY_ACCOUNT, new String[] { account.name, account.type }, null);
    if (c == null) {
        throw new RemoteException();
    }
    try {
        if (c.moveToNext()) {
            long rowId = c.getLong(1);
            byte[] blob = c.getBlob(c.getColumnIndexOrThrow(Columns.DATA));
            return Pair.create(ContentUris.withAppendedId(uri, rowId), blob);
        }
    } finally {
        c.close();
    }
    return null;
}",1,,,0,,,0,,,,,,,"2,3",2,"An additional check whether the cursor 'c' is null with an associated exception throw has been introduced, so the code change type is 2 for exception handling statement changed, and 3 for the control dependency change (an introduction of an if statement).","Due to the introduction of the null-check for 'c' and subsequent throw of a new RemoteException, the behaviour of the method has changed. Hence, if the cursor is null, the late version will throw a RemoteException, which the early version did not, indicating a CI type 2."
52,<android.nfc.NfcAdapter: boolean isEnabled()>,13,14,,,,"{
    try {
        return sService.isEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}","{
    try {
        return sService.getState() == STATE_ON;
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}",1,"/**
 * Return true if this NFC Adapter has any features enabled.
 *
 * <p>Application may use this as a helper to suggest that the user
 * should turn on NFC in Settings.
 * <p>If this method returns false, the NFC hardware is guaranteed not to
 * generate or respond to any NFC transactions.
 *
 * @return true if this NFC Adapter has any features enabled
 */
","/**
 * Return true if this NFC Adapter has any features enabled.
 *
 * <p>Application may use this as a helper to suggest that the user
 * should turn on NFC in Settings.
 * <p>If this method returns false, the NFC hardware is guaranteed not to
 * generate or respond to any NFC transactions.
 *
 * @return true if this NFC Adapter has any features enabled
 */
",0,,,0,,,,,,,"1,5",1,"The method called on `sService` has changed from `isEnabled()` to `getState()` and the returned value is now compared against `STATE_ON` instead of the direct return value, as well as potentially relying on a different behavior of `getState()` as compared to `isEnabled()`. Therefore, the code change types are 1 and 5.","Due to the change from using `isEnabled()` to using `getState() == STATE_ON`, the result of the method call could be different, which would lead to a different return value. If `getState()` method behaves differently from `isEnabled()`, or if `STATE_ON` does not equate to the original meaning of ""enabled"", the behavior of the API will change, resulting in a CI type of 1."
53,<android.inputmethodservice.SoftInputWindow: boolean dispatchTouchEvent(MotionEvent)>,13,14,,,,"{
    getWindow().getDecorView().getHitRect(mBounds);
    final MotionEvent event = clipMotionEvent(ev, mBounds);
    return super.dispatchTouchEvent(event);
}","{
    getWindow().getDecorView().getHitRect(mBounds);
    if (ev.isWithinBoundsNoHistory(mBounds.left, mBounds.top, mBounds.right - 1, mBounds.bottom - 1)) {
        return super.dispatchTouchEvent(ev);
    } else {
        MotionEvent temp = ev.clampNoHistory(mBounds.left, mBounds.top, mBounds.right - 1, mBounds.bottom - 1);
        boolean handled = super.dispatchTouchEvent(temp);
        temp.recycle();
        return handled;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",1,"The change consists of introducing a new condition with an if-else statement. The implementation now uses `isWithinBoundsNoHistory` method to check the bounds, and based on the result, either directly dispatches the touch event or clamps it before dispatching. This modifies the flow control and how the MotionEvent object is processed, thus the code change types are 3 (Control dependency changed) and 4 (Other statement changed).","The addition of the `if` condition that checks whether the MotionEvent is within certain bounds could affect the final value returned by the API, because the event passed to `super.dispatchTouchEvent` could be different than in the previous version. In the earlier version, the event is always clipped to bounds, whereas in the later version, it is only sometimes clamped when it is out of bounds. This might result in a different return value, the CI type is 1 (Compatibility Issue caused by potential different return values)."
55,<android.text.Layout: float getLineRight(int)>,13,14,,,,"{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return mWidth;
        else
            return getParagraphLeft(line) + getLineMax(line);
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getLineMax(line);
        else
            return mWidth;
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return right - ((right - left) - max) / 2;
    }
}","{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_LEFT) {
        return getParagraphLeft(line) + getLineMax(line);
    } else if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return mWidth;
        else
            return getParagraphLeft(line) + getLineMax(line);
    } else if (align == Alignment.ALIGN_RIGHT) {
        return mWidth;
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getLineMax(line);
        else
            return mWidth;
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return right - ((right - left) - max) / 2;
    }
}",1,"/**
 * Get the rightmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
","/**
 * Get the rightmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
",0,,,0,,,,,,,"3,4",1,"The implementation has changed where new conditions for Alignment.ALIGN_LEFT and Alignment.ALIGN_RIGHT are added, and the handling of Alignment.ALIGN_NORMAL is altered. Furthermore, condition checks and corresponding return statements have been modified, which would be categorized as both control dependency change (3) and other statement change (4).","The modifications in handling different Alignment values could lead to the method returning different values for the same input line values, hence the potential compatibility issue is caused by potential different return values or types, which corresponds to CI type 1."
57,<android.widget.AbsListView: void setRemoteViewsAdapter(Intent)>,13,14,,,,"{
    // service handling the specified intent.
    if (mRemoteAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}","{
    // service handling the specified intent.
    if (mRemoteAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}",1,"/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
","/**
 * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService
 * through the specified intent.
 * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.
 */
",0,,,0,,,,,,,4,0,"An assignment statement ""mDeferNotifyDataSetChanged = false;"" is added, so the code change type is 4.","The change is merely setting a flag variable and does not affect the return type, value, or exception handling of the method; thus, there is no Compatibility Issue."
59,<android.webkit.WebView: int getViewHeight()>,13,14,,,,"{
    return getViewHeightWithTitle() - getVisibleTitleHeight();
}","{
    return getViewHeightWithTitle() - getVisibleTitleHeightImpl();
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,5,1,"The method used in the return statement has changed from getVisibleTitleHeight() to getVisibleTitleHeightImpl(), indicating that a dependent API has changed, so the code change type is 5.","Since there is a change in the dependent API that is called within the return statement, the return value could potentially be different if the implementation of getVisibleTitleHeightImpl() is different from getVisibleTitleHeight(). Thus, the CI type is 1."
60,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: int getCount()>,13,14,,,,"{
    return mFactory.getCount();
}","{
    int count = 0;
    try {
        count = mFactory.getCount();
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return count;
}",1,,,0,,,0,,,,,,,"2,3,4",2,"The late implementation wraps the existing return statement within a try-catch block, introduces a new variable 'count', and assigns the result of the existing method call to this variable. It also adds an exception handling mechanism. Thus, the code change includes an exception handling statement change, control dependency change due to the try block, and other statement change for variable initialization and modification, corresponding to the types 2, 3, and 4 respectively.","The introduction of the try-catch block to handle exceptions can lead to different exception handling behaviors. In the early version, any exception thrown by getCount() would propagate up to the caller. In the late version, the exception is caught, and the default uncaught exception handler is called. This could alter the flow of the application if exceptions occur, thus creating a potential Compatibility Issue of type 2."
61,<android.server.BluetoothService: boolean allowIncomingTethering()>,13,14,,,,"{
    return mBluetoothPanProfileHandler.allowIncomingTethering();
}","{
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.allowIncomingTethering();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,4,0,"There is a change to the implementation which includes adding synchronization around the existing return statement, so the code change is of type 4 (Other statement changed).","The synchronization block added around the existing return statement does not change the behavior of the method's return value or exceptions it may throw; it only ensures thread safety when accessing the `mBluetoothPanProfileHandler`. Thus, there is no compatibility issue (CI type 0)."
63,<android.app.ContextImpl: void sendStickyBroadcast(Intent)>,13,14,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, true);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is the addition of intent.setAllowFds(false) within the try block, which is an alteration to the method behavior but not directly related to the return value or exception handling mechanism, thus the code change type is 4.","There is no Compatibility Issue caused because despite the addition of a new method call that affects the properties of the 'intent', the API's return type still does not change (as it is a void method), and the method does not introduce new exceptions or changes in exception handling. Hence, the behaviors related to return value or exception handling remain unchanged."
64,"<android.content.ContentProviderProxy: Uri insert(Uri,ContentValues)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    values.writeToParcel(data, 0);
    mRemote.transact(IContentProvider.INSERT_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    Uri out = Uri.CREATOR.createFromParcel(reply);
    data.recycle();
    reply.recycle();
    return out;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        values.writeToParcel(data, 0);
        mRemote.transact(IContentProvider.INSERT_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        Uri out = Uri.CREATOR.createFromParcel(reply);
        return out;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code structure has been changed by introducing try/finally block for resource management and removing explicit calls to data.recycle() and reply.recycle() from the main code to the finally block. Therefore, the changes belong to category 3 (Control dependency changed) and category 4 (Other statement changed).","There is no Compatibility Issue caused by the changes. The try/finally block ensures that resources are still recycled as before, and the behavior of the method remains the same in terms of returning a value or exception handling. The returned `Uri` out and any exceptions that could be thrown remain unchanged."
65,"<android.view.HardwareRenderer.Gl20Renderer: HardwareLayer createHardwareLayer(int,int,boolean)>",13,14,,,,"{
    return new GLES20Layer(width, height, isOpaque);
}","{
    return new GLES20RenderLayer(width, height, isOpaque);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,5",1,"The new object creation statement has changed from GLES20Layer to GLES20RenderLayer, which indicates a different class is being instantiated. This shows the dependent API has changed (class name changed), and therefore the return type might be different as well. The change types are 1 and 5.","Given that a different class object is being instantiated (GLES20RenderLayer instead of GLES20Layer) and returned, there could be a difference in behavior, methods available, or the state of the object, which would cause a compatibility issue of type 1 (potential different return values or types)."
66,"<android.widget.Gallery: int getChildDrawingOrder(int,int)>",13,14,,,,"{
    int selectedIndex = mSelectedPosition - mFirstPosition;
    // Just to be safe
    if (selectedIndex < 0)
        return i;
    if (i == childCount - 1) {
        // Draw the selected child last
        return selectedIndex;
    } else if (i >= selectedIndex) {
        // Move the children to the right of the selected child earlier one
        return i + 1;
    } else {
        // Keep the children to the left of the selected child the same
        return i;
    }
}","{
    int selectedIndex = mSelectedPosition - mFirstPosition;
    // Just to be safe
    if (selectedIndex < 0)
        return i;
    if (i == childCount - 1) {
        // Draw the selected child last
        return selectedIndex;
    } else if (i >= selectedIndex) {
        // Move the children after the selected child earlier one
        return i + 1;
    } else {
        // Keep the children before the selected child the same
        return i;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,0,0,"There is no functional change in the implementation, only comments have been altered which does not affect the code execution.",There is no Compatibility Issue as the behaviour of the method remains unchanged between the two versions.
67,<android.app.FragmentManagerImpl: boolean execPendingActions()>,13,14,,,,"{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                return didSomething;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
        }
        mExecutingActions = false;
        didSomething = true;
    }
}","{
    if (mExecutingActions) {
        throw new IllegalStateException(""Recursive entry to executePendingTransactions"");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException(""Must be called from main thread of process"");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                return didSomething;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
}",1,"/**
 * Only call from main thread!
 */
","/**
 * Only call from main thread!
 */
",0,,,0,,,,,,,4,0,"In the late version, mTmpActions[i] is set to null after being run in the loop. This is the only change in an otherwise identical implementation, which amounts to an ""other statement changed"" with no changes to return statements or exception handling.","There are no Compatibility Issues from this change because it does not affect the API's behavior externally. Setting an element to null in an array that is internal to the method's operation does not change what is ultimately returned or cause an exception to be thrown differently. The external contract and behavior of the API remain the same for the calling code; hence, there are no Compatibility Issues."
68,"<android.text.TextUtils: int lastIndexOf(CharSequence,char,int)>",13,14,,,,"{
    Class c = s.getClass();
    if (c == String.class)
        return ((String) s).lastIndexOf(ch, last);
    return lastIndexOf(s, ch, 0, last);
}","{
    Class<? extends CharSequence> c = s.getClass();
    if (c == String.class)
        return ((String) s).lastIndexOf(ch, last);
    return lastIndexOf(s, ch, 0, last);
}",1,,,0,,,0,,,,,,,0,0,"The only change made is the usage of a class literal with a generic wildcard, which doesn't affect the execution or behaviour of the code. There is no change in execution flow, return statements, exception handling, or dependent API changes.","No Compatibility Issue as the change doesn't affect how the method behaves or the values it returns. The modification is only in the type declaration, which does not alter the runtime behavior."
69,<android.server.BluetoothService: boolean disable(boolean)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    switch(mBluetoothState) {
        case BluetoothAdapter.STATE_OFF:
            return true;
        case BluetoothAdapter.STATE_ON:
            break;
        default:
            return false;
    }
    if (mEnableThread != null && mEnableThread.isAlive()) {
        return false;
    }
    setBluetoothState(BluetoothAdapter.STATE_TURNING_OFF);
    if (mAdapterSdpHandles != null)
        removeReservedServiceRecordsNative(mAdapterSdpHandles);
    setBluetoothTetheringNative(false, BluetoothPanProfileHandler.NAP_ROLE, BluetoothPanProfileHandler.NAP_BRIDGE);
    // Allow 3 seconds for profiles to gracefully disconnect
    // TODO: Introduce a callback mechanism so that each profile can notify
    // BluetoothService when it is done shutting down
    disconnectDevices();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_FINISH_DISABLE, saveSetting ? 1 : 0, 0), 3000);
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    int adapterState = getBluetoothStateInternal();
    switch(adapterState) {
        case BluetoothAdapter.STATE_OFF:
            return true;
        case BluetoothAdapter.STATE_ON:
            break;
        default:
            return false;
    }
    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_OFF, saveSetting);
    return true;
}",1,"/**
 * Bring down bluetooth. Returns true on success.
 *
 * @param saveSetting If true, persist the new setting
 */
","/**
 * Bring down bluetooth. Returns true on success.
 *
 * @param saveSetting If true, persist the new setting
 */
",0,,,0,,,,,,,"1,3,5",1,"The method has undergone several changes including the introduction of a new method call getBluetoothStateInternal(), different control flow, and the replacement of multiple method calls and operations with mBluetoothState.sendMessage(). Specifically, the sendMessageDelayed to mHandler has been replaced with a single call to sendMessage on mBluetoothState, and both setBluetoothState, removeReservedServiceRecordsNative, setBluetoothTetheringNative, and disconnectDevices calls have been removed. Because of these changes, the code change types are 1,3,5.","These changes in the implementation suggest that the behavior of the method can be different in the later version, potentially leading to different return values or the state of the Bluetooth adapter being changed in a different manner. Hence, the CI type is identified as 1 due to potential different return values or types."
70,<android.database.BulkCursorProxy: String[] getColumnNames()>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    mRemote.transact(GET_COLUMN_NAMES_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    String[] columnNames = null;
    int numColumns = reply.readInt();
    columnNames = new String[numColumns];
    for (int i = 0; i < numColumns; i++) {
        columnNames[i] = reply.readString();
    }
    data.recycle();
    reply.recycle();
    return columnNames;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        mRemote.transact(GET_COLUMN_NAMES_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        String[] columnNames = null;
        int numColumns = reply.readInt();
        columnNames = new String[numColumns];
        for (int i = 0; i < numColumns; i++) {
            columnNames[i] = reply.readString();
        }
        return columnNames;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code change includes adding a try-finally block for resource management (Parcel objects), which reflects a change in control dependency and other statements for ensuring the resources are recycled properly. Thus, the code change type is 3,4.","The added try-finally block does not change the logic of how the method retrieves column names, meaning it does not introduce a potential different return value or exception handling. Therefore, there is no Compatibility Issue, and the CI type is 0."
71,<android.widget.AbsListView: Parcelable onSaveInstanceState()>,13,14,,,,"{
    /*
         * This doesn't really make sense as the place to dismiss the
         * popups, but there don't seem to be any other useful hooks
         * that happen early enough to keep from getting complaints
         * about having leaked the window.
         */
    dismissPopup();
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    boolean haveChildren = getChildCount() > 0 && mItemCount > 0;
    long selectedId = getSelectedItemId();
    ss.selectedId = selectedId;
    ss.height = getHeight();
    if (selectedId >= 0) {
        // Remember the selection
        ss.viewTop = mSelectedTop;
        ss.position = getSelectedItemPosition();
        ss.firstId = INVALID_POSITION;
    } else {
        if (haveChildren && mFirstPosition > 0) {
            // Remember the position of the first child.
            // We only do this if we are not currently at the top of
            // the list, for two reasons:
            // (1) The list may be in the process of becoming empty, in
            // which case mItemCount may not be 0, but if we try to
            // ask for any information about position 0 we will crash.
            // (2) Being ""at the top"" seems like a special case, anyway,
            // and the user wouldn't expect to end up somewhere else when
            // they revisit the list even if its content has changed.
            View v = getChildAt(0);
            ss.viewTop = v.getTop();
            int firstPos = mFirstPosition;
            if (firstPos >= mItemCount) {
                firstPos = mItemCount - 1;
            }
            ss.position = firstPos;
            ss.firstId = mAdapter.getItemId(firstPos);
        } else {
            ss.viewTop = 0;
            ss.firstId = INVALID_POSITION;
            ss.position = 0;
        }
    }
    ss.filter = null;
    if (mFiltered) {
        final EditText textFilter = mTextFilter;
        if (textFilter != null) {
            Editable filterText = textFilter.getText();
            if (filterText != null) {
                ss.filter = filterText.toString();
            }
        }
    }
    ss.inActionMode = mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null;
    ss.checkState = mCheckStates;
    ss.checkIdState = mCheckedIdStates;
    ss.checkedItemCount = mCheckedItemCount;
    return ss;
}","{
    /*
         * This doesn't really make sense as the place to dismiss the
         * popups, but there don't seem to be any other useful hooks
         * that happen early enough to keep from getting complaints
         * about having leaked the window.
         */
    dismissPopup();
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    boolean haveChildren = getChildCount() > 0 && mItemCount > 0;
    long selectedId = getSelectedItemId();
    ss.selectedId = selectedId;
    ss.height = getHeight();
    if (selectedId >= 0) {
        // Remember the selection
        ss.viewTop = mSelectedTop;
        ss.position = getSelectedItemPosition();
        ss.firstId = INVALID_POSITION;
    } else {
        if (haveChildren && mFirstPosition > 0) {
            // Remember the position of the first child.
            // We only do this if we are not currently at the top of
            // the list, for two reasons:
            // (1) The list may be in the process of becoming empty, in
            // which case mItemCount may not be 0, but if we try to
            // ask for any information about position 0 we will crash.
            // (2) Being ""at the top"" seems like a special case, anyway,
            // and the user wouldn't expect to end up somewhere else when
            // they revisit the list even if its content has changed.
            View v = getChildAt(0);
            ss.viewTop = v.getTop();
            int firstPos = mFirstPosition;
            if (firstPos >= mItemCount) {
                firstPos = mItemCount - 1;
            }
            ss.position = firstPos;
            ss.firstId = mAdapter.getItemId(firstPos);
        } else {
            ss.viewTop = 0;
            ss.firstId = INVALID_POSITION;
            ss.position = 0;
        }
    }
    ss.filter = null;
    if (mFiltered) {
        final EditText textFilter = mTextFilter;
        if (textFilter != null) {
            Editable filterText = textFilter.getText();
            if (filterText != null) {
                ss.filter = filterText.toString();
            }
        }
    }
    ss.inActionMode = mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null;
    if (mCheckStates != null) {
        ss.checkState = mCheckStates.clone();
    }
    if (mCheckedIdStates != null) {
        final LongSparseArray<Integer> idState = new LongSparseArray<Integer>();
        final int count = mCheckedIdStates.size();
        for (int i = 0; i < count; i++) {
            idState.put(mCheckedIdStates.keyAt(i), mCheckedIdStates.valueAt(i));
        }
        ss.checkIdState = idState;
    }
    ss.checkedItemCount = mCheckedItemCount;
    return ss;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
74,<android.view.inputmethod.InputMethodSubtype: boolean equals(Object)>,13,14,,,,"{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue()));
    }
    return false;
}","{
    if (o instanceof InputMethodSubtype) {
        InputMethodSubtype subtype = (InputMethodSubtype) o;
        return (subtype.hashCode() == hashCode()) && (subtype.getNameResId() == getNameResId()) && (subtype.getMode().equals(getMode())) && (subtype.getIconResId() == getIconResId()) && (subtype.getLocale().equals(getLocale())) && (subtype.getExtraValue().equals(getExtraValue())) && (subtype.isAuxiliary() == isAuxiliary());
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,1,1,"The return statement's condition has been expanded to include an additional check (subtype.isAuxiliary() == isAuxiliary()), so the code change type is 1.","Due to the added comparison of the isAuxiliary() method in the return statement's condition, the API may return a different result when comparing InputMethodSubtype objects, leading to a different behavior in the newer version. Thus, the CI type is 1."
75,<android.bluetooth.BluetoothDeviceProfileState.IncomingHandsfree: boolean processMessage(Message)>,13,14,,,,"{
    log(""IncomingHandsfree State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HFP_INCOMING:
            // Ignore
            Log.e(TAG, ""Error: Incoming connection with a pending incoming connection"");
            break;
        case CONNECT_A2DP_INCOMING:
            // Serialize the commands.
            deferMessage(message);
            break;
        case CONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_HFP_OUTGOING:
            // We don't know at what state we are in the incoming HFP connection state.
            // We can be changing from DISCONNECTED to CONNECTING, or
            // from CONNECTING to CONNECTED, so serializing this command is
            // the safest option.
            deferMessage(message);
            break;
        case DISCONNECT_HFP_INCOMING:
            // by this point.
            break;
        case DISCONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_A2DP_INCOMING:
            // since both connections are incoming ones.
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            // ignore
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
        case CONNECT_OTHER_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    log(""IncomingHandsfree State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HFP_INCOMING:
            // Ignore
            Log.e(TAG, ""Error: Incoming connection with a pending incoming connection"");
            break;
        case CONNECTION_ACCESS_REQUEST_REPLY:
            int val = message.arg1;
            mConnectionAccessReplyReceived = true;
            boolean value = false;
            if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
                value = true;
            }
            setTrust(val);
            handleIncomingConnection(CONNECT_HFP_INCOMING, value);
            break;
        case CONNECTION_ACCESS_REQUEST_EXPIRY:
            if (!mConnectionAccessReplyReceived) {
                handleIncomingConnection(CONNECT_HFP_INCOMING, false);
                sendConnectionAccessRemovalIntent();
                sendMessage(TRANSITION_TO_STABLE);
            }
            break;
        case CONNECT_A2DP_INCOMING:
            // Serialize the commands.
            deferMessage(message);
            break;
        case CONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_HFP_OUTGOING:
            // We don't know at what state we are in the incoming HFP connection state.
            // We can be changing from DISCONNECTED to CONNECTING, or
            // from CONNECTING to CONNECTED, so serializing this command is
            // the safest option.
            deferMessage(message);
            break;
        case DISCONNECT_HFP_INCOMING:
            // by this point.
            break;
        case DISCONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_A2DP_INCOMING:
            // since both connections are incoming ones.
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            // ignore
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
        case CONNECT_OTHER_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There are two new case statements added (CONNECTION_ACCESS_REQUEST_REPLY and CONNECTION_ACCESS_REQUEST_EXPIRY). However, there are no changes to the return statements or exception handling; hence, the change types are 3,4.","While new control statements were added to handle additional message types, there is no indication that these changes would lead to return different values or throw different exceptions for the previously existing message types. Thus, there is no Compatibility Issue."
76,<android.widget.QuickContactBadge: void onClick(View)>,13,14,,,,"{
    if (mContactUri != null) {
        mQueryHandler.startQuery(TOKEN_CONTACT_LOOKUP_AND_TRIGGER, null, mContactUri, CONTACT_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactEmail != null) {
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, mContactEmail, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, mContactPhone, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}","{
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null) {
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, mContactEmail, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, mContactPhone, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}",1,,,0,,[@Override],1,,,,,,,"4,5",1,"The API implementation has been modified by replacing the mQueryHandler.startQuery call with QuickContact.showQuickContact call in the 'if' block for mContactUri. Additionally, there is no change in the 'else if' and 'else' blocks. Because the dependent method showQuickContact is called and its behaviour may be different from startQuery, the code change types are 4,5.","The change in the implementation where a different method with potentially different behavior is called (showQuickContact instead of startQuery) could lead to a different result when the mContactUri is not null. Therefore, CI type is 1."
77,<android.webkit.WebView: float getScale()>,13,14,,,,"{
    return mZoomManager.getScale();
}","{
    checkThread();
    return mZoomManager.getScale();
}",1,"/**
 * Return the current scale of the WebView
 * @return The current scale.
 */
","/**
 * Return the current scale of the WebView
 * @return The current scale.
 */
",0,,,0,,,,,,,4,0,"An additional method call checkThread() has been introduced at the beginning of the method, so the code change type is 4.","The additional call to checkThread() does not affect the return value or the exceptions thrown by the getScale() method. Consequently, there's no Compatibility Issue in this change."
78,"<android.webkit.WebView: boolean selectText(int,int)>",13,14,,,,"{
    if (!setUpSelect(true, x, y)) {
        return false;
    }
    nativeSetExtendSelection();
    mDrawSelectionPointer = false;
    mSelectionStarted = true;
    mTouchMode = TOUCH_DRAG_MODE;
    return true;
}","{
    if (!setUpSelect(true, x, y)) {
        return false;
    }
    nativeSetExtendSelection();
    mDrawSelectionPointer = false;
    mTouchMode = TOUCH_DRAG_MODE;
    return true;
}",1,"/**
 * Select the word at the indicated content coordinates.
 */
","/**
 * Select the word at the indicated content coordinates.
 */
",0,,,0,,,,,,,0,0,There is no code change between the two versions.,"Since there is no change, there is no Compatibility Issue."
79,<android.server.BluetoothService: boolean connectInputDeviceInternal(BluetoothDevice)>,13,14,,,,"{
    return mBluetoothInputProfileHandler.connectInputDeviceInternal(device);
}","{
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.connectInputDeviceInternal(device);
    }
}",1,,,0,,,0,,,,,,,3,0,"The implementation now includes a 'synchronized' block around the existing return statement, which is a control dependency change. This change type is 3 as it does not modify the logic of the method itself but only how it is synchronized.","There is no Compatibility Issue here as the method's behavior in terms of what it returns or what exceptions it might throw has not changed. The synchronization is an internal change to ensure thread safety but does not affect the outward functionality, so the CI type is 0."
80,<android.widget.AbsListView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    int deltaY;
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
                                        // find a nearby view to select
                                        return false;
                                    }
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                final int y = (int) ev.getY(pointerIndex);
                deltaY = y - mMotionY;
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(deltaY);
                        break;
                    case TOUCH_MODE_SCROLL:
                        if (PROFILE_SCROLLING) {
                            if (!mScrollProfilingStarted) {
                                Debug.startMethodTracing(""AbsListViewScroll"");
                                mScrollProfilingStarted = true;
                            }
                        }
                        if (mScrollStrictSpan == null) {
                            // If it's non-null, we're already in a scroll.
                            mScrollStrictSpan = StrictMode.enterCriticalSpan(""AbsListView-scroll"");
                        }
                        if (y != mLastY) {
                            // Make sure that we do so in case we're in a parent that can intercept.
                            if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
                                requestDisallowInterceptTouchEvent(true);
                            }
                            final int rawDeltaY = deltaY;
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            final int motionIndex;
                            if (mMotionPosition >= 0) {
                                motionIndex = mMotionPosition - mFirstPosition;
                            } else {
                                // If we don't have a motion position that we can reliably track,
                                // pick something in the middle to make a best guess at things below.
                                motionIndex = getChildCount() / 2;
                            }
                            int motionViewPrevTop = 0;
                            View motionView = this.getChildAt(motionIndex);
                            if (motionView != null) {
                                motionViewPrevTop = motionView.getTop();
                            }
                            // No need to do all this work if we're not going to move anyway
                            boolean atEdge = false;
                            if (incrementalDeltaY != 0) {
                                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);
                            }
                            // Check to see if we have bumped into the scroll limit
                            motionView = this.getChildAt(motionIndex);
                            if (motionView != null) {
                                // Check if the top of the motion view is where it is
                                // supposed to be
                                final int motionViewRealTop = motionView.getTop();
                                if (atEdge) {
                                    // Apply overscroll
                                    int overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
                                    overScrollBy(0, overscroll, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true);
                                    if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
                                        // Don't allow overfling if we're at the edge.
                                        mVelocityTracker.clear();
                                    }
                                    final int overscrollMode = getOverScrollMode();
                                    if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
                                        // Reset when entering overscroll.
                                        mDirection = 0;
                                        mTouchMode = TOUCH_MODE_OVERSCROLL;
                                        if (rawDeltaY > 0) {
                                            mEdgeGlowTop.onPull((float) overscroll / getHeight());
                                            if (!mEdgeGlowBottom.isFinished()) {
                                                mEdgeGlowBottom.onRelease();
                                            }
                                        } else if (rawDeltaY < 0) {
                                            mEdgeGlowBottom.onPull((float) overscroll / getHeight());
                                            if (!mEdgeGlowTop.isFinished()) {
                                                mEdgeGlowTop.onRelease();
                                            }
                                        }
                                    }
                                }
                                mMotionY = y;
                                invalidate();
                            }
                            mLastY = y;
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (y != mLastY) {
                            final int rawDeltaY = deltaY;
                            deltaY -= mMotionCorrection;
                            int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
                            final int oldScroll = mScrollY;
                            final int newScroll = oldScroll - incrementalDeltaY;
                            int newDirection = y > mLastY ? 1 : -1;
                            if (mDirection == 0) {
                                mDirection = newDirection;
                            }
                            if (mDirection != newDirection) {
                                // Coming back to 'real' list scrolling
                                incrementalDeltaY = -newScroll;
                                mScrollY = 0;
                                invalidateParentIfNeeded();
                                // No need to do all this work if we're not going to move anyway
                                if (incrementalDeltaY != 0) {
                                    trackMotionScroll(incrementalDeltaY, incrementalDeltaY);
                                }
                                // Check to see if we are back in
                                View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                                if (motionView != null) {
                                    mTouchMode = TOUCH_MODE_SCROLL;
                                    // We did not scroll the full amount. Treat this essentially like the
                                    // start of a new touch scroll
                                    final int motionPosition = findClosestMotionRow(y);
                                    mMotionCorrection = 0;
                                    motionView = getChildAt(motionPosition - mFirstPosition);
                                    mMotionViewOriginalTop = motionView.getTop();
                                    mMotionY = y;
                                    mMotionPosition = motionPosition;
                                }
                            } else {
                                overScrollBy(0, -incrementalDeltaY, 0, mScrollY, 0, 0, 0, mOverscrollDistance, true);
                                final int overscrollMode = getOverScrollMode();
                                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
                                    if (rawDeltaY > 0) {
                                        mEdgeGlowTop.onPull((float) -incrementalDeltaY / getHeight());
                                        if (!mEdgeGlowBottom.isFinished()) {
                                            mEdgeGlowBottom.onRelease();
                                        }
                                    } else if (rawDeltaY < 0) {
                                        mEdgeGlowBottom.onPull((float) -incrementalDeltaY / getHeight());
                                        if (!mEdgeGlowTop.isFinished()) {
                                            mEdgeGlowTop.onRelease();
                                        }
                                    }
                                    invalidate();
                                }
                                if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
                                    // Don't allow overfling if we're at the edge.
                                    mVelocityTracker.clear();
                                }
                            }
                            mLastY = y;
                            mDirection = newDirection;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        if (mVelocityTracker != null) {
                            mVelocityTracker.recycle();
                            mVelocityTracker = null;
                        }
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}","{
    if (!isEnabled()) {
        // events, it just doesn't respond to them.
        return isClickable() || isLongClickable();
    }
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    final int action = ev.getAction();
    View v;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERFLING:
                        {
                            mFlingRunnable.endFling();
                            if (mPositionScroller != null) {
                                mPositionScroller.stop();
                            }
                            mTouchMode = TOUCH_MODE_OVERSCROLL;
                            mMotionX = (int) ev.getX();
                            mMotionY = mLastY = (int) ev.getY();
                            mMotionCorrection = 0;
                            mActivePointerId = ev.getPointerId(0);
                            mDirection = 0;
                            break;
                        }
                    default:
                        {
                            mActivePointerId = ev.getPointerId(0);
                            final int x = (int) ev.getX();
                            final int y = (int) ev.getY();
                            int motionPosition = pointToPosition(x, y);
                            if (!mDataChanged) {
                                if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
                                    // User clicked on an actual view (and was not stopping a fling).
                                    // It might be a click or a scroll. Assume it is a click until
                                    // proven otherwise
                                    mTouchMode = TOUCH_MODE_DOWN;
                                    // FIXME Debounce
                                    if (mPendingCheckForTap == null) {
                                        mPendingCheckForTap = new CheckForTap();
                                    }
                                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                                } else {
                                    if (mTouchMode == TOUCH_MODE_FLING) {
                                        // Stopped a fling. It is a scroll.
                                        createScrollingCache();
                                        mTouchMode = TOUCH_MODE_SCROLL;
                                        mMotionCorrection = 0;
                                        motionPosition = findMotionRow(y);
                                        mFlingRunnable.flywheelTouch();
                                    }
                                }
                            }
                            if (motionPosition >= 0) {
                                // Remember where the motion event started
                                v = getChildAt(motionPosition - mFirstPosition);
                                mMotionViewOriginalTop = v.getTop();
                            }
                            mMotionX = x;
                            mMotionY = y;
                            mMotionPosition = motionPosition;
                            mLastY = Integer.MIN_VALUE;
                            break;
                        }
                }
                if (performButtonActionOnTouchDown(ev)) {
                    if (mTouchMode == TOUCH_MODE_DOWN) {
                        removeCallbacks(mPendingCheckForTap);
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                int pointerIndex = ev.findPointerIndex(mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    mActivePointerId = ev.getPointerId(pointerIndex);
                }
                final int y = (int) ev.getY(pointerIndex);
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        // Check if we have moved far enough that it looks more like a
                        // scroll than a tap
                        startScrollIfNeeded(y);
                        break;
                    case TOUCH_MODE_SCROLL:
                    case TOUCH_MODE_OVERSCROLL:
                        scrollIfNeeded(y);
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                    case TOUCH_MODE_TAP:
                    case TOUCH_MODE_DONE_WAITING:
                        final int motionPosition = mMotionPosition;
                        final View child = getChildAt(motionPosition - mFirstPosition);
                        final float x = ev.getX();
                        final boolean inList = x > mListPadding.left && x < getWidth() - mListPadding.right;
                        if (child != null && !child.hasFocusable() && inList) {
                            if (mTouchMode != TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            final AbsListView.PerformClick performClick = mPerformClick;
                            performClick.mClickMotionPosition = motionPosition;
                            performClick.rememberWindowAttachCount();
                            mResurrectToPosition = motionPosition;
                            if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
                                final Handler handler = getHandler();
                                if (handler != null) {
                                    handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
                                }
                                mLayoutMode = LAYOUT_NORMAL;
                                if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                    mTouchMode = TOUCH_MODE_TAP;
                                    setSelectedPositionInt(mMotionPosition);
                                    layoutChildren();
                                    child.setPressed(true);
                                    positionSelector(mMotionPosition, child);
                                    setPressed(true);
                                    if (mSelector != null) {
                                        Drawable d = mSelector.getCurrent();
                                        if (d != null && d instanceof TransitionDrawable) {
                                            ((TransitionDrawable) d).resetTransition();
                                        }
                                    }
                                    if (mTouchModeReset != null) {
                                        removeCallbacks(mTouchModeReset);
                                    }
                                    mTouchModeReset = new Runnable() {

                                        @Override
                                        public void run() {
                                            mTouchMode = TOUCH_MODE_REST;
                                            child.setPressed(false);
                                            setPressed(false);
                                            if (!mDataChanged) {
                                                performClick.run();
                                            }
                                        }
                                    };
                                    postDelayed(mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    updateSelectorState();
                                }
                                return true;
                            } else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
                                performClick.run();
                            }
                        }
                        mTouchMode = TOUCH_MODE_REST;
                        updateSelectorState();
                        break;
                    case TOUCH_MODE_SCROLL:
                        final int childCount = getChildCount();
                        if (childCount > 0) {
                            final int firstChildTop = getChildAt(0).getTop();
                            final int lastChildBottom = getChildAt(childCount - 1).getBottom();
                            final int contentTop = mListPadding.top;
                            final int contentBottom = getHeight() - mListPadding.bottom;
                            if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
                                mTouchMode = TOUCH_MODE_REST;
                                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                            } else {
                                final VelocityTracker velocityTracker = mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                                final int initialVelocity = (int) (velocityTracker.getYVelocity(mActivePointerId) * mVelocityScale);
                                // fling further.
                                if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
                                    if (mFlingRunnable == null) {
                                        mFlingRunnable = new FlingRunnable();
                                    }
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                                    mFlingRunnable.start(-initialVelocity);
                                } else {
                                    mTouchMode = TOUCH_MODE_REST;
                                    reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                                    if (mFlingRunnable != null) {
                                        mFlingRunnable.endFling();
                                    }
                                    if (mPositionScroller != null) {
                                        mPositionScroller.stop();
                                    }
                                }
                            }
                        } else {
                            mTouchMode = TOUCH_MODE_REST;
                            reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        final VelocityTracker velocityTracker = mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                        final int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                        reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > mMinimumVelocity) {
                            mFlingRunnable.startOverfling(-initialVelocity);
                        } else {
                            mFlingRunnable.startSpringback();
                        }
                        break;
                }
                setPressed(false);
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                // Need to redraw since we probably aren't drawing the selector anymore
                invalidate();
                final Handler handler = getHandler();
                if (handler != null) {
                    handler.removeCallbacks(mPendingCheckForLongPress);
                }
                recycleVelocityTracker();
                mActivePointerId = INVALID_POINTER;
                if (PROFILE_SCROLLING) {
                    if (mScrollProfilingStarted) {
                        Debug.stopMethodTracing();
                        mScrollProfilingStarted = false;
                    }
                }
                if (mScrollStrictSpan != null) {
                    mScrollStrictSpan.finish();
                    mScrollStrictSpan = null;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_OVERSCROLL:
                        if (mFlingRunnable == null) {
                            mFlingRunnable = new FlingRunnable();
                        }
                        mFlingRunnable.startSpringback();
                        break;
                    case TOUCH_MODE_OVERFLING:
                        // Do nothing - let it play out.
                        break;
                    default:
                        mTouchMode = TOUCH_MODE_REST;
                        setPressed(false);
                        View motionView = this.getChildAt(mMotionPosition - mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        clearScrollingCache();
                        final Handler handler = getHandler();
                        if (handler != null) {
                            handler.removeCallbacks(mPendingCheckForLongPress);
                        }
                        recycleVelocityTracker();
                }
                if (mEdgeGlowTop != null) {
                    mEdgeGlowTop.onRelease();
                    mEdgeGlowBottom.onRelease();
                }
                mActivePointerId = INVALID_POINTER;
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                final int x = mMotionX;
                final int y = mMotionY;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                // New pointers take over dragging duties
                final int index = ev.getActionIndex();
                final int id = ev.getPointerId(index);
                final int x = (int) ev.getX(index);
                final int y = (int) ev.getY(index);
                mMotionCorrection = 0;
                mActivePointerId = id;
                mMotionX = x;
                mMotionY = y;
                final int motionPosition = pointToPosition(x, y);
                if (motionPosition >= 0) {
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionPosition = motionPosition;
                }
                mLastY = y;
                break;
            }
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
81,<android.os.PowerManager.WakeLock: void acquire()>,13,14,,,,"{
    synchronized (mToken) {
        if (!mRefCounted || mCount++ == 0) {
            try {
                mService.acquireWakeLock(mFlags, mToken, mTag, mWorkSource);
            } catch (RemoteException e) {
            }
            mHeld = true;
        }
    }
}","{
    synchronized (mToken) {
        acquireLocked();
    }
}",1,"/**
 * Makes sure the device is on at the level you asked when you created
 * the wake lock.
 */
","/**
 * Makes sure the device is on at the level you asked when you created
 * the wake lock.
 */
",0,,,0,,,,,,,"4,5",0,"The body of the synchronized block has been replaced with a call to a separate method acquireLocked(). This indicates a code refactoring that has extracted the lock acquisition logic into its own method, so the code change types are 4 for other changes, such as refactoring, and 5 because it now depends on the new method 'acquireLocked()'.","Without knowing the implementation of the 'acquireLocked()' method, we can't definitively state that there's a compatibility issue. This change could be simply an internal restructuring that doesn't affect the API contract. Without evidence of a behavior change, we assume there is no compatibility issue."
83,<android.speech.tts.TextToSpeech: int setEngineByPackageName(String)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = TextToSpeech.ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            result = mITts.setEngineByPackageName(enginePackageName);
            if (result == TextToSpeech.SUCCESS) {
                mCachedParams[Engine.PARAM_POSITION_ENGINE + 1] = enginePackageName;
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    mRequestedEngine = enginePackageName;
    return initTts();
}",1,"/**
 * Sets the speech synthesis engine to be used by its packagename.
 *
 * @param enginePackageName
 * The packagename for the synthesis engine (ie, ""com.svox.pico"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Sets the TTS engine to use.
 *
 * @deprecated This doesn't inform callers when the TTS engine has been
 * initialized. {@link #TextToSpeech(Context, OnInitListener, String)}
 * can be used with the appropriate engine name. Also, there is no
 * guarantee that the engine specified will be loaded. If it isn't
 * installed or disabled, the user / system wide defaults will apply.
 *
 * @param enginePackageName The package name for the synthesis engine (e.g. ""com.svox.pico"")
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,[@Deprecated],1,,,,,,,"1,3,4",1,"The early implementation has a synchronized block with a try-catch-finally structure, exception handling, and it references mITts to call setEngineByPackageName with a conditional statement to update mCachedParams. In contrast, the late implementation assigns mRequestedEngine and then simply calls initTts() without any exception handling or conditional logic. Therefore, the changes include the removal of the synchronized block, exception handling structure, and direct use of the mITts method, and the addition of direct assignment to mRequestedEngine and a call to initTts(). So the change types are 1 (return statement changed), 3 (control dependency change), and 4 (other statement changed).","Due to the removal of complex logic, including checks and conditional updates to mCachedParams, and the simplification of the return statement, the late version of the API could return different results from the early version, resulting in potential compatibility issues for clients expecting the old behavior. Thus, the CI type is 1."
84,<android.server.BluetoothService: String[] getKnownDevices()>,13,14,,,,"{
    String[] bonds = null;
    String val = getProperty(""Devices"");
    if (val != null) {
        bonds = val.split("","");
    }
    return bonds;
}","{
    String[] bonds = null;
    String val = getProperty(""Devices"", true);
    if (val != null) {
        bonds = val.split("","");
    }
    return bonds;
}",1,,,0,,,0,,,,,,,5,0,"The method `getProperty` has changed from getProperty(""Devices"") to getProperty(""Devices"", true), indicating a change in the dependent API because an additional parameter is being used, so the code change type is 5.","While the change indicates a difference in how the method is called, it doesn't necessarily lead to a compatibility issue if the behavior of `getProperty` remains consistent with respect to the return value when the extra parameter is true. As there is no evidence that the return type or thrown exceptions have changed, it can be inferred that there is no compatibility issue, so CI type is 0."
86,"<android.content.ContentProviderProxy: int delete(Uri,String,String[])>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeString(selection);
    data.writeStringArray(selectionArgs);
    mRemote.transact(IContentProvider.DELETE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    int count = reply.readInt();
    data.recycle();
    reply.recycle();
    return count;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeString(selection);
        data.writeStringArray(selectionArgs);
        mRemote.transact(IContentProvider.DELETE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        int count = reply.readInt();
        return count;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The implementation change is wrapping the code in a try-finally block to ensure proper recycling of Parcel objects, which corresponds to a control dependency change (3) and an other statement changed (4). There is the introduction of a try-finally block to ensure parcels are recycled and no change to the logic of the method itself.",There is no Compatibility Issue since the functional behavior of the API remains unchanged; the method still performs the same operations and returns the same values under the same conditions as before. The introduction of the try-finally block is a code quality improvement and does not affect the API contract.
87,<android.app.Activity: boolean startNextMatchingActivity(Intent)>,13,14,,,,"{
    if (mParent == null) {
        try {
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        try {
            intent.setAllowFds(false);
            return ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent);
        } catch (RemoteException e) {
        // Empty
        }
        return false;
    }
    throw new UnsupportedOperationException(""startNextMatchingActivity can only be called from a top-level activity"");
}",1,"/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
","/**
 * Special version of starting an activity, for use when you are replacing
 * other activity components.  You can use this to hand the Intent off
 * to the next Activity that can handle it.  You typically call this in
 * {@link #onCreate} with the Intent returned by {@link #getIntent}.
 *
 * @param intent The intent to dispatch to the next activity.  For
 * correct behavior, this must be the same as the Intent that started
 * your own activity; the only changes you can make are to the extras
 * inside of it.
 *
 * @return Returns a boolean indicating whether there was another Activity
 * to start: true if there was a next activity to start, false if there
 * wasn't.  In general, if true is returned you will then want to call
 * finish() on yourself.
 */
",0,,,0,,,,,,,4,0,"The only change in the implementation is the addition of 'intent.setAllowFds(false);' before the existing call to 'ActivityManagerNative.getDefault().startNextMatchingActivity(mToken, intent);'. This line modifies the 'intent' object but does not alter the flow of control or the nature of exceptions thrown, so the code change type is 4.","Although an attribute of 'intent' is changed, the API's control flow, thrown exceptions, and return values are not affected. There is no Compatibility Issue since the API's behavior remains consistent in terms of what it returns and what exceptions it may throw. The invocation 'intent.setAllowFds(false);' may be setting a property to control file descriptor sharing over IPC calls, but this does not inherently lead to a different behavior from the perspective of 'startNextMatchingActivity' method's contract. Therefore, the CI type is 0."
91,<android.widget.TextView.HandleView: void show()>,13,14,,,,"{
    updateContainerPosition();
    if (isShowing()) {
        mContainer.update(mContainerPositionX, mContainerPositionY, mRight - mLeft, mBottom - mTop);
        hidePastePopupWindow();
    } else {
        mContainer.showAtLocation(TextView.this, 0, mContainerPositionX, mContainerPositionY);
        mIsActive = true;
        ViewTreeObserver vto = TextView.this.getViewTreeObserver();
        vto.addOnPreDrawListener(this);
    }
}","{
    if (isShowing())
        return;
    getPositionListener().addSubscriber(this, true);
    // Make sure the offset is always considered new, even when focusing at same position
    mPreviousOffset = -1;
    positionAtCursorOffset(getCurrentCursorOffset(), false);
    hideActionPopupWindow();
}",1,,,0,,,0,,,,,,,"1,3,4",1,"The late version has added new control dependency with a return statement, and also there are an addition of the getPositionListener().addSubscriber(this, true), a deletion of the updateContainerPosition(), and other modifications in the method. These constitute changes of type 1 (return statement changed), type 3 (control dependency changed), and type 4 (other statement changed).","The method now includes an early return if `isShowing()` evaluates to true, preventing execution of subsequent code, which implies a return type behavior change because the early version updated the container or showed it at a location based on this condition. That means the late version possibly returns without making changes that the early version would have. Thus, the CI type is 1."
92,<android.nfc.tech.BasicTagTechnology: void connect()>,13,14,,,,"{
    try {
        int errorCode = mTag.getTagService().connect(mTag.getServiceHandle(), mSelectedTechnology);
        if (errorCode == ErrorCodes.SUCCESS) {
            // Store this in the tag object
            mTag.setConnectedTechnology(mSelectedTechnology);
            mIsConnected = true;
        } else {
            throw new IOException();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}","{
    try {
        int errorCode = mTag.getTagService().connect(mTag.getServiceHandle(), mSelectedTechnology);
        if (errorCode == ErrorCodes.SUCCESS) {
            // Store this in the tag object
            mTag.setConnectedTechnology(mSelectedTechnology);
            mIsConnected = true;
        } else if (errorCode == ErrorCodes.ERROR_NOT_SUPPORTED) {
            throw new UnsupportedOperationException(""Connecting to "" + ""this technology is not supported by the NFC "" + ""adapter."");
        } else {
            throw new IOException();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,2,2,"The late implementation introduces a new condition with a different exception being thrown (UnsupportedOperationException), so the code change type is 2.","The introduction of a specific exception being thrown for the new error code ERROR_NOT_SUPPORTED means the method can now throw a new type of exception that it would not have thrown in the early version. This represents a potential CI related to exception handling, hence the CI type is 2."
93,<android.webkit.CallbackProxy: void onReceivedCertificate(SslCertificate)>,13,14,,,,"{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // here, certificate can be null (if the site is not secure)
    sendMessage(obtainMessage(RECEIVED_CERTIFICATE, certificate));
}","{
    // here, certificate can be null (if the site is not secure)
    sendMessage(obtainMessage(RECEIVED_CERTIFICATE, certificate));
}",1,,,0,,,0,,,,,,,"1,3",0,"The control dependency has changed because the check for 'mWebViewClient == null' and the related return statement in the early version were removed in the late version. This is a control dependency change, type 3.","Although the control dependency has been removed, there isn't actually a change in behavior with regards to the outside observer because the internal `sendMessage` method would likely have its own checks for a null `mWebViewClient` before doing any meaningful work. Thus, we can infer there is no Compatibility Issue as long as `sendMessage` is robust against `mWebViewClient` being null, which can be a reasonable assumption. Therefore, the CI type is 0."
96,<android.webkit.WebView: boolean overlayVerticalScrollbar()>,13,14,,,,"{
    return mOverlayVerticalScrollbar;
}","{
    checkThread();
    return mOverlayVerticalScrollbar;
}",1,"/**
 * Return whether vertical scrollbar has overlay style
 * @return TRUE if vertical scrollbar has overlay style.
 */
","/**
 * Return whether vertical scrollbar has overlay style
 * @return TRUE if vertical scrollbar has overlay style.
 */
",0,,,0,,,,,,,4,0,"The method now calls checkThread() before returning mOverlayVerticalScrollbar, which is a change in statements other than return, exception handling, and control dependency. Thus, the code change type is 4.","The added checkThread() call does not affect the return value of the method nor does it introduce a new exception that the method could throw. It's presumably a sanity check to ensure that the WebView methods are being called from the correct thread. Assuming checkThread() does not throw an exception that would alter the control flow of the method (which is not evident from the context we have), there should be no compatibility issue related to the return value or exception handling of the method. Therefore, the CI type is 0."
99,<android.app.Instrumentation.ActivityMonitor: Activity waitForActivityWithTimeout(long)>,13,14,,,,"{
    synchronized (this) {
        try {
            wait(timeOut);
        } catch (InterruptedException e) {
        }
        if (mLastActivity == null) {
            return null;
        } else {
            Activity res = mLastActivity;
            mLastActivity = null;
            return res;
        }
    }
}","{
    synchronized (this) {
        if (mLastActivity == null) {
            try {
                wait(timeOut);
            } catch (InterruptedException e) {
            }
        }
        if (mLastActivity == null) {
            return null;
        } else {
            Activity res = mLastActivity;
            mLastActivity = null;
            return res;
        }
    }
}",1,"/**
 * Block until an Activity is created that matches this monitor,
 * returning the resulting activity or till the timeOut period expires.
 * If the timeOut expires before the activity is started, return null.
 *
 * @param timeOut Time to wait before the activity is created.
 *
 * @return Activity
 */
","/**
 * Block until an Activity is created that matches this monitor,
 * returning the resulting activity or till the timeOut period expires.
 * If the timeOut expires before the activity is started, return null.
 *
 * @param timeOut Time to wait before the activity is created.
 *
 * @return Activity
 */
",0,,,0,,,,,,,3,0,"The early implementation performs the wait operation regardless of the state of 'mLastActivity', while the late implementation first checks if 'mLastActivity' is null and only then performs the wait. This constitutes a control dependency change so the change type is 3.","There's no Compatibility Issue here because the wait method call was moved inside a conditional statement. If mLastActivity is not null before the wait, it would skip the wait in the late version, as compared to the early version which unconditionally waits. However, this would not cause the API to return a different value or throw a different exception, because both versions will ultimately return mLastActivity. If mLastActivity is null, both versions wait for the same timeout and set mLastActivity to null before returning. Hence, the behavior from a client's perspective remains consistent."
101,<android.animation.AnimatorSet: AnimatorSet clone()>,13,14,,,,"{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    anim.mNeedsSort = true;
    anim.mCanceled = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>();
    anim.mSortedNodes = new ArrayList<Node>();
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    // <old, new>
    HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>();
    for (Node node : mNodes) {
        Node nodeClone = node.clone();
        nodeCloneMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            ArrayList<AnimatorListener> listenersToRemove = null;
            for (AnimatorListener listener : cloneListeners) {
                if (listener instanceof AnimatorSetListener) {
                    if (listenersToRemove == null) {
                        listenersToRemove = new ArrayList<AnimatorListener>();
                    }
                    listenersToRemove.add(listener);
                }
            }
            if (listenersToRemove != null) {
                for (AnimatorListener listener : listenersToRemove) {
                    cloneListeners.remove(listener);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (Node node : mNodes) {
        Node nodeClone = nodeCloneMap.get(node);
        if (node.dependencies != null) {
            for (Dependency dependency : node.dependencies) {
                Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
                nodeClone.addDependency(cloneDependency);
            }
        }
    }
    return anim;
}","{
    final AnimatorSet anim = (AnimatorSet) super.clone();
    /*
         * The basic clone() operation copies all items. This doesn't work very well for
         * AnimatorSet, because it will copy references that need to be recreated and state
         * that may not apply. What we need to do now is put the clone in an uninitialized
         * state, with fresh, empty data structures. Then we will build up the nodes list
         * manually, as we clone each Node (and its animation). The clone will then be sorted,
         * and will populate any appropriate lists, when it is started.
         */
    anim.mNeedsSort = true;
    anim.mTerminated = false;
    anim.mStarted = false;
    anim.mPlayingSet = new ArrayList<Animator>();
    anim.mNodeMap = new HashMap<Animator, Node>();
    anim.mNodes = new ArrayList<Node>();
    anim.mSortedNodes = new ArrayList<Node>();
    // Walk through the old nodes list, cloning each node and adding it to the new nodemap.
    // One problem is that the old node dependencies point to nodes in the old AnimatorSet.
    // We need to track the old/new nodes in order to reconstruct the dependencies in the clone.
    // <old, new>
    HashMap<Node, Node> nodeCloneMap = new HashMap<Node, Node>();
    for (Node node : mNodes) {
        Node nodeClone = node.clone();
        nodeCloneMap.put(node, nodeClone);
        anim.mNodes.add(nodeClone);
        anim.mNodeMap.put(nodeClone.animation, nodeClone);
        // Clear out the dependencies in the clone; we'll set these up manually later
        nodeClone.dependencies = null;
        nodeClone.tmpDependencies = null;
        nodeClone.nodeDependents = null;
        nodeClone.nodeDependencies = null;
        // clear out any listeners that were set up by the AnimatorSet; these will
        // be set up when the clone's nodes are sorted
        ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
        if (cloneListeners != null) {
            ArrayList<AnimatorListener> listenersToRemove = null;
            for (AnimatorListener listener : cloneListeners) {
                if (listener instanceof AnimatorSetListener) {
                    if (listenersToRemove == null) {
                        listenersToRemove = new ArrayList<AnimatorListener>();
                    }
                    listenersToRemove.add(listener);
                }
            }
            if (listenersToRemove != null) {
                for (AnimatorListener listener : listenersToRemove) {
                    cloneListeners.remove(listener);
                }
            }
        }
    }
    // dependencies, mapping the old dependencies to the new nodes
    for (Node node : mNodes) {
        Node nodeClone = nodeCloneMap.get(node);
        if (node.dependencies != null) {
            for (Dependency dependency : node.dependencies) {
                Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
                Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
                nodeClone.addDependency(cloneDependency);
            }
        }
    }
    return anim;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
103,"<android.view.View: boolean postDelayed(Runnable,long)>",13,14,,,,"{
    Handler handler;
    if (mAttachInfo != null) {
        handler = mAttachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRoot.getRunQueue().postDelayed(action, delayMillis);
        return true;
    }
    return handler.postDelayed(action, delayMillis);
}","{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
        return true;
    }
    return handler.postDelayed(action, delayMillis);
}",1,"/**
 * Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 */
","/**
 * <p>Causes the Runnable to be added to the message queue, to be run
 * after the specified amount of time elapses.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 * @param delayMillis The delay (in milliseconds) until the Runnable
 * will be executed.
 *
 * @return true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.  Note that a
 * result of true does not mean the Runnable will be processed --
 * if the looper is quit before the delivery time of the message
 * occurs then the message will be dropped.
 */
",1,,,0,,,,,,,"3,5",0,"The control dependency has changed due to the introduction of a new local variable 'attachInfo' that is used instead of directly accessing 'mAttachInfo'. Additionally, the dependent API changed from 'ViewRoot.getRunQueue()' to 'ViewRootImpl.getRunQueue()', so the code change type is 3,5.","There is no Compatibility Issue introduced by these changes, as the logic and the final outcomes of the method remain the same. The introduction of a new local variable does not alter the behavior, and the change made to the dependent API name does not implicitly indicate a difference in the execution or outcome. Therefore, the CI type is 0."
104,"<android.speech.tts.TextToSpeech: int synthesizeToFile(String,HashMap<String, String>,String)>",13,14,,,,"{
    Log.i(""TextToSpeech.java"", ""synthesizeToFile()"");
    synchronized (mStartLock) {
        int result = ERROR;
        Log.i(""TextToSpeech.java - synthesizeToFile"", ""synthesizeToFile text of length "" + text.length());
        if (!mStarted) {
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""service isn't started"");
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                // no need to read the stream type here
                setCachedParam(params, Engine.KEY_PARAM_UTTERANCE_ID, Engine.PARAM_POSITION_UTTERANCE_ID);
                setCachedParam(params, Engine.KEY_PARAM_ENGINE, Engine.PARAM_POSITION_ENGINE);
            }
            result = mITts.synthesizeToFile(mPackageName, text, mCachedParams, filename) ? SUCCESS : ERROR;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - synthesizeToFile"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.synthesizeToFile(getPackageName(), text, filename, getParams(params));
        }
    }, ERROR, ""synthesizeToFile"");
}",1,"/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text
 * The String of text that should be synthesized
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * @param filename
 * The string that gives the full output filename; it should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Synthesizes the given text to a file using the specified parameters.
 *
 * @param text The text that should be synthesized
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 * @param filename Absolute file filename to write the generated audio data to.It should be
 * something like ""/sdcard/myappsounds/mysound.wav"".
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4,5",1,"The late version of the implementation includes a significant change where the method uses a new 'runAction' mechanism instead of the direct method calls and exception handling present in the early version. Moreover, the variable 'mStarted' and associated check, logging statements, and parameters handling have been removed. The 'synthesizeToFile' method has been replaced with a call to 'service.synthesizeToFile'. These are changes in control dependency, other statements, and reliance on a dependent API, so the change types are 1,3,4,5.","The new implementation may return different values because of the change in control dependencies and the dependent API call. In the early version, various checks and initializations occur that could affect the return value, which is not present in the late version. There is also no longer any exception handling inside the method, potentially changing the exception throwing behavior. Thus, the CI type could be 1 (as it may possibly return a different value)."
105,<android.webkit.WebView: boolean onTrackballEvent(MotionEvent)>,13,14,,,,"{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time, ev.getMetaState());
    return true;
}","{
    long time = ev.getEventTime();
    if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
        if (ev.getY() > 0)
            pageDown(true);
        if (ev.getY() < 0)
            pageUp(true);
        return true;
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (mSelectingText) {
            // discard press if copy in progress
            return true;
        }
        mTrackballDown = true;
        if (mNativeClass == 0) {
            return false;
        }
        recordButtons(null, hasFocus() && hasWindowFocus(), true, true);
        if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
            nativeSelectBestAt(mLastCursorBounds);
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent down ev="" + ev + "" time="" + time + "" mLastCursorTime="" + mLastCursorTime);
        }
        if (isInTouchMode())
            requestFocusFromTouch();
        // let common code in onKeyDown at it
        return false;
    }
    if (ev.getAction() == MotionEvent.ACTION_UP) {
        // LONG_PRESS_CENTER is set in common onKeyDown
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mTrackballDown = false;
        mTrackballUpTime = time;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent up ev="" + ev + "" time="" + time);
        }
        // let common code in onKeyUp at it
        return false;
    }
    if ((mMapTrackballToArrowKeys && (ev.getMetaState() & KeyEvent.META_SHIFT_ON) == 0) || AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent gmail quit"");
        return false;
    }
    if (mTrackballDown) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent down quit"");
        // discard move if trackball is down
        return true;
    }
    if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW)
            Log.v(LOGTAG, ""onTrackballEvent up timeout quit"");
        return true;
    }
    // TODO: alternatively we can do panning as touch does
    switchOutDrawHistory();
    if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""onTrackballEvent time="" + time + "" last="" + mTrackballLastTime);
        }
        mTrackballFirstTime = time;
        mTrackballXMove = mTrackballYMove = 0;
    }
    mTrackballLastTime = time;
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""onTrackballEvent ev="" + ev + "" time="" + time);
    }
    mTrackballRemainsX += ev.getX();
    mTrackballRemainsY += ev.getY();
    doTrackball(time, ev.getMetaState());
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
109,"<android.view.HardwareRenderer.GlRenderer: EGLContext createContext(EGL10,EGLDisplay,EGLConfig)>",13,14,,,,"{
    int[] attrib_list = { EGL_CONTEXT_CLIENT_VERSION, mGlVersion, EGL10.EGL_NONE };
    return egl.eglCreateContext(eglDisplay, eglConfig, EGL10.EGL_NO_CONTEXT, mGlVersion != 0 ? attrib_list : null);
}","{
    int[] attribs = { EGL_CONTEXT_CLIENT_VERSION, mGlVersion, EGL_NONE };
    return egl.eglCreateContext(eglDisplay, eglConfig, EGL_NO_CONTEXT, mGlVersion != 0 ? attribs : null);
}",1,,,0,,,0,,,,,,,4,0,"The variable name changed from 'attrib_list' to 'attribs', and the constants are accessed directly (EGL_NONE, EGL_NO_CONTEXT) instead of through EGL10 (EGL10.EGL_NONE, EGL10.EGL_NO_CONTEXT). However, assuming these constants are the same (as they are referring to standard constants in EGL), there's no effect on the behavior of the method itself; hence it is classified as an 'other statement changed'.","Despite variable name changes and direct access to constants instead of through EGL10, the final behavior of the 'eglCreateContext' method call remains the same (assuming constants have the same values). Therefore, no compatibility issues arise from this change."
110,<android.webkit.WebView: boolean pageDown(boolean)>,13,14,,,,"{
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, computeRealVerticalScrollRange(), true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}","{
    checkThread();
    if (mNativeClass == 0) {
        return false;
    }
    // start next trackball movement from page edge
    nativeClearCursor();
    if (bottom) {
        return pinScrollTo(mScrollX, computeRealVerticalScrollRange(), true, 0);
    }
    // Page down.
    int h = getHeight();
    int y;
    if (h > 2 * PAGE_SCROLL_OVERLAP) {
        y = h - PAGE_SCROLL_OVERLAP;
    } else {
        y = h / 2;
    }
    return mScroller.isFinished() ? pinScrollBy(0, y, true, 0) : extendScroll(y);
}",1,"/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
","/**
 * Scroll the contents of the view down by half the page size
 * @param bottom true to jump to bottom of page
 * @return true if the page was scrolled
 */
",0,,,0,,,,,,,4,0,The only code change is the addition of the method call checkThread() at the beginning of the Late_Implementation. This is an example of an Other statement changed.,"The addition of the checkThread() method does not affect the return values or exception handling, as it seems to be a check for correct thread usage without impacting the control flow for the return statements or existing exception handling. Thus there's no Compatibility Issue."
112,<android.widget.TextView: boolean performLongClick()>,13,14,,,,"{
    if (super.performLongClick()) {
        mDiscardNextActionUp = true;
        return true;
    }
    boolean handled = false;
    // Long press in empty space moves cursor and shows the Paste affordance if available.
    if (!isPositionOnText(mLastDownPositionX, mLastDownPositionY) && mInsertionControllerEnabled) {
        final int offset = getOffset(mLastDownPositionX, mLastDownPositionY);
        stopSelectionActionMode();
        Selection.setSelection((Spannable) mText, offset);
        getInsertionController().show(0);
        handled = true;
    }
    if (!handled && mSelectionActionMode != null) {
        if (touchPositionIsInSelection()) {
            // Start a drag
            final int start = getSelectionStart();
            final int end = getSelectionEnd();
            CharSequence selectedText = mTransformed.subSequence(start, end);
            ClipData data = ClipData.newPlainText(null, selectedText);
            DragLocalState localState = new DragLocalState(this, start, end);
            startDrag(data, getTextThumbnailBuilder(selectedText), localState, 0);
            stopSelectionActionMode();
        } else {
            // New selection at touch position
            updateSelectedRegion();
        }
        handled = true;
    }
    // Start a new selection
    handled |= !handled && startSelectionActionMode();
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        mDiscardNextActionUp = true;
    }
    return handled;
}","{
    boolean handled = false;
    boolean vibrate = true;
    if (super.performLongClick()) {
        mDiscardNextActionUp = true;
        handled = true;
    }
    // Long press in empty space moves cursor and shows the Paste affordance if available.
    if (!handled && !isPositionOnText(mLastDownPositionX, mLastDownPositionY) && mInsertionControllerEnabled) {
        final int offset = getOffsetForPosition(mLastDownPositionX, mLastDownPositionY);
        stopSelectionActionMode();
        Selection.setSelection((Spannable) mText, offset);
        getInsertionController().showWithActionPopup();
        handled = true;
        vibrate = false;
    }
    if (!handled && mSelectionActionMode != null) {
        if (touchPositionIsInSelection()) {
            // Start a drag
            final int start = getSelectionStart();
            final int end = getSelectionEnd();
            CharSequence selectedText = getTransformedText(start, end);
            ClipData data = ClipData.newPlainText(null, selectedText);
            DragLocalState localState = new DragLocalState(this, start, end);
            startDrag(data, getTextThumbnailBuilder(selectedText), localState, 0);
            stopSelectionActionMode();
        } else {
            getSelectionController().hide();
            selectCurrentWord();
            getSelectionController().show();
        }
        handled = true;
    }
    // Start a new selection
    if (!handled) {
        vibrate = handled = startSelectionActionMode();
    }
    if (vibrate) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    if (handled) {
        mDiscardNextActionUp = true;
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,The code changes include:,"- The combined ""if"" condition `if (!handled && !isPositionOnText(mLastDownPositionX, mLastDownPositionY) && mInsertionControllerEnabled)` is split into a nested ""if"" where `!handled` is separated."
114,"<android.app.WallpaperManager: void suggestDesiredDimensions(int,int)>",13,14,,,,"{
    try {
        sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
    } catch (RemoteException e) {
    }
}","{
    try {
        sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
","/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */
",0,,,0,,,,,,,0,0,"There's no actual change in the implementation code; the catch block comment was modified, but it does not affect the functionality.",There is no Compatibility Issue because there is no change affecting the behavior of the method; it still performs the same operations and handles the exception in the exact same way.
116,<android.widget.TextView: boolean onTextContextMenuItem(int)>,13,14,,,,"{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_COPY_URL:
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length >= 1) {
                ClipData clip = null;
                for (int i = 0; i < urls.length; i++) {
                    Uri uri = Uri.parse(urls[0].getURL());
                    if (clip == null) {
                        clip = ClipData.newRawUri(null, uri);
                    } else {
                        clip.addItem(new ClipData.Item(uri));
                    }
                }
                if (clip != null) {
                    setPrimaryClip(clip);
                }
            }
            stopSelectionActionMode();
            return true;
        case ID_SELECTION_MODE:
            if (mSelectionActionMode != null) {
                // Selection mode is already started, simply change selected part.
                updateSelectedRegion();
            } else {
                startSelectionActionMode();
            }
            return true;
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does.
            selectAll();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, mTransformed.subSequence(min, max)));
            ((Editable) mText).delete(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, mTransformed.subSequence(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}","{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_COPY_URL:
            URLSpan[] urls = ((Spanned) mText).getSpans(min, max, URLSpan.class);
            if (urls.length >= 1) {
                ClipData clip = null;
                for (int i = 0; i < urls.length; i++) {
                    Uri uri = Uri.parse(urls[0].getURL());
                    if (clip == null) {
                        clip = ClipData.newRawUri(null, uri);
                    } else {
                        clip.addItem(new ClipData.Item(uri));
                    }
                }
                if (clip != null) {
                    setPrimaryClip(clip);
                }
            }
            stopSelectionActionMode();
            return true;
        case ID_SELECTION_MODE:
            if (mSelectionActionMode != null) {
                // Selection mode is already started, simply change selected part.
                selectCurrentWord();
            } else {
                startSelectionActionMode();
            }
            return true;
        case ID_SELECT_ALL:
            // This does not enter text selection mode. Text is highlighted, so that it can be
            // bulk edited, like selectAllOnFocus does. Returns true even if text is empty.
            selectAll();
            return true;
        case ID_PASTE:
            paste(min, max);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            ((Editable) mText).delete(min, max);
            stopSelectionActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopSelectionActionMode();
            return true;
    }
    return false;
}",1,"/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be {@link android.R.id#copyUrl}, {@link android.R.id#selectTextMode},
 * {@link android.R.id#selectAll}, {@link android.R.id#paste}, {@link android.R.id#cut}
 * or {@link android.R.id#copy}.
 */
","/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be {@link android.R.id#copyUrl}, {@link android.R.id#selectTextMode},
 * {@link android.R.id#selectAll}, {@link android.R.id#paste}, {@link android.R.id#cut}
 * or {@link android.R.id#copy}.
 *
 * @return true if the context menu item action was performed.
 */
",1,,,0,,,,,,,"3,4",0,"The control dependency change is observed in the 'ID_SELECTION_MODE' case where the method updateSelectedRegion() is replaced with selectCurrentWord(). Additionally, there's also a change in 'ID_CUT' and 'ID_COPY' cases where mTransformed.subSequence(min, max) is replaced by method call getTransformedText(min, max), so the change type includes both 3 and 4.",There is no Compatibility Issue; the API behavior doesn't seem to be affected in a way that would lead to a different return value or cause a different exception to be thrown; the changes appear to be internal with no visible impact on API contract.
118,<android.webkit.WebTextView: void setTextAndKeepSelection(String)>,13,14,,,,"{
    mPreChange = text.toString();
    Editable edit = getText();
    int selStart = Selection.getSelectionStart(edit);
    int selEnd = Selection.getSelectionEnd(edit);
    mInSetTextAndKeepSelection = true;
    edit.replace(0, edit.length(), text);
    int newLength = edit.length();
    if (selStart > newLength)
        selStart = newLength;
    if (selEnd > newLength)
        selEnd = newLength;
    Selection.setSelection(edit, selStart, selEnd);
    mInSetTextAndKeepSelection = false;
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        // Since the text has changed, do not allow the IME to replace the
        // existing text as though it were a completion.
        imm.restartInput(this);
    }
    updateCachedTextfield();
}","{
    Editable edit = getText();
    mPreChange = text;
    if (edit.toString().equals(text)) {
        return;
    }
    int selStart = Selection.getSelectionStart(edit);
    int selEnd = Selection.getSelectionEnd(edit);
    mInSetTextAndKeepSelection = true;
    edit.replace(0, edit.length(), text);
    int newLength = edit.length();
    if (selStart > newLength)
        selStart = newLength;
    if (selEnd > newLength)
        selEnd = newLength;
    Selection.setSelection(edit, selStart, selEnd);
    mInSetTextAndKeepSelection = false;
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(this)) {
        // Since the text has changed, do not allow the IME to replace the
        // existing text as though it were a completion.
        imm.restartInput(this);
    }
    updateCachedTextfield();
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,3,4",0,"The assignment of `mPreChange` is moved, and there's a new if-condition added to return early if `edit.toString()` equals `text`. This includes a return statement modified, a conditional dependency change, and an other statement change, which are the change types 1, 3, and 4 respectively.","There is no Compatibility Issue detected because the early return only happens when the new text is the same as the old one. In such a case, keeping the selection the same is the intended behavior and does not alter the functionality seen by the caller. The rest of the code is the same and would result in the same behavior when the conditional check is bypassed (in cases where the text is different). Thus, the functional behavior from an external point of view remains identical."
119,"<android.server.BluetoothService: boolean setBondState(String,int,int)>",13,14,,,,"{
    mBondState.setBondState(address.toUpperCase(), state);
    return true;
}","{
    mBondState.setBondState(address.toUpperCase(), state, reason);
    return true;
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"4,5",0,"The method call within the implementation has an additional parameter 'reason' in the late version. Therefore, the method signature for 'setBondState' has changed which is a dependent API change, so the code change is of type 4,5.","Despite the fact that a dependent API setBondState(String, int, int) now includes an extra parameter, 'true' is always returned from this API, which means there is no change in the return type or value and no new exceptions are thrown. There is no potential compatibility issue, therefore the CI type is 0."
121,<android.view.View: boolean isOpaque()>,13,14,,,,"{
    return (mPrivateFlags & OPAQUE_MASK) == OPAQUE_MASK && (mAlpha >= 1.0f - ViewConfiguration.ALPHA_THRESHOLD);
}","{
    return (mPrivateFlags & OPAQUE_MASK) == OPAQUE_MASK && ((mTransformationInfo != null ? mTransformationInfo.mAlpha : 1) >= 1.0f - ViewConfiguration.ALPHA_THRESHOLD);
}",1,"/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
","/**
 * Indicates whether this View is opaque. An opaque View guarantees that it will
 * draw all the pixels overlapping its bounds using a fully opaque color.
 *
 * Subclasses of View should override this method whenever possible to indicate
 * whether an instance is opaque. Opaque Views are treated in a special way by
 * the View hierarchy, possibly allowing it to perform optimizations during
 * invalidate/draw passes.
 *
 * @return True if this View is guaranteed to be fully opaque, false otherwise.
 */
",0,"[@ViewDebug.ExportedProperty(category = ""drawing"")]","[@ViewDebug.ExportedProperty(category = ""drawing"")]",0,,,,,,,4,0,"There is a change only in the operand `mTransformationInfo != null ? mTransformationInfo.mAlpha : 1` which alters how `mAlpha` is evaluated in the late version. This change does not affect control flow, exception handling, and does not introduce any new API dependencies; hence, the change type is 4.","The semantics of the check for opacity have been preserved, and the change does not introduce the possibility of a new behavior for return values or thrown exceptions, meaning no compatibility issue exists. The condition will still evaluate to the same boolean value in cases where `mTransformationInfo` is `null` or `mTransformationInfo.mAlpha` is `1`. Thus, the change is an internal refactoring that doesn't affect the API's contract."
123,<android.speech.tts.TextToSpeech: int setSpeechRate(float)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if (speechRate > 0) {
                int rate = (int) (speechRate * 100);
                mCachedParams[Engine.PARAM_POSITION_RATE + 1] = String.valueOf(rate);
                // with all upcoming utterances.
                if (speechRate > 0.0f) {
                    result = SUCCESS;
                } else {
                    result = ERROR;
                }
            }
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setSpeechRate"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setSpeechRate"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    if (speechRate > 0.0f) {
        int intRate = (int) (speechRate * 100);
        if (intRate > 0) {
            synchronized (mStartLock) {
                mParams.putInt(Engine.KEY_PARAM_RATE, intRate);
            }
            return SUCCESS;
        }
    }
    return ERROR;
}",1,"/**
 * Sets the speech rate for the TextToSpeech engine.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param speechRate
 * The speech rate for the TextToSpeech engine. 1 is the normal speed,
 * lower values slow down the speech (0.5 is half the normal speech rate),
 * greater values accelerate it (2 is twice the normal speech rate).
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Sets the speech rate.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param speechRate Speech rate. {@code 1.0} is the normal speech rate,
 * lower values slow down the speech ({@code 0.5} is half the normal speech rate),
 * greater values accelerate it ({@code 2.0} is twice the normal speech rate).
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4","1,2","The early version has an additional control dependency with the synchronized block and additional exception handling blocks. The late version removes this synchronization block, the exception handling, changes the flow of control, and alters the logic that determines the result (e.g., removing the needless secondary check of speechRate > 0.0f after verifying it's > 0, which given the context is redundant). Additionally, method calls and accessed fields have changed (e.g., from accessing mCachedParams to using mParams.putInt(Engine.KEY_PARAM_RATE, intRate)). Hence, the change type is 1,3,4.","Since the late version changes how the parameter is applied (from mCachedParams to mParams) and drops exception handling, it allows exceptions to propagate up the call stack instead of catching them and restarting the service, this can lead to different behaviors (potentially throwing a RuntimeException that was previously caught) which can cause a CI. The flow of the method has also been fundamentally altered due to the removal of the synchronization block and the try-catch-finally structure which changes when and how SUCCESS or ERROR is returned. Therefore, the CI type is 1,2 due to the potential for different return values in normal execution and the differing exception handling behavior."
125,<android.app.ActivityManager: List<RunningServiceInfo> getRunningServices(int)>,13,14,,,,"{
    try {
        return (List<RunningServiceInfo>) ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}",1,"/**
 * Return a list of the services that are currently running.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
","/**
 * Return a list of the services that are currently running.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */
",0,,,0,,,,,,,4,0,"The cast to `List<RunningServiceInfo>` has been removed from the return statement in the try block. This represents a removal of an unnecessary cast since `getServices()` is expected to return a `List<RunningServiceInfo>`. Therefore, the behavior of casting is implicit after the change. The code change type is 4.","There is no Compatibility Issue because the removal of the cast does not alter the type or value being returned by the method. The returned value is still a `List<RunningServiceInfo>`, and unless there was a change in the `getServices` method signature (which is not indicated in the provided information), the behavior should remain the same. The CI type is 0."
126,<android.preference.MultiSelectListPreference: void onPrepareDialogBuilder(Builder)>,13,14,,,,"{
    super.onPrepareDialogBuilder(builder);
    if (mEntries == null || mEntryValues == null) {
        throw new IllegalStateException(""MultiSelectListPreference requires an entries array and "" + ""an entryValues array."");
    }
    boolean[] checkedItems = getSelectedItems();
    builder.setMultiChoiceItems(mEntries, checkedItems, new DialogInterface.OnMultiChoiceClickListener() {

        public void onClick(DialogInterface dialog, int which, boolean isChecked) {
            if (isChecked) {
                mPreferenceChanged |= mNewValues.add(mEntries[which].toString());
            } else {
                mPreferenceChanged |= mNewValues.remove(mEntries[which].toString());
            }
        }
    });
    mNewValues.clear();
    mNewValues.addAll(mValues);
}","{
    super.onPrepareDialogBuilder(builder);
    if (mEntries == null || mEntryValues == null) {
        throw new IllegalStateException(""MultiSelectListPreference requires an entries array and "" + ""an entryValues array."");
    }
    boolean[] checkedItems = getSelectedItems();
    builder.setMultiChoiceItems(mEntries, checkedItems, new DialogInterface.OnMultiChoiceClickListener() {

        public void onClick(DialogInterface dialog, int which, boolean isChecked) {
            if (isChecked) {
                mPreferenceChanged |= mNewValues.add(mEntryValues[which].toString());
            } else {
                mPreferenceChanged |= mNewValues.remove(mEntryValues[which].toString());
            }
        }
    });
    mNewValues.clear();
    mNewValues.addAll(mValues);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change from `mEntries[which].toString()` to `mEntryValues[which].toString()` within the onClick listener represents a modification in the processing logic within a method implementation, constituting the code change type 4.","There is no Compatibility Issue arising from this change. While the implementation has indeed changed the set of values that may be added or removed from mNewValues, this deals with internal state change rather than altering the behavior of the API in terms of return values or exceptions. The API's method signature, return type, and exception throwing behavior remain unchanged."
128,"<android.widget.TextView.SelectionActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",13,14,,,,"{
    TypedArray styledAttributes = mContext.obtainStyledAttributes(R.styleable.Theme);
    mode.setTitle(mContext.getString(com.android.internal.R.string.textSelectionCABTitle));
    mode.setSubtitle(null);
    menu.add(0, ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (canCut()) {
        menu.add(0, ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.Theme_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (canCopy()) {
        menu.add(0, ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.Theme_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (canPaste()) {
        menu.add(0, ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.Theme_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        return true;
    } else {
        return false;
    }
}","{
    TypedArray styledAttributes = mContext.obtainStyledAttributes(com.android.internal.R.styleable.SelectionModeDrawables);
    boolean allowText = getContext().getResources().getBoolean(com.android.internal.R.bool.config_allowActionMenuItemTextWithIcon);
    mode.setTitle(allowText ? mContext.getString(com.android.internal.R.string.textSelectionCABTitle) : null);
    mode.setSubtitle(null);
    // No icon by default
    int selectAllIconId = 0;
    if (!allowText) {
        // Provide an icon, text will not be displayed on smaller screens.
        selectAllIconId = styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeSelectAllDrawable, 0);
    }
    menu.add(0, ID_SELECT_ALL, 0, com.android.internal.R.string.selectAll).setIcon(selectAllIconId).setAlphabeticShortcut('a').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    if (canCut()) {
        menu.add(0, ID_CUT, 0, com.android.internal.R.string.cut).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCutDrawable, 0)).setAlphabeticShortcut('x').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (canCopy()) {
        menu.add(0, ID_COPY, 0, com.android.internal.R.string.copy).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModeCopyDrawable, 0)).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    if (canPaste()) {
        menu.add(0, ID_PASTE, 0, com.android.internal.R.string.paste).setIcon(styledAttributes.getResourceId(R.styleable.SelectionModeDrawables_actionModePasteDrawable, 0)).setAlphabeticShortcut('v').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT);
    }
    styledAttributes.recycle();
    if (mCustomSelectionActionModeCallback != null) {
        if (!mCustomSelectionActionModeCallback.onCreateActionMode(mode, menu)) {
            // The custom mode can choose to cancel the action mode
            return false;
        }
    }
    if (menu.hasVisibleItems() || mode.getCustomView() != null) {
        getSelectionController().show();
        return true;
    } else {
        return false;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",0,The implementation code has multiple changes in terms of obtaining resources and setting menu items properties:,- The setTitle method call on mode now conditionally sets the title or null based on allowText.
129,<android.animation.PropertyValuesHolder: void setupSetterAndGetter(Object)>,13,14,,,,"{
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}","{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.e(""PropertyValuesHolder"", ""No such property ("" + mProperty.getName() + "") on target object "" + target + "". Trying reflection instead"");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            } catch (IllegalAccessException e) {
                Log.e(""PropertyValuesHolder"", e.toString());
            }
        }
    }
}",1,"/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
","/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */
",0,,,0,,,,,,,"3,4",0,"The late implementation introduces new control flow with an initial check for `mProperty` and handling of `ClassCastException`. The keyframes loop is now only reached if `mProperty` is not set successfully. Additionally, a new return statement is added for early termination if `mProperty.get(target)` is successful and does not throw an exception. This change involves control dependency and other statements addition. Hence, the type of code change is 3,4.","Despite the additional check for `mProperty`, if `mProperty` is null or a `ClassCastException` occurs, the functionality reverts to the same logic as the early version by setting up a setter and a getter. This preserves the original behavior for cases where `mProperty` cannot be used directly. Consequently, there should be no Compatibility Issue since the API's behavior remains unaffected for all public use cases, regardless of whether `mProperty` is applicable. Thus, the CI is 0."
130,<android.provider.ContactsContract.RawContacts.EntityIteratorImpl: Entity getEntityAndIncrementCursor(Cursor)>,13,14,,,,"{
    final int columnRawContactId = cursor.getColumnIndexOrThrow(RawContacts._ID);
    final long rawContactId = cursor.getLong(columnRawContactId);
    // we expect the cursor is already at the row we need to read from
    ContentValues cv = new ContentValues();
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, _ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, VERSION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SOURCE_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC4);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, CONTACT_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, STARRED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, IS_RESTRICTED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, NAME_VERIFIED);
    android.content.Entity contact = new android.content.Entity(cv);
    // read data rows until the contact id changes
    do {
        if (rawContactId != cursor.getLong(columnRawContactId)) {
            break;
        }
        // add the data to to the contact
        cv = new ContentValues();
        cv.put(Data._ID, cursor.getLong(cursor.getColumnIndexOrThrow(Entity.DATA_ID)));
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.RES_PACKAGE);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.MIMETYPE);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_SUPER_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CommonDataKinds.GroupMembership.GROUP_SOURCE_ID);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        for (String key : DATA_KEYS) {
            final int columnIndex = cursor.getColumnIndexOrThrow(key);
            switch(cursor.getType(columnIndex)) {
                case Cursor.FIELD_TYPE_NULL:
                    // don't put anything
                    break;
                case Cursor.FIELD_TYPE_INTEGER:
                case Cursor.FIELD_TYPE_FLOAT:
                case Cursor.FIELD_TYPE_STRING:
                    cv.put(key, cursor.getString(columnIndex));
                    break;
                case Cursor.FIELD_TYPE_BLOB:
                    cv.put(key, cursor.getBlob(columnIndex));
                    break;
                default:
                    throw new IllegalStateException(""Invalid or unhandled data type"");
            }
        }
        contact.addSubValue(ContactsContract.Data.CONTENT_URI, cv);
    } while (cursor.moveToNext());
    return contact;
}","{
    final int columnRawContactId = cursor.getColumnIndexOrThrow(RawContacts._ID);
    final long rawContactId = cursor.getLong(columnRawContactId);
    // we expect the cursor is already at the row we need to read from
    ContentValues cv = new ContentValues();
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_NAME);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, ACCOUNT_TYPE);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, DATA_SET);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, _ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DIRTY);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, VERSION);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SOURCE_ID);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC1);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC2);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC3);
    DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, SYNC4);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, DELETED);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, CONTACT_ID);
    DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, STARRED);
    DatabaseUtils.cursorIntToContentValuesIfPresent(cursor, cv, NAME_VERIFIED);
    android.content.Entity contact = new android.content.Entity(cv);
    // read data rows until the contact id changes
    do {
        if (rawContactId != cursor.getLong(columnRawContactId)) {
            break;
        }
        // add the data to to the contact
        cv = new ContentValues();
        cv.put(Data._ID, cursor.getLong(cursor.getColumnIndexOrThrow(Entity.DATA_ID)));
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.RES_PACKAGE);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.MIMETYPE);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.IS_SUPER_PRIMARY);
        DatabaseUtils.cursorLongToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, CommonDataKinds.GroupMembership.GROUP_SOURCE_ID);
        DatabaseUtils.cursorStringToContentValuesIfPresent(cursor, cv, Data.DATA_VERSION);
        for (String key : DATA_KEYS) {
            final int columnIndex = cursor.getColumnIndexOrThrow(key);
            switch(cursor.getType(columnIndex)) {
                case Cursor.FIELD_TYPE_NULL:
                    // don't put anything
                    break;
                case Cursor.FIELD_TYPE_INTEGER:
                case Cursor.FIELD_TYPE_FLOAT:
                case Cursor.FIELD_TYPE_STRING:
                    cv.put(key, cursor.getString(columnIndex));
                    break;
                case Cursor.FIELD_TYPE_BLOB:
                    cv.put(key, cursor.getBlob(columnIndex));
                    break;
                default:
                    throw new IllegalStateException(""Invalid or unhandled data type"");
            }
        }
        contact.addSubValue(ContactsContract.Data.CONTENT_URI, cv);
    } while (cursor.moveToNext());
    return contact;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
131,<android.view.accessibility.AccessibilityEvent: void recycle()>,13,14,,,,"{
    if (mIsInPool) {
        return;
    }
    clear();
    synchronized (mPoolLock) {
        if (sPoolSize <= MAX_POOL_SIZE) {
            mNext = sPool;
            sPool = this;
            mIsInPool = true;
            sPoolSize++;
        }
    }
}","{
    if (mIsInPool) {
        throw new IllegalStateException(""Event already recycled!"");
    }
    clear();
    synchronized (sPoolLock) {
        if (sPoolSize <= MAX_POOL_SIZE) {
            mNext = sPool;
            sPool = this;
            mIsInPool = true;
            sPoolSize++;
        }
    }
}",1,"/**
 * Return an instance back to be reused.
 * <p>
 * <b>Note: You must not touch the object after calling this function.</b>
 */
","/**
 * Recycles an instance back to be reused.
 * <p>
 * <b>Note: You must not touch the object after calling this function.</b>
 * </p>
 *
 * @throws IllegalStateException If the event is already recycled.
 */
",1,,[@Override],1,,,,,,,2,2,"The early version of the method returns silently if 'mIsInPool' is true, while the late version throws an IllegalStateException, so the code change type is 2.","The change introduces a new exception throwing behavior when 'mIsInPool' is true. This represents a compatibility issue due to a potential different exception being thrown, so the CI type is 2."
132,<android.animation.PropertyValuesHolder: void setAnimatedValue(Object)>,13,14,,,,"{
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = getAnimatedValue();
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}","{
    if (mProperty != null) {
        mProperty.set(target, getAnimatedValue());
    }
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = getAnimatedValue();
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}",1,"/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
","/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
",0,,,0,,,,,,,"3,4",0,"The control dependency has changed by adding the check `if (mProperty != null)` and a corresponding action `mProperty.set(target, getAnimatedValue());`, which is an addition of other statements (mProperty.set()). Hence, the code change is 3 for the control dependency change and 4 for the additional statements.","There are no Compatibility Issues in terms of return values or thrown exceptions because: 1) there are no return statements in this method, and 2) there are no changes to the exception handling code. The method's behavior has been extended to set the property using `mProperty` when it is not null, but this does not affect the existing method's contract or its exception behavior."
134,<android.database.AbstractCursor: int getColumnIndex(String)>,13,14,,,,"{
    // Hack according to bug 903852
    final int periodIndex = columnName.lastIndexOf('.');
    if (periodIndex != -1) {
        Exception e = new Exception();
        Log.e(TAG, ""requesting column name with table name -- "" + columnName, e);
        columnName = columnName.substring(periodIndex + 1);
    }
    String[] columnNames = getColumnNames();
    int length = columnNames.length;
    for (int i = 0; i < length; i++) {
        if (columnNames[i].equalsIgnoreCase(columnName)) {
            return i;
        }
    }
    if (Config.LOGV) {
        if (getCount() > 0) {
            Log.w(""AbstractCursor"", ""Unknown column "" + columnName);
        }
    }
    return -1;
}","{
    // Hack according to bug 903852
    final int periodIndex = columnName.lastIndexOf('.');
    if (periodIndex != -1) {
        Exception e = new Exception();
        Log.e(TAG, ""requesting column name with table name -- "" + columnName, e);
        columnName = columnName.substring(periodIndex + 1);
    }
    String[] columnNames = getColumnNames();
    int length = columnNames.length;
    for (int i = 0; i < length; i++) {
        if (columnNames[i].equalsIgnoreCase(columnName)) {
            return i;
        }
    }
    if (false) {
        if (getCount() > 0) {
            Log.w(""AbstractCursor"", ""Unknown column "" + columnName);
        }
    }
    return -1;
}",1,,,0,,,0,,,,,,,4,0,"The only change in the code is the conditional statement in the logging block. It changed from 'Config.LOGV' to 'false', which makes the block inert. This is an 'Other statement changed' since it's not related to return statements, exception handling, control dependency, or dependent APIs.",There's no Compatibility Issue because the change doesn't affect the returned value or the exception handling flow of the method. The logging part was for debugging purposes and changing the condition to 'false' effectively removes the logging in the late version but doesn't alter the behavior of the API as perceived by the user.
135,<android.widget.TimePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    int flags = DateUtils.FORMAT_SHOW_TIME;
    if (mIs24HourView) {
        flags |= DateUtils.FORMAT_24HOUR;
    } else {
        flags |= DateUtils.FORMAT_12HOUR;
    }
    mTempCalendar.set(Calendar.HOUR_OF_DAY, getCurrentHour());
    mTempCalendar.set(Calendar.MINUTE, getCurrentMinute());
    String selectedDateUtterance = DateUtils.formatDateTime(mContext, mTempCalendar.getTimeInMillis(), flags);
    event.getText().add(selectedDateUtterance);
    return true;
}","{
    onPopulateAccessibilityEvent(event);
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4,5",1,"The late implementation has completely changed, replacing the block of functional code with a single call to `onPopulateAccessibilityEvent(event)`. This indicates a significant change in the method's body (4) and the use of a different method (5). Also, since the return value 'true' remains constant across changes, the specific change category affected is the return statement (1).","While the return value remains the same ('true'), the behavior that populates the AccessibilityEvent has changed because it now relies on the different method `onPopulateAccessibilityEvent(event)`. This new method could potentially populate the event with different text or perform different actions compared to the inline code in the early version. This means that the API may return the same value (`true`) but with a different state of the `event` object, causing a Compatibility Issue due to potential different return values or types; hence the CI type is 1."
136,<android.widget.TextView: void setEnabled(boolean)>,13,14,,,,"{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
}","{
    if (enabled == isEnabled()) {
        return;
    }
    if (!enabled) {
        // Hide the soft input if the currently active TextView is disabled
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(this)) {
            imm.hideSoftInputFromWindow(getWindowToken(), 0);
        }
    }
    super.setEnabled(enabled);
    prepareCursorControllers();
    if (enabled) {
        // Make sure IME is updated with current editor info.
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.restartInput(this);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The late version contains new calls after the super.setEnabled(enabled) statement: prepareCursorControllers() and a conditional block to restart the input method manager if enabled. Since these statements are not changing the return type or handling of exceptions, the change type is 4 (Other statement changed).","This change is not causing a different return value or type, and also not introducing a change in exception handling; Therefore, there is no Compatibility Issue, which corresponds to 0 (No Compatibility Issue)."
137,<android.widget.TabWidget: int getTabCount()>,13,14,,,,"{
    int children = getChildCount();
    // this: 1, 2, 3, ...
    if (mDividerDrawable != null) {
        children = (children + 1) / 2;
    }
    return children;
}","{
    return getChildCount();
}",1,"/**
 * Returns the number of tab indicator views.
 * @return the number of tab indicator views.
 */
","/**
 * Returns the number of tab indicator views.
 * @return the number of tab indicator views.
 */
",0,,,0,,,,,,,"1,4",1,"The implementation of the method has been simplified, removing the conditional check for `mDividerDrawable` and the adjustment of the children count based on it. Now it just returns the result of `getChildCount()` directly. The removed if condition and the related arithmetic operation on 'children' constitute an other statement change (4) and since the return statement is simplified, it counts as a return statement change (1).","The removal of the conditional check and related arithmetic operation potentially leads to the API returning a different value than before. Previously if `mDividerDrawable` was not null, `children` might have been halved which would not be the case anymore. Hence, there is a compatibility issue because of the potentially different return values (1)."
138,"<android.view.GLES20Canvas: void drawBitmapMesh(Bitmap,int,int,float[],int,int[],int,Paint)>",13,14,,,,"{
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    // TODO: Colors are ignored for now
    colors = null;
    colorOffset = 0;
    boolean hasColorFilter = paint != null && setupColorFilter(paint);
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    if (hasColorFilter)
        nResetModifiers(mRenderer);
}","{
    if (meshWidth < 0 || meshHeight < 0 || vertOffset < 0 || colorOffset < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    final int count = (meshWidth + 1) * (meshHeight + 1);
    checkRange(verts.length, vertOffset, count * 2);
    // TODO: Colors are ignored for now
    colors = null;
    colorOffset = 0;
    int modifiers = paint != null ? setupModifiers(bitmap, paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    nDrawBitmapMesh(mRenderer, bitmap.mNativeBitmap, bitmap.mBuffer, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, nativePaint);
    if (modifiers != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifiers);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The variable 'hasColorFilter' has been replaced with 'modifiers' and the conditional check for resetting modifiers has changed from 'if (hasColorFilter)' to 'if (modifiers != MODIFIER_NONE)'. Since 'hasColorFilter' always results from 'paint' being non-null and 'setupColorFilter(paint)', whereas 'modifiers' is set directly by 'setupModifiers(bitmap, paint)', these are different statements that are not about return or exception handling. Therefore, the code change type is 4, which denotes ""Other statement changed"".","There is no compatibility issue since the logic for setting up and resetting modifiers is internal to the method and does not affect the method's return type or the exceptions thrown. Even though the logic has changed, the method still performs the same overall function (drawing a bitmap mesh) and does not change in terms of external behavior that would affect API consumers. Thus, the compatibility issue type is 0 (No Compatibility Issue)."
139,<android.widget.Gallery: void trackMotionScroll(int)>,13,14,,,,"{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    invalidate();
}","{
    if (getChildCount() == 0) {
        return;
    }
    boolean toLeft = deltaX < 0;
    int limitedDeltaX = getLimitedMotionScrollAmount(toLeft, deltaX);
    if (limitedDeltaX != deltaX) {
        // The above call returned a limited amount, so stop any scrolls/flings
        mFlingRunnable.endFling(false);
        onFinishedMovement();
    }
    offsetChildrenLeftAndRight(limitedDeltaX);
    detachOffScreenChildren(toLeft);
    if (toLeft) {
        // If moved left, there will be empty space on the right
        fillToGalleryRight();
    } else {
        // Similarly, empty space on the left
        fillToGalleryLeft();
    }
    // Clear unused views
    mRecycler.clear();
    setSelectionToCenterChild();
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
    invalidate();
}",1,"/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
","/**
 * Tracks a motion scroll. In reality, this is used to do just about any
 * movement to items (touch scroll, arrow-key scroll, set an item as selected).
 *
 * @param deltaX Change in X from the previous event.
 */
",0,,,0,,,,,,,4,0,"The only change is the addition of a new method call onScrollChanged(0, 0, 0, 0) before invalidate(), which belongs to the type of other statement change (4).","As the added method call onScrollChanged(0, 0, 0, 0) is specified as a dummy operation with a comment indicating that View's implementation does not actually use these values, this change should not alter the behavior that would affect the clients in a way that would cause a compatibility issue. Thus, there is no compatibility issue (0)."
142,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofInt(String,int)>",13,14,,,,"{
    PropertyValuesHolder pvh = new IntPropertyValuesHolder(propertyName, values);
    return pvh;
}","{
    return new IntPropertyValuesHolder(propertyName, values);
}",1,"/**
 * Constructs and returns a PropertyValuesHolder with a given property name and
 * set of int values.
 * @param propertyName The name of the property being animated.
 * @param values The values that the named property will animate between.
 * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
 */
","/**
 * Constructs and returns a PropertyValuesHolder with a given property name and
 * set of int values.
 * @param propertyName The name of the property being animated.
 * @param values The values that the named property will animate between.
 * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
 */
",0,,,0,,,,,,,4,0,"The variable assignment to the local variable 'pvh' has been removed and the return statement has been streamlined to return the object directly, so the code change type is 4 (Other statement changed).",There is no Compatibility Issue present because the outcome of executing the method is the same: it returns an `IntPropertyValuesHolder` object instantiated with the same parameters. The internal simplification of code does not affect the method's external behavior.
145,<android.view.WindowOrientationListener.SensorEventListenerImpl: void onSensorChanged(SensorEvent)>,13,14,,,,"{
    final boolean log = mOrientationListener.mLogEnabled;
    // The vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  I'll call this up vector elsewhere.
    float x = event.values[ACCELEROMETER_DATA_X];
    float y = event.values[ACCELEROMETER_DATA_Y];
    float z = event.values[ACCELEROMETER_DATA_Z];
    if (log) {
        Slog.v(TAG, ""Raw acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
    }
    // Apply a low-pass filter to the acceleration up vector in cartesian space.
    // Reset the orientation listener state if the samples are too far apart in time
    // or when we see values of (0, 0, 0) which indicates that we polled the
    // accelerometer too soon after turning it on and we don't have any data yet.
    final float timeDeltaMS = (event.timestamp - mLastTimestamp) * 0.000001f;
    boolean skipSample;
    if (timeDeltaMS <= 0 || timeDeltaMS > MAX_FILTER_DELTA_TIME_MS || (x == 0 && y == 0 && z == 0)) {
        if (log) {
            Slog.v(TAG, ""Resetting orientation listener."");
        }
        for (int i = 0; i < 4; i++) {
            mConfidence[i] = 0;
        }
        skipSample = true;
    } else {
        final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS) * FILTER_GAIN;
        x = alpha * (x - mLastFilteredX) + mLastFilteredX;
        y = alpha * (y - mLastFilteredY) + mLastFilteredY;
        z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
        if (log) {
            Slog.v(TAG, ""Filtered acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
        }
        skipSample = false;
    }
    mLastTimestamp = event.timestamp;
    mLastFilteredX = x;
    mLastFilteredY = y;
    mLastFilteredZ = z;
    boolean orientationChanged = false;
    if (!skipSample) {
        // Determine a proposed orientation based on the currently available data.
        int proposedOrientation = ROTATION_UNKNOWN;
        float combinedConfidence = 1.0f;
        // Calculate the magnitude of the acceleration vector.
        final float magnitude = (float) Math.sqrt(x * x + y * y + z * z);
        if (magnitude < MIN_ACCELERATION_MAGNITUDE || magnitude > MAX_ACCELERATION_MAGNITUDE) {
            if (log) {
                Slog.v(TAG, ""Ignoring sensor data, magnitude out of range: "" + ""magnitude="" + magnitude);
            }
        } else {
            // Calculate the tilt angle.
            // This is the angle between the up vector and the x-y plane (the plane of
            // the screen) in a range of [-90, 90] degrees.
            // -90 degrees: screen horizontal and facing the ground (overhead)
            // 0 degrees: screen vertical
            // 90 degrees: screen horizontal and facing the sky (on table)
            final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
            // the orientation angle of the screen.
            if (Math.abs(tiltAngle) > MAX_TILT) {
                if (log) {
                    Slog.v(TAG, ""Ignoring sensor data, tilt angle too high: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle);
                }
            } else {
                // Calculate the orientation angle.
                // This is the angle between the x-y projection of the up vector onto
                // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                if (orientationAngle < 0) {
                    // atan2 returns [-180, 180]; normalize to [0, 360]
                    orientationAngle += 360;
                }
                // Find the nearest orientation.
                // An orientation of 0 can have a nearest angle of 0 or 360 depending
                // on which is closer to the measured orientation angle.  We leave the
                // nearest angle at 360 in that case since it makes the delta calculation
                // for orientation angle confidence easier below.
                int nearestOrientation = (orientationAngle + 45) / 90;
                int nearestOrientationAngle = nearestOrientation * 90;
                if (nearestOrientation == 4) {
                    nearestOrientation = 0;
                }
                // angle, tilt and magnitude of the proposed orientation.
                if (isTiltAngleAcceptable(nearestOrientation, tiltAngle) && isOrientationAngleAcceptable(nearestOrientation, orientationAngle)) {
                    proposedOrientation = nearestOrientation;
                    final float idealOrientationAngle = nearestOrientationAngle;
                    final float orientationConfidence = confidence(orientationAngle, idealOrientationAngle, ORIENTATION_ANGLE_CONFIDENCE_SCALE);
                    final float idealTiltAngle = 0;
                    final float tiltConfidence = confidence(tiltAngle, idealTiltAngle, TILT_ANGLE_CONFIDENCE_SCALE);
                    final float idealMagnitude = SensorManager.STANDARD_GRAVITY;
                    final float magnitudeConfidence = confidence(magnitude, idealMagnitude, MAGNITUDE_CONFIDENCE_SCALE);
                    combinedConfidence = orientationConfidence * tiltConfidence * magnitudeConfidence;
                    if (log) {
                        Slog.v(TAG, ""Proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle + "", proposedOrientation="" + proposedOrientation + "", combinedConfidence="" + combinedConfidence + "", orientationConfidence="" + orientationConfidence + "", tiltConfidence="" + tiltConfidence + "", magnitudeConfidence="" + magnitudeConfidence);
                    }
                } else {
                    if (log) {
                        Slog.v(TAG, ""Ignoring sensor data, no proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle);
                    }
                }
            }
        }
        // Sum up the orientation confidence weights.
        // Detect an orientation change when the sum reaches 1.0.
        final float confidenceAmount = combinedConfidence * timeDeltaMS / ORIENTATION_SETTLE_TIME_MS;
        for (int i = 0; i < 4; i++) {
            if (i == proposedOrientation) {
                mConfidence[i] += confidenceAmount;
                if (mConfidence[i] >= 1.0f) {
                    mConfidence[i] = 1.0f;
                    if (i != mRotation) {
                        if (log) {
                            Slog.v(TAG, ""Orientation changed!  rotation="" + i);
                        }
                        mRotation = i;
                        orientationChanged = true;
                    }
                }
            } else {
                mConfidence[i] -= confidenceAmount;
                if (mConfidence[i] < 0.0f) {
                    mConfidence[i] = 0.0f;
                }
            }
        }
    }
    // Write final statistics about where we are in the orientation detection process.
    if (log) {
        Slog.v(TAG, ""Result: rotation="" + mRotation + "", confidence=["" + mConfidence[0] + "", "" + mConfidence[1] + "", "" + mConfidence[2] + "", "" + mConfidence[3] + ""], timeDeltaMS="" + timeDeltaMS);
    }
    // Tell the listener.
    if (orientationChanged) {
        mOrientationListener.onOrientationChanged(mRotation);
    }
}","{
    final boolean log = mOrientationListener.mLogEnabled;
    // The vector given in the SensorEvent points straight up (towards the sky) under ideal
    // conditions (the phone is not accelerating).  I'll call this up vector elsewhere.
    float x = event.values[ACCELEROMETER_DATA_X];
    float y = event.values[ACCELEROMETER_DATA_Y];
    float z = event.values[ACCELEROMETER_DATA_Z];
    if (log) {
        Slog.v(TAG, ""Raw acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
    }
    // Apply a low-pass filter to the acceleration up vector in cartesian space.
    // Reset the orientation listener state if the samples are too far apart in time
    // or when we see values of (0, 0, 0) which indicates that we polled the
    // accelerometer too soon after turning it on and we don't have any data yet.
    final long now = event.timestamp;
    final float timeDeltaMS = (now - mLastTimestamp) * 0.000001f;
    boolean skipSample;
    if (timeDeltaMS <= 0 || timeDeltaMS > MAX_FILTER_DELTA_TIME_MS || (x == 0 && y == 0 && z == 0)) {
        if (log) {
            Slog.v(TAG, ""Resetting orientation listener."");
        }
        clearProposal();
        skipSample = true;
    } else {
        final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
        x = alpha * (x - mLastFilteredX) + mLastFilteredX;
        y = alpha * (y - mLastFilteredY) + mLastFilteredY;
        z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
        if (log) {
            Slog.v(TAG, ""Filtered acceleration vector: "" + ""x="" + x + "", y="" + y + "", z="" + z);
        }
        skipSample = false;
    }
    mLastTimestamp = now;
    mLastFilteredX = x;
    mLastFilteredY = y;
    mLastFilteredZ = z;
    final int oldProposedRotation = getProposedRotation();
    if (!skipSample) {
        // Calculate the magnitude of the acceleration vector.
        final float magnitude = (float) Math.sqrt(x * x + y * y + z * z);
        if (magnitude < MIN_ACCELERATION_MAGNITUDE || magnitude > MAX_ACCELERATION_MAGNITUDE) {
            if (log) {
                Slog.v(TAG, ""Ignoring sensor data, magnitude out of range: "" + ""magnitude="" + magnitude);
            }
            clearProposal();
        } else {
            // Calculate the tilt angle.
            // This is the angle between the up vector and the x-y plane (the plane of
            // the screen) in a range of [-90, 90] degrees.
            // -90 degrees: screen horizontal and facing the ground (overhead)
            // 0 degrees: screen vertical
            // 90 degrees: screen horizontal and facing the sky (on table)
            final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
            // the orientation angle of the screen.
            if (Math.abs(tiltAngle) > MAX_TILT) {
                if (log) {
                    Slog.v(TAG, ""Ignoring sensor data, tilt angle too high: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle);
                }
                clearProposal();
            } else {
                // Calculate the orientation angle.
                // This is the angle between the x-y projection of the up vector onto
                // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                if (orientationAngle < 0) {
                    // atan2 returns [-180, 180]; normalize to [0, 360]
                    orientationAngle += 360;
                }
                // Find the nearest rotation.
                int nearestRotation = (orientationAngle + 45) / 90;
                if (nearestRotation == 4) {
                    nearestRotation = 0;
                }
                // angle, tilt and magnitude of the proposed orientation.
                if (!isTiltAngleAcceptable(nearestRotation, tiltAngle) || !isOrientationAngleAcceptable(nearestRotation, orientationAngle)) {
                    if (log) {
                        Slog.v(TAG, ""Ignoring sensor data, no proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle);
                    }
                    clearProposal();
                } else {
                    if (log) {
                        Slog.v(TAG, ""Proposal: "" + ""magnitude="" + magnitude + "", tiltAngle="" + tiltAngle + "", orientationAngle="" + orientationAngle + "", proposalRotation="" + mProposalRotation);
                    }
                    updateProposal(nearestRotation, now / 1000000L, magnitude, tiltAngle, orientationAngle);
                }
            }
        }
    }
    // Write final statistics about where we are in the orientation detection process.
    final int proposedRotation = getProposedRotation();
    if (log) {
        final float proposalConfidence = Math.min(mProposalAgeMS * 1.0f / SETTLE_TIME_MS, 1.0f);
        Slog.v(TAG, ""Result: currentRotation="" + mOrientationListener.mCurrentRotation + "", proposedRotation="" + proposedRotation + "", timeDeltaMS="" + timeDeltaMS + "", proposalRotation="" + mProposalRotation + "", proposalAgeMS="" + mProposalAgeMS + "", proposalConfidence="" + proposalConfidence);
    }
    // Tell the listener.
    if (proposedRotation != oldProposedRotation && proposedRotation >= 0) {
        if (log) {
            Slog.v(TAG, ""Proposed rotation changed!  proposedRotation="" + proposedRotation + "", oldProposedRotation="" + oldProposedRotation);
        }
        mOrientationListener.onProposedRotationChanged(proposedRotation);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
146,<android.database.BulkCursorProxy: void close()>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    mRemote.transact(CLOSE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    data.recycle();
    reply.recycle();
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        mRemote.transact(CLOSE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,3,0,"The late version added a try-finally block around the existing code, but the functional behavior of the code has not changed, so the code change type is 3.","The try-finally block ensures that 'data.recycle()' and 'reply.recycle()' are called in case an exception occurs, but since the method is 'void' and does not return any value or throw a new or different exception, the behavior remains the same. Thus, there is no compatibility issue, so the CI type is 0."
147,"<android.view.View: void postInvalidateDelayed(long,int,int,int,int)>",13,14,,,,"{
    // if we are not attached to our window
    if (mAttachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        final Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_RECT_MSG;
        msg.obj = info;
        mAttachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.acquire();
        info.target = this;
        info.left = left;
        info.top = top;
        info.right = right;
        info.bottom = bottom;
        final Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_RECT_MSG;
        msg.obj = info;
        attachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}",1,"/**
 * Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 */
","/**
 * <p>Cause an invalidate of the specified area to happen on a subsequent cycle
 * through the event loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 * @param left The left coordinate of the rectangle to invalidate.
 * @param top The top coordinate of the rectangle to invalidate.
 * @param right The right coordinate of the rectangle to invalidate.
 * @param bottom The bottom coordinate of the rectangle to invalidate.
 */
",1,,,0,,,,,,,4,0,"The only change in the implementation is the creation of a local variable `attachInfo` which references `mAttachInfo` before the conditional check, so the code change type is 4.","No Compatibility Issue arises in this change because the modification does not affect the behavior of the method; it is simply a local variable assignment for clarity, with no change in functionality or in the API contract."
148,<android.webkit.WebView: Bitmap getFavicon()>,13,14,,,,"{
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getFavicon() : null;
}","{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getFavicon() : null;
}",1,"/**
 * Get the favicon for the current page. This is the favicon of the current
 * page until WebViewClient.onReceivedIcon is called.
 * @return The favicon for the current page.
 */
","/**
 * Get the favicon for the current page. This is the favicon of the current
 * page until WebViewClient.onReceivedIcon is called.
 * @return The favicon for the current page.
 */
",0,,,0,,,,,,,4,0,"The change consists of the addition of a method call (checkThread()) at the start of the method body, which does not impact the return value or exception handling, so the code change type is 4.","Since the addition of checkThread() does not affect the return value or the exceptions that might be thrown by the method, no compatibility issue should arise from this change. The CI type is 0."
149,<android.widget.ListPopupWindow: int getVerticalOffset()>,13,14,,,,"{
    return mDropDownVerticalOffset;
}","{
    if (!mDropDownVerticalOffsetSet) {
        return 0;
    }
    return mDropDownVerticalOffset;
}",1,"/**
 * @return The vertical offset of the popup from its anchor in pixels.
 */
","/**
 * @return The vertical offset of the popup from its anchor in pixels.
 */
",0,,,0,,,,,,,3,1,"The control dependency 'if' is added in the late implementation to check whether mDropDownVerticalOffsetSet is true before returning mDropDownVerticalOffset, so the code change type is 3.","Since the late version contains new logic that potentially returns a different value based on the condition of mDropDownVerticalOffsetSet, the late version may return 0 instead of the value of mDropDownVerticalOffset under some circumstances. This change introduces a Compatibility Issue of type 1 due to potentially different return values."
150,"<android.provider.ContactsContract.Contacts: InputStream openContactPhotoInputStream(ContentResolver,Uri)>",13,14,,,,"{
    Uri photoUri = Uri.withAppendedPath(contactUri, Photo.CONTENT_DIRECTORY);
    if (photoUri == null) {
        return null;
    }
    Cursor cursor = cr.query(photoUri, new String[] { ContactsContract.CommonDataKinds.Photo.PHOTO }, null, null, null);
    try {
        if (cursor == null || !cursor.moveToNext()) {
            return null;
        }
        byte[] data = cursor.getBlob(0);
        if (data == null) {
            return null;
        }
        return new ByteArrayInputStream(data);
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
}","{
    return openContactPhotoInputStream(cr, contactUri, false);
}",1,"/**
 * Opens an InputStream for the contacts's default photo and returns the
 * photo as a byte stream. If there is not photo null will be returned.
 *
 * @param contactUri the contact whose photo should be used. This can be used with
 * either a {@link #CONTENT_URI} or a {@link #CONTENT_LOOKUP_URI} URI.
 * </p>
 *
 * @return an InputStream of the photo, or null if no photo is present
 */
","/**
 * Opens an InputStream for the contacts's thumbnail photo and returns the
 * photo as a byte stream.
 * @param cr The content resolver to use for querying
 * @param contactUri the contact whose photo should be used. This can be used with
 * either a {@link #CONTENT_URI} or a {@link #CONTENT_LOOKUP_URI} URI.
 * @return an InputStream of the photo, or null if no photo is present
 * @see #openContactPhotoInputStream(ContentResolver, Uri, boolean), if instead
 * of the thumbnail the high-res picture is preferred
 */
",1,,,0,,,,,,,"1,5",1,"The late version of the method is calling another method (overload of openContactPhotoInputStream) instead of implementing the logic inline. Hence, the change type includes 1 for the return statement and 5 for the dependent API change.","The implementation is changed to return the result of a different method call, which might have a different behavior from the original inline implementation, leading to potential differences in the data returned by the API. Therefore, the CI type is 1 due to the code potentially returning a different result."
151,<android.app.Activity: void finish()>,13,14,,,,"{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (Config.LOGV)
            Log.v(TAG, ""Finishing self: token="" + mToken);
        try {
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}","{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, ""Finishing self: token="" + mToken);
        try {
            if (resultData != null) {
                resultData.setAllowFds(false);
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}",1,"/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
","/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */
",0,,,0,,,,,,,"3,4",0,"There is a modification in a logging condition, changing from checking Config.LOGV to always evaluating as false, thus this control dependency has changed. Additionally, there is a new statement added that calls resultData.setAllowFds(false), which is an other statement change. Therefore, the changes involve code change types 3 and 4.","There is no Compatibility Issue, as the changes do not affect the method's behavior from an external point of view. The change to the logging condition will only disable the logging and will not affect the method's logic or outcome. The call to resultData.setAllowFds(false) might change internal properties of the Intent, but this does not constitute a different return value or type, nor does it introduce different exception handlings from the method's perspective. Hence, the CI type is 0."
152,<android.database.AbstractCursor: Bundle getExtras()>,13,14,,,,"{
    return Bundle.EMPTY;
}","{
    return mExtras;
}",1,,,0,,,0,,,,,,,1,1,"The return statement has been changed from returning a constant (Bundle.EMPTY) to returning a member variable (mExtras), so the change type is 1.","The change in the return statement from a constant to a member variable means the API could potentially return different values between the two versions, so the CI type is 1."
154,<android.database.sqlite.SQLiteStatement: long executeInsert()>,13,14,,,,"{
    try {
        long timeStart = acquireAndLock(WRITE);
        long lastInsertedRowId = native_executeInsert();
        mDatabase.logTimeStat(mSql, timeStart);
        return lastInsertedRowId;
    } finally {
        releaseAndUnlock();
    }
}","{
    try {
        saveSqlAsLastSqlStatement();
        acquireAndLock(WRITE);
        return native_executeInsert();
    } finally {
        releaseAndUnlock();
    }
}",1,"/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement and return the ID of the row inserted due to this call.
 * The SQL statement should be an INSERT for this to be a useful call.
 *
 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
 *
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",0,,,0,,,,,,,"3,4",0,There are multiple changes in the late implementation compared to the early one:,- The variable `timeStart` used for logging statement timing is removed.
155,<android.os.Handler: String toString()>,13,14,,,,"{
    return ""Handler{"" + Integer.toHexString(System.identityHashCode(this)) + ""}"";
}","{
    return ""Handler ("" + getClass().getName() + "") {"" + Integer.toHexString(System.identityHashCode(this)) + ""}"";
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change is the addition of some more text to the string returned by `toString()`. This does not affect the efficiency of the API, but rather the string that gets generated, so the change type is 4.","There isn't a Compatibility Issue as the API functionality remains the same though the output string has changed. While the content of the string returned by `toString()` is different, this does not represent a functional change in terms of the application logic. Hence, it will not cause a compatibility issue as it does not affect program execution."
157,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: void onDestroy(Intent)>,13,14,,,,"{
    synchronized (sLock) {
        Intent.FilterComparison fc = new Intent.FilterComparison(intent);
        if (RemoteViewsService.sRemoteViewFactories.containsKey(fc)) {
            RemoteViewsFactory factory = RemoteViewsService.sRemoteViewFactories.get(fc);
            factory.onDestroy();
            RemoteViewsService.sRemoteViewFactories.remove(fc);
        }
    }
}","{
    synchronized (sLock) {
        Intent.FilterComparison fc = new Intent.FilterComparison(intent);
        if (RemoteViewsService.sRemoteViewFactories.containsKey(fc)) {
            RemoteViewsFactory factory = RemoteViewsService.sRemoteViewFactories.get(fc);
            try {
                factory.onDestroy();
            } catch (Exception ex) {
                Thread t = Thread.currentThread();
                Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
            }
            RemoteViewsService.sRemoteViewFactories.remove(fc);
        }
    }
}",1,,,0,,,0,,,,,,,"2,3",2,"The late version adds a try-catch block around the factory.onDestroy() call to catch exceptions, which is different from the early version. Thus, the change types are 2 (Exception handling statement changed) and 3 (Control dependency changed).","Due to the added try-catch block, exceptions that would previously propagate up the call stack will now be caught and managed within the new block. This represents a change in exception handling behavior, and therefore, the CI type is 2 (Compatibility Issue caused by potential different exception handlings)."
158,"<android.widget.TextView: void onFocusChanged(boolean,int,Rect)>",13,14,,,,"{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    mShowCursor = SystemClock.uptimeMillis();
    ensureEndedBatchEdit();
    if (focused) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        // SelectAllOnFocus fields are highlighted and not selected. Do not start text selection
        // mode for these, unless there was a specific selection already started.
        final boolean isFocusHighlighted = mSelectAllOnFocus && selStart == 0 && selEnd == mText.length();
        mCreatedWithASelection = mFrozenWithFocus && hasSelection() && !isFocusHighlighted;
        if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
            // If a tap was used to give focus to that view, move cursor at tap position.
            // Has to be done before onTakeFocus, which can be overloaded.
            final int lastTapPosition = getLastTapPosition();
            if (lastTapPosition >= 0) {
                Selection.setSelection((Spannable) mText, lastTapPosition);
            }
            if (mMovement != null) {
                mMovement.onTakeFocus(this, (Spannable) mText, direction);
            }
            // It would be better to know why the DecorView does not have focus at that time.
            if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
                /*
                     * Someone intentionally set the selection, so let them
                     * do whatever it is that they wanted to do instead of
                     * the default on-focus behavior.  We reset the selection
                     * here instead of just skipping the onTakeFocus() call
                     * because some movement methods do something other than
                     * just setting the selection in theirs and we still
                     * need to go through that path.
                     */
                Selection.setSelection((Spannable) mText, selStart, selEnd);
            }
            if (mSelectAllOnFocus) {
                selectAll();
            }
            mTouchFocusSelected = true;
        }
        mFrozenWithFocus = false;
        mSelectionMoved = false;
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
        makeBlink();
        if (mError != null) {
            showError();
        }
    } else {
        if (mError != null) {
            hideError();
        }
        // Don't leave us in the middle of a batch edit.
        onEndBatchEdit();
        if (this instanceof ExtractEditText) {
            // terminateTextSelectionMode removes selection, which we want to keep when
            // ExtractEditText goes out of focus.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            hideControllers();
            Selection.setSelection((Spannable) mText, selStart, selEnd);
        } else {
            hideControllers();
        }
        // No need to create the controller
        if (mSelectionModifierCursorController != null) {
            mSelectionModifierCursorController.resetTouchOffsets();
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
    // does not happen in that case (using the arrows on a bluetooth keyboard).
    if (focused && isTextEditable()) {
        final InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null)
            imm.showSoftInput(this, 0);
    }
}","{
    if (mTemporaryDetach) {
        // If we are temporarily in the detach state, then do nothing.
        super.onFocusChanged(focused, direction, previouslyFocusedRect);
        return;
    }
    mShowCursor = SystemClock.uptimeMillis();
    ensureEndedBatchEdit();
    if (focused) {
        int selStart = getSelectionStart();
        int selEnd = getSelectionEnd();
        // SelectAllOnFocus fields are highlighted and not selected. Do not start text selection
        // mode for these, unless there was a specific selection already started.
        final boolean isFocusHighlighted = mSelectAllOnFocus && selStart == 0 && selEnd == mText.length();
        mCreatedWithASelection = mFrozenWithFocus && hasSelection() && !isFocusHighlighted;
        if (!mFrozenWithFocus || (selStart < 0 || selEnd < 0)) {
            // If a tap was used to give focus to that view, move cursor at tap position.
            // Has to be done before onTakeFocus, which can be overloaded.
            final int lastTapPosition = getLastTapPosition();
            if (lastTapPosition >= 0) {
                Selection.setSelection((Spannable) mText, lastTapPosition);
            }
            if (mMovement != null) {
                mMovement.onTakeFocus(this, (Spannable) mText, direction);
            }
            // It would be better to know why the DecorView does not have focus at that time.
            if (((this instanceof ExtractEditText) || mSelectionMoved) && selStart >= 0 && selEnd >= 0) {
                /*
                     * Someone intentionally set the selection, so let them
                     * do whatever it is that they wanted to do instead of
                     * the default on-focus behavior.  We reset the selection
                     * here instead of just skipping the onTakeFocus() call
                     * because some movement methods do something other than
                     * just setting the selection in theirs and we still
                     * need to go through that path.
                     */
                Selection.setSelection((Spannable) mText, selStart, selEnd);
            }
            if (mSelectAllOnFocus) {
                selectAll();
            }
            mTouchFocusSelected = true;
        }
        mFrozenWithFocus = false;
        mSelectionMoved = false;
        if (mText instanceof Spannable) {
            Spannable sp = (Spannable) mText;
            MetaKeyKeyListener.resetMetaState(sp);
        }
        makeBlink();
        if (mError != null) {
            showError();
        }
    } else {
        if (mError != null) {
            hideError();
        }
        // Don't leave us in the middle of a batch edit.
        onEndBatchEdit();
        if (this instanceof ExtractEditText) {
            // terminateTextSelectionMode removes selection, which we want to keep when
            // ExtractEditText goes out of focus.
            final int selStart = getSelectionStart();
            final int selEnd = getSelectionEnd();
            hideControllers();
            Selection.setSelection((Spannable) mText, selStart, selEnd);
        } else {
            hideControllers();
            downgradeEasyCorrectionSpans();
        }
        // No need to create the controller
        if (mSelectionModifierCursorController != null) {
            mSelectionModifierCursorController.resetTouchOffsets();
        }
    }
    startStopMarquee(focused);
    if (mTransformation != null) {
        mTransformation.onFocusChanged(this, mText, focused, direction, previouslyFocusedRect);
    }
    super.onFocusChanged(focused, direction, previouslyFocusedRect);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
159,"<android.preference.PreferenceActivity: boolean onPreferenceStartFragment(PreferenceFragment,Preference)>",13,14,,,,"{
    startPreferencePanel(pref.getFragment(), pref.getExtras(), 0, pref.getTitle(), null, 0);
    return true;
}","{
    startPreferencePanel(pref.getFragment(), pref.getExtras(), pref.getTitleRes(), pref.getTitle(), null, 0);
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The change is in the arguments of the method 'startPreferencePanel'. The number of arguments remains the same, but the value of the third argument has changed from a hardcoded '0' to 'pref.getTitleRes()'. This indicates a change in the dependent API (4,5), but no change to the local return statement or exception handling.","Since the return value is hardcoded 'true' and does not depend on the arguments passed to 'startPreferencePanel' method, there is no difference in the return value or type, and there are no changes in exception handling between the versions. Thus, no compatibility issue arises due to the observed changes (0)."
161,"<android.server.BluetoothService: boolean fetchRemoteUuids(String,ParcelUuid,IBluetoothCallback)>",13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    boolean ret;
    // NULL, else create the device and then do SDP.
    if (mDeviceProperties.isInCache(address) && getRemoteUuids(address) != null) {
        String path = getObjectPathFromAddress(address);
        if (path == null)
            return false;
        // Use an empty string for the UUID pattern
        ret = discoverServicesNative(path, """");
    } else {
        ret = createDeviceNative(address);
    }
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return false;
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        return false;
    }
    RemoteService service = new RemoteService(address, uuid);
    if (uuid != null && mUuidCallbackTracker.get(service) != null) {
        // Do not add this callback for the uuid
        return false;
    }
    if (mUuidIntentTracker.contains(address)) {
        // Add this uuid onto the in-progress SDP query
        if (uuid != null) {
            mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
        }
        return true;
    }
    // If the device is already created, we will
    // do the SDP on the callback of createDeviceNative.
    boolean ret = createDeviceNative(address);
    mUuidIntentTracker.add(address);
    if (uuid != null) {
        mUuidCallbackTracker.put(new RemoteService(address, uuid), callback);
    }
    Message message = mHandler.obtainMessage(MESSAGE_UUID_INTENT);
    message.obj = address;
    mHandler.sendMessageDelayed(message, UUID_INTENT_DELAY);
    return ret;
}",1,"/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
","/**
 * Connect and fetch new UUID's using SDP.
 * The UUID's found are broadcast as intents.
 * Optionally takes a uuid and callback to fetch the RFCOMM channel for the
 * a given uuid.
 * TODO: Don't wait UUID_INTENT_DELAY to broadcast UUID intents on success
 * TODO: Don't wait UUID_INTENT_DELAY to handle the failure case for
 * callback and broadcast intents.
 */
",0,,,0,,,,,,,"3,4",1,"The conditional code block for checking if the device properties are in cache and getting remote UUIDs has been removed. Furthermore, there is a change in the statements regarding the use of the createDeviceNative method that has been moved up, which falls under control dependency and other statements changed. Therefore, the code change type is 3,4.","Due to the removal of the check and the usage of discoverServicesNative, the late version of the method may directly call createDeviceNative without checking the cache, resulting in a potential different return behavior. These changes could lead to the API returning different values depending on the cache presence condition interacting with the createDeviceNative method, thus the CI type is 1."
163,"<android.server.BluetoothService: boolean setInputDevicePriority(BluetoothDevice,int)>",13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    return mBluetoothInputProfileHandler.setInputDevicePriority(device, priority);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.setInputDevicePriority(device, priority);
    }
}",1,,,0,,,0,,,,,,,3,0,"The code has been wrapped in a synchronized block without changing the underlying behavior, so the code change type is 3 (Control dependency changed).",Adding a synchronized block does not change the method's behavior or the values it returns or the exceptions it might throw; it only affects the thread-safety of the method. So there's no Compatibility Issue in terms of behavior change; the CI type is 0 (No Compatibility Issue).
164,<android.server.BluetoothPanProfileHandler: boolean connectPanDevice(BluetoothDevice)>,13,14,,,,"{
    String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (DBG)
        Log.d(TAG, ""connect PAN("" + objectPath + "")"");
    if (getPanDeviceConnectionState(device) != BluetoothPan.STATE_DISCONNECTED) {
        errorLog(device + "" already connected to PAN"");
    }
    int connectedCount = 0;
    for (BluetoothDevice panDevice : mPanDevices.keySet()) {
        if (getPanDeviceConnectionState(panDevice) == BluetoothPan.STATE_CONNECTED) {
            connectedCount++;
        }
    }
    if (connectedCount > 8) {
        debugLog(device + "" could not connect to PAN because 8 other devices are"" + ""already connected"");
        return false;
    }
    handlePanDeviceStateChange(device, BluetoothPan.STATE_CONNECTING, BluetoothPan.LOCAL_PANU_ROLE);
    if (mBluetoothService.connectPanDeviceNative(objectPath, ""nap"")) {
        debugLog(""connecting to PAN"");
        return true;
    } else {
        handlePanDeviceStateChange(device, BluetoothPan.STATE_DISCONNECTED, BluetoothPan.LOCAL_PANU_ROLE);
        errorLog(""could not connect to PAN"");
        return false;
    }
}","{
    String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    if (DBG)
        Log.d(TAG, ""connect PAN("" + objectPath + "")"");
    if (getPanDeviceConnectionState(device) != BluetoothPan.STATE_DISCONNECTED) {
        errorLog(device + "" already connected to PAN"");
    }
    int connectedCount = 0;
    for (BluetoothDevice panDevice : mPanDevices.keySet()) {
        if (getPanDeviceConnectionState(panDevice) == BluetoothPan.STATE_CONNECTED) {
            connectedCount++;
        }
    }
    if (connectedCount > 8) {
        debugLog(device + "" could not connect to PAN because 8 other devices are"" + ""already connected"");
        return false;
    }
    // Send interface as null as it is not known
    handlePanDeviceStateChange(device, null, BluetoothPan.STATE_CONNECTING, BluetoothPan.LOCAL_PANU_ROLE);
    if (mBluetoothService.connectPanDeviceNative(objectPath, ""nap"")) {
        debugLog(""connecting to PAN"");
        return true;
    } else {
        handlePanDeviceStateChange(device, null, BluetoothPan.STATE_DISCONNECTED, BluetoothPan.LOCAL_PANU_ROLE);
        errorLog(""could not connect to PAN"");
        return false;
    }
}",1,,,0,,,0,,,,,,,"4,5",0,"The method `handlePanDeviceStateChange` in the late version implementation takes different parameters than the early version. The new parameter 'null' is added in two calls of this method, so the code change type is 4 (Other statement changed) and 5 (Dependent API changed).","The two calls to `handlePanDeviceStateChange` changed by introducing 'null' as a new parameter but the functionality of `connectPanDevice` method is not altered. The calls to `handlePanDeviceStateChange` do not influence the return value or the exception handling of the `connectPanDevice` method. Therefore, there is No Compatibility Issue, which is 0."
165,<android.bluetooth.BluetoothSocket: void connect()>,13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            throw new IOException(""socket closed"");
        if (mSdp != null) {
            // blocks
            mPort = mSdp.doSdp();
        }
        // blocks
        connectNative();
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        if (mSdp != null) {
            // blocks
            mPort = mSdp.doSdp();
        }
        // blocks
        connectNative();
        mSocketState = SocketState.CONNECTED;
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
","/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */
",0,,,0,,,,,,,"3,4",0,"The condition of the 'if' statement has been changed from checking 'mClosed' to 'mSocketState == SocketState.CLOSED' and a new state assignment statement 'mSocketState = SocketState.CONNECTED' was added, so the code change types are 3 and 4.","Considering the condition change and the additional assignment statement, the API might get internally adjusted with how it handles the socket state checking and updates the state after connection. However, these changes do not affect the method's return type or value, nor do they affect the exceptions it may throw. The API still throws the same IOException when the socket is closed, and there is no other change in the control flow that would lead to different behavior externally. Therefore, no compatibility issue is expected to arise from this change, and the CI type is 0."
166,<android.webkit.WebView: int getContentHeight()>,13,14,,,,"{
    return mContentHeight;
}","{
    checkThread();
    return mContentHeight;
}",1,"/**
 * @return the height of the HTML content.
 */
","/**
 * @return the height of the HTML content.
 */
",0,,,0,,,,,,,4,0,"An other statement, ""checkThread();"", has been added before the return statement, so the change type is 4.","The newly added ""checkThread();"" statement does not influence the return value, since it is checking the calling thread and does not modify the value of ""mContentHeight"". Therefore, it does not lead to a CI, and the CI type is 0."
167,<android.app.ActivityThread.Idler: boolean queueIdle()>,13,14,,,,"{
    ActivityClientRecord a = mNewActivities;
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null ? a.activity.mFinished : false));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    ensureJitEnabled();
    return false;
}","{
    ActivityClientRecord a = mNewActivities;
    boolean stopProfiling = false;
    if (mBoundApplication != null && mProfiler.profileFd != null && mProfiler.autoStopProfiler) {
        stopProfiling = true;
    }
    if (a != null) {
        mNewActivities = null;
        IActivityManager am = ActivityManagerNative.getDefault();
        ActivityClientRecord prev;
        do {
            if (localLOGV)
                Slog.v(TAG, ""Reporting idle of "" + a + "" finished="" + (a.activity != null && a.activity.mFinished));
            if (a.activity != null && !a.activity.mFinished) {
                try {
                    am.activityIdle(a.token, a.createdConfig, stopProfiling);
                    a.createdConfig = null;
                } catch (RemoteException ex) {
                // Ignore
                }
            }
            prev = a;
            a = a.nextIdle;
            prev.nextIdle = null;
        } while (a != null);
    }
    if (stopProfiling) {
        mProfiler.stopProfiling();
    }
    ensureJitEnabled();
    return false;
}",1,,,0,,,0,,,,,,,"3,4,5",0,"The changes include the addition of new variable initialization (stopProfiling), control dependency change to include an 'if' condition (checking mProfiler related conditions), and other statements in the implementation (stopProfiling is passed as an argument to am.activityIdle and mProfiler.stopProfiling() is called). The dependent API am.activityIdle also seems to have an additional parameter stopProfiling which suggests the underlying signature for activityIdle might have changed in the IActivityManager interface. Hence, the change types are 3,4,5.","Despite multiple changes, every code path still leads to the return value of 'false', and the handling of RemoteException remains unchanged. As a result, the behavior visible to the caller of queueIdle does not change between the two versions; thus there's no Compatibility Issue."
169,<android.widget.NumberPicker: void setFormatter(Formatter)>,13,14,,,,"{
    if (formatter == mFormatter) {
        return;
    }
    mFormatter = formatter;
    resetSelectorWheelIndices();
    updateInputTextView();
}","{
    if (formatter == mFormatter) {
        return;
    }
    mFormatter = formatter;
    initializeSelectorWheelIndices();
    updateInputTextView();
}",1,"/**
 * Set the formatter to be used for formatting the current value.
 * <p>
 * Note: If you have provided alternative values for the values this
 * formatter is never invoked.
 * </p>
 *
 * @param formatter The formatter object. If formatter is <code>null</code>,
 * {@link String#valueOf(int)} will be used.
 *
 * @see #setDisplayedValues(String[])
 */
","/**
 * Set the formatter to be used for formatting the current value.
 * <p>
 * Note: If you have provided alternative values for the values this
 * formatter is never invoked.
 * </p>
 *
 * @param formatter The formatter object. If formatter is <code>null</code>,
 * {@link String#valueOf(int)} will be used.
 *
 * @see #setDisplayedValues(String[])
 */
",0,,,0,,,,,,,"4,5",0,"A call to resetSelectorWheelIndices() in the early version has changed to a call to initializeSelectorWheelIndices() in the late version, which indicates the dependent API has changed, resulting in change type 4,5.","Despite the change in the method being called after setting the formatter, this does not necessarily indicate a change in the return type or value, nor does it indicate a change in exception handling, since the method's purpose is to initialize or reset state and not to define the return value or throw exceptions. Moreover, both methods are likely intended to serve similar purposes related to setting up the selector wheel indices. Therefore, there should be no Compatibility Issue and the type is 0."
170,"<android.view.View: boolean onKeyDown(int,KeyEvent)>",13,14,,,,"{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                // Long clickable items don't necessarily have to be clickable
                if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
                    setPressed(true);
                    if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
                        postCheckForLongClick(0);
                    }
                    return true;
                }
                break;
            }
    }
    return result;
}","{
    boolean result = false;
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if ((mViewFlags & ENABLED_MASK) == DISABLED) {
                    return true;
                }
                // Long clickable items don't necessarily have to be clickable
                if (((mViewFlags & CLICKABLE) == CLICKABLE || (mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) && (event.getRepeatCount() == 0)) {
                    setPressed(true);
                    checkForLongClick(0);
                    return true;
                }
                break;
            }
    }
    return result;
}",1,"/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
","/**
 * Default implementation of {@link KeyEvent.Callback#onKeyDown(int, KeyEvent)
 * KeyEvent.Callback.onKeyDown()}: perform press of the view
 * when {@link KeyEvent#KEYCODE_DPAD_CENTER} or {@link KeyEvent#KEYCODE_ENTER}
 * is released, if the view is enabled and clickable.
 *
 * @param keyCode A key code that represents the button pressed, from
 * {@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
",0,,,0,,,,,,,"4,5",0,"A method call within a condition has been altered from postCheckForLongClick(0) to checkForLongClick(0); therefore, it's a dependent API change - the dependent API being invoked has changed from postCheckForLongClick to checkForLongClick. The return statement and its conditions have remained the same, so there is no return statement change. Hence, the code change types are 4 and 5.","As the behavior related to the return value of the method hasn't changed and assuming that the checkForLongClick(0) performs the same role with probably just a different mechanism (posted to a handler versus directly invoking the check), there is no compatibility issue arising out of a potentially different return value or exception handling. Therefore, the Compatibility Issue is 0."
172,"<android.server.BluetoothService: boolean setScanMode(int,int)>",13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, ""Need WRITE_SECURE_SETTINGS permission"");
    boolean pairable;
    boolean discoverable;
    switch(mode) {
        case BluetoothAdapter.SCAN_MODE_NONE:
            pairable = false;
            discoverable = false;
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
            pairable = true;
            discoverable = false;
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
            pairable = true;
            discoverable = true;
            if (DBG)
                Log.d(TAG, ""BT Discoverable for "" + duration + "" seconds"");
            break;
        default:
            Log.w(TAG, ""Requested invalid scan mode "" + mode);
            return false;
    }
    setPropertyBoolean(""Pairable"", pairable);
    setPropertyBoolean(""Discoverable"", discoverable);
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, ""Need WRITE_SECURE_SETTINGS permission"");
    boolean pairable;
    boolean discoverable;
    switch(mode) {
        case BluetoothAdapter.SCAN_MODE_NONE:
            pairable = false;
            discoverable = false;
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE:
            pairable = true;
            discoverable = false;
            break;
        case BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE:
            pairable = true;
            discoverable = true;
            if (DBG)
                Log.d(TAG, ""BT Discoverable for "" + duration + "" seconds"");
            break;
        default:
            Log.w(TAG, ""Requested invalid scan mode "" + mode);
            return false;
    }
    setPropertyBoolean(""Discoverable"", discoverable);
    setPropertyBoolean(""Pairable"", pairable);
    return true;
}",1,,,0,,,0,,,,,,,4,0,"The sequence of calling setPropertyBoolean() has been altered, with ""Discoverable"" being set before ""Pairable"" in the later version, but this only affects the internal execution order and not the external behavior.","Despite the change in the internal sequence of operations, there is no change in the overall behavior of the method from an external viewpoint. Both versions set the properties correctly, and return the same value, thus there will be no Compatibility Issue."
174,"<android.text.method.BaseMovementMethod: boolean handleMovementKey(TextView,Spannable,int,int,KeyEvent)>",13,14,,,,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return left(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return lineStart(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return right(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return lineEnd(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_UP:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return up(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return top(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return down(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return bottom(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_PAGE_UP:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return pageUp(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return top(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_PAGE_DOWN:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return pageDown(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return bottom(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_MOVE_HOME:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return home(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_MOVE_END:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return end(widget, buffer);
            }
            break;
    }
    return false;
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return left(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_CTRL_ON)) {
                return leftWord(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return lineStart(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return right(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_CTRL_ON)) {
                return rightWord(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return lineEnd(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_UP:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return up(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return top(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_DPAD_DOWN:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return down(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return bottom(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_PAGE_UP:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return pageUp(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return top(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_PAGE_DOWN:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return pageDown(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_ALT_ON)) {
                return bottom(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_MOVE_HOME:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return home(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_CTRL_ON)) {
                return top(widget, buffer);
            }
            break;
        case KeyEvent.KEYCODE_MOVE_END:
            if (KeyEvent.metaStateHasNoModifiers(movementMetaState)) {
                return end(widget, buffer);
            } else if (KeyEvent.metaStateHasModifiers(movementMetaState, KeyEvent.META_CTRL_ON)) {
                return bottom(widget, buffer);
            }
            break;
    }
    return false;
}",1,"/**
 * Performs a movement key action.
 * The default implementation decodes the key down and invokes movement actions
 * such as {@link #down} and {@link #up}.
 * {@link #onKeyDown(TextView, Spannable, int, KeyEvent)} calls this method once
 * to handle an {@link KeyEvent#ACTION_DOWN}.
 * {@link #onKeyOther(TextView, Spannable, KeyEvent)} calls this method repeatedly
 * to handle each repetition of an {@link KeyEvent#ACTION_MULTIPLE}.
 *
 * @param widget The text view.
 * @param buffer The text buffer.
 * @param event The key event.
 * @param keyCode The key code.
 * @param movementMetaState The keyboard meta states used for movement.
 * @param event The key event.
 * @return True if the event was handled.
 */
","/**
 * Performs a movement key action.
 * The default implementation decodes the key down and invokes movement actions
 * such as {@link #down} and {@link #up}.
 * {@link #onKeyDown(TextView, Spannable, int, KeyEvent)} calls this method once
 * to handle an {@link KeyEvent#ACTION_DOWN}.
 * {@link #onKeyOther(TextView, Spannable, KeyEvent)} calls this method repeatedly
 * to handle each repetition of an {@link KeyEvent#ACTION_MULTIPLE}.
 *
 * @param widget The text view.
 * @param buffer The text buffer.
 * @param event The key event.
 * @param keyCode The key code.
 * @param movementMetaState The keyboard meta states used for movement.
 * @param event The key event.
 * @return True if the event was handled.
 */
",0,,,0,,,,,,,,,,
180,<android.webkit.WebView: int getVisibleTitleHeight()>,13,14,,,,"{
    // need to restrict mScrollY due to over scroll
    return Math.max(getTitleHeight() - Math.max(0, mScrollY), 0);
}","{
    checkThread();
    return getVisibleTitleHeightImpl();
}",1,"/**
 * Return the amount of the titlebarview (if any) that is visible
 *
 * @deprecated This method is now obsolete.
 */
","/**
 * Return the amount of the titlebarview (if any) that is visible
 *
 * @deprecated This method is now obsolete.
 */
",0,,,0,,,,,,,"4,5",1,"The implementation has changed from direct calculations within the method to a call to a separate method getVisibleTitleHeightImpl(). Additionally, a checkThread() call has been introduced before the return statement. These changes make the code change type 4,5.","The introduction of the checkThread() method call could lead to new behavior if it throws exceptions for invalid thread access, which would be a change in exception handling. However, this seems like a check that would enforce correct usage rather than change the method's basic behavior. The call to getVisibleTitleHeightImpl() instead of direct calculation within the method also indicates a potential change in the return value depending on the implementation of getVisibleTitleHeightImpl(). Therefore, the CI type is 1."
181,<android.view.View: boolean hasIdentityMatrix()>,13,14,,,,"{
    updateMatrix();
    return mMatrixIsIdentity;
}","{
    if (mTransformationInfo != null) {
        updateMatrix();
        return mTransformationInfo.mMatrixIsIdentity;
    }
    return true;
}",1,"/**
 * Returns true if the transform matrix is the identity matrix.
 * Recomputes the matrix if necessary.
 *
 * @return True if the transform matrix is the identity matrix, false otherwise.
 */
","/**
 * Returns true if the transform matrix is the identity matrix.
 * Recomputes the matrix if necessary.
 *
 * @return True if the transform matrix is the identity matrix, false otherwise.
 */
",0,,,0,,,,,,,"1,3",1,"The late version has a new control dependency change (condition check for mTransformationInfo != null) and the return statement is conditionally changed depending on this control flow. Additionally, the return value now comes from a potentially different source (mTransformationInfo.mMatrixIsIdentity), so the change type is 1,3.","The introduction of a new conditional check that changes the return value introduces a possible CI. Depending on whether mTransformationInfo is null or not, the method can return different values (either true or mTransformationInfo.mMatrixIsIdentity), which could lead to different behavior from an invocation of this method between versions. Therefore, the CI type is 1."
182,<android.webkit.WebView: boolean canGoBack()>,13,14,,,,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() > 0;
        }
    }
}","{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() > 0;
        }
    }
}",1,"/**
 * Return true if this WebView has a back history item.
 * @return True iff this WebView has a back history item.
 */
","/**
 * Return true if this WebView has a back history item.
 * @return True iff this WebView has a back history item.
 */
",0,,,0,,,,,,,4,0,"There is an addition of the checkThread() method call at the beginning of the implementation, which does not affect the output of the method and is not an exception handling statement, hence it's classified as code change type 4.","The addition of the checkThread() method is presumably for ensuring that the WebView methods are called on the correct thread and it should throw an exception if it's not. However, this would not result in a Compatibility Issue regarding the behavior of the canGoBack() method itself because if the thread check passes (as would be the case in properly implemented applications), the rest of the implementation remains unchanged. Thus, there is no Compatibility Issue, and the CI type is 0."
183,<android.webkit.WebView: int findAll(String)>,13,14,,,,"{
    // client isn't initialized
    if (0 == mNativeClass)
        return 0;
    int result = find != null ? nativeFindAll(find.toLowerCase(), find.toUpperCase(), find.equalsIgnoreCase(mLastFind)) : 0;
    invalidate();
    mLastFind = find;
    return result;
}","{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return 0;
    int result = find != null ? nativeFindAll(find.toLowerCase(), find.toUpperCase(), find.equalsIgnoreCase(mLastFind)) : 0;
    invalidate();
    mLastFind = find;
    return result;
}",1,"/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
","/*
     * Find all instances of find on the page and highlight them.
     * @param find  String to find.
     * @return int  The number of occurances of the String ""find""
     *              that were found.
     */
",0,,,0,,,,,,,4,0,"The late version introduces a call to the method checkThread() at the beginning of the method implementation which is a change of a non-controlled, non-return, non-exception statement; thus, the code change type is 4.","The added checkThread() call does not affect any return value or exception handling, hence it doesn't lead to a Compatibility Issue. The change appears to be a thread safety check and should not modify the execution result of the method assuming the check passes. If the check fails, it would raise an exception which is presumably the intended behavior for both versions."
185,"<android.speech.tts.TextToSpeech: int addSpeech(String,String)>",13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return ERROR;
        }
        try {
            mITts.addSpeechFile(mPackageName, text, filename);
            return SUCCESS;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return ERROR;
    }
}","{
    synchronized (mStartLock) {
        mUtterances.put(text, Uri.parse(filename));
        return SUCCESS;
    }
}",1,"/**
 * Adds a mapping between a string of text and a sound file. Using this, it
 * is possible to add custom pronounciations for a string of text.
 * After a call to this method, subsequent calls to {@link #speak(String, int, HashMap)}
 * will play the specified sound resource if it is available, or synthesize the text it is
 * missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/hello.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound file. Using this, it
 * is possible to add custom pronounciations for a string of text.
 * After a call to this method, subsequent calls to {@link #speak(String, int, HashMap)}
 * will play the specified sound resource if it is available, or synthesize the text it is
 * missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/hello.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",0,,,0,,,,,,,"1,2,4","1,2","There is a removal of exception handling for RemoteException, NullPointerException, and IllegalStateException, and the try-catch block is removed. Additionally, the method body has been completely refactored, removing the calls to mITts.addSpeechFile and all associated error handling, including setting mStarted to false and calling initTts(). Instead, it now adds an entry to mUtterances. Thus, there is a return statement changed, exception handling changed, and other statements changed, so the code change types are 1,2,4.","The changes introduced in the method implementation could potentially return different values due to the removal of all previous error handling and changes in the logic. The late version does not handle exceptions and always returns SUCCESS, unlike the early version which could return ERROR. This is a significant change that will change the behavior, so the CI types are 1 (for potentially different return values) and 2 (for different exception handlings)."
186,<android.widget.AbsListView: void handleDataChanged()>,13,14,,,,"{
    int count = mItemCount;
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getBottom() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= mOldItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}","{
    int count = mItemCount;
    int lastHandledItemCount = mLastHandledItemCount;
    mLastHandledItemCount = mItemCount;
    if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
        confirmCheckedPositionsById();
    }
    if (count > 0) {
        int newPos;
        int selectablePos;
        // Find the row we are supposed to sync to
        if (mNeedSync) {
            // Update this first, since setNextSelectedPositionInt inspects it
            mNeedSync = false;
            if (mTranscriptMode == TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                mLayoutMode = LAYOUT_FORCE_BOTTOM;
                return;
            } else if (mTranscriptMode == TRANSCRIPT_MODE_NORMAL) {
                if (mForceTranscriptScroll) {
                    mForceTranscriptScroll = false;
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                final int childCount = getChildCount();
                final int listBottom = getHeight() - getPaddingBottom();
                final View lastChild = getChildAt(childCount - 1);
                final int lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                if (mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                    mLayoutMode = LAYOUT_FORCE_BOTTOM;
                    return;
                }
                // Something new came in and we didn't scroll; give the user a clue that
                // there's something new.
                awakenScrollBars();
            }
            switch(mSyncMode) {
                case SYNC_SELECTED_POSITION:
                    if (isInTouchMode()) {
                        // We saved our state when not in touch mode. (We know this because
                        // mSyncMode is SYNC_SELECTED_POSITION.) Now we are trying to
                        // restore in touch mode. Just leave mSyncPosition as it is (possibly
                        // adjusting if the available range changed) and return.
                        mLayoutMode = LAYOUT_SYNC;
                        mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                        return;
                    } else {
                        // See if we can find a position in the new data with the same
                        // id as the old selection. This will change mSyncPosition.
                        newPos = findSyncPosition();
                        if (newPos >= 0) {
                            // Found it. Now verify that new selection is still selectable
                            selectablePos = lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                // Same row id is selected
                                mSyncPosition = newPos;
                                if (mSyncHeight == getHeight()) {
                                    // If we are at the same height as when we saved state, try
                                    // to restore the scroll position too.
                                    mLayoutMode = LAYOUT_SYNC;
                                } else {
                                    // We are not the same height as when the selection was saved, so
                                    // don't try to restore the exact position
                                    mLayoutMode = LAYOUT_SET_SELECTION;
                                }
                                // Restore selection
                                setNextSelectedPositionInt(newPos);
                                return;
                            }
                        }
                    }
                    break;
                case SYNC_FIRST_POSITION:
                    // Leave mSyncPosition as it is -- just pin to available range
                    mLayoutMode = LAYOUT_SYNC;
                    mSyncPosition = Math.min(Math.max(0, mSyncPosition), count - 1);
                    return;
            }
        }
        if (!isInTouchMode()) {
            // We couldn't find matching data -- try to use the same position
            newPos = getSelectedItemPosition();
            // Pin position to the available range
            if (newPos >= count) {
                newPos = count - 1;
            }
            if (newPos < 0) {
                newPos = 0;
            }
            // Make sure we select something selectable -- first look down
            selectablePos = lookForSelectablePosition(newPos, true);
            if (selectablePos >= 0) {
                setNextSelectedPositionInt(selectablePos);
                return;
            } else {
                // Looking down didn't work -- try looking up
                selectablePos = lookForSelectablePosition(newPos, false);
                if (selectablePos >= 0) {
                    setNextSelectedPositionInt(selectablePos);
                    return;
                }
            }
        } else {
            // We already know where we want to resurrect the selection
            if (mResurrectToPosition >= 0) {
                return;
            }
        }
    }
    // Nothing is selected. Give up and reset everything.
    mLayoutMode = mStackFromBottom ? LAYOUT_FORCE_BOTTOM : LAYOUT_FORCE_TOP;
    mSelectedPosition = INVALID_POSITION;
    mSelectedRowId = INVALID_ROW_ID;
    mNextSelectedPosition = INVALID_POSITION;
    mNextSelectedRowId = INVALID_ROW_ID;
    mNeedSync = false;
    mSelectorPosition = INVALID_POSITION;
    checkSelectionChanged();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
187,<android.widget.SimpleCursorAdapter: Cursor swapCursor(Cursor)>,13,14,,,,"{
    Cursor res = super.swapCursor(c);
    // rescan columns in case cursor layout is different
    findColumns(mOriginalFrom);
    return res;
}","{
    // happens
    if (mFrom == null) {
        findColumns(mOriginalFrom);
    }
    Cursor res = super.swapCursor(c);
    // rescan columns in case cursor layout is different
    findColumns(mOriginalFrom);
    return res;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"An if statement checking if mFrom is null has been introduced before the call to super.swapCursor(c), so the code change type is 3.","The added if statement does not alter the behavior of the existing return statement or introduce a new one. Furthermore, since the `findColumns` method is called regardless of whether `mFrom` is null or not, the actual return value `res` is not affected by this change. Therefore, there is no Compatibility Issue, and the CI type is 0."
188,"<android.hardware.SensorManager: boolean registerListener(SensorEventListener,Sensor,int,Handler)>",13,14,,,,"{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result = true;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 60000;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    synchronized (sListeners) {
        // look for this listener in our list
        ListenerDelegate l = null;
        for (ListenerDelegate i : sListeners) {
            if (i.getListener() == listener) {
                l = i;
                break;
            }
        }
        // if we don't find it, add it to the list
        if (l == null) {
            l = new ListenerDelegate(listener, sensor, handler);
            sListeners.add(l);
            // if the list is not empty, start our main thread
            if (!sListeners.isEmpty()) {
                if (sSensorThread.startLocked()) {
                    if (!enableSensorLocked(sensor, delay)) {
                        // oops. there was an error
                        sListeners.remove(l);
                        result = false;
                    }
                } else {
                    // there was an error, remove the listener
                    sListeners.remove(l);
                    result = false;
                }
            } else {
                // weird, we couldn't add the listener
                result = false;
            }
        } else {
            l.addSensor(sensor);
            if (!enableSensorLocked(sensor, delay)) {
                // oops. there was an error
                l.removeSensor(sensor);
                result = false;
            }
        }
    }
    return result;
}","{
    if (listener == null || sensor == null) {
        return false;
    }
    boolean result = true;
    int delay = -1;
    switch(rate) {
        case SENSOR_DELAY_FASTEST:
            delay = 0;
            break;
        case SENSOR_DELAY_GAME:
            delay = 20000;
            break;
        case SENSOR_DELAY_UI:
            delay = 66667;
            break;
        case SENSOR_DELAY_NORMAL:
            delay = 200000;
            break;
        default:
            delay = rate;
            break;
    }
    synchronized (sListeners) {
        // look for this listener in our list
        ListenerDelegate l = null;
        for (ListenerDelegate i : sListeners) {
            if (i.getListener() == listener) {
                l = i;
                break;
            }
        }
        // if we don't find it, add it to the list
        if (l == null) {
            l = new ListenerDelegate(listener, sensor, handler);
            sListeners.add(l);
            // if the list is not empty, start our main thread
            if (!sListeners.isEmpty()) {
                if (sSensorThread.startLocked()) {
                    if (!enableSensorLocked(sensor, delay)) {
                        // oops. there was an error
                        sListeners.remove(l);
                        result = false;
                    }
                } else {
                    // there was an error, remove the listener
                    sListeners.remove(l);
                    result = false;
                }
            } else {
                // weird, we couldn't add the listener
                result = false;
            }
        } else {
            l.addSensor(sensor);
            if (!enableSensorLocked(sensor, delay)) {
                // oops. there was an error
                l.removeSensor(sensor);
                result = false;
            }
        }
    }
    return result;
}",1,"/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microsecond.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
","/**
 * Registers a {@link android.hardware.SensorEventListener
 * SensorEventListener} for the given sensor.
 *
 * @param listener
 * A {@link android.hardware.SensorEventListener SensorEventListener}
 * object.
 *
 * @param sensor
 * The {@link android.hardware.Sensor Sensor} to register to.
 *
 * @param rate
 * The rate {@link android.hardware.SensorEvent sensor events} are
 * delivered at. This is only a hint to the system. Events may be
 * received faster or slower than the specified rate. Usually events
 * are received faster. The value must be one of
 * {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
 * {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
 * or, the desired delay between events in microsecond.
 *
 * @param handler
 * The {@link android.os.Handler Handler} the
 * {@link android.hardware.SensorEvent sensor events} will be
 * delivered to.
 *
 * @return true if the sensor is supported and successfully enabled.
 *
 * @see #registerListener(SensorEventListener, Sensor, int)
 * @see #unregisterListener(SensorEventListener)
 * @see #unregisterListener(SensorEventListener, Sensor)
 */
",0,,,0,,,,,,,3,0,"There is a change in an expression within the 'switch' statement for the case SENSOR_DELAY_UI, from 60000 to 66667, which is a control dependency change. There are no other changes in the return or exception handling statements.","Since this change only affects the delay interval for SENSOR_DELAY_UI and does not introduce a new return statement or modify exception handling, it does not imply a possible Compatibility Issue as the method's return type and behavior remain the same for the given inputs."
189,"<android.webkit.WebView: void passToJavaScript(String,KeyEvent)>",13,14,,,,"{
    WebViewCore.JSKeyData arg = new WebViewCore.JSKeyData();
    arg.mEvent = event;
    arg.mCurrentText = currentText;
    // Increase our text generation number, and pass it to webcore thread
    mTextGeneration++;
    mWebViewCore.sendMessage(EventHub.PASS_TO_JS, mTextGeneration, 0, arg);
    // WebKit's document state is not saved until about to leave the page.
    // To make sure the host application, like Browser, has the up to date
    // document state when it goes to background, we force to save the
    // document state.
    mWebViewCore.removeMessages(EventHub.SAVE_DOCUMENT_STATE);
    mWebViewCore.sendMessageDelayed(EventHub.SAVE_DOCUMENT_STATE, cursorData(), 1000);
}","{
    // check if mWebViewCore has been destroyed
    if (mWebViewCore == null) {
        return;
    }
    WebViewCore.JSKeyData arg = new WebViewCore.JSKeyData();
    arg.mEvent = event;
    arg.mCurrentText = currentText;
    // Increase our text generation number, and pass it to webcore thread
    mTextGeneration++;
    mWebViewCore.sendMessage(EventHub.PASS_TO_JS, mTextGeneration, 0, arg);
    // WebKit's document state is not saved until about to leave the page.
    // To make sure the host application, like Browser, has the up to date
    // document state when it goes to background, we force to save the
    // document state.
    mWebViewCore.removeMessages(EventHub.SAVE_DOCUMENT_STATE);
    mWebViewCore.sendMessageDelayed(EventHub.SAVE_DOCUMENT_STATE, cursorData(), 1000);
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,3",0,"The introduction of a new if-check for mWebViewCore being null and associated return statement at the beginning of the method, which is a change related to control dependency, so the change types are 1 and 3.","Despite the introduction of the new if-check, this change does not introduce a Compatibility Issue because the additional check only affects scenarios where mWebViewCore would be null, which previously would have resulted in a NullPointerException and terminated the method early anyway. The new check explicitly returns early without executing further code, which is safer and does not alter the API's intended behavior when mWebViewCore is valid. The intent of the method remains the same and no new behavior is introduced in valid use cases. Thus, no Compatibility Issue is expected from this change."
190,<android.widget.QuickContactBadge: void onDraw(Canvas)>,13,14,,,,"{
    super.onDraw(canvas);
    if (mOverlay == null || mOverlay.getIntrinsicWidth() == 0 || mOverlay.getIntrinsicHeight() == 0) {
        // nothing to draw
        return;
    }
    mOverlay.setBounds(0, 0, getWidth(), getHeight());
    if (mPaddingTop == 0 && mPaddingLeft == 0) {
        mOverlay.draw(canvas);
    } else {
        int saveCount = canvas.getSaveCount();
        canvas.save();
        canvas.translate(mPaddingLeft, mPaddingTop);
        mOverlay.draw(canvas);
        canvas.restoreToCount(saveCount);
    }
}","{
    super.onDraw(canvas);
    if (!isEnabled()) {
        // not clickable? don't show triangle
        return;
    }
    if (mOverlay == null || mOverlay.getIntrinsicWidth() == 0 || mOverlay.getIntrinsicHeight() == 0) {
        // nothing to draw
        return;
    }
    mOverlay.setBounds(0, 0, getWidth(), getHeight());
    if (mPaddingTop == 0 && mPaddingLeft == 0) {
        mOverlay.draw(canvas);
    } else {
        int saveCount = canvas.getSaveCount();
        canvas.save();
        canvas.translate(mPaddingLeft, mPaddingTop);
        mOverlay.draw(canvas);
        canvas.restoreToCount(saveCount);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"There's an added control check 'if (!isEnabled())' with a corresponding return statement in the late implementation, which is a control dependency change, classified as 3.","Due to the added condition that checks if the QuickContactBadge is enabled before drawing the overlay, the method may now return earlier than it did in the early version. This represents a change in behavior when the QuickContactBadge is disabled, which could result in a different visual output, classifying this as a Compatibility Issue of type 1 (different return value or behavior due to an added return statement in a control flow)."
191,"<android.nfc.NfcAdapter: void disableForegroundDispatchInternal(Activity,boolean)>",13,14,,,,"{
    try {
        sService.disableForegroundDispatch(activity.getComponentName());
        if (!force && !activity.isResumed()) {
            throw new IllegalStateException(""You must disable forgeground dispatching "" + ""while your activity is still resumed"");
        }
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}","{
    try {
        sService.setForegroundDispatch(null, null, null);
        if (!force && !activity.isResumed()) {
            throw new IllegalStateException(""You must disable foreground dispatching "" + ""while your activity is still resumed"");
        }
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}",1,,,0,,,0,,,,,,,"3,5",0,"The method called within the 'try' block has been changed from `sService.disableForegroundDispatch(activity.getComponentName())` to `sService.setForegroundDispatch(null, null, null)`. Although there's a change in the method being called (a dependent API), the rest of the code, including the control structures and the exception thrown, remains the same, resulting in the change types of 3 and 5.","No Compatibility Issue could arise because the boolean 'force' and the condition 'activity.isResumed()' remain untouched, and the exception handling for RemoteException has not changed either. Thus, the behavior of exception throwing remains consistent. The change in the internal API method called does not directly cause a change in return values or exception handling of the `disableForegroundDispatchInternal()` method, so the CI type is 0."
192,"<android.app.ContextImpl: int checkUriPermission(Uri,int,int,int)>",13,14,,,,"{
    if (!Process.supportsProcesses()) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(uri, pid, uid, modeFlags);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    try {
        return ActivityManagerNative.getDefault().checkUriPermission(uri, pid, uid, modeFlags);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The return statement for the condition `!Process.supportsProcesses()` has been removed, causing a control flow change. If the condition were true, the early version would short-circuit and return `PackageManager.PERMISSION_GRANTED`, while the late version would instead proceed to the try-catch block. Thus, the changes can be classified under types 1 and 3.","With the removal of the initial if-statement that returns `PackageManager.PERMISSION_GRANTED`, the late version will no longer return this value when the condition `!Process.supportsProcesses()` is met. Instead, it will proceed with further checks that could potentially lead to a different return value, thus causing a Compatibility Issue of type 1."
193,<android.view.View: boolean dispatchTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!onFilterTouchEventForSecurity(event)) {
        return false;
    }
    // noinspection SimplifiableIfStatement
    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event)) {
        return true;
    }
    return onTouchEvent(event);
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    if (onFilterTouchEventForSecurity(event)) {
        // noinspection SimplifiableIfStatement
        if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnTouchListener.onTouch(this, event)) {
            return true;
        }
        if (onTouchEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}",1,"/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",0,,,0,,,,,,,"1,3",1,"The sequence of checks and method calls in the control flow are heavily modified. The condition checking `onFilterTouchEventForSecurity(event)` is now part of a larger if-else structure, plus there is a new consistency check with `mInputEventConsistencyVerifier`. These changes qualify as a control dependency change (3). Additionally, the return statements are now nested within different blocks, altering when they get executed; thus, return statements have changed as well (1).","Because there is a control flow change that affects when and how return statements are reached, it may affect the return value of the function. The introduction of the new condition and additional checks with `mInputEventConsistencyVerifier` may also lead to new behaviors that were not present before, such as potentially throwing an exception (if the verifier method does so). Therefore, there is a potential for a different return value, making it a Compatibility Issue of type 1."
195,<android.app.ActivityThread.H: String codeToString(int)>,13,14,,,,"{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
        }
    }
    return ""(unknown)"";
}","{
    if (DEBUG_MESSAGES) {
        switch(code) {
            case LAUNCH_ACTIVITY:
                return ""LAUNCH_ACTIVITY"";
            case PAUSE_ACTIVITY:
                return ""PAUSE_ACTIVITY"";
            case PAUSE_ACTIVITY_FINISHING:
                return ""PAUSE_ACTIVITY_FINISHING"";
            case STOP_ACTIVITY_SHOW:
                return ""STOP_ACTIVITY_SHOW"";
            case STOP_ACTIVITY_HIDE:
                return ""STOP_ACTIVITY_HIDE"";
            case SHOW_WINDOW:
                return ""SHOW_WINDOW"";
            case HIDE_WINDOW:
                return ""HIDE_WINDOW"";
            case RESUME_ACTIVITY:
                return ""RESUME_ACTIVITY"";
            case SEND_RESULT:
                return ""SEND_RESULT"";
            case DESTROY_ACTIVITY:
                return ""DESTROY_ACTIVITY"";
            case BIND_APPLICATION:
                return ""BIND_APPLICATION"";
            case EXIT_APPLICATION:
                return ""EXIT_APPLICATION"";
            case NEW_INTENT:
                return ""NEW_INTENT"";
            case RECEIVER:
                return ""RECEIVER"";
            case CREATE_SERVICE:
                return ""CREATE_SERVICE"";
            case SERVICE_ARGS:
                return ""SERVICE_ARGS"";
            case STOP_SERVICE:
                return ""STOP_SERVICE"";
            case REQUEST_THUMBNAIL:
                return ""REQUEST_THUMBNAIL"";
            case CONFIGURATION_CHANGED:
                return ""CONFIGURATION_CHANGED"";
            case CLEAN_UP_CONTEXT:
                return ""CLEAN_UP_CONTEXT"";
            case GC_WHEN_IDLE:
                return ""GC_WHEN_IDLE"";
            case BIND_SERVICE:
                return ""BIND_SERVICE"";
            case UNBIND_SERVICE:
                return ""UNBIND_SERVICE"";
            case DUMP_SERVICE:
                return ""DUMP_SERVICE"";
            case LOW_MEMORY:
                return ""LOW_MEMORY"";
            case ACTIVITY_CONFIGURATION_CHANGED:
                return ""ACTIVITY_CONFIGURATION_CHANGED"";
            case RELAUNCH_ACTIVITY:
                return ""RELAUNCH_ACTIVITY"";
            case PROFILER_CONTROL:
                return ""PROFILER_CONTROL"";
            case CREATE_BACKUP_AGENT:
                return ""CREATE_BACKUP_AGENT"";
            case DESTROY_BACKUP_AGENT:
                return ""DESTROY_BACKUP_AGENT"";
            case SUICIDE:
                return ""SUICIDE"";
            case REMOVE_PROVIDER:
                return ""REMOVE_PROVIDER"";
            case ENABLE_JIT:
                return ""ENABLE_JIT"";
            case DISPATCH_PACKAGE_BROADCAST:
                return ""DISPATCH_PACKAGE_BROADCAST"";
            case SCHEDULE_CRASH:
                return ""SCHEDULE_CRASH"";
            case DUMP_HEAP:
                return ""DUMP_HEAP"";
            case DUMP_ACTIVITY:
                return ""DUMP_ACTIVITY"";
            case SLEEPING:
                return ""SLEEPING"";
            case SET_CORE_SETTINGS:
                return ""SET_CORE_SETTINGS"";
            case UPDATE_PACKAGE_COMPATIBILITY_INFO:
                return ""UPDATE_PACKAGE_COMPATIBILITY_INFO"";
            case TRIM_MEMORY:
                return ""TRIM_MEMORY"";
        }
    }
    return ""(unknown)"";
}",1,,,0,,,0,,,,,,,,,,
200,<android.speech.tts.TextToSpeech: Locale getLanguage()>,13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return null;
        }
        try {
            // Only do a call to the native synth if there is nothing in the cached params
            if (mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1].length() < 1) {
                String[] locStrings = mITts.getLanguage();
                if ((locStrings != null) && (locStrings.length == 3)) {
                    return new Locale(locStrings[0], locStrings[1], locStrings[2]);
                } else {
                    return null;
                }
            } else {
                return new Locale(mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1], mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1], mCachedParams[Engine.PARAM_POSITION_VARIANT + 1]);
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - getLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return null;
    }
}","{
    return runAction(new Action<Locale>() {

        @Override
        public Locale run(ITextToSpeechService service) throws RemoteException {
            String[] locStrings = service.getLanguage();
            if (locStrings != null && locStrings.length == 3) {
                return new Locale(locStrings[0], locStrings[1], locStrings[2]);
            }
            return null;
        }
    }, null, ""getLanguage"");
}",1,"/**
 * Returns a Locale instance describing the language currently being used by the TextToSpeech
 * engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
 * instance, or null is the TextToSpeech engine has failed.
 */
","/**
 * Returns a Locale instance describing the language currently being used by the TextToSpeech
 * engine.
 *
 * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
 * instance, or {@code null} on error.
 */
",1,,,0,,,,,,,"1,3,4,5","1,2","The control flow has significantly changed with the introduction of a new way to execute the method (runAction with an anonymous Action class). The handling of RemoteException has changed: before it was caught and logged with stack trace, and now it propagates through the run method. The Internal API used to perform the service call (mITts.getLanguage()) has been replaced with service.getLanguage() used inside the anonymous Action class. Also, the exception handling has been altered by removing the catch blocks for NullPointerException and IllegalStateException. Those changes make the code change types 1,3,4,5.","The change in exception handling will result in different exceptions possibly being thrown (previously they were caught and logged, now RemoteException will propagate), and since the implementation has changed from the direct use of cached parameters and a conditional service call to always using the service call, the Locale returned could be different. This leads to potential difference in both return values or types, and exception handling, so the CI type is 1,2."
201,<android.webkit.WebView: void handleMultiTouchInWebView(MotionEvent)>,13,14,,,,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""multi-touch: "" + ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode + "" numPointers="" + ev.getPointerCount() + "" scrolloffset=("" + mScrollX + "","" + mScrollY + "")"");
    }
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    // We don't need to support multi touch for them.
    if (detector == null)
        return;
    float x = ev.getX();
    float y = ev.getY();
    if (mPreventDefault != PREVENT_DEFAULT_YES) {
        detector.onTouchEvent(ev);
        if (detector.isInProgress()) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""detector is in progress"");
            }
            mLastTouchTime = ev.getEventTime();
            x = detector.getFocusX();
            y = detector.getFocusY();
            cancelLongPress();
            mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
            if (!mZoomManager.supportsPanDuringZoom()) {
                return;
            }
            mTouchMode = TOUCH_DRAG_MODE;
            if (mVelocityTracker == null) {
                mVelocityTracker = VelocityTracker.obtain();
            }
        }
    }
    int action = ev.getActionMasked();
    if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action = MotionEvent.ACTION_DOWN;
    } else if (action == MotionEvent.ACTION_POINTER_UP && ev.getPointerCount() == 2) {
        // set mLastTouchX/Y to the remaining point
        mLastTouchX = Math.round(x);
        mLastTouchY = Math.round(y);
    } else if (action == MotionEvent.ACTION_MOVE) {
        // negative x or y indicate it is on the edge, skip it.
        if (x < 0 || y < 0) {
            return;
        }
    }
    handleTouchEventCommon(ev, action, Math.round(x), Math.round(y));
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""multi-touch: "" + ev + "" at "" + ev.getEventTime() + "" mTouchMode="" + mTouchMode + "" numPointers="" + ev.getPointerCount() + "" scrolloffset=("" + mScrollX + "","" + mScrollY + "")"");
    }
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    // We don't need to support multi touch for them.
    if (detector == null)
        return;
    float x = ev.getX();
    float y = ev.getY();
    if (mPreventDefault != PREVENT_DEFAULT_YES) {
        detector.onTouchEvent(ev);
        if (detector.isInProgress()) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""detector is in progress"");
            }
            mLastTouchTime = ev.getEventTime();
            x = detector.getFocusX();
            y = detector.getFocusY();
            cancelLongPress();
            mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
            if (!mZoomManager.supportsPanDuringZoom()) {
                return;
            }
            mTouchMode = TOUCH_DRAG_MODE;
            if (mVelocityTracker == null) {
                mVelocityTracker = VelocityTracker.obtain();
            }
        }
    }
    int action = ev.getActionMasked();
    if (action == MotionEvent.ACTION_POINTER_DOWN) {
        cancelTouch();
        action = MotionEvent.ACTION_DOWN;
    } else if (action == MotionEvent.ACTION_POINTER_UP && ev.getPointerCount() >= 2) {
        // set mLastTouchX/Y to the remaining points for multi-touch.
        mLastTouchX = Math.round(x);
        mLastTouchY = Math.round(y);
    } else if (action == MotionEvent.ACTION_MOVE) {
        // negative x or y indicate it is on the edge, skip it.
        if (x < 0 || y < 0) {
            return;
        }
    }
    handleTouchEventCommon(ev, action, Math.round(x), Math.round(y));
}",1,,,0,,,0,,,,,,,3,0,There is a change in one of the conditionals to check the pointer count (from `== 2` to `>= 2`). The code change type is 3 as this is a change in a control statement.,"There is no Compatibility Issue introduced by this change as the modification does not affect the return type or value of the method, nor does it introduce different exception handling. Since the method has a void return type and the change only affects an internal condition of the event handling, it will not cause any different behavior visible to the caller of this method with respect to what value is returned or what exceptions might be thrown."
202,<android.content.Intent: String toString()>,13,14,,,,"{
    StringBuilder b = new StringBuilder(128);
    b.append(""Intent { "");
    toShortString(b, true, true);
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder(128);
    b.append(""Intent { "");
    toShortString(b, true, true, true);
    b.append("" }"");
    return b.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",1,"The dependent API 'toShortString' is called with different arguments in late implementation (`toShortString(b, true, true, true)` instead of `toShortString(b, true, true)`), thus the change type is 4,5.","The dependent API changed with an additional argument in late implementation, which might potentially return a different value from the 'toString()' API, so CI type is 1."
204,"<android.view.View: Bitmap createSnapshot(Config,int,boolean)>",13,14,,,,"{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}","{
    int width = mRight - mLeft;
    int height = mBottom - mTop;
    final AttachInfo attachInfo = mAttachInfo;
    final float scale = attachInfo != null ? attachInfo.mApplicationScale : 1.0f;
    width = (int) ((width * scale) + 0.5f);
    height = (int) ((height * scale) + 0.5f);
    Bitmap bitmap = Bitmap.createBitmap(width > 0 ? width : 1, height > 0 ? height : 1, quality);
    if (bitmap == null) {
        throw new OutOfMemoryError();
    }
    Resources resources = getResources();
    if (resources != null) {
        bitmap.setDensity(resources.getDisplayMetrics().densityDpi);
    }
    Canvas canvas;
    if (attachInfo != null) {
        canvas = attachInfo.mCanvas;
        if (canvas == null) {
            canvas = new Canvas();
        }
        canvas.setBitmap(bitmap);
        // Temporarily clobber the cached Canvas in case one of our children
        // is also using a drawing cache. Without this, the children would
        // steal the canvas by attaching their own bitmap to it and bad, bad
        // things would happen (invisible views, corrupted drawings, etc.)
        attachInfo.mCanvas = null;
    } else {
        // This case should hopefully never or seldom happen
        canvas = new Canvas(bitmap);
    }
    if ((backgroundColor & 0xff000000) != 0) {
        bitmap.eraseColor(backgroundColor);
    }
    computeScroll();
    final int restoreCount = canvas.save();
    canvas.scale(scale, scale);
    canvas.translate(-mScrollX, -mScrollY);
    // Temporarily remove the dirty mask
    int flags = mPrivateFlags;
    mPrivateFlags &= ~DIRTY_MASK;
    // Fast path for layouts with no backgrounds
    if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
        dispatchDraw(canvas);
    } else {
        draw(canvas);
    }
    mPrivateFlags = flags;
    canvas.restoreToCount(restoreCount);
    canvas.setBitmap(null);
    if (attachInfo != null) {
        // Restore the cached Canvas for our siblings
        attachInfo.mCanvas = canvas;
    }
    return bitmap;
}",1,"/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
","/**
 * Create a snapshot of the view into a bitmap.  We should probably make
 * some form of this public, but should think about the API.
 */
",0,,,0,,,,,,,4,1,"The line `canvas.setBitmap(null);` has been added before the return statement in the late version, whereas the rest of the code remains the same. This is an other statement change, so the code change type is 4.","The newly added call to `canvas.setBitmap(null);` can alter the state of the `canvas` object which may affect subsequent operations performed on the same `canvas` object if it is reused elsewhere. This could potentially lead to a compatibility issue by altering the behavior of the subsequent use of the `canvas` object, so the CI type is 1."
205,<android.app.ContextImpl: boolean stopService(Intent)>,13,14,,,,"{
    try {
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    try {
        service.setAllowFds(false);
        int res = ActivityManagerNative.getDefault().stopService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (res < 0) {
            throw new SecurityException(""Not allowed to stop service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is a new method call to 'service.setAllowFds(false)' before the existing code; this is an addition of a new other statement hence, the change type is 4.","The addition of 'service.setAllowFds(false)' does not affect the return value or exception handling of the method 'stopService'. Therefore, there are no compatibility issues and the CI type is 0."
206,<android.database.BulkCursorProxy: boolean getWantsAllOnMoveCalls()>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    mRemote.transact(WANTS_ON_MOVE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    int result = reply.readInt();
    data.recycle();
    reply.recycle();
    return result != 0;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        mRemote.transact(WANTS_ON_MOVE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        int result = reply.readInt();
        return result != 0;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"2,3,4",0,"An exception handling statement has been introduced ('try' block), there is control dependency change with the addition of 'finally' block, and the code inside finally block for recycling parcels has changed its position from outside to inside the finally block. Hence, the code change types are 2 for adding the exception handling with 'try-finally', 3 for the control statement 'finally', and 4 for the change in the position of the recycle calls.","There is no Compatibility Issue due to this change, as the new implementation with the 'try-finally' blocks ensures that the Parcel objects are recycled in both normal operation and if an exception occurs, without altering the actual logic of the method. The method still reads an int from the Parcel and returns whether or not it is zero, which is the same behavior as before. Therefore, the CI type is 0."
207,<android.view.View: Matrix getMatrix()>,13,14,,,,"{
    updateMatrix();
    return mMatrix;
}","{
    if (mTransformationInfo != null) {
        updateMatrix();
        return mTransformationInfo.mMatrix;
    }
    return Matrix.IDENTITY_MATRIX;
}",1,"/**
 * The transform matrix of this view, which is calculated based on the current
 * roation, scale, and pivot properties.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The current transform matrix for the view
 */
","/**
 * The transform matrix of this view, which is calculated based on the current
 * roation, scale, and pivot properties.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The current transform matrix for the view
 */
",0,,,0,,,,,,,"1,3,4",1,"The return statement has changed, additional conditional checks and an alternative return path have been added, and the matrix that is returned has been moved to a member of `mTransformationInfo`. This involves changes in the control statement to include the null check for `mTransformationInfo` and a new variable being returned which is `mTransformationInfo.mMatrix` instead of `mMatrix`. Besides that, a new return Matrix.IDENTITY_MATRIX has been added for the situation where `mTransformationInfo` is `null`. Control dependency changed because of the added `if` statement, and other statement changed due to the new variable accessed and a new return path introduced. Hence, the change type includes 1, 3, and 4.","The new version adds a check for `mTransformationInfo` being `null` before updating and returning the matrix. In scenarios where `mTransformationInfo` is `null`, the method now returns `Matrix.IDENTITY_MATRIX` instead of the previous `mMatrix` (which could potentially be uninitialized or have a different value). Thus, the method could potentially return different values, which is indicative of a compatibility issue of type 1."
213,"<android.app.AlertDialog: int resolveDialogTheme(Context,int)>",13,14,,,,"{
    if (resid == THEME_TRADITIONAL) {
        return com.android.internal.R.style.Theme_Dialog_Alert;
    } else if (resid == THEME_HOLO_DARK) {
        return com.android.internal.R.style.Theme_Holo_Dialog_Alert;
    } else if (resid == THEME_HOLO_LIGHT) {
        return com.android.internal.R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (resid >= 0x01000000) {
        // start of real resource IDs.
        return resid;
    } else {
        TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(com.android.internal.R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}","{
    if (resid == THEME_TRADITIONAL) {
        return com.android.internal.R.style.Theme_Dialog_Alert;
    } else if (resid == THEME_HOLO_DARK) {
        return com.android.internal.R.style.Theme_Holo_Dialog_Alert;
    } else if (resid == THEME_HOLO_LIGHT) {
        return com.android.internal.R.style.Theme_Holo_Light_Dialog_Alert;
    } else if (resid == THEME_DEVICE_DEFAULT_DARK) {
        return com.android.internal.R.style.Theme_DeviceDefault_Dialog_Alert;
    } else if (resid == THEME_DEVICE_DEFAULT_LIGHT) {
        return com.android.internal.R.style.Theme_DeviceDefault_Light_Dialog_Alert;
    } else if (resid >= 0x01000000) {
        // start of real resource IDs.
        return resid;
    } else {
        TypedValue outValue = new TypedValue();
        context.getTheme().resolveAttribute(com.android.internal.R.attr.alertDialogTheme, outValue, true);
        return outValue.resourceId;
    }
}",1,,,0,,,0,,,,,,,"1,3",1,"Two new if-conditions (resid == THEME_DEVICE_DEFAULT_DARK and resid == THEME_DEVICE_DEFAULT_LIGHT) have been added to the early implementation, which constitutes a change in control dependencies (code change type 3) and additionally introduces new return statements (code change type 1).","The introduction of new conditions with their corresponding return statements can lead to different return values when the late version API is invoked with either of those new theme constants (THEME_DEVICE_DEFAULT_DARK or THEME_DEVICE_DEFAULT_LIGHT), resulting in a potential change in behavior of the API. Therefore, the CI type is 1."
214,"<android.widget.Gallery: void layout(int,boolean)>",13,14,,,,"{
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}","{
    mIsRtl = isLayoutRtl();
    int childrenLeft = mSpinnerPadding.left;
    int childrenWidth = mRight - mLeft - mSpinnerPadding.left - mSpinnerPadding.right;
    if (mDataChanged) {
        handleDataChanged();
    }
    // Handle an empty gallery by removing all views.
    if (mItemCount == 0) {
        resetList();
        return;
    }
    // Update to the new selected position.
    if (mNextSelectedPosition >= 0) {
        setSelectedPositionInt(mNextSelectedPosition);
    }
    // All views go in recycler while we are in layout
    recycleAllViews();
    // Clear out old views
    // removeAllViewsInLayout();
    detachAllViewsFromParent();
    /*
         * These will be used to give initial positions to views entering the
         * gallery as we scroll
         */
    mRightMost = 0;
    mLeftMost = 0;
    // Make selected view and center it
    /*
         * mFirstPosition will be decreased as we add views to the left later
         * on. The 0 for x will be offset in a couple lines down.
         */
    mFirstPosition = mSelectedPosition;
    View sel = makeAndAddView(mSelectedPosition, 0, 0, true);
    // Put the selected child in the center
    int selectedOffset = childrenLeft + (childrenWidth / 2) - (sel.getWidth() / 2);
    sel.offsetLeftAndRight(selectedOffset);
    fillToGalleryRight();
    fillToGalleryLeft();
    // Flush any cached views that did not get reused above
    mRecycler.clear();
    invalidate();
    checkSelectionChanged();
    mDataChanged = false;
    mNeedSync = false;
    setNextSelectedPositionInt(mSelectedPosition);
    updateSelectedItemMetadata();
}",1,"/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
","/**
 * Creates and positions all views for this Gallery.
 * <p>
 * We layout rarely, most of the time {@link #trackMotionScroll(int)} takes
 * care of repositioning, adding, and removing children.
 *
 * @param delta Change in the selected position. +1 means the selection is
 * moving to the right, so views are scrolling to the left. -1
 * means the selection is moving to the left.
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The only change in the late version is the addition of the line `mIsRtl = isLayoutRtl();`. This is considered an Other statement changed since it's not related to return statements, exception handling, control dependency changes, or dependent API changes.","There's no Compatibility Issue arising from this change, as the new statement only assigns a boolean value without affecting the behavior of the method (`layout(int, boolean)`) with regards to return values, control flows, or exceptions thrown, therefore the value of `pred_CI` should be 0."
216,<android.webkit.WebView: String findAddress(String)>,13,14,,,,"{
    return findAddress(addr, false);
}","{
    checkThread();
    return findAddress(addr, false);
}",1,"/**
 * Return the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * - a house number
 * - a street name
 * - a street type (Road, Circle, etc), either spelled out or abbreviated
 * - a city name
 * - a state or territory, either spelled out or two-letter abbr.
 * - an optional 5 digit or 9 digit zip code.
 *
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 * @param addr The string to search for addresses.
 *
 * @return the address, or if no address is found, return null.
 */
","/**
 * Return the first substring consisting of the address of a physical
 * location. Currently, only addresses in the United States are detected,
 * and consist of:
 * - a house number
 * - a street name
 * - a street type (Road, Circle, etc), either spelled out or abbreviated
 * - a city name
 * - a state or territory, either spelled out or two-letter abbr.
 * - an optional 5 digit or 9 digit zip code.
 *
 * All names must be correctly capitalized, and the zip code, if present,
 * must be valid for the state. The street type must be a standard USPS
 * spelling or abbreviation. The state or territory must also be spelled
 * or abbreviated using USPS standards. The house number may not exceed
 * five digits.
 * @param addr The string to search for addresses.
 *
 * @return the address, or if no address is found, return null.
 */
",0,,,0,,,,,,,4,0,"An additional method call 'checkThread()' is introduced before the existing return statement. This is an 'other statement' change, which is denoted as type 4.","The added 'checkThread()' method call does not directly affect the return value or the exception handling aspect of the method. It seems to be a check for thread safety or correct thread usage, so it introduces no compatibility issue, assuming this check does not result in a new kind of exception being thrown or the method exiting early. However, if 'checkThread()' throws a runtime exception for incorrect thread usage which was previously unchecked, it would introduce a compatibility issue, but the provided information does not indicate any exception being thrown. Therefore, based on the available information, the CI type is 0."
217,<android.widget.TextView: boolean bringPointIntoView(int)>,13,14,,,,"{
    boolean changed = false;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_NORMAL:
            grav = 1;
            break;
        case ALIGN_OPPOSITE:
            grav = -1;
            break;
        default:
            grav = 0;
    }
    grav *= mLayout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // This offsets because getInterestingRect() is in terms of
        // viewport coordinates, but requestRectangleOnScreen()
        // is in terms of content coordinates.
        Rect r = new Rect(x, top, x + 1, bottom);
        getInterestingRect(r, line);
        r.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(r)) {
            changed = true;
        }
    }
    return changed;
}","{
    boolean changed = false;
    if (mLayout == null)
        return changed;
    int line = mLayout.getLineForOffset(offset);
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) mLayout.getPrimaryHorizontal(offset);
    final int top = mLayout.getLineTop(line);
    final int bottom = mLayout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(mLayout.getLineLeft(line));
    int right = (int) FloatMath.ceil(mLayout.getLineRight(line));
    int ht = mLayout.getHeight();
    int grav;
    switch(mLayout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = mLayout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -mLayout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        if (mTempRect == null)
            mTempRect = new Rect();
        // The offsets here are to ensure the rectangle we are using is
        // within our view bounds, in case the cursor is on the far left
        // or right.  If it isn't withing the bounds, then this request
        // will be ignored.
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}",1,"/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
","/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */
",0,,,0,,,,,,,,,,
218,<android.appwidget.AppWidgetManager: AppWidgetProviderInfo getAppWidgetInfo(int)>,13,14,,,,"{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
","/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */
",0,,,0,,,,,,,4,0,"In the late version implementation, two additional lines of code are modifying the fields `info.minResizeWidth` and `info.minResizeHeight` using `TypedValue.complexToDimensionPixelSize()` which did not exist in the early version. These lines are neither return statements nor exception handling statements, nor do they indicate a change in control flow or the use of a different dependent API. Therefore, this is classified as an ""Other statement changed.""","Despite the change in mutating additional fields of `AppWidgetProviderInfo`, there is no change to the return type or value of the API method itself. It still returns `AppWidgetProviderInfo` with potentially modified properties; hence, no Compatibility Issue arises due to this change. The clients that use this API will receive an `AppWidgetProviderInfo` object with additional initialized fields, but this does not change the contract of how this method is used or the type of object returned. Thus, it's a non-breaking, backward-compatible change."
219,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: RemoteViews getLoadingView()>,13,14,,,,"{
    return mFactory.getLoadingView();
}","{
    RemoteViews rv = null;
    try {
        rv = mFactory.getLoadingView();
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return rv;
}",1,,,0,,,0,,,,,,,"1,2,3,4","1,2","The implementation has introduced try-catch blocks which change exception handling, a new local variable initialization, and the control dependency has been changed due to the try-catch block. The default return value has been changed from an implicit `null` or `mFactory.getLoadingView()` result to an explicit `null` assigned to `rv`. So, the code change types are 1,2,3,4.","The introduction of the try-catch block that catches any Exception and handles it with the default uncaught exception handler could potentially change the exceptions thrown by the method. Instead of potentially propagating an exception to the caller, it is now being caught and processed by the default uncaught exception handler which may alter the program's behavior significantly. Moreover, because the method now always returns `rv` which is initialized to `null`, there is a potential change in the return value, especially in situations where `mFactory.getLoadingView()` used to throw an exception that is now being caught. Therefore, the CI types are 1,2."
220,"<android.webkit.WebTextView: void onTextChanged(CharSequence,int,int,int)>",13,14,,,,"{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    mPreChange = postChange;
    if (0 == count) {
        if (before > 0) {
            // For this and all changes to the text, update our cache
            updateCachedTextfield();
            if (mGotDelete) {
                mGotDelete = false;
                int oldEnd = start + before;
                if (mDelSelEnd == oldEnd && (mDelSelStart == start || (mDelSelStart == oldEnd && before == 1))) {
                    // If the selection is set up properly before the
                    // delete, send the DOM events.
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL));
                    return;
                }
            }
            // This was simply a delete or a cut, so just delete the
            // selection.
            mWebView.deleteSelection(start, start + before);
        }
        mGotDelete = false;
        // changed, we should return.
        return;
    }
    // Ensure that this flag gets cleared, since with autocorrect on, a
    // delete key press may have a more complex result than deleting one
    // character or the existing selection, so it will not get cleared
    // above.
    mGotDelete = false;
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native (after replacing the beginning
    // of the changed text), so we can see javascript events.
    // Otherwise, replace the text being changed (including the last
    // character) in the textfield.
    TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
    KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
    KeyEvent[] events = kmap.getEvents(mCharacter);
    boolean cannotUseKeyEvents = null == events;
    int charactersFromKeyEvents = cannotUseKeyEvents ? 0 : 1;
    if (count > 1 || cannotUseKeyEvents) {
        String replace = s.subSequence(start, start + count - charactersFromKeyEvents).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count - charactersFromKeyEvents, start + count - charactersFromKeyEvents);
    } else {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
    }
    if (!cannotUseKeyEvents) {
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    }
    updateCachedTextfield();
}","{
    super.onTextChanged(s, start, before, count);
    String postChange = s.toString();
    // limit on text length from registering the onTextChanged event.
    if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0, mMaxLength).equals(postChange))) {
        return;
    }
    mPreChange = postChange;
    if (0 == count) {
        if (before > 0) {
            // For this and all changes to the text, update our cache
            updateCachedTextfield();
            if (mGotDelete) {
                mGotDelete = false;
                int oldEnd = start + before;
                if (mDelSelEnd == oldEnd && (mDelSelStart == start || (mDelSelStart == oldEnd && before == 1))) {
                    // If the selection is set up properly before the
                    // delete, send the DOM events.
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
                    sendDomEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL));
                    return;
                }
            }
            // This was simply a delete or a cut, so just delete the
            // selection.
            mWebView.deleteSelection(start, start + before);
        }
        mGotDelete = false;
        // changed, we should return.
        return;
    }
    // Ensure that this flag gets cleared, since with autocorrect on, a
    // delete key press may have a more complex result than deleting one
    // character or the existing selection, so it will not get cleared
    // above.
    mGotDelete = false;
    // don't replace the unchanged text.
    if (count > 1 && before == count - 1) {
        String replaceButOne = s.subSequence(start, start + before).toString();
        String replacedString = getText().subSequence(start, start + before).toString();
        if (replaceButOne.equals(replacedString)) {
            // we're just adding one character
            start += before;
            before = 0;
            count = 1;
        }
    }
    // Find the last character being replaced.  If it can be represented by
    // events, we will pass them to native so we can see javascript events.
    // Otherwise, replace the text being changed in the textfield.
    KeyEvent[] events = null;
    if (count == 1) {
        TextUtils.getChars(s, start + count - 1, start + count, mCharacter, 0);
        KeyCharacterMap kmap = KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
        events = kmap.getEvents(mCharacter);
    }
    boolean useKeyEvents = (events != null);
    if (useKeyEvents) {
        // trackball or auto-correct.
        if (DebugFlags.WEB_TEXT_VIEW) {
            Log.v(LOGTAG, ""onTextChanged start="" + start + "" start + before="" + (start + before));
        }
        if (!mInSetTextAndKeepSelection) {
            mWebView.setSelection(start, start + before);
        }
        int length = events.length;
        for (int i = 0; i < length; i++) {
            // here either.
            if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
                sendDomEvent(events[i]);
            }
        }
    } else {
        String replace = s.subSequence(start, start + count).toString();
        mWebView.replaceTextfieldText(start, start + before, replace, start + count, start + count);
    }
    updateCachedTextfield();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
221,"<android.preference.PreferenceScreen: void onItemClick(AdapterView,View,int,long)>",13,14,,,,"{
    Object item = getRootAdapter().getItem(position);
    if (!(item instanceof Preference))
        return;
    final Preference preference = (Preference) item;
    preference.performClick(this);
}","{
    // If the list has headers, subtract them from the index.
    if (parent instanceof ListView) {
        position -= ((ListView) parent).getHeaderViewsCount();
    }
    Object item = getRootAdapter().getItem(position);
    if (!(item instanceof Preference))
        return;
    final Preference preference = (Preference) item;
    preference.performClick(this);
}",1,,,0,,,0,,,,,,,3,0,"The added code adjusts the 'position' based on the number of header views in a ListView. It does not affect any return statements, exception handling, or the result of 'preference.performClick(this)'. The code change type is 3, as it reflects a change in the control dependency due to the introduction of a new conditional block that adjusts the 'position'.","This change does not cause a Compatibility Issue because it adjusts 'position' for header views, which is essentially a bug fix to ensure that the correct item is passed to 'getRootAdapter().getItem(position)'. The behavior post this change aligns with the expected behavior pre-change when there are no header views. It does not lead to any change in the API's return type, returned value, or thrown exceptions under normal operation."
224,<android.speech.tts.TextToSpeech: void shutdown()>,13,14,,,,"{
    try {
        mContext.unbindService(mServiceConnection);
    } catch (IllegalArgumentException e) {
    // Do nothing and fail silently since an error here indicates that
    // binding never succeeded in the first place.
    }
}","{
    runActionNoReconnect(new Action<Void>() {

        @Override
        public Void run(ITextToSpeechService service) throws RemoteException {
            service.setCallback(getPackageName(), null);
            service.stop(getPackageName());
            mServiceConnection.disconnect();
            // Context#unbindService does not result in a call to
            // ServiceConnection#onServiceDisconnected. As a result, the
            // service ends up being destroyed (if there are no other open
            // connections to it) but the process lives on and the
            // ServiceConnection continues to refer to the destroyed service.
            // 
            // This leads to tons of log spam about SynthThread being dead.
            mServiceConnection = null;
            mCurrentEngine = null;
            return null;
        }
    }, null, ""shutdown"");
}",1,"/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
","/**
 * Releases the resources used by the TextToSpeech engine.
 * It is good practice for instance to call this method in the onDestroy() method of an Activity
 * so the TextToSpeech engine can be cleanly stopped.
 */
",0,,,0,,,,,,,4,0,"The early version implementation involved directly unbinding from the service, surrounded by a try-catch block to handle potential IllegalArgumentException. In contrast, the late version uses a method 'runActionNoReconnect' that encapsulates the service stop actions and sets callbacks to null, among other things. However, it fundamentally does not change the behavior of the method as it still attempts to shut down the connection to the TextToSpeech service.","There is no Compatibility Issue introduced by this change. The late version's use of 'runActionNoReconnect' encapsulates the unbinding logic, but the try-catch block handling IllegalArgumentException in the early version already fails silently. The new version ensures callbacks are null and stops the service in a more controlled manner with 'setCallback' and 'stop', and also sets the connection to null to avoid the log spam. It does not fundamentally alter the behavior an app would expect from a call to 'shutdown', which is to shut down the TextToSpeech service connection. Therefore, the shutdown process still completes as expected in the late version, resulting in no Compatibility Issue."
225,"<android.content.res.AssetManager: boolean getThemeValue(int,int,TypedValue,boolean)>",13,14,,,,"{
    int block = loadThemeAttributeValue(theme, ident, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        StringBlock[] blocks = mStringBlocks;
        if (blocks == null) {
            ensureStringBlocks();
        }
        outValue.string = blocks[block].get(outValue.data);
        return true;
    }
    return false;
}","{
    int block = loadThemeAttributeValue(theme, ident, outValue, resolveRefs);
    if (block >= 0) {
        if (outValue.type != TypedValue.TYPE_STRING) {
            return true;
        }
        StringBlock[] blocks = mStringBlocks;
        if (blocks == null) {
            ensureStringBlocks();
            blocks = mStringBlocks;
        }
        outValue.string = blocks[block].get(outValue.data);
        return true;
    }
    return false;
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"3,4",0,"The late version includes an assignment `blocks = mStringBlocks;` after the `ensureStringBlocks();` call, which is not present in the early version. This is a change related to variable assignments within a control block (within the `if` statement checking `blocks == null`), so the code change type is 3,4.","There is no Compatibility Issue because the new assignment makes no semantic difference. The `ensureStringBlocks()` method is expected to initialize `mStringBlocks`, and after that, `blocks` references the same `mStringBlocks`. Thus, the API's behavior remains unchanged before and after this code was introduced."
227,<android.webkit.WebView: void onDraw(Canvas)>,13,14,,,,"{
    // if mNativeClass is 0, the WebView has been destroyed. Do nothing.
    if (mNativeClass == 0) {
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    if (canvas.isHardwareAccelerated()) {
        mZoomManager.setHardwareAccelerated();
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
        canvas.translate(0, getTitleHeight());
    }
    drawContent(canvas);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    if (inEditingMode()) {
        mWebTextView.onDrawSubstitute();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
        invalidate();
    }
    // paint the highlight in the end
    if (!mTouchHighlightRegion.isEmpty()) {
        if (mTouchHightlightPaint == null) {
            mTouchHightlightPaint = new Paint();
            mTouchHightlightPaint.setColor(mHightlightColor);
            mTouchHightlightPaint.setAntiAlias(true);
            mTouchHightlightPaint.setPathEffect(new CornerPathEffect(TOUCH_HIGHLIGHT_ARC));
        }
        canvas.drawPath(mTouchHighlightRegion.getBoundaryPath(), mTouchHightlightPaint);
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
        if (getSettings().getNavDump()) {
            if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                if (mTouchCrossHairColor == null) {
                    mTouchCrossHairColor = new Paint();
                    mTouchCrossHairColor.setColor(Color.RED);
                }
                canvas.drawLine(mTouchHighlightX - mNavSlop, mTouchHighlightY - mNavSlop, mTouchHighlightX + mNavSlop + 1, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
                canvas.drawLine(mTouchHighlightX + mNavSlop + 1, mTouchHighlightY - mNavSlop, mTouchHighlightX - mNavSlop, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
            }
        }
    }
}","{
    // initialized. In either case, just draw the background color and return
    if (mNativeClass == 0) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    // just starts. Draw the background and return.
    if ((mContentWidth | mContentHeight) == 0 && mHistoryPicture == null) {
        canvas.drawColor(mBackgroundColor);
        return;
    }
    if (canvas.isHardwareAccelerated()) {
        mZoomManager.setHardwareAccelerated();
    }
    int saveCount = canvas.save();
    if (mInOverScrollMode && !getSettings().getUseWebViewBackgroundForOverscrollBackground()) {
        drawOverScrollBackground(canvas);
    }
    if (mTitleBar != null) {
        canvas.translate(0, getTitleHeight());
    }
    boolean drawJavaRings = !mTouchHighlightRegion.isEmpty() && (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_DONE_MODE);
    boolean drawNativeRings = !drawJavaRings;
    if (USE_WEBKIT_RINGS) {
        drawNativeRings = !drawJavaRings && !isInTouchMode();
    }
    drawContent(canvas, drawNativeRings);
    canvas.restoreToCount(saveCount);
    if (AUTO_REDRAW_HACK && mAutoRedraw) {
        invalidate();
    }
    mWebViewCore.signalRepaintDone();
    if (mOverScrollGlow != null && mOverScrollGlow.drawEdgeGlows(canvas)) {
        invalidate();
    }
    // paint the highlight in the end
    if (drawJavaRings) {
        long delay = System.currentTimeMillis() - mTouchHighlightRequested;
        if (delay < ViewConfiguration.getTapTimeout()) {
            Rect r = mTouchHighlightRegion.getBounds();
            postInvalidateDelayed(delay, r.left, r.top, r.right, r.bottom);
        } else {
            if (mTouchHightlightPaint == null) {
                mTouchHightlightPaint = new Paint();
                mTouchHightlightPaint.setColor(HIGHLIGHT_COLOR);
            }
            RegionIterator iter = new RegionIterator(mTouchHighlightRegion);
            Rect r = new Rect();
            while (iter.next(r)) {
                canvas.drawRect(r, mTouchHightlightPaint);
            }
        }
    }
    if (DEBUG_TOUCH_HIGHLIGHT) {
        if (getSettings().getNavDump()) {
            if ((mTouchHighlightX | mTouchHighlightY) != 0) {
                if (mTouchCrossHairColor == null) {
                    mTouchCrossHairColor = new Paint();
                    mTouchCrossHairColor.setColor(Color.RED);
                }
                canvas.drawLine(mTouchHighlightX - mNavSlop, mTouchHighlightY - mNavSlop, mTouchHighlightX + mNavSlop + 1, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
                canvas.drawLine(mTouchHighlightX + mNavSlop + 1, mTouchHighlightY - mNavSlop, mTouchHighlightX - mNavSlop, mTouchHighlightY + mNavSlop + 1, mTouchCrossHairColor);
            }
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
231,"<android.app.ContextImpl: void sendStickyOrderedBroadcast(Intent,BroadcastReceiver,Handler,int,String,Bundle)>",13,14,,,,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, null, true, true);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change is an additional method call `intent.setAllowFds(false);`, which is an 'Other statement changed' situation, so the code change type is 4.","This additional method call is used to modify the 'intent' by setting a property, which does not inherently change the method return type, value, or exception handling. Assuming `setAllowFds(false)` does not throw an unchecked exception, it is unlikely to introduce a compatibility issue as it doesn't change the structure of the method control flow or result in new exceptions that need to be handled. Therefore, no compatibility issue is detected, with the type being 0."
232,<android.server.BluetoothService: int getScanMode()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return BluetoothAdapter.SCAN_MODE_NONE;
    boolean pairable = getProperty(""Pairable"").equals(""true"");
    boolean discoverable = getProperty(""Discoverable"").equals(""true"");
    return bluezStringToScanMode(pairable, discoverable);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return BluetoothAdapter.SCAN_MODE_NONE;
    boolean pairable = getProperty(""Pairable"", true).equals(""true"");
    boolean discoverable = getProperty(""Discoverable"", true).equals(""true"");
    return bluezStringToScanMode(pairable, discoverable);
}",1,,,0,,,0,,,,,,,5,0,The dependent API 'getProperty' has its parameter list changed from single to double parameters so the change type is 5.,"There is no Compatibility Issue since default values are provided for the 'getProperty' method, thus ensuring that the return value remains consistent with the previous version. The addition of default values is a backward-compatible change that would not affect the behavior of 'getScanMode()' as long as the 'getProperty' method handles default values appropriately."
233,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: long getItemId(int)>,13,14,,,,"{
    return mFactory.getItemId(position);
}","{
    long id = 0;
    try {
        id = mFactory.getItemId(position);
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return id;
}",1,,,0,,,0,,,,,,,"2,4","1,2","An exception handling statement has been introduced along with an initialization of the variable 'id' to 0, so the code change type is 2 for the exception handling change, and 4 for the other statement change (i.e., the initialization of 'id').","There is a potential Compatibility Issue as the introduction of the try-catch block may lead to different behavior in exception cases. Previously uncaught exceptions would propagate up the call stack, which may lead to application crash or further handling at a higher level. In the late version, all exceptions are caught and processed within the method, possibly changing the application's behavior by returning a default id (0) on exception instead of terminating. Therefore, there could be a Compatibility Issue due to both potential differences in return values (CI type 1) and differences in exception handling (CI type 2)."
234,"<android.view.GLES20Canvas: int saveLayerAlpha(RectF,int,int)>",13,14,,,,"{
    return saveLayerAlpha(bounds.left, bounds.top, bounds.right, bounds.bottom, alpha, saveFlags);
}","{
    if (bounds != null) {
        return saveLayerAlpha(bounds.left, bounds.top, bounds.right, bounds.bottom, alpha, saveFlags);
    }
    return nSaveLayerAlpha(mRenderer, alpha, saveFlags);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The late version introduces a new conditional check `if (bounds != null)` before calling saveLayerAlpha with parameters derived from bounds. There is also a new return statement `return nSaveLayerAlpha(mRenderer, alpha, saveFlags)` for the null case, so this is categorized as a control dependency change and a return statement change.","The additional null check for `bounds` and a new return statement when `bounds` is null can lead to a different return value in cases where bounds is indeed null. Therefore, it can cause a different behavior and thus it's a compatibility issue."
241,"<android.view.View: View findUserSetNextFocus(View,int)>",13,14,,,,"{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                final int id = mID;
                return root.findViewByPredicate(new Predicate<View>() {

                    @Override
                    public boolean apply(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}","{
    switch(direction) {
        case FOCUS_LEFT:
            if (mNextFocusLeftId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusLeftId);
        case FOCUS_RIGHT:
            if (mNextFocusRightId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusRightId);
        case FOCUS_UP:
            if (mNextFocusUpId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusUpId);
        case FOCUS_DOWN:
            if (mNextFocusDownId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusDownId);
        case FOCUS_FORWARD:
            if (mNextFocusForwardId == View.NO_ID)
                return null;
            return findViewInsideOutShouldExist(root, mNextFocusForwardId);
        case FOCUS_BACKWARD:
            {
                final int id = mID;
                return root.findViewByPredicateInsideOut(this, new Predicate<View>() {

                    @Override
                    public boolean apply(View t) {
                        return t.mNextFocusForwardId == id;
                    }
                });
            }
    }
    return null;
}",1,"/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
","/**
 * If a user manually specified the next view id for a particular direction,
 * use the root to look up the view.
 * @param root The root view of the hierarchy containing this view.
 * @param direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD,
 * or FOCUS_BACKWARD.
 * @return The user specified next view, or null if there is none.
 */
",0,,,0,,,,,,,"4,5",1,"The dependent API `findViewShouldExist` has been changed to `findViewInsideOutShouldExist`, and in the case `FOCUS_BACKWARD`, the API `findViewByPredicate` has been changed to `findViewByPredicateInsideOut`, so the code change types are 4 and 5.","The change in the method used to find the view (`findViewShouldExist` to `findViewInsideOutShouldExist`, `findViewByPredicate` to `findViewByPredicateInsideOut`) means that the API might return a different view than it would previously, causing a potential change in behavior, so the CI type is 1."
243,"<android.view.ViewDebug: void startHierarchyTracing(String,View)>",13,14,,,,"{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_HIERARCHY) {
        return;
    }
    if (sHierarhcyRoot != null) {
        throw new IllegalStateException(""You must call stopHierarchyTracing() before running"" + "" a new trace!"");
    }
    File hierarchyDump = new File(Environment.getExternalStorageDirectory(), ""view-hierarchy/"");
    // noinspection ResultOfMethodCallIgnored
    hierarchyDump.mkdirs();
    hierarchyDump = new File(hierarchyDump, prefix + "".traces"");
    sHierarchyTracePrefix = prefix;
    try {
        sHierarchyTraces = new BufferedWriter(new FileWriter(hierarchyDump), 8 * 1024);
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump view hierarchy"");
        return;
    }
    sHierarhcyRoot = (ViewRoot) view.getRootView().getParent();
}","{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_HIERARCHY) {
        return;
    }
    if (sHierarhcyRoot != null) {
        throw new IllegalStateException(""You must call stopHierarchyTracing() before running"" + "" a new trace!"");
    }
    File hierarchyDump = new File(Environment.getExternalStorageDirectory(), ""view-hierarchy/"");
    // noinspection ResultOfMethodCallIgnored
    hierarchyDump.mkdirs();
    hierarchyDump = new File(hierarchyDump, prefix + "".traces"");
    sHierarchyTracePrefix = prefix;
    try {
        sHierarchyTraces = new BufferedWriter(new FileWriter(hierarchyDump), 8 * 1024);
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump view hierarchy"");
        return;
    }
    sHierarhcyRoot = (ViewRootImpl) view.getRootView().getParent();
}",1,"/**
 * Starts tracing the view hierarchy of the specified view. The trace is identified by a prefix,
 * used to build the traces files names: <code>/EXTERNAL/view-hierarchy/PREFIX.traces</code> and
 * <code>/EXTERNAL/view-hierarchy/PREFIX.tree</code>.
 *
 * Only one view hierarchy can be traced at the same time. After calling this method, any
 * other invocation will result in a <code>IllegalStateException</code> unless
 * {@link #stopHierarchyTracing()} is invoked before.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-hierarchy/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's hierarchy.
 *
 * This method will return immediately if TRACE_HIERARCHY is false.
 *
 * @param prefix the traces files name prefix
 * @param view the view whose hierarchy must be traced
 *
 * @see #stopHierarchyTracing()
 * @see #trace(View, android.view.ViewDebug.HierarchyTraceType)
 */
","/**
 * Starts tracing the view hierarchy of the specified view. The trace is identified by a prefix,
 * used to build the traces files names: <code>/EXTERNAL/view-hierarchy/PREFIX.traces</code> and
 * <code>/EXTERNAL/view-hierarchy/PREFIX.tree</code>.
 *
 * Only one view hierarchy can be traced at the same time. After calling this method, any
 * other invocation will result in a <code>IllegalStateException</code> unless
 * {@link #stopHierarchyTracing()} is invoked before.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-hierarchy/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's hierarchy.
 *
 * This method will return immediately if TRACE_HIERARCHY is false.
 *
 * @param prefix the traces files name prefix
 * @param view the view whose hierarchy must be traced
 *
 * @see #stopHierarchyTracing()
 * @see #trace(View, android.view.ViewDebug.HierarchyTraceType)
 */
",0,,,0,,,,,,,"4,5",0,"The only change in the code is the cast from (ViewRoot) to (ViewRootImpl). This indicates an expected type change, suggesting a modification in the dependent API or in the class hierarchy, which makes it a change of type 4 and 5.","The modification does not affect the return value or exception handling of the method because the method still doesn't return any value and there is no change in exceptions being thrown. Hence, there is no compatibility issue regarding different return values or exception handlings. Thus, the CI is of type 0."
245,"<android.database.CursorWindow: boolean isBlob(int,int)>",13,14,,,,"{
    int type = getType(row, col);
    return type == Cursor.FIELD_TYPE_BLOB || type == Cursor.FIELD_TYPE_NULL;
}","{
    int type = getType(row, column);
    return type == Cursor.FIELD_TYPE_BLOB || type == Cursor.FIELD_TYPE_NULL;
}",1,"/**
 * Checks if a field contains either a blob or is null.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return {@code true} if given field is {@code NULL} or a blob
 * @deprecated use {@link #getType(int, int)} instead
 */
","/**
 * Returns true if the field at the specified row and column index
 * has type {@link Cursor#FIELD_TYPE_BLOB} or {@link Cursor#FIELD_TYPE_NULL}.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if the field has type {@link Cursor#FIELD_TYPE_BLOB} or
 * {@link Cursor#FIELD_TYPE_NULL}.
 * @deprecated Use {@link #getType(int, int)} instead.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,"There are no changes in the implementation between the early and late versions, they just renamed the variable in the method signature from 'col' to 'column', which does not affect the code within the method body.","Since there is no actual change in the code and the behavior of the API remains consistent, there is no compatibility issue."
248,"<android.server.BluetoothBondState: void setBondState(String,int,int)>",13,14,,,,"{
    int oldState = getBondState(address);
    if (oldState == state) {
        return;
    }
    // If yes, reset the state.
    if (oldState == BluetoothDevice.BOND_BONDING) {
        if (address.equals(mPendingOutgoingBonding)) {
            mPendingOutgoingBonding = null;
        }
    }
    if (state == BluetoothDevice.BOND_BONDED) {
        mService.addProfileState(address);
    } else if (state == BluetoothDevice.BOND_NONE) {
        mService.removeProfileState(address);
    }
    // HID is handled by BluetoothService, other profiles
    // will be handled by their respective services.
    mBluetoothInputProfileHandler.setInitialInputDevicePriority(mService.getRemoteDevice(address), state);
    if (DBG) {
        Log.d(TAG, address + "" bond state "" + oldState + "" -> "" + state + "" ("" + reason + "")"");
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mService.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
    if (state == BluetoothDevice.BOND_NONE) {
        if (reason <= 0) {
            Log.w(TAG, ""setBondState() called to unbond device, but reason code is "" + ""invalid. Overriding reason code with BOND_RESULT_REMOVED"");
            reason = BluetoothDevice.UNBOND_REASON_REMOVED;
        }
        intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
        mState.remove(address);
    } else {
        mState.put(address, state);
    }
    mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
}","{
    if (DBG)
        Log.d(TAG, ""setBondState "" + ""address"" + "" "" + state + ""reason: "" + reason);
    int oldState = getBondState(address);
    if (oldState == state) {
        return;
    }
    // If yes, reset the state.
    if (oldState == BluetoothDevice.BOND_BONDING) {
        if (address.equals(mPendingOutgoingBonding)) {
            mPendingOutgoingBonding = null;
        }
    }
    if (state == BluetoothDevice.BOND_BONDED) {
        boolean setTrust = false;
        if (mPairingRequestRcvd.contains(address))
            setTrust = true;
        mService.addProfileState(address, setTrust);
        mPairingRequestRcvd.remove(address);
    } else if (state == BluetoothDevice.BOND_BONDING) {
        if (mA2dpProxy == null || mHeadsetProxy == null) {
            getProfileProxy();
        }
    } else if (state == BluetoothDevice.BOND_NONE) {
        mPairingRequestRcvd.remove(address);
    }
    setProfilePriorities(address, state);
    if (DBG) {
        Log.d(TAG, address + "" bond state "" + oldState + "" -> "" + state + "" ("" + reason + "")"");
    }
    Intent intent = new Intent(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mService.getRemoteDevice(address));
    intent.putExtra(BluetoothDevice.EXTRA_BOND_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, oldState);
    if (state == BluetoothDevice.BOND_NONE) {
        if (reason <= 0) {
            Log.w(TAG, ""setBondState() called to unbond device, but reason code is "" + ""invalid. Overriding reason code with BOND_RESULT_REMOVED"");
            reason = BluetoothDevice.UNBOND_REASON_REMOVED;
        }
        intent.putExtra(BluetoothDevice.EXTRA_REASON, reason);
        mState.remove(address);
    } else {
        mState.put(address, state);
    }
    mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
}",1,"/**
 * reason is ignored unless state == BOND_NOT_BONDED
 */
","/**
 * reason is ignored unless state == BOND_NOT_BONDED
 */
",0,,,0,,,,,,,"3,4",0,"The change consists of restructuring conditionals and introducing a new variable setTrust in the late version as well as the removal of code related to mBluetoothInputProfileHandler.setInitialInputDevicePriority(...). A debug log statement was added at the beginning, the call to mService.addProfileState now includes an additional parameter, and conditional logic was added for BOND_BONDING and BOND_NONE states. There is also a new call to a method called 'setProfilePriorities' and several changes in the handling of mPairingRequestRcvd. These changes are considered as control dependency changes and other statement changes.","Despite the changes made to the implementation, no compatibility issue is expected to arise as a result. This is because the interface signature hasn't changed, and none of the modifications lead to a change in the API's return value or throw a new kind of exception; all handled exceptions remain within the method, and the method's return value is void, indicating that the method's external behavior, in terms of return types or thrown exceptions, remains consistent with the previous version."
252,"<android.app.PendingIntent: void send(Context,int,Intent,OnFinished,Handler)>",13,14,,,,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null);
        if (res < 0) {
            throw new CanceledException();
        }
    } catch (RemoteException e) {
        throw new CanceledException(e);
    }
}","{
    send(context, code, intent, onFinished, handler, null);
}",1,"/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this PendingIntent, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * <p>For the intent parameter, a PendingIntent
 * often has restrictions on which fields can be supplied here, based on
 * how the PendingIntent was retrieved in {@link #getActivity},
 * {@link #getBroadcast}, or {@link #getService}.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the PendingIntent's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 *
 * @see #send()
 * @see #send(int)
 * @see #send(Context, int, Intent)
 * @see #send(int, android.app.PendingIntent.OnFinished, Handler)
 * @see #send(Context, int, Intent, OnFinished, Handler, String)
 *
 * @throws CanceledException Throws CanceledException if the PendingIntent
 * is no longer allowing more intents to be sent through it.
 */
",1,,,0,,,,,,,"4,5",0,"The implementation has been changed to delegate the work to another overload of the send method with an additional null argument; the body of the early implementation is no longer present and has been replaced with a method call. Thus, the code change here is 4 for the change in the method body, and 5 for the change in the dependent API call.","There is no Compatibility Issue because the logic encapsulated within the method implementation has been moved to an overloaded version of the same method. This overloaded method should handle the logic previously defined in the early version's method body. Assuming the overloaded method maintains consistent behavior, the method's contract remains the same from the caller's perspective, even though the implementation has changed."
253,"<android.widget.QuickContactBadge.QueryHandler: void onQueryComplete(int,Object,Cursor)>",13,14,,,,"{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_CONTACT_LOOKUP_AND_TRIGGER:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(CONTACT_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(CONTACT_LOOKUPKEY_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                        trigger = true;
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger track
        trigger(lookupUri);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}","{
    Uri lookupUri = null;
    Uri createUri = null;
    boolean trigger = false;
    try {
        switch(token) {
            case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""tel"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_PHONE_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(PHONE_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
            case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
                trigger = true;
                createUri = Uri.fromParts(""mailto"", (String) cookie, null);
            // $FALL-THROUGH$
            case TOKEN_EMAIL_LOOKUP:
                {
                    if (cursor != null && cursor.moveToFirst()) {
                        long contactId = cursor.getLong(EMAIL_ID_COLUMN_INDEX);
                        String lookupKey = cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
                        lookupUri = Contacts.getLookupUri(contactId, lookupKey);
                    }
                    break;
                }
        }
    } finally {
        if (cursor != null) {
            cursor.close();
        }
    }
    mContactUri = lookupUri;
    onContactUriChanged();
    if (trigger && lookupUri != null) {
        // Found contact, so trigger QuickContact
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (createUri != null) {
        // Prompt user to add this person to contacts
        final Intent intent = new Intent(Intents.SHOW_OR_CREATE_CONTACT, createUri);
        getContext().startActivity(intent);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The case `TOKEN_CONTACT_LOOKUP_AND_TRIGGER` has been removed in the switch control structure, and the logic associated with triggering contact lookup has been modified. Instead of the previous `trigger(lookupUri);`, the late version uses `QuickContact.showQuickContact(getContext(), QuickContactBadge.this, lookupUri, QuickContact.MODE_LARGE, mExcludeMimes);`. These are classified as both control dependency changes (due to removal of the case) and other statement changes (due to change in the method of triggering QuickContact).","There is no Compatibility Issue because nothing in the altered or removed code paths suggests that the API will behave differently in terms of its contract. The method does not return a value (void return type), and the exception handling remains the same. The changes are internal to the method's implementation and do not affect its external behavior; the method's contract still behaves the same way for the client code, as it relates to finding and triggering the contact information display. As there are no changes that could lead to different return values or exceptions thrown, the type is 0."
255,<android.widget.AbsSeekBar: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            setPressed(true);
            onStartTrackingTouch();
            trackTouchEvent(event);
            break;
        case MotionEvent.ACTION_MOVE:
            trackTouchEvent(event);
            attemptClaimDrag();
            break;
        case MotionEvent.ACTION_UP:
            trackTouchEvent(event);
            onStopTrackingTouch();
            setPressed(false);
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            onStopTrackingTouch();
            setPressed(false);
            // see above explanation
            invalidate();
            break;
    }
    return true;
}","{
    if (!mIsUserSeekable || !isEnabled()) {
        return false;
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            if (isInScrollingContainer()) {
                mTouchDownX = event.getX();
            } else {
                setPressed(true);
                if (mThumb != null) {
                    // This may be within the padding region
                    invalidate(mThumb.getBounds());
                }
                onStartTrackingTouch();
                trackTouchEvent(event);
                attemptClaimDrag();
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mIsDragging) {
                trackTouchEvent(event);
            } else {
                final float x = event.getX();
                if (Math.abs(x - mTouchDownX) > mScaledTouchSlop) {
                    setPressed(true);
                    if (mThumb != null) {
                        // This may be within the padding region
                        invalidate(mThumb.getBounds());
                    }
                    onStartTrackingTouch();
                    trackTouchEvent(event);
                    attemptClaimDrag();
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsDragging) {
                trackTouchEvent(event);
                onStopTrackingTouch();
                setPressed(false);
            } else {
                // Touch up when we never crossed the touch slop threshold should
                // be interpreted as a tap-seek to that location.
                onStartTrackingTouch();
                trackTouchEvent(event);
                onStopTrackingTouch();
            }
            // ProgressBar doesn't know to repaint the thumb drawable
            // in its inactive state when the touch stops (because the
            // value has not apparently changed)
            invalidate();
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsDragging) {
                onStopTrackingTouch();
                setPressed(false);
            }
            // see above explanation
            invalidate();
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",1,"There are control dependency changes within the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_MOVE cases, and other changes include adding new variables and conditional checks for thumb drawable invalidation and drag detection, so the code change type is 3,4.","The behavior of the MotionEvent.ACTION_DOWN and MotionEvent.ACTION_MOVE cases have been significantly altered by the introduction of new conditionals and state changes such as checking for dragging and the distance moved. These changes can lead to different return values when touch events are processed, particularly because the conditions for engaging drag behavior and redrawing the thumb drawable have changed. Hence, the CI type is 1."
257,<android.view.HardwareRenderer.GlRenderer: boolean initialize(SurfaceHolder)>,13,14,,,,"{
    if (isRequested() && !isEnabled()) {
        initializeEgl();
        mGl = createEglSurface(holder);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL10.EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                }
                if (mCanvas != null) {
                    setEnabled(true);
                } else {
                    Log.w(LOG_TAG, ""Hardware accelerated Canvas could not be created"");
                }
            }
            return mCanvas != null;
        }
    }
    return false;
}","{
    if (isRequested() && !isEnabled()) {
        initializeEgl();
        mGl = createEglSurface(holder);
        mDestroyed = false;
        if (mGl != null) {
            int err = sEgl.eglGetError();
            if (err != EGL_SUCCESS) {
                destroy(true);
                setRequested(false);
            } else {
                if (mCanvas == null) {
                    mCanvas = createCanvas();
                }
                if (mCanvas != null) {
                    setEnabled(true);
                } else {
                    Log.w(LOG_TAG, ""Hardware accelerated Canvas could not be created"");
                }
            }
            return mCanvas != null;
        }
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,0,0,"There are no changes between the early and late implementations of the method body except for the missing fully qualified class name for the constant `EGL_SUCCESS`. Due to the absence of any actual modification in how method behaves—no difference in control structures, exception handling, or dependent API calls—the code essentially remains equivalent. The change in the constant `EGL_SUCCESS` is likely a refactoring to use import statements rather than a compatibility issue, assuming that the import statement exists which is a reasonable assumption given that the rest of the method is unchanged.","No Compatibility Issue is detected since there is no actual change in the execution path or return values between the two versions. The modification is only in removing the class name prefix from the constant `EGL_SUCCESS`, which does not alter the behavior of the method."
260,<android.view.View: float getPivotY()>,13,14,,,,"{
    return mPivotY;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mPivotY : 0;
}",1,"/**
 * The y location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleY(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The y location of the pivot point.
 */
","/**
 * The y location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleY(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The y location of the pivot point.
 */
",0,,,0,,,,,,,1,1,"The return statement has been changed to include a conditional expression that returns either mTransformationInfo.mPivotY or 0 if mTransformationInfo is null, whereas previously it was always returning mPivotY, so the change type is 1.","The modification of the return statement can potentially lead to the API returning a different value, particularly when mTransformationInfo is null, therefore the CI type is 1."
263,<android.view.ViewGroup: boolean dispatchTrackballEvent(MotionEvent)>,13,14,,,,"{
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        return super.dispatchTrackballEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        return mFocused.dispatchTrackballEvent(event);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTrackballEvent(event, 1);
    }
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        if (super.dispatchTrackballEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        if (mFocused.dispatchTrackballEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The consistency verifier check and corresponding logging are added to the beginning and end of the method (Other statement changed). The if conditions have been expanded into if-else blocks with an additional return statement inside (Control dependency changed and Return statement changed), so the change type is 1,3,4.","The addition of the consistency verifier will not alter the return type or value of the method, but the restructuring of the if conditions to explicitly return true if `super.dispatchTrackballEvent(event)` or `mFocused.dispatchTrackballEvent(event)` return true changes what the method will return in the circumstances that these calls are true, which they previously did not do. Therefore, the CI type is 1 as it can potentially return a different value."
265,<android.webkit.WebView: WebBackForwardList saveState(Bundle)>,13,14,,,,"{
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean(""privateBrowsingEnabled"", isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
}","{
    checkThread();
    if (outState == null) {
        return null;
    }
    // We grab a copy of the back/forward list because a client of WebView
    // may have invalidated the history list by calling clearHistory.
    WebBackForwardList list = copyBackForwardList();
    final int currentIndex = list.getCurrentIndex();
    final int size = list.getSize();
    // not in a valid range.
    if (currentIndex < 0 || currentIndex >= size || size == 0) {
        return null;
    }
    outState.putInt(""index"", currentIndex);
    // FIXME: This should just be a byte[][] instead of ArrayList but
    // Parcel.java does not have the code to handle multi-dimensional
    // arrays.
    ArrayList<byte[]> history = new ArrayList<byte[]>(size);
    for (int i = 0; i < size; i++) {
        WebHistoryItem item = list.getItemAtIndex(i);
        if (null == item) {
            // FIXME: this shouldn't happen
            // need to determine how item got set to null
            Log.w(LOGTAG, ""saveState: Unexpected null history item."");
            return null;
        }
        byte[] data = item.getFlattenedData();
        if (data == null) {
            // flattened data.
            return null;
        }
        history.add(data);
    }
    outState.putSerializable(""history"", history);
    if (mCertificate != null) {
        outState.putBundle(""certificate"", SslCertificate.saveState(mCertificate));
    }
    outState.putBoolean(""privateBrowsingEnabled"", isPrivateBrowsingEnabled());
    mZoomManager.saveZoomState(outState);
    return list;
}",1,"/**
 * Save the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 * @param outState The Bundle to store the WebView state.
 * @return The same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
","/**
 * Save the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called. See {@link #savePicture} and {@link #restorePicture} for saving
 * and restoring the display data.
 * @param outState The Bundle to store the WebView state.
 * @return The same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 * @see #savePicture
 * @see #restorePicture
 */
",0,,,0,,,,,,,4,0,"The only code addition in the late version is the call to `checkThread();`. This is an additional method invocation that checks the thread requirements for the `saveState` method, but it doesn't directly affect the return value or exception handling of the method.","Since the added call to `checkThread();` does not change the return value or the exception handling of the existing method's logic, this particular change will not cause a Compatibility Issue as per the definitions provided."
266,<android.widget.AbsListView: boolean onInterceptTouchEvent(MotionEvent)>,13,14,,,,"{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        final int y = (int) ev.getY(pointerIndex);
                        if (startScrollIfNeeded(y - mMotionY)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}","{
    int action = ev.getAction();
    View v;
    if (mFastScroller != null) {
        boolean intercepted = mFastScroller.onInterceptTouchEvent(ev);
        if (intercepted) {
            return true;
        }
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                int touchMode = mTouchMode;
                if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                    mMotionCorrection = 0;
                    return true;
                }
                final int x = (int) ev.getX();
                final int y = (int) ev.getY();
                mActivePointerId = ev.getPointerId(0);
                int motionPosition = findMotionRow(y);
                if (touchMode != TOUCH_MODE_FLING && motionPosition >= 0) {
                    // User clicked on an actual view (and was not stopping a fling).
                    // Remember where the motion event started
                    v = getChildAt(motionPosition - mFirstPosition);
                    mMotionViewOriginalTop = v.getTop();
                    mMotionX = x;
                    mMotionY = y;
                    mMotionPosition = motionPosition;
                    mTouchMode = TOUCH_MODE_DOWN;
                    clearScrollingCache();
                }
                mLastY = Integer.MIN_VALUE;
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                if (touchMode == TOUCH_MODE_FLING) {
                    return true;
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                switch(mTouchMode) {
                    case TOUCH_MODE_DOWN:
                        int pointerIndex = ev.findPointerIndex(mActivePointerId);
                        if (pointerIndex == -1) {
                            pointerIndex = 0;
                            mActivePointerId = ev.getPointerId(pointerIndex);
                        }
                        final int y = (int) ev.getY(pointerIndex);
                        initVelocityTrackerIfNotExists();
                        mVelocityTracker.addMovement(ev);
                        if (startScrollIfNeeded(y)) {
                            return true;
                        }
                        break;
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            {
                mTouchMode = TOUCH_MODE_REST;
                mActivePointerId = INVALID_POINTER;
                recycleVelocityTracker();
                reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            {
                onSecondaryPointerUp(ev);
                break;
            }
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"Changes have been made within the ACTION_MOVE and ACTION_DOWN cases, and the ACTION_CANCEL handling has been added into the same clause as ACTION_UP, indicating changes in control flow (case statements) and other statements. The changes include new `if` conditions, `initVelocityTrackerIfNotExists()` and `mVelocityTracker.addMovement(ev)` calls, so the code change types are 3,4.","The changes within the ACTION_MOVE and ACTION_DOWN case clauses do not suggest different return values; they are enhancements in tracking touch velocity. Importantly, the paths where `return true;` occurs have not been altered, and no changes in exception handling are introduced. The additions of velocity tracker-related calls do not affect the method's return value or exception throwing patterns based on how the method is expected to react to different touch events. Therefore, we can conclude No Compatibility Issue, type 0."
268,<android.widget.ArrayAdapter.ArrayFilter: FilterResults performFiltering(CharSequence)>,13,14,,,,"{
    FilterResults results = new FilterResults();
    if (mOriginalValues == null) {
        synchronized (mLock) {
            mOriginalValues = new ArrayList<T>(mObjects);
        }
    }
    if (prefix == null || prefix.length() == 0) {
        synchronized (mLock) {
            ArrayList<T> list = new ArrayList<T>(mOriginalValues);
            results.values = list;
            results.count = list.size();
        }
    } else {
        String prefixString = prefix.toString().toLowerCase();
        final ArrayList<T> values = mOriginalValues;
        final int count = values.size();
        final ArrayList<T> newValues = new ArrayList<T>(count);
        for (int i = 0; i < count; i++) {
            final T value = values.get(i);
            final String valueText = value.toString().toLowerCase();
            // First match against the whole, non-splitted value
            if (valueText.startsWith(prefixString)) {
                newValues.add(value);
            } else {
                final String[] words = valueText.split("" "");
                final int wordCount = words.length;
                // Start at index 0, in case valueText starts with space(s)
                for (int k = 0; k < wordCount; k++) {
                    if (words[k].startsWith(prefixString)) {
                        newValues.add(value);
                        break;
                    }
                }
            }
        }
        results.values = newValues;
        results.count = newValues.size();
    }
    return results;
}","{
    FilterResults results = new FilterResults();
    if (mOriginalValues == null) {
        synchronized (mLock) {
            mOriginalValues = new ArrayList<T>(mObjects);
        }
    }
    if (prefix == null || prefix.length() == 0) {
        ArrayList<T> list;
        synchronized (mLock) {
            list = new ArrayList<T>(mOriginalValues);
        }
        results.values = list;
        results.count = list.size();
    } else {
        String prefixString = prefix.toString().toLowerCase();
        ArrayList<T> values;
        synchronized (mLock) {
            values = new ArrayList<T>(mOriginalValues);
        }
        final int count = values.size();
        final ArrayList<T> newValues = new ArrayList<T>();
        for (int i = 0; i < count; i++) {
            final T value = values.get(i);
            final String valueText = value.toString().toLowerCase();
            // First match against the whole, non-splitted value
            if (valueText.startsWith(prefixString)) {
                newValues.add(value);
            } else {
                final String[] words = valueText.split("" "");
                final int wordCount = words.length;
                // Start at index 0, in case valueText starts with space(s)
                for (int k = 0; k < wordCount; k++) {
                    if (words[k].startsWith(prefixString)) {
                        newValues.add(value);
                        break;
                    }
                }
            }
        }
        results.values = newValues;
        results.count = newValues.size();
    }
    return results;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The change appears to be in how the synchronization is performed around the `mOriginalValues` and the local variable assignment (i.e., `ArrayList<T> list` and `ArrayList<T> values`), as well as removing the initial capacity hint for the `newValues` ArrayList creation. These are categorized as other statement changes (4) and control dependency changes (3), as the structure of the code and when the synchronization occurs have been modified.","Even though there are changes in synchronization and creation without the initial capacity, these changes do not affect the values being returned by the method or the exceptions that might be thrown. Therefore, there is no Compatibility Issue arising from these changes."
271,<android.view.View: float getRotationY()>,13,14,,,,"{
    return mRotationY;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mRotationY : 0;
}",1,"/**
 * The degrees that the view is rotated around the vertical axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationY(float)
 *
 * @return The degrees of Y rotation.
 */
","/**
 * The degrees that the view is rotated around the vertical axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationY(float)
 *
 * @return The degrees of Y rotation.
 */
",0,,,0,,,,,,,"1,4",1,"The return statement has an additional null check for mTransformationInfo in the late version, which alters how the return value is computed, so the code change type is 1,4.","The additional null check for mTransformationInfo could result in a different return value, specifically returning 0 when mTransformationInfo is null whereas early version did not check for null and would return the value of mRotationY regardless. This constitutes a potential different return value, and the CI type is 1."
272,<android.view.View: int[] onCreateDrawableState(int)>,13,14,,,,"{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PRESSED) != 0)
        viewStateIndex |= VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= VIEW_STATE_FOCUSED;
    if ((privateFlags & SELECTED) != 0)
        viewStateIndex |= VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & ACTIVATED) != 0)
        viewStateIndex |= VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= VIEW_STATE_ACCELERATED;
    }
    drawableState = VIEW_STATE_SETS[viewStateIndex];
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}","{
    if ((mViewFlags & DUPLICATE_PARENT_STATE) == DUPLICATE_PARENT_STATE && mParent instanceof View) {
        return ((View) mParent).onCreateDrawableState(extraSpace);
    }
    int[] drawableState;
    int privateFlags = mPrivateFlags;
    int viewStateIndex = 0;
    if ((privateFlags & PRESSED) != 0)
        viewStateIndex |= VIEW_STATE_PRESSED;
    if ((mViewFlags & ENABLED_MASK) == ENABLED)
        viewStateIndex |= VIEW_STATE_ENABLED;
    if (isFocused())
        viewStateIndex |= VIEW_STATE_FOCUSED;
    if ((privateFlags & SELECTED) != 0)
        viewStateIndex |= VIEW_STATE_SELECTED;
    if (hasWindowFocus())
        viewStateIndex |= VIEW_STATE_WINDOW_FOCUSED;
    if ((privateFlags & ACTIVATED) != 0)
        viewStateIndex |= VIEW_STATE_ACTIVATED;
    if (mAttachInfo != null && mAttachInfo.mHardwareAccelerationRequested && HardwareRenderer.isAvailable()) {
        // This is set if HW acceleration is requested, even if the current
        // process doesn't allow it.  This is just to allow app preview
        // windows to better match their app.
        viewStateIndex |= VIEW_STATE_ACCELERATED;
    }
    if ((privateFlags & HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_HOVERED;
    final int privateFlags2 = mPrivateFlags2;
    if ((privateFlags2 & DRAG_CAN_ACCEPT) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_CAN_ACCEPT;
    if ((privateFlags2 & DRAG_HOVERED) != 0)
        viewStateIndex |= VIEW_STATE_DRAG_HOVERED;
    drawableState = VIEW_STATE_SETS[viewStateIndex];
    // noinspection ConstantIfStatement
    if (false) {
        Log.i(""View"", ""drawableStateIndex="" + viewStateIndex);
        Log.i(""View"", toString() + "" pressed="" + ((privateFlags & PRESSED) != 0) + "" en="" + ((mViewFlags & ENABLED_MASK) == ENABLED) + "" fo="" + hasFocus() + "" sl="" + ((privateFlags & SELECTED) != 0) + "" wf="" + hasWindowFocus() + "": "" + Arrays.toString(drawableState));
    }
    if (extraSpace == 0) {
        return drawableState;
    }
    final int[] fullState;
    if (drawableState != null) {
        fullState = new int[drawableState.length + extraSpace];
        System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
    } else {
        fullState = new int[extraSpace];
    }
    return fullState;
}",1,"/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates
 */
","/**
 * Generate the new {@link android.graphics.drawable.Drawable} state for
 * this view. This is called by the view
 * system when the cached Drawable state is determined to be invalid.  To
 * retrieve the current state, you should use {@link #getDrawableState}.
 *
 * @param extraSpace if non-zero, this is the number of extra entries you
 * would like in the returned array in which you can place your own
 * states.
 *
 * @return Returns an array holding the current {@link Drawable} state of
 * the view.
 *
 * @see #mergeDrawableStates(int[], int[])
 */
",1,,,0,,,,,,,,,,
274,<android.webkit.WebViewFragment: WebView getWebView()>,13,14,,,,"{
    return mWebView;
}","{
    return mIsWebViewAvailable ? mWebView : null;
}",1,"/**
 * Gets the WebView.
 */
","/**
 * Gets the WebView.
 */
",0,,,0,,,,,,,"1,3",1,"The return statement includes a new check (mIsWebViewAvailable ? mWebView : null) for the condition before returning mWebView, which is a control dependency change and a change in the return statement, so the code change type is 1,3.","This change to the return statement indicates that the method may return a different value (null) when mIsWebViewAvailable is false, which was not previously checked. This means that there is a potential Compatibility Issue where the method could return a different value, resulting in a CI type of 1."
275,<android.inputmethodservice.IInputMethodSessionWrapper: void executeMessage(Message)>,13,14,,,,"{
    if (mInputMethodSession == null)
        return;
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}","{
    if (mInputMethodSession == null)
        return;
    switch(msg.what) {
        case DO_FINISH_INPUT:
            mInputMethodSession.finishInput();
            return;
        case DO_DISPLAY_COMPLETIONS:
            mInputMethodSession.displayCompletions((CompletionInfo[]) msg.obj);
            return;
        case DO_UPDATE_EXTRACTED_TEXT:
            mInputMethodSession.updateExtractedText(msg.arg1, (ExtractedText) msg.obj);
            return;
        case DO_DISPATCH_KEY_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchKeyEvent(msg.arg1, (KeyEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_DISPATCH_TRACKBALL_EVENT:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.dispatchTrackballEvent(msg.arg1, (MotionEvent) args.arg1, new InputMethodEventCallbackWrapper((IInputMethodCallback) args.arg2));
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_SELECTION:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.updateSelection(args.argi1, args.argi2, args.argi3, args.argi4, args.argi5, args.argi6);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_UPDATE_CURSOR:
            {
                mInputMethodSession.updateCursor((Rect) msg.obj);
                return;
            }
        case DO_APP_PRIVATE_COMMAND:
            {
                HandlerCaller.SomeArgs args = (HandlerCaller.SomeArgs) msg.obj;
                mInputMethodSession.appPrivateCommand((String) args.arg1, (Bundle) args.arg2);
                mCaller.recycleArgs(args);
                return;
            }
        case DO_TOGGLE_SOFT_INPUT:
            {
                mInputMethodSession.toggleSoftInput(msg.arg1, msg.arg2);
                return;
            }
        case DO_FINISH_SESSION:
            {
                mInputMethodSession = null;
                return;
            }
        case DO_VIEW_CLICKED:
            {
                mInputMethodSession.viewClicked(msg.arg1 == 1);
                return;
            }
    }
    Log.w(TAG, ""Unhandled message code: "" + msg.what);
}",1,,,0,,,0,,,,,,,"1,3",1,"A case statement for `DO_VIEW_CLICKED` has been added within the switch control structure, which adds a new behaviour for handling a message with code `DO_VIEW_CLICKED`. This falls under control dependency change (3) and also introduces a new return statement for this case (1).","The addition of a new case (`DO_VIEW_CLICKED`) in the switch statement introduces new behaviour, potentially causing the API to perform different actions and return at points where it wouldn't have in the earlier version. Therefore, this is a compatibility issue of type 1, as the method can return a different value depending on the value of `msg.what`."
276,"<android.speech.tts.TextToSpeech: int addEarcon(String,String,int)>",13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return ERROR;
        }
        try {
            mITts.addEarcon(mPackageName, earcon, packagename, resourceId);
            return SUCCESS;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return ERROR;
    }
}","{
    synchronized (mStartLock) {
        mEarcons.put(earcon, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}",1,"/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>""[tick]""</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon The name of the earcon.
 * Example: <code>""[tick]""</code><br/>
 *
 * @param packagename
 * the package name of the application that contains the
 * resource. This can for instance be the package name of your own application.
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The package name can be found in the AndroidManifest.xml of
 * the application containing the resource.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.tick_snd</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",0,,,0,,,,,,,"1,4",1,"The late implementation removes the try-catch block entirely and changes the functionality to use a HashMap (mEarcons.put) for earcons, instead of directly interacting with the mITts service. This change removes the potential exceptions that can be thrown and alters the functional behavior. Therefore, this change includes removing exception handling (no more RemoteException, NullPointerException, or IllegalStateException being caught) and other statements due to altered functionality. The change type is 1,4.","Due to the change in the method implementation, there is no longer a scenario where ERROR will be returned if an exception occurs because the exception handling has been removed. Additionally, changing how earcons are added (from using mITts.addEarcon to using mEarcons.put) can lead to a different functional outcome. Therefore, this represents a CI due to potential different return values or types, and the CI type is 1."
277,"<android.app.ActivityGroup: void dispatchActivityResult(String,int,int,Intent)>",13,14,,,,"{
    if (who != null) {
        Activity act = mLocalActivityManager.getActivity(who);
        /*
            if (Config.LOGV) Log.v(
                TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode
                + "", resCode="" + resultCode + "", data="" + data
                + "", rec="" + rec);
            */
        if (act != null) {
            act.onActivityResult(requestCode, resultCode, data);
            return;
        }
    }
    super.dispatchActivityResult(who, requestCode, resultCode, data);
}","{
    if (who != null) {
        Activity act = mLocalActivityManager.getActivity(who);
        /*
            if (false) Log.v(
                TAG, ""Dispatching result: who="" + who + "", reqCode="" + requestCode
                + "", resCode="" + resultCode + "", data="" + data
                + "", rec="" + rec);
            */
        if (act != null) {
            act.onActivityResult(requestCode, resultCode, data);
            return;
        }
    }
    super.dispatchActivityResult(who, requestCode, resultCode, data);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change in the implementation is within a comment block. No executable code has been altered, so the change type is 4 which is categorized as 'Other statement changed'.","Comments do not affect the execution or behavior of the code. Therefore, the change in the commented Log.v() call from `if (Config.LOGV)` to `if (false)` does not cause any compatibility issues. The CI type is 0."
278,<android.webkit.WebView: boolean performLongClick()>,13,14,,,,"{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    // A multi-finger gesture can look like a long press; make sure we don't take
    // long press actions if we're scaling.
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    if (detector != null && detector.isInProgress()) {
        return false;
    }
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    } else {
        clearTextEntry();
    }
    if (inEditingMode()) {
        // Since we just called rebuildWebTextView, the layout is not set
        // properly.  Update it so it can correctly find the word to select.
        mWebTextView.ensureLayout();
        // Provide a touch down event to WebTextView, which will allow it
        // to store the location to use in performLongClick.
        AbsoluteLayout.LayoutParams params = (AbsoluteLayout.LayoutParams) mWebTextView.getLayoutParams();
        MotionEvent fake = MotionEvent.obtain(mLastTouchTime, mLastTouchTime, MotionEvent.ACTION_DOWN, mLastTouchX - params.x + mScrollX, mLastTouchY - params.y + mScrollY, 0);
        mWebTextView.dispatchTouchEvent(fake);
        return mWebTextView.performLongClick();
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (super.performLongClick()) {
        return true;
    }
    /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
    return selectText();
}","{
    // view system. In that case, do nothing.
    if (getParent() == null)
        return false;
    // A multi-finger gesture can look like a long press; make sure we don't take
    // long press actions if we're scaling.
    final ScaleGestureDetector detector = mZoomManager.getMultiTouchGestureDetector();
    if (detector != null && detector.isInProgress()) {
        return false;
    }
    if (mNativeClass != 0 && nativeCursorIsTextInput()) {
        // Send the click so that the textfield is in focus
        centerKeyPressOnTextField();
        rebuildWebTextView();
    } else {
        clearTextEntry();
    }
    if (inEditingMode()) {
        // Since we just called rebuildWebTextView, the layout is not set
        // properly.  Update it so it can correctly find the word to select.
        mWebTextView.ensureLayout();
        // Provide a touch down event to WebTextView, which will allow it
        // to store the location to use in performLongClick.
        AbsoluteLayout.LayoutParams params = (AbsoluteLayout.LayoutParams) mWebTextView.getLayoutParams();
        MotionEvent fake = MotionEvent.obtain(mLastTouchTime, mLastTouchTime, MotionEvent.ACTION_DOWN, mLastTouchX - params.x + mScrollX, mLastTouchY - params.y + mScrollY, 0);
        mWebTextView.dispatchTouchEvent(fake);
        return mWebTextView.performLongClick();
    }
    // long click does nothing on selection
    if (mSelectingText)
        return false;
    /* if long click brings up a context menu, the super function
         * returns true and we're done. Otherwise, nothing happened when
         * the user clicked. */
    if (super.performLongClick()) {
        return true;
    }
    /* In the case where the application hasn't already handled the long
         * click action, look for a word under the  click. If one is found,
         * animate the text selection into view.
         * FIXME: no animation code yet */
    final boolean isSelecting = selectText();
    if (isSelecting) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return isSelecting;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change consists of a haptic feedback introduced in the last part which was previously not there, so the code change type is 4.","There is no potential Compatibility Issue with respect to the return value or thrown exceptions within the API itself. The addition of the haptic feedback does not affect the logic flow or the return values of the method; it only affects the user experience by providing physical feedback on a long press event. This does not change the behavior of the `performLongClick` return value or exceptions, thus it should be classified as having no compatibility issue."
279,<android.pim.ContactsAsyncHelper.WorkerHandler: void handleMessage(Message)>,13,14,,,,"{
    WorkerArgs args = (WorkerArgs) msg.obj;
    switch(msg.arg1) {
        case EVENT_LOAD_IMAGE:
            InputStream inputStream = null;
            try {
                inputStream = Contacts.openContactPhotoInputStream(args.context.getContentResolver(), args.uri);
            } catch (Exception e) {
                Log.e(LOG_TAG, ""Error opening photo input stream"", e);
            }
            if (inputStream != null) {
                args.result = Drawable.createFromStream(inputStream, args.uri.toString());
                if (DBG)
                    Log.d(LOG_TAG, ""Loading image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri);
            } else {
                args.result = null;
                if (DBG)
                    Log.d(LOG_TAG, ""Problem with image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri + "", using default image."");
            }
            break;
        default:
    }
    // send the reply to the enclosing class.
    Message reply = ContactsAsyncHelper.this.obtainMessage(msg.what);
    reply.arg1 = msg.arg1;
    reply.obj = msg.obj;
    reply.sendToTarget();
}","{
    WorkerArgs args = (WorkerArgs) msg.obj;
    switch(msg.arg1) {
        case EVENT_LOAD_IMAGE:
            InputStream inputStream = null;
            try {
                inputStream = Contacts.openContactPhotoInputStream(args.context.getContentResolver(), args.uri, true);
            } catch (Exception e) {
                Log.e(LOG_TAG, ""Error opening photo input stream"", e);
            }
            if (inputStream != null) {
                args.result = Drawable.createFromStream(inputStream, args.uri.toString());
                if (DBG)
                    Log.d(LOG_TAG, ""Loading image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri);
            } else {
                args.result = null;
                if (DBG)
                    Log.d(LOG_TAG, ""Problem with image: "" + msg.arg1 + "" token: "" + msg.what + "" image URI: "" + args.uri + "", using default image."");
            }
            break;
        default:
    }
    // send the reply to the enclosing class.
    Message reply = ContactsAsyncHelper.this.obtainMessage(msg.what);
    reply.arg1 = msg.arg1;
    reply.obj = msg.obj;
    reply.sendToTarget();
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"The dependent API `Contacts.openContactPhotoInputStream` now takes an additional parameter `true`, making it a Dependent API change. No other parts of the code have been altered.","The addition of a parameter to a dependent API call (from `Contacts.openContactPhotoInputStream(args.context.getContentResolver(), args.uri)` to `Contacts.openContactPhotoInputStream(args.context.getContentResolver(), args.uri, true)`) does not necessarily lead to a compatibility issue, as there is no change in the control flow or exception handling of the `handleMessage` method itself. The behavior change would entirely depend on the implementation of `openContactPhotoInputStream` in the Contacts class. Since there's no indication that the behavior of the `handleMessage` method itself has changed, there is no compatibility issue based on the provided context."
281,<android.widget.NumberPicker: void setMinValue(int)>,13,14,,,,"{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    resetSelectorWheelIndices();
    updateInputTextView();
}","{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException(""minValue must be >= 0"");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
}",1,"/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
","/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value.
 */
",0,,,0,,,,,,,4,0,"There is a change from resetSelectorWheelIndices() to initializeSelectorWheelIndices() which is considered a change in an ""Other statement"" as it doesn't fall into the return statements, exception handling statements, control dependency changes or dependent APIs modifications.","Even though there's a named method change, since this is an internal method call with no direct change in the API's return type, return values, or exception throwing, no Compatibility Issue should arise. The behavior of the API remains the same in terms of how it is observed from the outside."
283,"<android.bluetooth.BluetoothSocket: int write(byte[],int,int)>",13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            throw new IOException(""socket closed"");
        return writeNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return writeNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,4,0,"The condition in the 'if' statement has changed from checking 'mClosed' to checking 'mSocketState == SocketState.CLOSED', so the code change type is 4.","Despite the change in the condition that throws an IOException, this does not constitute a compatibility issue because the same exception is thrown for the same condition - a closed socket. The change in the condition does not affect the outcome of the API's execution in terms of different behavior; it's simply a change in how the closed state is checked internally. Thus, the CI type is 0."
286,<android.net.Uri.Part: Part readFrom(Parcel)>,13,14,,,,"{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new AssertionError();
    }
}","{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new IllegalArgumentException(""Unknown representation: "" + representation);
    }
}",1,,,0,,,0,,,,,,,"2,4",2,"The exception type thrown in the default case of the switch statement has changed from AssertionError to IllegalArgumentException, and the message passed to the exception has also changed. This counts as an 'exception handling statement changed' and 'other statement changed', so the change type is 2,4.","The nature of the exception thrown in case of an unexpected representation value has changed, which can affect the behavior of the API when dealing with unknown values. Therefore, it could lead to a different exception handling, making the CI type 2."
289,<android.widget.HorizontalScrollView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                final int overscrollMode = getOverScrollMode();
                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0)) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        final int right = getScrollRange();
                        if (mScroller.springBack(mScrollX, mScrollY, 0, right, 0, 0)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                if (mVelocityTracker != null) {
                    mVelocityTracker.recycle();
                    mVelocityTracker = null;
                }
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                // Remember where the motion event started
                mLastMotionX = ev.getX();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float x = ev.getX(activePointerIndex);
                final int deltaX = (int) (mLastMotionX - x);
                mLastMotionX = x;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(deltaX, 0, mScrollX, 0, range, 0, mOverscrollDistance, 0, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToX = oldX + deltaX;
                    if (pulledToX < 0) {
                        mEdgeGlowLeft.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowRight.isFinished()) {
                            mEdgeGlowRight.onRelease();
                        }
                    } else if (pulledToX > range) {
                        mEdgeGlowRight.onPull((float) deltaX / getWidth());
                        if (!mEdgeGlowLeft.isFinished()) {
                            mEdgeGlowLeft.onRelease();
                        }
                    }
                    if (mEdgeGlowLeft != null && (!mEdgeGlowLeft.isFinished() || !mEdgeGlowRight.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getXVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                mIsBeingDragged = false;
                recycleVelocityTracker();
                if (mEdgeGlowLeft != null) {
                    mEdgeGlowLeft.onRelease();
                    mEdgeGlowRight.onRelease();
                }
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
290,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setupSetter(Class)>,13,14,,,,"{
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // System.out.println(""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetFloatMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
        Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The new early return check (`if (mProperty != null)`) and log statement (`Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);`) are added in the late version. These are a control dependency change (due to the early return) and other statement change (due to the logging), resulting in change types of 3 and 4.",There is no compatibility issue arising from these changes since they do not lead to different return values or exception handlings when using proper usage according to the API specifications. Adding an early return when 'mProperty' is not null is a defensive programming practice that won't affect the correct functioning of the method assumming 'mProperty' should not have been initialized before this method is called. The added logging statement also does not affect the behavior of the method; it merely provides more debugging information and therefore does not cause a CI.
292,"<android.preference.PreferenceActivity: void loadHeadersFromResource(int,List<Header>)>",13,14,,,,"{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        }
        String nodeName = parser.getName();
        if (!""preference-headers"".equals(nodeName)) {
            throw new RuntimeException(""XML document must start with <preference-headers> tag; found"" + nodeName + "" at "" + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if (""header"".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals(""extra"")) {
                        getResources().parseBundleExtra(""extra"", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals(""intent"")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } catch (IOException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}","{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!""preference-headers"".equals(nodeName)) {
            throw new RuntimeException(""XML document must start with <preference-headers> tag; found"" + nodeName + "" at "" + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if (""header"".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals(""extra"")) {
                        getResources().parseBundleExtra(""extra"", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals(""intent"")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } catch (IOException e) {
        throw new RuntimeException(""Error parsing headers"", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}",1,"/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */
","/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */
",0,,,0,,,,,,,,,,
294,<android.speech.tts.TextToSpeech: String getDefaultEngine()>,13,14,,,,"{
    synchronized (mStartLock) {
        String engineName = """";
        if (!mStarted) {
            return engineName;
        }
        try {
            engineName = mITts.getDefaultEngine();
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setEngineByPackageName"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return engineName;
        }
    }
}","{
    return mEnginesHelper.getDefaultEngine();
}",1,"/**
 * Gets the packagename of the default speech synthesis engine.
 *
 * @return Packagename of the TTS engine that the user has chosen as their default.
 */
","/**
 * Gets the package name of the default speech synthesis engine.
 *
 * @return Package name of the TTS engine that the user has chosen
 * as their default.
 */
",1,,,0,,,,,,,"1,4,5","1,2","The implementation changed significantly from calling multiple methods within a synchronized block and handling exceptions to directly calling a single method mEnginesHelper.getDefaultEngine(). This is considered a change in the return statement, a change in other statements, and the late version method is now dependent on a different API (mEnginesHelper.getDefaultEngine()), so the change types are 1,4,5.","Since the entire method body was replaced, the late version might return a different value than the early version. Additionally, the early version had exception handling statements which were removed in the late version, leading to potential changes in exception handling behavior. Thus, the CI types are 1,2."
296,<android.server.BluetoothService: boolean disconnectInputDevice(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
    return mBluetoothInputProfileHandler.disconnectInputDevice(device, state);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    BluetoothDeviceProfileState state = mDeviceProfileState.get(device.getAddress());
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.disconnectInputDevice(device, state);
    }
}",1,,,0,,,0,,,,,,,3,0,"The only change that has been introduced is the addition of a 'synchronized' block around the return statement. This change is a control dependency change, as it introduces synchronization control around the existing code, but does not inherently change the behavior of returning a value. The code type is 3.","This addition of a 'synchronized' block does not constitute a compatibility issue, as it doesn't alter what the method returns nor does it introduce a change in the exceptions that the method might throw. It simply adds thread-safety to the operation. Therefore, the CI type is 0."
297,"<android.bluetooth.BluetoothAdapter: boolean getProfileProxy(Context,ServiceListener,int)>",13,14,,,,"{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else {
        return false;
    }
}","{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else {
        return false;
    }
}",1,"/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}. Clients must implements
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEADSET}
 * or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
","/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}. Clients must implements
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */
",1,,,0,,,,,,,"3,4",0,"An additional 'else if' control structure is added for BluetoothProfile.HEALTH (newly introduced in the API), which includes a new instantiation of a BluetoothHealth object. This counts as both a change in the control structure (making it a 3) and an addition of an instantiation statement (making it a 4).","The changes do not introduce a Compatibility Issue because they only extend the functionality to support an additional profile without altering the existing behavior or the expected return types/values for previously supported profiles (BluetoothProfile.HEADSET, BluetoothProfile.A2DP, BluetoothProfile.INPUT_DEVICE, BluetoothProfile.PAN). Clients using the previous version of the API with the supported profiles would experience consistent behavior with the latest version."
299,"<android.content.ContentResolver: AssetFileDescriptor openTypedAssetFileDescriptor(Uri,String,Bundle)>",13,14,,,,"{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    try {
        AssetFileDescriptor fd = provider.openTypedAssetFile(uri, mimeType, opts);
        if (fd == null) {
            releaseProvider(provider);
            return null;
        }
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        provider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        throw new FileNotFoundException(""Dead content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (provider != null) {
            releaseProvider(provider);
        }
    }
}","{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new FileNotFoundException(""No content provider: "" + uri);
    }
    try {
        AssetFileDescriptor fd = provider.openTypedAssetFile(uri, mimeType, opts);
        if (fd == null) {
            // The provider will be released by the finally{} clause
            return null;
        }
        ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
        // Success!  Don't release the provider when exiting, let
        // ParcelFileDescriptorInner do that when it is closed.
        provider = null;
        return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
    } catch (RemoteException e) {
        throw new FileNotFoundException(""Dead content provider: "" + uri);
    } catch (FileNotFoundException e) {
        throw e;
    } finally {
        if (provider != null) {
            releaseProvider(provider);
        }
    }
}",1,"/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
","/**
 * Open a raw file descriptor to access (potentially type transformed)
 * data from a ""content:"" URI.  This interacts with the underlying
 * {@link ContentProvider#openTypedAssetFile} method of the provider
 * associated with the given URI, to retrieve retrieve any appropriate
 * data stream for the data stored there.
 *
 * <p>Unlike {@link #openAssetFileDescriptor}, this function only works
 * with ""content:"" URIs, because content providers are the only facility
 * with an associated MIME type to ensure that the returned data stream
 * is of the desired type.
 *
 * <p>All text/* streams are encoded in UTF-8.
 *
 * @param uri The desired URI to open.
 * @param mimeType The desired MIME type of the returned data.  This can
 * be a pattern such as *\/*, which will allow the content provider to
 * select a type, though there is no way for you to determine what type
 * it is returning.
 * @param opts Additional provider-dependent options.
 * @return Returns a new ParcelFileDescriptor from which you can read the
 * data stream from the provider.  Note that this may be a pipe, meaning
 * you can't seek in it.  The only seek you should do is if the
 * AssetFileDescriptor contains an offset, to move to that offset before
 * reading.  You own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * data of the desired type exists under the URI.
 */
",0,,,0,,,,,,,0,0,There was no change to the implementation between the early version and the late version of the API.,"As there were no changes to the code, no Compatibility Issue could arise."
300,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,boolean,AccountManagerCallback<Bundle>,Handler)>",13,14,,,,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    return new AmsTask(null, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, notifyAuthFailure, false, /* expectActivityLaunch */
            null);
        }
    }.start();
}","{
    return getAuthToken(account, authTokenType, null, notifyAuthFailure, callback, handler);
}",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * optionally raising a notification if the user must enter credentials.
 * This method is intended for background tasks and services where the
 * user should not be immediately interrupted with a password prompt.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, an {@link Intent} is returned which, when started, will
 * prompt the user for a password.  If the notifyAuthFailure parameter is
 * set, a status bar notification is also created with the same Intent,
 * alerting the user that they need to enter a password at some point.
 *
 * <p>In that case, you may need to wait until the user responds, which
 * could take hours or days or forever.  When the user does respond and
 * supply a new password, the account manager will broadcast the
 * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can
 * use to try again.
 *
 * <p>If notifyAuthFailure is not set, it is the application's
 * responsibility to launch the returned Intent at some point.
 * Either way, the result from this call will not wait for user action.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param notifyAuthFailure True to add a notification to prompt the
 * user for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields on success:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If the user
 * must enter credentials, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.
 *
 * If an error occurred, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 * @deprecated use {@link #getAuthToken(Account, String, android.os.Bundle,
 * boolean, AccountManagerCallback, android.os.Handler)} instead
 */
",1,,[@Deprecated],1,,,,,,,"1,5",1,"The implementation now calls another method getAuthToken with different parameters, and the original argument checks for account and authTokenType being null have been removed. This is a Dependent API change as well as a Return statement change.","The late version of the API does not perform checks on account and authTokenType like the early version. This difference can lead to the API not throwing IllegalArgumentException in the late version when it would in the early version, potentially leading to different return values or types when such an exception would have been expected. Thus, the type of CI is 1."
301,"<android.widget.AbsListView: boolean performItemClick(View,int,long)>",13,14,,,,"{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (newValue) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, newValue);
                dispatchItemClick = false;
            }
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
        }
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}","{
    boolean handled = false;
    boolean dispatchItemClick = true;
    if (mChoiceMode != CHOICE_MODE_NONE) {
        handled = true;
        if (mChoiceMode == CHOICE_MODE_MULTIPLE || (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode != null)) {
            boolean newValue = !mCheckStates.get(position, false);
            mCheckStates.put(position, newValue);
            if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                if (newValue) {
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                } else {
                    mCheckedIdStates.delete(mAdapter.getItemId(position));
                }
            }
            if (newValue) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
            if (mChoiceActionMode != null) {
                mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, newValue);
                dispatchItemClick = false;
            }
        } else if (mChoiceMode == CHOICE_MODE_SINGLE) {
            boolean newValue = !mCheckStates.get(position, false);
            if (newValue) {
                mCheckStates.clear();
                mCheckStates.put(position, true);
                if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
                    mCheckedIdStates.clear();
                    mCheckedIdStates.put(mAdapter.getItemId(position), position);
                }
                mCheckedItemCount = 1;
            } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
                mCheckedItemCount = 0;
            }
        }
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
    if (dispatchItemClick) {
        handled |= super.performItemClick(view, position, id);
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is present within the 'if' blocks where the value put into mCheckedIdStates has changed from Boolean.TRUE to position. This is an internal data structure operation and not part of the method's return type or exception handling, and it does not change the control flow, so the code change type is 4.","The change from Boolean.TRUE to position in the mCheckedIdStates map does not alter the method's return value or the exceptions it throws. Since the change only affects the internal state and does not impact the outward behavior of the method as it pertains to its outputs or exception throwing, there is no compatibility issue, so the CI type is 0."
302,<android.view.View: void buildDrawingCache(boolean)>,13,14,,,,"{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}","{
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || (autoScale ? mDrawingCache == null : mUnscaledDrawingCache == null)) {
        mCachingFailed = false;
        if (ViewDebug.TRACE_HIERARCHY) {
            ViewDebug.trace(this, ViewDebug.HierarchyTraceType.BUILD_CACHE);
        }
        int width = mRight - mLeft;
        int height = mBottom - mTop;
        final AttachInfo attachInfo = mAttachInfo;
        final boolean scalingRequired = attachInfo != null && attachInfo.mScalingRequired;
        if (autoScale && scalingRequired) {
            width = (int) ((width * attachInfo.mApplicationScale) + 0.5f);
            height = (int) ((height * attachInfo.mApplicationScale) + 0.5f);
        }
        final int drawingCacheBackgroundColor = mDrawingCacheBackgroundColor;
        final boolean opaque = drawingCacheBackgroundColor != 0 || isOpaque();
        final boolean use32BitCache = attachInfo != null && attachInfo.mUse32BitDrawingCache;
        if (width <= 0 || height <= 0 || // Projected bitmap size in bytes
        (width * height * (opaque && !use32BitCache ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
            destroyDrawingCache();
            mCachingFailed = true;
            return;
        }
        boolean clear = true;
        Bitmap bitmap = autoScale ? mDrawingCache : mUnscaledDrawingCache;
        if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
            Bitmap.Config quality;
            if (!opaque) {
                // Keep the DRAWING_CACHE_QUALITY_LOW flag just in case
                switch(mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
                    case DRAWING_CACHE_QUALITY_AUTO:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_LOW:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    case DRAWING_CACHE_QUALITY_HIGH:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                    default:
                        quality = Bitmap.Config.ARGB_8888;
                        break;
                }
            } else {
                // Optimization for translucent windows
                // If the window is translucent, use a 32 bits bitmap to benefit from memcpy()
                quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            }
            // Try to cleanup memory
            if (bitmap != null)
                bitmap.recycle();
            try {
                bitmap = Bitmap.createBitmap(width, height, quality);
                bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
                if (autoScale) {
                    mDrawingCache = bitmap;
                } else {
                    mUnscaledDrawingCache = bitmap;
                }
                if (opaque && use32BitCache)
                    bitmap.setHasAlpha(false);
            } catch (OutOfMemoryError e) {
                // view hierarchy
                if (autoScale) {
                    mDrawingCache = null;
                } else {
                    mUnscaledDrawingCache = null;
                }
                mCachingFailed = true;
                return;
            }
            clear = drawingCacheBackgroundColor != 0;
        }
        Canvas canvas;
        if (attachInfo != null) {
            canvas = attachInfo.mCanvas;
            if (canvas == null) {
                canvas = new Canvas();
            }
            canvas.setBitmap(bitmap);
            // Temporarily clobber the cached Canvas in case one of our children
            // is also using a drawing cache. Without this, the children would
            // steal the canvas by attaching their own bitmap to it and bad, bad
            // thing would happen (invisible views, corrupted drawings, etc.)
            attachInfo.mCanvas = null;
        } else {
            // This case should hopefully never or seldom happen
            canvas = new Canvas(bitmap);
        }
        if (clear) {
            bitmap.eraseColor(drawingCacheBackgroundColor);
        }
        computeScroll();
        final int restoreCount = canvas.save();
        if (autoScale && scalingRequired) {
            final float scale = attachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
        canvas.translate(-mScrollX, -mScrollY);
        mPrivateFlags |= DRAWN;
        if (mAttachInfo == null || !mAttachInfo.mHardwareAccelerated || mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= DRAWING_CACHE_VALID;
        }
        // Fast path for layouts with no backgrounds
        if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
            if (ViewDebug.TRACE_HIERARCHY) {
                ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
            }
            mPrivateFlags &= ~DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
        canvas.restoreToCount(restoreCount);
        canvas.setBitmap(null);
        if (attachInfo != null) {
            // Restore the cached Canvas for our siblings
            attachInfo.mCanvas = canvas;
        }
    }
}",1,"/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
","/**
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p>
 *
 * <p>If you call {@link #buildDrawingCache()} manually without calling
 * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you
 * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.</p>
 *
 * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,
 * this method will create a bitmap of the same size as this view. Because this bitmap
 * will be drawn scaled by the parent ViewGroup, the result on screen might show
 * scaling artifacts. To avoid such artifacts, you should call this method by setting
 * the auto scaling to true. Doing so, however, will generate a bitmap of a different
 * size than the view. This implies that your application must be able to handle this
 * size.</p>
 *
 * <p>You should avoid calling this method when hardware acceleration is enabled. If
 * you do not need the drawing cache bitmap, calling this method will increase memory
 * usage and cause the view to be rendered in software once, thus negatively impacting
 * performance.</p>
 *
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
",0,,,0,,,,,,,,,,
303,<android.speech.tts.TextToSpeech: int stop()>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            result = mITts.stop(mPackageName);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - stop"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - stop"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - stop"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.stop(getPackageName());
        }
    }, ERROR, ""stop"");
}",1,"/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Interrupts the current utterance (whether played or rendered to file) and discards other
 * utterances in the queue.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4,5","1,2","The entire implementation of the method has changed, including the removal of the synchronized block, control statements, exception handling, and dependent API calls. The way 'stop' is implemented has been heavily refactored, where a new internal method 'runAction' is introduced, and the earlier direct calls to the service have been wrapped in an anonymous inner class. Both the structure of the code and the method calls it depends on differ. Therefore, the code change types are 1, 3, 4, and 5.",Due to these extensive changes:
306,"<android.nfc.tech.BasicTagTechnology: byte[] transceive(byte[],boolean)>",13,14,,,,"{
    checkConnected();
    try {
        TransceiveResult result = mTag.getTagService().transceive(mTag.getServiceHandle(), data, raw);
        if (result == null) {
            throw new IOException(""transceive failed"");
        } else {
            if (result.isSuccessful()) {
                return result.getResponseData();
            } else {
                if (result.isTagLost()) {
                    throw new TagLostException(""Tag was lost."");
                } else {
                    throw new IOException(""transceive failed"");
                }
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}","{
    checkConnected();
    try {
        TransceiveResult result = mTag.getTagService().transceive(mTag.getServiceHandle(), data, raw);
        if (result == null) {
            throw new IOException(""transceive failed"");
        } else {
            return result.getResponseOrThrow();
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        throw new IOException(""NFC service died"");
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"1,3","1,2","The control structure after checking if result is not null has been changed. The detailed logic to throw specific exceptions based on the result of transceive has been replaced by a single method call result.getResponseOrThrow(). This changes both the control flow and potentially alters the exceptions thrown and the return values (in cases where result.isSuccessful() returned false before, now an exception will be thrown by result.getResponseOrThrow()). Hence, the change types are 1,3.","There's a change in the exception handling where specific exceptions were thrown based on status flags in the result, and now a new default set of exceptions could be thrown by the getResponseOrThrow() method. Additionally, there might be cases where previously a result was unsuccessfully received and an IOException was thrown, but with the new implementation, other types of exceptions may be thrown by getResponseOrThrow(). This could lead to a change in behaviour for the callers of this API, hence CI types are 1 (for potential different return values) and 2 (for potential different exception handlings)."
308,"<android.net.MobileDataStateTracker.MobileDataStateReceiver: void onReceive(Context,Intent)>",13,14,,,,"{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        mNetworkInfo.setSubtype(TelephonyManager.getDefault().getNetworkType(), TelephonyManager.getDefault().getNetworkTypeName());
        Phone.DataState state = Enum.valueOf(Phone.DataState.class, intent.getStringExtra(Phone.STATE_KEY));
        String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        log(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(Phone.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        log(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, Phone.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    log(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else if (intent.getAction().equals(DataConnectionTracker.ACTION_DATA_CONNECTION_TRACKER_MESSENGER)) {
        if (DBG)
            log(mApnType + "" got ACTION_DATA_CONNECTION_TRACKER_MESSENGER"");
        mMessenger = intent.getParcelableExtra(DataConnectionTracker.EXTRA_MESSENGER);
        AsyncChannel ac = new AsyncChannel();
        ac.connect(mContext, MobileDataStateTracker.this.mHandler, mMessenger);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}","{
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (VDBG) {
            log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_STATE_CHANGED"" + ""mApnType=%s %s received apnType=%s"", mApnType, TextUtils.equals(apnType, mApnType) ? ""=="" : ""!="", apnType));
        }
        if (!TextUtils.equals(apnType, mApnType)) {
            return;
        }
        mNetworkInfo.setSubtype(TelephonyManager.getDefault().getNetworkType(), TelephonyManager.getDefault().getNetworkTypeName());
        Phone.DataState state = Enum.valueOf(Phone.DataState.class, intent.getStringExtra(Phone.STATE_KEY));
        String reason = intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        mNetworkInfo.setRoaming(intent.getBooleanExtra(Phone.DATA_NETWORK_ROAMING_KEY, false));
        if (VDBG) {
            log(mApnType + "" setting isAvailable to "" + intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false));
        }
        mNetworkInfo.setIsAvailable(!intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY, false));
        if (DBG) {
            log(""Received state="" + state + "", old="" + mMobileDataState + "", reason="" + (reason == null ? ""(unspecified)"" : reason));
        }
        if (mMobileDataState != state) {
            mMobileDataState = state;
            switch(state) {
                case DISCONNECTED:
                    if (isTeardownRequested()) {
                        setTeardownRequested(false);
                    }
                    setDetailedState(DetailedState.DISCONNECTED, reason, apnName);
                    // mInterfaceName = null;
                    break;
                case CONNECTING:
                    setDetailedState(DetailedState.CONNECTING, reason, apnName);
                    break;
                case SUSPENDED:
                    setDetailedState(DetailedState.SUSPENDED, reason, apnName);
                    break;
                case CONNECTED:
                    mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                    if (mLinkProperties == null) {
                        loge(""CONNECTED event did not supply link properties."");
                        mLinkProperties = new LinkProperties();
                    }
                    mLinkCapabilities = intent.getParcelableExtra(Phone.DATA_LINK_CAPABILITIES_KEY);
                    if (mLinkCapabilities == null) {
                        loge(""CONNECTED event did not supply link capabilities."");
                        mLinkCapabilities = new LinkCapabilities();
                    }
                    setDetailedState(DetailedState.CONNECTED, reason, apnName);
                    break;
            }
        } else {
            // There was no state change. Check if LinkProperties has been updated.
            if (TextUtils.equals(reason, Phone.REASON_LINK_PROPERTIES_CHANGED)) {
                mLinkProperties = intent.getParcelableExtra(Phone.DATA_LINK_PROPERTIES_KEY);
                if (mLinkProperties == null) {
                    loge(""No link property in LINK_PROPERTIES change event."");
                    mLinkProperties = new LinkProperties();
                }
                // Just update reason field in this NetworkInfo
                mNetworkInfo.setDetailedState(mNetworkInfo.getDetailedState(), reason, mNetworkInfo.getExtraInfo());
                Message msg = mTarget.obtainMessage(EVENT_CONFIGURATION_CHANGED, mNetworkInfo);
                msg.sendToTarget();
            }
        }
    } else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
        String apnType = intent.getStringExtra(Phone.DATA_APN_TYPE_KEY);
        if (!TextUtils.equals(apnType, mApnType)) {
            if (DBG) {
                log(String.format(""Broadcast received: ACTION_ANY_DATA_CONNECTION_FAILED ignore, "" + ""mApnType=%s != received apnType=%s"", mApnType, apnType));
            }
            return;
        }
        String reason = intent.getStringExtra(Phone.FAILURE_REASON_KEY);
        String apnName = intent.getStringExtra(Phone.DATA_APN_KEY);
        if (DBG) {
            log(""Received "" + intent.getAction() + "" broadcast"" + reason == null ? """" : ""("" + reason + "")"");
        }
        setDetailedState(DetailedState.FAILED, reason, apnName);
    } else if (intent.getAction().equals(DataConnectionTracker.ACTION_DATA_CONNECTION_TRACKER_MESSENGER)) {
        if (VDBG)
            log(mApnType + "" got ACTION_DATA_CONNECTION_TRACKER_MESSENGER"");
        mMessenger = intent.getParcelableExtra(DataConnectionTracker.EXTRA_MESSENGER);
        AsyncChannel ac = new AsyncChannel();
        ac.connect(mContext, MobileDataStateTracker.this.mHandler, mMessenger);
    } else {
        if (DBG)
            log(""Broadcast received: ignore "" + intent.getAction());
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
311,<android.server.BluetoothService: ParcelUuid[] getUuids()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    String value = getProperty(""UUIDs"");
    if (value == null)
        return null;
    return convertStringToParcelUuid(value);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    String value = getProperty(""UUIDs"", true);
    if (value == null)
        return null;
    return convertStringToParcelUuid(value);
}",1,,,0,,,0,,,,,,,"4,5",0,"The dependent API getProperty has an additional boolean parameter in the late version, which implies a change in its signature, so the code change type is 4,5.","The change does not introduce a new return statement or exception handling, and there is no indication that the behaviour of getProperty with the new parameter would be different in such a way that it would affect the return value of getUuids. As such, there is no direct evidence to suggest that there would be a Compatibility Issue, so the CI type is 0."
312,"<android.content.ContentProviderProxy: AssetFileDescriptor openTypedAssetFile(Uri,String,Bundle)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeString(mimeType);
    data.writeBundle(opts);
    mRemote.transact(IContentProvider.OPEN_TYPED_ASSET_FILE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
    int has = reply.readInt();
    AssetFileDescriptor fd = has != 0 ? AssetFileDescriptor.CREATOR.createFromParcel(reply) : null;
    data.recycle();
    reply.recycle();
    return fd;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeString(mimeType);
        data.writeBundle(opts);
        mRemote.transact(IContentProvider.OPEN_TYPED_ASSET_FILE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
        int has = reply.readInt();
        AssetFileDescriptor fd = has != 0 ? AssetFileDescriptor.CREATOR.createFromParcel(reply) : null;
        return fd;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The try-finally block has been added to ensure resources are recycled in case of exceptions. This is a change of type 4 due to the added try-finally block. It is also a change of type 3 because the recycling of 'data' and 'reply' that was previously in the regular control flow, has now been moved to the ""finally"" block which is a control dependency change.","There is no Compatibility Issue here because the change does not affect the return values or the exception handling of the method; it simply ensures that the Parcel objects are recycled properly in case of exceptions, which is an internal change not visible to the API consumers."
313,<android.view.accessibility.AccessibilityManager: List<ServiceInfo> getAccessibilityServiceList()>,13,14,,,,"{
    List<ServiceInfo> services = null;
    try {
        services = mService.getAccessibilityServiceList();
        if (LOGV) {
            Log.i(LOG_TAG, ""Installed AccessibilityServices "" + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while obtaining the installed AccessibilityServices. "", re);
    }
    return Collections.unmodifiableList(services);
}","{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<ServiceInfo>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}",1,"/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 */
","/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */
",1,,[@Deprecated],1,,,,,,,"1,4,5",1,"The implementation of the method is completely different; it no longer uses mService.getAccessibilityServiceList() and introduces a new way to obtain and construct the list of ServiceInfo objects. This change suggests 'Other statement changed', 'Return statement changed', and 'Dependent API changed'. Therefore, the code change type is a combination of 1,4,5.","Because there is a completely new implementation for obtaining the list of ServiceInfo, there is a possibility that the result list may be different before and after the change (e.g., a different ordering or a different set of services). Hence, clients relying on the order or the exact content of the list might experience incompatibilities. Additionally, since the implementation details between the methods may differ, there's a potential for different return values or even types if the subsequent APIs used internally have different behaviors. Thus, the CI type is 1."
314,<android.database.sqlite.SQLiteProgram: void compileAndbindAllArgs()>,13,14,,,,"{
    if ((mStatementType & STATEMENT_DONT_PREPARE) > 0) {
        // no need to prepare this SQL statement
        if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
            if (mBindArgs != null) {
                throw new IllegalArgumentException(""no need to pass bindargs for this sql :"" + mSql);
            }
        }
        return;
    }
    if (nStatement == 0) {
        // SQL statement is not compiled yet. compile it now.
        compileSql();
    }
    if (mBindArgs == null) {
        return;
    }
    for (int index : mBindArgs.keySet()) {
        Object value = mBindArgs.get(index);
        if (value == null) {
            native_bind_null(index);
        } else if (value instanceof Double || value instanceof Float) {
            native_bind_double(index, ((Number) value).doubleValue());
        } else if (value instanceof Number) {
            native_bind_long(index, ((Number) value).longValue());
        } else if (value instanceof Boolean) {
            Boolean bool = (Boolean) value;
            native_bind_long(index, (bool) ? 1 : 0);
            if (bool) {
                native_bind_long(index, 1);
            } else {
                native_bind_long(index, 0);
            }
        } else if (value instanceof byte[]) {
            native_bind_blob(index, (byte[]) value);
        } else {
            native_bind_string(index, value.toString());
        }
    }
}","{
    if ((mStatementType & STATEMENT_DONT_PREPARE) > 0) {
        if (mBindArgs != null) {
            throw new IllegalArgumentException(""Can't pass bindargs for this sql :"" + mSql);
        }
        // no need to prepare this SQL statement
        return;
    }
    if (nStatement == 0) {
        // SQL statement is not compiled yet. compile it now.
        compileSql();
    }
    if (mBindArgs == null) {
        return;
    }
    for (int index : mBindArgs.keySet()) {
        Object value = mBindArgs.get(index);
        if (value == null) {
            native_bind_null(index);
        } else if (value instanceof Double || value instanceof Float) {
            native_bind_double(index, ((Number) value).doubleValue());
        } else if (value instanceof Number) {
            native_bind_long(index, ((Number) value).longValue());
        } else if (value instanceof Boolean) {
            Boolean bool = (Boolean) value;
            native_bind_long(index, (bool) ? 1 : 0);
            if (bool) {
                native_bind_long(index, 1);
            } else {
                native_bind_long(index, 0);
            }
        } else if (value instanceof byte[]) {
            native_bind_blob(index, (byte[]) value);
        } else {
            native_bind_string(index, value.toString());
        }
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,4,0,"The change is in the error message thrown by IllegalArgumentException, and the reordering of a comment, so the code change type is 4.","Since only the error message text and the position of the comment within the code block have been changed (neither of which would affect the program's behavior), there is no Compatibility Issue; hence, the CI type is 0."
315,<android.view.MotionEvent: String toString()>,13,14,,,,"{
    return ""MotionEvent{"" + Integer.toHexString(System.identityHashCode(this)) + "" pointerId="" + getPointerId(0) + "" action="" + actionToString(getAction()) + "" x="" + getX() + "" y="" + getY() + "" pressure="" + getPressure() + "" size="" + getSize() + "" touchMajor="" + getTouchMajor() + "" touchMinor="" + getTouchMinor() + "" toolMajor="" + getToolMajor() + "" toolMinor="" + getToolMinor() + "" orientation="" + getOrientation() + "" meta="" + KeyEvent.metaStateToString(getMetaState()) + "" pointerCount="" + getPointerCount() + "" historySize="" + getHistorySize() + "" flags=0x"" + Integer.toHexString(getFlags()) + "" edgeFlags=0x"" + Integer.toHexString(getEdgeFlags()) + "" device="" + getDeviceId() + "" source=0x"" + Integer.toHexString(getSource()) + (getPointerCount() > 1 ? "" pointerId2="" + getPointerId(1) + "" x2="" + getX(1) + "" y2="" + getY(1) : """") + ""}"";
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""MotionEvent { action="").append(actionToString(getAction()));
    final int pointerCount = getPointerCount();
    for (int i = 0; i < pointerCount; i++) {
        msg.append("", id["").append(i).append(""]="").append(getPointerId(i));
        msg.append("", x["").append(i).append(""]="").append(getX(i));
        msg.append("", y["").append(i).append(""]="").append(getY(i));
        msg.append("", toolType["").append(i).append(""]="").append(toolTypeToString(getToolType(i)));
    }
    msg.append("", buttonState="").append(MotionEvent.buttonStateToString(getButtonState()));
    msg.append("", metaState="").append(KeyEvent.metaStateToString(getMetaState()));
    msg.append("", flags=0x"").append(Integer.toHexString(getFlags()));
    msg.append("", edgeFlags=0x"").append(Integer.toHexString(getEdgeFlags()));
    msg.append("", pointerCount="").append(pointerCount);
    msg.append("", historySize="").append(getHistorySize());
    msg.append("", eventTime="").append(getEventTime());
    msg.append("", downTime="").append(getDownTime());
    msg.append("", deviceId="").append(getDeviceId());
    msg.append("", source=0x"").append(Integer.toHexString(getSource()));
    msg.append("" }"");
    return msg.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The implementation of toString() has changed significantly, with a different string construction method using StringBuilder and a different set of data included in the output string. The control dependency has changed because a for-loop is introduced and the return statement has also changed from a single return statement to a return of StringBuilder's toString() method. Additionally, the way some information is appended to the output string has changed, leading to the classification as Other statement changed. Therefore, the change types are 1,3,4.","The toString() method is intended to provide a string representation of the object, and since the way this string is constructed and its content has changed, the API will return different values between versions. Therefore, there is a Compatibility Issue caused by potential different return values, which makes the CI type 1."
316,"<android.database.CursorWindow: boolean putBlob(byte[],int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return putBlob_native(value, row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativePutBlob(mWindowPtr, value, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * copy byte array to cursor window
 * @param value
 * @param row
 * @param col
 * @return false if fail to copy
 */
","/**
 * Copies a byte array into the field at the specified row and column index.
 *
 * @param value The value to store.
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if successful.
 */
",1,,,0,,,,,,,"1,5",1,"The implementation has changed from invoking `putBlob_native` to `nativePutBlob`, and the parameters passed are slightly renamed (from `col` to `column`). This indicates a change in the method invoked and its corresponding parameters; hence, the change types are 1 and 5.","Because there's a change in the dependent API (from `putBlob_native` to `nativePutBlob`), this can potentially cause the API to return a different result, if these two functions behave differently in any way, leading to a Compatibility Issue of type 1."
317,"<android.nfc.NfcAdapter: void enableForegroundDispatch(Activity,PendingIntent,IntentFilter[],String[][])>",13,14,,,,"{
    if (activity == null || intent == null) {
        throw new NullPointerException();
    }
    if (!activity.isResumed()) {
        throw new IllegalStateException(""Foregorund dispatching can only be enabled "" + ""when your activity is resumed"");
    }
    try {
        TechListParcel parcel = null;
        if (techLists != null && techLists.length > 0) {
            parcel = new TechListParcel(techLists);
        }
        ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundDispatchListener);
        sService.enableForegroundDispatch(activity.getComponentName(), intent, filters, parcel);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}","{
    if (activity == null || intent == null) {
        throw new NullPointerException();
    }
    if (!activity.isResumed()) {
        throw new IllegalStateException(""Foreground dispatch can only be enabled "" + ""when your activity is resumed"");
    }
    try {
        TechListParcel parcel = null;
        if (techLists != null && techLists.length > 0) {
            parcel = new TechListParcel(techLists);
        }
        ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundDispatchListener);
        sService.setForegroundDispatch(intent, filters, parcel);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}",1,"/**
 * Enable foreground dispatch to the given Activity.
 *
 * <p>This will give give priority to the foreground activity when
 * dispatching a discovered {@link Tag} to an application.
 *
 * <p>If any IntentFilters are provided to this method they are used to match dispatch Intents
 * for both the {@link NfcAdapter#ACTION_NDEF_DISCOVERED} and
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED}. Since {@link NfcAdapter#ACTION_TECH_DISCOVERED}
 * relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 * by passing in the tech lists separately. Each first level entry in the tech list represents
 * an array of technologies that must all be present to match. If any of the first level sets
 * match then the dispatch is routed through the given PendingIntent. In other words, the second
 * level is ANDed together and the first level entries are ORed together.
 *
 * <p>If you pass {@code null} for both the {@code filters} and {@code techLists} parameters
 * that acts a wild card and will cause the foreground activity to receive all tags via the
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED} intent.
 *
 * <p>This method must be called from the main thread, and only when the activity is in the
 * foreground (resumed). Also, activities must call {@link #disableForegroundDispatch} before
 * the completion of their {@link Activity#onPause} callback to disable foreground dispatch
 * after it has been enabled.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to dispatch to
 * @param intent the PendingIntent to start for the dispatch
 * @param filters the IntentFilters to override dispatching for, or null to always dispatch
 * @param techLists the tech lists used to perform matching for dispatching of the
 * {@link NfcAdapter#ACTION_TECH_DISCOVERED} intent
 * @throws IllegalStateException if the Activity is not currently in the foreground
 */
","/**
 * Enable foreground dispatch to the given Activity.
 *
 * <p>This will give give priority to the foreground activity when
 * dispatching a discovered {@link Tag} to an application.
 *
 * <p>If any IntentFilters are provided to this method they are used to match dispatch Intents
 * for both the {@link NfcAdapter#ACTION_NDEF_DISCOVERED} and
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED}. Since {@link NfcAdapter#ACTION_TECH_DISCOVERED}
 * relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled
 * by passing in the tech lists separately. Each first level entry in the tech list represents
 * an array of technologies that must all be present to match. If any of the first level sets
 * match then the dispatch is routed through the given PendingIntent. In other words, the second
 * level is ANDed together and the first level entries are ORed together.
 *
 * <p>If you pass {@code null} for both the {@code filters} and {@code techLists} parameters
 * that acts a wild card and will cause the foreground activity to receive all tags via the
 * {@link NfcAdapter#ACTION_TAG_DISCOVERED} intent.
 *
 * <p>This method must be called from the main thread, and only when the activity is in the
 * foreground (resumed). Also, activities must call {@link #disableForegroundDispatch} before
 * the completion of their {@link Activity#onPause} callback to disable foreground dispatch
 * after it has been enabled.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Activity to dispatch to
 * @param intent the PendingIntent to start for the dispatch
 * @param filters the IntentFilters to override dispatching for, or null to always dispatch
 * @param techLists the tech lists used to perform matching for dispatching of the
 * {@link NfcAdapter#ACTION_TECH_DISCOVERED} intent
 * @throws IllegalStateException if the Activity is not currently in the foreground
 */
",0,,,0,,,,,,,"4,5",0,"The only change in the late implementation compared to the early implementation is the method called on `sService`, which is from `sService.enableForegroundDispatch(...)` to `sService.setForegroundDispatch(...)`, and the `activity.getComponentName()` parameter has been removed. Therefore, the code change types are 4 and 5 because the dependent API call has changed.","As the dependent service method call has changed, an issue could arise if the new method has a different behavior from the old one. However, since the information provided does not indicate what the replacement method `setForegroundDispatch` does differently from `enableForegroundDispatch`, or if it even uses the `componentName`, we cannot be certain that a compatibility issue is introduced. The intent is still enabled for foreground dispatch with the same intent, filters, and technology lists, suggesting the changes are internal to the service and may not affect the method's behavior as it interacts with the `Activity`. Based on the information provided, we cannot assume a change in behavior; hence, there is no compatibility issue evident."
318,<android.inputmethodservice.ExtractButton: boolean hasWindowFocus()>,13,14,,,,"{
    return this.isEnabled() ? true : false;
}","{
    return isEnabled() && getVisibility() == VISIBLE ? true : false;
}",1,"/**
 * Pretend like the window this view is in always has focus, so it will
 * highlight when selected.
 */
","/**
 * Pretend like the window this view is in always has focus, so it will
 * highlight when selected.
 */
",0,[@Override],[@Override],0,,,,,,,"1,4",1,"The addition of the ""&& getVisibility() == VISIBLE"" condition before returning the boolean value is an other statement that has been changed. Furthermore, a new condition has been introduced that alters the return value of the method, making it a return statement change.","The change of the condition by adding ""getVisibility() == VISIBLE"" means that this method now also checks the visibility of the button before returning 'true'. This could cause the API to return a different value (false instead of true if the button is not visible) in the late version; hence, the CI type is 1."
320,<android.server.BluetoothService: int getBluetoothStateInternal()>,13,14,,,,"{
    return mBluetoothState;
}","{
    return mBluetoothState.getBluetoothAdapterState();
}",1,,,0,,,0,,,,,,,5,1,"The way 'mBluetoothState' is accessed has changed; before, it returned directly from the variable, but now it's invoking the method 'getBluetoothAdapterState()' on 'mBluetoothState', so this is a dependent API changed (5).","Since 'mBluetoothState.getBluetoothAdapterState()' could potentially return a different value from the direct 'mBluetoothState' field access, there is a possibility of the API returning different values or types than before. Thus, it constitutes a Compatibility Issue of type 1."
321,<android.util.Xml: XmlPullParser newPullParser()>,13,14,,,,"{
    ExpatPullParser parser = new ExpatPullParser();
    parser.setNamespaceProcessingEnabled(true);
    return parser;
}","{
    try {
        KXmlParser parser = new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
        return parser;
    } catch (XmlPullParserException e) {
        throw new AssertionError();
    }
}",1,"/**
 * Creates a new pull parser with namespace support.
 *
 * <p><b>Note:</b> This is actually slower than the SAX parser, and it's not
 * fully implemented. If you need a fast, mostly implemented pull parser,
 * use this. If you need a complete implementation, use KXML.
 */
","/**
 * Returns a new pull parser with namespace support.
 */
",1,,,0,,,,,,,"1,2,4,5","1,2","The instantiation of the parser has changed from `ExpatPullParser` to `KXmlParser` and a new try-catch block has been introduced with different setup methods and a new throw statement. This indicates changes in the construction and initialization of the parser object as well as the exception handling strategy, so the code change type is 1,2,4,5.","Due to the construction of a different parser type and introduction of a new exception throw (throw new AssertionError()), the late implementation could either return a different type of `XmlPullParser` or throw an exception where the early implementation would not. Therefore, the CI type is both 1 and 2 because it could lead to different returned object type/values and different exception handling."
322,<android.server.BluetoothService: boolean isTetheringOn()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothPanProfileHandler.isTetheringOn();
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.isTetheringOn();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The late implementation adds a synchronized block around the return statement, thus the code change type includes both 3 (since a synchronization control statement has been added which changes the control flow) and 4 (as a new structure/syntax has been introduced that wasn't present before).","Although a new synchronization block is added, it doesn't change the behavior in terms of the return value or the exception handling from the perspective of the method's caller. The addition of synchronization is for thread-safety and doesn't affect the method's output or the exceptions it might throw. Therefore, there is no Compatibility Issue in this case."
324,<android.server.BluetoothService: List<BluetoothDevice> getConnectedPanDevices()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothPanProfileHandler.getConnectedPanDevices();
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.getConnectedPanDevices();
    }
}",1,,,0,,,0,,,,,,,3,0,The change is the addition of a synchronized block around the existing code that returns the connected PAN devices. This is a control dependency change.,"The addition of the synchronized block does not change the behavior of the API in terms of what it returns or how it handles exceptions. It is meant to make the operation thread-safe, but it does not affect the API's output or exception-throwing behavior. Therefore, there is no Compatibility Issue."
325,"<android.speech.tts.TextToSpeech: int addSpeech(String,String,int)>",13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return ERROR;
        }
        try {
            mITts.addSpeech(mPackageName, text, packagename, resourceId);
            return SUCCESS;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addSpeech"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return ERROR;
    }
}","{
    synchronized (mStartLock) {
        mUtterances.put(text, makeResourceUri(packagename, resourceId));
        return SUCCESS;
    }
}",1,"/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. After a call to this method, subsequent calls to
 * {@link #speak(String, int, HashMap)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound resource in a
 * package. After a call to this method, subsequent calls to
 * {@link #speak(String, int, HashMap)} will play the specified sound resource
 * if it is available, or synthesize the text it is missing.
 *
 * @param text
 * The string of text. Example: <code>""south_south_east""</code>
 *
 * @param packagename
 * Pass the packagename of the application that contains the
 * resource. If the resource is in your own application (this is
 * the most common case), then put the packagename of your
 * application here.<br/>
 * Example: <b>""com.google.marvin.compass""</b><br/>
 * The packagename can be found in the AndroidManifest.xml of
 * your application.
 * <p>
 * <code>&lt;manifest xmlns:android=&quot;...&quot;
 * package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
 * </p>
 *
 * @param resourceId
 * Example: <code>R.raw.south_south_east</code>
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",0,,,0,,,,,,,"1,2,3,4","1,2","The return statement, exception handling, and control dependency within the 'try' block have been removed and replaced with a new return statement. Along with that, the implementation of the method body has changed. New behavior is introduced and old behavior is removed, which corresponds to changes in return statement, exception handling statements, control dependencies, and other statements.","Potential compatibility issues arise due to multiple changes. Firstly, the new implementation removes the possibility of previously thrown exceptions, such as RemoteException, NullPointerException, and IllegalStateException, which affects exception handling behavior. Secondly, the method no longer calls mITts.addSpeech(), but adds something to mUtterances and always returns SUCCESS. There is no check for mStarted, nor any handling for when the service is not started. These changes can lead to different return values, whether it's always SUCCESS now vs. a possible ERROR previously, and the lack of exception throwing when an error occurs, which can have ripple effects on apps using this method. Hence, both return value changes and exception handling changes can cause compatibility issues."
326,"<android.os.AsyncTask: AsyncTask<Params, Progress, Result> execute(Params)>",13,14,,,,"{
    return executeOnExecutor(THREAD_POOL_EXECUTOR, params);
}","{
    return executeOnExecutor(sDefaultExecutor, params);
}",1,"/**
 * Executes the task with the specified parameters. The task returns
 * itself (this) so that the caller can keep a reference to it.
 *
 * <p>Note: this function schedules the task on a queue for a single background
 * thread or pool of threads depending on the platform version.  When first
 * introduced, AsyncTasks were executed serially on a single background thread.
 * Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was changed
 * to a pool of threads allowing multiple tasks to operate in parallel.  After
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, it is planned to change this
 * back to a single thread to avoid common application errors caused
 * by parallel execution.  If you truly want parallel execution, you can use
 * the {@link #executeOnExecutor} version of this method
 * with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for warnings on
 * its use.
 *
 * <p>This method must be invoked on the UI thread.
 *
 * @param params The parameters of the task.
 *
 * @return This instance of AsyncTask.
 *
 * @throws IllegalStateException If {@link #getStatus()} returns either
 * {@link AsyncTask.Status#RUNNING} or {@link AsyncTask.Status#FINISHED}.
 */
","/**
 * Executes the task with the specified parameters. The task returns
 * itself (this) so that the caller can keep a reference to it.
 *
 * <p>Note: this function schedules the task on a queue for a single background
 * thread or pool of threads depending on the platform version.  When first
 * introduced, AsyncTasks were executed serially on a single background thread.
 * Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was changed
 * to a pool of threads allowing multiple tasks to operate in parallel.  After
 * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, it is planned to change this
 * back to a single thread to avoid common application errors caused
 * by parallel execution.  If you truly want parallel execution, you can use
 * the {@link #executeOnExecutor} version of this method
 * with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for warnings on
 * its use.
 *
 * <p>This method must be invoked on the UI thread.
 *
 * @param params The parameters of the task.
 *
 * @return This instance of AsyncTask.
 *
 * @throws IllegalStateException If {@link #getStatus()} returns either
 * {@link AsyncTask.Status#RUNNING} or {@link AsyncTask.Status#FINISHED}.
 */
",0,,,0,,,,,,,5,0,"The dependent API executeOnExecutor() has not changed its signature, but the parameter passed to it has changed from a static reference THREAD_POOL_EXECUTOR to sDefaultExecutor. Thus, the change type is 5.","There is no Compatibility Issue because the change is simply switching to a different executor, but the contract of how the `execute(Params)` method works remains the same, which is to execute the task asynchronously, possibly on different threads. The actual behavior as documented (executing the task) does not change, only the executor used for the operation does. Therefore, the client code calling this method will not experience a change in behavior that would constitute a compatibility issue."
327,<android.text.Layout: float getLineLeft(int)>,13,14,,,,"{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getParagraphRight(line) - getLineMax(line);
        else
            return 0;
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return 0;
        else
            return mWidth - getLineMax(line);
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return left + ((right - left) - max) / 2;
    }
}","{
    int dir = getParagraphDirection(line);
    Alignment align = getParagraphAlignment(line);
    if (align == Alignment.ALIGN_LEFT) {
        return 0;
    } else if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return getParagraphRight(line) - getLineMax(line);
        else
            return 0;
    } else if (align == Alignment.ALIGN_RIGHT) {
        return mWidth - getLineMax(line);
    } else if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT)
            return 0;
        else
            return mWidth - getLineMax(line);
    } else {
        /* align == Alignment.ALIGN_CENTER */
        int left = getParagraphLeft(line);
        int right = getParagraphRight(line);
        int max = ((int) getLineMax(line)) & ~1;
        return left + ((right - left) - max) / 2;
    }
}",1,"/**
 * Get the leftmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
","/**
 * Get the leftmost position that should be exposed for horizontal
 * scrolling on the specified line.
 */
",0,,,0,,,,,,,"1,3",1,"The return statements and control dependency have been changed in the late version. There are changes in the conditions related to `Alignment`, and there's the introduction of `ALIGN_LEFT` and `ALIGN_RIGHT`, which were not present in the early version. Specifically, `ALIGN_NORMAL` and `ALIGN_OPPOSITE` conditions have been modified to handle the new alignment types. Therefore, the code change types are 1 and 3.","The introduction of new conditions `ALIGN_LEFT` and `ALIGN_RIGHT` and the changes in `ALIGN_NORMAL` and `ALIGN_OPPOSITE`'s control flow could lead to this method returning different values than before for certain alignments. Consequently, a Compatibility Issue of type 1 exists due to potential different return values."
328,"<android.app.ContextImpl: void sendOrderedBroadcast(Intent,String,BroadcastReceiver,Handler,int,String,Bundle)>",13,14,,,,"{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}","{
    IIntentReceiver rd = null;
    if (resultReceiver != null) {
        if (mPackageInfo != null) {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = mPackageInfo.getReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false);
        } else {
            if (scheduler == null) {
                scheduler = mMainThread.getHandler();
            }
            rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver();
        }
    }
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermission, true, false);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The addition of the statement ""intent.setAllowFds(false);"" is the change between the two versions. It is not a return or exception handling statement change, a control dependency change, or a dependent API change. Therefore, the code change type is 4.","Since the method does not return any value (void return type), the added statement does not affect the return value or the exceptions thrown by the method. Thus, there is no Compatibility Issue due to this change."
329,<android.widget.DatePicker: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    int flags = DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_SHOW_WEEKDAY | DateUtils.FORMAT_SHOW_YEAR;
    String selectedDateUtterance = DateUtils.formatDateTime(mContext, mCurrentDate.getTimeInMillis(), flags);
    event.getText().add(selectedDateUtterance);
    return true;
}","{
    onPopulateAccessibilityEvent(event);
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4,5",0,"There's a change in the method implementation: the direct logic to populate the AccessibilityEvent has been replaced with a method call to `onPopulateAccessibilityEvent(event)`. This indicates a dependent API change (as the API now depends on `onPopulateAccessibilityEvent` method for its behaviour), along with other statement change because the statements inside the method have been removed and replaced with a method call. However, the return type remains the same, true for both versions.","There is no Compatibility Issue in this code change as the return statement in both versions of the API returns the same constant value (true), hence, from the external point of view who uses this API, behavior is unchanged."
330,"<android.content.ContentProviderProxy: AssetFileDescriptor openAssetFile(Uri,String)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeString(mode);
    mRemote.transact(IContentProvider.OPEN_ASSET_FILE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
    int has = reply.readInt();
    AssetFileDescriptor fd = has != 0 ? AssetFileDescriptor.CREATOR.createFromParcel(reply) : null;
    data.recycle();
    reply.recycle();
    return fd;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeString(mode);
        mRemote.transact(IContentProvider.OPEN_ASSET_FILE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
        int has = reply.readInt();
        AssetFileDescriptor fd = has != 0 ? AssetFileDescriptor.CREATOR.createFromParcel(reply) : null;
        return fd;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"In the early implementation, parcels are recycled after the AssetFileDescriptor is created and before the method returns. In the late implementation, the recycling of parcels is moved inside a 'finally' block, which qualifies as a control dependency change (3), and other statements changed inside the try-finally block (4).","Due to the change being purely structural (moving the recycle calls to a finally block), no functional difference is introduced. The API will not return a different value or throw a different exception due to this structural change, so there is no compatibility issue."
331,<android.content.ContentProviderProxy: String getType(Uri)>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    mRemote.transact(IContentProvider.GET_TYPE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    String out = reply.readString();
    data.recycle();
    reply.recycle();
    return out;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        mRemote.transact(IContentProvider.GET_TYPE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        String out = reply.readString();
        return out;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code change is the addition of a try-finally block around the existing statements and the removal of explicit calls to `recycle()` on `data` and `reply` Parcels outside the block. Since the `recycle()` calls are now placed within the `finally` block, it ensures that these resources will be recycled even if an exception occurs. This is a change in the control dependency and other statement due to change in the structure (3,4).","There is no compatibility issue as the logic of the code and the behavior of the method `getType` have not changed. The return value remains the same and no new exceptions are thrown or handled differently. The method will still return the same `out` String and handle exceptions in the same way as before; it just ensures better resource management with the `finally` block. Therefore, the compatibility issue is 0."
332,<android.widget.TextView: Parcelable onSaveInstanceState()>,13,14,,,,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            SuggestionSpan[] suggestionSpans = sp.getSpans(0, sp.length(), SuggestionSpan.class);
            for (int i = 0; i < suggestionSpans.length; i++) {
                int flags = suggestionSpans[i].getFlags();
                if ((flags & SuggestionSpan.FLAG_EASY_CORRECT) != 0 && (flags & SuggestionSpan.FLAG_MISSPELLED) != 0) {
                    sp.removeSpan(suggestionSpans[i]);
                }
            }
            sp.removeSpan(mSuggestionRangeSpan);
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = mError;
        return ss;
    }
    return superState;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The code change involves adding additional logic to remove certain SuggestionSpan instances from a Spannable instance if they meet specific conditions. This addition is done within an 'if' block that checks if the text is an instance of Spanned, without altering any existing control flow or behavior related to return values or exception handling. Therefore, the type of code change is 4 (Other statement changed).","The new logic regarding SuggestionSpan does not affect the API's external behavior in terms of the returned Parcelable object or the exceptions it might throw. The altered internal behavior specifically targets certain SuggestionSpan instances, but this does not factor into the data saved into the Parcelable object that is returned. The new code only filters the SuggestionSpan instances based on flags and removes them in specific circumstances which is a part of internal state-processing without changing the outcome, thus, there is no Compatibility Issue (0)."
336,"<android.os.storage.IMountService.Stub: boolean onTransact(int,Parcel,Parcel,int)>",13,14,,,,"{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force;
                force = 0 != data.readInt();
                unmountVolume(mountPoint, force);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String key;
                key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(filename, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                Parcelable[] result = getVolumeList();
                reply.writeNoException();
                reply.writeParcelableArray(result, 0);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}","{
    switch(code) {
        case INTERFACE_TRANSACTION:
            {
                reply.writeString(DESCRIPTOR);
                return true;
            }
        case TRANSACTION_registerListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                registerListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unregisterListener:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountServiceListener listener;
                listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
                unregisterListener(listener);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageConnected:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageConnected();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_setUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean enable;
                enable = 0 != data.readInt();
                setUsbMassStorageEnabled(enable);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isUsbMassStorageEnabled:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean result = isUsbMassStorageEnabled();
                reply.writeNoException();
                reply.writeInt((result ? 1 : 0));
                return true;
            }
        case TRANSACTION_mountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int resultCode = mountVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                boolean force = 0 != data.readInt();
                boolean removeEncrypt = 0 != data.readInt();
                unmountVolume(mountPoint, force, removeEncrypt);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_formatVolume:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                int result = formatVolume(mountPoint);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getStorageUsers:
            {
                data.enforceInterface(DESCRIPTOR);
                String path;
                path = data.readString();
                int[] pids = getStorageUsers(path);
                reply.writeNoException();
                reply.writeIntArray(pids);
                return true;
            }
        case TRANSACTION_getVolumeState:
            {
                data.enforceInterface(DESCRIPTOR);
                String mountPoint;
                mountPoint = data.readString();
                String state = getVolumeState(mountPoint);
                reply.writeNoException();
                reply.writeString(state);
                return true;
            }
        case TRANSACTION_createSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int sizeMb;
                sizeMb = data.readInt();
                String fstype;
                fstype = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = createSecureContainer(id, sizeMb, fstype, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_finalizeSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                int resultCode = finalizeSecureContainer(id);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_destroySecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = destroySecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_mountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String key;
                key = data.readString();
                int ownerUid;
                ownerUid = data.readInt();
                int resultCode = mountSecureContainer(id, key, ownerUid);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_unmountSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean force;
                force = 0 != data.readInt();
                int resultCode = unmountSecureContainer(id, force);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_isSecureContainerMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                boolean status = isSecureContainerMounted(id);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_renameSecureContainer:
            {
                data.enforceInterface(DESCRIPTOR);
                String oldId;
                oldId = data.readString();
                String newId;
                newId = data.readString();
                int resultCode = renameSecureContainer(oldId, newId);
                reply.writeNoException();
                reply.writeInt(resultCode);
                return true;
            }
        case TRANSACTION_getSecureContainerPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getSecureContainerList:
            {
                data.enforceInterface(DESCRIPTOR);
                String[] ids = getSecureContainerList();
                reply.writeNoException();
                reply.writeStringArray(ids);
                return true;
            }
        case TRANSACTION_shutdown:
            {
                data.enforceInterface(DESCRIPTOR);
                IMountShutdownObserver observer;
                observer = IMountShutdownObserver.Stub.asInterface(data.readStrongBinder());
                shutdown(observer);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_finishMediaUpdate:
            {
                data.enforceInterface(DESCRIPTOR);
                finishMediaUpdate();
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_mountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String key;
                key = data.readString();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                mountObb(filename, key, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_unmountObb:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean force;
                force = 0 != data.readInt();
                IObbActionListener observer;
                observer = IObbActionListener.Stub.asInterface(data.readStrongBinder());
                int nonce;
                nonce = data.readInt();
                unmountObb(filename, force, observer, nonce);
                reply.writeNoException();
                return true;
            }
        case TRANSACTION_isObbMounted:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                boolean status = isObbMounted(filename);
                reply.writeNoException();
                reply.writeInt((status ? 1 : 0));
                return true;
            }
        case TRANSACTION_getMountedObbPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String filename;
                filename = data.readString();
                String mountedPath = getMountedObbPath(filename);
                reply.writeNoException();
                reply.writeString(mountedPath);
                return true;
            }
        case TRANSACTION_isExternalStorageEmulated:
            {
                data.enforceInterface(DESCRIPTOR);
                boolean emulated = isExternalStorageEmulated();
                reply.writeNoException();
                reply.writeInt(emulated ? 1 : 0);
                return true;
            }
        case TRANSACTION_decryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = decryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_encryptStorage:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = encryptStorage(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_changeEncryptionPassword:
            {
                data.enforceInterface(DESCRIPTOR);
                String password = data.readString();
                int result = changeEncryptionPassword(password);
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
        case TRANSACTION_getVolumeList:
            {
                data.enforceInterface(DESCRIPTOR);
                Parcelable[] result = getVolumeList();
                reply.writeNoException();
                reply.writeParcelableArray(result, 0);
                return true;
            }
        case TRANSACTION_getSecureContainerFilesystemPath:
            {
                data.enforceInterface(DESCRIPTOR);
                String id;
                id = data.readString();
                String path = getSecureContainerFilesystemPath(id);
                reply.writeNoException();
                reply.writeString(path);
                return true;
            }
        case TRANSACTION_getEncryptionState:
            {
                data.enforceInterface(DESCRIPTOR);
                int result = getEncryptionState();
                reply.writeNoException();
                reply.writeInt(result);
                return true;
            }
    }
    return super.onTransact(code, data, reply, flags);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
337,<android.widget.TextView: void getFocusedRect(Rect)>,13,14,,,,"{
    if (mLayout == null) {
        super.getFocusedRect(r);
        return;
    }
    int sel = getSelectionEnd();
    if (sel < 0) {
        super.getFocusedRect(r);
        return;
    }
    int line = mLayout.getLineForOffset(sel);
    r.top = mLayout.getLineTop(line);
    r.bottom = mLayout.getLineBottom(line);
    r.left = (int) mLayout.getPrimaryHorizontal(sel);
    r.right = r.left + 1;
    // Adjust for padding and gravity.
    int paddingLeft = getCompoundPaddingLeft();
    int paddingTop = getExtendedPaddingTop();
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        paddingTop += getVerticalOffset(false);
    }
    r.offset(paddingLeft, paddingTop);
}","{
    if (mLayout == null) {
        super.getFocusedRect(r);
        return;
    }
    int selEnd = getSelectionEnd();
    if (selEnd < 0) {
        super.getFocusedRect(r);
        return;
    }
    int selStart = getSelectionStart();
    if (selStart < 0 || selStart >= selEnd) {
        int line = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(line);
        r.bottom = mLayout.getLineBottom(line);
        r.left = (int) mLayout.getPrimaryHorizontal(selEnd) - 2;
        r.right = r.left + 4;
    } else {
        int lineStart = mLayout.getLineForOffset(selStart);
        int lineEnd = mLayout.getLineForOffset(selEnd);
        r.top = mLayout.getLineTop(lineStart);
        r.bottom = mLayout.getLineBottom(lineEnd);
        if (lineStart == lineEnd) {
            r.left = (int) mLayout.getPrimaryHorizontal(selStart);
            r.right = (int) mLayout.getPrimaryHorizontal(selEnd);
        } else {
            // rect covers the entire width.
            if (mHighlightPath == null)
                mHighlightPath = new Path();
            if (mHighlightPathBogus) {
                mHighlightPath.reset();
                mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                mHighlightPathBogus = false;
            }
            synchronized (sTempRect) {
                mHighlightPath.computeBounds(sTempRect, true);
                r.left = (int) sTempRect.left - 1;
                r.right = (int) sTempRect.right + 1;
            }
        }
    }
    // Adjust for padding and gravity.
    int paddingLeft = getCompoundPaddingLeft();
    int paddingTop = getExtendedPaddingTop();
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
        paddingTop += getVerticalOffset(false);
    }
    r.offset(paddingLeft, paddingTop);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,There are multiple changes made in the late implementation:,- The logic to set `r.left` and `r.right` has been changed significantly and includes additional logic when `selStart` is not the same as `selEnd`.
338,<android.webkit.WebView: boolean isPrivateBrowsingEnabled()>,13,14,,,,"{
    return getSettings().isPrivateBrowsingEnabled();
}","{
    checkThread();
    return getSettings().isPrivateBrowsingEnabled();
}",1,"/**
 * Returns true if private browsing is enabled in this WebView.
 */
","/**
 * Returns true if private browsing is enabled in this WebView.
 */
",0,,,0,,,,,,,4,0,"An additional method call checkThread() is introduced before the return statement, so the change type is 4.","The added checkThread() method call does not alter the return value or the exception handling of the API, as it serves as a precondition check (likely for concurrency issues) without affecting the output. Thus, there is no CI."
339,"<android.view.GLES20Canvas: boolean drawDisplayList(DisplayList,int,int,Rect)>",13,14,,,,"{
    return nDrawDisplayList(mRenderer, ((GLES20DisplayList) displayList).mNativeDisplayList, width, height, dirty);
}","{
    return nDrawDisplayList(mRenderer, ((GLES20DisplayList) displayList).getNativeDisplayList(), width, height, dirty);
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"The method being called in the return statement has changed from directly accessing mNativeDisplayList to using a getter getNativeDisplayList(), thus the code change type is 5.","There is no Compatibility Issue since the return value is still provided by the same object, although through a different method. The change to a getter method does not imply a behavior change that would cause a CI, so the CI type is 0."
340,<android.webkit.WebView: boolean sendViewSizeZoom(boolean)>,13,14,,,,"{
    if (mZoomManager.isPreventingWebkitUpdates())
        return false;
    int viewWidth = getViewWidth();
    int newWidth = Math.round(viewWidth * mZoomManager.getInvScale());
    // This height could be fixed and be different from actual visible height.
    int viewHeight = getViewHeightWithTitle() - getTitleHeight();
    int newHeight = Math.round(viewHeight * mZoomManager.getInvScale());
    // Make the ratio more accurate than (newHeight / newWidth), since the
    // latter both are calculated and rounded.
    float heightWidthRatio = (float) viewHeight / viewWidth;
    /*
         * Because the native side may have already done a layout before the
         * View system was able to measure us, we have to send a height of 0 to
         * remove excess whitespace when we grow our width. This will trigger a
         * layout and a change in content size. This content size change will
         * mean that contentSizeChanged will either call this method directly or
         * indirectly from onSizeChanged.
         */
    if (newWidth > mLastWidthSent && mWrapContent) {
        newHeight = 0;
        heightWidthRatio = 0;
    }
    // Actual visible content height.
    int actualViewHeight = Math.round(getViewHeight() * mZoomManager.getInvScale());
    // Avoid sending another message if the dimensions have not changed.
    if (newWidth != mLastWidthSent || newHeight != mLastHeightSent || force || actualViewHeight != mLastActualHeightSent) {
        ViewSizeData data = new ViewSizeData();
        data.mWidth = newWidth;
        data.mHeight = newHeight;
        data.mHeightWidthRatio = heightWidthRatio;
        data.mActualViewHeight = actualViewHeight;
        data.mTextWrapWidth = Math.round(viewWidth / mZoomManager.getTextWrapScale());
        data.mScale = mZoomManager.getScale();
        data.mIgnoreHeight = mZoomManager.isFixedLengthAnimationInProgress() && !mHeightCanMeasure;
        data.mAnchorX = mZoomManager.getDocumentAnchorX();
        data.mAnchorY = mZoomManager.getDocumentAnchorY();
        mWebViewCore.sendMessage(EventHub.VIEW_SIZE_CHANGED, data);
        mLastWidthSent = newWidth;
        mLastHeightSent = newHeight;
        mLastActualHeightSent = actualViewHeight;
        mZoomManager.clearDocumentAnchor();
        return true;
    }
    return false;
}","{
    if (mBlockWebkitViewMessages)
        return false;
    if (mZoomManager.isPreventingWebkitUpdates())
        return false;
    int viewWidth = getViewWidth();
    int newWidth = Math.round(viewWidth * mZoomManager.getInvScale());
    // This height could be fixed and be different from actual visible height.
    int viewHeight = getViewHeightWithTitle() - getTitleHeight();
    int newHeight = Math.round(viewHeight * mZoomManager.getInvScale());
    // Make the ratio more accurate than (newHeight / newWidth), since the
    // latter both are calculated and rounded.
    float heightWidthRatio = (float) viewHeight / viewWidth;
    /*
         * Because the native side may have already done a layout before the
         * View system was able to measure us, we have to send a height of 0 to
         * remove excess whitespace when we grow our width. This will trigger a
         * layout and a change in content size. This content size change will
         * mean that contentSizeChanged will either call this method directly or
         * indirectly from onSizeChanged.
         */
    if (newWidth > mLastWidthSent && mWrapContent) {
        newHeight = 0;
        heightWidthRatio = 0;
    }
    // Actual visible content height.
    int actualViewHeight = Math.round(getViewHeight() * mZoomManager.getInvScale());
    // Avoid sending another message if the dimensions have not changed.
    if (newWidth != mLastWidthSent || newHeight != mLastHeightSent || force || actualViewHeight != mLastActualHeightSent) {
        ViewSizeData data = new ViewSizeData();
        data.mWidth = newWidth;
        data.mHeight = newHeight;
        data.mHeightWidthRatio = heightWidthRatio;
        data.mActualViewHeight = actualViewHeight;
        data.mTextWrapWidth = Math.round(viewWidth / mZoomManager.getTextWrapScale());
        data.mScale = mZoomManager.getScale();
        data.mIgnoreHeight = mZoomManager.isFixedLengthAnimationInProgress() && !mHeightCanMeasure;
        data.mAnchorX = mZoomManager.getDocumentAnchorX();
        data.mAnchorY = mZoomManager.getDocumentAnchorY();
        mWebViewCore.sendMessage(EventHub.VIEW_SIZE_CHANGED, data);
        mLastWidthSent = newWidth;
        mLastHeightSent = newHeight;
        mLastActualHeightSent = actualViewHeight;
        mZoomManager.clearDocumentAnchor();
        return true;
    }
    return false;
}",1,"/**
 * Compute unzoomed width and height, and if they differ from the last
 * values we sent, send them to webkit (to be used as new viewport)
 *
 * @param force ensures that the message is sent to webkit even if the width
 * or height has not changed since the last message
 *
 * @return true if new values were sent
 */
","/**
 * Compute unzoomed width and height, and if they differ from the last
 * values we sent, send them to webkit (to be used as new viewport)
 *
 * @param force ensures that the message is sent to webkit even if the width
 * or height has not changed since the last message
 *
 * @return true if new values were sent
 */
",0,,,0,,,,,,,,,,
341,"<android.text.SpannableStringBuilder: T[] getSpans(int,int,Class<T>)>",13,14,,,,"{
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int[] flags = mSpanFlags;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    int count = 0;
    T[] ret = null;
    T ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = starts[i];
        int spanEnd = ends[i];
        if (spanStart > gapstart) {
            spanStart -= gaplen;
        }
        if (spanEnd > gapstart) {
            spanEnd -= gaplen;
        }
        if (spanStart > queryEnd) {
            continue;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd)
                continue;
            if (spanEnd == queryStart)
                continue;
        }
        if (kind != null && !kind.isInstance(spans[i])) {
            continue;
        }
        if (count == 0) {
            // Safe conversion thanks to the isInstance test above
            ret1 = (T) spans[i];
            count++;
        } else {
            if (count == 1) {
                // Safe conversion, but requires a suppressWarning
                ret = (T[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = flags[i] & SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                // Safe conversion thanks to the isInstance test above
                ret[j] = (T) spans[i];
                count++;
            } else {
                // Safe conversion thanks to the isInstance test above
                ret[count++] = (T) spans[i];
            }
        }
    }
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        // Safe conversion, but requires a suppressWarning
        ret = (T[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return ret;
    }
    if (count == ret.length) {
        return ret;
    }
    // Safe conversion, but requires a suppressWarning
    T[] nret = (T[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return nret;
}","{
    if (kind == null)
        return ArrayUtils.emptyArray(kind);
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int[] flags = mSpanFlags;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    int count = 0;
    T[] ret = null;
    T ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = starts[i];
        if (spanStart > gapstart) {
            spanStart -= gaplen;
        }
        if (spanStart > queryEnd) {
            continue;
        }
        int spanEnd = ends[i];
        if (spanEnd > gapstart) {
            spanEnd -= gaplen;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd)
                continue;
            if (spanEnd == queryStart)
                continue;
        }
        // Expensive test, should be performed after the previous tests
        if (!kind.isInstance(spans[i]))
            continue;
        if (count == 0) {
            // Safe conversion thanks to the isInstance test above
            ret1 = (T) spans[i];
            count++;
        } else {
            if (count == 1) {
                // Safe conversion, but requires a suppressWarning
                ret = (T[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = flags[i] & SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                // Safe conversion thanks to the isInstance test above
                ret[j] = (T) spans[i];
                count++;
            } else {
                // Safe conversion thanks to the isInstance test above
                ret[count++] = (T) spans[i];
            }
        }
    }
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        // Safe conversion, but requires a suppressWarning
        ret = (T[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return ret;
    }
    if (count == ret.length) {
        return ret;
    }
    // Safe conversion, but requires a suppressWarning
    T[] nret = (T[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return nret;
}",1,"/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
","/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */
",0,"[@SuppressWarnings(""unchecked"")]","[@SuppressWarnings(""unchecked"")]",0,,,,,,,,,,
342,<android.webkit.WebView: void requestImageRef(Message)>,13,14,,,,"{
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    String ref = nativeImageURI(contentX, contentY);
    Bundle data = msg.getData();
    data.putString(""url"", ref);
    msg.setData(data);
    msg.sendToTarget();
}","{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    String ref = nativeImageURI(contentX, contentY);
    Bundle data = msg.getData();
    data.putString(""url"", ref);
    msg.setData(data);
    msg.sendToTarget();
}",1,"/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
","/**
 * Request the url of the image last touched by the user. msg will be sent
 * to its target with a String representing the url as its object.
 *
 * @param msg This message will be dispatched with the result of the request
 * as the data member with ""url"" as key. The result can be null.
 */
",0,,,0,,,,,,,"3,4",0,"The late version of the code includes an additional method call `checkThread()` which is not altering any return or exception handling statements, but it adds a new behavior to the method. Given that `checkThread()` is likely a check on the correct thread usage and doesn't influence the output of the method directly, the code change type is 3 (control dependency change due to the new check that might affect the flow but not a return or exception directly) and 4 (other statement changed because a new statement is introduced that isn't a return or exception handling statement).","Despite the addition of the `checkThread()` method call, it doesn't lead to a Compatibility Issue because it doesn't change how the method `requestImageRef(Message)` behaves in terms of returning a value or throwing an exception; it's a thread check that ensures method is being called on the correct thread. If the thread check fails, it will likely throw a runtime exception which is an implicit behavior of the method, hence, no compatibility issue is introduced."
344,<android.view.View: void sendAccessibilityEventUnchecked(AccessibilityEvent)>,13,14,,,,"{
    if (!isShown()) {
        return;
    }
    event.setClassName(getClass().getName());
    event.setPackageName(getContext().getPackageName());
    event.setEnabled(isEnabled());
    event.setContentDescription(mContentDescription);
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_FOCUSED && mAttachInfo != null) {
        ArrayList<View> focusablesTempList = mAttachInfo.mFocusablesTempList;
        getRootView().addFocusables(focusablesTempList, View.FOCUS_FORWARD, FOCUSABLES_ALL);
        event.setItemCount(focusablesTempList.size());
        event.setCurrentItemIndex(focusablesTempList.indexOf(this));
        focusablesTempList.clear();
    }
    dispatchPopulateAccessibilityEvent(event);
    AccessibilityManager.getInstance(mContext).sendAccessibilityEvent(event);
}","{
    if (mAccessibilityDelegate != null) {
        mAccessibilityDelegate.sendAccessibilityEventUnchecked(this, event);
    } else {
        sendAccessibilityEventUncheckedInternal(event);
    }
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * This method behaves exactly as {@link #sendAccessibilityEvent(int)} but
 * takes as an argument an empty {@link AccessibilityEvent} and does not
 * perform a check whether accessibility is enabled.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#sendAccessibilityEventUnchecked(View, AccessibilityEvent)}
 * is responsible for handling this call.
 * </p>
 *
 * @param event The event to send.
 *
 * @see #sendAccessibilityEvent(int)
 */
",1,,,0,,,,,,,"1,4","1,2","There is a complete overhaul in the implementation. An if condition has been added to check for a null mAccessibilityDelegate, and call delegation or an internal method accordingly. The previous implementation is not visible in the late implementation, which indicates a significant refactoring with the introduction of new methods. Hence, the code change types are 1 and 4 due to the removal of the entire block of code and addition of new control flow and methods.","Since a new condition check has been added and all original statements have been wrapped inside an else, which calls sendAccessibilityEventUncheckedInternal(event) instead of the inline code, and since the old implementation is no longer executed if the mAccessibilityDelegate condition is met, the CI type is 1 due to the potential for different return values or types. Moreover, the introduction of calling a delegate method that possibly throws different exceptions results in a CI type of 2."
345,<android.view.View: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        mPrivateFlags |= PRESSED;
                        refreshDrawableState();
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                if (mPendingCheckForTap == null) {
                    mPendingCheckForTap = new CheckForTap();
                }
                mPrivateFlags |= PREPRESSED;
                mHasPerformedLongPress = false;
                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                break;
            case MotionEvent.ACTION_CANCEL:
                mPrivateFlags &= ~PRESSED;
                refreshDrawableState();
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        // Need to switch from pressed to not pressed
                        mPrivateFlags &= ~PRESSED;
                        refreshDrawableState();
                    }
                }
                break;
        }
        return true;
    }
    return false;
}","{
    final int viewFlags = mViewFlags;
    if ((viewFlags & ENABLED_MASK) == DISABLED) {
        if (event.getAction() == MotionEvent.ACTION_UP && (mPrivateFlags & PRESSED) != 0) {
            mPrivateFlags &= ~PRESSED;
            refreshDrawableState();
        }
        // events, it just doesn't respond to them.
        return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
    }
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch(event.getAction()) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags & PREPRESSED) != 0;
                if ((mPrivateFlags & PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                        focusTaken = requestFocus();
                    }
                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        mPrivateFlags |= PRESSED;
                        refreshDrawableState();
                    }
                    if (!mHasPerformedLongPress) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();
                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }
                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }
                    if (prepressed) {
                        postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }
                    removeTapCallback();
                }
                break;
            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;
                if (performButtonActionOnTouchDown(event)) {
                    break;
                }
                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    mPrivateFlags |= PRESSED;
                    refreshDrawableState();
                    checkForLongClick(0);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
                mPrivateFlags &= ~PRESSED;
                refreshDrawableState();
                removeTapCallback();
                break;
            case MotionEvent.ACTION_MOVE:
                final int x = (int) event.getX();
                final int y = (int) event.getY();
                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags & PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();
                        // Need to switch from pressed to not pressed
                        mPrivateFlags &= ~PRESSED;
                        refreshDrawableState();
                    }
                }
                break;
        }
        return true;
    }
    return false;
}",1,"/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Implement this method to handle touch screen motion events.
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
",0,,,0,,,,,,,,,,
347,"<android.accounts.AbstractAccountAuthenticator.Transport: void confirmCredentials(IAccountAuthenticatorResponse,Account,Bundle)>",13,14,,,,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""confirmCredentials: "" + account);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""confirmCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""confirmCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""confirmCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""confirmCredentials not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""confirmCredentials: "" + account);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.confirmCredentials(new AccountAuthenticatorResponse(response), account, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""confirmCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""confirmCredentials"", account.toString(), e);
    }
}",1,,,0,,,0,,,,,,,"2,3",2,"The catch block has been changed from catching specific exceptions (NetworkErrorException and UnsupportedOperationException) to catching a generic Exception, and handling it with handleException method. Thus, the exception handling statement changed type is 2, and since the control structure of exception handling has been modified, the control dependency changed type is 3.","Due to the change from specific exception handling to generic exception handling, the API could potentially throw different exceptions than it used to (any Exception will now be caught and handled by handleException method). Therefore, the CI type is 2."
348,<android.bluetooth.BluetoothAdapter: boolean cancelDiscovery()>,13,14,,,,"{
    if (getState() != STATE_ON)
        return false;
    try {
        mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}","{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return false;
}",1,"/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
","/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */
",0,,,0,,,,,,,1,1,"The return statament inside the try block is changed from not returning a value to returning the result of mService.cancelDiscovery(), so the code change type is 1.","Because the return statament inside the try block has changed, the method is now potentially returning a different value based on the mService.cancelDiscovery() result instead of always returning false. This could lead to different behaviors when the API is invoked, so the CI type is 1."
349,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAccountRemovalAllowed(IAccountAuthenticatorResponse,Account)>",13,14,,,,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAccountRemovalAllowed(new AccountAuthenticatorResponse(response), account);
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAccountRemovalAllowed not supported"");
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    }
}","{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAccountRemovalAllowed(new AccountAuthenticatorResponse(response), account);
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""getAccountRemovalAllowed"", account.toString(), e);
    }
}",1,,,0,,,0,,,,,,,"2,3",2,"The code change involves a change in exception handling: the catching block for 'UnsupportedOperationException' and 'NetworkErrorException' has been replaced with a generic 'Exception' block. This is classified as change type 2, which is ""Exception handling statement changed."" There is also a change in the control dependency due to the modification in the catch block.","Since the exception handling has been transformed to catch more general exceptions ('Exception' rather than 'UnsupportedOperationException' and 'NetworkErrorException'), it might result in different exception handling behavior. Therefore, the CI type is 2, meaning a ""Compatibility Issue caused by potential different exception handlings."""
350,<android.view.inputmethod.BaseInputConnection: boolean sendKeyEvent(KeyEvent)>,13,14,,,,"{
    synchronized (mIMM.mH) {
        Handler h = mTargetView != null ? mTargetView.getHandler() : null;
        if (h == null) {
            if (mIMM.mServedView != null) {
                h = mIMM.mServedView.getHandler();
            }
        }
        if (h != null) {
            h.sendMessage(h.obtainMessage(ViewRoot.DISPATCH_KEY_FROM_IME, event));
        }
    }
    return false;
}","{
    synchronized (mIMM.mH) {
        Handler h = mTargetView != null ? mTargetView.getHandler() : null;
        if (h == null) {
            if (mIMM.mServedView != null) {
                h = mIMM.mServedView.getHandler();
            }
        }
        if (h != null) {
            h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, event));
        }
    }
    return false;
}",1,"/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
","/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */
",0,,,0,,,,,,,"4,5",0,"The implementation has changed the constant `ViewRoot.DISPATCH_KEY_FROM_IME` to `ViewRootImpl.DISPATCH_KEY_FROM_IME`, which indicates the dependency on another API or constant has changed. Thus, the change types are 4 (Other statement changed) and 5 (Dependent API changed).","Despite the change in the constant used in the `obtainMessage` method call, there is no change in the control flow or the behavior of the `sendKeyEvent` method itself as the return value is consistently `false` and there is no change in exception handling. Therefore, there is no Compatibility Issue."
351,<android.widget.FastScroller: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (mState == STATE_NONE) {
        return false;
    }
    final int action = me.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        if (isPointInside(me.getX(), me.getY())) {
            setState(STATE_DRAGGING);
            if (mListAdapter == null && mList != null) {
                getSectionsFromIndexer();
            }
            if (mList != null) {
                mList.requestDisallowInterceptTouchEvent(true);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
            cancelFling();
            return true;
        }
    } else if (action == MotionEvent.ACTION_UP) {
        // don't add ACTION_CANCEL here
        if (mState == STATE_DRAGGING) {
            if (mList != null) {
                // ViewGroup does the right thing already, but there might
                // be other classes that don't properly reset on touch-up,
                // so do this explicitly just in case.
                mList.requestDisallowInterceptTouchEvent(false);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
            }
            setState(STATE_VISIBLE);
            final Handler handler = mHandler;
            handler.removeCallbacks(mScrollFade);
            if (!mAlwaysShow) {
                handler.postDelayed(mScrollFade, 1000);
            }
            mList.invalidate();
            return true;
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (mState == STATE_DRAGGING) {
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            if (Math.abs(mThumbY - newThumbY) < 2) {
                return true;
            }
            mThumbY = newThumbY;
            // If the previous scrollTo is still pending
            if (mScrollCompleted) {
                scrollTo((float) mThumbY / (viewHeight - mThumbH));
            }
            return true;
        }
    }
    return false;
}","{
    if (mState == STATE_NONE) {
        return false;
    }
    final int action = me.getAction();
    if (action == MotionEvent.ACTION_DOWN) {
        if (isPointInside(me.getX(), me.getY())) {
            if (!mList.isInScrollingContainer()) {
                beginDrag();
                return true;
            }
            mInitialTouchY = me.getY();
            startPendingDrag();
        }
    } else if (action == MotionEvent.ACTION_UP) {
        // don't add ACTION_CANCEL here
        if (mPendingDrag) {
            // Allow a tap to scroll.
            beginDrag();
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            mThumbY = newThumbY;
            scrollTo((float) mThumbY / (viewHeight - mThumbH));
            cancelPendingDrag();
        // Will hit the STATE_DRAGGING check below
        }
        if (mState == STATE_DRAGGING) {
            if (mList != null) {
                // ViewGroup does the right thing already, but there might
                // be other classes that don't properly reset on touch-up,
                // so do this explicitly just in case.
                mList.requestDisallowInterceptTouchEvent(false);
                mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
            }
            setState(STATE_VISIBLE);
            final Handler handler = mHandler;
            handler.removeCallbacks(mScrollFade);
            if (!mAlwaysShow) {
                handler.postDelayed(mScrollFade, 1000);
            }
            mList.invalidate();
            return true;
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (mPendingDrag) {
            final float y = me.getY();
            if (Math.abs(y - mInitialTouchY) > mScaledTouchSlop) {
                setState(STATE_DRAGGING);
                if (mListAdapter == null && mList != null) {
                    getSectionsFromIndexer();
                }
                if (mList != null) {
                    mList.requestDisallowInterceptTouchEvent(true);
                    mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                }
                cancelFling();
                cancelPendingDrag();
            // Will hit the STATE_DRAGGING check below
            }
        }
        if (mState == STATE_DRAGGING) {
            final int viewHeight = mList.getHeight();
            // Jitter
            int newThumbY = (int) me.getY() - mThumbH + 10;
            if (newThumbY < 0) {
                newThumbY = 0;
            } else if (newThumbY + mThumbH > viewHeight) {
                newThumbY = viewHeight - mThumbH;
            }
            if (Math.abs(mThumbY - newThumbY) < 2) {
                return true;
            }
            mThumbY = newThumbY;
            // If the previous scrollTo is still pending
            if (mScrollCompleted) {
                scrollTo((float) mThumbY / (viewHeight - mThumbH));
            }
            return true;
        }
    } else if (action == MotionEvent.ACTION_CANCEL) {
        cancelPendingDrag();
    }
    return false;
}",1,,,0,,,0,,,,,,,,,,
353,<android.widget.RelativeLayout: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    if (mTopToBottomLeftToRightSet == null) {
        mTopToBottomLeftToRightSet = new TreeSet<View>(new TopToBottomLeftToRightComparator());
    }
    // sort children top-to-bottom and left-to-right
    for (int i = 0, count = getChildCount(); i < count; i++) {
        mTopToBottomLeftToRightSet.add(getChildAt(i));
    }
    for (View view : mTopToBottomLeftToRightSet) {
        if (view.dispatchPopulateAccessibilityEvent(event)) {
            mTopToBottomLeftToRightSet.clear();
            return true;
        }
    }
    mTopToBottomLeftToRightSet.clear();
    return false;
}","{
    if (mTopToBottomLeftToRightSet == null) {
        mTopToBottomLeftToRightSet = new TreeSet<View>(new TopToBottomLeftToRightComparator());
    }
    // sort children top-to-bottom and left-to-right
    for (int i = 0, count = getChildCount(); i < count; i++) {
        mTopToBottomLeftToRightSet.add(getChildAt(i));
    }
    for (View view : mTopToBottomLeftToRightSet) {
        if (view.getVisibility() == View.VISIBLE && view.dispatchPopulateAccessibilityEvent(event)) {
            mTopToBottomLeftToRightSet.clear();
            return true;
        }
    }
    mTopToBottomLeftToRightSet.clear();
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,The control dependency has changed because there is an additional condition (view.getVisibility() == View.VISIBLE) in the 'if' statement within the loop in the Late_Implementation. This is a change in the control statement that affects how the statements inside are executed and thus qualifies as a type 3 change.,"Despite the change in control dependency, this would not introduce a compatibility issue since the additional condition reinforces and limits the check to visible views only, which is in accordance with what one would expect from dispatching accessibility events (invisible items generally do not dispatch such events). Therefore, while the control flow has been tightened, it is unlikely to affect existing applications negatively since their logic should not rely on dispatching events for invisible items. Thus, the prediction is 0, no compatibility issue."
354,"<android.app.Activity: View onCreateView(View,String,Context,AttributeSet)>",13,14,,,,"{
    if (!""fragment"".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = mFragments.findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = mFragments.findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(this, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mImmediateActivity = this;
        fragment.mFragmentManager = mFragments;
        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        mFragments.addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        fragment.mImmediateActivity = this;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        }
        mFragments.moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}","{
    if (!""fragment"".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    String fname = attrs.getAttributeValue(null, ""class"");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Must specify unique android:id, android:tag, or have a parent with an id for "" + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = mFragments.findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = mFragments.findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, ""onCreateView: id=0x"" + Integer.toHexString(id) + "" fname="" + fname + "" existing="" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(this, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = mFragments;
        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        mFragments.addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + "": Duplicate id 0x"" + Integer.toHexString(id) + "", tag "" + tag + "", or parent id 0x"" + Integer.toHexString(containerId) + "" with another fragment for "" + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        }
        mFragments.moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException(""Fragment "" + fname + "" did not create a view."");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}",1,"/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */
","/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */
",0,,,0,,,,,,,,,,
358,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: boolean hasStableIds()>,13,14,,,,"{
    return mFactory.hasStableIds();
}","{
    boolean hasStableIds = false;
    try {
        hasStableIds = mFactory.hasStableIds();
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return hasStableIds;
}",1,,,0,,,0,,,,,,,"1,2,3","1,2","There's an addition of a try-catch block, initialization of a local boolean variable, an assignment within the try block, and an exception handler within the catch block. Hence, the code change types include return statement changed (1), exception handling statement changed (2), and control dependency changed (3).","The late version introduces a new way of handling the 'hasStableIds()' method where exceptions are now caught and handled within the method itself instead of propagating them. Also, with the introduction of a variable to hold the result of 'mFactory.hasStableIds()', there's a change in the method's return behavior where by default it will now return false upon an Exception, whereas previously any Exception would propagate out of the method. This signifies that there are compatibility issues caused by potential different return values or types (1) and by potential different exception handlings (2)."
360,"<android.view.GLES20Canvas: void drawText(char[],int,int,float,float,Paint)>",13,14,,,,"{
    if ((index | count | (index + count) | (text.length - index - count)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    boolean hasModifier = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, index, count, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    if ((index | count | (index + count) | (text.length - index - count)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, index, count, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The code has changed in the ""finally"" block where 'hasModifier' was previously a boolean and would evaluate to either the `nResetModifiers(mRenderer)` call or no call at all. In the late version, `modifiers` is an int and the `nResetModifiers(mRenderer, modifiers)` method is called always with `modifiers` as a parameter. The method signature for `nResetModifiers` has changed or overloaded since it now takes an additional parameter. This is categorized as a Control dependency change (3) since the condition for the finally block has changed and Other statement changed (4) because of changed calls to `nResetModifiers`.","Despite the changes, these do not result in a change in the return value of the method (the method returns void) or a different exception being thrown (the same index out of bounds check is performed). The changes reflect an internal modification state, which does not appear to affect the API contract of `drawText`. Therefore, it seems that there will not be a Compatibility Issue (0)."
362,<android.widget.TabWidget: void addView(View)>,13,14,,,,"{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    // tab, then add a divider before adding the next tab.
    if (mDividerDrawable != null && getTabCount() > 0) {
        ImageView divider = new ImageView(mContext);
        final LinearLayout.LayoutParams lp = new LayoutParams(mDividerDrawable.getIntrinsicWidth(), LayoutParams.MATCH_PARENT);
        lp.setMargins(0, 0, 0, 0);
        divider.setLayoutParams(lp);
        divider.setBackgroundDrawable(mDividerDrawable);
        super.addView(divider);
    }
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
    child.setOnFocusChangeListener(this);
}","{
    if (child.getLayoutParams() == null) {
        final LinearLayout.LayoutParams lp = new LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f);
        lp.setMargins(0, 0, 0, 0);
        child.setLayoutParams(lp);
    }
    // Ensure you can navigate to the tab with the keyboard, and you can touch it
    child.setFocusable(true);
    child.setClickable(true);
    super.addView(child);
    // TODO: detect this via geometry with a tabwidget listener rather
    // than potentially interfere with the view's listener
    child.setOnClickListener(new TabClickListener(getTabCount() - 1));
    child.setOnFocusChangeListener(this);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",0,"The code for adding a divider view has been removed. This indicates a change in the implementation where a divider is no longer added between tabs, which is an 'Other statement changed' (4). Additionally, the 'Return statement changed' (1) category applies as the method now always performs a 'super.addView(child)' without the conditional addition of a divider that could affect the control flow.","Despite the implementation changes, there is no change in the API return type or exceptions thrown, and the method does not return any value as its return type is void. Therefore, the behavior regarding the return value and exception handling remains the same for client code, hence no Compatibility Issue."
363,<android.app.FragmentManagerImpl: boolean dispatchOptionsItemSelected(MenuItem)>,13,14,,,,"{
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu) {
                if (f.onOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}","{
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                if (f.onOptionsItemSelected(item)) {
                    return true;
                }
            }
        }
    }
    return false;
}",1,,,0,,,0,,,,,,,3,0,"There's an additional condition (f.mMenuVisible) in the control dependency (if statement) within the loop, so the code change type is 3.","Despite the additional condition (f.mMenuVisible) within the if statement, there's no change in the structure of the return statements or the exception handling. The method will still return true if an item is selected and matches the conditions, or false otherwise. Therefore, no new behavior has been introduced that could lead to a compatibility issue, and the CI type is 0."
365,<android.server.BluetoothService: int getInputDeviceConnectionState(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothInputProfileHandler.getInputDeviceConnectionState(device);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.getInputDeviceConnectionState(device);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The addition of the synchronized block around the return statement does not change the return value; it only ensures thread safety for the operation. Therefore, the code change types are 3 for the control dependency change due to the new 'synchronized' block and 4 because the structure of the code (synchronization) has been altered.","There is no compatibility issue caused by this change since the logic and the return value remain the same; the synchronization just prevents simultaneous access by multiple threads. Therefore, the CI type is 0."
366,<android.content.ContentResolver.CursorWrapperInner: void finalize()>,13,14,,,,"{
    // TODO: integrate CloseGuard support.
    try {
        if (!mCloseFlag) {
            Log.w(TAG, ""Cursor finalized without prior close()"");
            close();
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        if (!mProviderReleased && mContentProvider != null) {
            // Even though we are using CloseGuard, log this anyway so that
            // application developers always see the message in the log.
            Log.w(TAG, ""Cursor finalized without prior close()"");
            ContentResolver.this.releaseProvider(mContentProvider);
        }
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",0,"The implementation of the finalize method has changed, an if condition and CloseGuard related code have been introduced, and the old close logic has been replaced with `ContentResolver.this.releaseProvider(mContentProvider);`. These changes include other statement changes and exception handling statements related to the CloseGuard, hence the change types are 2,4.","There is no Compatibility Issue in terms of behavior, since both implementations aim to ensure that resources are closed before finalization, although the mechanism for warning the developer has changed. The new implementation uses CloseGuard, while the old implementation directly closed the cursor and logged a warning message. Since the purpose and effect of the code remain to enforce that resources should be released, there is no change in the behavior from an external perspective, so the CI type is 0."
367,<android.view.inputmethod.InputMethodManager: void finishInputLocked()>,13,14,,,,"{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        if (mServedInputConnection != null) {
            // We need to tell the previously served view that it is no
            // longer the input target, so it can reset its state.  Schedule
            // this call on its window's Handler so it will be on the correct
            // thread and outside of our lock.
            Handler vh = mServedView.getHandler();
            if (vh != null) {
                // This will result in a call to reportFinishInputConnection()
                // below.
                vh.sendMessage(vh.obtainMessage(ViewRoot.FINISH_INPUT_CONNECTION, mServedInputConnection));
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}","{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, ""FINISH INPUT: "" + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        if (mServedInputConnection != null) {
            // We need to tell the previously served view that it is no
            // longer the input target, so it can reset its state.  Schedule
            // this call on its window's Handler so it will be on the correct
            // thread and outside of our lock.
            Handler vh = mServedView.getHandler();
            if (vh != null) {
                // This will result in a call to reportFinishInputConnection()
                // below.
                vh.sendMessage(vh.obtainMessage(ViewRootImpl.FINISH_INPUT_CONNECTION, mServedInputConnection));
            }
        }
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}",1,"/**
 * Disconnect any existing input connection, clearing the served view.
 */
","/**
 * Disconnect any existing input connection, clearing the served view.
 */
",0,,,0,,,,,,,5,0,"The constant `ViewRoot.FINISH_INPUT_CONNECTION` has been changed to `ViewRootImpl.FINISH_INPUT_CONNECTION`, but the functionality of sendMessage() and the message code remain logically the same. So the code change type is 5 (Dependent API changed).","There is no Compatibility Issue as the change does not affect the method's behavior from the client's perspective. The different reference (`ViewRootImpl` instead of `ViewRoot`) should not cause any observable changes as it is an internal detail, assuming `ViewRootImpl.FINISH_INPUT_CONNECTION` represents the same actual value as `ViewRoot.FINISH_INPUT_CONNECTION`. So the CI type is 0 (No Compatibility Issue)."
368,<android.server.BluetoothService: int getPanDeviceConnectionState(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothPanProfileHandler.getPanDeviceConnectionState(device);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.getPanDeviceConnectionState(device);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code change includes the introduction of a 'synchronized' block around the existing return statement. This affects the thread safety of the code by ensuring that 'getPanDeviceConnectionState' is accessed in a thread-safe manner, but it does not alter the behavior of the method from the perspective of the method caller. Due to the synchronization block added around the return statement, the change type is 3. Additionally, it qualifies as 'Other statement changed' because of the addition of synchronization, which is classified as type 4.",There is no Compatibility Issue because the return value and the behavior of getting the connection state of the PAN device do not change due to the added synchronization. The method still enforces the same permission and returns the same value based on the state retrieved from 'mBluetoothPanProfileHandler.getPanDeviceConnectionState(device)'. The synchronization merely ensures thread safety without affecting the API's external behavior.
370,"<android.app.ContextImpl: boolean bindService(Intent,ServiceConnection,int)>",13,14,,,,"{
    IServiceConnection sd;
    if (mPackageInfo != null) {
        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags);
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
    try {
        int res = ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags);
        if (res < 0) {
            throw new SecurityException(""Not allowed to bind to service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}","{
    IServiceConnection sd;
    if (mPackageInfo != null) {
        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags);
    } else {
        throw new RuntimeException(""Not supported in system context"");
    }
    try {
        IBinder token = getActivityToken();
        if (token == null && (flags & BIND_AUTO_CREATE) == 0 && mPackageInfo != null && mPackageInfo.getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            flags |= BIND_WAIVE_PRIORITY;
        }
        service.setAllowFds(false);
        int res = ActivityManagerNative.getDefault().bindService(mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags);
        if (res < 0) {
            throw new SecurityException(""Not allowed to bind to service "" + service);
        }
        return res != 0;
    } catch (RemoteException e) {
        return false;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",1,"The late version of the implementation introduces a new conditional block that alters the flags variable used in the method call to bindService, adds a new method call service.setAllowFds(false), and uses the token variable for the second time which was previously directly accessed through getActivityToken() method call. Hence, the code change type is 3 for the control dependency change on the if condition, 4 for the new method call, and 5 because the late implementation affects the dependent API bindService through flags variable modification.","The changes to the flags variable and the additional method call to setAllowFds(false) could potentially affect the behavior of the service binding process. These modifications might change the outcome of the API method, where the return value is determined by the result of the bindService method call, resulting in a different boolean value being returned. Hence, the CI type is 1."
372,<android.database.BulkCursorProxy: void deactivate()>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    mRemote.transact(DEACTIVATE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    data.recycle();
    reply.recycle();
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        mRemote.transact(DEACTIVATE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,3,0,"The actual implementation code did not change. Only a try-finally block has been introduced to ensure recycling of the `Parcel` objects, so the change type is 3 as it changes the control dependency structure.","There will be no Compatibility Issue caused by this change since the try-finally blocks are used to ensure that resources are cleaned up properly and do not affect the external behavior of the method; the functional outcome remains the same. Thus, the CI type is 0."
373,<android.content.pm.PackageStats: String toString()>,13,14,,,,"{
    final StringBuilder sb = new StringBuilder(""PackageStats{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" packageName="");
    sb.append(packageName);
    sb.append("",codeSize="");
    sb.append(codeSize);
    sb.append("",dataSize="");
    sb.append(dataSize);
    sb.append("",cacheSize="");
    sb.append(cacheSize);
    sb.append("",externalDataSize="");
    sb.append(externalDataSize);
    sb.append("",externalCacheSize="");
    sb.append(externalCacheSize);
    sb.append("",externalMediaSize="");
    sb.append(externalMediaSize);
    sb.append("",externalObbSize="");
    sb.append(externalObbSize);
    return sb.toString();
}","{
    final StringBuilder sb = new StringBuilder(""PackageStats{"");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("" packageName="");
    sb.append(packageName);
    sb.append("",codeSize="");
    sb.append(codeSize);
    sb.append("",dataSize="");
    sb.append(dataSize);
    sb.append("",cacheSize="");
    sb.append(cacheSize);
    sb.append("",externalCodeSize="");
    sb.append(externalCodeSize);
    sb.append("",externalDataSize="");
    sb.append(externalDataSize);
    sb.append("",externalCacheSize="");
    sb.append(externalCacheSize);
    sb.append("",externalMediaSize="");
    sb.append(externalMediaSize);
    sb.append("",externalObbSize="");
    sb.append(externalObbSize);
    return sb.toString();
}",1,,,0,,,0,,,,,,,4,1,"The late version of the method introduces a new field, externalCodeSize, to the string being built, which is a statement change not related to control structures, return or exception handling. Thus, the change type is 4 (Other statement changed).","The addition of the externalCodeSize field in the toString() output changes what is returned by the method, hence the API will potentially return a different value. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
374,<android.app.FragmentManagerImpl: boolean dispatchPrepareOptionsMenu(Menu)>,13,14,,,,"{
    boolean show = false;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu) {
                show = true;
                f.onPrepareOptionsMenu(menu);
            }
        }
    }
    return show;
}","{
    boolean show = false;
    if (mActive != null) {
        for (int i = 0; i < mAdded.size(); i++) {
            Fragment f = mAdded.get(i);
            if (f != null && !f.mHidden && f.mHasMenu && f.mMenuVisible) {
                show = true;
                f.onPrepareOptionsMenu(menu);
            }
        }
    }
    return show;
}",1,,,0,,,0,,,,,,,3,1,"An additional condition `f.mMenuVisible` is checked in the if statement within the for loop, resulting in a change in control dependency.","The introduction of the additional condition `f.mMenuVisible` could potentially change the outcome of the API, making the `show` variable different from the previous version. Hence, this is a CI caused by potential different return values."
376,"<android.text.TextUtils: int lastIndexOf(CharSequence,char,int,int)>",13,14,,,,"{
    if (last < 0)
        return -1;
    if (last >= s.length())
        last = s.length() - 1;
    int end = last + 1;
    Class c = s.getClass();
    if (s instanceof GetChars || c == StringBuffer.class || c == StringBuilder.class || c == String.class) {
        final int INDEX_INCREMENT = 500;
        char[] temp = obtain(INDEX_INCREMENT);
        while (start < end) {
            int segstart = end - INDEX_INCREMENT;
            if (segstart < start)
                segstart = start;
            getChars(s, segstart, end, temp, 0);
            int count = end - segstart;
            for (int i = count - 1; i >= 0; i--) {
                if (temp[i] == ch) {
                    recycle(temp);
                    return i + segstart;
                }
            }
            end = segstart;
        }
        recycle(temp);
        return -1;
    }
    for (int i = end - 1; i >= start; i--) if (s.charAt(i) == ch)
        return i;
    return -1;
}","{
    if (last < 0)
        return -1;
    if (last >= s.length())
        last = s.length() - 1;
    int end = last + 1;
    Class<? extends CharSequence> c = s.getClass();
    if (s instanceof GetChars || c == StringBuffer.class || c == StringBuilder.class || c == String.class) {
        final int INDEX_INCREMENT = 500;
        char[] temp = obtain(INDEX_INCREMENT);
        while (start < end) {
            int segstart = end - INDEX_INCREMENT;
            if (segstart < start)
                segstart = start;
            getChars(s, segstart, end, temp, 0);
            int count = end - segstart;
            for (int i = count - 1; i >= 0; i--) {
                if (temp[i] == ch) {
                    recycle(temp);
                    return i + segstart;
                }
            }
            end = segstart;
        }
        recycle(temp);
        return -1;
    }
    for (int i = end - 1; i >= start; i--) if (s.charAt(i) == ch)
        return i;
    return -1;
}",1,,,0,,,0,,,,,,,4,0,The change that occurred is in the type of the `Class` object `c` which has been changed to a bounded type `Class<? extends CharSequence>`. This change does not affect the control flow or the outcome of the method as it is merely a refinement of the type parameter to ensure type safety in the source code.,"There is no compatibility issue, because the refinement of the type parameter from `Class` to `Class<? extends CharSequence>` does not change the behavior of the method. All variables returned and all exceptions thrown remain unchanged, and no new control dependencies are introduced."
377,"<android.webkit.FindActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",13,14,,,,"{
    mode.setCustomView(mCustomView);
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_find, menu);
    mActionMode = mode;
    Editable edit = mEditText.getText();
    Selection.setSelection(edit, edit.length());
    mMatches.setVisibility(View.GONE);
    mMatchesFound = false;
    mMatches.setText(""0"");
    mEditText.requestFocus();
    return true;
}","{
    if (!mode.isUiFocusable()) {
        // already less than ideal; disable the option for now.
        return false;
    }
    mode.setCustomView(mCustomView);
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_find, menu);
    mActionMode = mode;
    Editable edit = mEditText.getText();
    Selection.setSelection(edit, edit.length());
    mMatches.setVisibility(View.GONE);
    mMatchesFound = false;
    mMatches.setText(""0"");
    mEditText.requestFocus();
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"In the late version of the implementation, there is an introduction of a new control dependency (an 'if' statement with a conditional check and a return statement) that was not present in the early version. This change is associated with the control dependency change.","The introduction of the new condition (if mode.isUiFocusable()) with an associated return false statement can potentially cause the method to return a different value (false instead of true) when the condition is met. This represents a change in potential behavior, which could lead to a Compatibility Issue of type 1, where the method returns a different value."
379,<android.widget.ScrollView: boolean onInterceptTouchEvent(MotionEvent)>,13,14,,,,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionY is set to the y value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float y = ev.getY(pointerIndex);
                final int yDiff = (int) Math.abs(y - mLastMotionY);
                if (yDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionY = y;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mScrollStrictSpan == null) {
                        mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                    }
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float y = ev.getY();
                if (!inChild((int) ev.getX(), (int) y)) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                if (mIsBeingDragged && mScrollStrictSpan == null) {
                    mScrollStrictSpan = StrictMode.enterCriticalSpan(""ScrollView-scroll"");
                }
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            recycleVelocityTracker();
            if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
381,<android.view.View: float getAlpha()>,13,14,,,,"{
    return mAlpha;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mAlpha : 1;
}",1,"/**
 * The opacity of the view. This is a value from 0 to 1, where 0 means the view is
 * completely transparent and 1 means the view is completely opaque.
 *
 * <p>By default this is 1.0f.
 * @return The opacity of the view.
 */
","/**
 * The opacity of the view. This is a value from 0 to 1, where 0 means the view is
 * completely transparent and 1 means the view is completely opaque.
 *
 * <p>By default this is 1.0f.
 * @return The opacity of the view.
 */
",0,,,0,,,,,,,1,1,"The return statement has been changed to include a new conditional statement which could potentially return a different value based on the condition, so the code change type is 1.","The change in the return statement means that the API potentially returns a different value, specifically if `mTransformationInfo` is not null, it returns `mTransformationInfo.mAlpha`, otherwise, it returns `1`. This is a different behavior compared to always returning `mAlpha`; hence the CI type is 1."
383,<android.content.pm.Signature: boolean equals(Object)>,13,14,,,,"{
    try {
        if (obj != null) {
            Signature other = (Signature) obj;
            return Arrays.equals(mSignature, other.mSignature);
        }
    } catch (ClassCastException e) {
    }
    return false;
}","{
    try {
        if (obj != null) {
            Signature other = (Signature) obj;
            return this == other || Arrays.equals(mSignature, other.mSignature);
        }
    } catch (ClassCastException e) {
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,1,The implementation of the equals method in the late version has a new condition 'this == other' which adds a reference comparison before the content comparison with Arrays.equals. Since this is a logical addition within the return statement it is classified as other statement changed (4).,"This addition can impact the result of the equals comparison such that if the same object is passed to the equals method, it will short-circuit and return true before checking the array content. In the early version, even the same object would still go through array content comparison. This change could lead to different return values when the object compared is actually the same instance, thus a compatibility issue of type 1 could arise due to potential different return values."
384,"<android.database.CursorWindow: String getString(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return getString_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetString(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns a String for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a String value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a string.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a string.
 */
",1,,,0,,,,,,,"1,5",1,"The getString_native() method has been replaced with nativeGetString() and the second parameter of the called method has been changed from `col` to `column`, which indicates that there is a change in the dependent API. Hence, the code change types are 1,5.","The replacement of getString_native() with nativeGetString() method and the change in parameter names indicate there is a potential for the API to return different values even if the behavior and functionality seem to be equivalent, as it depends on the implementation details of these methods and how they interpret the parameters passed. Therefore, there is a CI type 1."
385,<android.webkit.WebView: String getUrl()>,13,14,,,,"{
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getUrl() : null;
}","{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getUrl() : null;
}",1,"/**
 * Get the url for the current page. This is not always the same as the url
 * passed to WebViewClient.onPageStarted because although the load for
 * that url has begun, the current page may not have changed.
 * @return The url for the current page.
 */
","/**
 * Get the url for the current page. This is not always the same as the url
 * passed to WebViewClient.onPageStarted because although the load for
 * that url has begun, the current page may not have changed.
 * @return The url for the current page.
 */
",0,,,0,,,,,,,4,0,"An additional method call 'checkThread()' is added in the beginning of the method which is not a control statement nor does it change the return value, nor the exception handling, so the code change type is 4.","The new method call 'checkThread()' does not affect the output of the method 'getUrl()' since it does not alter the return statement or exception handling, therefore there is no Compatibility Issue."
386,<android.widget.ScrollView: boolean fullScroll(int)>,13,14,,,,"{
    boolean down = direction == View.FOCUS_DOWN;
    int height = getHeight();
    mTempRect.top = 0;
    mTempRect.bottom = height;
    if (down) {
        int count = getChildCount();
        if (count > 0) {
            View view = getChildAt(count - 1);
            mTempRect.bottom = view.getBottom();
            mTempRect.top = mTempRect.bottom - height;
        }
    }
    return scrollAndFocus(direction, mTempRect.top, mTempRect.bottom);
}","{
    boolean down = direction == View.FOCUS_DOWN;
    int height = getHeight();
    mTempRect.top = 0;
    mTempRect.bottom = height;
    if (down) {
        int count = getChildCount();
        if (count > 0) {
            View view = getChildAt(count - 1);
            mTempRect.bottom = view.getBottom() + mPaddingBottom;
            mTempRect.top = mTempRect.bottom - height;
        }
    }
    return scrollAndFocus(direction, mTempRect.top, mTempRect.bottom);
}",1,"/**
 * <p>Handles scrolling in response to a ""home/end"" shortcut press. This
 * method will scroll the view to the top or bottom and give the focus
 * to the topmost/bottommost component in the new visible area. If no
 * component is a good candidate for focus, this scrollview reclaims the
 * focus.</p>
 *
 * @param direction the scroll direction: {@link android.view.View#FOCUS_UP}
 * to go the top of the view or
 * {@link android.view.View#FOCUS_DOWN} to go the bottom
 * @return true if the key event is consumed by this method, false otherwise
 */
","/**
 * <p>Handles scrolling in response to a ""home/end"" shortcut press. This
 * method will scroll the view to the top or bottom and give the focus
 * to the topmost/bottommost component in the new visible area. If no
 * component is a good candidate for focus, this scrollview reclaims the
 * focus.</p>
 *
 * @param direction the scroll direction: {@link android.view.View#FOCUS_UP}
 * to go the top of the view or
 * {@link android.view.View#FOCUS_DOWN} to go the bottom
 * @return true if the key event is consumed by this method, false otherwise
 */
",0,,,0,,,,,,,4,0,"There is an addition of `mPaddingBottom` to the `mTempRect.bottom` assignment within the `if (down)` block. This constitutes a change in a non-control, non-exception handling, non-return and non-dependent API statement, so the code change type is 4.","Although there is a change in how the `mTempRect.bottom` is calculated, the method's return type and the conditions which lead to its execution remain unchanged. Since the modification does not directly affect the control flow or introduce changes that would cause this method to produce a different type of return value, or throw a different exception than before, there is no compatibility issue according to the provided definitions."
388,<android.widget.ExpandableListView: boolean expandGroup(int)>,13,14,,,,"{
    boolean retValue = mConnector.expandGroup(groupPos);
    if (mOnGroupExpandListener != null) {
        mOnGroupExpandListener.onGroupExpand(groupPos);
    }
    return retValue;
}","{
    return expandGroup(groupPos, false);
}",1,"/**
 * Expand a group in the grouped list view
 *
 * @param groupPos the group to be expanded
 * @return True if the group was expanded, false otherwise (if the group
 * was already expanded, this will return false)
 */
","/**
 * Expand a group in the grouped list view
 *
 * @param groupPos the group to be expanded
 * @return True if the group was expanded, false otherwise (if the group
 * was already expanded, this will return false)
 */
",0,,,0,,,,,,,"1,5",1,"The method implementation has changed from a block of codes that calls mConnector.expandGroup(groupPos) and triggers an event if mOnGroupExpandListener is not null, to a single call expandGroup(groupPos, false) and there has been an internal change in the dependent method being called with different parameters. The code change type is 1,5.","The change in implementation potentially leads to different return values because the previously used method may have had different logic compared to the new method with a boolean parameter. Given that the behavior of the method depends on the implementation of expandGroup, if the logic within the dependent method expandGroup(int, boolean) is different, it can lead to a different return value. Therefore, the CI type is 1."
390,<android.preference.PreferenceActivity: void onCreate(Bundle)>,13,14,,,,"{
    super.onCreate(savedInstanceState);
    setContentView(com.android.internal.R.layout.preference_list_content);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            }
        }
    } else {
        if (initialFragment != null && mSinglePane) {
            // If we are just showing a fragment, we want to run in
            // new fragment mode, but don't need to compute and show
            // the headers.
            switchToHeader(initialFragment, initialArguments);
        } else {
            // We need to try to build the headers.
            onBuildHeaders(mHeaders);
            // the currently selected preference fragment.
            if (mHeaders.size() > 0) {
                if (!mSinglePane) {
                    if (initialFragment == null) {
                        Header h = onGetInitialHeader();
                        switchToHeader(h);
                    } else {
                        switchToHeader(initialFragment, initialArguments);
                    }
                }
            }
        }
    }
    // visibility for other configurations.
    if (initialFragment != null && mSinglePane) {
        // Single pane, showing just a prefs fragment.
        findViewById(com.android.internal.R.id.headers).setVisibility(View.GONE);
        mPrefsContainer.setVisibility(View.VISIBLE);
    } else if (mHeaders.size() > 0) {
        mAdapter = new HeaderAdapter(this, mHeaders);
        setListAdapter(mAdapter);
        if (!mSinglePane) {
            // Multi-pane.
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
            if (mCurHeader != null) {
                setSelectedHeader(mCurHeader);
            }
            mPrefsContainer.setVisibility(View.VISIBLE);
        }
    } else {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
    }
    getListView().setScrollBarStyle(View.SCROLLBARS_INSIDE_OVERLAY);
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}","{
    super.onCreate(savedInstanceState);
    setContentView(com.android.internal.R.layout.preference_list_content);
    mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
    mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs_frame);
    boolean hidingHeaders = onIsHidingHeaders();
    mSinglePane = hidingHeaders || !onIsMultiPane();
    String initialFragment = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT);
    Bundle initialArguments = getIntent().getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
    int initialTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE, 0);
    int initialShortTitle = getIntent().getIntExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE, 0);
    if (savedInstanceState != null) {
        // We are restarting from a previous saved state; used that to
        // initialize, instead of starting fresh.
        ArrayList<Header> headers = savedInstanceState.getParcelableArrayList(HEADERS_TAG);
        if (headers != null) {
            mHeaders.addAll(headers);
            int curHeader = savedInstanceState.getInt(CUR_HEADER_TAG, (int) HEADER_ID_UNDEFINED);
            if (curHeader >= 0 && curHeader < mHeaders.size()) {
                setSelectedHeader(mHeaders.get(curHeader));
            }
        }
    } else {
        if (initialFragment != null && mSinglePane) {
            // If we are just showing a fragment, we want to run in
            // new fragment mode, but don't need to compute and show
            // the headers.
            switchToHeader(initialFragment, initialArguments);
            if (initialTitle != 0) {
                CharSequence initialTitleStr = getText(initialTitle);
                CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
                showBreadCrumbs(initialTitleStr, initialShortTitleStr);
            }
        } else {
            // We need to try to build the headers.
            onBuildHeaders(mHeaders);
            // the currently selected preference fragment.
            if (mHeaders.size() > 0) {
                if (!mSinglePane) {
                    if (initialFragment == null) {
                        Header h = onGetInitialHeader();
                        switchToHeader(h);
                    } else {
                        switchToHeader(initialFragment, initialArguments);
                    }
                }
            }
        }
    }
    // visibility for other configurations.
    if (initialFragment != null && mSinglePane) {
        // Single pane, showing just a prefs fragment.
        findViewById(com.android.internal.R.id.headers).setVisibility(View.GONE);
        mPrefsContainer.setVisibility(View.VISIBLE);
        if (initialTitle != 0) {
            CharSequence initialTitleStr = getText(initialTitle);
            CharSequence initialShortTitleStr = initialShortTitle != 0 ? getText(initialShortTitle) : null;
            showBreadCrumbs(initialTitleStr, initialShortTitleStr);
        }
    } else if (mHeaders.size() > 0) {
        setListAdapter(new HeaderAdapter(this, mHeaders));
        if (!mSinglePane) {
            // Multi-pane.
            getListView().setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
            if (mCurHeader != null) {
                setSelectedHeader(mCurHeader);
            }
            mPrefsContainer.setVisibility(View.VISIBLE);
        }
    } else {
        // If there are no headers, we are in the old ""just show a screen
        // of preferences"" mode.
        setContentView(com.android.internal.R.layout.preference_list_content_single);
        mListFooter = (FrameLayout) findViewById(com.android.internal.R.id.list_footer);
        mPrefsContainer = (ViewGroup) findViewById(com.android.internal.R.id.prefs);
        mPreferenceManager = new PreferenceManager(this, FIRST_REQUEST_CODE);
        mPreferenceManager.setOnPreferenceTreeClickListener(this);
    }
    // see if we should show Back/Next buttons
    Intent intent = getIntent();
    if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_BUTTON_BAR, false)) {
        findViewById(com.android.internal.R.id.button_bar).setVisibility(View.VISIBLE);
        Button backButton = (Button) findViewById(com.android.internal.R.id.back_button);
        backButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                finish();
            }
        });
        Button skipButton = (Button) findViewById(com.android.internal.R.id.skip_button);
        skipButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        mNextButton = (Button) findViewById(com.android.internal.R.id.next_button);
        mNextButton.setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                setResult(RESULT_OK);
                finish();
            }
        });
        // set our various button parameters
        if (intent.hasExtra(EXTRA_PREFS_SET_NEXT_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_NEXT_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                mNextButton.setVisibility(View.GONE);
            } else {
                mNextButton.setText(buttonText);
            }
        }
        if (intent.hasExtra(EXTRA_PREFS_SET_BACK_TEXT)) {
            String buttonText = intent.getStringExtra(EXTRA_PREFS_SET_BACK_TEXT);
            if (TextUtils.isEmpty(buttonText)) {
                backButton.setVisibility(View.GONE);
            } else {
                backButton.setText(buttonText);
            }
        }
        if (intent.getBooleanExtra(EXTRA_PREFS_SHOW_SKIP, false)) {
            skipButton.setVisibility(View.VISIBLE);
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
394,<android.content.ContentProviderProxy: ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation>)>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    data.writeInt(operations.size());
    for (ContentProviderOperation operation : operations) {
        operation.writeToParcel(data, 0);
    }
    mRemote.transact(IContentProvider.APPLY_BATCH_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionWithOperationApplicationExceptionFromParcel(reply);
    final ContentProviderResult[] results = reply.createTypedArray(ContentProviderResult.CREATOR);
    data.recycle();
    reply.recycle();
    return results;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        data.writeInt(operations.size());
        for (ContentProviderOperation operation : operations) {
            operation.writeToParcel(data, 0);
        }
        mRemote.transact(IContentProvider.APPLY_BATCH_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithOperationApplicationExceptionFromParcel(reply);
        final ContentProviderResult[] results = reply.createTypedArray(ContentProviderResult.CREATOR);
        return results;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The change here is the addition of a try-finally block for better resource management. There is no change in the actual logic that affects the control flow or the return value. There has been a control dependency change by adding the try-finally block and other statement changed by moving the recycle calls into the finally block, so the code change type is 3,4.","Though the structure of the code has been altered to include a try-finally block, there is no change in the behavior of the API with respect to the return values or the exceptions it might throw. The addition of the try-finally block ensures that the data and reply parcels are recycled even if an exception occurs during the transaction, which aligns with the behavior of the early version but with better resource management. Therefore, there is no Compatibility Issue, and the CI type is 0."
395,<android.view.GLES20DisplayList: HardwareCanvas start()>,13,14,,,,"{
    if (mStarted) {
        throw new IllegalStateException(""Recording has already started"");
    }
    if (mCanvas != null) {
        ((GLES20RecordingCanvas) mCanvas).reset();
    } else {
        mCanvas = new GLES20RecordingCanvas(true);
    }
    mStarted = true;
    mRecorded = false;
    mValid = true;
    return mCanvas;
}","{
    if (mCanvas != null) {
        throw new IllegalStateException(""Recording has already started"");
    }
    mValid = false;
    mCanvas = GLES20RecordingCanvas.obtain(this);
    mCanvas.start();
    return mCanvas;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,2,3,4","1,2","There is a change in the exception handling statement as the condition for throwing the exception changed from checking `mStarted` to `mCanvas`. There are also changes in control dependency as the condition and the order of assignment statements have changed. The late implementation also introduces a new method call `GLES20RecordingCanvas.obtain(this)` and `mCanvas.start()` which are not present in the early version, and removes a reset call for `((GLES20RecordingCanvas) mCanvas).reset()` and flips the value of `mValid` to false before getting the canvas as opposed to setting it to true after the canvas operations, and there are other statement changes regarding variables `mStarted` and `mRecorded` which are set in early version but absent in late version. Hence, the change type is a combination of 1,2,3,4.","The change in the conditions for throwing an exception may lead to a different exception being thrown (`IllegalStateException`), causing a CI of type 2. Additionally, since there are changes in the return statements due to different method calls and removal of some state changes before returning `mCanvas`, this might lead to different return values, causing a CI of type 1."
396,"<android.content.pm.PackageManager: PackageInfo getPackageArchiveInfo(String,int)>",13,14,,,,"{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0);
}","{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0);
}",1,"/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
","/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */
",0,,,0,,,,,,,"3,4",0,"The implementation has an additional conditional block to check for the GET_SIGNATURES flag and, based on that condition, a call to packageParser.collectCertificates(pkg, 0) is added. These are changes of type 3 (Control dependency changed) and 4 (Other statement changed).","There is no change in the method's functionality that affects the return value or the exceptions thrown by the method because the additional collectCertificates call only affects the internals of the PackageParser.Package object without altering what is being returned by getPackageArchiveInfo or introducing a new exception path. Therefore, the pred_CI is 0 (No Compatibility Issue)."
397,<android.webkit.WebView: void rebuildWebTextView()>,13,14,,,,"{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this, mAutoFillData.getQueryId());
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.updateTextSize();
    Rect visibleRect = new Rect();
    calcOurContentVisibleRect(visibleRect);
    // Note that sendOurVisibleRect calls viewToContent, so the coordinates
    // should be in content coordinates.
    Rect bounds = nativeFocusCandidateNodeBounds();
    Rect vBox = contentToViewRect(bounds);
    mWebTextView.setRect(vBox.left, vBox.top, vBox.width(), vBox.height());
    if (!Rect.intersects(bounds, visibleRect)) {
        revealSelection();
    }
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
        // another update when that text is recognized.
        if (text != null && !text.equals(mWebTextView.getText().toString()) && nativeTextGeneration() == mTextGeneration) {
            mWebTextView.setTextAndKeepSelection(text);
        }
    } else {
        mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
        // This needs to be called before setType, which may call
        // requestFormData, and it needs to have the correct nodePointer.
        mWebTextView.setNodePointer(nodePointer);
        mWebTextView.setType(nativeFocusCandidateType());
        updateWebTextViewPadding();
        if (null == text) {
            if (DebugFlags.WEB_VIEW) {
                Log.v(LOGTAG, ""rebuildWebTextView null == text"");
            }
            text = """";
        }
        mWebTextView.setTextAndKeepSelection(text);
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null && imm.isActive(mWebTextView)) {
            imm.restartInput(mWebTextView);
        }
    }
    if (isFocused()) {
        mWebTextView.requestFocus();
    }
}","{
    // If the WebView does not have focus, do nothing until it gains focus.
    if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus())) {
        return;
    }
    boolean alreadyThere = inEditingMode();
    // so we can safely call remove() if (alreadyThere)
    if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
        if (alreadyThere) {
            mWebTextView.remove();
        }
        return;
    }
    // and create the WebTextView if necessary.
    if (mWebTextView == null) {
        mWebTextView = new WebTextView(mContext, WebView.this, mAutoFillData.getQueryId());
        // Initialize our generation number.
        mTextGeneration = 0;
    }
    mWebTextView.updateTextSize();
    updateWebTextViewPosition();
    String text = nativeFocusCandidateText();
    int nodePointer = nativeFocusCandidatePointer();
    // This needs to be called before setType, which may call
    // requestFormData, and it needs to have the correct nodePointer.
    mWebTextView.setNodePointer(nodePointer);
    mWebTextView.setType(nativeFocusCandidateType());
    // Gravity needs to be set after setType
    mWebTextView.setGravityForRtl(nativeFocusCandidateIsRtlText());
    if (null == text) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""rebuildWebTextView null == text"");
        }
        text = """";
    }
    mWebTextView.setTextAndKeepSelection(text);
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null && imm.isActive(mWebTextView)) {
        imm.restartInput(mWebTextView);
        mWebTextView.clearComposingText();
    }
    if (isFocused()) {
        mWebTextView.requestFocus();
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,3,4",1,Several changes can be spotted between the early and late implementations: ,"- The `if(alreadyThere && mWebTextView.isSameTextField(nodePointer)) { ... }` block is removed. As a result, the checking and potential text update that happens in this block are not performed in the late version, which fundamentally changes the control flow and potentially affects the operation of `mWebTextView.setTextAndKeepSelection(text);`. Therefore, it is classified as 'Control dependency changed' (type 3)."
398,<android.server.BluetoothDeviceProperties: boolean isInCache(String)>,13,14,,,,"{
    return (mPropertiesMap.get(address) != null);
}","{
    synchronized (mPropertiesMap) {
        return (mPropertiesMap.get(address) != null);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The change is the addition of a synchronized block around the code. This is a control dependency change (type 3) because synchronization is a form of control structure. Additionally, there is a statement change inside the control structure (type 4) due to introducing a synchronized block; however, there is no change in the functional behavior of the statement itself — it's still checking if an item is present in the map.","The addition of synchronization does not affect the outcome of what the method returns. It controls access to 'mPropertiesMap' in a multi-threaded environment, but the return value for any given input remains unchanged. Therefore, no Compatibility Issue arises in this context."
399,<android.view.HardwareRenderer.GlRenderer: GL createEglSurface(SurfaceHolder)>,13,14,,,,"{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != sEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    /*
             *  The window size has changed, so we need to create a new
             *  surface.
             */
    if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
        /*
                 * Unbind and destroy the old EGL surface, if
                 * there is one.
                 */
        sEgl.eglMakeCurrent(sEglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
        sEgl.eglDestroySurface(sEglDisplay, mEglSurface);
    }
    // Create an EGL surface we can render into.
    mEglSurface = sEgl.eglCreateWindowSurface(sEglDisplay, sEglConfig, holder, null);
    if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
        int error = sEgl.eglGetError();
        if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
            Log.e(LOG_TAG, ""createWindowSurface returned EGL_BAD_NATIVE_WINDOW."");
            return null;
        }
        throw new RuntimeException(""createWindowSurface failed "" + getEGLErrorString(error));
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, sEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + getEGLErrorString(sEgl.eglGetError()));
    }
    if (mDirtyRegions) {
        if (!GLES20Canvas.preserveBackBuffer()) {
            Log.w(LOG_TAG, ""Backbuffer cannot be preserved"");
        }
    }
    return sEglContext.getGL();
}","{
    // Check preconditions.
    if (sEgl == null) {
        throw new RuntimeException(""egl not initialized"");
    }
    if (sEglDisplay == null) {
        throw new RuntimeException(""eglDisplay not initialized"");
    }
    if (sEglConfig == null) {
        throw new RuntimeException(""eglConfig not initialized"");
    }
    if (Thread.currentThread() != mEglThread) {
        throw new IllegalStateException(""HardwareRenderer cannot be used "" + ""from multiple threads"");
    }
    // In case we need to destroy an existing surface
    destroySurface();
    // Create an EGL surface we can render into.
    if (!createSurface(holder)) {
        return null;
    }
    /*
             * Before we can issue GL commands, we need to make sure
             * the context is current and bound to a surface.
             */
    if (!sEgl.eglMakeCurrent(sEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        throw new Surface.OutOfResourcesException(""eglMakeCurrent failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
    }
    // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
    if (sDirtyRegions) {
        if (!(mDirtyRegionsEnabled = GLES20Canvas.preserveBackBuffer())) {
            Log.w(LOG_TAG, ""Backbuffer cannot be preserved"");
        }
    } else if (sDirtyRegionsRequested) {
        // If mDirtyRegions is not set, our EGL configuration does not
        // have EGL_SWAP_BEHAVIOR_PRESERVED_BIT; however, the default
        // swap behavior might be EGL_BUFFER_PRESERVED, which means we
        // want to set mDirtyRegions. We try to do this only if dirty
        // regions were initially requested as part of the device
        // configuration (see RENDER_DIRTY_REGIONS)
        mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
    }
    return mEglContext.getGL();
}",1,,,0,,,0,,,,,,,"2,3,4,5","1,2",The late version includes multiple changes:,"- Other statements changed: The error handling for surface creation now uses `GLUtils.getEGLErrorString` instead of `getEGLErrorString`. Also, the management of dirty regions (preservation of back buffer) has been restructured significantly; the condition check `mDirtyRegions` has been changed to `sDirtyRegions` and `mDirtyRegionsEnabled` assignment logic has changed. `sDirtyRegionsRequested` is newly introduced, and `GLES20Canvas.isBackBufferPreserved()` is a new call."
401,"<android.webkit.WebView: void addJavascriptInterface(Object,String)>",13,14,,,,"{
    if (obj == null) {
        return;
    }
    WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
    arg.mObject = obj;
    arg.mInterfaceName = interfaceName;
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
}","{
    checkThread();
    if (obj == null) {
        return;
    }
    WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
    arg.mObject = obj;
    arg.mInterfaceName = interfaceName;
    mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
}",1,"/**
 * Use this function to bind an object to JavaScript so that the
 * methods can be accessed from JavaScript.
 * <p><strong>IMPORTANT:</strong>
 * <ul>
 * <li> Using addJavascriptInterface() allows JavaScript to control your
 * application. This can be a very useful feature or a dangerous security
 * issue. When the HTML in the WebView is untrustworthy (for example, part
 * or all of the HTML is provided by some person or process), then an
 * attacker could inject HTML that will execute your code and possibly any
 * code of the attacker's choosing.<br>
 * Do not use addJavascriptInterface() unless all of the HTML in this
 * WebView was written by you.</li>
 * <li> The Java object that is bound runs in another thread and not in
 * the thread that it was constructed in.</li>
 * </ul></p>
 * @param obj The class instance to bind to JavaScript, null instances are
 * ignored.
 * @param interfaceName The name to used to expose the instance in
 * JavaScript.
 */
","/**
 * Use this function to bind an object to JavaScript so that the
 * methods can be accessed from JavaScript.
 * <p><strong>IMPORTANT:</strong>
 * <ul>
 * <li> Using addJavascriptInterface() allows JavaScript to control your
 * application. This can be a very useful feature or a dangerous security
 * issue. When the HTML in the WebView is untrustworthy (for example, part
 * or all of the HTML is provided by some person or process), then an
 * attacker could inject HTML that will execute your code and possibly any
 * code of the attacker's choosing.<br>
 * Do not use addJavascriptInterface() unless all of the HTML in this
 * WebView was written by you.</li>
 * <li> The Java object that is bound runs in another thread and not in
 * the thread that it was constructed in.</li>
 * </ul></p>
 * @param obj The class instance to bind to JavaScript, null instances are
 * ignored.
 * @param interfaceName The name to used to expose the instance in
 * JavaScript.
 */
",0,,,0,,,,,,,4,0,"The statement ""checkThread();"" was added at the beginning of the method implementation, which is a new statement but not a return, exception handling, or control dependency change. So, the code change type is 4.","The added statement ""checkThread();"" is likely a concurrency check and does not alter the method's behavior regarding what it returns or the exceptions it may throw. Hence, there is no change that could potentially cause the API to return a different variable or throw a different exception than it previously did, assuming ""checkThread();"" does not throw an exception itself. Therefore, there is no Compatibility Issue, and the CI type is 0."
402,<android.database.BulkCursorProxy: Bundle respond(Bundle)>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    data.writeBundle(extras);
    mRemote.transact(RESPOND_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    Bundle returnExtras = reply.readBundle();
    data.recycle();
    reply.recycle();
    return returnExtras;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        data.writeBundle(extras);
        mRemote.transact(RESPOND_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        Bundle returnExtras = reply.readBundle();
        return returnExtras;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The structure of the code changed by wrapping the existing code into a try-finally block for resource cleanup, and the sequence of recycling Parcel objects has been modified. This would be categorized under control dependency change (3) and other statement changed (4).","These changes don't affect the functional behavior of the method related to its interface contract. The method still performs the same operations and returns the same value under the same conditions; hence, no Compatibility Issue should arise from these changes. The try-finally block ensures that resources are properly cleaned up even if exceptions occur, which is an internal change that does not affect the API's return values or the exceptions it throws."
403,<android.widget.AbsListView: long[] getCheckedItemIds()>,13,14,,,,"{
    if (mChoiceMode == CHOICE_MODE_NONE || mCheckedIdStates == null || mAdapter == null) {
        return new long[0];
    }
    final LongSparseArray<Boolean> idStates = mCheckedIdStates;
    final int count = idStates.size();
    final long[] ids = new long[count];
    for (int i = 0; i < count; i++) {
        ids[i] = idStates.keyAt(i);
    }
    return ids;
}","{
    if (mChoiceMode == CHOICE_MODE_NONE || mCheckedIdStates == null || mAdapter == null) {
        return new long[0];
    }
    final LongSparseArray<Integer> idStates = mCheckedIdStates;
    final int count = idStates.size();
    final long[] ids = new long[count];
    for (int i = 0; i < count; i++) {
        ids[i] = idStates.keyAt(i);
    }
    return ids;
}",1,"/**
 * Returns the set of checked items ids. The result is only valid if the
 * choice mode has not been set to {@link #CHOICE_MODE_NONE} and the adapter
 * has stable IDs. ({@link ListAdapter#hasStableIds()} == {@code true})
 *
 * @return A new array which contains the id of each checked item in the
 * list.
 */
","/**
 * Returns the set of checked items ids. The result is only valid if the
 * choice mode has not been set to {@link #CHOICE_MODE_NONE} and the adapter
 * has stable IDs. ({@link ListAdapter#hasStableIds()} == {@code true})
 *
 * @return A new array which contains the id of each checked item in the
 * list.
 */
",0,,,0,,,,,,,4,0,"The type within the LongSparseArray from Boolean to Integer (LongSparseArray<Boolean> to LongSparseArray<Integer>) has changed, which is an internal type change in a statement. Thus, the code change type is 4.","There's no Compatibility Issue because this internal change does not affect the return values or the exceptions since only the generic type of LongSparseArray is changed and it does not alter the behavior of how ids[] array is populated or returned. The return type is still long[] and the values are determined by idStates.keyAt(i), which is unaffected by the type of value the LongSparseArray stores."
405,<android.server.BluetoothService: void updateBluetoothState(String)>,13,14,,,,"{
    if (mBluetoothState == BluetoothAdapter.STATE_TURNING_ON) {
        ParcelUuid[] adapterUuids = convertStringToParcelUuid(uuids);
        if (mAdapterUuids != null && BluetoothUuid.containsAllUuids(adapterUuids, mAdapterUuids)) {
            setBluetoothState(BluetoothAdapter.STATE_ON);
            autoConnect();
            String[] propVal = { ""Pairable"", getProperty(""Pairable"") };
            mEventLoop.onPropertyChanged(propVal);
            // Log bluetooth on to battery stats.
            long ident = Binder.clearCallingIdentity();
            try {
                mBatteryStats.noteBluetoothOn();
            } catch (RemoteException e) {
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
                disable(false);
            }
        }
    }
}","{
    ParcelUuid[] adapterUuids = convertStringToParcelUuid(uuids);
    if (mAdapterUuids != null && BluetoothUuid.containsAllUuids(adapterUuids, mAdapterUuids)) {
        mBluetoothState.sendMessage(BluetoothAdapterStateMachine.SERVICE_RECORD_LOADED);
    }
}",1,"/**
 * This function is called from Bluetooth Event Loop when onPropertyChanged
 * for adapter comes in with UUID property.
 * @param uuidsThe uuids of adapter as reported by Bluez.
 */
","/*package*/
",1,,,0,,,,,,,"1,3,4",1,"The implementation has been significantly changed: the condition for setting Bluetooth state and several method calls inside the if block have been removed, along with exception handling for RemoteException and the related try-finally block. The entire if block condition and all of its contents have been replaced with a single message send to mBluetoothState. Also, a variable 'adapterUuids' which depends on 'convertStringToParcelUuid(uuids)' method call has been lifted out of the conditional. Therefore, the changes include return statement changed, control dependency changed, and other statements changed.","Due to the removal of the condition check for mBluetoothState and subsequent statements, as well as the introduction of a new action, these changes can lead to potential different behaviors when the Bluetooth state is updated, which constitutes a compatibility issue with type 1."
407,"<android.widget.AdapterView: boolean performItemClick(View,int,long)>",13,14,,,,"{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        return true;
    }
    return false;
}","{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        mOnItemClickListener.onItemClick(this, view, position, id);
        return true;
    }
    return false;
}",1,"/**
 * Call the OnItemClickListener, if it is defined.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
","/**
 * Call the OnItemClickListener, if it is defined.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */
",0,,,0,,,,,,,"3,4",0,"In the late version, a new 'if' condition has been introduced to check if the view is non-null and then call `view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED)`. However, there are no changes to the returned value or the overall flow of the method that affects its returning value. This addition is a new statement that is not a return, exception, or dependent API call, resulting in change types 3 (Control dependency changed) and 4 (Other statement changed).","Although a new statement was inserted that sends an accessibility event based on a condition, this does not affect the return value of the method or its exception throwing behavior. The method's capability to return `true` or `false` based on the `mOnItemClickListener` remains intact. Thus, there is no Compatibility Issue here, as the code change does not lead to different return values or exception handlings."
408,"<android.webkit.WebView: void loadDataWithBaseURL(String,String,String,String,String)>",13,14,,,,"{
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadData(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearHelpers();
}","{
    checkThread();
    if (baseUrl != null && baseUrl.toLowerCase().startsWith(""data:"")) {
        loadDataImpl(data, mimeType, encoding);
        return;
    }
    switchOutDrawHistory();
    WebViewCore.BaseUrlData arg = new WebViewCore.BaseUrlData();
    arg.mBaseUrl = baseUrl;
    arg.mData = data;
    arg.mMimeType = mimeType;
    arg.mEncoding = encoding;
    arg.mHistoryUrl = historyUrl;
    mWebViewCore.sendMessage(EventHub.LOAD_DATA, arg);
    clearHelpers();
}",1,"/**
 * Load the given data into the WebView, use the provided URL as the base
 * URL for the content. The base URL is the URL that represents the page
 * that is loaded through this interface. As such, it is used to resolve any
 * relative URLs. The historyUrl is used for the history entry.
 * <p>
 * Note for post 1.0. Due to the change in the WebKit, the access to asset
 * files through ""file:///android_asset/"" for the sub resources is more
 * restricted. If you provide null or empty string as baseUrl, you won't be
 * able to access asset files. If the baseUrl is anything other than
 * http(s)/ftp(s)/about/javascript as scheme, you can access asset files for
 * sub resources.
 *
 * @param baseUrl Url to resolve relative paths with, if null defaults to
 * ""about:blank""
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data. i.e. text/html. If null,
 * defaults to ""text/html""
 * @param encoding The encoding of the data. i.e. utf-8, us-ascii
 * @param historyUrl URL to use as the history entry.  Can be null.
 */
","/**
 * Load the given data into the WebView, using baseUrl as the base URL for
 * the content. The base URL is used both to resolve relative URLs and when
 * applying JavaScript's same origin policy. The historyUrl is used for the
 * history entry.
 * <p>
 * Note that content specified in this way can access local device files
 * (via 'file' scheme URLs) only if baseUrl specifies a scheme other than
 * 'http', 'https', 'ftp', 'ftps', 'about' or 'javascript'.
 * <p>
 * If the base URL uses the data scheme, this method is equivalent to
 * calling {@link #loadData(String,String,String) loadData()} and the
 * historyUrl is ignored.
 * @param baseUrl URL to use as the page's base URL. If null defaults to
 * 'about:blank'
 * @param data A String of data in the given encoding.
 * @param mimeType The MIMEType of the data, e.g. 'text/html'. If null,
 * defaults to 'text/html'.
 * @param encoding The encoding of the data.
 * @param historyUrl URL to use as the history entry, if null defaults to
 * 'about:blank'.
 */
",1,,,0,,,,,,,4,0,"The method call loadData(data, mimeType, encoding) was replaced with loadDataImpl(data, mimeType, encoding), and the method checkThread() was added at the beginning of the method. These changes are not control statements, return statements, or exception handling, so the code change type is 4.","There is no Compatibility Issue detected. The addition of checkThread() is an internal check that should not affect the external behavior of the method as long as the thread precondition is met. The modification of loadData() to loadDataImpl() is an internal change, and without further context on how loadDataImpl() behaves, it can be assumed the behavior remains internally consistent as this is a common practice for versioning or altering internal implementations without changing the public API contract. The same return paths and exception handling seem to be present in both versions, assuming loadDataImpl() throws no new exceptions. Thus, there is no indication of a different return value or new exceptions being thrown based on the given code."
409,<android.server.BluetoothService: String getAddress()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return getProperty(""Address"");
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    // Don't check state since we want to provide address, even if BT is off
    return getProperty(""Address"", false);
}",1,,,0,,,0,,,,,,,5,1,"The dependent API getProperty(String) has been changed to getProperty(String, boolean) by including an additional boolean parameter, which is a Dependent API changed type 5.","The dependent API change involves adding an additional parameter to the getProperty method call, potentially changing the behavior of the method and therefore leading to a different return value. Thus, the CI type is 1."
411,<android.speech.tts.TextToSpeech: int isLanguageAvailable(Locale)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        try {
            result = mITts.isLanguageAvailable(loc.getISO3Language(), loc.getISO3Country(), loc.getVariant(), mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isLanguageAvailable"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.isLanguageAvailable(loc.getISO3Language(), loc.getISO3Country(), loc.getVariant());
        }
    }, LANG_NOT_SUPPORTED, ""isLanguageAvailable"");
}",1,"/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc
 * The Locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Checks if the specified language as represented by the Locale is available and supported.
 *
 * @param loc The Locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",1,,,0,,,,,,,"1,3,4,5","1,2","The entire implementation of the method has changed, including the structure and the underlying mechanism for executing the action. The method now uses a `runAction` method to handle the language availability check, which likely changes how exceptions are handled and how the value is returned. So this is a case with changes in return statement, exception handling, control dependency, and use of a dependent API, resulting in types 1,3,4,5.","The modification in the mechanism of execution could lead to both different return values (e.g., different handling of situations where TTS is not started), and different exception handling (no more catching of NullPointerException or IllegalStateException, and RemoteException is now handled inside the runAction method). As the code change potentially leads to changes in API behavior in terms of both return values and exceptions, the CI types are 1,2."
412,<android.widget.ScrollView: boolean arrowScroll(int)>,13,14,,,,"{
    View currentFocused = findFocus();
    if (currentFocused == this)
        currentFocused = null;
    View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
    final int maxJump = getMaxScrollAmount();
    if (nextFocused != null && isWithinDeltaOfScreen(nextFocused, maxJump, getHeight())) {
        nextFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(nextFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
        nextFocused.requestFocus(direction);
    } else {
        // no new focus
        int scrollDelta = maxJump;
        if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
            scrollDelta = getScrollY();
        } else if (direction == View.FOCUS_DOWN) {
            if (getChildCount() > 0) {
                int daBottom = getChildAt(0).getBottom();
                int screenBottom = getScrollY() + getHeight();
                if (daBottom - screenBottom < maxJump) {
                    scrollDelta = daBottom - screenBottom;
                }
            }
        }
        if (scrollDelta == 0) {
            return false;
        }
        doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
    }
    if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
        // previously focused item still has focus and is off screen, give
        // it up (take it back to ourselves)
        // (also, need to temporarily force FOCUS_BEFORE_DESCENDANTS so we are
        // sure to
        // get it)
        // save
        final int descendantFocusability = getDescendantFocusability();
        setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
        requestFocus();
        // restore
        setDescendantFocusability(descendantFocusability);
    }
    return true;
}","{
    View currentFocused = findFocus();
    if (currentFocused == this)
        currentFocused = null;
    View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
    final int maxJump = getMaxScrollAmount();
    if (nextFocused != null && isWithinDeltaOfScreen(nextFocused, maxJump, getHeight())) {
        nextFocused.getDrawingRect(mTempRect);
        offsetDescendantRectToMyCoords(nextFocused, mTempRect);
        int scrollDelta = computeScrollDeltaToGetChildRectOnScreen(mTempRect);
        doScrollY(scrollDelta);
        nextFocused.requestFocus(direction);
    } else {
        // no new focus
        int scrollDelta = maxJump;
        if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
            scrollDelta = getScrollY();
        } else if (direction == View.FOCUS_DOWN) {
            if (getChildCount() > 0) {
                int daBottom = getChildAt(0).getBottom();
                int screenBottom = getScrollY() + getHeight() - mPaddingBottom;
                if (daBottom - screenBottom < maxJump) {
                    scrollDelta = daBottom - screenBottom;
                }
            }
        }
        if (scrollDelta == 0) {
            return false;
        }
        doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
    }
    if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
        // previously focused item still has focus and is off screen, give
        // it up (take it back to ourselves)
        // (also, need to temporarily force FOCUS_BEFORE_DESCENDANTS so we are
        // sure to
        // get it)
        // save
        final int descendantFocusability = getDescendantFocusability();
        setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
        requestFocus();
        // restore
        setDescendantFocusability(descendantFocusability);
    }
    return true;
}",1,"/**
 * Handle scrolling in response to an up or down arrow click.
 *
 * @param direction The direction corresponding to the arrow key that was
 * pressed
 * @return True if we consumed the event, false otherwise
 */
","/**
 * Handle scrolling in response to an up or down arrow click.
 *
 * @param direction The direction corresponding to the arrow key that was
 * pressed
 * @return True if we consumed the event, false otherwise
 */
",0,,,0,,,,,,,"3,4",0,The change happened in the expression used to calculate 'screenBottom' where 'mPaddingBottom' is subtracted from 'getHeight()' in the late implementation. This is a change in the arithmetic expression used in an assignment statement (other statement change) and may also affect the control flow because it influences the value of 'scrollDelta' within an if-statement (control dependency change).,"Although the change could potentially affect how much the ScrollView scrolls, it wouldn't yield a compatibility issue concerning the method's return value or exception handling. This method returns a boolean indicating if it successfully scrolled, not how much it scrolled. The modification doesn't introduce any new scenarios where the method would return a different boolean value or where it would throw a different exception; it merely adjusts the scroll by taking the padding into account to continue providing the correct boolean result. Hence, there is no compatibility issue."
413,"<android.app.WallpaperManager: void sendWallpaperCommand(IBinder,String,int,int,int,Bundle)>",13,14,,,,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRoot.getWindowSession(mContext.getMainLooper()).sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
","/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as ""com.mycompany.wallpaper.DOIT"".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */
",0,,,0,,,,,,,"4,5",0,"The change between the versions is the call from ""ViewRoot"" to ""ViewRootImpl"" in getting the window session. This is considered an internal change to the implementation, and it is a change in a dependent API. Therefore, the types are 4 for an internal change and 5 for the dependent API change.","Despite the change in the dependent API, the overall behavior of the method remains unchanged as long as the getWindowSession() method of ViewRootImpl has the same signature and expected behavior as the one from ViewRoot. Since the catch block for RemoteException has not changed and any exceptions are still ignored, there is no change in the exception thrown by the method. Hence, there is no Compatibility Issue."
414,"<android.database.CursorWindow: void copyStringToBuffer(int,int,CharArrayBuffer)>",13,14,,,,"{
    if (buffer == null) {
        throw new IllegalArgumentException(""CharArrayBuffer should not be null"");
    }
    if (buffer.data == null) {
        buffer.data = new char[64];
    }
    acquireReference();
    try {
        char[] newbuf = copyStringToBuffer_native(row - mStartPos, col, buffer.data.length, buffer);
        if (newbuf != null) {
            buffer.data = newbuf;
        }
    } finally {
        releaseReference();
    }
}","{
    if (buffer == null) {
        throw new IllegalArgumentException(""CharArrayBuffer should not be null"");
    }
    acquireReference();
    try {
        nativeCopyStringToBuffer(mWindowPtr, row - mStartPos, column, buffer);
    } finally {
        releaseReference();
    }
}",1,"/**
 * copy the text for the given field in the provided char array.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @param buffer the CharArrayBuffer to copy the text into,
 * If the requested string is larger than the buffer
 * a new char buffer will be created to hold the string. and assigne to
 * CharArrayBuffer.data
 */
","/**
 * Copies the text of the field at the specified row and column index into
 * a {@link CharArrayBuffer}.
 * <p>
 * The buffer is populated as follows:
 * <ul>
 * <li>If the buffer is too small for the value to be copied, then it is
 * automatically resized.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the buffer
 * is set to an empty string.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the buffer
 * is set to the contents of the string.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the buffer
 * is set to a string representation of the integer in decimal, obtained by formatting the
 * value with the <code>printf</code> family of functions using
 * format specifier <code>%lld</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the buffer is
 * set to a string representation of the floating-point value in decimal, obtained by
 * formatting the value with the <code>printf</code> family of functions using
 * format specifier <code>%g</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @param buffer The {@link CharArrayBuffer} to hold the string.  It is automatically
 * resized if the requested string is larger than the buffer's current capacity.
 */
",1,,,0,,,,,,,"1,3,4,5","1,2","The early version has a branch checking if buffer.data is null and initializes it if needed, which is entirely removed in the late version, and the implementation detail within the try block is changed significantly (from using copyStringToBuffer_native to nativeCopyStringToBuffer with altered parameters). This qualifies the code change types as 1 for the return statement, 3 for the control dependency change, 4 for other statement change, and 5 for the dependent API change.","Compatibility Issues could occur as potentially different values can be returned due to the removal of the buffer.data initialization and changes within the try block. Additionally, there is a possibility of different exceptions being thrown as the behavior of nativeCopyStringToBuffer could differ from the previous copyStringToBuffer_native, particularly in how errors are handled when the native method is invoked. This qualifies as CI types 1 for potential different return values and 2 for potential different exception handlings."
417,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setAnimatedValue(Object)>,13,14,,,,"{
    if (mJniSetter != 0) {
        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);
        return;
    }
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = mIntAnimatedValue;
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}","{
    if (mIntProperty != null) {
        mIntProperty.setValue(target, mIntAnimatedValue);
        return;
    }
    if (mProperty != null) {
        mProperty.set(target, mIntAnimatedValue);
        return;
    }
    if (mJniSetter != 0) {
        nCallIntMethod(target, mJniSetter, mIntAnimatedValue);
        return;
    }
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = mIntAnimatedValue;
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}",1,"/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
","/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
",0,[@Override],[@Override],0,,,,,,,"1,3,4",0,"The method implementation has changed to include additional checks and method calls on 'mIntProperty' and 'mProperty'. While there is no change in return value type, the sequence of operations and the conditions under which they are performed has changed, hence it's a combination of control dependency changes (type 3) and other statement changes (type 4). Moreover, because these changes introduce new variables that are not present in the early version, 'mIntProperty' and 'mProperty', which are independent APIs, their introduction constitutes a dependent API change (type 5).","Although the logic of the method has been significantly altered, it is not clear that this will lead to a different return value or type since every code path in the late version still ends with setting the animated value in a manner analogous to the early version, just through potentially different properties or methods. Furthermore, there is no change in the exception handling as the same exceptions are caught and handled in the same way. Hence, no compatibility issue in the context of return values or types (type 1) or exception handlings (type 2) is detected based on the given instructions and definitions."
418,"<android.webkit.SslErrorHandlerImpl: boolean checkSslPrefTable(LoadListener,SslError)>",13,14,,,,"{
    final String host = loader.host();
    final int primary = error.getPrimaryError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
        if (primary <= mSslPrefTable.getInt(host)) {
            handleSslErrorResponse(loader, error, true);
            return true;
        }
    }
    return false;
}","{
    final String host = loader.host();
    final int primary = error.getPrimaryError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
        assert host != null;
        assert primary != -1;
    }
    if (mSslPrefTable.containsKey(host) && primary <= mSslPrefTable.getInt(host)) {
        if (!loader.cancelled()) {
            loader.handleSslErrorResponse(true);
        }
        return true;
    }
    return false;
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"3,4",0,"There are changes in the assertion condition within the 'if' statement and the code block within the 'if' condition that checks the preference table. There's also an additional check for loader cancellation and a change in how the SSL error response is handled. Thus, the code changes are 3 and 4.","While there are changes to the assertions and the handling of the SSL error response, these are not changes that would result in a Compatibility Issue. The return statements are unchanged, and the exception handling remains the same. Therefore, there's no Compatibility Issue occurring here."
420,<android.webkit.ZoomManager.ScaleDetectorListener: boolean onScaleBegin(ScaleGestureDetector)>,13,14,,,,"{
    mInitialZoomOverview = false;
    dismissZoomPicker();
    mFocusMovementQueue.clear();
    mWebView.mViewManager.startZoom();
    mWebView.onPinchToZoomAnimationStart();
    mAccumulatedSpan = 0;
    return true;
}","{
    mInitialZoomOverview = false;
    dismissZoomPicker();
    mFocusMovementQueue.clear();
    mFocusX = detector.getFocusX();
    mFocusY = detector.getFocusY();
    mWebView.mViewManager.startZoom();
    mWebView.onPinchToZoomAnimationStart();
    mAccumulatedSpan = 0;
    return true;
}",1,,,0,,,0,,,,,,,4,0,"Two new assignments have been added (`mFocusX = detector.getFocusX();` and `mFocusY = detector.getFocusY();`) but the return statement remains the same and the method still returns a constant `true` value, so the code change type is 4.","As the added assignments do not affect the return value nor the exceptions thrown by the method, there is no Compatibility Issue, thus CI type is 0."
421,"<android.speech.tts.TextToSpeech: int playEarcon(String,int,HashMap<String, String>)>",13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                String extra = params.get(Engine.KEY_PARAM_STREAM);
                if (extra != null) {
                    mCachedParams[Engine.PARAM_POSITION_STREAM + 1] = extra;
                }
                setCachedParam(params, Engine.KEY_PARAM_STREAM, Engine.PARAM_POSITION_STREAM);
                setCachedParam(params, Engine.KEY_PARAM_UTTERANCE_ID, Engine.PARAM_POSITION_UTTERANCE_ID);
            }
            result = mITts.playEarcon(mPackageName, earcon, queueMode, null);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playEarcon"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playEarcon"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playEarcon"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri earconUri = mEarcons.get(earcon);
            if (earconUri == null) {
                return ERROR;
            }
            return service.playAudio(getPackageName(), earconUri, queueMode, getParams(params));
        }
    }, ERROR, ""playEarcon"");
}",1,"/**
 * Plays the earcon using the specified queueing mode and parameters.
 *
 * @param earcon
 * The earcon that should be played
 * @param queueMode
 * {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_STREAM} or
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Plays the earcon using the specified queueing mode and parameters.
 * The earcon must already have been added with {@link #addEarcon(String, String)} or
 * {@link #addEarcon(String, String, int)}.
 *
 * @param earcon The earcon that should be played
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,2,3,4,5","1,2","The implementation has been completely refactored, leading to changes in return statements, exception handling statements, control dependency statements, and other statements. Moreover, this includes a change in the way the method interacts with dependent APIs such as mITts.playEarcon and the introduction of new lambdas and callbacks, signaling a change in dependent APIs as well.","Since the method's return value now depends on the success or failure of different internal API calls, the potential return values have been altered, leading to CI type 1. Additionally, exception handling is also changed. The old version caught a few specific exceptions and performed certain actions, while the new version propagates exceptions through a different mechanism. This could lead to a different exception being thrown under similar circumstances, indicating CI type 2."
424,<android.speech.tts.TextToSpeech: int setLanguage(Locale)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = LANG_NOT_SUPPORTED;
        if (!mStarted) {
            return result;
        }
        if (loc == null) {
            return result;
        }
        try {
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            result = mITts.isLanguageAvailable(language, country, variant, mCachedParams);
            if (result >= LANG_AVAILABLE) {
                mCachedParams[Engine.PARAM_POSITION_LANGUAGE + 1] = language;
                if (result >= LANG_COUNTRY_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = country;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_COUNTRY + 1] = """";
                }
                if (result >= LANG_COUNTRY_VAR_AVAILABLE) {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = variant;
                } else {
                    mCachedParams[Engine.PARAM_POSITION_VARIANT + 1] = """";
                }
            }
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setLanguage"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = loc.getISO3Language();
            String country = loc.getISO3Country();
            String variant = loc.getVariant();
            // Check if the language, country, variant are available, and cache
            // the available parts.
            // Note that the language is not actually set here, instead it is cached so it
            // will be associated with all upcoming utterances.
            int result = service.loadLanguage(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = """";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = """";
                    }
                }
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, ""setLanguage"");
}",1,"/**
 * Sets the language for the TextToSpeech engine.
 * The TextToSpeech engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc
 * The locale describing the language to be used.
 *
 * @return code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
","/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */
",1,,,0,,,,,,,"1,3,4,5",1,"The late version removed the synchronized block and used a different method (runAction) to execute the code, which changes the threading model. The internal implementation has been refactored to avoid explicit exception handling and instead, uses a different dependent API `service.loadLanguage` (the early version uses `mITts.isLanguageAvailable`). Different variables are used to store language, country, and variant data. The structure of the code has seen substantial refactoring, which implicates control dependency change, other statement changes, and dependent API changes.","Since there is a change in the method used to set the language and the structure has been substantially refactored, there could be a different behavior in the return value (either a different value is returned or the conditions under which values are returned have changed). The refactoring indicates that the method may have a different behavior in terms of how it processes the input Locale and whether or not it supports the particular language features, resulting in different return codes, which is a compatibility issue."
426,<android.bluetooth.BluetoothSocket: BluetoothSocket accept(int)>,13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            throw new IOException(""socket closed"");
        return acceptNative(timeout);
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        BluetoothSocket acceptedSocket = acceptNative(timeout);
        mSocketState = SocketState.CONNECTED;
        return acceptedSocket;
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"1,4",1,"The condition in the 'if' statement checks a different variable (from mClosed to mSocketState) and a new assignment statement has been introduced to change the state of mSocketState, which leads to code change types of 1 and 4.","The assignment statement (mSocketState = SocketState.CONNECTED;) can potentially change the behavior of subsequent method calls or the state of the object, which may cause the API to return a different value in future interactions. Therefore, the CI type is 1."
428,<android.database.CursorWindow: int getNumRows()>,13,14,,,,"{
    acquireReference();
    try {
        return getNumRows_native();
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetNumRows(mWindowPtr);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns the number of rows in this window.
 *
 * @return the number of rows in this window.
 */
","/**
 * Gets the number of rows in this window.
 *
 * @return The number of rows in this cursor window.
 */
",1,,,0,,,,,,,5,0,"The dependent method called within the return statement has changed from getNumRows_native() to nativeGetNumRows(mWindowPtr). This change indicates that the dependent API has changed, leading to code change type 5.","Since only the method name and its parameter have been updated without altering the method semantics or its return type, it is not expected to cause a Compatibility Issue. There is no indication of changes in the behavior or contract of the API from the signature and implementation provided. As such, the type is 0, denoting no Compatibility Issue."
429,<android.view.Surface: Canvas lockCanvas(Rect)>,13,14,,,,"{
    /* the dirty rectangle may be expanded to the surface's size, if
         * for instance it has been resized or if the bits were lost, since
         * the last call.
         */
    return lockCanvasNative(dirty);
}","{
    /*
         * the dirty rectangle may be expanded to the surface's size, if for
         * instance it has been resized or if the bits were lost, since the last
         * call.
         */
    return lockCanvasNative(dirty);
}",1,"/**
 * draw into a surface
 */
","/**
 * draw into a surface
 */
",0,,,0,,,,,,,0,0,"There is no code change between the early and late implementation, the comments in the code have only been reformatted.",There is no compatibility issue between the versions as there have been no changes in the implementation.
433,<android.webkit.WebView: View getZoomControls()>,13,14,,,,"{
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return null;
    }
    return mZoomManager.getExternalZoomPicker();
}","{
    checkThread();
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return null;
    }
    return mZoomManager.getExternalZoomPicker();
}",1,"/**
 * Returns a view containing zoom controls i.e. +/- buttons. The caller is
 * in charge of installing this view to the view hierarchy. This view will
 * become visible when the user starts scrolling via touch and fade away if
 * the user does not interact with it.
 * <p/>
 * API version 3 introduces a built-in zoom mechanism that is shown
 * automatically by the MapView. This is the preferred approach for
 * showing the zoom UI.
 *
 * @deprecated The built-in zoom mechanism is preferred, see
 * {@link WebSettings#setBuiltInZoomControls(boolean)}.
 */
","/**
 * Returns a view containing zoom controls i.e. +/- buttons. The caller is
 * in charge of installing this view to the view hierarchy. This view will
 * become visible when the user starts scrolling via touch and fade away if
 * the user does not interact with it.
 * <p/>
 * API version 3 introduces a built-in zoom mechanism that is shown
 * automatically by the MapView. This is the preferred approach for
 * showing the zoom UI.
 *
 * @deprecated The built-in zoom mechanism is preferred, see
 * {@link WebSettings#setBuiltInZoomControls(boolean)}.
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,4,0,"The only change is the addition of the checkThread() invocation at the beginning of the method, which is not related to return statements, exception handling, or control dependencies; thus the code change type is 4.","The added checkThread() method call does not alter the return values or the exception handling of the method. It is a common practice to ensure that the method is being called on the correct thread, and if this thread check fails, it would throw an exception before reaching any of the return statements, hence it does not constitute a change that would create a compatibility issue. The behavior of the method in terms of returning values and exception handling remains unchanged between the two versions."
434,"<android.text.BoringLayout: Metrics isBoring(CharSequence,TextPaint,Metrics)>",13,14,,,,"{
    char[] temp = TextUtils.obtain(500);
    int len = text.length();
    boolean boring = true;
    outer: for (int i = 0; i < len; i += 500) {
        int j = i + 500;
        if (j > len)
            j = len;
        TextUtils.getChars(text, i, j, temp, 0);
        int n = j - i;
        for (int a = 0; a < n; a++) {
            char c = temp[a];
            if (c == '\n' || c == '\t' || c >= FIRST_RIGHT_TO_LEFT) {
                boring = false;
                break outer;
            }
        }
    }
    TextUtils.recycle(temp);
    if (boring && text instanceof Spanned) {
        Spanned sp = (Spanned) text;
        Object[] styles = sp.getSpans(0, text.length(), ParagraphStyle.class);
        if (styles.length > 0) {
            boring = false;
        }
    }
    if (boring) {
        Metrics fm = metrics;
        if (fm == null) {
            fm = new Metrics();
        }
        TextLine line = TextLine.obtain();
        line.set(paint, text, 0, text.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        fm.width = (int) FloatMath.ceil(line.metrics(fm));
        TextLine.recycle(line);
        return fm;
    } else {
        return null;
    }
}","{
    return isBoring(text, paint, TextDirectionHeuristics.FIRSTSTRONG_LTR, metrics);
}",1,"/**
 * Returns null if not boring; the width, ascent, and descent in the
 * provided Metrics object (or a new one if the provided one was null)
 * if boring.
 */
","/**
 * Returns null if not boring; the width, ascent, and descent in the
 * provided Metrics object (or a new one if the provided one was null)
 * if boring.
 */
",0,,,0,,,,,,,"1,4",1,"The early implementation of the method has been replaced by a single return statement that calls another method in the late implementation, which implies an entire refactoring of the method body. Hence, there's a return statement change, and other statements are changed as well, leading to the classification as 1,4.","Given that the method body is entirely different, calling a separate function that may have different internal logic, this could lead to different return values, establishing a Compatibility Issue of type 1."
435,<android.widget.NumberPicker: void onDraw(Canvas)>,13,14,,,,"{
    // we only draw the selector wheel
    if (!mDrawSelectorWheel) {
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    // draw the selector wheel
    int[] selectorIndices = getSelectorIndices();
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        canvas.drawText(scrollSelectorValue, x, y, mSelectorPaint);
        y += mSelectorElementHeight;
    }
    // draw the selection dividers (only if scrolling and drawable specified)
    if (mSelectionDivider != null) {
        mSelectionDivider.setAlpha(mSelectorPaint.getAlpha());
        // draw the top divider
        int topOfTopDivider = (getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int topOfBottomDivider = topOfTopDivider + mSelectorElementHeight;
        int bottomOfBottomDivider = bottomOfTopDivider + mSelectorElementHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
}","{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    float x = (mRight - mLeft) / 2;
    float y = mCurrentScrollOffset;
    final int restoreCount = canvas.save();
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_SMALL) {
        Rect clipBounds = canvas.getClipBounds();
        clipBounds.inset(0, mSelectorElementHeight);
        canvas.clipRect(clipBounds);
    }
    // draw the selector wheel
    int[] selectorIndices = mSelectorIndices;
    for (int i = 0; i < selectorIndices.length; i++) {
        int selectorIndex = selectorIndices[i];
        String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
        // value intermixed with the new one.
        if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
            canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
        }
        y += mSelectorElementHeight;
    }
    // draw the selection dividers (only if scrolling and drawable specified)
    if (mSelectionDivider != null) {
        // draw the top divider
        int topOfTopDivider = (getHeight() - mSelectorElementHeight - mSelectionDividerHeight) / 2;
        int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
        mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
        mSelectionDivider.draw(canvas);
        // draw the bottom divider
        int topOfBottomDivider = topOfTopDivider + mSelectorElementHeight;
        int bottomOfBottomDivider = bottomOfTopDivider + mSelectorElementHeight;
        mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
        mSelectionDivider.draw(canvas);
    }
    canvas.restoreToCount(restoreCount);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",0,"The early version draws the selector wheel only if `mDrawSelectorWheel` is true, while the late version draws it based on the `mSelectorWheelState`. There is an introduction of canvas state saving and restoring using `save()` and `restoreToCount(restoreCount)`, as well as canvas clipping with `clipRect(clipBounds)`. Additionally, the late version uses `mSelectorWheelPaint` instead of `mSelectorPaint`, and there's a condition to not draw the middle item if `mInputText` is visible. These changes span return statements, control dependencies, and other statements so the change types are 1,3,4.","Despite the various changes in the implementation, all code paths eventually draw the selector wheel and selection dividers as intended, and none of the changes involve altering the return type or introducing new exceptions. The method's signature remains void, meaning no return value is affected, and any internal changes to how the drawing is performed do not impact the method's external behavior contract. Therefore, there's no compatibility issue as the purpose and result of calling the method remain the same: to draw elements on the canvas."
436,"<android.text.TextUtils: int indexOf(CharSequence,char,int,int)>",13,14,,,,"{
    Class c = s.getClass();
    if (s instanceof GetChars || c == StringBuffer.class || c == StringBuilder.class || c == String.class) {
        final int INDEX_INCREMENT = 500;
        char[] temp = obtain(INDEX_INCREMENT);
        while (start < end) {
            int segend = start + INDEX_INCREMENT;
            if (segend > end)
                segend = end;
            getChars(s, start, segend, temp, 0);
            int count = segend - start;
            for (int i = 0; i < count; i++) {
                if (temp[i] == ch) {
                    recycle(temp);
                    return i + start;
                }
            }
            start = segend;
        }
        recycle(temp);
        return -1;
    }
    for (int i = start; i < end; i++) if (s.charAt(i) == ch)
        return i;
    return -1;
}","{
    Class<? extends CharSequence> c = s.getClass();
    if (s instanceof GetChars || c == StringBuffer.class || c == StringBuilder.class || c == String.class) {
        final int INDEX_INCREMENT = 500;
        char[] temp = obtain(INDEX_INCREMENT);
        while (start < end) {
            int segend = start + INDEX_INCREMENT;
            if (segend > end)
                segend = end;
            getChars(s, start, segend, temp, 0);
            int count = segend - start;
            for (int i = 0; i < count; i++) {
                if (temp[i] == ch) {
                    recycle(temp);
                    return i + start;
                }
            }
            start = segend;
        }
        recycle(temp);
        return -1;
    }
    for (int i = start; i < end; i++) if (s.charAt(i) == ch)
        return i;
    return -1;
}",1,,,0,,,0,,,,,,,4,0,"The class type retrieved from getClass() method has been changed to a generic type Class<? extends CharSequence>, but the logic inside the method remains the same. This is a change in type parameter declaration without affecting the behavior, hence categorized as another statement changed.","This change does not affect return values or exception handling, therefore, there is no Compatibility Issue."
437,<android.bluetooth.BluetoothDeviceProfileState.IncomingA2dp: boolean processMessage(Message)>,13,14,,,,"{
    log(""IncomingA2dp State->Processing Message: "" + message.what);
    Message deferMsg = new Message();
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HFP_INCOMING:
            // Shouldn't happen, but serialize the commands.
            deferMessage(message);
            break;
        case CONNECT_A2DP_INCOMING:
            // ignore
            break;
        case CONNECT_A2DP_OUTGOING:
            // Defer message and retry
            deferMessage(message);
            break;
        case DISCONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_HFP_INCOMING:
            // ignore
            break;
        case DISCONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_A2DP_INCOMING:
            // Ignore, will be handled by Bluez
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            // ignore
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
        case CONNECT_OTHER_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    log(""IncomingA2dp State->Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HFP_INCOMING:
            // Shouldn't happen, but serialize the commands.
            deferMessage(message);
            break;
        case CONNECT_A2DP_INCOMING:
            // ignore
            break;
        case CONNECTION_ACCESS_REQUEST_REPLY:
            int val = message.arg1;
            mConnectionAccessReplyReceived = true;
            boolean value = false;
            if (val == BluetoothDevice.CONNECTION_ACCESS_YES) {
                value = true;
            }
            setTrust(val);
            handleIncomingConnection(CONNECT_A2DP_INCOMING, value);
            break;
        case CONNECTION_ACCESS_REQUEST_EXPIRY:
            // and the timer expiry.
            if (!mConnectionAccessReplyReceived) {
                handleIncomingConnection(CONNECT_A2DP_INCOMING, false);
                sendConnectionAccessRemovalIntent();
                sendMessage(TRANSITION_TO_STABLE);
            }
            break;
        case CONNECT_A2DP_OUTGOING:
            // Defer message and retry
            deferMessage(message);
            break;
        case DISCONNECT_HFP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_HFP_INCOMING:
            // ignore
            break;
        case DISCONNECT_A2DP_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_A2DP_INCOMING:
            // Ignore, will be handled by Bluez
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            // ignore
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
        case CONNECT_OTHER_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There are new cases added in the switch statement (CONNECTION_ACCESS_REQUEST_REPLY and CONNECTION_ACCESS_REQUEST_EXPIRY) and behavior for the existing case CONNECT_A2DP_INCOMING remains the same. However, there are no changes in the exception handling, return statements, or dependent APIs, just the addition of two new control branches, which leads to the classification 3 for control dependency change and 4 for other statements that have been changed inside the new cases.","Despite new cases being added to the switch statement, they do not alter the existing behavior of how exceptions are handled or what the method returns. These additions are inside the control structure and are specific to the new messages. Existing cases that would have fallen into the 'default' previously will still do so, and the final return statement has not been modified. Therefore, there is no Compatibility Issue according to the rules provided."
438,<android.widget.AbsListView: boolean onRemoteAdapterConnected()>,13,14,,,,"{
    if (mRemoteAdapter != mAdapter) {
        setAdapter(mRemoteAdapter);
        return false;
    } else if (mRemoteAdapter != null) {
        mRemoteAdapter.superNotifyDataSetChanged();
        return true;
    }
    return false;
}","{
    if (mRemoteAdapter != mAdapter) {
        setAdapter(mRemoteAdapter);
        if (mDeferNotifyDataSetChanged) {
            mRemoteAdapter.notifyDataSetChanged();
            mDeferNotifyDataSetChanged = false;
        }
        return false;
    } else if (mRemoteAdapter != null) {
        mRemoteAdapter.superNotifyDataSetChanged();
        return true;
    }
    return false;
}",1,"/**
 * Called back when the adapter connects to the RemoteViewsService.
 */
","/**
 * Called back when the adapter connects to the RemoteViewsService.
 */
",0,,,0,,,,,,,3,0,"A conditional check for mDeferNotifyDataSetChanged and the call to mRemoteAdapter.notifyDataSetChanged() along with the assignment of mDeferNotifyDataSetChanged to false have been introduced within the first 'if' block, so the change is categorized as 3 (Control dependency changed).","Although there is a change within the method, it does not lead to a Compatibility Issue since the two added statements only affect the state of mDeferNotifyDataSetChanged and call notifyDataSetChanged on mRemoteAdapter. This does not affect the return values of the method nor does it introduce new exceptions. The returned values still remain false in the same condition, and true when mRemoteAdapter is not null. Therefore, there are no changes in the return values or exceptions thrown by the API, hence no compatibility issue arises."
439,"<android.database.CursorWindow: boolean putLong(long,int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return putLong_native(value, row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativePutLong(mWindowPtr, value, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Copy integer to cursor window
 * @param value
 * @param row
 * @param col
 * @return false if fail to copy
 */
","/**
 * Puts a long integer into the field at the specified row and column index.
 *
 * @param value The value to store.
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if successful.
 */
",1,,,0,,,,,,,"1,5",1,"The dependent method within the return statement changed from 'putLong_native' to 'nativePutLong', also it has been renamed, and the parameter names have changed from `col` to `column`, so the code change is of types 1,5.","Because the dependent method has been changed, which directly affects the return statement, this could potentially lead to a different return value. Hence, the CI type is 1."
440,"<android.server.BluetoothService: int addRfcommServiceRecord(String,ParcelUuid,int,IBinder)>",13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        Log.d(TAG, ""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    int pid = Binder.getCallingPid();
    mServiceRecordToPid.put(new Integer(handle), new Integer(pid));
    try {
        b.linkToDeath(new Reaper(handle, pid), 0);
    } catch (RemoteException e) {
    }
    return handle;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    if (!isEnabledInternal())
        return -1;
    if (serviceName == null || uuid == null || channel < 1 || channel > BluetoothSocket.MAX_RFCOMM_CHANNEL) {
        return -1;
    }
    if (BluetoothUuid.isUuidPresent(BluetoothUuid.RESERVED_UUIDS, uuid)) {
        Log.w(TAG, ""Attempted to register a reserved UUID: "" + uuid);
        return -1;
    }
    int handle = addRfcommServiceRecordNative(serviceName, uuid.getUuid().getMostSignificantBits(), uuid.getUuid().getLeastSignificantBits(), (short) channel);
    if (DBG)
        Log.d(TAG, ""new handle "" + Integer.toHexString(handle));
    if (handle == -1) {
        return -1;
    }
    int pid = Binder.getCallingPid();
    mServiceRecordToPid.put(new Integer(handle), new Pair<Integer, IBinder>(pid, b));
    try {
        b.linkToDeath(new Reaper(handle, pid, RFCOMM_RECORD_REAPER), 0);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
    }
    return handle;
}",1,"/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
","/**
 * b is a handle to a Binder instance, so that this service can be notified
 * for Applications that terminate unexpectedly, to clean there service
 * records
 */
",0,,,0,,,,,,,"4,5",0,"The changes are the addition of a new argument (RFCOMM_RECORD_REAPER) to the Reaper constructor and logging an exception using Log.e(), and the change of the stored value in the mServiceRecordToPid map, from new Integer(pid) to new Pair<Integer, IBinder>(pid, b). The code change type is 4, as there is a change in the statements that are neither return statements, exception handling statements, nor control dependency statements, and 5 since the dependent API changed.","There is no Compatibility Issue in terms of the return value or the exceptions thrown by this API, since the returned handle remains the same and there's no change in the exception handling that would cause a different exception to be thrown. The addition of logging and storing additional data in a map doesn't affect the functional behavior in terms of outputs or exceptions."
441,<android.nfc.tech.Ndef: boolean canMakeReadOnly()>,13,14,,,,"{
    if (mNdefType == TYPE_1 || mNdefType == TYPE_2) {
        return true;
    } else {
        return false;
    }
}","{
    INfcTag tagService = mTag.getTagService();
    try {
        return tagService.canMakeReadOnly(mNdefType);
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
        return false;
    }
}",1,"/**
 * Indicates whether a tag can be made read-only with {@link #makeReadOnly()}.
 *
 * <p>Does not cause any RF activity and does not block.
 *
 * @return true if it is possible to make this tag read-only
 */
","/**
 * Indicates whether a tag can be made read-only with {@link #makeReadOnly()}.
 *
 * <p>Does not cause any RF activity and does not block.
 *
 * @return true if it is possible to make this tag read-only
 */
",0,,,0,,,,,,,"1,2,5","1,2","The implementation of the API has changed significantly. Instead of using a static check against NDEF types, the late version queries the tag service. There is a new dependent API method call (tagService.canMakeReadOnly(mNdefType)) and a new exception handling statement (catch RemoteException). Thus the code change type is 1,2,5.","The late version of the API can behave significantly differently because it now relies on a service that could change or be unavailable, leading to a RemoteException. This inclusion of service-based logic and new exception handling means there is a potential Compatibility Issue (CI) due to the API returning different values and throwing a different exception, so the CI type is 1,2."
443,"<android.accounts.AbstractAccountAuthenticator.Transport: void hasFeatures(IAccountAuthenticatorResponse,Account,String[])>",13,14,,,,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.hasFeatures(new AccountAuthenticatorResponse(response), account, features);
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""hasFeatures not supported"");
    } catch (NetworkErrorException e) {
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    }
}","{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.hasFeatures(new AccountAuthenticatorResponse(response), account, features);
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""hasFeatures"", account.toString(), e);
    }
}",1,,,0,,,0,,,,,,,"2,4",2,"The two specific catch clauses (`UnsupportedOperationException` and `NetworkErrorException`) have been replaced by a single general catch clause (`Exception`) which handles all exceptions through a new method `handleException`. This constitutes a change in the exception handling statement, which is indicated by the code change type 2. Additionally, there's the introduction of a new method call (`handleException`), which can be considered as 'Other statement changed', and thus type 4 is also applicable.","The replacement of the specific exception handling with a more general one means the API could throw different exceptions (or handle them differently) when the late version API is invoked, which could cause Compatibility Issues if the client code relies on catching specific exceptions from the early version. Therefore, the CI type is 2."
444,"<android.database.CursorWindow: boolean putString(String,int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return putString_native(value, row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativePutString(mWindowPtr, value, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Copy String to cursor window
 * @param value
 * @param row
 * @param col
 * @return false if fail to copy
 */
","/**
 * Copies a string into the field at the specified row and column index.
 *
 * @param value The value to store.
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if successful.
 */
",1,,,0,,,,,,,"4,5",0,"The implementation has changed the method called from putString_native to nativePutString, with a modification in argument names from 'col' to 'column'. Additionally, there's an introduction of 'mWindowPtr' as a new argument which indicates a change in the dependent API, hence the code change types are 4 and 5.","No Compatibility Issue should arise from this change because the change doesn't affect the method's return type, value, or exception handling; its signature remains the same, and the body change does not lead to different behavior in terms of the API contract. The internal implementation details and the usage of parameters have changed, but these should be transparent to the caller as long as the contract of the method remains intact and the new implementation adheres to the same expected behavior. Hence, the pred_CI is 0."
445,"<android.content.SyncAdaptersCache: SyncAdapterType parseServiceAttributes(Resources,String,AttributeSet)>",13,14,,,,"{
    TypedArray sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.SyncAdapter);
    try {
        final String authority = sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
        final String accountType = sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
        if (authority == null || accountType == null) {
            return null;
        }
        final boolean userVisible = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible, true);
        final boolean supportsUploading = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading, true);
        final boolean isAlwaysSyncable = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_isAlwaysSyncable, false);
        final boolean allowParallelSyncs = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_allowParallelSyncs, false);
        return new SyncAdapterType(authority, accountType, userVisible, supportsUploading, isAlwaysSyncable, allowParallelSyncs);
    } finally {
        sa.recycle();
    }
}","{
    TypedArray sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.SyncAdapter);
    try {
        final String authority = sa.getString(com.android.internal.R.styleable.SyncAdapter_contentAuthority);
        final String accountType = sa.getString(com.android.internal.R.styleable.SyncAdapter_accountType);
        if (authority == null || accountType == null) {
            return null;
        }
        final boolean userVisible = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_userVisible, true);
        final boolean supportsUploading = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_supportsUploading, true);
        final boolean isAlwaysSyncable = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_isAlwaysSyncable, false);
        final boolean allowParallelSyncs = sa.getBoolean(com.android.internal.R.styleable.SyncAdapter_allowParallelSyncs, false);
        final String settingsActivity = sa.getString(com.android.internal.R.styleable.SyncAdapter_settingsActivity);
        return new SyncAdapterType(authority, accountType, userVisible, supportsUploading, isAlwaysSyncable, allowParallelSyncs, settingsActivity);
    } finally {
        sa.recycle();
    }
}",1,,,0,,,0,,,,,,,"1,5",1,"The constructor of SyncAdapterType in the return statement has an additional parameter in the late version which is settingsActivity. Therefore, the dependent API has changed and a new value is returned from the method in the late version, so the code change type is 1,5.","Since the return type's constructor call in the late version includes an extra parameter (settingsActivity), the API could potentially return different values (due to the additional information in the SyncAdapterType object). Thus, there is a Compatibility Issue of type 1."
447,<android.database.sqlite.SQLiteCursor: boolean requery()>,13,14,,,,"{
    if (isClosed()) {
        return false;
    }
    long timeStart = 0;
    if (Config.LOGV) {
        timeStart = System.currentTimeMillis();
    }
    synchronized (this) {
        if (mWindow != null) {
            mWindow.clear();
        }
        mPos = -1;
        SQLiteDatabase db = null;
        try {
            db = mQuery.mDatabase.getDatabaseHandle(mQuery.mSql);
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        }
        if (!db.equals(mQuery.mDatabase)) {
            // re-compile the query
            try {
                db.lock();
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            }
            try {
                // close the old mQuery object and open a new one
                mQuery.close();
                mQuery = new SQLiteQuery(db, mQuery);
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            } finally {
                db.unlock();
            }
        }
        // This one will recreate the temp table, and get its count
        mDriver.cursorRequeried(this);
        mCount = NO_COUNT;
        mCursorState++;
        queryThreadLock();
        try {
            mQuery.requery();
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        } finally {
            queryThreadUnlock();
        }
    }
    if (Config.LOGV) {
        Log.v(""DatabaseWindow"", ""closing window in requery()"");
        Log.v(TAG, ""--- Requery()ed cursor "" + this + "": "" + mQuery);
    }
    boolean result = false;
    try {
        result = super.requery();
    } catch (IllegalStateException e) {
        // for backwards compatibility, just return false
        Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
    }
    if (Config.LOGV) {
        long timeEnd = System.currentTimeMillis();
        Log.v(TAG, ""requery ("" + (timeEnd - timeStart) + "" ms): "" + mDriver.toString());
    }
    return result;
}","{
    if (isClosed()) {
        return false;
    }
    long timeStart = 0;
    if (false) {
        timeStart = System.currentTimeMillis();
    }
    synchronized (this) {
        if (mWindow != null) {
            mWindow.clear();
        }
        mPos = -1;
        SQLiteDatabase db = null;
        try {
            db = mQuery.mDatabase.getDatabaseHandle(mQuery.mSql);
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        }
        if (!db.equals(mQuery.mDatabase)) {
            // re-compile the query
            try {
                db.lock(mQuery.mSql);
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            }
            try {
                // close the old mQuery object and open a new one
                mQuery.close();
                mQuery = new SQLiteQuery(db, mQuery);
            } catch (IllegalStateException e) {
                // for backwards compatibility, just return false
                Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
                return false;
            } finally {
                db.unlock();
            }
        }
        // This one will recreate the temp table, and get its count
        mDriver.cursorRequeried(this);
        mCount = NO_COUNT;
        try {
            mQuery.requery();
        } catch (IllegalStateException e) {
            // for backwards compatibility, just return false
            Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
            return false;
        }
    }
    if (false) {
        Log.v(""DatabaseWindow"", ""closing window in requery()"");
        Log.v(TAG, ""--- Requery()ed cursor "" + this + "": "" + mQuery);
    }
    boolean result = false;
    try {
        result = super.requery();
    } catch (IllegalStateException e) {
        // for backwards compatibility, just return false
        Log.w(TAG, ""requery() failed "" + e.getMessage(), e);
    }
    if (false) {
        long timeEnd = System.currentTimeMillis();
        Log.v(TAG, ""requery ("" + (timeEnd - timeStart) + "" ms): "" + mDriver.toString());
    }
    return result;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
449,<android.widget.HorizontalScrollView: boolean onInterceptTouchEvent(MotionEvent)>,13,14,,,,"{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}","{
    /*
         * This method JUST determines whether we want to intercept the motion.
         * If we return true, onMotionEvent will be called and we do the actual
         * scrolling there.
         */
    /*
        * Shortcut the most recurring case: the user is in the dragging
        * state and he is moving his finger.  We want to intercept this
        * motion.
        */
    final int action = ev.getAction();
    if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
        return true;
    }
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_MOVE:
            {
                /*
                 * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
                 * whether the user has moved far enough from his original down touch.
                 */
                /*
                * Locally do absolute value. mLastMotionX is set to the x value
                * of the down event.
                */
                final int activePointerId = mActivePointerId;
                if (activePointerId == INVALID_POINTER) {
                    // If we don't have a valid id, the touch down wasn't on content.
                    break;
                }
                final int pointerIndex = ev.findPointerIndex(activePointerId);
                final float x = ev.getX(pointerIndex);
                final int xDiff = (int) Math.abs(x - mLastMotionX);
                if (xDiff > mTouchSlop) {
                    mIsBeingDragged = true;
                    mLastMotionX = x;
                    initVelocityTrackerIfNotExists();
                    mVelocityTracker.addMovement(ev);
                    if (mParent != null)
                        mParent.requestDisallowInterceptTouchEvent(true);
                }
                break;
            }
        case MotionEvent.ACTION_DOWN:
            {
                final float x = ev.getX();
                if (!inChild((int) x, (int) ev.getY())) {
                    mIsBeingDragged = false;
                    recycleVelocityTracker();
                    break;
                }
                /*
                 * Remember location of down touch.
                 * ACTION_DOWN always refers to pointer index 0.
                 */
                mLastMotionX = x;
                mActivePointerId = ev.getPointerId(0);
                initOrResetVelocityTracker();
                mVelocityTracker.addMovement(ev);
                /*
                * If being flinged and user touches the screen, initiate drag;
                * otherwise don't.  mScroller.isFinished should be false when
                * being flinged.
                */
                mIsBeingDragged = !mScroller.isFinished();
                break;
            }
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            /* Release the drag */
            mIsBeingDragged = false;
            mActivePointerId = INVALID_POINTER;
            if (mScroller.springBack(mScrollX, mScrollY, 0, getScrollRange(), 0, 0)) {
                invalidate();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                mLastMotionX = ev.getX(index);
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionX = ev.getX(ev.findPointerIndex(mActivePointerId));
            break;
    }
    /*
        * The only time we want to intercept motion events is if we are in the
        * drag mode.
        */
    return mIsBeingDragged;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
451,<android.server.search.Searchables: void buildSearchableList()>,13,14,,,,"{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    final PackageManager pm = mContext.getPackageManager();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    searchList = pm.queryIntentActivities(intent, PackageManager.GET_META_DATA);
    List<ResolveInfo> webSearchInfoList;
    final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
    webSearchInfoList = pm.queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
    // analyze each one, generate a Searchables record, and record
    if (searchList != null || webSearchInfoList != null) {
        int search_count = (searchList == null ? 0 : searchList.size());
        int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
        int count = search_count + web_search_count;
        for (int ii = 0; ii < count; ii++) {
            // for each component, try to find metadata
            ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
            ActivityInfo ai = info.activityInfo;
            // Check first to avoid duplicate entries.
            if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai);
                if (searchable != null) {
                    newSearchablesList.add(searchable);
                    newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                    if (searchable.shouldIncludeInGlobalSearch()) {
                        newSearchablesInGlobalSearchList.add(searchable);
                    }
                }
            }
        }
    }
    // Find the global search activity
    ComponentName newGlobalSearchActivity = findGlobalSearchActivity();
    // Find the web search activity
    ComponentName newWebSearchActivity = findWebSearchActivity(newGlobalSearchActivity);
    // Store a consistent set of new values
    synchronized (this) {
        mSearchablesMap = newSearchablesMap;
        mSearchablesList = newSearchablesList;
        mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
        mGlobalSearchActivity = newGlobalSearchActivity;
        mWebSearchActivity = newWebSearchActivity;
    }
}","{
    // These will become the new values at the end of the method
    HashMap<ComponentName, SearchableInfo> newSearchablesMap = new HashMap<ComponentName, SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesList = new ArrayList<SearchableInfo>();
    ArrayList<SearchableInfo> newSearchablesInGlobalSearchList = new ArrayList<SearchableInfo>();
    final PackageManager pm = mContext.getPackageManager();
    // Use intent resolver to generate list of ACTION_SEARCH & ACTION_WEB_SEARCH receivers.
    List<ResolveInfo> searchList;
    final Intent intent = new Intent(Intent.ACTION_SEARCH);
    searchList = pm.queryIntentActivities(intent, PackageManager.GET_META_DATA);
    List<ResolveInfo> webSearchInfoList;
    final Intent webSearchIntent = new Intent(Intent.ACTION_WEB_SEARCH);
    webSearchInfoList = pm.queryIntentActivities(webSearchIntent, PackageManager.GET_META_DATA);
    // analyze each one, generate a Searchables record, and record
    if (searchList != null || webSearchInfoList != null) {
        int search_count = (searchList == null ? 0 : searchList.size());
        int web_search_count = (webSearchInfoList == null ? 0 : webSearchInfoList.size());
        int count = search_count + web_search_count;
        for (int ii = 0; ii < count; ii++) {
            // for each component, try to find metadata
            ResolveInfo info = (ii < search_count) ? searchList.get(ii) : webSearchInfoList.get(ii - search_count);
            ActivityInfo ai = info.activityInfo;
            // Check first to avoid duplicate entries.
            if (newSearchablesMap.get(new ComponentName(ai.packageName, ai.name)) == null) {
                SearchableInfo searchable = SearchableInfo.getActivityMetaData(mContext, ai);
                if (searchable != null) {
                    newSearchablesList.add(searchable);
                    newSearchablesMap.put(searchable.getSearchActivity(), searchable);
                    if (searchable.shouldIncludeInGlobalSearch()) {
                        newSearchablesInGlobalSearchList.add(searchable);
                    }
                }
            }
        }
    }
    List<ResolveInfo> newGlobalSearchActivities = findGlobalSearchActivities();
    // Find the global search activity
    ComponentName newGlobalSearchActivity = findGlobalSearchActivity(newGlobalSearchActivities);
    // Find the web search activity
    ComponentName newWebSearchActivity = findWebSearchActivity(newGlobalSearchActivity);
    // Store a consistent set of new values
    synchronized (this) {
        mSearchablesMap = newSearchablesMap;
        mSearchablesList = newSearchablesList;
        mSearchablesInGlobalSearchList = newSearchablesInGlobalSearchList;
        mGlobalSearchActivities = newGlobalSearchActivities;
        mCurrentGlobalSearchActivity = newGlobalSearchActivity;
        mWebSearchActivity = newWebSearchActivity;
    }
}",1,"/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
","/**
 * Builds an entire list (suitable for display) of
 * activities that are searchable, by iterating the entire set of
 * ACTION_SEARCH & ACTION_WEB_SEARCH intents.
 *
 * Also clears the hash of all activities -> searches which will
 * refill as the user clicks ""search"".
 *
 * This should only be done at startup and again if we know that the
 * list has changed.
 *
 * TODO: every activity that provides a ACTION_SEARCH intent should
 * also provide searchability meta-data.  There are a bunch of checks here
 * that, if data is not found, silently skip to the next activity.  This
 * won't help a developer trying to figure out why their activity isn't
 * showing up in the list, but an exception here is too rough.  I would
 * like to find a better notification mechanism.
 *
 * TODO: sort the list somehow?  UI choice.
 */
",0,,,0,,,,,,,,,,
452,<android.bluetooth.BluetoothSocket: void close()>,13,14,,,,"{
    // abort blocking operations on the socket
    mLock.readLock().lock();
    try {
        if (mClosed)
            return;
        if (mSdp != null) {
            mSdp.cancel();
        }
        abortNative();
    } finally {
        mLock.readLock().unlock();
    }
    // all native calls are guaranteed to immediately return after
    // abortNative(), so this lock should immediately acquire
    mLock.writeLock().lock();
    try {
        mClosed = true;
        destroyNative();
    } finally {
        mLock.writeLock().unlock();
    }
}","{
    // abort blocking operations on the socket
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            return;
        if (mSdp != null) {
            mSdp.cancel();
        }
        abortNative();
    } finally {
        mLock.readLock().unlock();
    }
    // all native calls are guaranteed to immediately return after
    // abortNative(), so this lock should immediately acquire
    mLock.writeLock().lock();
    try {
        mSocketState = SocketState.CLOSED;
        destroyNative();
    } finally {
        mLock.writeLock().unlock();
    }
}",1,"/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 */
","/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 */
",0,,,0,,,,,,,4,0,"The early version uses a boolean field `mClosed` to check if the socket is closed, while the later version uses an enum `SocketState` to check the state of the socket. So a different field with a different type (`boolean` vs. `enum`) is being accessed and set, but the overall logic of the method is still the same, which means the change type is 4.","Even though the implementation has changed to use an enum instead of a boolean, the logic remains the same: checking if the socket is closed and setting it to closed if it's not. Therefore, there is no change in behavior of the method relative to how it is used (i.e., it will behave the same to callers), so there is no Compatibility Issue."
453,<android.database.BulkCursorProxy: int count()>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    boolean result = mRemote.transact(COUNT_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    int count;
    if (result == false) {
        count = -1;
    } else {
        count = reply.readInt();
    }
    data.recycle();
    reply.recycle();
    return count;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        boolean result = mRemote.transact(COUNT_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        int count;
        if (result == false) {
            count = -1;
        } else {
            count = reply.readInt();
        }
        return count;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code changed in the late version includes the addition of a try-finally block around the existing code to ensure that `data.recycle()` and `reply.recycle()` are called even if an exception occurs. This is a change in the exception handling pattern, but it's not a change to the exception handling statements (no new exceptions are thrown and no catch blocks have been added). It's also a control dependency change because now the recycle calls are guaranteed to occur. However, it's not directly an exception handling statement change in terms of the API's external behavior. So the code change types are control dependency change (3) and other statement change (4), due to the restructuring of the code inside a try-finally block.","There is no Compatibility Issue because all the return statements and functional behaviors are identical to the early version of the API. The use of the try-finally block does not affect the API's return values or potential exceptions seen by the caller, it only ensures proper cleanup of resources. Thus, there is no CI (0)."
454,<android.database.sqlite.SQLiteStatement: int executeUpdateDelete()>,13,14,,,,"{
    try {
        long timeStart = acquireAndLock(WRITE);
        int numChanges = 0;
        if ((mStatementType & STATEMENT_DONT_PREPARE) > 0) {
            // since the statement doesn't have to be prepared,
            // call the following native method which will not prepare
            // the query plan
            native_executeSql(mSql);
        } else {
            numChanges = native_execute();
        }
        mDatabase.logTimeStat(mSql, timeStart);
        return numChanges;
    } finally {
        releaseAndUnlock();
    }
}","{
    try {
        saveSqlAsLastSqlStatement();
        acquireAndLock(WRITE);
        int numChanges = 0;
        if ((mStatementType & STATEMENT_DONT_PREPARE) > 0) {
            // since the statement doesn't have to be prepared,
            // call the following native method which will not prepare
            // the query plan
            native_executeSql(mSql);
        } else {
            numChanges = native_execute();
        }
        return numChanges;
    } finally {
        releaseAndUnlock();
    }
}",1,"/**
 * Execute this SQL statement, if the the number of rows affected by execution of this SQL
 * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
 *
 * @return the number of rows affected by this SQL statement execution.
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
","/**
 * Execute this SQL statement, if the the number of rows affected by execution of this SQL
 * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements.
 *
 * @return the number of rows affected by this SQL statement execution.
 * @throws android.database.SQLException If the SQL string is invalid for
 * some reason
 */
",0,,,0,,,,,,,4,0,"A method call `saveSqlAsLastSqlStatement();` has been added before the `acquireAndLock(WRITE);` which is not related to return values or exception handling. Therefore, the code change type is 4.","The added method call does not influence the behavior of the API with respect to return values or exceptions, thus, there's no Compatibility Issue. The API will return the same value and will throw the same exceptions as before, therefore CI type is 0."
457,<android.app.WallpaperManager: void setStream(InputStream)>,13,14,,,,"{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    }
}","{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",0,,,0,,,,,,,0,0,"There is no actual code change between the two versions, the only change is the addition of a comment ""// Ignore"" in the catch block, which does not affect the execution or behavior of the API.","Since there is no change in the behavior of the API between the two versions, no Compatibility Issue can arise."
459,<android.widget.TabWidget: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    event.setItemCount(getTabCount());
    event.setCurrentItemIndex(mSelectedTab);
    if (mSelectedTab != -1) {
        getChildTabViewAt(mSelectedTab).dispatchPopulateAccessibilityEvent(event);
    }
    return true;
}","{
    onPopulateAccessibilityEvent(event);
    // Dispatch only to the selected tab.
    if (mSelectedTab != -1) {
        View tabView = getChildTabViewAt(mSelectedTab);
        if (tabView != null && tabView.getVisibility() == VISIBLE) {
            return tabView.dispatchPopulateAccessibilityEvent(event);
        }
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3","1,2","The early version always returns true, while the late version may return false or the result of tabView.dispatchPopulateAccessibilityEvent(event), depending on conditions. Furthermore, the call to onPopulateAccessibilityEvent(event) has been introduced before the condition. Since the return statement and the behavior under the condition have changed, the change types are 1 and 3.","The late version introduces a change in the potential return value (true to false), which constitutes a CI type 1. Additionally, since the event handling pattern has changed (always populating the event versus conditionally based on the visibility and presence of the tabView), there is also a potential change in how exceptions are thrown. If tabView is null or not VISIBLE, the old implementation would not dispatch the event and thus not throw an exception from dispatchPopulateAccessibilityEvent(event), while the new implementation would return false. Therefore, CI type 2 is also identified as the exception handling has changed due to this new condition check."
463,<android.webkit.WebView: boolean canZoomIn()>,13,14,,,,"{
    return mZoomManager.canZoomIn();
}","{
    checkThread();
    return mZoomManager.canZoomIn();
}",1,"/**
 * @return TRUE if the WebView can be zoomed in.
 */
","/**
 * @return TRUE if the WebView can be zoomed in.
 */
",0,,,0,,,,,,,4,0,"A new method checkThread() is added at the beginning of the late version of the implementation, which is different from the early version. This indicates a change type of 4, meaning ""Other statement changed.""","The added checkThread() method is likely to perform a thread check to ensure that the WebView method canZoomIn() is being called from the correct thread. Since there's no indication that the method affects the return value or the exception throwing behavior of the canZoomIn() functionality, it does not introduce a compatibility issue based on the information given. Hence, the CI type is 0, meaning ""No Compatibility Issue."""
465,"<android.webkit.ZoomManager: void handleDoubleTap(float,float)>",13,14,,,,"{
    // User takes action, set initial zoom overview to false.
    mInitialZoomOverview = false;
    WebSettings settings = mWebView.getSettings();
    if (!isDoubleTapEnabled()) {
        return;
    }
    setZoomCenter(lastTouchX, lastTouchY);
    mAnchorX = mWebView.viewToContentX((int) lastTouchX + mWebView.getScrollX());
    mAnchorY = mWebView.viewToContentY((int) lastTouchY + mWebView.getScrollY());
    settings.setDoubleTapToastCount(0);
    // remove the zoom control after double tap
    dismissZoomPicker();
    /*
         * If the double tap was on a plugin then either zoom to maximize the
         * plugin on the screen or scale to overview mode.
         */
    Rect pluginBounds = mWebView.getPluginBounds(mAnchorX, mAnchorY);
    if (pluginBounds != null) {
        if (mWebView.isRectFitOnScreen(pluginBounds)) {
            zoomToOverview();
        } else {
            mWebView.centerFitRect(pluginBounds);
        }
        return;
    }
    final float newTextWrapScale;
    if (settings.getUseFixedViewport()) {
        newTextWrapScale = Math.max(mActualScale, getReadingLevelScale());
    } else {
        newTextWrapScale = mActualScale;
    }
    if (settings.isNarrowColumnLayout() && exceedsMinScaleIncrement(mTextWrapScale, newTextWrapScale)) {
        mTextWrapScale = newTextWrapScale;
        refreshZoomScale(true);
    } else if (!mInZoomOverview && willScaleTriggerZoom(getZoomOverviewScale())) {
        zoomToOverview();
    } else {
        zoomToReadingLevel();
    }
}","{
    // User takes action, set initial zoom overview to false.
    mInitialZoomOverview = false;
    WebSettings settings = mWebView.getSettings();
    if (!isDoubleTapEnabled()) {
        return;
    }
    setZoomCenter(lastTouchX, lastTouchY);
    mAnchorX = mWebView.viewToContentX((int) lastTouchX + mWebView.getScrollX());
    mAnchorY = mWebView.viewToContentY((int) lastTouchY + mWebView.getScrollY());
    settings.setDoubleTapToastCount(0);
    // remove the zoom control after double tap
    dismissZoomPicker();
    /*
         * If the double tap was on a plugin then either zoom to maximize the
         * plugin on the screen or scale to overview mode.
         */
    Rect pluginBounds = mWebView.getPluginBounds(mAnchorX, mAnchorY);
    if (pluginBounds != null) {
        if (mWebView.isRectFitOnScreen(pluginBounds)) {
            zoomToOverview();
        } else {
            mWebView.centerFitRect(pluginBounds);
        }
        return;
    }
    final float newTextWrapScale;
    if (settings.getUseFixedViewport()) {
        newTextWrapScale = Math.max(mActualScale, getReadingLevelScale());
    } else {
        newTextWrapScale = mActualScale;
    }
    final boolean firstTimeReflow = !exceedsMinScaleIncrement(mActualScale, mTextWrapScale);
    if (firstTimeReflow || mInZoomOverview) {
        // In case first time reflow or in zoom overview mode, let reflow and zoom
        // happen at the same time.
        mTextWrapScale = newTextWrapScale;
    }
    if (settings.isNarrowColumnLayout() && exceedsMinScaleIncrement(mTextWrapScale, newTextWrapScale) && !firstTimeReflow && !mInZoomOverview) {
        // Reflow only.
        mTextWrapScale = newTextWrapScale;
        refreshZoomScale(true);
    } else if (!mInZoomOverview && willScaleTriggerZoom(getZoomOverviewScale())) {
        // Reflow, if necessary.
        if (mTextWrapScale > getReadingLevelScale()) {
            mTextWrapScale = getReadingLevelScale();
            refreshZoomScale(true);
        }
        zoomToOverview();
    } else {
        zoomToReadingLevelOrMore();
    }
}",1,"/**
 * The double tap gesture can result in different behaviors depending on the
 * content that is tapped.
 *
 * (1) PLUGINS: If the taps occur on a plugin then we maximize the plugin on
 * the screen. If the plugin is already maximized then zoom the user into
 * overview mode.
 *
 * (2) HTML/OTHER: If the taps occur outside a plugin then the following
 * heuristic is used.
 * A. If the current text wrap scale differs from newly calculated and the
 * layout algorithm specifies the use of NARROW_COLUMNS, then fit to
 * column by reflowing the text.
 * B. If the page is not in overview mode then change to overview mode.
 * C. If the page is in overmode then change to the default scale.
 */
","/**
 * The double tap gesture can result in different behaviors depending on the
 * content that is tapped.
 *
 * (1) PLUGINS: If the taps occur on a plugin then we maximize the plugin on
 * the screen. If the plugin is already maximized then zoom the user into
 * overview mode.
 *
 * (2) HTML/OTHER: If the taps occur outside a plugin then the following
 * heuristic is used.
 * A. If the current text wrap scale differs from newly calculated and the
 * layout algorithm specifies the use of NARROW_COLUMNS, then fit to
 * column by reflowing the text.
 * B. If the page is not in overview mode then change to overview mode.
 * C. If the page is in overmode then change to the default scale.
 */
",0,,,0,,,,,,,"3,4",0,"The late implementation introduces a new local variable `firstTimeReflow` and changes the conditionals with multiple instances of `if`. Additionally, the last `else` block calls a different method `zoomToReadingLevelOrMore()` instead of the initial `zoomToReadingLevel()`. These represent control dependency changes and other statement changes, thus the code change types are 3,4.","Despite the changes in the local variable declaration and the conditional logic, these modifications do not lead to either a change in the return value or the exception handling of this void method. The added condition check using `firstTimeReflow` and the use of `zoomToReadingLevelOrMore()` instead of `zoomToReadingLevel()` alters internal behavior but does not change the return type (since there is none) nor does it introduce a new exception handling path. Therefore, no Compatibility Issue is expected, and the CI type is 0."
466,<android.webkit.WebView: Rect sendOurVisibleRect()>,13,14,,,,"{
    if (mZoomManager.isPreventingWebkitUpdates())
        return mLastVisibleRectSent;
    Rect rect = new Rect();
    calcOurContentVisibleRect(rect);
    // Rect.equals() checks for null input.
    if (!rect.equals(mLastVisibleRectSent)) {
        Point pos = new Point(rect.left, rect.top);
        mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
        mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET, nativeMoveGeneration(), mSendScrollEvent ? 1 : 0, pos);
        mLastVisibleRectSent = rect;
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
    }
    Rect globalRect = new Rect();
    if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""sendOurVisibleRect=("" + globalRect.left + "","" + globalRect.top + "",r="" + globalRect.right + "",b="" + globalRect.bottom);
        }
        // TODO: the global offset is only used by windowRect()
        // in ChromeClientAndroid ; other clients such as touch
        // and mouse events could return view + screen relative points.
        mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS, globalRect);
        mLastGlobalRect = globalRect;
    }
    return rect;
}","{
    if (mZoomManager.isPreventingWebkitUpdates())
        return mLastVisibleRectSent;
    Rect rect = new Rect();
    calcOurContentVisibleRect(rect);
    // Rect.equals() checks for null input.
    if (!rect.equals(mLastVisibleRectSent)) {
        if (!mBlockWebkitViewMessages) {
            Point pos = new Point(rect.left, rect.top);
            mWebViewCore.removeMessages(EventHub.SET_SCROLL_OFFSET);
            mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET, nativeMoveGeneration(), mSendScrollEvent ? 1 : 0, pos);
        }
        mLastVisibleRectSent = rect;
        mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
    }
    Rect globalRect = new Rect();
    if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
        if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG, ""sendOurVisibleRect=("" + globalRect.left + "","" + globalRect.top + "",r="" + globalRect.right + "",b="" + globalRect.bottom);
        }
        // and mouse events could return view + screen relative points.
        if (!mBlockWebkitViewMessages) {
            mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS, globalRect);
        }
        mLastGlobalRect = globalRect;
    }
    return rect;
}",1,,,0,,,0,,,,,,,3,0,"There is a control dependency change, specifically the addition of a new conditional check `if (!mBlockWebkitViewMessages)` before sending messages to `mWebViewCore`. No other changes can be seen.","Despite the addition of a new conditional check, the return value of the method has not changed. Both versions of the method still return `rect`, where `rect` is not directly influenced by the new condition. Consequently, this should not result in a compatibility issue since the output returned by the method remains unaffected by this particular change. Therefore, there is no Compatibility Issue."
470,<android.widget.TextView: float getLeftFadingEdgeStrength()>,13,14,,,,"{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                return marquee.mScroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            switch(mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}","{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            if (marquee.shouldDrawLeftFade()) {
                return marquee.mScroll / getHorizontalFadingEdgeLength();
            } else {
                return 0.0f;
            }
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    return 0.0f;
                case Gravity.RIGHT:
                    return (mLayout.getLineRight(0) - (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight() - mLayout.getLineLeft(0)) / getHorizontalFadingEdgeLength();
                case Gravity.CENTER_HORIZONTAL:
                    return 0.0f;
            }
        }
    }
    return super.getLeftFadingEdgeStrength();
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",1,"The control dependency has changed due to the additional condition check `(mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS)`, and the computation of `absoluteGravity` is altered (`getResolvedLayoutDirection()` and `Gravity.getAbsoluteGravity(mGravity, layoutDirection)` are added). Also, the signature of the method `getAbsoluteGravity` indicates a Dependent API change. Hence, the change types are 3, 4, and 5.","The additional condition `(mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS)` and the changes in computation of the gravity could alter the behavior of the method `getLeftFadingEdgeStrength()`. Depending on the value of `mMarqueeFadeMode`, the code could now take different execution paths, which might result in different return values from this method. Therefore, the CI type is 1."
472,<android.view.accessibility.AccessibilityManager: void sendAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event);
        Binder.restoreCallingIdentity(identityToken);
        if (LOGV) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}","{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + "" sent"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error during sending "" + event + "" "", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}",1,"/**
 * Sends an {@link AccessibilityEvent}. If this {@link AccessibilityManager} is not
 * enabled the call is a NOOP.
 *
 * @param event The {@link AccessibilityEvent}.
 *
 * @throws IllegalStateException if a client tries to send an {@link AccessibilityEvent}
 * while accessibility is not enabled.
 */
","/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 */
",1,,,0,,,,,,,4,0,"The code change is in the logging flag, from LOGV to DEBUG. This is a non-functional change and does not affect the execution logic or output of the method, thus the code change is of type 4.","Since the change is only related to a debug log statement and not to the return values or exception handling, it does not cause any Compatibility Issues. Hence, the CI type is 0."
473,<android.widget.NumberPicker: void setDisplayedValues(String[])>,13,14,,,,"{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    resetSelectorWheelIndices();
}","{
    if (mDisplayedValues == displayedValues) {
        return;
    }
    mDisplayedValues = displayedValues;
    if (mDisplayedValues != null) {
        // Allow text entry rather than strictly numeric entry.
        mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
    } else {
        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
    }
    updateInputTextView();
    initializeSelectorWheelIndices();
}",1,"/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
","/**
 * Sets the values to be displayed.
 *
 * @param displayedValues The displayed values.
 */
",0,,,0,,,,,,,4,0,"There is a change in the method name that is called from resetSelectorWheelIndices() to initializeSelectorWheelIndices(). Since this is an internal method call within the class and does not affect the return value or exception handling of the setDisplayedValues() method, it is categorized under other statement changed. ","There is no Compatibility Issue, as the change does not affect the method’s return value or the exception it might throw. The internal logic and state change are implicit to the callers."
474,"<android.content.ContentProviderProxy: Cursor query(Uri,String[],String,String[],String)>",13,14,,,,"{
    // TODO make a pool of windows so we can reuse memory dealers
    CursorWindow window = new CursorWindow(false);
    BulkCursorToCursorAdaptor adaptor = new BulkCursorToCursorAdaptor();
    IBulkCursor bulkCursor = bulkQueryInternal(url, projection, selection, selectionArgs, sortOrder, adaptor.getObserver(), window, adaptor);
    if (bulkCursor == null) {
        return null;
    }
    return adaptor;
}","{
    BulkCursorToCursorAdaptor adaptor = new BulkCursorToCursorAdaptor();
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        int length = 0;
        if (projection != null) {
            length = projection.length;
        }
        data.writeInt(length);
        for (int i = 0; i < length; i++) {
            data.writeString(projection[i]);
        }
        data.writeString(selection);
        if (selectionArgs != null) {
            length = selectionArgs.length;
        } else {
            length = 0;
        }
        data.writeInt(length);
        for (int i = 0; i < length; i++) {
            data.writeString(selectionArgs[i]);
        }
        data.writeString(sortOrder);
        data.writeStrongBinder(adaptor.getObserver().asBinder());
        mRemote.transact(IContentProvider.QUERY_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        IBulkCursor bulkCursor = BulkCursorNative.asInterface(reply.readStrongBinder());
        if (bulkCursor != null) {
            int rowCount = reply.readInt();
            int idColumnPosition = reply.readInt();
            boolean wantsAllOnMoveCalls = reply.readInt() != 0;
            adaptor.initialize(bulkCursor, rowCount, idColumnPosition, wantsAllOnMoveCalls);
        } else {
            adaptor.close();
            adaptor = null;
        }
        return adaptor;
    } catch (RemoteException ex) {
        adaptor.close();
        throw ex;
    } catch (RuntimeException ex) {
        adaptor.close();
        throw ex;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"1,2,3,4","1,2","The late version of the implementation has introduced a complete replacement of the body of the method, which includes changes in the instantiation and initialization of objects, the usage of Parcel for marshalling and unmarshalling data for the IPC, try-catch blocks, and the transact method call for remote invocation. Therefore, the change types are 1 (return statement changed), 2 (exception handling statement changed), 3 (control dependency changed), and 4 (other statement changed).","Due to the overhaul of the method's body with new implementation details, these changes could lead to both different return values/types and difference in the exception handling. The bulkQueryInternal() is replaced with manual marshalling/unmarshalling and IPC (Inter-Process Communication) transactions; Also, the return value adaptor could potentially have different states or even be null under different circumstances (in the late version, it is set to null if bulkCursor is null, while in the early version it simply returns null if bulkCursor is null without additional handling). Exception handling is also different: new exceptions are thrown, adaptor is closed in case of exceptions which was not present in the early version. Hence, the CI types are 1 (potential different return values or types) and 2 (potential different exception handlings)."
476,"<android.widget.Gallery: int getLimitedMotionScrollAmount(boolean,int)>",13,14,,,,"{
    int extremeItemPosition = motionToLeft ? mItemCount - 1 : 0;
    View extremeChild = getChildAt(extremeItemPosition - mFirstPosition);
    if (extremeChild == null) {
        return deltaX;
    }
    int extremeChildCenter = getCenterOfView(extremeChild);
    int galleryCenter = getCenterOfGallery();
    if (motionToLeft) {
        if (extremeChildCenter <= galleryCenter) {
            // The extreme child is past his boundary point!
            return 0;
        }
    } else {
        if (extremeChildCenter >= galleryCenter) {
            // The extreme child is past his boundary point!
            return 0;
        }
    }
    int centerDifference = galleryCenter - extremeChildCenter;
    return motionToLeft ? Math.max(centerDifference, deltaX) : Math.min(centerDifference, deltaX);
}","{
    int extremeItemPosition = motionToLeft != mIsRtl ? mItemCount - 1 : 0;
    View extremeChild = getChildAt(extremeItemPosition - mFirstPosition);
    if (extremeChild == null) {
        return deltaX;
    }
    int extremeChildCenter = getCenterOfView(extremeChild);
    int galleryCenter = getCenterOfGallery();
    if (motionToLeft) {
        if (extremeChildCenter <= galleryCenter) {
            // The extreme child is past his boundary point!
            return 0;
        }
    } else {
        if (extremeChildCenter >= galleryCenter) {
            // The extreme child is past his boundary point!
            return 0;
        }
    }
    int centerDifference = galleryCenter - extremeChildCenter;
    return motionToLeft ? Math.max(centerDifference, deltaX) : Math.min(centerDifference, deltaX);
}",1,,,0,,,0,,,,,,,"3,5",0,"The assignment of extremeItemPosition has changed by including a check for mIsRtl which is a control dependency change (type 3). Additionally, since mIsRtl does not appear to be a parameter signature of the method and seems to be an internal state of the object, then this represents a dependent API that has changed (type 5).","Although the assignment of extremeItemPosition has changed if mIsRtl is true, this does not influence the outcome of the method (the returned value) due to the same subsequent logic in both versions. Therefore, there is no Compatibility Issue (0)."
477,<android.database.BulkCursorProxy: Bundle getExtras()>,13,14,,,,"{
    if (mExtras == null) {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IBulkCursor.descriptor);
        mRemote.transact(GET_EXTRAS_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        mExtras = reply.readBundle();
        data.recycle();
        reply.recycle();
    }
    return mExtras;
}","{
    if (mExtras == null) {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        try {
            data.writeInterfaceToken(IBulkCursor.descriptor);
            mRemote.transact(GET_EXTRAS_TRANSACTION, data, reply, 0);
            DatabaseUtils.readExceptionFromParcel(reply);
            mExtras = reply.readBundle();
        } finally {
            data.recycle();
            reply.recycle();
        }
    }
    return mExtras;
}",1,,,0,,,0,,,,,,,"3,4",0,"The implementation now includes a try-finally block for resource management, but the logic and return value remain the same, so the code changes are classified as 3 (control dependency changed due to the addition of try-finally block) and 4 (other statement changed due to the restructuring of code to include the try-finally block). ","There is no Compatibility Issue because the behavior of the API hasn't changed; the method still returns the same 'mExtras' value and the exception handling remains the same, just the code structure is improved for better resource management."
478,<android.widget.TabWidget: void sendAccessibilityEventUnchecked(AccessibilityEvent)>,13,14,,,,"{
    // this class fires events only when tabs are focused or selected
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_FOCUSED && isFocused()) {
        return;
    }
    super.sendAccessibilityEventUnchecked(event);
}","{
    // this class fires events only when tabs are focused or selected
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_FOCUSED && isFocused()) {
        event.recycle();
        return;
    }
    super.sendAccessibilityEventUnchecked(event);
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"An event.recycle() call has been added before a return statement in a conditional block, which is classified as 'Other statement changed' (4). This adds an operation to recycle the event, but only affects the state of the event object being passed in and cleans up the object without changing the method's behavior from the perspective of the caller.","There is no Compatibility Issue, as this change does not affect the behavior of the method in a way that would lead to different return values, different exceptions thrown, or different control flow from the perspective of the caller. The added event.recycle() call is effectively a memory optimization and/or cleanup within a conditional branch that otherwise exits the method early."
479,<android.net.http.SslCertificate: SslCertificate restoreState(Bundle)>,13,14,,,,"{
    if (bundle != null) {
        return new SslCertificate(bundle.getString(ISSUED_TO), bundle.getString(ISSUED_BY), bundle.getString(VALID_NOT_BEFORE), bundle.getString(VALID_NOT_AFTER));
    }
    return null;
}","{
    if (bundle == null) {
        return null;
    }
    X509Certificate x509Certificate;
    byte[] bytes = bundle.getByteArray(X509_CERTIFICATE);
    if (bytes == null) {
        x509Certificate = null;
    } else {
        try {
            CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            Certificate cert = certFactory.generateCertificate(new ByteArrayInputStream(bytes));
            x509Certificate = (X509Certificate) cert;
        } catch (CertificateException e) {
            x509Certificate = null;
        }
    }
    return new SslCertificate(bundle.getString(ISSUED_TO), bundle.getString(ISSUED_BY), parseDate(bundle.getString(VALID_NOT_BEFORE)), parseDate(bundle.getString(VALID_NOT_AFTER)), x509Certificate);
}",1,"/**
 * Restores the certificate stored in the bundle
 * @param bundle The bundle with the certificate state stored in it
 * @return The SSL certificate stored in the bundle or null if fails
 */
","/**
 * Restores the certificate stored in the bundle
 * @param bundle The bundle with the certificate state stored in it
 * @return The SSL certificate stored in the bundle or null if fails
 */
",0,,,0,,,,,,,"1,3,5","1,2","The implementation of the method has changed significantly: the conditional check for the bundle has been reversed; the method restores the state by parsing the bundle differently, incorporating X.509 certificate parsing; and a new dependent API, parseDate(), is called. Moreover, the type of one or more parameters passed to the SslCertificate constructor has changed from String to Date, due to the inclusion of the parseDate() method. Hence, the code change types are 1,3,5.","Given that the implementation of SslCertificate restoreState has been altered to include new data parsing and the control flow has been modified to incorporate additional error handling for the certificate parsing, there are two potential compatibility issues. There is a possibility of different return values because the method may now return SslCertificate instances with different initialization parameters (due to the new parseDate calls and potential inclusion of an X509Certificate object). Additionally, a new exception handling path for CertificateException has been introduced, which can lead to different exception handling behavior. Therefore, the CI types are 1 for potential different return values or types, and 2 for potential different exception handlings."
482,<android.widget.PopupWindow.PopupViewContainer: boolean dispatchKeyEvent(KeyEvent)>,13,14,,,,"{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null && state.isTracking(event) && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}","{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (getKeyDispatcherState() == null) {
            return super.dispatchKeyEvent(event);
        }
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = getKeyDispatcherState();
            if (state != null && state.isTracking(event) && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    } else {
        return super.dispatchKeyEvent(event);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,0,"The control dependency has changed because a section of code was added that checks if getKeyDispatcherState() is null before processing other conditions, so the code change type is 3.","Although the control dependency has changed, the potential behavior of the API remains the same. If getKeyDispatcherState() is null, it now returns super.dispatchKeyEvent(event) earlier than before. However, if getKeyDispatcherState() were null in the earlier version, the later conditions would also not execute, leading to the same call to super.dispatchKeyEvent(event). Thus, there is no CI because the return values and exception handling remain unaffected by this change."
488,"<android.database.CursorWindow: int getType(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return getType_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetType(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns data type of the given column's value.
 * <p>
 * Returned column types are
 * <ul>
 * <li>{@link Cursor#FIELD_TYPE_NULL}</li>
 * <li>{@link Cursor#FIELD_TYPE_INTEGER}</li>
 * <li>{@link Cursor#FIELD_TYPE_FLOAT}</li>
 * <li>{@link Cursor#FIELD_TYPE_STRING}</li>
 * <li>{@link Cursor#FIELD_TYPE_BLOB}</li>
 * </ul>
 * </p>
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return the value type
 */
","/**
 * Returns the type of the field at the specified row and column index.
 * <p>
 * The returned field types are:
 * <ul>
 * <li>{@link Cursor#FIELD_TYPE_NULL}</li>
 * <li>{@link Cursor#FIELD_TYPE_INTEGER}</li>
 * <li>{@link Cursor#FIELD_TYPE_FLOAT}</li>
 * <li>{@link Cursor#FIELD_TYPE_STRING}</li>
 * <li>{@link Cursor#FIELD_TYPE_BLOB}</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The field type.
 */
",1,,,0,,,,,,,"1,4,5",1,"The method called within the return statement has changed from getType_native(int, int) to nativeGetType(long, int, int), and the method signature and parameter list have been modified, so the code change types are 1,4,5.","This modification could cause the API to return a different value due to the change in the method called and the parameters used, thus the CI type is 1."
489,<android.widget.NumberPicker: boolean dispatchTouchEvent(MotionEvent)>,13,14,,,,"{
    int action = event.getActionMasked();
    if ((action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) && !isEventInViewHitRect(event, mInputText)) {
        removeAllCallbacks();
    }
    return super.dispatchTouchEvent(event);
}","{
    final int action = event.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            if (mSelectorWheelState == SELECTOR_WHEEL_STATE_LARGE) {
                removeAllCallbacks();
                forceCompleteChangeCurrentByOneViaScroll();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            removeAllCallbacks();
            break;
    }
    return super.dispatchTouchEvent(event);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The control dependency has changed from an if-statement to a switch-statement. Additionally, a new case for ACTION_MOVE and associated logic has been added to the late version of the method, which did not exist in the early version. Therefore, the changes include return statements in the context of the control structures being modified and control dependency change, so the code change types are 1,3.","The addition of new control logic that handles ACTION_MOVE events in the late version can potentially affect the return value of the method, because it calls removeAllCallbacks() and forceCompleteChangeCurrentByOneViaScroll(), which were not present in the early version, when a MOVE event occurs. This addition yields a flow of execution that does not exist in the early version, hence the potential for a different return value arises, identifying the CI type as 1."
490,<android.webkit.WebView: boolean canZoomOut()>,13,14,,,,"{
    return mZoomManager.canZoomOut();
}","{
    checkThread();
    return mZoomManager.canZoomOut();
}",1,"/**
 * @return TRUE if the WebView can be zoomed out.
 */
","/**
 * @return TRUE if the WebView can be zoomed out.
 */
",0,,,0,,,,,,,4,0,"An additional method call, checkThread(), is added before the return statement, so the change type is 4 (Other statement changed).","The new checkThread() call does not affect the return statement or exception handling. It seems to be a thread safety check and is unlikely to change the return value of the API, so the CI type is 0 (No Compatibility Issue)."
491,<android.server.BluetoothDeviceProperties: Set<String> keySet()>,13,14,,,,"{
    return mPropertiesMap.keySet();
}","{
    synchronized (mPropertiesMap) {
        return mPropertiesMap.keySet();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The introduction of a synchronized block around the return statement is a control dependency change (3), and the overall synchronization pattern added is an other statement change (4).","Although a synchronized block has been added to make the method thread-safe, this change does not affect the return value of the method. The method still returns the same set which is mPropertiesMap.keySet(), hence there is no Compatibility Issue as the behavior of the method with respect to the returned value remains unchanged."
492,<android.database.sqlite.SQLiteQuery: int columnCountLocked()>,13,14,,,,"{
    acquireReference();
    try {
        return native_column_count();
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeColumnCount(nStatement);
    } finally {
        releaseReference();
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,5",1,"The method called within the return statement has changed from native_column_count() to nativeColumnCount(nStatement), with an additional parameter 'nStatement' passed to the new method, so the code change type is 1,5.","The change in the dependent method call could potentially lead to a different return value due to the change in the method signature, so the CI type is 1."
493,"<android.app.Activity: boolean startActivityIfNeeded(Intent,int)>",13,14,,,,"{
    if (mParent == null) {
        int result = IActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, 0, mToken, mEmbeddedID, requestCode, true, false);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != IActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}","{
    if (mParent == null) {
        int result = IActivityManager.START_RETURN_INTENT_TO_CALLER;
        try {
            intent.setAllowFds(false);
            result = ActivityManagerNative.getDefault().startActivity(mMainThread.getApplicationThread(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, 0, mToken, mEmbeddedID, requestCode, true, false, null, null, false);
        } catch (RemoteException e) {
        // Empty
        }
        Instrumentation.checkStartActivityResult(result, intent);
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
        return result != IActivityManager.START_RETURN_INTENT_TO_CALLER;
    }
    throw new UnsupportedOperationException(""startActivityIfNeeded can only be called from a top-level activity"");
}",1,"/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
","/**
 * A special variation to launch an activity only if a new activity
 * instance is needed to handle the given Intent.  In other words, this is
 * just like {@link #startActivityForResult(Intent, int)} except: if you are
 * using the {@link Intent#FLAG_ACTIVITY_SINGLE_TOP} flag, or
 * singleTask or singleTop
 * {@link android.R.styleable#AndroidManifestActivity_launchMode launchMode},
 * and the activity
 * that handles <var>intent</var> is the same as your currently running
 * activity, then a new instance is not needed.  In this case, instead of
 * the normal behavior of calling {@link #onNewIntent} this function will
 * return and you can handle the Intent yourself.
 *
 * <p>This function can only be called from a top-level activity; if it is
 * called from a child activity, a runtime exception will be thrown.
 *
 * @param intent The intent to start.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits, as described in
 * {@link #startActivityForResult}.
 *
 * @return If a new activity was launched then true is returned; otherwise
 * false is returned and you must handle the Intent yourself.
 *
 * @see #startActivity
 * @see #startActivityForResult
 */
",0,,,0,,,,,,,"4,5",0,"The method invocation `intent.setAllowFds(false);` has been added and the method call to `ActivityManagerNative.getDefault().startActivity(...)` now includes additional `null, null, false` parameters. Therefore, the code change type is 4,5, since Other statements have changed, and Dependent APIs have changed with the addition of new parameters to the method call.","There's no Compatibility Issue detected, because the additions do not alter the return value of the method nor do they introduce different exception handling. The call to `intent.setAllowFds(false);` is setting an internal state of the intent, and unless this setting affects the outcome of `ActivityManagerNative.getDefault().startActivity(...)`, which is not evident from the context provided, this does not qualify as a change that leads to a Compatibility Issue. Therefore, the CI type is 0."
495,<android.app.ContextImpl: int checkCallingPermission(String)>,13,14,,,,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    if (!Process.supportsProcesses()) {
        return PackageManager.PERMISSION_GRANTED;
    }
    int pid = Binder.getCallingPid();
    if (pid != Process.myPid()) {
        return checkPermission(permission, pid, Binder.getCallingUid());
    }
    return PackageManager.PERMISSION_DENIED;
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    int pid = Binder.getCallingPid();
    if (pid != Process.myPid()) {
        return checkPermission(permission, pid, Binder.getCallingUid());
    }
    return PackageManager.PERMISSION_DENIED;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The check for `Process.supportsProcesses()` has been removed, and hence the corresponding return statement `return PackageManager.PERMISSION_GRANTED;` is also removed. The code changes include a 3 (Control dependency change) because an if condition was removed. Also, it includes a 4 (Other statement changed) due to the deletion of that return statement.","Despite the change in control dependencies and statements, they do not lead to a Compatibility Issue because the outcome of the removed code was only relevant when the OS did not support processes which is not applicable for the devices running version of Android 14 or above. Therefore, the API's behavior will not change for its intended usage scenarios, and there is no CI here."
496,<android.content.SyncAdapterType: String toString()>,13,14,,,,"{
    if (isKey) {
        return ""SyncAdapterType Key {name="" + authority + "", type="" + accountType + ""}"";
    } else {
        return ""SyncAdapterType {name="" + authority + "", type="" + accountType + "", userVisible="" + userVisible + "", supportsUploading="" + supportsUploading + "", isAlwaysSyncable="" + isAlwaysSyncable + "", allowParallelSyncs="" + allowParallelSyncs + ""}"";
    }
}","{
    if (isKey) {
        return ""SyncAdapterType Key {name="" + authority + "", type="" + accountType + ""}"";
    } else {
        return ""SyncAdapterType {name="" + authority + "", type="" + accountType + "", userVisible="" + userVisible + "", supportsUploading="" + supportsUploading + "", isAlwaysSyncable="" + isAlwaysSyncable + "", allowParallelSyncs="" + allowParallelSyncs + "", settingsActivity="" + settingsActivity + ""}"";
    }
}",1,,,0,,,0,,,,,,,"1,4",1,"Other statements have been added to the non-'isKey' return statement: the string concatenates a new field, “settingsActivity,” in the return statement, which makes the change fall under code change type 1,4.","The addition of a new field in the toString() method output potentially changes the returned value. Therefore, this will cause a Compatibility Issue of the type where the return variable value is different (CI type 1)."
497,"<android.server.BluetoothDeviceProperties: String getProperty(String,String)>",13,14,,,,"{
    Map<String, String> properties = mPropertiesMap.get(address);
    if (properties != null) {
        return properties.get(property);
    } else {
        // Query for remote device properties, again.
        // We will need to reload the cache when we switch Bluetooth on / off
        // or if we crash.
        properties = updateCache(address);
        if (properties != null) {
            return properties.get(property);
        }
    }
    Log.e(TAG, ""getRemoteDeviceProperty: "" + property + "" not present: "" + address);
    return null;
}","{
    synchronized (mPropertiesMap) {
        Map<String, String> properties = mPropertiesMap.get(address);
        if (properties != null) {
            return properties.get(property);
        } else {
            // Query for remote device properties, again.
            // We will need to reload the cache when we switch Bluetooth on / off
            // or if we crash.
            properties = updateCache(address);
            if (properties != null) {
                return properties.get(property);
            }
        }
    }
    Log.e(TAG, ""getRemoteDeviceProperty: "" + property + "" not present: "" + address);
    return null;
}",1,,,0,,,0,,,,,,,"3, 4",0,"The implementation change involves adding a `synchronized` block around the existing code without modifying the logic within the block, and the rest of the code remains the same. The added synchronization is an ""other statement"" (code change type 4) and the addition of this synchronization block also introduces a change in the control dependency (code change type 3), as it introduces a new level of block structure around the previous code.","This change adds thread-safety to the method by synchronizing access to the `mPropertiesMap` to prevent concurrent modifications. Since the method's behavior (in terms of returning values and handling exceptions) does not change with respect to the single-threaded execution, there is no compatibility issue introduced by this change. The method will still return the same values and handle exceptions as it did before, provided the state of `mPropertiesMap` when accessed is consistent."
499,<android.view.View: float getPivotX()>,13,14,,,,"{
    return mPivotX;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mPivotX : 0;
}",1,"/**
 * The x location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleX(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The x location of the pivot point.
 */
","/**
 * The x location of the point around which the view is {@link #setRotation(float) rotated}
 * and {@link #setScaleX(float) scaled}.
 *
 * @see #getRotation()
 * @see #getScaleX()
 * @see #getScaleY()
 * @see #getPivotY()
 * @return The x location of the pivot point.
 */
",0,,,0,,,,,,,1,1,"The return statement has changed. In the early version, it directly returns the value of mPivotX, while in the late version, it checks if mTransformationInfo is not null and then returns mTransformationInfo.mPivotX; otherwise, it returns 0. This constitutes a change of the return statement.","This change could lead to a different return value when mTransformationInfo is null; in the early version, it would return the raw value of mPivotX which could be anything, while in the late version, it would return 0. Hence, the potential different return values constitute a Compatibility Issue of type 1."
500,<android.nfc.Tag: String toString()>,13,14,,,,"{
    StringBuilder sb = new StringBuilder(""TAG "").append(""uid = "").append(mId).append("" Tech ["");
    for (int i : mTechList) {
        sb.append(i).append("", "");
    }
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(""TAG: Tech ["");
    String[] techList = getTechList();
    int length = techList.length;
    for (int i = 0; i < length; i++) {
        sb.append(techList[i]);
        if (i < length - 1) {
            sb.append("", "");
        }
    }
    sb.append(""]"");
    return sb.toString();
}",1,"/**
 * Human-readable description of the tag, for debugging.
 */
","/**
 * Human-readable description of the tag, for debugging.
 */
",0,[@Override],[@Override],0,,,,,,,"1,3,4,5",1,"The method's implementation has changed significantly between the early and late versions. It now uses 'getTechList' (a probable dependent API) to get the list of technologies supported by the NFC Tag, changes the 'for' loop control structure, and modifies the way the 'StringBuilder' is constructed and appended. Therefore, the change types are 1 (because the content of the returned String is different), 3 (control dependency change for the loop structure), 4 (other statement changed because of StringBuilder alteration), and 5 (use of dependent API 'getTechList').","Because the implementation has changed, the output string from 'toString()' method is different. It omits ""uid = "" and possible integer tech representations with their string counterparts pulled from 'getTechList()', this represents a return value change, and so the CI type is 1."
501,"<android.content.ContentResolver: AssetFileDescriptor openAssetFileDescriptor(Uri,String)>",13,14,,,,"{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider provider = acquireProvider(uri);
            if (provider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            try {
                AssetFileDescriptor fd = provider.openAssetFile(uri, mode);
                if (fd == null) {
                    releaseProvider(provider);
                    return null;
                }
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                provider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // process shortly anyway if the depdendent ContentProvider dies.
                throw new FileNotFoundException(""Dead content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (provider != null) {
                    releaseProvider(provider);
                }
            }
        }
    }
}","{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!""r"".equals(mode)) {
            throw new FileNotFoundException(""Can't write resources: "" + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException(""Resource does not exist: "" + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), modeToMode(uri, mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if (""r"".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, ""*/*"", null);
        } else {
            IContentProvider provider = acquireProvider(uri);
            if (provider == null) {
                throw new FileNotFoundException(""No content provider: "" + uri);
            }
            try {
                AssetFileDescriptor fd = provider.openAssetFile(uri, mode);
                if (fd == null) {
                    // The provider will be released by the finally{} clause
                    return null;
                }
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), provider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                provider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // process shortly anyway if the depdendent ContentProvider dies.
                throw new FileNotFoundException(""Dead content provider: "" + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (provider != null) {
                    releaseProvider(provider);
                }
            }
        }
    }
}",1,"/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
","/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/"" + R.raw.my_resource"");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse(""android.resource://com.example.myapp/raw/my_resource"");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is ""r"")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of ""*\/*"".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */
",0,,,0,,,,,,,0,0,The early version and the late version are identical—no changes have been made to the code.,"Since there are no changes between the two versions, there are no compatibility issues."
503,<android.animation.AnimatorSet: void cancel()>,13,14,,,,"{
    mCanceled = true;
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        for (AnimatorListener listener : tmpListeners) {
            listener.onAnimationCancel(this);
        }
    }
    if (mDelayAnim != null && mDelayAnim.isRunning()) {
        // If we're currently in the startDelay period, just cancel that animator and
        // send out the end event to all listeners
        mDelayAnim.cancel();
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            for (AnimatorListener listener : tmpListeners) {
                listener.onAnimationEnd(this);
            }
        }
        return;
    }
    if (mSortedNodes.size() > 0) {
        for (Node node : mSortedNodes) {
            node.animation.cancel();
        }
    }
}","{
    mTerminated = true;
    if (isStarted()) {
        ArrayList<AnimatorListener> tmpListeners = null;
        if (mListeners != null) {
            tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            for (AnimatorListener listener : tmpListeners) {
                listener.onAnimationCancel(this);
            }
        }
        if (mDelayAnim != null && mDelayAnim.isRunning()) {
            // If we're currently in the startDelay period, just cancel that animator and
            // send out the end event to all listeners
            mDelayAnim.cancel();
        } else if (mSortedNodes.size() > 0) {
            for (Node node : mSortedNodes) {
                node.animation.cancel();
            }
        }
        if (tmpListeners != null) {
            for (AnimatorListener listener : tmpListeners) {
                listener.onAnimationEnd(this);
            }
        }
        mStarted = false;
    }
}",1,"/**
 * {@inheritDoc}
 *
 * <p>Note that canceling a <code>AnimatorSet</code> also cancels all of the animations that it is
 * responsible for.</p>
 */
","/**
 * {@inheritDoc}
 *
 * <p>Note that canceling a <code>AnimatorSet</code> also cancels all of the animations that it
 * is responsible for.</p>
 */
",1,"[@SuppressWarnings(""unchecked""), @Override]","[@SuppressWarnings(""unchecked""), @Override]",0,,,,,,,"1,3,4","1,2","The early version checks `mListeners != null` twice for canceling `mDelayAnim` and for the `if (mSortedNodes.size() > 0)` branch, while the late version only checks it once before these blocks and reuses the `tmpListeners`. Also, the variable `mCanceled` is changed to `mTerminated`. Furthermore, there is a check for `isStarted()` enclosing the entire late version's code, a new condition for `mDelayAnim` and `mSortedNodes`, and a statement to set `mStarted` to false at the end. So, there are changes regarding control dependency, other statements, and a return statement has been removed.","Since the late version introduces a check for `isStarted()` and subsequently does not execute any cancellation if the animator set is not started, whereas the early version does not perform such a check, this could change the behavior by not canceling when the animator set is not started. Thus, a different behavior is introduced, leading to a CI. Additionally, there is a potential difference in exception handling, since the late version could throw exceptions during the clone operation whereas in the early version any exceptions during the second clone would be caught. This also indicates a potential CI."
504,<android.provider.Telephony.Sms.Intents: SmsMessage[] getMessagesFromIntent(Intent)>,13,14,,,,"{
    Object[] messages = (Object[]) intent.getSerializableExtra(""pdus"");
    byte[][] pduObjs = new byte[messages.length][];
    for (int i = 0; i < messages.length; i++) {
        pduObjs[i] = (byte[]) messages[i];
    }
    byte[][] pdus = new byte[pduObjs.length][];
    int pduCount = pdus.length;
    SmsMessage[] msgs = new SmsMessage[pduCount];
    for (int i = 0; i < pduCount; i++) {
        pdus[i] = pduObjs[i];
        msgs[i] = SmsMessage.createFromPdu(pdus[i]);
    }
    return msgs;
}","{
    Object[] messages = (Object[]) intent.getSerializableExtra(""pdus"");
    String format = intent.getStringExtra(""format"");
    byte[][] pduObjs = new byte[messages.length][];
    for (int i = 0; i < messages.length; i++) {
        pduObjs[i] = (byte[]) messages[i];
    }
    byte[][] pdus = new byte[pduObjs.length][];
    int pduCount = pdus.length;
    SmsMessage[] msgs = new SmsMessage[pduCount];
    for (int i = 0; i < pduCount; i++) {
        pdus[i] = pduObjs[i];
        msgs[i] = SmsMessage.createFromPdu(pdus[i], format);
    }
    return msgs;
}",1,"/**
 * Read the PDUs out of an {@link #SMS_RECEIVED_ACTION} or a
 * {@link #DATA_SMS_RECEIVED_ACTION} intent.
 *
 * @param intent the intent to read from
 * @return an array of SmsMessages for the PDUs
 */
","/**
 * Read the PDUs out of an {@link #SMS_RECEIVED_ACTION} or a
 * {@link #DATA_SMS_RECEIVED_ACTION} intent.
 *
 * @param intent the intent to read from
 * @return an array of SmsMessages for the PDUs
 */
",0,,,0,,,,,,,"4,5","1,5","A new local variable declaration (`String format = intent.getStringExtra(""format"");`) has been added and the method call `SmsMessage.createFromPdu(pdus[i], format);` now includes the additional `format` parameter. There's an addition to the method signature of the dependent API `createFromPdu`. Therefore, the code change types are 4 for other statement changed and 5 for dependent API changed.","The dependent API `SmsMessage.createFromPdu` has been called with an additional parameter (`format`) which could potentially change the behavior of the `getMessagesFromIntent` method either by affecting the return values or by throwing different exceptions if the format is not supported or is processed differently. Therefore, the Compatibility Issue types could be 1 for potential different return values or types, and 5 for changes due to modified dependent API call."
505,<android.bluetooth.BluetoothSocket: int bindListen()>,13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            return EBADFD;
        return bindListenNative();
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            return EBADFD;
        return bindListenNative();
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"3,4",0,"The condition in the if statement has changed from checking `mClosed` to checking `mSocketState == SocketState.CLOSED`. There is also the introduction of an enum or constant `SocketState.CLOSED`, which is a type of Other statement changed.","Even though there is a change in the condition statement, it doesn't affect the behavior of the method in terms of returned values or thrown exceptions, assuming that the two conditions `mClosed` and `mSocketState == SocketState.CLOSED` are semantically equivalent and only the structure of the condition has changed. Therefore, the Compatibility Issue type is 0."
506,<android.view.View: boolean requestFocusFromTouch()>,13,14,,,,"{
    // Leave touch mode if we need to
    if (isInTouchMode()) {
        ViewRoot viewRoot = getViewRoot();
        if (viewRoot != null) {
            viewRoot.ensureTouchMode(false);
        }
    }
    return requestFocus(View.FOCUS_DOWN);
}","{
    // Leave touch mode if we need to
    if (isInTouchMode()) {
        ViewRootImpl viewRoot = getViewRootImpl();
        if (viewRoot != null) {
            viewRoot.ensureTouchMode(false);
        }
    }
    return requestFocus(View.FOCUS_DOWN);
}",1,"/**
 * Call this to try to give focus to a specific view or to one of its descendants. This is a
 * special variant of {@link #requestFocus() } that will allow views that are not focuable in
 * touch mode to request focus when they are touched.
 *
 * @return Whether this view or one of its descendants actually took focus.
 *
 * @see #isInTouchMode()
 */
","/**
 * Call this to try to give focus to a specific view or to one of its descendants. This is a
 * special variant of {@link #requestFocus() } that will allow views that are not focuable in
 * touch mode to request focus when they are touched.
 *
 * @return Whether this view or one of its descendants actually took focus.
 *
 * @see #isInTouchMode()
 */
",0,,,0,,,,,,,"3,5",0,"The method getViewRoot() has been changed to getViewRootImpl(), and the type of variable `viewRoot` has changed from `ViewRoot` to `ViewRootImpl`. This indicates a change in the dependent API as well as the control dependency change because the source of the variable has altered, however, these changes are localized within an if block and do not affect the return statement. The code change type is 3,5.","Although there is a change in the way the viewRoot object is obtained and its type, the public behavior of this API method (requestFocusFromTouch) remains consistent with the previous implementation because the control flow is not altered in a way that affects the output of the method. The final return statement remains unchanged and will return the same result. Thus, no Compatibility Issue should be introduced by these changes since the behavior as observed by the caller should remain the same; hence the CI type is 0."
509,"<android.text.method.MultiTapKeyListener: boolean onKeyDown(View,Editable,int,KeyEvent)>",13,14,,,,"{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // now for the multitap cases...
    // Try to increment the character we were working on before
    // if we have one and it's still the same key.
    int rec = (content.getSpanFlags(TextKeyListener.ACTIVE) & Spannable.SPAN_USER) >>> Spannable.SPAN_USER_SHIFT;
    if (activeStart == selStart && activeEnd == selEnd && selEnd - selStart == 1 && rec >= 0 && rec < sRecs.size()) {
        if (keyCode == KeyEvent.KEYCODE_STAR) {
            char current = content.charAt(selStart);
            if (Character.isLowerCase(current)) {
                content.replace(selStart, selEnd, String.valueOf(current).toUpperCase());
                removeTimeouts(content);
                Timeout t = new Timeout(content);
                return true;
            }
            if (Character.isUpperCase(current)) {
                content.replace(selStart, selEnd, String.valueOf(current).toLowerCase());
                removeTimeouts(content);
                Timeout t = new Timeout(content);
                return true;
            }
        }
        if (sRecs.indexOfKey(keyCode) == rec) {
            String val = sRecs.valueAt(rec);
            char ch = content.charAt(selStart);
            int ix = val.indexOf(ch);
            if (ix >= 0) {
                ix = (ix + 1) % (val.length());
                content.replace(selStart, selEnd, val, ix, ix + 1);
                removeTimeouts(content);
                Timeout t = new Timeout(content);
                return true;
            }
        }
        // Is this key one we know about at all?  If so, acknowledge
        // that the selection is our fault but the key has changed
        // or the text no longer matches, so move the selection over
        // so that it inserts instead of replaces.
        rec = sRecs.indexOfKey(keyCode);
        if (rec >= 0) {
            Selection.setSelection(content, selEnd, selEnd);
            selStart = selEnd;
        }
    } else {
        rec = sRecs.indexOfKey(keyCode);
    }
    if (rec >= 0) {
        // We have a valid key.  Replace the selection or insertion point
        // with the first character for that key, and remember what
        // record it came from for next time.
        String val = sRecs.valueAt(rec);
        int off = 0;
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && TextKeyListener.shouldCap(mCapitalize, content, selStart)) {
            for (int i = 0; i < val.length(); i++) {
                if (Character.isUpperCase(val.charAt(i))) {
                    off = i;
                    break;
                }
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, val, off, off + 1);
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (selEnd != oldStart) {
            Selection.setSelection(content, oldStart, selEnd);
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | (rec << Spannable.SPAN_USER_SHIFT));
        }
        removeTimeouts(content);
        Timeout t = new Timeout(content);
        if (content.getSpanStart(this) < 0) {
            KeyListener[] methods = content.getSpans(0, content.length(), KeyListener.class);
            for (Object method : methods) {
                content.removeSpan(method);
            }
            content.setSpan(this, 0, content.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
        }
        return true;
    }
    return super.onKeyDown(view, content, keyCode, event);
}","{
    int selStart, selEnd;
    int pref = 0;
    if (view != null) {
        pref = TextKeyListener.getInstance().getPrefs(view.getContext());
    }
    {
        int a = Selection.getSelectionStart(content);
        int b = Selection.getSelectionEnd(content);
        selStart = Math.min(a, b);
        selEnd = Math.max(a, b);
    }
    int activeStart = content.getSpanStart(TextKeyListener.ACTIVE);
    int activeEnd = content.getSpanEnd(TextKeyListener.ACTIVE);
    // now for the multitap cases...
    // Try to increment the character we were working on before
    // if we have one and it's still the same key.
    int rec = (content.getSpanFlags(TextKeyListener.ACTIVE) & Spannable.SPAN_USER) >>> Spannable.SPAN_USER_SHIFT;
    if (activeStart == selStart && activeEnd == selEnd && selEnd - selStart == 1 && rec >= 0 && rec < sRecs.size()) {
        if (keyCode == KeyEvent.KEYCODE_STAR) {
            char current = content.charAt(selStart);
            if (Character.isLowerCase(current)) {
                content.replace(selStart, selEnd, String.valueOf(current).toUpperCase());
                removeTimeouts(content);
                // for its side effects
                new Timeout(content);
                return true;
            }
            if (Character.isUpperCase(current)) {
                content.replace(selStart, selEnd, String.valueOf(current).toLowerCase());
                removeTimeouts(content);
                // for its side effects
                new Timeout(content);
                return true;
            }
        }
        if (sRecs.indexOfKey(keyCode) == rec) {
            String val = sRecs.valueAt(rec);
            char ch = content.charAt(selStart);
            int ix = val.indexOf(ch);
            if (ix >= 0) {
                ix = (ix + 1) % (val.length());
                content.replace(selStart, selEnd, val, ix, ix + 1);
                removeTimeouts(content);
                // for its side effects
                new Timeout(content);
                return true;
            }
        }
        // Is this key one we know about at all?  If so, acknowledge
        // that the selection is our fault but the key has changed
        // or the text no longer matches, so move the selection over
        // so that it inserts instead of replaces.
        rec = sRecs.indexOfKey(keyCode);
        if (rec >= 0) {
            Selection.setSelection(content, selEnd, selEnd);
            selStart = selEnd;
        }
    } else {
        rec = sRecs.indexOfKey(keyCode);
    }
    if (rec >= 0) {
        // We have a valid key.  Replace the selection or insertion point
        // with the first character for that key, and remember what
        // record it came from for next time.
        String val = sRecs.valueAt(rec);
        int off = 0;
        if ((pref & TextKeyListener.AUTO_CAP) != 0 && TextKeyListener.shouldCap(mCapitalize, content, selStart)) {
            for (int i = 0; i < val.length(); i++) {
                if (Character.isUpperCase(val.charAt(i))) {
                    off = i;
                    break;
                }
            }
        }
        if (selStart != selEnd) {
            Selection.setSelection(content, selEnd);
        }
        content.setSpan(OLD_SEL_START, selStart, selStart, Spannable.SPAN_MARK_MARK);
        content.replace(selStart, selEnd, val, off, off + 1);
        int oldStart = content.getSpanStart(OLD_SEL_START);
        selEnd = Selection.getSelectionEnd(content);
        if (selEnd != oldStart) {
            Selection.setSelection(content, oldStart, selEnd);
            content.setSpan(TextKeyListener.LAST_TYPED, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            content.setSpan(TextKeyListener.ACTIVE, oldStart, selEnd, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE | (rec << Spannable.SPAN_USER_SHIFT));
        }
        removeTimeouts(content);
        // for its side effects
        new Timeout(content);
        if (content.getSpanStart(this) < 0) {
            KeyListener[] methods = content.getSpans(0, content.length(), KeyListener.class);
            for (Object method : methods) {
                content.removeSpan(method);
            }
            content.setSpan(this, 0, content.length(), Spannable.SPAN_INCLUSIVE_INCLUSIVE);
        }
        return true;
    }
    return super.onKeyDown(view, content, keyCode, event);
}",1,,,0,,,0,,,,,,,,,,
510,<android.view.GestureDetector: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mBiggerTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    final float y = ev.getY();
    final float x = ev.getX();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            if (mIgnoreMultitouch) {
                // Multitouch event - abort.
                cancel();
            }
            break;
        case MotionEvent.ACTION_POINTER_UP:
            // Ending a multitouch gesture and going back to 1 finger
            if (mIgnoreMultitouch && ev.getPointerCount() == 2) {
                int index = (((action & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT) == 0) ? 1 : 0;
                mLastMotionX = ev.getX(index);
                mLastMotionY = ev.getY(index);
                mVelocityTracker.recycle();
                mVelocityTracker = VelocityTracker.obtain();
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mLastMotionX = x;
            mLastMotionY = y;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || (mIgnoreMultitouch && ev.getPointerCount() > 1)) {
                break;
            }
            final float scrollX = mLastMotionX - x;
            final float scrollY = mLastMotionY - y;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (x - mCurrentDownEvent.getX());
                final int deltaY = (int) (y - mCurrentDownEvent.getY());
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mBiggerTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastMotionX = x;
                mLastMotionY = y;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity();
                final float velocityX = velocityTracker.getXVelocity();
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            mIsDoubleTapping = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}",1,"/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
","/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */
",0,,,0,,,,,,,,,,
511,"<android.content.ContentProviderProxy: int update(Uri,ContentValues,String,String[])>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    values.writeToParcel(data, 0);
    data.writeString(selection);
    data.writeStringArray(selectionArgs);
    mRemote.transact(IContentProvider.UPDATE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    int count = reply.readInt();
    data.recycle();
    reply.recycle();
    return count;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        values.writeToParcel(data, 0);
        data.writeString(selection);
        data.writeStringArray(selectionArgs);
        mRemote.transact(IContentProvider.UPDATE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        int count = reply.readInt();
        return count;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"2,3,4",0,"The code is now wrapped in a try-finally block to ensure the parcels are recycled, which is a change in exception handling and other statements but no new exceptions are thrown and return values have not been altered, the code changes are 2,3,4.","There is no Compatibility Issue as there's no change in the exception being thrown or the return value of the method; the refactoring only ensures resource cleanup with no effect on method behavior - thus, CI type is 0."
516,<android.os.ParcelFileDescriptor: ParcelFileDescriptor fromSocket(Socket)>,13,14,,,,"{
    FileDescriptor fd = getFileDescriptorFromSocket(socket);
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}","{
    FileDescriptor fd = socket.getFileDescriptor$();
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}",1,"/**
 * Create a new ParcelFileDescriptor from the specified Socket.  The new
 * ParcelFileDescriptor holds a dup of the original FileDescriptor in
 * the Socket, so you must still close the Socket as well as the new
 * ParcelFileDescriptor.
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified Socket.
 */
","/**
 * Create a new ParcelFileDescriptor from the specified Socket.  The new
 * ParcelFileDescriptor holds a dup of the original FileDescriptor in
 * the Socket, so you must still close the Socket as well as the new
 * ParcelFileDescriptor.
 *
 * @param socket The Socket whose FileDescriptor is used to create
 * a new ParcelFileDescriptor.
 *
 * @return A new ParcelFileDescriptor with the FileDescriptor of the
 * specified Socket.
 */
",0,,,0,,,,,,,"4,5",0,"The method for obtaining the file descriptor from a socket has changed from getFileDescriptorFromSocket(socket) to socket.getFileDescriptor$(). This is an internal change in the method of obtaining the file descriptor; hence, the change type is 4.",#CI_description
517,<android.animation.ValueAnimator.AnimationHandler: void handleMessage(Message)>,13,14,,,,"{
    boolean callAgain = true;
    ArrayList<ValueAnimator> animations = sAnimations.get();
    ArrayList<ValueAnimator> delayedAnims = sDelayedAnims.get();
    switch(msg.what) {
        // were already running?
        case ANIMATION_START:
            ArrayList<ValueAnimator> pendingAnimations = sPendingAnimations.get();
            if (animations.size() > 0 || delayedAnims.size() > 0) {
                callAgain = false;
            }
            // is empty.
            while (pendingAnimations.size() > 0) {
                ArrayList<ValueAnimator> pendingCopy = (ArrayList<ValueAnimator>) pendingAnimations.clone();
                pendingAnimations.clear();
                int count = pendingCopy.size();
                for (int i = 0; i < count; ++i) {
                    ValueAnimator anim = pendingCopy.get(i);
                    // If the animation has a startDelay, place it on the delayed list
                    if (anim.mStartDelay == 0) {
                        anim.startAnimation();
                    } else {
                        delayedAnims.add(anim);
                    }
                }
            }
        // fall through to process first frame of new animations
        case ANIMATION_FRAME:
            // currentTime holds the common time for all animations processed
            // during this frame
            long currentTime = AnimationUtils.currentAnimationTimeMillis();
            ArrayList<ValueAnimator> readyAnims = sReadyAnims.get();
            ArrayList<ValueAnimator> endingAnims = sEndingAnims.get();
            // First, process animations currently sitting on the delayed queue, adding
            // them to the active animations if they are ready
            int numDelayedAnims = delayedAnims.size();
            for (int i = 0; i < numDelayedAnims; ++i) {
                ValueAnimator anim = delayedAnims.get(i);
                if (anim.delayedAnimationFrame(currentTime)) {
                    readyAnims.add(anim);
                }
            }
            int numReadyAnims = readyAnims.size();
            if (numReadyAnims > 0) {
                for (int i = 0; i < numReadyAnims; ++i) {
                    ValueAnimator anim = readyAnims.get(i);
                    anim.startAnimation();
                    delayedAnims.remove(anim);
                }
                readyAnims.clear();
            }
            // Now process all active animations. The return value from animationFrame()
            // tells the handler whether it should now be ended
            int numAnims = animations.size();
            int i = 0;
            while (i < numAnims) {
                ValueAnimator anim = animations.get(i);
                if (anim.animationFrame(currentTime)) {
                    endingAnims.add(anim);
                }
                if (animations.size() == numAnims) {
                    ++i;
                } else {
                    // An animation might be canceled or ended by client code
                    // during the animation frame. Check to see if this happened by
                    // seeing whether the current index is the same as it was before
                    // calling animationFrame(). Another approach would be to copy
                    // animations to a temporary list and process that list instead,
                    // but that entails garbage and processing overhead that would
                    // be nice to avoid.
                    --numAnims;
                    endingAnims.remove(anim);
                }
            }
            if (endingAnims.size() > 0) {
                for (i = 0; i < endingAnims.size(); ++i) {
                    endingAnims.get(i).endAnimation();
                }
                endingAnims.clear();
            }
            // after the frameDelay
            if (callAgain && (!animations.isEmpty() || !delayedAnims.isEmpty())) {
                sendEmptyMessageDelayed(ANIMATION_FRAME, Math.max(0, sFrameDelay - (AnimationUtils.currentAnimationTimeMillis() - currentTime)));
            }
            break;
    }
}","{
    boolean callAgain = true;
    ArrayList<ValueAnimator> animations = sAnimations.get();
    ArrayList<ValueAnimator> delayedAnims = sDelayedAnims.get();
    switch(msg.what) {
        // were already running?
        case ANIMATION_START:
            ArrayList<ValueAnimator> pendingAnimations = sPendingAnimations.get();
            if (animations.size() > 0 || delayedAnims.size() > 0) {
                callAgain = false;
            }
            // is empty.
            while (pendingAnimations.size() > 0) {
                ArrayList<ValueAnimator> pendingCopy = (ArrayList<ValueAnimator>) pendingAnimations.clone();
                pendingAnimations.clear();
                int count = pendingCopy.size();
                for (int i = 0; i < count; ++i) {
                    ValueAnimator anim = pendingCopy.get(i);
                    // If the animation has a startDelay, place it on the delayed list
                    if (anim.mStartDelay == 0) {
                        anim.startAnimation();
                    } else {
                        delayedAnims.add(anim);
                    }
                }
            }
        // fall through to process first frame of new animations
        case ANIMATION_FRAME:
            // currentTime holds the common time for all animations processed
            // during this frame
            long currentTime = AnimationUtils.currentAnimationTimeMillis();
            ArrayList<ValueAnimator> readyAnims = sReadyAnims.get();
            ArrayList<ValueAnimator> endingAnims = sEndingAnims.get();
            // First, process animations currently sitting on the delayed queue, adding
            // them to the active animations if they are ready
            int numDelayedAnims = delayedAnims.size();
            for (int i = 0; i < numDelayedAnims; ++i) {
                ValueAnimator anim = delayedAnims.get(i);
                if (anim.delayedAnimationFrame(currentTime)) {
                    readyAnims.add(anim);
                }
            }
            int numReadyAnims = readyAnims.size();
            if (numReadyAnims > 0) {
                for (int i = 0; i < numReadyAnims; ++i) {
                    ValueAnimator anim = readyAnims.get(i);
                    anim.startAnimation();
                    anim.mRunning = true;
                    delayedAnims.remove(anim);
                }
                readyAnims.clear();
            }
            // Now process all active animations. The return value from animationFrame()
            // tells the handler whether it should now be ended
            int numAnims = animations.size();
            int i = 0;
            while (i < numAnims) {
                ValueAnimator anim = animations.get(i);
                if (anim.animationFrame(currentTime)) {
                    endingAnims.add(anim);
                }
                if (animations.size() == numAnims) {
                    ++i;
                } else {
                    // An animation might be canceled or ended by client code
                    // during the animation frame. Check to see if this happened by
                    // seeing whether the current index is the same as it was before
                    // calling animationFrame(). Another approach would be to copy
                    // animations to a temporary list and process that list instead,
                    // but that entails garbage and processing overhead that would
                    // be nice to avoid.
                    --numAnims;
                    endingAnims.remove(anim);
                }
            }
            if (endingAnims.size() > 0) {
                for (i = 0; i < endingAnims.size(); ++i) {
                    endingAnims.get(i).endAnimation();
                }
                endingAnims.clear();
            }
            // after the frameDelay
            if (callAgain && (!animations.isEmpty() || !delayedAnims.isEmpty())) {
                sendEmptyMessageDelayed(ANIMATION_FRAME, Math.max(0, sFrameDelay - (AnimationUtils.currentAnimationTimeMillis() - currentTime)));
            }
            break;
    }
}",1,"/**
 * There are only two messages that we care about: ANIMATION_START and
 * ANIMATION_FRAME. The START message is sent when an animation's start()
 * method is called. It cannot start synchronously when start() is called
 * because the call may be on the wrong thread, and it would also not be
 * synchronized with other animations because it would not start on a common
 * timing pulse. So each animation sends a START message to the handler, which
 * causes the handler to place the animation on the active animations queue and
 * start processing frames for that animation.
 * The FRAME message is the one that is sent over and over while there are any
 * active animations to process.
 */
","/**
 * There are only two messages that we care about: ANIMATION_START and
 * ANIMATION_FRAME. The START message is sent when an animation's start()
 * method is called. It cannot start synchronously when start() is called
 * because the call may be on the wrong thread, and it would also not be
 * synchronized with other animations because it would not start on a common
 * timing pulse. So each animation sends a START message to the handler, which
 * causes the handler to place the animation on the active animations queue and
 * start processing frames for that animation.
 * The FRAME message is the one that is sent over and over while there are any
 * active animations to process.
 */
",0,[@Override],[@Override],0,,,,,,,,,,
518,<android.widget.TextView: void setTransformationMethod(TransformationMethod)>,13,14,,,,"{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    setText(mText);
}","{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !mTextIsSelectable && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
}",1,"/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
","/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */
",0,,,0,,,,,,,"3,4",0,"The late version introduces new logic to handle the case when 'method' is an instance of TransformationMethod2, including a new type casting, a new assignment to `mAllowTransformationLengthChange`, and a method call to `method2.setLengthChangesAllowed(...)`. Also, the `mAllowTransformationLengthChange` is set to false when 'method' is not an instance of TransformationMethod2. Changes are related with control flow and other statements, so the code change type is 3,4.","Despite these changes, they do not affect the control flow in a way that the method would return a different value or throw an exception under the possible conditions allowed by the earlier version. Therefore, there will not be a Compatibility Issue regarding return values or exception handlings, and the CI type is 0."
519,"<android.database.CursorWindow: boolean isString(int,int)>",13,14,,,,"{
    int type = getType(row, col);
    return type == Cursor.FIELD_TYPE_STRING || type == Cursor.FIELD_TYPE_NULL;
}","{
    int type = getType(row, column);
    return type == Cursor.FIELD_TYPE_STRING || type == Cursor.FIELD_TYPE_NULL;
}",1,"/**
 * Checks if a field contains either a String or is null.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return {@code true} if given field is {@code NULL} or a String
 * @deprecated use {@link #getType(int, int)} instead
 */
","/**
 * Returns true if the field at the specified row and column index
 * has type {@link Cursor#FIELD_TYPE_STRING} or {@link Cursor#FIELD_TYPE_NULL}.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if the field has type {@link Cursor#FIELD_TYPE_STRING}
 * or {@link Cursor#FIELD_TYPE_NULL}.
 * @deprecated Use {@link #getType(int, int)} instead.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,"There is only a variable name change from 'col' to 'column', which does not affect the behavior of the method since it's internal to the method and the operational logic remains the same. Therefore, there is no code change that affects the functionality.",No Compatibility Issue detected as there is no change in the behavior of the method.
521,"<android.text.TextUtils: int indexOf(CharSequence,char,int)>",13,14,,,,"{
    Class c = s.getClass();
    if (c == String.class)
        return ((String) s).indexOf(ch, start);
    return indexOf(s, ch, start, s.length());
}","{
    Class<? extends CharSequence> c = s.getClass();
    if (c == String.class)
        return ((String) s).indexOf(ch, start);
    return indexOf(s, ch, start, s.length());
}",1,,,0,,,0,,,,,,,4,0,"The change is in the type of the local variable `c` from `Class` to `Class<? extends CharSequence>`, so the change type is 4.","This is a change to the type of local variable `c`, but it does not affect the return values or the exception handling of the method. Therefore, there is no compatibility issue, and the CI type is 0."
522,"<android.view.View: boolean startDrag(ClipData,DragShadowBuilder,Object,int)>",13,14,,,,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDrag: data="" + data + "" flags="" + flags);
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    Surface surface = new Surface();
    try {
        IBinder token = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, surface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + token + "" surface="" + surface);
        if (token != null) {
            Canvas canvas = surface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                surface.unlockCanvasAndPost(canvas);
            }
            final ViewRoot root = getViewRoot();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, token, shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        surface.destroy();
    }
    return okay;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""startDrag: data="" + data + "" flags="" + flags);
    }
    boolean okay = false;
    Point shadowSize = new Point();
    Point shadowTouchPoint = new Point();
    shadowBuilder.onProvideShadowMetrics(shadowSize, shadowTouchPoint);
    if ((shadowSize.x < 0) || (shadowSize.y < 0) || (shadowTouchPoint.x < 0) || (shadowTouchPoint.y < 0)) {
        throw new IllegalStateException(""Drag shadow dimensions must not be negative"");
    }
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(VIEW_LOG_TAG, ""drag shadow: width="" + shadowSize.x + "" height="" + shadowSize.y + "" shadowX="" + shadowTouchPoint.x + "" shadowY="" + shadowTouchPoint.y);
    }
    Surface surface = new Surface();
    try {
        IBinder token = mAttachInfo.mSession.prepareDrag(mAttachInfo.mWindow, flags, shadowSize.x, shadowSize.y, surface);
        if (ViewDebug.DEBUG_DRAG)
            Log.d(VIEW_LOG_TAG, ""prepareDrag returned token="" + token + "" surface="" + surface);
        if (token != null) {
            Canvas canvas = surface.lockCanvas(null);
            try {
                canvas.drawColor(0, PorterDuff.Mode.CLEAR);
                shadowBuilder.onDrawShadow(canvas);
            } finally {
                surface.unlockCanvasAndPost(canvas);
            }
            final ViewRootImpl root = getViewRootImpl();
            // Cache the local state object for delivery with DragEvents
            root.setLocalDragState(myLocalState);
            // repurpose 'shadowSize' for the last touch point
            root.getLastTouchPoint(shadowSize);
            okay = mAttachInfo.mSession.performDrag(mAttachInfo.mWindow, token, shadowSize.x, shadowSize.y, shadowTouchPoint.x, shadowTouchPoint.y, data);
            if (ViewDebug.DEBUG_DRAG)
                Log.d(VIEW_LOG_TAG, ""performDrag returned "" + okay);
            // Off and running!  Release our local surface instance; the drag
            // shadow surface is now managed by the system process.
            surface.release();
        }
    } catch (Exception e) {
        Log.e(VIEW_LOG_TAG, ""Unable to initiate drag"", e);
        surface.destroy();
    }
    return okay;
}",1,"/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke startDrag() on any attached View object. The View object does not
 * need to be the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to
 * be related to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. This Object is put into every DragEvent object sent by the system during the
 * current drag.
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. No flags are currently defined,
 * so the parameter should be set to 0.
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
","/**
 * Starts a drag and drop operation. When your application calls this method, it passes a
 * {@link android.view.View.DragShadowBuilder} object to the system. The
 * system calls this object's {@link DragShadowBuilder#onProvideShadowMetrics(Point, Point)}
 * to get metrics for the drag shadow, and then calls the object's
 * {@link DragShadowBuilder#onDrawShadow(Canvas)} to draw the drag shadow itself.
 * <p>
 * Once the system has the drag shadow, it begins the drag and drop operation by sending
 * drag events to all the View objects in your application that are currently visible. It does
 * this either by calling the View object's drag listener (an implementation of
 * {@link android.view.View.OnDragListener#onDrag(View,DragEvent) onDrag()} or by calling the
 * View object's {@link android.view.View#onDragEvent(DragEvent) onDragEvent()} method.
 * Both are passed a {@link android.view.DragEvent} object that has a
 * {@link android.view.DragEvent#getAction()} value of
 * {@link android.view.DragEvent#ACTION_DRAG_STARTED}.
 * </p>
 * <p>
 * Your application can invoke startDrag() on any attached View object. The View object does not
 * need to be the one used in {@link android.view.View.DragShadowBuilder}, nor does it need to
 * be related to the View the user selected for dragging.
 * </p>
 * @param data A {@link android.content.ClipData} object pointing to the data to be
 * transferred by the drag and drop operation.
 * @param shadowBuilder A {@link android.view.View.DragShadowBuilder} object for building the
 * drag shadow.
 * @param myLocalState An {@link java.lang.Object} containing local data about the drag and
 * drop operation. This Object is put into every DragEvent object sent by the system during the
 * current drag.
 * <p>
 * myLocalState is a lightweight mechanism for the sending information from the dragged View
 * to the target Views. For example, it can contain flags that differentiate between a
 * a copy operation and a move operation.
 * </p>
 * @param flags Flags that control the drag and drop operation. No flags are currently defined,
 * so the parameter should be set to 0.
 * @return {@code true} if the method completes successfully, or
 * {@code false} if it fails anywhere. Returning {@code false} means the system was unable to
 * do a drag, and so no drag operation is in progress.
 */
",0,,,0,,,,,,,"3,4",0,The code change includes calling a different method (getViewRootImpl() instead of getViewRoot()) and adding a new line of code (surface.release()) under the conditional block. ,There is no Compatibility Issue because the newly added method call (getViewRootImpl) does not change the API's behavior concerning what it returns or what exceptions it throws. The additional line of code (surface.release()) also does not lead to a Compatibility Issue since it's related to releasing a resource that the system is handling after initiating drag and does not affect the return value or exceptions thrown by the method.
529,<android.webkit.WebSettings: TextSize getTextSize()>,13,14,,,,"{
    return mTextSize;
}","{
    TextSize closestSize = null;
    int smallestDelta = Integer.MAX_VALUE;
    for (TextSize size : TextSize.values()) {
        int delta = Math.abs(mTextSize - size.value);
        if (delta == 0) {
            return size;
        }
        if (delta < smallestDelta) {
            smallestDelta = delta;
            closestSize = size;
        }
    }
    return closestSize != null ? closestSize : TextSize.NORMAL;
}",1,"/**
 * Get the text size of the page.
 * @return A TextSize enum value describing the text size.
 * @see WebSettings.TextSize
 */
","/**
 * Get the text size of the page. If the text size was previously specified
 * in percent using {@link #setTextZoom(int)}, this will return
 * the closest matching {@link TextSize}.
 * @return A TextSize enum value describing the text size.
 * @see WebSettings.TextSize
 * @deprecated Use {@link #getTextZoom()} instead
 */
",1,,,0,,,,,,,"1,4",1,"The return statement has been significantly changed. The early version directly returns the value of the member variable mTextSize, while the late version involves a more complex logic to find and return the closest TextSize enum constant that matches the mTextSize value. A new variable declaration, a loop with conditional checks, and updated return logic are present, which qualifies it as other statement changes as well, so the change types are 1 and 4.","The return type in terms of enum constants of TextSize might differ between the two versions due to the introduction of a new algorithm to determine the closest matching TextSize. In the late version, it is possible to get a different TextSize value than what would be returned directly from mTextSize in the early version, and this change will lead to different behavior when the API is called. Therefore, the CI type is 1."
530,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: int getViewTypeCount()>,13,14,,,,"{
    return mFactory.getViewTypeCount();
}","{
    int count = 0;
    try {
        count = mFactory.getViewTypeCount();
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return count;
}",1,,,0,,,0,,,,,,,"2,3,4",2,"An exception handling block and a local variable initialization (int count = 0;) have been introduced and the return statement is modified to return the local variable instead of directly invoking the method. So, the change type is categorized under 2,3,4.","The introduction of an exception handling block with the usage of Thread's default uncaught exception handler changes how exceptions are processed. Previously, any exception would propagate out of the method, but in the late version, the exception is caught and passed to the uncaught exception handler while providing a default return value (0). This alteration can cause the API to handle exceptions differently and could potentially affect the return value if an exception occurs. Therefore, the CI type is 2."
533,"<android.widget.TextView: boolean onKeyUp(int,KeyEvent)>",13,14,,,,"{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            mDPadCenterIsDown = false;
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (mOnClickListener == null) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        if (imm != null)
                            imm.showSoftInput(this, 0);
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            mEnterKeyIsDown = false;
            if (event.hasNoModifiers()) {
                if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                    mInputContentType.enterDown = false;
                    if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (mOnClickListener == null) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}","{
    if (!isEnabled()) {
        return super.onKeyUp(keyCode, event);
    }
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
            mDPadCenterIsDown = false;
            if (event.hasNoModifiers()) {
                /*
                     * If there is a click listener, just call through to
                     * super, which will invoke it.
                     *
                     * If there isn't a click listener, try to show the soft
                     * input method.  (It will also
                     * call performClick(), but that won't do anything in
                     * this case.)
                     */
                if (mOnClickListener == null) {
                    if (mMovement != null && mText instanceof Editable && mLayout != null && onCheckIsTextEditor()) {
                        InputMethodManager imm = InputMethodManager.peekInstance();
                        viewClicked(imm);
                        if (imm != null) {
                            imm.showSoftInput(this, 0);
                        }
                    }
                }
            }
            return super.onKeyUp(keyCode, event);
        case KeyEvent.KEYCODE_ENTER:
            mEnterKeyIsDown = false;
            if (event.hasNoModifiers()) {
                if (mInputContentType != null && mInputContentType.onEditorActionListener != null && mInputContentType.enterDown) {
                    mInputContentType.enterDown = false;
                    if (mInputContentType.onEditorActionListener.onEditorAction(this, EditorInfo.IME_NULL, event)) {
                        return true;
                    }
                }
                if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 || shouldAdvanceFocusOnEnter()) {
                    /*
                         * If there is a click listener, just call through to
                         * super, which will invoke it.
                         *
                         * If there isn't a click listener, try to advance focus,
                         * but still call through to super, which will reset the
                         * pressed state and longpress state.  (It will also
                         * call performClick(), but that won't do anything in
                         * this case.)
                         */
                    if (mOnClickListener == null) {
                        View v = focusSearch(FOCUS_DOWN);
                        if (v != null) {
                            if (!v.requestFocus(FOCUS_DOWN)) {
                                throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                            }
                            /*
                                 * Return true because we handled the key; super
                                 * will return false because there was no click
                                 * listener.
                                 */
                            super.onKeyUp(keyCode, event);
                            return true;
                        } else if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0) {
                            // No target for next focus, but make sure the IME
                            // if this came from it.
                            InputMethodManager imm = InputMethodManager.peekInstance();
                            if (imm != null && imm.isActive(this)) {
                                imm.hideSoftInputFromWindow(getWindowToken(), 0);
                            }
                        }
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            break;
    }
    if (mInput != null)
        if (mInput.onKeyUp(this, (Editable) mText, keyCode, event))
            return true;
    if (mMovement != null && mLayout != null)
        if (mMovement.onKeyUp(this, (Spannable) mText, keyCode, event))
            return true;
    return super.onKeyUp(keyCode, event);
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
535,<android.view.ViewGroup: boolean dispatchKeyEvent(KeyEvent)>,13,14,,,,"{
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        return super.dispatchKeyEvent(event);
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        return mFocused.dispatchKeyEvent(event);
    }
    return false;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 1);
    }
    if ((mPrivateFlags & (FOCUSED | HAS_BOUNDS)) == (FOCUSED | HAS_BOUNDS)) {
        if (super.dispatchKeyEvent(event)) {
            return true;
        }
    } else if (mFocused != null && (mFocused.mPrivateFlags & HAS_BOUNDS) == HAS_BOUNDS) {
        if (mFocused.dispatchKeyEvent(event)) {
            return true;
        }
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);
    }
    return false;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,"3,4",0,"The conditional checks now contain an additional upper block that utilizes `mInputEventConsistencyVerifier`, and the return statements inside the control flow blocks have transformed from immediate returns to conditions followed by returns if true, so the code change type is both 3 and 4 due to a control dependency change and an other statement (addition of a new code block and modification of returns).","Despite the addition of the consistency verification and the transformation of immediate returns to conditional checks, these changes should not lead to a change in how the method behaves from an external point of view: it still processes key events in the same way and returns the same boolean value as before. Thus, there should be no Compatibility Issue (CI type 0)."
536,<android.ddm.DdmHandleHeap: Chunk handleChunk(Chunk)>,13,14,,,,"{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_HPDS) {
        return handleHPDS(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_HPDS) {
        return handleHPDS(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",0,,,0,,,,,,,4,0,"The only change in the code is the condition in the logging statement: `Config.LOGV` has been changed to `false`. This is an other statement change involving non-functional, debug logging code and has no impact on the method's behavior. Hence, the code change type is 4.","There is no compatibility issue since this change is not related to the functional behavior of the API; it only affects a logging statement that won't execute due to the condition being `false` and therefore, it doesn't affect the output of the method or its execution path for API consumers."
537,<android.view.View: boolean removeCallbacks(Runnable)>,13,14,,,,"{
    Handler handler;
    if (mAttachInfo != null) {
        handler = mAttachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRoot.getRunQueue().removeCallbacks(action);
        return true;
    }
    handler.removeCallbacks(action);
    return true;
}","{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().removeCallbacks(action);
        return true;
    }
    handler.removeCallbacks(action);
    return true;
}",1,"/**
 * Removes the specified Runnable from the message queue.
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 */
","/**
 * <p>Removes the specified Runnable from the message queue.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable to remove from the message handling queue
 *
 * @return true if this view could ask the Handler to remove the Runnable,
 * false otherwise. When the returned value is true, the Runnable
 * may or may not have been actually removed from the message queue
 * (for instance, if the Runnable was not in the queue already.)
 */
",1,,,0,,,,,,,"4,5",1,The code change consists of the replacement of `ViewRoot.getRunQueue()` with `ViewRootImpl.getRunQueue()` and the addition of a new local variable `attachInfo`. This results in type 4 (other statement changed) and type 5 (dependent API changed) because the method call ViewRoot.getRunQueue() has been replaced with ViewRootImpl.getRunQueue().,"By changing the method call from `ViewRoot.getRunQueue()` to `ViewRootImpl.getRunQueue()`, there is a potential difference in behavior if the `getRunQueue()` method in `ViewRootImpl` behaves differently than the one in `ViewRoot`, which could lead to different return values. Therefore, the CI type is 1."
538,"<android.view.GLES20Canvas: int saveLayer(RectF,Paint,int)>",13,14,,,,"{
    return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
}","{
    if (bounds != null) {
        return saveLayer(bounds.left, bounds.top, bounds.right, bounds.bottom, paint, saveFlags);
    }
    int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
    final int nativePaint = paint == null ? 0 : paint.mNativePaint;
    int count = nSaveLayer(mRenderer, nativePaint, saveFlags);
    if (modifier != MODIFIER_NONE)
        nResetModifiers(mRenderer, modifier);
    return count;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The late version added a conditional check for `bounds` and introduced new logic to handle cases when `bounds` is null. This includes setting up a color filter if `paint` is not null, obtaining a modifier, and new calls like `nSaveLayer` and `nResetModifiers`. Therefore, changes are both in return statement and control dependency type, which are 1,3.","The introduction of a new condition (`if (bounds != null)`) results in a different execution path when `bounds` is null, which was not accounted for in the early version. Additionally, the `return` statements are now dependent on the new control path, which can lead to a different return value. Therefore, the CI type is 1."
541,<android.view.View: boolean dispatchGenericMotionEvent(MotionEvent)>,13,14,,,,"{
    // noinspection SimplifiableIfStatement
    if (mOnGenericMotionListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnGenericMotionListener.onGenericMotion(this, event)) {
        return true;
    }
    return onGenericMotionEvent(event);
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onGenericMotionEvent(event, 0);
    }
    final int source = event.getSource();
    if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
        final int action = event.getAction();
        if (action == MotionEvent.ACTION_HOVER_ENTER || action == MotionEvent.ACTION_HOVER_MOVE || action == MotionEvent.ACTION_HOVER_EXIT) {
            if (dispatchHoverEvent(event)) {
                return true;
            }
        } else if (dispatchGenericPointerEvent(event)) {
            return true;
        }
    } else if (dispatchGenericFocusedEvent(event)) {
        return true;
    }
    if (dispatchGenericMotionEventInternal(event)) {
        return true;
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}",1,"/**
 * Dispatch a generic motion event.
 * <p>
 * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
 * are delivered to the view under the pointer.  All other generic motion events are
 * delivered to the focused view.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Dispatch a generic motion event.
 * <p>
 * Generic motion events with source class {@link InputDevice#SOURCE_CLASS_POINTER}
 * are delivered to the view under the pointer.  All other generic motion events are
 * delivered to the focused view.  Hover events are handled specially and are delivered
 * to {@link #onHoverEvent(MotionEvent)}.
 * </p>
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",1,,,0,,,,,,,"1,3,4",1,"The implementation has significant changes with new control structures and other statements. A new verification step is added at the beginning, the logic for determining whether to dispatch hover events or generic pointer events is updated, and an internal generic motion event dispatch method is called before falling back to false. Hence, the code change type is 1,3,4.","The late version introduces several new return points which depend on multiple conditions that were not present in the early version. This results in a potential change in the return value of the method, so the CI type is 1."
542,<android.bluetooth.BluetoothDeviceProfileState.BondedDevice: boolean processMessage(Message)>,13,14,,,,"{
    log(""ACL Connected State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case DISCONNECT_HFP_OUTGOING:
            transitionTo(mOutgoingHandsfree);
            break;
        case CONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case DISCONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
            transitionTo(mOutgoingA2dp);
            break;
        case CONNECT_A2DP_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            transitionTo(mIncomingA2dp);
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            transitionTo(mOutgoingHid);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            transitionTo(mIncomingHid);
            break;
        case DISCONNECT_PBAP_OUTGOING:
            processCommand(DISCONNECT_PBAP_OUTGOING);
            break;
        case UNPAIR:
            if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HFP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_A2DP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mService.getInputDeviceConnectionState(mDevice) != BluetoothInputDevice.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HID_OUTGOING);
                deferMessage(message);
                break;
            }
            processCommand(UNPAIR);
            break;
        case AUTO_CONNECT_PROFILES:
            if (isPhoneDocked(mDevice)) {
                // Don't auto connect to docks.
                break;
            } else {
                if (mHeadsetService != null && mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT && mHeadsetService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mHeadsetService.connect(mDevice);
                }
                if (mA2dpService != null && mA2dpService.getPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT && mA2dpService.getDevicesMatchingConnectionStates(new int[] { BluetoothA2dp.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mA2dpService.connect(mDevice);
                }
                if (mService.getInputDevicePriority(mDevice) == BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
                    mService.connectInputDevice(mDevice);
                }
            }
            break;
        case CONNECT_OTHER_PROFILES:
            if (isPhoneDocked(mDevice)) {
                break;
            }
            if (message.arg1 == CONNECT_A2DP_OUTGOING) {
                if (mA2dpService != null && mA2dpService.getConnectedDevices().size() == 0) {
                    Log.i(TAG, ""A2dp:Connect Other Profiles"");
                    mA2dpService.connect(mDevice);
                }
            } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
                if (mHeadsetService == null) {
                    deferMessage(message);
                } else {
                    if (mHeadsetService.getConnectedDevices().size() == 0) {
                        Log.i(TAG, ""Headset:Connect Other Profiles"");
                        mHeadsetService.connect(mDevice);
                    }
                }
            }
            break;
        case TRANSITION_TO_STABLE:
            // ignore.
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    log(""ACL Connected State -> Processing Message: "" + message.what);
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case DISCONNECT_HFP_OUTGOING:
            transitionTo(mOutgoingHandsfree);
            break;
        case CONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case DISCONNECT_HFP_INCOMING:
            transitionTo(mIncomingHandsfree);
            break;
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
            transitionTo(mOutgoingA2dp);
            break;
        case CONNECT_A2DP_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            transitionTo(mIncomingA2dp);
            break;
        case CONNECT_HID_OUTGOING:
        case DISCONNECT_HID_OUTGOING:
            transitionTo(mOutgoingHid);
            break;
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_INCOMING:
            transitionTo(mIncomingHid);
            break;
        case DISCONNECT_PBAP_OUTGOING:
            processCommand(DISCONNECT_PBAP_OUTGOING);
            break;
        case UNPAIR:
            if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HFP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_A2DP_OUTGOING);
                deferMessage(message);
                break;
            } else if (mService.getInputDeviceConnectionState(mDevice) != BluetoothInputDevice.STATE_DISCONNECTED) {
                sendMessage(DISCONNECT_HID_OUTGOING);
                deferMessage(message);
                break;
            }
            processCommand(UNPAIR);
            break;
        case AUTO_CONNECT_PROFILES:
            if (isPhoneDocked(mDevice)) {
                // Don't auto connect to docks.
                break;
            } else {
                if (mHeadsetService == null) {
                    mAutoConnectionPending = true;
                } else if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT && mHeadsetService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mHeadsetService.connect(mDevice);
                }
                if (mA2dpService != null && mA2dpService.getPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT && mA2dpService.getDevicesMatchingConnectionStates(new int[] { BluetoothA2dp.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING }).size() == 0) {
                    mA2dpService.connect(mDevice);
                }
                if (mService.getInputDevicePriority(mDevice) == BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
                    mService.connectInputDevice(mDevice);
                }
            }
            break;
        case CONNECT_OTHER_PROFILES:
            if (isPhoneDocked(mDevice)) {
                break;
            }
            if (message.arg1 == CONNECT_A2DP_OUTGOING) {
                if (mA2dpService != null && mA2dpService.getConnectedDevices().size() == 0) {
                    Log.i(TAG, ""A2dp:Connect Other Profiles"");
                    mA2dpService.connect(mDevice);
                }
            } else if (message.arg1 == CONNECT_HFP_OUTGOING) {
                if (mHeadsetService == null) {
                    deferMessage(message);
                } else {
                    if (mHeadsetService.getConnectedDevices().size() == 0) {
                        Log.i(TAG, ""Headset:Connect Other Profiles"");
                        mHeadsetService.connect(mDevice);
                    }
                }
            }
            break;
        case TRANSITION_TO_STABLE:
            // ignore.
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
543,<android.server.search.Searchables: ComponentName getGlobalSearchActivity()>,13,14,,,,"{
    return mGlobalSearchActivity;
}","{
    return mCurrentGlobalSearchActivity;
}",1,"/**
 * Gets the name of the global search activity.
 */
","/**
 * Gets the name of the global search activity.
 */
",0,,,0,,,,,,,4,1,"The variable returned has changed from mGlobalSearchActivity to mCurrentGlobalSearchActivity, but this is not a return type change but rather a change in the identity of the variable returned. Hence, the code change type is 4.","The variable name has changed which means a different value could be returned (even though the type remains the same). Therefore, the API has the potential to return a different value, and the CI type is 1."
544,<android.widget.TextView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    final int action = event.getActionMasked();
    if (hasInsertionController()) {
        getInsertionController().onTouchEvent(event);
    }
    if (hasSelectionController()) {
        getSelectionController().onTouchEvent(event);
    }
    if (action == MotionEvent.ACTION_DOWN) {
        mLastDownPositionX = (int) event.getX();
        mLastDownPositionY = (int) event.getY();
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mIgnoreActionUpEvent = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = action == MotionEvent.ACTION_UP && !mIgnoreActionUpEvent && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        final int oldScrollX = mScrollX;
        final int oldScrollY = mScrollY;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (mLinksClickable && mAutoLinkMask != 0 && mTextIsSelectable && touchIsFinished) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // to support text selection. We reproduce its behavior here to open links.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length != 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (isTextEditable() || mTextIsSelectable) {
            if (mScrollX != oldScrollX || mScrollY != oldScrollY) {
                // TODO remove
                // Hide insertion anchor while scrolling. Leave selection.
                // TODO any motion should hide it
                hideInsertionPointCursorController();
            }
            if (touchIsFinished) {
                // Show the IME, except when selecting in read-only text.
                if (!mTextIsSelectable) {
                    final InputMethodManager imm = InputMethodManager.peekInstance();
                    handled |= imm != null && imm.showSoftInput(this, 0);
                }
                boolean selectAllGotFocus = mSelectAllOnFocus && didTouchFocusSelect();
                if (!selectAllGotFocus && hasSelection()) {
                    startSelectionActionMode();
                } else {
                    stopSelectionActionMode();
                    if (hasInsertionController() && !selectAllGotFocus && mText.length() > 0) {
                        getInsertionController().show();
                    }
                }
            }
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}","{
    final int action = event.getActionMasked();
    if (hasSelectionController()) {
        getSelectionController().onTouchEvent(event);
    }
    if (action == MotionEvent.ACTION_DOWN) {
        mLastDownPositionX = event.getX();
        mLastDownPositionY = event.getY();
        // Reset this state; it will be re-set if super.onTouchEvent
        // causes focus to move to the view.
        mTouchFocusSelected = false;
        mIgnoreActionUpEvent = false;
    }
    final boolean superResult = super.onTouchEvent(event);
    /*
         * Don't handle the release after a long press, because it will
         * move the selection away from whatever the menu action was
         * trying to affect.
         */
    if (mDiscardNextActionUp && action == MotionEvent.ACTION_UP) {
        mDiscardNextActionUp = false;
        return superResult;
    }
    final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) && !shouldIgnoreActionUpEvent() && isFocused();
    if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null) {
        boolean handled = false;
        if (mMovement != null) {
            handled |= mMovement.onTouchEvent(this, (Spannable) mText, event);
        }
        if (touchIsFinished && mLinksClickable && mAutoLinkMask != 0 && mTextIsSelectable) {
            // The LinkMovementMethod which should handle taps on links has not been installed
            // on non editable text that support text selection.
            // We reproduce its behavior here to open links for these.
            ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class);
            if (links.length != 0) {
                links[0].onClick(this);
                handled = true;
            }
        }
        if (touchIsFinished && (isTextEditable() || mTextIsSelectable)) {
            // Show the IME, except when selecting in read-only text.
            final InputMethodManager imm = InputMethodManager.peekInstance();
            viewClicked(imm);
            if (!mTextIsSelectable) {
                handled |= imm != null && imm.showSoftInput(this, 0);
            }
            boolean selectAllGotFocus = mSelectAllOnFocus && didTouchFocusSelect();
            hideControllers();
            if (!selectAllGotFocus && mText.length() > 0) {
                if (mSpellChecker != null) {
                    // When the cursor moves, the word that was typed may need spell check
                    mSpellChecker.onSelectionChanged();
                }
                if (isCursorInsideEasyCorrectionSpan()) {
                    showSuggestions();
                } else if (hasInsertionController()) {
                    getInsertionController().show();
                }
            }
            handled = true;
        }
        if (handled) {
            return true;
        }
    }
    return superResult;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
545,"<android.app.PendingIntent: PendingIntent getActivities(Context,int,Intent[],int)>",13,14,,,,"{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String[] resolvedTypes = new String[intents.length];
    for (int i = 0; i < intents.length; i++) {
        intents[i].setAllowFds(false);
        resolvedTypes[i] = intents[i].resolveTypeIfNeeded(context.getContentResolver());
    }
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, intents, resolvedTypes, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Like {@link #getActivity(Context, int, Intent, int)}, but allows an
 * array of Intents to be supplied.  The first Intent in the array is
 * taken as the primary key for the PendingIntent, like the single Intent
 * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending
 * the resulting PendingIntent, all of the Intents are started in the same
 * way as they would be by passing them to {@link Context#startActivities(Intent[])}.
 *
 * <p class=""note"">
 * The <em>first</em> intent in the array will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after
 * the first in the array are started in the context of the previous activity
 * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)
 * </p>
 *
 * <p class=""note"">
 * The <em>last</em> intent in the array represents the key for the
 * PendingIntent.  In other words, it is the significant element for matching
 * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},
 * its content will be the subject of replacement by
 * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.
 * This is because it is the most specific of the supplied intents, and the
 * UI the user actually sees when the intents are started.
 * </p>
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intents Array of Intents of the activities to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",0,,,0,,,,,,,4,0,"The new statement `intents[i].setAllowFds(false);` is introduced within the loop, which is an additional operation on each `Intent` object in the array 'intents'. Thus the code change type is 4.","The change prevents file descriptors from being included in the returned `Intent` objects by calling `setAllowFds(false)`. However, this does not alter the overall behavior of how the `PendingIntent` is created and does not affect the return type or value of `getActivities()`, nor does it change exception handling. Therefore, there is no compatibility issue, and the CI type is 0."
546,"<android.database.CursorWindow: boolean isFloat(int,int)>",13,14,,,,"{
    return getType(row, col) == Cursor.FIELD_TYPE_FLOAT;
}","{
    return getType(row, column) == Cursor.FIELD_TYPE_FLOAT;
}",1,"/**
 * Checks if a field contains a float.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return {@code true} if given field is a float
 * @deprecated use {@link #getType(int, int)} instead
 */
","/**
 * Returns true if the field at the specified row and column index
 * has type {@link Cursor#FIELD_TYPE_FLOAT}.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if the field has type {@link Cursor#FIELD_TYPE_FLOAT}.
 * @deprecated Use {@link #getType(int, int)} instead.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,"The method bodies are identical with only a parameter name being changed from 'col' to 'column' which will not affect the method's behavior since parameter names are not part of a method's signature used at call sites. Therefore, there is no code change affecting the behavior.","Since there is no change in the behavior of the method between versions, there is no Compatibility Issue."
547,<android.widget.TextView: boolean verifyDrawable(Drawable)>,13,14,,,,"{
    final boolean verified = super.verifyDrawable(who);
    if (!verified && mDrawables != null) {
        return who == mDrawables.mDrawableLeft || who == mDrawables.mDrawableTop || who == mDrawables.mDrawableRight || who == mDrawables.mDrawableBottom;
    }
    return verified;
}","{
    final boolean verified = super.verifyDrawable(who);
    if (!verified && mDrawables != null) {
        return who == mDrawables.mDrawableLeft || who == mDrawables.mDrawableTop || who == mDrawables.mDrawableRight || who == mDrawables.mDrawableBottom || who == mDrawables.mDrawableStart || who == mDrawables.mDrawableEnd;
    }
    return verified;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1, 3",1,"The return statement has been expanded with additional conditions (who == mDrawables.mDrawableStart || who == mDrawables.mDrawableEnd), and since this is part of an 'if' condition this also involves a control dependency change. Therefore, the code change types are 1, 3.","Because the return statement added new conditions, this may cause the late version of the API to potentially return a different boolean value than the early version under some circumstances (specifically, when 'who' is either mDrawableStart or mDrawableEnd). Therefore, the CI type is 1."
549,<android.nfc.NfcAdapter: void disableForegroundNdefPush(Activity)>,13,14,,,,"{
    ActivityThread.currentActivityThread().unregisterOnActivityPausedListener(activity, mForegroundNdefPushListener);
    disableForegroundNdefPushInternal(activity, false);
}","{
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}",1,"/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @throws OperationNotSupportedException if this Android device does not support NDEF push
 */
","/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",1,,,0,,,,,,,"1,3,4","1,2","The internal implementation has significantly changed. A new null check is introduced, different methods are called, and the previous methods called are not present. The change types are 1,3 for the control flow changes (introduction of null check and removal of the unregister call), and 4 for the changes in what methods are called with different parameters.","There is a possibility for a Compatibility Issue caused by different return values since the method's internal behavior has changed, which can lead to different outcomes. Additionally, an exception handling statement has been introduced with the potential to throw a new exception if the 'activity' is null which could not have been thrown in the early version (even though 'NullPointerException' could be an unchecked exception, its explicit addition in the code path is considered a change in the exception handling behavior), hence CI types are both 1 and 2."
554,"<android.view.GLES20Canvas: int saveLayer(float,float,float,float,Paint,int)>",13,14,,,,"{
    if (left < right && top < bottom) {
        boolean hasColorFilter = paint != null && setupColorFilter(paint);
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int count = nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
        if (hasColorFilter)
            nResetModifiers(mRenderer);
        return count;
    }
    return save(saveFlags);
}","{
    if (left < right && top < bottom) {
        int modifier = paint != null ? setupColorFilter(paint) : MODIFIER_NONE;
        final int nativePaint = paint == null ? 0 : paint.mNativePaint;
        int count = nSaveLayer(mRenderer, left, top, right, bottom, nativePaint, saveFlags);
        if (modifier != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifier);
        return count;
    }
    return save(saveFlags);
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The changes include modifying the assignment of the variable `hasColorFilter` to `modifier` with different initial values and changing the conditional check from `hasColorFilter` to `modifier != MODIFIER_NONE`. Additionally, the method call for `nResetModifiers` now includes the `modifier` argument. These changes correspond to code change types 3 and 4.","Despite the modifications in variable assignments and method argument changes within the control flow, the behavior of the API has not altered in terms of the value it returns or the exceptions it may throw. There is no new return statement introduced nor deleted, and there is no new exception handling introduced nor deleted. Therefore, there is no Compatibility Issue, so the CI type is 0."
555,"<android.preference.PreferenceActivity: void showBreadCrumbs(CharSequence,CharSequence)>",13,14,,,,"{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        if (crumbs != null && !(crumbs instanceof FragmentBreadCrumbs))
            return;
        mFragmentBreadCrumbs = (FragmentBreadCrumbs) findViewById(android.R.id.title);
        if (mFragmentBreadCrumbs == null) {
            mFragmentBreadCrumbs = new FragmentBreadCrumbs(this);
            ActionBar actionBar = getActionBar();
            if (actionBar != null) {
                actionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM, ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_CUSTOM);
                actionBar.setCustomView(mFragmentBreadCrumbs);
            }
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    mFragmentBreadCrumbs.setTitle(title, shortTitle);
    mFragmentBreadCrumbs.setParentTitle(null, null, null);
}","{
    if (mFragmentBreadCrumbs == null) {
        View crumbs = findViewById(android.R.id.title);
        // For screens with a different kind of title, don't create breadcrumbs.
        try {
            mFragmentBreadCrumbs = (FragmentBreadCrumbs) crumbs;
        } catch (ClassCastException e) {
            return;
        }
        if (mFragmentBreadCrumbs == null) {
            if (title != null) {
                setTitle(title);
            }
            return;
        }
        mFragmentBreadCrumbs.setMaxVisible(2);
        mFragmentBreadCrumbs.setActivity(this);
    }
    mFragmentBreadCrumbs.setTitle(title, shortTitle);
    mFragmentBreadCrumbs.setParentTitle(null, null, null);
}",1,"/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
","/**
 * Change the base title of the bread crumbs for the current preferences.
 * This will normally be called for you.  See
 * {@link android.app.FragmentBreadCrumbs} for more information.
 */
",0,,,0,,,,,,,"1,2,3,4","1,2","The early version contains a cast without a try-catch block, an explicit conditional check against an instanceof comparison, a fallback to create a new FragmentBreadCrumbs instance if no view is found, and additional logic to set up the action bar. The late version introduces a try-catch block for the ClassCastException, removes the instanceof check and the condition that checks for crumbs not being null, modifies the creation logic of FragmentBreadCrumbs to only set the title if it's not null, and drops the action bar setup logic. The change encompasses return statement changes, exception handling statement changes, control dependency changes, and other statement changes.",The changes can lead to compatibility issues for several reasons: 
556,<android.app.WallpaperManager: void clearWallpaperOffsets(IBinder)>,13,14,,,,"{
    try {
        ViewRoot.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
","/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */
",0,,,0,,,,,,,"4,5",0,"The method that is being called has changed from ViewRoot.getWindowSession() to ViewRootImpl.getWindowSession(). This is an example of the 'Dependent API changed' category. The method call within the try block has been modified, but it does not change the control flow or the exception handling, so the CI is 0.","There is no direct evidence that these changes will result in a compatibility issue as they do not affect the method's return type or the exception handling. The calling of a potentially different method (getWindowSession) does not necessarily equate to a different behavior because signatures and contract of the dependent method might not have changed externally, leading to no compatibility issues."
559,"<android.view.GLES20Canvas: void drawTextRun(char[],int,int,int,int,float,float,int,Paint)>",13,14,,,,"{
    if ((index | count | text.length - index - count) < 0) {
        throw new IndexOutOfBoundsException();
    }
    if (dir != DIRECTION_LTR && dir != DIRECTION_RTL) {
        throw new IllegalArgumentException(""Unknown direction: "" + dir);
    }
    boolean hasModifier = setupModifiers(paint);
    try {
        nDrawTextRun(mRenderer, text, index, count, contextIndex, contextCount, x, y, dir, paint.mNativePaint);
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    if ((index | count | text.length - index - count) < 0) {
        throw new IndexOutOfBoundsException();
    }
    if (dir != DIRECTION_LTR && dir != DIRECTION_RTL) {
        throw new IllegalArgumentException(""Unknown direction: "" + dir);
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawTextRun(mRenderer, text, index, count, contextIndex, contextCount, x, y, dir, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change is in the type of variable 'hasModifier' which has been changed to 'modifiers' and the associated logical condition in 'finally' block. Furthermore, a parameter is added to the 'nResetModifiers()' method call. However, all these changes are internal variable naming and logic that don't affect the public API's signature, return type, thrown exceptions, or control flow dependencies. So, the code change type is 4.","There appears to be no Compatibility Issue, as the changes do not affect the outward behavior of the method. The method signature remains the same, no new exceptions are thrown, and the return value is not modified. Therefore, the type is 0."
561,<android.webkit.WebView: CursorData cursorData()>,13,14,,,,"{
    WebViewCore.CursorData result = new WebViewCore.CursorData();
    result.mMoveGeneration = nativeMoveGeneration();
    result.mFrame = nativeCursorFramePointer();
    Point position = nativeCursorPosition();
    result.mX = position.x;
    result.mY = position.y;
    return result;
}","{
    WebViewCore.CursorData result = cursorDataNoPosition();
    Point position = nativeCursorPosition();
    result.mX = position.x;
    result.mY = position.y;
    return result;
}",1,,,0,,,0,,,,,,,5,0,"The code changed from explicitly creating a new `WebViewCore.CursorData` and setting its fields, to calling `cursorDataNoPosition()` which potentially does the same internally. This change indicates that a dependent API is being used, so the code change type is 5.","Even though there is a change in how the `CursorData` object is instantiated, the late implementation still ensures that the fields `mX` and `mY` are set to the same values from `nativeCursorPosition()` method. Hence, there should be no Compatibility Issue because the same values are being returned by the API. The final result object should contain the same data assuming `cursorDataNoPosition()` correctly initializes the `CursorData` as the earlier implementation. Therefore, it's coded as 0 for no Compatibility Issue."
563,<android.bluetooth.BluetoothSocket: int available()>,13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            throw new IOException(""socket closed"");
        return availableNative();
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return availableNative();
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,4,0,"The condition check for the socket state has changed from `if (mClosed)` to `if (mSocketState == SocketState.CLOSED)`. Since this is a change in the variable used within an 'if' statement which does not affect control flow or introduce new behavior, the code change type is 4.","Despite the change in a state-checking variable, it doesn't lead to a Compatibility Issue. The check remains semantically the same, assuming that `mClosed` was simply refactored to `mSocketState == SocketState.CLOSED`, and it will throw the same exception with the same message when the socket is closed. Therefore, no behaviours will differ because of this code change, thus no Compatibility Issue is detected."
566,"<android.app.FragmentManagerImpl: void restoreAllState(Parcelable,ArrayList<Fragment>)>",13,14,,,,"{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": (null)"");
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throw new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]);
            }
            f.mAdded = true;
            f.mImmediateActivity = mActivity;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: making added #"" + i + "": "" + f);
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding bse #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}","{
    // any nonConfig fragments either, so that is that.
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: re-attaching retained "" + f);
            FragmentState fs = fms.mActive[f.mIndex];
            fs.mInstance = f;
            f.mSavedViewState = null;
            f.mBackStackNesting = 0;
            f.mInLayout = false;
            f.mAdded = false;
            f.mTarget = null;
            if (fs.mSavedFragmentState != null) {
                fs.mSavedFragmentState.setClassLoader(mActivity.getClassLoader());
                f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            }
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive = new ArrayList<Fragment>(fms.mActive.length);
    if (mAvailIndices != null) {
        mAvailIndices.clear();
    }
    for (int i = 0; i < fms.mActive.length; i++) {
        FragmentState fs = fms.mActive[i];
        if (fs != null) {
            Fragment f = fs.instantiate(mActivity);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": "" + f);
            mActive.add(f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        } else {
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding #"" + i + "": (null)"");
            mActive.add(null);
            if (mAvailIndices == null) {
                mAvailIndices = new ArrayList<Integer>();
            }
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding avail #"" + i);
            mAvailIndices.add(i);
        }
    }
    // Update the target of all retained fragments.
    if (nonConfig != null) {
        for (int i = 0; i < nonConfig.size(); i++) {
            Fragment f = nonConfig.get(i);
            if (f.mTargetIndex >= 0) {
                if (f.mTargetIndex < mActive.size()) {
                    f.mTarget = mActive.get(f.mTargetIndex);
                } else {
                    Log.w(TAG, ""Re-attaching retained fragment "" + f + "" target no longer exists: "" + f.mTargetIndex);
                    f.mTarget = null;
                }
            }
        }
    }
    // Build the list of currently added fragments.
    if (fms.mAdded != null) {
        mAdded = new ArrayList<Fragment>(fms.mAdded.length);
        for (int i = 0; i < fms.mAdded.length; i++) {
            Fragment f = mActive.get(fms.mAdded[i]);
            if (f == null) {
                throw new IllegalStateException(""No instantiated fragment for index #"" + fms.mAdded[i]);
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: making added #"" + i + "": "" + f);
            mAdded.add(f);
        }
    } else {
        mAdded = null;
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG)
                Log.v(TAG, ""restoreAllState: adding bse #"" + i + "" (index "" + bse.mIndex + ""): "" + bse);
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
}",1,,,0,,,0,,,,,,,,,,
567,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthTokenLabel(IAccountAuthenticatorResponse,String)>",13,14,,,,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthTokenLabel: authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthTokenLabel: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (IllegalArgumentException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthTokenLabel"", e);
        }
        response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, ""unknown authTokenType"");
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthTokenLabel"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthTokenTypeLabel not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthTokenLabel: authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_AUTH_TOKEN_LABEL, AbstractAccountAuthenticator.this.getAuthTokenLabel(authTokenType));
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthTokenLabel: result "" + AccountManager.sanitizeResult(result));
        }
        response.onResult(result);
    } catch (Exception e) {
        handleException(response, ""getAuthTokenLabel"", authTokenType, e);
    }
}",1,,,0,,,0,,,,,,,"2,3",2,"Exception handling has changed: it catches a generic Exception rather than specific exceptions and the handling of the exception is moved to the handleException method. Furthermore, a control dependency change occurs with the removal of ""if (result != null)"" before calling response.onResult(result), which means that the null-check before sending a result to the response has been removed. This implies a change type of 2,3.","As the previous implementation checked if ""result != null"" before calling response.onResult(result), but the new implementation does not include such a check (which means it will now always call onResult, possibly with a null value), and because the new implementation modifies how exceptions are handled by calling handleException, this could lead to different behavior either in terms of exceptions thrown or the result passed. Therefore, the CI type is 2."
569,<android.app.ContextImpl: void sendBroadcast(Intent)>,13,14,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"An additional method call intent.setAllowFds(false) has been inserted before broadcasting the intent. This represents a change of type 4 (Other statement changed), as it does not affect the return statement, exception handling statement, or control dependencies.","There is no Compatibility Issue detected because the method call intent.setAllowFds(false) is not changing the behavior of how the method sendBroadcast(Intent) operates in terms of changing its returned value or the exceptions it may throw. It merely changes an internal property of the intent object before it is broadcasted, which should not affect existing callers assuming they do not rely on file descriptors being sent with the broadcast."
570,<android.net.ConnectivityManager: boolean getBackgroundDataSetting()>,13,14,,,,"{
    try {
        return mService.getBackgroundDataSetting();
    } catch (RemoteException e) {
        // Err on the side of safety
        return false;
    }
}","{
    // NetworkInfo which may be blocked.
    return true;
}",1,"/**
 * Returns the value of the setting for background data usage. If false,
 * applications should not use the network if the application is not in the
 * foreground. Developers should respect this setting, and check the value
 * of this before performing any background data operations.
 * <p>
 * All applications that have background services that use the network
 * should listen to {@link #ACTION_BACKGROUND_DATA_SETTING_CHANGED}.
 *
 * @return Whether background data usage is allowed.
 */
","/**
 * Returns the value of the setting for background data usage. If false,
 * applications should not use the network if the application is not in the
 * foreground. Developers should respect this setting, and check the value
 * of this before performing any background data operations.
 * <p>
 * All applications that have background services that use the network
 * should listen to {@link #ACTION_BACKGROUND_DATA_SETTING_CHANGED}.
 * <p>
 * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability of
 * background data depends on several combined factors, and this method will
 * always return {@code true}. Instead, when background data is unavailable,
 * {@link #getActiveNetworkInfo()} will now appear disconnected.
 *
 * @return Whether background data usage is allowed.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"The implementation of the method has completely changed. In the early version, the method calls another method and handles a possible exception while in the late version, the method simply returns true. A comment was also added, which falls under 'Other statement changed'. The code changes involve the return statement and other statements, Thus, the change type is 1,4.","The method in the late version always returns true, contrasting with the early version which may return either the result of mService.getBackgroundDataSetting() or false in case of a RemoteException. Because this behavior is entirely different, there is a Compatibility Issue due to a potentially different return value. The CI type is 1."
573,<android.widget.AbsListView: InputConnection onCreateInputConnection(EditorInfo)>,13,14,,,,"{
    if (isTextFilterEnabled()) {
        // XXX we need to have the text filter created, so we can get an
        // InputConnection to proxy to.  Unfortunately this means we pretty
        // much need to make it as soon as a list view gets focus.
        createTextFilter(false);
        if (mPublicInputConnection == null) {
            mDefInputConnection = new BaseInputConnection(this, false);
            mPublicInputConnection = new InputConnectionWrapper(mTextFilter.onCreateInputConnection(outAttrs), true) {

                @Override
                public boolean reportFullscreenMode(boolean enabled) {
                    // the ""real"" one the IME is talking with.
                    return mDefInputConnection.reportFullscreenMode(enabled);
                }

                @Override
                public boolean performEditorAction(int editorAction) {
                    // the one that does this.
                    if (editorAction == EditorInfo.IME_ACTION_DONE) {
                        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                        if (imm != null) {
                            imm.hideSoftInputFromWindow(getWindowToken(), 0);
                        }
                        return true;
                    }
                    return false;
                }

                @Override
                public boolean sendKeyEvent(KeyEvent event) {
                    // no ViewRoot to dispatch events with.
                    return mDefInputConnection.sendKeyEvent(event);
                }
            };
        }
        outAttrs.inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_FILTER;
        outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE;
        return mPublicInputConnection;
    }
    return null;
}","{
    if (isTextFilterEnabled()) {
        // XXX we need to have the text filter created, so we can get an
        // InputConnection to proxy to.  Unfortunately this means we pretty
        // much need to make it as soon as a list view gets focus.
        createTextFilter(false);
        if (mPublicInputConnection == null) {
            mDefInputConnection = new BaseInputConnection(this, false);
            mPublicInputConnection = new InputConnectionWrapper(mTextFilter.onCreateInputConnection(outAttrs), true) {

                @Override
                public boolean reportFullscreenMode(boolean enabled) {
                    // the ""real"" one the IME is talking with.
                    return mDefInputConnection.reportFullscreenMode(enabled);
                }

                @Override
                public boolean performEditorAction(int editorAction) {
                    // the one that does this.
                    if (editorAction == EditorInfo.IME_ACTION_DONE) {
                        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                        if (imm != null) {
                            imm.hideSoftInputFromWindow(getWindowToken(), 0);
                        }
                        return true;
                    }
                    return false;
                }

                @Override
                public boolean sendKeyEvent(KeyEvent event) {
                    // no ViewAncestor to dispatch events with.
                    return mDefInputConnection.sendKeyEvent(event);
                }
            };
        }
        outAttrs.inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_FILTER;
        outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE;
        return mPublicInputConnection;
    }
    return null;
}",1,"/**
 * Return an InputConnection for editing of the filter text.
 */
","/**
 * Return an InputConnection for editing of the filter text.
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"The change occurs in a comment from 'no ViewRoot to dispatch events with' to 'no ViewAncestor to dispatch events with', so the type is 4.","Comments are non-executable segments of code that do not affect the program's operation, so the change in the comment does not introduce any compatibility issues. Thus, the CI type is 0."
574,"<android.text.Layout: float measurePara(TextPaint,TextPaint,CharSequence,int,int)>",13,14,,,,"{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, DIR_REQUEST_LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}","{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,5,0,"The parameter provided to the mt.setPara() method has been changed from DIR_REQUEST_LTR to TextDirectionHeuristics.LTR but no other changes are observed, so the code change type is 5.","There is no change in return value or exceptions being thrown, so the code doesn't seem to manifest any Compatibility Issue, which is type 0. The dependency on the MeasuredText.setPara() method has changed, but since there's no indication of how the behavior of setPara() has changed (if at all), we have to assume it does not cause a compatibility issue based solely on the given data."
579,"<android.animation.PropertyValuesHolder: String getMethodName(String,String)>",13,14,,,,"{
    char firstLetter = propertyName.charAt(0);
    String theRest = propertyName.substring(1);
    firstLetter = Character.toUpperCase(firstLetter);
    return prefix + firstLetter + theRest;
}","{
    if (propertyName == null || propertyName.length() == 0) {
        // shouldn't get here
        return prefix;
    }
    char firstLetter = Character.toUpperCase(propertyName.charAt(0));
    String theRest = propertyName.substring(1);
    return prefix + firstLetter + theRest;
}",1,"/**
 * Utility method to derive a setter/getter method name from a property name, where the
 * prefix is typically ""set"" or ""get"" and the first letter of the property name is
 * capitalized.
 *
 * @param prefix The precursor to the method name, before the property name begins, typically
 * ""set"" or ""get"".
 * @param propertyName The name of the property that represents the bulk of the method name
 * after the prefix. The first letter of this word will be capitalized in the resulting
 * method name.
 * @return String the property name converted to a method name according to the conventions
 * specified above.
 */
","/**
 * Utility method to derive a setter/getter method name from a property name, where the
 * prefix is typically ""set"" or ""get"" and the first letter of the property name is
 * capitalized.
 *
 * @param prefix The precursor to the method name, before the property name begins, typically
 * ""set"" or ""get"".
 * @param propertyName The name of the property that represents the bulk of the method name
 * after the prefix. The first letter of this word will be capitalized in the resulting
 * method name.
 * @return String the property name converted to a method name according to the conventions
 * specified above.
 */
",0,,,0,,,,,,,"1,3,4",0,"The method's control flow has been altered by adding an if-statement to check for a null or empty propertyName and to return the prefix immediately if that condition is met. The firstLetter variable assignment is also merged into a single line with the toUpperCase call. These changes include control dependency (introducing a new check for null or empty) and other statement changes (refactoring how firstLetter is assigned and used), so the code change types are 1, 3, and 4.","Although there is a change in how the method handles a null or empty propertyName and the assignment to firstLetter, these changes do not cause the method to return different results under the conditions that would have executed successfully in the early version. The added check only guards against conditions that should not typically happen ('shouldn't get here'), so it likely does not represent a realistic usage scenario that would affect API consumers. Therefore, there is no Compatibility Issue in terms of different return values or types—assuming the propertyName is valid and not null or empty, the method produces the same result."
580,<android.animation.PropertyValuesHolder: PropertyValuesHolder clone()>,13,14,,,,"{
    try {
        PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
        newPVH.mPropertyName = mPropertyName;
        newPVH.mKeyframeSet = mKeyframeSet.clone();
        newPVH.mEvaluator = mEvaluator;
        return newPVH;
    } catch (CloneNotSupportedException e) {
        // won't reach here
        return null;
    }
}","{
    try {
        PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
        newPVH.mPropertyName = mPropertyName;
        newPVH.mProperty = mProperty;
        newPVH.mKeyframeSet = mKeyframeSet.clone();
        newPVH.mEvaluator = mEvaluator;
        return newPVH;
    } catch (CloneNotSupportedException e) {
        // won't reach here
        return null;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"A new field assignment `newPVH.mProperty = mProperty;` has been added in the try block which is an additional property being cloned from the current object to the new object, so the code change type is 4.","This change does not introduce a compatibility issue because the new line adds the cloning of an internal field that does not affect the outward behavior of the `clone()` method in terms of the object it returns or the exceptions it throws. The cloning of an additional internal field should not affect the API contract, as it is an internal change to ensure a deep copy. This does not affect the return value or observable behaviour from an API consumer's point of view, thus with no compatibility issue."
582,<android.webkit.WebView: SslCertificate getCertificate()>,13,14,,,,"{
    return mCertificate;
}","{
    checkThread();
    return mCertificate;
}",1,"/**
 * @return The SSL certificate for the main top-level page or null if
 * there is no certificate (the site is not secure).
 */
","/**
 * @return The SSL certificate for the main top-level page or null if
 * there is no certificate (the site is not secure).
 */
",0,,,0,,,,,,,4,0,"The late version of the implementation has an additional method call, `checkThread()`, before returning `mCertificate`. Therefore, the code change type is 4 (Other statement changed).","The additional `checkThread()` call doesn't alter the return value or the type of exceptions thrown; it serves as a check to ensure that the current thread is valid for the operation. There is no change that could result in a Compatibility Issue based on the given information, hence the CI type is 0 (No Compatibility Issue)."
585,"<android.database.CursorWindow: boolean putDouble(double,int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return putDouble_native(value, row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativePutDouble(mWindowPtr, value, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Copy double to cursor window
 * @param value
 * @param row
 * @param col
 * @return false if fail to copy
 */
","/**
 * Puts a double-precision floating point value into the field at the
 * specified row and column index.
 *
 * @param value The value to store.
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if successful.
 */
",1,,,0,,,,,,,"1,5",1,"The change involves the method called within the return statement; it was putDouble_native before and is now nativePutDouble, and the parameters passed to the method have also changed order, indicating a dependent API change. Since the method being called and its parameters are different, the return value may be different, so the code change type is 1,5.","Because the method implementation called within the return statement has been altered and the parameters' order has been changed, this could lead to different return values from the API. Therefore, the CI type is 1."
587,<android.speech.tts.TextToSpeech: boolean isSpeaking()>,13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return false;
        }
        try {
            return mITts.isSpeaking();
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isSpeaking"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isSpeaking"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - isSpeaking"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return false;
    }
}","{
    return runAction(new Action<Boolean>() {

        @Override
        public Boolean run(ITextToSpeechService service) throws RemoteException {
            return service.isSpeaking();
        }
    }, false, ""isSpeaking"");
}",1,"/**
 * Returns whether or not the TextToSpeech engine is busy speaking.
 *
 * @return Whether or not the TextToSpeech engine is busy speaking.
 */
","/**
 * Checks whether the TTS engine is busy speaking. Note that a speech item is
 * considered complete once it's audio data has been sent to the audio mixer, or
 * written to a file. There might be a finite lag between this point, and when
 * the audio hardware completes playback.
 *
 * @return {@code true} if the TTS engine is speaking.
 */
",1,,,0,,,,,,,"1,4",1,"The entire implementation of the method has been drastically changed. It has moved from having an explicit synchronization block with multiple catch statements to utilizing a runAction method with a specific Action<Boolean> implementation. The runAction method abstracts the synchronization and exception handling, and as such the return statements have also been modified. This change falls under both categories 1 and 4 since the return mechanism has changed and other statements have changed significantly.","Given that the old implementation handles various exceptions differently, initializing the TTS system repeatedly, and the new implementation abstracts exception handling altogether with a default return value, this change could lead to the API returning different boolean values under certain circumstances. Thus, a Compatibility Issue arises due to the potential for different return values. The CI type is 1."
589,<android.app.ContextImpl: ComponentName startService(Intent)>,13,14,,,,"{
    try {
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (cn != null && cn.getPackageName().equals(""!"")) {
            throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}","{
    try {
        service.setAllowFds(false);
        ComponentName cn = ActivityManagerNative.getDefault().startService(mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()));
        if (cn != null && cn.getPackageName().equals(""!"")) {
            throw new SecurityException(""Not allowed to start service "" + service + "" without permission "" + cn.getClassName());
        }
        return cn;
    } catch (RemoteException e) {
        return null;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There's an added statement `service.setAllowFds(false);` before the try block, which is an Other statement change type (4) as it does not affect return or exception handling behaviour.","Despite the additional statement, this change does not lead to a Compatibility Issue as it is only preparing an `Intent` object by altering its properties before use in the `ActivityManagerNative.getDefault().startService` method. It does not affect the method's return type or exception handling and would not lead to a different behavior from the API's perspective when handling the `Intent` if that property change is internally handled in `startService`. Thus, the Compatibility Issue is marked as 0 (No Compatibility Issue)."
590,<android.server.BluetoothService: String getName()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return getProperty(""Name"");
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    // Don't check state since we want to provide name, even if BT is off
    return getProperty(""Name"", false);
}",1,,,0,,,0,,,,,,,"1,4,5",1,"The method call of getProperty has been changed by adding an extra parameter 'false'. Additionally, there is a comment added which suggests a change in the policy of the method’s functionality but it doesn't directly contribute to code change classification. Since the getProperty API is being called with different parameters, the code change types are 1 for the return statement, 4 for the other statement by adding a comment, and 5 for the dependent API change.","Because the call to getProperty now includes an argument 'false', this could potentially lead to a case where the value returned by the method is different from earlier versions. Therefore, there is a potential Compatibility Issue that would be caused by the API potentially returning a different value, which is indicated by the CI type 1."
592,<android.view.ViewGroup: boolean dispatchDragEvent(DragEvent)>,13,14,,,,"{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRoot root = getViewRoot();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                    }
                    mDragNotifiedChildren.clear();
                    mCurrentDrag.recycle();
                    mCurrentDrag = null;
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        mCurrentDragView.dispatchDragEvent(event);
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    mCurrentDragView.dispatchDragEvent(event);
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}","{
    boolean retval = false;
    final float tx = event.mX;
    final float ty = event.mY;
    ViewRootImpl root = getViewRootImpl();
    // Dispatch down the view hierarchy
    switch(event.mAction) {
        case DragEvent.ACTION_DRAG_STARTED:
            {
                // clear state to recalculate which views we drag over
                mCurrentDragView = null;
                // Set up our tracking of drag-started notifications
                mCurrentDrag = DragEvent.obtain(event);
                if (mDragNotifiedChildren == null) {
                    mDragNotifiedChildren = new HashSet<View>();
                } else {
                    mDragNotifiedChildren.clear();
                }
                // Now dispatch down to our children, caching the responses
                mChildAcceptsDrag = false;
                final int count = mChildrenCount;
                final View[] children = mChildren;
                for (int i = 0; i < count; i++) {
                    final View child = children[i];
                    child.mPrivateFlags2 &= ~View.DRAG_MASK;
                    if (child.getVisibility() == VISIBLE) {
                        final boolean handled = notifyChildOfDrag(children[i]);
                        if (handled) {
                            mChildAcceptsDrag = true;
                        }
                    }
                }
                // Return HANDLED if one of our children can accept the drag
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            {
                // Release the bookkeeping now that the drag lifecycle has ended
                if (mDragNotifiedChildren != null) {
                    for (View child : mDragNotifiedChildren) {
                        // If a child was notified about an ongoing drag, it's told that it's over
                        child.dispatchDragEvent(event);
                        child.mPrivateFlags2 &= ~View.DRAG_MASK;
                        child.refreshDrawableState();
                    }
                    mDragNotifiedChildren.clear();
                    mCurrentDrag.recycle();
                    mCurrentDrag = null;
                }
                // had offered to handle the drag.
                if (mChildAcceptsDrag) {
                    retval = true;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_LOCATION:
            {
                // Find the [possibly new] drag target
                final View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                // before reporting the new potential recipient to the framework.
                if (mCurrentDragView != target) {
                    root.setDragFocus(target);
                    final int action = event.mAction;
                    // If we've dragged off of a child view, send it the EXITED message
                    if (mCurrentDragView != null) {
                        final View view = mCurrentDragView;
                        event.mAction = DragEvent.ACTION_DRAG_EXITED;
                        view.dispatchDragEvent(event);
                        view.mPrivateFlags2 &= ~View.DRAG_HOVERED;
                        view.refreshDrawableState();
                    }
                    mCurrentDragView = target;
                    // If we've dragged over a new child view, send it the ENTERED message
                    if (target != null) {
                        event.mAction = DragEvent.ACTION_DRAG_ENTERED;
                        target.dispatchDragEvent(event);
                        target.mPrivateFlags2 |= View.DRAG_HOVERED;
                        target.refreshDrawableState();
                    }
                    // restore the event's original state
                    event.mAction = action;
                }
                // Dispatch the actual drag location notice, localized into its coordinates
                if (target != null) {
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                }
            }
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            {
                if (mCurrentDragView != null) {
                    final View view = mCurrentDragView;
                    view.dispatchDragEvent(event);
                    view.mPrivateFlags2 &= ~View.DRAG_HOVERED;
                    view.refreshDrawableState();
                    mCurrentDragView = null;
                }
            }
            break;
        case DragEvent.ACTION_DROP:
            {
                if (ViewDebug.DEBUG_DRAG)
                    Log.d(View.VIEW_LOG_TAG, ""Drop event: "" + event);
                View target = findFrontmostDroppableChildAt(event.mX, event.mY, mLocalPoint);
                if (target != null) {
                    if (ViewDebug.DEBUG_DRAG)
                        Log.d(View.VIEW_LOG_TAG, ""   dispatch drop to "" + target);
                    event.mX = mLocalPoint.x;
                    event.mY = mLocalPoint.y;
                    retval = target.dispatchDragEvent(event);
                    event.mX = tx;
                    event.mY = ty;
                } else {
                    if (ViewDebug.DEBUG_DRAG) {
                        Log.d(View.VIEW_LOG_TAG, ""   not dropped on an accepting view"");
                    }
                }
            }
            break;
    }
    // If none of our children could handle the event, try here
    if (!retval) {
        // Call up to the View implementation that dispatches to installed listeners
        retval = super.dispatchDragEvent(event);
    }
    return retval;
}",1,"/**
 * {@inheritDoc}
 *
 * !!! TODO: write real docs
 */
","/**
 * {@inheritDoc}
 *
 * !!! TODO: write real docs
 */
",0,[@Override],[@Override],0,,,,,,,,,,
594,<android.widget.SearchView: void setIconifiedByDefault(boolean)>,13,14,,,,"{
    if (mIconifiedByDefault == iconified)
        return;
    mIconifiedByDefault = iconified;
    updateViewsVisibility(iconified);
}","{
    if (mIconifiedByDefault == iconified)
        return;
    mIconifiedByDefault = iconified;
    updateViewsVisibility(iconified);
    updateQueryHint();
}",1,"/**
 * Sets the default or resting state of the search field. If true, a single search icon is
 * shown by default and expands to show the text field and other buttons when pressed. Also,
 * if the default state is iconified, then it collapses to that state when the close button
 * is pressed. Changes to this property will take effect immediately.
 *
 * <p>The default value is true.</p>
 *
 * @param iconified whether the search field should be iconified by default
 *
 * @attr ref android.R.styleable#SearchView_iconifiedByDefault
 */
","/**
 * Sets the default or resting state of the search field. If true, a single search icon is
 * shown by default and expands to show the text field and other buttons when pressed. Also,
 * if the default state is iconified, then it collapses to that state when the close button
 * is pressed. Changes to this property will take effect immediately.
 *
 * <p>The default value is true.</p>
 *
 * @param iconified whether the search field should be iconified by default
 *
 * @attr ref android.R.styleable#SearchView_iconifiedByDefault
 */
",0,,,0,,,,,,,4,0,"There is an additional method call 'updateQueryHint()' at the end of the late version implementation, so the code change type is 4.","The addition of the method call 'updateQueryHint()' does not change the return type or value (since the method is void) nor does it introduce a new exception handling, so there is no Compatibility Issue."
595,<android.view.ViewDebug: void stopRecyclerTracing()>,13,14,,,,"{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_RECYCLER) {
        return;
    }
    if (sRecyclerOwnerView == null || sRecyclerViews == null) {
        throw new IllegalStateException(""You must call startRecyclerTracing() before"" + "" stopRecyclerTracing()!"");
    }
    File recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    // noinspection ResultOfMethodCallIgnored
    recyclerDump.mkdirs();
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".recycler"");
    try {
        final BufferedWriter out = new BufferedWriter(new FileWriter(recyclerDump), 8 * 1024);
        for (View view : sRecyclerViews) {
            final String name = view.getClass().getName();
            out.write(name);
            out.newLine();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler content"");
        return;
    }
    recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".traces"");
    try {
        if (recyclerDump.exists()) {
            recyclerDump.delete();
        }
        final FileOutputStream file = new FileOutputStream(recyclerDump);
        final DataOutputStream out = new DataOutputStream(file);
        for (RecyclerTrace trace : sRecyclerTraces) {
            out.writeInt(trace.view);
            out.writeInt(trace.type.ordinal());
            out.writeInt(trace.position);
            out.writeInt(trace.indexOnScreen);
            out.flush();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler traces"");
        return;
    }
    sRecyclerViews.clear();
    sRecyclerViews = null;
    sRecyclerTraces.clear();
    sRecyclerTraces = null;
    sRecyclerOwnerView = null;
}","{
    // noinspection PointlessBooleanExpression,ConstantConditions
    if (!TRACE_RECYCLER) {
        return;
    }
    if (sRecyclerOwnerView == null || sRecyclerViews == null) {
        throw new IllegalStateException(""You must call startRecyclerTracing() before"" + "" stopRecyclerTracing()!"");
    }
    File recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    // noinspection ResultOfMethodCallIgnored
    recyclerDump.mkdirs();
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".recycler"");
    try {
        final BufferedWriter out = new BufferedWriter(new FileWriter(recyclerDump), 8 * 1024);
        for (View view : sRecyclerViews) {
            final String name = view.getClass().getName();
            out.write(name);
            out.newLine();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler content"");
        return;
    }
    recyclerDump = new File(Environment.getExternalStorageDirectory(), ""view-recycler/"");
    recyclerDump = new File(recyclerDump, sRecyclerTracePrefix + "".traces"");
    try {
        if (recyclerDump.exists()) {
            // noinspection ResultOfMethodCallIgnored
            recyclerDump.delete();
        }
        final FileOutputStream file = new FileOutputStream(recyclerDump);
        final DataOutputStream out = new DataOutputStream(file);
        for (RecyclerTrace trace : sRecyclerTraces) {
            out.writeInt(trace.view);
            out.writeInt(trace.type.ordinal());
            out.writeInt(trace.position);
            out.writeInt(trace.indexOnScreen);
            out.flush();
        }
        out.close();
    } catch (IOException e) {
        Log.e(""View"", ""Could not dump recycler traces"");
        return;
    }
    sRecyclerViews.clear();
    sRecyclerViews = null;
    sRecyclerTraces.clear();
    sRecyclerTraces = null;
    sRecyclerOwnerView = null;
}",1,"/**
 * Stops the current view recycer tracing.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's recycler.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code>
 * containing all of the views used by the recycler of the view supplied to
 * {@link #startRecyclerTracing(String, View)}.
 *
 * This method will return immediately if TRACE_RECYCLER is false.
 *
 * @see #startRecyclerTracing(String, View)
 * @see #trace(View, android.view.ViewDebug.RecyclerTraceType, int[])
 */
","/**
 * Stops the current view recycer tracing.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.traces</code>
 * containing all the traces (or method calls) relative to the specified view's recycler.
 *
 * Calling this method creates the file <code>/EXTERNAL/view-recycler/PREFIX.recycler</code>
 * containing all of the views used by the recycler of the view supplied to
 * {@link #startRecyclerTracing(String, View)}.
 *
 * This method will return immediately if TRACE_RECYCLER is false.
 *
 * @see #startRecyclerTracing(String, View)
 * @see #trace(View, android.view.ViewDebug.RecyclerTraceType, int[])
 */
",0,,,0,,,,,,,4,0,"The only difference in the code is the addition of the comment line `// noinspection ResultOfMethodCallIgnored` before `recyclerDump.delete();` in the late version. Since this is a comment and does not affect the code's execution, the change type is 4 (Other statement changed).",There is no Compatibility Issue as comments do not affect the execution flow or behavior of the code.
596,<android.database.sqlite.SQLiteCursor: void setWindow(CursorWindow)>,13,14,,,,"{
    if (mWindow != null) {
        mCursorState++;
        queryThreadLock();
        try {
            mWindow.close();
        } finally {
            queryThreadUnlock();
        }
        mCount = NO_COUNT;
    }
    mWindow = window;
}","{
    super.setWindow(window);
    mCount = NO_COUNT;
}",1,,,0,[@Override],[@Override],0,,,,,,,5,0,"The implementation now calls super.setWindow(window) instead of directly manipulating mWindow, making it a dependent API change.","There is no Compatibility Issue caused by this change, because the behavior of setting the window still achieves the same outcome, and no new throw statement is introduced nor are there any changes to the return value of the method (which is void in both versions)."
598,<android.view.View: boolean setAlphaNoInvalidation(float)>,13,14,,,,"{
    mAlpha = alpha;
    boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
    if (subclassHandlesAlpha) {
        mPrivateFlags |= ALPHA_SET;
    } else {
        mPrivateFlags &= ~ALPHA_SET;
    }
    return subclassHandlesAlpha;
}","{
    ensureTransformationInfo();
    mTransformationInfo.mAlpha = alpha;
    boolean subclassHandlesAlpha = onSetAlpha((int) (alpha * 255));
    if (subclassHandlesAlpha) {
        mPrivateFlags |= ALPHA_SET;
    } else {
        mPrivateFlags &= ~ALPHA_SET;
    }
    return subclassHandlesAlpha;
}",1,"/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha())
 */
","/**
 * Faster version of setAlpha() which performs the same steps except there are
 * no calls to invalidate(). The caller of this function should perform proper invalidation
 * on the parent and this object. The return value indicates whether the subclass handles
 * alpha (the return value for onSetAlpha()).
 *
 * @param alpha The new value for the alpha property
 * @return true if the View subclass handles alpha (the return value for onSetAlpha())
 */
",0,,,0,,,,,,,4,0,"The code has introduced a new method call ensureTransformationInfo() which does not affect the return value or the exception handling, so the code change type is 4.","No Compatibility Issue arises from this change as it neither affects the return value nor the exception handling of the method; the method still executes the same steps to compute the boolean 'subclassHandlesAlpha' and return it. Therefore, the CI type is 0."
600,"<android.webkit.WebView: boolean onKeyUp(int,KeyEvent)>",13,14,,,,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_UP, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), false, event.getMetaState());
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (isEnterActionKey(keyCode)) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry();
        nativeShowCursorTimed();
        if (mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            return true;
        }
        if (nativeCursorNodePointer() != 0 && !nativeCursorWantsKeyEvents()) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
            return true;
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyUp at "" + System.currentTimeMillis() + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // special CALL handling when cursor node's href is ""tel:XXX""
    if (keyCode == KeyEvent.KEYCODE_CALL && nativeHasCursorNode()) {
        String text = nativeCursorText();
        if (!nativeCursorIsTextInput() && text != null && text.startsWith(SCHEME_TEL)) {
            Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse(text));
            getContext().startActivity(intent);
            return true;
        }
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_UP, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), false, event.getMetaState());
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (isEnterActionKey(keyCode)) {
        // remove the long press message first
        mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
        mGotCenterDown = false;
        if (mSelectingText) {
            if (mExtendSelection) {
                copySelection();
                selectionDone();
            } else {
                mExtendSelection = true;
                nativeSetExtendSelection();
                // draw the i-beam instead of the arrow
                invalidate();
            }
            // discard press if copy in progress
            return true;
        }
        // perform the single click
        Rect visibleRect = sendOurVisibleRect();
        // coordinates should be in content coordinates.
        if (!nativeCursorIntersects(visibleRect)) {
            return false;
        }
        WebViewCore.CursorData data = cursorData();
        mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE, data);
        playSoundEffect(SoundEffectConstants.CLICK);
        if (nativeCursorIsTextInput()) {
            rebuildWebTextView();
            centerKeyPressOnTextField();
            if (inEditingMode()) {
                mWebTextView.setDefaultSelection();
            }
            return true;
        }
        clearTextEntry();
        nativeShowCursorTimed();
        if (mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
            return true;
        }
        if (nativeCursorNodePointer() != 0 && !nativeCursorWantsKeyEvents()) {
            mWebViewCore.sendMessage(EventHub.CLICK, data.mFrame, nativeCursorNodePointer());
            return true;
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
602,"<android.widget.AbsListView: boolean performLongPress(View,int,long)>",13,14,,,,"{
    // CHOICE_MODE_MULTIPLE_MODAL takes over long press.
    if (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        if (mChoiceActionMode == null) {
            mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
            setItemChecked(longPressPosition, true);
        }
        // TODO Should we select the long pressed item if we were already in
        // selection mode? (i.e. treat it like an item click?)
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        return true;
    }
    boolean handled = false;
    if (mOnItemLongClickListener != null) {
        handled = mOnItemLongClickListener.onItemLongClick(AbsListView.this, child, longPressPosition, longPressId);
    }
    if (!handled) {
        mContextMenuInfo = createContextMenuInfo(child, longPressPosition, longPressId);
        handled = super.showContextMenuForChild(AbsListView.this);
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}","{
    // CHOICE_MODE_MULTIPLE_MODAL takes over long press.
    if (mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        if (mChoiceActionMode == null && (mChoiceActionMode = startActionMode(mMultiChoiceModeCallback)) != null) {
            setItemChecked(longPressPosition, true);
            performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
        }
        return true;
    }
    boolean handled = false;
    if (mOnItemLongClickListener != null) {
        handled = mOnItemLongClickListener.onItemLongClick(AbsListView.this, child, longPressPosition, longPressId);
    }
    if (!handled) {
        mContextMenuInfo = createContextMenuInfo(child, longPressPosition, longPressId);
        handled = super.showContextMenuForChild(AbsListView.this);
    }
    if (handled) {
        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
    }
    return handled;
}",1,,,0,,,0,,,,,,,"1,3",1,"The assignment and the condition check of 'mChoiceActionMode' have been combined into one line, introducing a new control dependency structure. Additionally, the performHapticFeedback call has been moved inside the conditional statement to only execute when mChoiceActionMode is not null and successfully started, unlike the early version where it was executed regardless of whether mChoiceActionMode was started successfully, so the change types are 1,3.","Given the performHapticFeedback is a side effect and not related to the return value or the logic flow of the method, it wouldn't cause a compatibility issue in terms of what value is returned. However, the logic of starting the action mode and performing haptic feedback only if the action mode is non-null and successfully started, will change the behavior of the method compared to when the haptic feedback was always performed in the earlier version. This change can result in a different experience for the end user who might expect the long press to always result in a haptic feedback, and thus is a compatibility issue type 1 due to the potential for the API to return different behavior under certain conditions."
604,"<android.webkit.WebTextView.AutoCompleteAdapter: View getView(int,View,ViewGroup)>",13,14,,,,"{
    TextView tv = (TextView) super.getView(position, convertView, parent);
    if (tv != null && mTextView != null) {
        tv.setTextSize(mTextView.getTextSize());
    }
    return tv;
}","{
    TextView tv = (TextView) super.getView(position, convertView, parent);
    if (tv != null && mTextView != null) {
        tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextView.getTextSize());
    }
    return tv;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"There's a change in one method call: instead of a single argument in `setTextSize` the late version uses two arguments, with `TypedValue.COMPLEX_UNIT_PX` specifying the unit. This is an example of using an overloaded version of the same method, so the code change type is 4.","The modification does not result in any different return value or exception handling as it is merely specifying the unit for the text size which would have been the default unit used even in the early version. Therefore, there's no Compatibility Issue, and the CI type is 0."
606,<android.app.ContextImpl: void removeStickyBroadcast(Intent)>,13,14,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    if (resolvedType != null) {
        intent = new Intent(intent);
        intent.setDataAndType(intent.getData(), resolvedType);
    }
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().unbroadcastIntent(mMainThread.getApplicationThread(), intent);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The statement `intent.setAllowFds(false);` was added, which is neither a change in return statement, exception handling statement, control structure nor a dependent API change. So the change type is 4.","The additional call to `intent.setAllowFds(false);` does not create a Compatibility Issue since it neither affects the method's return value nor the exceptions thrown. It is an internal configuration change that does not change the observable behavior as far as the method signature and contract are concerned. Hence, the CI type is 0."
607,"<android.text.util.Rfc822Tokenizer: int findTokenEnd(CharSequence,int)>",13,14,,,,"{
    int len = text.length();
    int i = cursor;
    while (i < len) {
        char c = text.charAt(i);
        if (c == ',' || c == ';') {
            return i;
        } else if (c == '""') {
            i++;
            while (i < len) {
                c = text.charAt(i);
                if (c == '""') {
                    i++;
                    break;
                } else if (c == '\\') {
                    i += 2;
                } else {
                    i++;
                }
            }
        } else if (c == '(') {
            int level = 1;
            i++;
            while (i < len && level > 0) {
                c = text.charAt(i);
                if (c == ')') {
                    level--;
                    i++;
                } else if (c == '(') {
                    level++;
                    i++;
                } else if (c == '\\') {
                    i += 2;
                } else {
                    i++;
                }
            }
        } else if (c == '<') {
            i++;
            while (i < len) {
                c = text.charAt(i);
                if (c == '>') {
                    i++;
                    break;
                } else {
                    i++;
                }
            }
        } else {
            i++;
        }
    }
    return i;
}","{
    int len = text.length();
    int i = cursor;
    while (i < len) {
        char c = text.charAt(i);
        if (c == ',' || c == ';') {
            return i;
        } else if (c == '""') {
            i++;
            while (i < len) {
                c = text.charAt(i);
                if (c == '""') {
                    i++;
                    break;
                } else if (c == '\\' && i + 1 < len) {
                    i += 2;
                } else {
                    i++;
                }
            }
        } else if (c == '(') {
            int level = 1;
            i++;
            while (i < len && level > 0) {
                c = text.charAt(i);
                if (c == ')') {
                    level--;
                    i++;
                } else if (c == '(') {
                    level++;
                    i++;
                } else if (c == '\\' && i + 1 < len) {
                    i += 2;
                } else {
                    i++;
                }
            }
        } else if (c == '<') {
            i++;
            while (i < len) {
                c = text.charAt(i);
                if (c == '>') {
                    i++;
                    break;
                } else {
                    i++;
                }
            }
        } else {
            i++;
        }
    }
    return i;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,,,0,,,,,,,3,0,"The change happens inside two 'if' control blocks where the check for the '\\' character is now followed by an additional check if (i + 1 < len). This change is a control dependency change, so the code change type is 3.","Despite the change inside control blocks, the functionality of the method will not lead to a change in behavior regarding the return value or exceptions thrown when compared to the previous implementation. All changes ensure that no index out of bounds exception are thrown, which would not change the result of the method because the same operational logic occurs after the checks, just with added safety. This means there is no compatibility issue, so the CI type is 0."
609,"<android.text.method.ArrowKeyMovementMethod: boolean onTouchEvent(TextView,Spannable,MotionEvent)>",13,14,,,,"{
    int initialScrollX = -1, initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            boolean cap = isSelecting(buffer);
            if (cap) {
                int offset = widget.getOffset((int) event.getX(), (int) event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            boolean cap = isSelecting(buffer);
            if (cap && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffset((int) event.getX(), (int) event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffset((int) event.getX(), (int) event.getY());
            if (isSelecting(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            } else {
                Selection.setSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}","{
    int initialScrollX = -1;
    int initialScrollY = -1;
    final int action = event.getAction();
    if (action == MotionEvent.ACTION_UP) {
        initialScrollX = Touch.getInitialScrollX(widget, buffer);
        initialScrollY = Touch.getInitialScrollY(widget, buffer);
    }
    boolean handled = Touch.onTouchEvent(widget, buffer, event);
    if (widget.isFocused() && !widget.didTouchFocusSelect()) {
        if (action == MotionEvent.ACTION_DOWN) {
            if (isSelecting(buffer)) {
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                buffer.setSpan(LAST_TAP_DOWN, offset, offset, Spannable.SPAN_POINT_POINT);
                // Disallow intercepting of the touch events, so that
                // users can scroll and select at the same time.
                // without this, users would get booted out of select
                // mode once the view detected it needed to scroll.
                widget.getParent().requestDisallowInterceptTouchEvent(true);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            if (isSelecting(buffer) && handled) {
                // Before selecting, make sure we've moved out of the ""slop"".
                // handled will be true, if we're in select mode AND we're
                // OUT of the slop
                // Turn long press off while we're selecting. User needs to
                // re-tap on the selection to enable long press
                widget.cancelLongPress();
                // Update selection as we're moving the selection area.
                // Get the current touch position
                int offset = widget.getOffsetForPosition(event.getX(), event.getY());
                Selection.extendSelection(buffer, offset);
                return true;
            }
        } else if (action == MotionEvent.ACTION_UP) {
            // to show it.
            if ((initialScrollY >= 0 && initialScrollY != widget.getScrollY()) || (initialScrollX >= 0 && initialScrollX != widget.getScrollX())) {
                widget.moveCursorToVisibleOffset();
                return true;
            }
            int offset = widget.getOffsetForPosition(event.getX(), event.getY());
            if (isSelecting(buffer)) {
                buffer.removeSpan(LAST_TAP_DOWN);
                Selection.extendSelection(buffer, offset);
            } else if (!widget.shouldIgnoreActionUpEvent()) {
                Selection.setSelection(buffer, offset);
            }
            MetaKeyKeyListener.adjustMetaAfterKeypress(buffer);
            MetaKeyKeyListener.resetLockedMeta(buffer);
            return true;
        }
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
610,<android.widget.TextView: void onDraw(Canvas)>,13,14,,,,"{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return;
    restartMarqueeIfNeeded();
    // Draw the background for this view
    super.onDraw(canvas);
    final int compoundPaddingLeft = getCompoundPaddingLeft();
    final int compoundPaddingTop = getCompoundPaddingTop();
    final int compoundPaddingRight = getCompoundPaddingRight();
    final int compoundPaddingBottom = getCompoundPaddingBottom();
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    final int right = mRight;
    final int left = mLeft;
    final int bottom = mBottom;
    final int top = mTop;
    final Drawables dr = mDrawables;
    if (dr != null) {
        /*
             * Compound, not extended, because the icon is not clipped
             * if the text height is smaller.
             */
        int vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
        int hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableLeft != null) {
            canvas.save();
            canvas.translate(scrollX + mPaddingLeft, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
            dr.mDrawableLeft.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableRight != null) {
            canvas.save();
            canvas.translate(scrollX + right - left - mPaddingRight - dr.mDrawableSizeRight, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
            dr.mDrawableRight.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableTop != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + mPaddingTop);
            dr.mDrawableTop.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableBottom != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);
            dr.mDrawableBottom.draw(canvas);
            canvas.restore();
        }
    }
    if (mPreDrawState == PREDRAW_DONE) {
        final ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnPreDrawListener(this);
        mPreDrawState = PREDRAW_NOT_REGISTERED;
    }
    int color = mCurTextColor;
    if (mLayout == null) {
        assumeLayout();
    }
    Layout layout = mLayout;
    int cursorcolor = color;
    if (mHint != null && mText.length() == 0) {
        if (mHintTextColor != null) {
            color = mCurHintTextColor;
        }
        layout = mHintLayout;
    }
    mTextPaint.setColor(color);
    if (mCurrentAlpha != 255) {
        // If set, the alpha will override the color's alpha. Multiply the alphas.
        mTextPaint.setAlpha((mCurrentAlpha * Color.alpha(color)) / 255);
    }
    mTextPaint.drawableState = getDrawableState();
    canvas.save();
    /*  Would be faster if we didn't have to do this. Can we chop the
            (displayable) text so that we don't need to do this ever?
        */
    int extendedPaddingTop = getExtendedPaddingTop();
    int extendedPaddingBottom = getExtendedPaddingBottom();
    float clipLeft = compoundPaddingLeft + scrollX;
    float clipTop = extendedPaddingTop + scrollY;
    float clipRight = right - left - compoundPaddingRight + scrollX;
    float clipBottom = bottom - top - extendedPaddingBottom + scrollY;
    if (mShadowRadius != 0) {
        clipLeft += Math.min(0, mShadowDx - mShadowRadius);
        clipRight += Math.max(0, mShadowDx + mShadowRadius);
        clipTop += Math.min(0, mShadowDy - mShadowRadius);
        clipBottom += Math.max(0, mShadowDy + mShadowRadius);
    }
    canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
    int voffsetText = 0;
    int voffsetCursor = 0;
    // translate in by our padding
    {
        /* shortcircuit calling getVerticaOffset() */
        if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
            voffsetText = getVerticalOffset(false);
            voffsetCursor = getVerticalOffset(true);
        }
        canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
    }
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
        if (!mSingleLine && getLineCount() == 1 && canMarquee() && (mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
            canvas.translate(mLayout.getLineRight(0) - (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight()), 0.0f);
        }
        if (mMarquee != null && mMarquee.isRunning()) {
            canvas.translate(-mMarquee.mScroll, 0.0f);
        }
    }
    Path highlight = null;
    int selStart = -1, selEnd = -1;
    boolean drawCursor = false;
    // selection manually if it really wanted to.
    if (mMovement != null && (isFocused() || isPressed())) {
        selStart = getSelectionStart();
        selEnd = getSelectionEnd();
        if ((isCursorVisible() || mTextIsSelectable) && selStart >= 0 && isEnabled()) {
            if (mHighlightPath == null)
                mHighlightPath = new Path();
            if (selStart == selEnd) {
                if (!mTextIsSelectable && (SystemClock.uptimeMillis() - mShowCursor) % (2 * BLINK) < BLINK) {
                    if (mHighlightPathBogus) {
                        mHighlightPath.reset();
                        mLayout.getCursorPath(selStart, mHighlightPath, mText);
                        updateCursorsPositions();
                        mHighlightPathBogus = false;
                    }
                    // XXX should pass to skin instead of drawing directly
                    mHighlightPaint.setColor(cursorcolor);
                    if (mCurrentAlpha != 255) {
                        mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(cursorcolor)) / 255);
                    }
                    mHighlightPaint.setStyle(Paint.Style.STROKE);
                    highlight = mHighlightPath;
                    drawCursor = mCursorCount > 0;
                }
            } else {
                if (mHighlightPathBogus) {
                    mHighlightPath.reset();
                    mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                    mHighlightPathBogus = false;
                }
                // XXX should pass to skin instead of drawing directly
                mHighlightPaint.setColor(mHighlightColor);
                if (mCurrentAlpha != 255) {
                    mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(mHighlightColor)) / 255);
                }
                mHighlightPaint.setStyle(Paint.Style.FILL);
                highlight = mHighlightPath;
            }
        }
    }
    /*  Comment out until we decide what to do about animations
        boolean isLinearTextOn = false;
        if (currentTransformation != null) {
            isLinearTextOn = mTextPaint.isLinearTextOn();
            Matrix m = currentTransformation.getMatrix();
            if (!m.isIdentity()) {
                // mTextPaint.setLinearTextOn(true);
            }
        }
        */
    final InputMethodState ims = mInputMethodState;
    final int cursorOffsetVertical = voffsetCursor - voffsetText;
    if (ims != null && ims.mBatchEditNesting == 0) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            if (imm.isActive(this)) {
                boolean reported = false;
                if (ims.mContentChanged || ims.mSelectionModeChanged) {
                    // We are in extract mode and the content has changed
                    // in some way... just report complete new text to the
                    // input method.
                    reported = reportExtractedText();
                }
                if (!reported && highlight != null) {
                    int candStart = -1;
                    int candEnd = -1;
                    if (mText instanceof Spannable) {
                        Spannable sp = (Spannable) mText;
                        candStart = EditableInputConnection.getComposingSpanStart(sp);
                        candEnd = EditableInputConnection.getComposingSpanEnd(sp);
                    }
                    imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
                }
            }
            if (imm.isWatchingCursor(this) && highlight != null) {
                highlight.computeBounds(ims.mTmpRectF, true);
                ims.mTmpOffset[0] = ims.mTmpOffset[1] = 0;
                canvas.getMatrix().mapPoints(ims.mTmpOffset);
                ims.mTmpRectF.offset(ims.mTmpOffset[0], ims.mTmpOffset[1]);
                ims.mTmpRectF.offset(0, cursorOffsetVertical);
                ims.mCursorRectInWindow.set((int) (ims.mTmpRectF.left + 0.5), (int) (ims.mTmpRectF.top + 0.5), (int) (ims.mTmpRectF.right + 0.5), (int) (ims.mTmpRectF.bottom + 0.5));
                imm.updateCursor(this, ims.mCursorRectInWindow.left, ims.mCursorRectInWindow.top, ims.mCursorRectInWindow.right, ims.mCursorRectInWindow.bottom);
            }
        }
    }
    if (mCorrectionHighlighter != null) {
        mCorrectionHighlighter.draw(canvas, cursorOffsetVertical);
    }
    if (drawCursor) {
        drawCursor(canvas, cursorOffsetVertical);
        // Rely on the drawable entirely, do not draw the cursor line.
        // Has to be done after the IMM related code above which relies on the highlight.
        highlight = null;
    }
    layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    if (mMarquee != null && mMarquee.shouldDrawGhost()) {
        canvas.translate((int) mMarquee.getGhostOffset(), 0.0f);
        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    }
    /*  Comment out until we decide what to do about animations
        if (currentTransformation != null) {
            mTextPaint.setLinearTextOn(isLinearTextOn);
        }
        */
    canvas.restore();
}","{
    if (mPreDrawState == PREDRAW_DONE) {
        final ViewTreeObserver observer = getViewTreeObserver();
        observer.removeOnPreDrawListener(this);
        mPreDrawState = PREDRAW_NOT_REGISTERED;
    }
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return;
    restartMarqueeIfNeeded();
    // Draw the background for this view
    super.onDraw(canvas);
    final int compoundPaddingLeft = getCompoundPaddingLeft();
    final int compoundPaddingTop = getCompoundPaddingTop();
    final int compoundPaddingRight = getCompoundPaddingRight();
    final int compoundPaddingBottom = getCompoundPaddingBottom();
    final int scrollX = mScrollX;
    final int scrollY = mScrollY;
    final int right = mRight;
    final int left = mLeft;
    final int bottom = mBottom;
    final int top = mTop;
    final Drawables dr = mDrawables;
    if (dr != null) {
        /*
             * Compound, not extended, because the icon is not clipped
             * if the text height is smaller.
             */
        int vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
        int hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableLeft != null) {
            canvas.save();
            canvas.translate(scrollX + mPaddingLeft, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
            dr.mDrawableLeft.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableRight != null) {
            canvas.save();
            canvas.translate(scrollX + right - left - mPaddingRight - dr.mDrawableSizeRight, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
            dr.mDrawableRight.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableTop != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + mPaddingTop);
            dr.mDrawableTop.draw(canvas);
            canvas.restore();
        }
        // Make sure to update invalidateDrawable() when changing this code.
        if (dr.mDrawableBottom != null) {
            canvas.save();
            canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - mPaddingBottom - dr.mDrawableSizeBottom);
            dr.mDrawableBottom.draw(canvas);
            canvas.restore();
        }
    }
    int color = mCurTextColor;
    if (mLayout == null) {
        assumeLayout();
    }
    Layout layout = mLayout;
    int cursorcolor = color;
    if (mHint != null && mText.length() == 0) {
        if (mHintTextColor != null) {
            color = mCurHintTextColor;
        }
        layout = mHintLayout;
    }
    mTextPaint.setColor(color);
    if (mCurrentAlpha != 255) {
        // If set, the alpha will override the color's alpha. Multiply the alphas.
        mTextPaint.setAlpha((mCurrentAlpha * Color.alpha(color)) / 255);
    }
    mTextPaint.drawableState = getDrawableState();
    canvas.save();
    /*  Would be faster if we didn't have to do this. Can we chop the
            (displayable) text so that we don't need to do this ever?
        */
    int extendedPaddingTop = getExtendedPaddingTop();
    int extendedPaddingBottom = getExtendedPaddingBottom();
    float clipLeft = compoundPaddingLeft + scrollX;
    float clipTop = extendedPaddingTop + scrollY;
    float clipRight = right - left - compoundPaddingRight + scrollX;
    float clipBottom = bottom - top - extendedPaddingBottom + scrollY;
    if (mShadowRadius != 0) {
        clipLeft += Math.min(0, mShadowDx - mShadowRadius);
        clipRight += Math.max(0, mShadowDx + mShadowRadius);
        clipTop += Math.min(0, mShadowDy - mShadowRadius);
        clipBottom += Math.max(0, mShadowDy + mShadowRadius);
    }
    canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
    int voffsetText = 0;
    int voffsetCursor = 0;
    // translate in by our padding
    {
        /* shortcircuit calling getVerticaOffset() */
        if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
            voffsetText = getVerticalOffset(false);
            voffsetCursor = getVerticalOffset(true);
        }
        canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
    }
    final int layoutDirection = getResolvedLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (!mSingleLine && getLineCount() == 1 && canMarquee() && (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
            canvas.translate(mLayout.getLineRight(0) - (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight()), 0.0f);
        }
        if (mMarquee != null && mMarquee.isRunning()) {
            canvas.translate(-mMarquee.mScroll, 0.0f);
        }
    }
    Path highlight = null;
    int selStart = -1, selEnd = -1;
    boolean drawCursor = false;
    // selection manually if it really wanted to.
    if (mMovement != null && (isFocused() || isPressed())) {
        selStart = getSelectionStart();
        selEnd = getSelectionEnd();
        if (selStart >= 0) {
            if (mHighlightPath == null)
                mHighlightPath = new Path();
            if (selStart == selEnd) {
                if (isCursorVisible() && (SystemClock.uptimeMillis() - mShowCursor) % (2 * BLINK) < BLINK) {
                    if (mHighlightPathBogus) {
                        mHighlightPath.reset();
                        mLayout.getCursorPath(selStart, mHighlightPath, mText);
                        updateCursorsPositions();
                        mHighlightPathBogus = false;
                    }
                    // XXX should pass to skin instead of drawing directly
                    mHighlightPaint.setColor(cursorcolor);
                    if (mCurrentAlpha != 255) {
                        mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(cursorcolor)) / 255);
                    }
                    mHighlightPaint.setStyle(Paint.Style.STROKE);
                    highlight = mHighlightPath;
                    drawCursor = mCursorCount > 0;
                }
            } else if (textCanBeSelected()) {
                if (mHighlightPathBogus) {
                    mHighlightPath.reset();
                    mLayout.getSelectionPath(selStart, selEnd, mHighlightPath);
                    mHighlightPathBogus = false;
                }
                // XXX should pass to skin instead of drawing directly
                mHighlightPaint.setColor(mHighlightColor);
                if (mCurrentAlpha != 255) {
                    mHighlightPaint.setAlpha((mCurrentAlpha * Color.alpha(mHighlightColor)) / 255);
                }
                mHighlightPaint.setStyle(Paint.Style.FILL);
                highlight = mHighlightPath;
            }
        }
    }
    /*  Comment out until we decide what to do about animations
        boolean isLinearTextOn = false;
        if (currentTransformation != null) {
            isLinearTextOn = mTextPaint.isLinearTextOn();
            Matrix m = currentTransformation.getMatrix();
            if (!m.isIdentity()) {
                // mTextPaint.setLinearTextOn(true);
            }
        }
        */
    final InputMethodState ims = mInputMethodState;
    final int cursorOffsetVertical = voffsetCursor - voffsetText;
    if (ims != null && ims.mBatchEditNesting == 0) {
        InputMethodManager imm = InputMethodManager.peekInstance();
        if (imm != null) {
            if (imm.isActive(this)) {
                boolean reported = false;
                if (ims.mContentChanged || ims.mSelectionModeChanged) {
                    // We are in extract mode and the content has changed
                    // in some way... just report complete new text to the
                    // input method.
                    reported = reportExtractedText();
                }
                if (!reported && highlight != null) {
                    int candStart = -1;
                    int candEnd = -1;
                    if (mText instanceof Spannable) {
                        Spannable sp = (Spannable) mText;
                        candStart = EditableInputConnection.getComposingSpanStart(sp);
                        candEnd = EditableInputConnection.getComposingSpanEnd(sp);
                    }
                    imm.updateSelection(this, selStart, selEnd, candStart, candEnd);
                }
            }
            if (imm.isWatchingCursor(this) && highlight != null) {
                highlight.computeBounds(ims.mTmpRectF, true);
                ims.mTmpOffset[0] = ims.mTmpOffset[1] = 0;
                canvas.getMatrix().mapPoints(ims.mTmpOffset);
                ims.mTmpRectF.offset(ims.mTmpOffset[0], ims.mTmpOffset[1]);
                ims.mTmpRectF.offset(0, cursorOffsetVertical);
                ims.mCursorRectInWindow.set((int) (ims.mTmpRectF.left + 0.5), (int) (ims.mTmpRectF.top + 0.5), (int) (ims.mTmpRectF.right + 0.5), (int) (ims.mTmpRectF.bottom + 0.5));
                imm.updateCursor(this, ims.mCursorRectInWindow.left, ims.mCursorRectInWindow.top, ims.mCursorRectInWindow.right, ims.mCursorRectInWindow.bottom);
            }
        }
    }
    if (mCorrectionHighlighter != null) {
        mCorrectionHighlighter.draw(canvas, cursorOffsetVertical);
    }
    if (drawCursor) {
        drawCursor(canvas, cursorOffsetVertical);
        // Rely on the drawable entirely, do not draw the cursor line.
        // Has to be done after the IMM related code above which relies on the highlight.
        highlight = null;
    }
    layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    if (mMarquee != null && mMarquee.shouldDrawGhost()) {
        canvas.translate((int) mMarquee.getGhostOffset(), 0.0f);
        layout.draw(canvas, highlight, mHighlightPaint, cursorOffsetVertical);
    }
    /*  Comment out until we decide what to do about animations
        if (currentTransformation != null) {
            mTextPaint.setLinearTextOn(isLinearTextOn);
        }
        */
    canvas.restore();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
614,<android.widget.Gallery.FlingRunnable: void run()>,13,14,,,,"{
    if (mItemCount == 0) {
        endFling(true);
        return;
    }
    mShouldStopFling = false;
    final Scroller scroller = mScroller;
    boolean more = scroller.computeScrollOffset();
    final int x = scroller.getCurrX();
    // Flip sign to convert finger direction to list items direction
    // (e.g. finger moving down means list is moving towards the top)
    int delta = mLastFlingX - x;
    // Pretend that each frame of a fling scroll is a touch scroll
    if (delta > 0) {
        // Moving towards the left. Use first view as mDownTouchPosition
        mDownTouchPosition = mFirstPosition;
        // Don't fling more than 1 screen
        delta = Math.min(getWidth() - mPaddingLeft - mPaddingRight - 1, delta);
    } else {
        // Moving towards the right. Use last view as mDownTouchPosition
        int offsetToLast = getChildCount() - 1;
        mDownTouchPosition = mFirstPosition + offsetToLast;
        // Don't fling more than 1 screen
        delta = Math.max(-(getWidth() - mPaddingRight - mPaddingLeft - 1), delta);
    }
    trackMotionScroll(delta);
    if (more && !mShouldStopFling) {
        mLastFlingX = x;
        post(this);
    } else {
        endFling(true);
    }
}","{
    if (mItemCount == 0) {
        endFling(true);
        return;
    }
    mShouldStopFling = false;
    final Scroller scroller = mScroller;
    boolean more = scroller.computeScrollOffset();
    final int x = scroller.getCurrX();
    // Flip sign to convert finger direction to list items direction
    // (e.g. finger moving down means list is moving towards the top)
    int delta = mLastFlingX - x;
    // Pretend that each frame of a fling scroll is a touch scroll
    if (delta > 0) {
        // Moving towards the left. Use leftmost view as mDownTouchPosition
        mDownTouchPosition = mIsRtl ? (mFirstPosition + getChildCount() - 1) : mFirstPosition;
        // Don't fling more than 1 screen
        delta = Math.min(getWidth() - mPaddingLeft - mPaddingRight - 1, delta);
    } else {
        // Moving towards the right. Use rightmost view as mDownTouchPosition
        int offsetToLast = getChildCount() - 1;
        mDownTouchPosition = mIsRtl ? mFirstPosition : (mFirstPosition + getChildCount() - 1);
        // Don't fling more than 1 screen
        delta = Math.max(-(getWidth() - mPaddingRight - mPaddingLeft - 1), delta);
    }
    trackMotionScroll(delta);
    if (more && !mShouldStopFling) {
        mLastFlingX = x;
        post(this);
    } else {
        endFling(true);
    }
}",1,,,0,,[@Override],1,,,,,,,4,0,"The assignment of `mDownTouchPosition` based on the direction of the delta and the condition involving `mIsRtl` has changed. The assignments are made using different conditional logic, but it ultimately assigns the same value to the `mDownTouchPosition` variable. No other changes are made in the method body that could affect the behavior of the method. Hence, the code change type is 4.","Although there are changes in the code (assignments of `mDownTouchPosition`), these changes do not cause any Compatibility Issue because they do not affect the return values nor do they change exception handlings. The behavior of the method is preserved, leading to no compatibility issues; thus CI type is 0."
615,"<android.view.GLES20Canvas: void drawText(String,int,int,float,float,Paint)>",13,14,,,,"{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    boolean hasModifier = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4,5",0,"The return type of `setupModifiers` changed from `boolean` to `int`, additional argument in `nResetModifiers`, and a check against `MODIFIER_NONE` instead of checking the boolean value. These are changes in variable types and control statement expressions, so the change types are 3, 4, and 5.",There's no Compatibility Issue because the changes do not affect the behavior of the API from the caller's perspective. The method does not return any value (it's `void`) and there is no change in exception being thrown. The adjustment is internal to the method's implementation and does not alter the expected outcome of the method call.
618,<android.os.Looper: void loop()>,13,14,,,,"{
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    while (true) {
        // might block
        Message msg = queue.next();
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
            if (me.mLogging != null)
                me.mLogging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
            msg.target.dispatchMessage(msg);
            if (me.mLogging != null)
                me.mLogging.println(""<<<<< Finished to    "" + msg.target + "" "" + msg.callback);
            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(""Looper"", ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target + "" "" + msg.callback + "" what="" + msg.what);
            }
            msg.recycle();
        }
    }
}","{
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(""No Looper; Looper.prepare() wasn't called on this thread."");
    }
    MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    while (true) {
        // might block
        Message msg = queue.next();
        if (msg != null) {
            if (msg.target == null) {
                // No target is a magic identifier for the quit message.
                return;
            }
            long wallStart = 0;
            long threadStart = 0;
            // This must be in a local variable, in case a UI event sets the logger
            Printer logging = me.mLogging;
            if (logging != null) {
                logging.println("">>>>> Dispatching to "" + msg.target + "" "" + msg.callback + "": "" + msg.what);
                wallStart = SystemClock.currentTimeMicro();
                threadStart = SystemClock.currentThreadTimeMicro();
            }
            msg.target.dispatchMessage(msg);
            if (logging != null) {
                long wallTime = SystemClock.currentTimeMicro() - wallStart;
                long threadTime = SystemClock.currentThreadTimeMicro() - threadStart;
                logging.println(""<<<<< Finished to "" + msg.target + "" "" + msg.callback);
                if (logging instanceof Profiler) {
                    ((Profiler) logging).profile(msg, wallStart, wallTime, threadStart, threadTime);
                }
            }
            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, ""Thread identity changed from 0x"" + Long.toHexString(ident) + "" to 0x"" + Long.toHexString(newIdent) + "" while dispatching to "" + msg.target.getClass().getName() + "" "" + msg.callback + "" what="" + msg.what);
            }
            msg.recycle();
        }
    }
}",1,"/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
","/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
",0,,,0,,,,,,,"3,4",0,"The added code is about collecting timing information for logging and possibly profiling, which involves new local variables and if checks. This changes are classified as 4 (Other statement changed) for the new code related to logging and profiling, and as 3 (Control dependency changed) since the if statement as part of a control structure has been added.","Despite the added profiling and logging code, neither the return values nor the exceptions thrown are different between the early and late versions, hence there's no compatibility issue: the API behaves the same in terms of input-output contract from an external caller's point of view."
620,<android.widget.NumberPicker: void setMaxValue(int)>,13,14,,,,"{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    resetSelectorWheelIndices();
    updateInputTextView();
}","{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException(""maxValue must be >= 0"");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
}",1,"/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
","/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value.
 */
",0,,,0,,,,,,,4,0,"The method implementation only changes in the method that is called near the end: `resetSelectorWheelIndices()` has been replaced with `initializeSelectorWheelIndices()`, so the code change type is 4.","Considering that `resetSelectorWheelIndices()` was replaced with `initializeSelectorWheelIndices()`, and assuming that both methods have the intended effect of updating or initializing the indices related to the selector wheel without affecting the `setMaxValue` method's behavior, no potential Compatibility Issue should arise. The method's return value or exception behavior is not altered by this change. However, if `initializeSelectorWheelIndices()` behaves differently than `resetSelectorWheelIndices()`, which could not be determined without additional context, there might be a compatibility issue affecting external behavior. With the information given, it's classified as no Compatibility Issue."
621,<android.net.Uri.AbstractPart: void writeTo(Parcel)>,13,14,,,,"{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NOT_CACHED;
    @SuppressWarnings(""StringEquality"") boolean hasDecoded = decoded != NOT_CACHED;
    if (hasEncoded && hasDecoded) {
        parcel.writeInt(Representation.BOTH);
        parcel.writeString(encoded);
        parcel.writeString(decoded);
    } else if (hasEncoded) {
        parcel.writeInt(Representation.ENCODED);
        parcel.writeString(encoded);
    } else if (hasDecoded) {
        parcel.writeInt(Representation.DECODED);
        parcel.writeString(decoded);
    } else {
        throw new AssertionError();
    }
}","{
    @SuppressWarnings(""StringEquality"") boolean hasEncoded = encoded != NOT_CACHED;
    @SuppressWarnings(""StringEquality"") boolean hasDecoded = decoded != NOT_CACHED;
    if (hasEncoded && hasDecoded) {
        parcel.writeInt(Representation.BOTH);
        parcel.writeString(encoded);
        parcel.writeString(decoded);
    } else if (hasEncoded) {
        parcel.writeInt(Representation.ENCODED);
        parcel.writeString(encoded);
    } else if (hasDecoded) {
        parcel.writeInt(Representation.DECODED);
        parcel.writeString(decoded);
    } else {
        throw new IllegalArgumentException(""Neither encoded nor decoded"");
    }
}",1,,,0,,,0,,,,,,,2,2,"There's a change in the exception throw statement from 'throw new AssertionError()' to 'throw new IllegalArgumentException(""Neither encoded nor decoded"")', so the code change type is 2.","Since the type of exception thrown has changed from AssertionError to IllegalArgumentException, the API could now potentially throw a different exception when neither 'encoded' nor 'decoded' is cached, which is a change in exception handling behavior. Therefore, the CI type is 2."
623,"<android.provider.SyncStateContract.Helpers: byte[] get(ContentProviderClient,Uri,Account)>",13,14,,,,"{
    Cursor c = provider.query(uri, DATA_PROJECTION, SELECT_BY_ACCOUNT, new String[] { account.name, account.type }, null);
    try {
        if (c.moveToNext()) {
            return c.getBlob(c.getColumnIndexOrThrow(Columns.DATA));
        }
    } finally {
        c.close();
    }
    return null;
}","{
    Cursor c = provider.query(uri, DATA_PROJECTION, SELECT_BY_ACCOUNT, new String[] { account.name, account.type }, null);
    // Unable to query the provider
    if (c == null) {
        throw new RemoteException();
    }
    try {
        if (c.moveToNext()) {
            return c.getBlob(c.getColumnIndexOrThrow(Columns.DATA));
        }
    } finally {
        c.close();
    }
    return null;
}",1,"/**
 * Get the sync state that is associated with the account or null.
 * @param provider the {@link ContentProviderClient} that is to be used to communicate
 * with the {@link android.content.ContentProvider} that contains the sync state.
 * @param uri the uri of the sync state
 * @param account the {@link Account} whose sync state should be returned
 * @return the sync state or null if there is no sync state associated with the account
 * @throws RemoteException if there is a failure communicating with the remote
 * {@link android.content.ContentProvider}
 */
","/**
 * Get the sync state that is associated with the account or null.
 * @param provider the {@link ContentProviderClient} that is to be used to communicate
 * with the {@link android.content.ContentProvider} that contains the sync state.
 * @param uri the uri of the sync state
 * @param account the {@link Account} whose sync state should be returned
 * @return the sync state or null if there is no sync state associated with the account
 * @throws RemoteException if there is a failure communicating with the remote
 * {@link android.content.ContentProvider}
 */
",0,,,0,,,,,,,"2,3","1,2","The late version has introduced a new check that throws a new exception (RemoteException()) if the cursor is null and added a new comment. The code change types are 2,3 due to the new exception handling statement for a null cursor and the new comment indicating a change of control flow.","The introduction of throwing a new exception (RemoteException) when 'c' is null potentially changes the exception that clients will need to handle, and thus there might be a CI due to different exception handlings. This can lead to a CI type 2. In addition to the exception handling change, returning a value could potentially change if the cursor 'c' were null in the early version (previously it would return null, now it throws an exception), contributing to a CI type 1 as well."
624,<android.webkit.CookieSyncManager: CookieSyncManager createInstance(Context)>,13,14,,,,"{
    JniUtil.setContext(context);
    Context appContext = context.getApplicationContext();
    if (sRef == null) {
        sRef = new CookieSyncManager(appContext);
    }
    return sRef;
}","{
    if (context == null) {
        throw new IllegalArgumentException(""Invalid context argument"");
    }
    JniUtil.setContext(context);
    Context appContext = context.getApplicationContext();
    if (sRef == null) {
        sRef = new CookieSyncManager(appContext);
    }
    return sRef;
}",1,"/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
","/**
 * Create a singleton CookieSyncManager within a context
 * @param context
 * @return CookieSyncManager
 */
",0,,,0,,,,,,,3,2,"There is a new conditional statement introducing an exception handling for a null context parameter, so the code change type is 3.","The change introduces a Compatibility Issue due to the newly added exception handling for the null context argument, hence the CI type is 2. Previously, the method would not throw an exception if a null context was passed, but with the new version, it will throw an IllegalArgumentException, which is a different behavior."
629,<android.view.View: HardwareLayer getHardwareLayer()>,13,14,,,,"{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null) {
        return null;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.setEmpty();
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.setEmpty();
        }
        Canvas currentCanvas = mAttachInfo.mHardwareCanvas;
        final HardwareCanvas canvas = mHardwareLayer.start(currentCanvas);
        mAttachInfo.mHardwareCanvas = canvas;
        try {
            canvas.setViewport(width, height);
            canvas.onPreDraw(mLocalDirtyRect);
            mLocalDirtyRect.setEmpty();
            final int restoreCount = canvas.save();
            computeScroll();
            canvas.translate(-mScrollX, -mScrollY);
            mPrivateFlags |= DRAWN | DRAWING_CACHE_VALID;
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                mPrivateFlags &= ~DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
            canvas.restoreToCount(restoreCount);
        } finally {
            canvas.onPostDraw();
            mHardwareLayer.end(currentCanvas);
            mAttachInfo.mHardwareCanvas = currentCanvas;
        }
    }
    return mHardwareLayer;
}","{
    if (mAttachInfo == null || mAttachInfo.mHardwareRenderer == null || !mAttachInfo.mHardwareRenderer.isEnabled()) {
        return null;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    if (width == 0 || height == 0) {
        return null;
    }
    if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mHardwareLayer == null) {
        if (mHardwareLayer == null) {
            mHardwareLayer = mAttachInfo.mHardwareRenderer.createHardwareLayer(width, height, isOpaque());
            mLocalDirtyRect.setEmpty();
        } else if (mHardwareLayer.getWidth() != width || mHardwareLayer.getHeight() != height) {
            mHardwareLayer.resize(width, height);
            mLocalDirtyRect.setEmpty();
        }
        HardwareCanvas currentCanvas = mAttachInfo.mHardwareCanvas;
        final HardwareCanvas canvas = mHardwareLayer.start(currentCanvas);
        mAttachInfo.mHardwareCanvas = canvas;
        try {
            canvas.setViewport(width, height);
            canvas.onPreDraw(mLocalDirtyRect);
            mLocalDirtyRect.setEmpty();
            final int restoreCount = canvas.save();
            computeScroll();
            canvas.translate(-mScrollX, -mScrollY);
            mPrivateFlags |= DRAWN | DRAWING_CACHE_VALID;
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                mPrivateFlags &= ~DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
            canvas.restoreToCount(restoreCount);
        } finally {
            canvas.onPostDraw();
            mHardwareLayer.end(currentCanvas);
            mAttachInfo.mHardwareCanvas = currentCanvas;
        }
    }
    return mHardwareLayer;
}",1,"/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
","/**
 * <p>Returns a hardware layer that can be used to draw this view again
 * without executing its draw method.</p>
 *
 * @return A HardwareLayer ready to render, or null if an error occurred.
 */
",0,,,0,,,,,,,3,1,"There is an additional condition check in the 'if' statement: !mAttachInfo.mHardwareRenderer.isEnabled(). This is a control dependency change, which potentially alters when the method returns null, making the change type 3.","Since there is a new condition under which the method will return null, there is a potential Compatibility Issue due to the API possibly returning a different value (null in cases where mAttachInfo.mHardwareRenderer.isEnabled() returns false). Thus, the CI type is 1."
632,"<android.database.CursorWindow: short getShort(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return (short) getLong_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    return (short) getLong(row, column);
}",1,"/**
 * Returns a short for the given field.
 * row is 0 based
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a short value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a
 * <code>short</code>.
 * <p>
 * The result is determined by invoking {@link #getLong} and converting the
 * result to <code>short</code>.
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a <code>short</code>.
 */
",1,,,0,,,,,,,"1,4,5",1,"The return statement changed from using getLong_native() to getLong(). The control flow for resource management (acquire/release reference) has been removed, and dependent API changed from getLong_native(int, int) to getLong(int, int), so the code change type is 1,4,5.","The change in the implementation of getting the long value and casting it to short, as well as the removal of reference management, can lead to the API returning different values under certain conditions (like if getLong() behaves differently from getLong_native() or incurs a different exception). Therefore, the CI type is 1."
633,"<android.view.GLES20Canvas: void drawTextRun(CharSequence,int,int,int,int,float,float,int,Paint)>",13,14,,,,"{
    if ((start | end | end - start | text.length() - end) < 0) {
        throw new IndexOutOfBoundsException();
    }
    boolean hasModifier = setupModifiers(paint);
    try {
        int flags = dir == 0 ? 0 : 1;
        if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
            nDrawTextRun(mRenderer, text.toString(), start, end, contextStart, contextEnd, x, y, flags, paint.mNativePaint);
        } else if (text instanceof GraphicsOperations) {
            ((GraphicsOperations) text).drawTextRun(this, start, end, contextStart, contextEnd, x, y, flags, paint);
        } else {
            int contextLen = contextEnd - contextStart;
            int len = end - start;
            char[] buf = TemporaryBuffer.obtain(contextLen);
            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);
            nDrawTextRun(mRenderer, buf, start - contextStart, len, 0, contextLen, x, y, flags, paint.mNativePaint);
            TemporaryBuffer.recycle(buf);
        }
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    if ((start | end | end - start | text.length() - end) < 0) {
        throw new IndexOutOfBoundsException();
    }
    int modifiers = setupModifiers(paint);
    try {
        int flags = dir == 0 ? 0 : 1;
        if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
            nDrawTextRun(mRenderer, text.toString(), start, end, contextStart, contextEnd, x, y, flags, paint.mNativePaint);
        } else if (text instanceof GraphicsOperations) {
            ((GraphicsOperations) text).drawTextRun(this, start, end, contextStart, contextEnd, x, y, flags, paint);
        } else {
            int contextLen = contextEnd - contextStart;
            int len = end - start;
            char[] buf = TemporaryBuffer.obtain(contextLen);
            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);
            nDrawTextRun(mRenderer, buf, start - contextStart, len, 0, contextLen, x, y, flags, paint.mNativePaint);
            TemporaryBuffer.recycle(buf);
        }
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The variable name `hasModifier` changed to `modifiers` and the value check in the `finally` block is different (`hasModifier` vs `modifiers != MODIFIER_NONE`) along with an extra argument `modifiers` passed to `nResetModifiers`. These changes do not affect the return type, value, or exceptions thrown, so the code change type is 4.","Since these changes do not affect the external behavior of the API—no difference in the return value, the type of return value, and exception handling—the changes are internal and will not cause compatibility issues. Therefore, there is no CI."
634,"<android.app.ContextImpl: boolean startInstrumentation(ComponentName,String,Bundle)>",13,14,,,,"{
    try {
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null);
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}","{
    try {
        if (arguments != null) {
            arguments.setAllowFds(false);
        }
        return ActivityManagerNative.getDefault().startInstrumentation(className, profileFile, 0, arguments, null);
    } catch (RemoteException e) {
    // System has crashed, nothing we can do.
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There is an addition of an if statement that calls arguments.setAllowFds(false), which is classified as a control dependency change (3). Since the if statement changes a property of `arguments`, it is also an other statement change (4).","Despite the code changes, there is no Compatibility Issue because the behavior of the API has not altered in a way that would cause it to return different values or throw different exceptions under the same input conditions. The return value is still contingent upon the result of ActivityManagerNative.getDefault().startInstrumentation(), and failure still results in returning false without throwing any exception. The added if statement does not impact these behaviors but ensures that file descriptors are not allowed in the `arguments`, which doesn't affect the API's return value or exception handling."
637,"<com.google.android.mms.pdu.PduPersister: Uri persistPart(PduPart,long)>",13,14,,,,"{
    Uri uri = Uri.parse(""content://mms/"" + msgId + ""/part"");
    ContentValues values = new ContentValues(8);
    int charset = part.getCharset();
    if (charset != 0) {
        values.put(Part.CHARSET, charset);
    }
    String contentType = null;
    if (part.getContentType() != null) {
        contentType = toIsoString(part.getContentType());
        values.put(Part.CONTENT_TYPE, contentType);
        // To ensure the SMIL part is always the first part.
        if (ContentType.APP_SMIL.equals(contentType)) {
            values.put(Part.SEQ, -1);
        }
    } else {
        throw new MmsException(""MIME type of the part must be set."");
    }
    if (part.getFilename() != null) {
        String fileName = new String(part.getFilename());
        values.put(Part.FILENAME, fileName);
    }
    if (part.getName() != null) {
        String name = new String(part.getName());
        values.put(Part.NAME, name);
    }
    Object value = null;
    if (part.getContentDisposition() != null) {
        value = toIsoString(part.getContentDisposition());
        values.put(Part.CONTENT_DISPOSITION, (String) value);
    }
    if (part.getContentId() != null) {
        value = toIsoString(part.getContentId());
        values.put(Part.CONTENT_ID, (String) value);
    }
    if (part.getContentLocation() != null) {
        value = toIsoString(part.getContentLocation());
        values.put(Part.CONTENT_LOCATION, (String) value);
    }
    Uri res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
    if (res == null) {
        throw new MmsException(""Failed to persist part, return null."");
    }
    persistData(part, res, contentType);
    // After successfully store the data, we should update
    // the dataUri of the part.
    part.setDataUri(res);
    return res;
}","{
    Uri uri = Uri.parse(""content://mms/"" + msgId + ""/part"");
    ContentValues values = new ContentValues(8);
    int charset = part.getCharset();
    if (charset != 0) {
        values.put(Part.CHARSET, charset);
    }
    String contentType = null;
    if (part.getContentType() != null) {
        contentType = toIsoString(part.getContentType());
        // Change it to ""image/jpeg""
        if (ContentType.IMAGE_JPG.equals(contentType)) {
            contentType = ContentType.IMAGE_JPEG;
        }
        values.put(Part.CONTENT_TYPE, contentType);
        // To ensure the SMIL part is always the first part.
        if (ContentType.APP_SMIL.equals(contentType)) {
            values.put(Part.SEQ, -1);
        }
    } else {
        throw new MmsException(""MIME type of the part must be set."");
    }
    if (part.getFilename() != null) {
        String fileName = new String(part.getFilename());
        values.put(Part.FILENAME, fileName);
    }
    if (part.getName() != null) {
        String name = new String(part.getName());
        values.put(Part.NAME, name);
    }
    Object value = null;
    if (part.getContentDisposition() != null) {
        value = toIsoString(part.getContentDisposition());
        values.put(Part.CONTENT_DISPOSITION, (String) value);
    }
    if (part.getContentId() != null) {
        value = toIsoString(part.getContentId());
        values.put(Part.CONTENT_ID, (String) value);
    }
    if (part.getContentLocation() != null) {
        value = toIsoString(part.getContentLocation());
        values.put(Part.CONTENT_LOCATION, (String) value);
    }
    Uri res = SqliteWrapper.insert(mContext, mContentResolver, uri, values);
    if (res == null) {
        throw new MmsException(""Failed to persist part, return null."");
    }
    persistData(part, res, contentType);
    // After successfully store the data, we should update
    // the dataUri of the part.
    part.setDataUri(res);
    return res;
}",1,,,0,,,0,,,,,,,"1,4",1,"The method implementation has changed where the contentType is now being specifically checked for ContentType.IMAGE_JPG and, if so, is being replaced with ContentType.IMAGE_JPEG in the ContentValues. This is a change in a regular statement which does affect the data being put into 'values', categorized as 4. Since this statement influences what is being stored in the content values and subsequently affects what will be persisted in 'uri', this leads to a changed return type, because a different content type may be set for the persisted part, categorized as 1.","As this change directly affects what kind of content type is saved in the database and returned when the part is persisted, it can lead to different values being returned. Therefore, the CI type is 1."
638,<android.server.BluetoothService: int getInputDevicePriority(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothInputProfileHandler.getInputDevicePriority(device);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.getInputDevicePriority(device);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"A new 'synchronized' block has been added around the return statement, which is control dependency change, and thus denotes a change type 3. Since adding 'synchronized' does not inherently change the behavior or the value returned by the method, it is also classified under other statement changed, which is type 4.","The addition of a synchronized block does not change the return value or the nature of the exceptions this method could throw. It simply ensures thread-safety for the critical section. Therefore, there is no Compatibility Issue, and the CI type is 0."
639,<android.widget.TextView.HandleView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(mController.getCurrentOffset(this));
                mDownPositionX = ev.getRawX();
                mDownPositionY = ev.getRawY();
                mTouchToWindowOffsetX = mDownPositionX - mPositionX;
                mTouchToWindowOffsetY = mDownPositionY - mPositionY;
                final int[] coords = mTempCoords;
                TextView.this.getLocationInWindow(coords);
                mLastParentX = coords[0];
                mLastParentY = coords[1];
                mIsDragging = true;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float rawX = ev.getRawX();
                final float rawY = ev.getRawY();
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = rawY - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = rawX - mTouchToWindowOffsetX + mHotspotX;
                final float newPosY = rawY - mTouchToWindowOffsetY + mTouchOffsetY;
                mController.updatePosition(this, Math.round(newPosX), Math.round(newPosY));
                break;
            }
        case MotionEvent.ACTION_UP:
            if (mIsInsertionHandle) {
                final float deltaX = mDownPositionX - ev.getRawX();
                final float deltaY = mDownPositionY - ev.getRawY();
                final float distanceSquared = deltaX * deltaX + deltaY * deltaY;
                if (distanceSquared < mSquaredTouchSlopDistance) {
                    if (mPastePopupWindow != null && mPastePopupWindow.isShowing()) {
                        // Tapping on the handle dismisses the displayed paste view,
                        mPastePopupWindow.hide();
                    } else {
                        ((InsertionPointCursorController) mController).show(0);
                    }
                }
            }
            filterOnTouchUp();
            mIsDragging = false;
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            break;
    }
    return true;
}","{
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            {
                startTouchUpFilter(getCurrentCursorOffset());
                mTouchToWindowOffsetX = ev.getRawX() - mPositionX;
                mTouchToWindowOffsetY = ev.getRawY() - mPositionY;
                final PositionListener positionListener = getPositionListener();
                mLastParentX = positionListener.getPositionX();
                mLastParentY = positionListener.getPositionY();
                mIsDragging = true;
                break;
            }
        case MotionEvent.ACTION_MOVE:
            {
                final float rawX = ev.getRawX();
                final float rawY = ev.getRawY();
                // Vertical hysteresis: vertical down movement tends to snap to ideal offset
                final float previousVerticalOffset = mTouchToWindowOffsetY - mLastParentY;
                final float currentVerticalOffset = rawY - mPositionY - mLastParentY;
                float newVerticalOffset;
                if (previousVerticalOffset < mIdealVerticalOffset) {
                    newVerticalOffset = Math.min(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.max(newVerticalOffset, previousVerticalOffset);
                } else {
                    newVerticalOffset = Math.max(currentVerticalOffset, mIdealVerticalOffset);
                    newVerticalOffset = Math.min(newVerticalOffset, previousVerticalOffset);
                }
                mTouchToWindowOffsetY = newVerticalOffset + mLastParentY;
                final float newPosX = rawX - mTouchToWindowOffsetX + mHotspotX;
                final float newPosY = rawY - mTouchToWindowOffsetY + mTouchOffsetY;
                updatePosition(newPosX, newPosY);
                break;
            }
        case MotionEvent.ACTION_UP:
            filterOnTouchUp();
            mIsDragging = false;
            break;
        case MotionEvent.ACTION_CANCEL:
            mIsDragging = false;
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,The code has undergone several changes:,- The way to obtain mLastParentX and mLastParentY values has changed: removed TextView.this.getLocationInWindow(coords) and used getPositionListener().getPositionX/Y() instead.
640,"<android.view.GLES20Canvas: void drawText(CharSequence,int,int,float,float,Paint)>",13,14,,,,"{
    boolean hasModifier = setupModifiers(paint);
    try {
        if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
            nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
        } else if (text instanceof GraphicsOperations) {
            ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
        } else {
            char[] buf = TemporaryBuffer.obtain(end - start);
            TextUtils.getChars(text, start, end, buf, 0);
            nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint);
            TemporaryBuffer.recycle(buf);
        }
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    int modifiers = setupModifiers(paint);
    try {
        if (text instanceof String || text instanceof SpannedString || text instanceof SpannableString) {
            nDrawText(mRenderer, text.toString(), start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
        } else if (text instanceof GraphicsOperations) {
            ((GraphicsOperations) text).drawText(this, start, end, x, y, paint);
        } else {
            char[] buf = TemporaryBuffer.obtain(end - start);
            TextUtils.getChars(text, start, end, buf, 0);
            nDrawText(mRenderer, buf, 0, end - start, x, y, paint.mBidiFlags, paint.mNativePaint);
            TemporaryBuffer.recycle(buf);
        }
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",0,"The variable type and name for tracking paint modifiers has been changed from 'boolean hasModifier' to 'int modifiers', and hence the method used to reset modifiers has also changed to include the passed modifier values (nResetModifiers(mRenderer, modifiers)), so the code change type is 1,4.","There is no compatibility issue detected because these changes don't influence the behavior seen by the caller of the method. The method does not change its return type as it is void, and it does not introduce new exceptions or change the values passed back to the caller. The changes are internal to the handling of paint modifiers and will not affect the functionality from the perspective of the API user."
641,<android.accounts.AccountManagerService.TestFeaturesSession: void onResult(Bundle)>,13,14,,,,"{
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        try {
            if (result == null) {
                onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle"");
                return;
            }
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
            }
            final Bundle newResult = new Bundle();
            newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));
            response.onResult(newResult);
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}","{
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        try {
            if (result == null) {
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, ""null bundle"");
                return;
            }
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, getClass().getSimpleName() + "" calling onResult() on response "" + response);
            }
            final Bundle newResult = new Bundle();
            newResult.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false));
            response.onResult(newResult);
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""failure while notifying response"", e);
            }
        }
    }
}",1,,,0,,,0,,,,,,,2,2,"Exception handling statement changed. The method used to call 'onError' on 'this' now calls 'response.onError' in the case result is null, so the change type is 2.","The API will now throw a different exception in the case that result is null, where previously it handled the error internally. This is a potential CI caused by different exception handling, type 2."
643,<android.widget.AdapterViewAnimator: void setRemoteViewsAdapter(Intent)>,13,14,,,,"{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteViewsAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteViewsAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}","{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        Intent.FilterComparison fcNew = new Intent.FilterComparison(intent);
        Intent.FilterComparison fcOld = new Intent.FilterComparison(mRemoteViewsAdapter.getRemoteViewsServiceIntent());
        if (fcNew.equals(fcOld)) {
            return;
        }
    }
    mDeferNotifyDataSetChanged = false;
    // Otherwise, create a new RemoteViewsAdapter for binding
    mRemoteViewsAdapter = new RemoteViewsAdapter(getContext(), intent, this);
}",1,"/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
","/**
 * Sets up this AdapterViewAnimator to use a remote views adapter which connects to a
 * RemoteViewsService through the specified intent.
 *
 * @param intent the intent used to identify the RemoteViewsService for the adapter to
 * connect to.
 */
",0,[@android.view.RemotableViewMethod],[@android.view.RemotableViewMethod],0,,,,,,,4,0,"A new statement (mDeferNotifyDataSetChanged = false;) has been introduced that is not related to return statements, exception handling, or control dependency. It seems to be a state change within the Class itself, so the code change type is 4.","The introduction of the new statement does not affect the method's return value or exception handling behavior. Thus, there is no Compatibility Issue, and the CI type is 0."
644,"<android.content.res.Configuration: void writeToParcel(Parcel,int)>",13,14,,,,"{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(seq);
}","{
    dest.writeFloat(fontScale);
    dest.writeInt(mcc);
    dest.writeInt(mnc);
    if (locale == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeString(locale.getLanguage());
        dest.writeString(locale.getCountry());
        dest.writeString(locale.getVariant());
    }
    if (userSetLocale) {
        dest.writeInt(1);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(touchscreen);
    dest.writeInt(keyboard);
    dest.writeInt(keyboardHidden);
    dest.writeInt(hardKeyboardHidden);
    dest.writeInt(navigation);
    dest.writeInt(navigationHidden);
    dest.writeInt(orientation);
    dest.writeInt(screenLayout);
    dest.writeInt(uiMode);
    dest.writeInt(screenWidthDp);
    dest.writeInt(screenHeightDp);
    dest.writeInt(smallestScreenWidthDp);
    dest.writeInt(compatScreenWidthDp);
    dest.writeInt(compatScreenHeightDp);
    dest.writeInt(compatSmallestScreenWidthDp);
    dest.writeInt(textLayoutDirection);
    dest.writeInt(seq);
}",1,,,0,,,0,,,,,,,4,0,"A single line of code has been added that writes a new value (`textLayoutDirection`) into the parcel. Since this is just an additional piece of data being written out without any modification to the existing data or flow control, the change type is 4.","There is no Compatibility Issue because the change is backward compatible. Older versions of the API do not expect the `textLayoutDirection` value, and newer versions of the API will include it but this won't affect old clients that are not reading this new field. The method signature remains the same and there is no change in the behavior that would affect old clients negatively, therefore the CI type is 0."
647,<android.hardware.Camera.EventHandler: void handleMessage(Message)>,13,14,,,,"{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}","{
    switch(msg.what) {
        case CAMERA_MSG_SHUTTER:
            if (mShutterCallback != null) {
                mShutterCallback.onShutter();
            }
            return;
        case CAMERA_MSG_RAW_IMAGE:
            if (mRawImageCallback != null) {
                mRawImageCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_COMPRESSED_IMAGE:
            if (mJpegCallback != null) {
                mJpegCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_FRAME:
            if (mPreviewCallback != null) {
                PreviewCallback cb = mPreviewCallback;
                if (mOneShot) {
                    // Clear the callback variable before the callback
                    // in case the app calls setPreviewCallback from
                    // the callback function
                    mPreviewCallback = null;
                } else if (!mWithBuffer) {
                    // We're faking the camera preview mode to prevent
                    // the app from being flooded with preview frames.
                    // Set to oneshot mode again.
                    setHasPreviewCallback(true, false);
                }
                cb.onPreviewFrame((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_POSTVIEW_FRAME:
            if (mPostviewCallback != null) {
                mPostviewCallback.onPictureTaken((byte[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_FOCUS:
            if (mAutoFocusCallback != null) {
                mAutoFocusCallback.onAutoFocus(msg.arg1 == 0 ? false : true, mCamera);
            }
            return;
        case CAMERA_MSG_ZOOM:
            if (mZoomListener != null) {
                mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera);
            }
            return;
        case CAMERA_MSG_PREVIEW_METADATA:
            if (mFaceListener != null) {
                mFaceListener.onFaceDetection((Face[]) msg.obj, mCamera);
            }
            return;
        case CAMERA_MSG_ERROR:
            Log.e(TAG, ""Error "" + msg.arg1);
            if (mErrorCallback != null) {
                mErrorCallback.onError(msg.arg1, mCamera);
            }
            return;
        default:
            Log.e(TAG, ""Unknown message type "" + msg.what);
            return;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The change involves the addition of a new 'case' statement (CAMERA_MSG_PREVIEW_METADATA) in the 'switch' block. Therefore, the change type is both a control dependency change (3) due to the change within the 'switch' statement and a new 'other statement' (4).",There is no Compatibility Issue detected because the addition of a new case for CAMERA_MSG_PREVIEW_METADATA does not affect the existing functionality or alter the behavior of previously defined cases. Existing clients that do not send CAMERA_MSG_PREVIEW_METADATA will observe no difference in behavior.
651,<android.webkit.WebView: void requestFocusNodeHref(Message)>,13,14,,,,"{
    if (hrefMsg == null) {
        return;
    }
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    if (nativeHasCursorNode()) {
        Rect cursorBounds = nativeGetCursorRingBounds();
        if (!cursorBounds.contains(contentX, contentY)) {
            int slop = viewToContentDimension(mNavSlop);
            cursorBounds.inset(-slop, -slop);
            if (cursorBounds.contains(contentX, contentY)) {
                contentX = (int) cursorBounds.centerX();
                contentY = (int) cursorBounds.centerY();
            }
        }
    }
    mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF, contentX, contentY, hrefMsg);
}","{
    checkThread();
    if (hrefMsg == null) {
        return;
    }
    int contentX = viewToContentX(mLastTouchX + mScrollX);
    int contentY = viewToContentY(mLastTouchY + mScrollY);
    if (nativeHasCursorNode()) {
        Rect cursorBounds = nativeGetCursorRingBounds();
        if (!cursorBounds.contains(contentX, contentY)) {
            int slop = viewToContentDimension(mNavSlop);
            cursorBounds.inset(-slop, -slop);
            if (cursorBounds.contains(contentX, contentY)) {
                contentX = (int) cursorBounds.centerX();
                contentY = (int) cursorBounds.centerY();
            }
        }
    }
    mWebViewCore.sendMessage(EventHub.REQUEST_CURSOR_HREF, contentX, contentY, hrefMsg);
}",1,"/**
 * Request the anchor or image element URL at the last tapped point.
 * If hrefMsg is null, this method returns immediately and does not
 * dispatch hrefMsg to its target. If the tapped point hits an image,
 * an anchor, or an image in an anchor, the message associates
 * strings in named keys in its data. The value paired with the key
 * may be an empty string.
 *
 * @param hrefMsg This message will be dispatched with the result of the
 * request. The message data contains three keys:
 * - ""url"" returns the anchor's href attribute.
 * - ""title"" returns the anchor's text.
 * - ""src"" returns the image's src attribute.
 */
","/**
 * Request the anchor or image element URL at the last tapped point.
 * If hrefMsg is null, this method returns immediately and does not
 * dispatch hrefMsg to its target. If the tapped point hits an image,
 * an anchor, or an image in an anchor, the message associates
 * strings in named keys in its data. The value paired with the key
 * may be an empty string.
 *
 * @param hrefMsg This message will be dispatched with the result of the
 * request. The message data contains three keys:
 * - ""url"" returns the anchor's href attribute.
 * - ""title"" returns the anchor's text.
 * - ""src"" returns the image's src attribute.
 */
",0,,,0,,,,,,,4,0,"There's an addition of the checkThread() method call at the beginning of the method, which is a change type of 4 (Other statement changed).","The added checkThread() method is likely used for ensuring that the code is running on the correct thread. As long as checkThread() does not throw an exception or otherwise alter program flow, the operation of requestFocusNodeHref remains the same. Thus, there is no change in behavior concerning return values/types or exceptions that are thrown, which means no Compatibility Issue has arisen due to this change."
652,"<android.view.View: void setLayerType(int,Paint)>",13,14,,,,"{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_SOFTWARE:
            if (mDrawingCache != null) {
                mDrawingCache.recycle();
                mDrawingCache = null;
            }
            if (mUnscaledDrawingCache != null) {
                mUnscaledDrawingCache.recycle();
                mUnscaledDrawingCache = null;
            }
            break;
        case LAYER_TYPE_HARDWARE:
            if (mHardwareLayer != null) {
                mHardwareLayer.destroy();
                mHardwareLayer = null;
            }
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}","{
    if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {
        throw new IllegalArgumentException(""Layer type can only be one of: LAYER_TYPE_NONE, "" + ""LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE"");
    }
    if (layerType == mLayerType) {
        if (layerType != LAYER_TYPE_NONE && paint != mLayerPaint) {
            mLayerPaint = paint == null ? new Paint() : paint;
            invalidateParentCaches();
            invalidate(true);
        }
        return;
    }
    // Destroy any previous software drawing cache if needed
    switch(mLayerType) {
        case LAYER_TYPE_HARDWARE:
            destroyLayer();
        // fall through - unaccelerated views may use software layer mechanism instead
        case LAYER_TYPE_SOFTWARE:
            destroyDrawingCache();
            break;
        default:
            break;
    }
    mLayerType = layerType;
    final boolean layerDisabled = mLayerType == LAYER_TYPE_NONE;
    mLayerPaint = layerDisabled ? null : (paint == null ? new Paint() : paint);
    mLocalDirtyRect = layerDisabled ? null : new Rect();
    invalidateParentCaches();
    invalidate(true);
}",1,"/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
","/**
 * <p>Specifies the type of layer backing this view. The layer can be
 * {@link #LAYER_TYPE_NONE disabled}, {@link #LAYER_TYPE_SOFTWARE software} or
 * {@link #LAYER_TYPE_HARDWARE hardware}.</p>
 *
 * <p>A layer is associated with an optional {@link android.graphics.Paint}
 * instance that controls how the layer is composed on screen. The following
 * properties of the paint are taken into account when composing the layer:</p>
 * <ul>
 * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}</li>
 * <li>{@link android.graphics.Paint#getXfermode() Blending mode}</li>
 * <li>{@link android.graphics.Paint#getColorFilter() Color filter}</li>
 * </ul>
 *
 * <p>If this view has an alpha value set to < 1.0 by calling
 * {@link #setAlpha(float)}, the alpha value of the layer's paint is replaced by
 * this view's alpha value. Calling {@link #setAlpha(float)} is therefore
 * equivalent to setting a hardware layer on this view and providing a paint with
 * the desired alpha value.<p>
 *
 * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE disabled},
 * {@link #LAYER_TYPE_SOFTWARE software} and {@link #LAYER_TYPE_HARDWARE hardware}
 * for more information on when and how to use layers.</p>
 *
 * @param layerType The ype of layer to use with this view, must be one of
 * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or
 * {@link #LAYER_TYPE_HARDWARE}
 * @param paint The paint used to compose the layer. This argument is optional
 * and can be null. It is ignored when the layer type is
 * {@link #LAYER_TYPE_NONE}
 *
 * @see #getLayerType()
 * @see #LAYER_TYPE_NONE
 * @see #LAYER_TYPE_SOFTWARE
 * @see #LAYER_TYPE_HARDWARE
 * @see #setAlpha(float)
 *
 * @attr ref android.R.styleable#View_layerType
 */
",0,,,0,,,,,,,"3,4",0,"The change occurred in the switch statement, where the case LAYER_TYPE_SOFTWARE was modified by merging its content with the case LAYER_TYPE_HARDWARE and removing specific recycling calls. Additionally, some method calls within the switch statement were changed to call ""destroyLayer()"" instead of directly manipulating ""mHardwareLayer"" and to call ""destroyDrawingCache()"" instead of recycling drawing caches directly. This implies that there are other statement changes and changes in control dependency.","There is no Compatibility Issue arising from this change since the logic for handling different layer types still preserves the functional behavior. Even though the method calls have been refactored, the pre-conditions for calling them and their post-conditions appear to be consistent with the existing behavior, so there would be no difference in exception handling or return values."
653,"<android.content.ContentProviderProxy: Bundle call(String,String,Bundle)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    data.writeString(method);
    data.writeString(request);
    data.writeBundle(args);
    mRemote.transact(IContentProvider.CALL_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    Bundle bundle = reply.readBundle();
    data.recycle();
    reply.recycle();
    return bundle;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        data.writeString(method);
        data.writeString(request);
        data.writeBundle(args);
        mRemote.transact(IContentProvider.CALL_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        Bundle bundle = reply.readBundle();
        return bundle;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The early version doesn't use try-finally blocks for recycling Parcel objects, whereas the late version adds a try-finally block to ensure Parcel objects are recycled. This is a change of control dependency (introduction of try-finally) and other statements changed (adding finally block with recycle calls), so the code change type is 3,4.","Despite these changes, the behavior of the API in terms of what values it returns and exceptions it may throw, assuming no errors in the Parcel operations, remains consistent between versions. There is no change that would affect the values returned from this method or exception handling that could result in a compatibility issue. Hence, there is no compatibility issue."
654,"<android.content.SearchRecentSuggestionsProvider: void setupSuggestions(String,int)>",13,14,,,,"{
    if (TextUtils.isEmpty(authority) || ((mode & DATABASE_MODE_QUERIES) == 0)) {
        throw new IllegalArgumentException();
    }
    // unpack mode flags
    mTwoLineDisplay = (0 != (mode & DATABASE_MODE_2LINES));
    // saved values
    mAuthority = new String(authority);
    mMode = mode;
    // derived values
    mSuggestionsUri = Uri.parse(""content://"" + mAuthority + ""/suggestions"");
    mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mUriMatcher.addURI(mAuthority, SearchManager.SUGGEST_URI_PATH_QUERY, URI_MATCH_SUGGEST);
    if (mTwoLineDisplay) {
        mSuggestSuggestionClause = ""display1 LIKE ? OR display2 LIKE ?"";
        mSuggestionProjection = new String[] { ""0 AS "" + SearchManager.SUGGEST_COLUMN_FORMAT, ""display1 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_1, ""display2 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_2, ""query AS "" + SearchManager.SUGGEST_COLUMN_QUERY, ""_id"" };
    } else {
        mSuggestSuggestionClause = ""display1 LIKE ?"";
        mSuggestionProjection = new String[] { ""0 AS "" + SearchManager.SUGGEST_COLUMN_FORMAT, ""display1 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_1, ""query AS "" + SearchManager.SUGGEST_COLUMN_QUERY, ""_id"" };
    }
}","{
    if (TextUtils.isEmpty(authority) || ((mode & DATABASE_MODE_QUERIES) == 0)) {
        throw new IllegalArgumentException();
    }
    // unpack mode flags
    mTwoLineDisplay = (0 != (mode & DATABASE_MODE_2LINES));
    // saved values
    mAuthority = new String(authority);
    mMode = mode;
    // derived values
    mSuggestionsUri = Uri.parse(""content://"" + mAuthority + ""/suggestions"");
    mUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mUriMatcher.addURI(mAuthority, SearchManager.SUGGEST_URI_PATH_QUERY, URI_MATCH_SUGGEST);
    if (mTwoLineDisplay) {
        mSuggestSuggestionClause = ""display1 LIKE ? OR display2 LIKE ?"";
        mSuggestionProjection = new String[] { ""0 AS "" + SearchManager.SUGGEST_COLUMN_FORMAT, ""'android.resource://system/"" + com.android.internal.R.drawable.ic_menu_recent_history + ""' AS "" + SearchManager.SUGGEST_COLUMN_ICON_1, ""display1 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_1, ""display2 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_2, ""query AS "" + SearchManager.SUGGEST_COLUMN_QUERY, ""_id"" };
    } else {
        mSuggestSuggestionClause = ""display1 LIKE ?"";
        mSuggestionProjection = new String[] { ""0 AS "" + SearchManager.SUGGEST_COLUMN_FORMAT, ""'android.resource://system/"" + com.android.internal.R.drawable.ic_menu_recent_history + ""' AS "" + SearchManager.SUGGEST_COLUMN_ICON_1, ""display1 AS "" + SearchManager.SUGGEST_COLUMN_TEXT_1, ""query AS "" + SearchManager.SUGGEST_COLUMN_QUERY, ""_id"" };
    }
}",1,"/**
 * In order to use this class, you must extend it, and call this setup function from your
 * constructor.  In your application or activities, you must provide the same values when
 * you create the {@link android.provider.SearchRecentSuggestions} helper.
 *
 * @param authority This must match the authority that you've declared in your manifest.
 * @param mode You can use mode flags here to determine certain functional aspects of your
 * database.  Note, this value should not change from run to run, because when it does change,
 * your suggestions database may be wiped.
 *
 * @see #DATABASE_MODE_QUERIES
 * @see #DATABASE_MODE_2LINES
 */
","/**
 * In order to use this class, you must extend it, and call this setup function from your
 * constructor.  In your application or activities, you must provide the same values when
 * you create the {@link android.provider.SearchRecentSuggestions} helper.
 *
 * @param authority This must match the authority that you've declared in your manifest.
 * @param mode You can use mode flags here to determine certain functional aspects of your
 * database.  Note, this value should not change from run to run, because when it does change,
 * your suggestions database may be wiped.
 *
 * @see #DATABASE_MODE_QUERIES
 * @see #DATABASE_MODE_2LINES
 */
",0,,,0,,,,,,,4,0,"The assignment to the `mSuggestionProjection` variable has changed by adding a new constant string for `SearchManager.SUGGEST_COLUMN_ICON_1`. This is counted as an 'Other statement changed', so the code change type is 4.","Despite the change in the assignment to `mSuggestionProjection`, this doesn't constitute a compatibility issue because it doesn't change the method's signature, return type, or throw any new exceptions; it merely changes the content of an array which is internal to the implementation. This sort of change typically won't affect existing clients of the API, assuming they are correctly using constants defined in `SearchManager` for column names rather than relying on the array positions. Therefore, we classify this as 'No Compatibility Issue', CI type 0."
656,"<android.os.Bundle: void writeToParcel(Parcel,int)>",13,14,,,,"{
    if (mParcelledData != null) {
        int length = mParcelledData.dataSize();
        parcel.writeInt(length);
        // 'B' 'N' 'D' 'L'
        parcel.writeInt(0x4C444E42);
        parcel.appendFrom(mParcelledData, 0, length);
    } else {
        // dummy, will hold length
        parcel.writeInt(-1);
        // 'B' 'N' 'D' 'L'
        parcel.writeInt(0x4C444E42);
        int oldPos = parcel.dataPosition();
        parcel.writeMapInternal(mMap);
        int newPos = parcel.dataPosition();
        // Backpatch length
        parcel.setDataPosition(oldPos - 8);
        int length = newPos - oldPos;
        parcel.writeInt(length);
        parcel.setDataPosition(newPos);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            // 'B' 'N' 'D' 'L'
            parcel.writeInt(0x4C444E42);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            // dummy, will hold length
            parcel.writeInt(-1);
            // 'B' 'N' 'D' 'L'
            parcel.writeInt(0x4C444E42);
            int oldPos = parcel.dataPosition();
            parcel.writeMapInternal(mMap);
            int newPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(oldPos - 8);
            int length = newPos - oldPos;
            parcel.writeInt(length);
            parcel.setDataPosition(newPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",0,,,0,,,,,,,"3,4",0,"The late version implementation has wrapped the original code inside a `try-finally` block along with two new method calls from the `Parcel` class: `pushAllowFds` and `restoreAllowFds`. The control flow and some other statements are added, so the change type is 3,4.","Despite the addition of the `try-finally` block and two new method calls, these changes do not affect the behavior of `writeToParcel` in terms of what it writes to the parcel or the exceptions it might throw. The `pushAllowFds` and `restoreAllowFds` manage the file descriptor behavior inside the `Parcel`, but they do not change the serialized representation of the `Bundle`. The method still writes the same data, so this code change does not introduce any compatibility issues, and the CI type is 0."
657,<android.nfc.tech.BasicTagTechnology: void close()>,13,14,,,,"{
    try {
        /* Note that we don't want to physically disconnect the tag,
             * but just reconnect to it to reset its state
             */
        mTag.getTagService().reconnect(mTag.getServiceHandle());
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    } finally {
        mIsConnected = false;
        mTag.setTechnologyDisconnected();
    }
}","{
    try {
        /* Note that we don't want to physically disconnect the tag,
             * but just reconnect to it to reset its state
             */
        mTag.getTagService().resetTimeouts();
        mTag.getTagService().reconnect(mTag.getServiceHandle());
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    } finally {
        mIsConnected = false;
        mTag.setTechnologyDisconnected();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"An additional method call `resetTimeouts()` has been added to the try block which is not a return statement, exception handling statement, or a control dependency change, so the code change type is 4 (Other statement changed).","The added method call `resetTimeouts()` within the try block does not affect the behavior of the API in terms of changing return values or the exception handling because it neither changes the return type or value nor alters the exceptions thrown by the method. Thus, there is no compatibility issue in terms of different return values or types or exceptions thrown, so the CI type is 0 (No Compatibility Issue)."
659,<android.webkit.WebView: void invokeZoomPicker()>,13,14,,,,"{
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return;
    }
    clearHelpers();
    mZoomManager.invokeZoomPicker();
}","{
    checkThread();
    if (!getSettings().supportZoom()) {
        Log.w(LOGTAG, ""This WebView doesn't support zoom."");
        return;
    }
    clearHelpers();
    mZoomManager.invokeZoomPicker();
}",1,"/**
 * Invoke the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
","/**
 * Invoke the graphical zoom picker widget for this WebView. This will
 * result in the zoom widget appearing on the screen to control the zoom
 * level of this WebView.
 */
",0,,,0,,,,,,,"3,4",0,"A new method call checkThread() has been added at the beginning. This reflects a change in the control dependency due to the added method call (type 3), as well as other statement changes since it is an additional line outside of existing control structures (type 4).","Despite the introduction of a new method call at the beginning, this does not necessarily imply a Compatibility Issue. The method checkThread() is presumably used to check if the method is being called on the correct thread. If this check passes silently when successful and raises an issue only when the thread is incorrect (due to the design of standard check methods), it will not alter the behavior of the API in terms of what it returns or the exceptions it throws under normal expected conditions. Therefore, there is no Compatibility Issue according to the provided information."
660,<android.webkit.ZoomManager: float getDefaultScale()>,13,14,,,,"{
    return mDefaultScale;
}","{
    return mInitialScale > 0 ? mInitialScale : mDefaultScale;
}",1,,,0,,,0,,,,,,,1,1,"The return statement has changed from returning a single variable `mDefaultScale` to returning a conditional value which might be `mInitialScale` (if `mInitialScale` is greater than 0) or `mDefaultScale`. So, the change type is 1.","This code change can cause a different value to be returned depending on the value of `mInitialScale`. Therefore, it's a Compatibility Issue of type 1 caused by potential different return values."
664,<android.server.BluetoothAdapterProperties: void getAllProperties()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BluetoothService.BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    mPropertiesMap.clear();
    String[] properties = (String[]) mService.getAdapterPropertiesNative();
    // The String Array consists of key-value pairs.
    if (properties == null) {
        Log.e(TAG, ""*Error*: GetAdapterProperties returned NULL"");
        return;
    }
    for (int i = 0; i < properties.length; i++) {
        String name = properties[i];
        String newValue = null;
        int len;
        if (name == null) {
            Log.e(TAG, ""Error:Adapter Property at index "" + i + "" is null"");
            continue;
        }
        if (name.equals(""Devices"") || name.equals(""UUIDs"")) {
            StringBuilder str = new StringBuilder();
            len = Integer.valueOf(properties[++i]);
            for (int j = 0; j < len; j++) {
                str.append(properties[++i]);
                str.append("","");
            }
            if (len > 0) {
                newValue = str.toString();
            }
        } else {
            newValue = properties[++i];
        }
        mPropertiesMap.put(name, newValue);
    }
    // Add adapter object path property.
    String adapterPath = mService.getAdapterPathNative();
    if (adapterPath != null) {
        mPropertiesMap.put(""ObjectPath"", adapterPath + ""/dev_"");
    }
}","{
    mContext.enforceCallingOrSelfPermission(BluetoothService.BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    mPropertiesMap.clear();
    String[] properties = (String[]) mService.getAdapterPropertiesNative();
    // The String Array consists of key-value pairs.
    if (properties == null) {
        Log.e(TAG, ""*Error*: GetAdapterProperties returned NULL"");
        return;
    }
    for (int i = 0; i < properties.length; i++) {
        String name = properties[i];
        String newValue = null;
        if (name == null) {
            Log.e(TAG, ""Error:Adapter Property at index "" + i + "" is null"");
            continue;
        }
        if (name.equals(""Devices"") || name.equals(""UUIDs"")) {
            StringBuilder str = new StringBuilder();
            int len = Integer.valueOf(properties[++i]);
            for (int j = 0; j < len; j++) {
                str.append(properties[++i]);
                str.append("","");
            }
            if (len > 0) {
                newValue = str.toString();
            }
        } else {
            newValue = properties[++i];
        }
        mPropertiesMap.put(name, newValue);
    }
    // Add adapter object path property.
    String adapterPath = mService.getAdapterPathNative();
    if (adapterPath != null) {
        mPropertiesMap.put(""ObjectPath"", adapterPath + ""/dev_"");
    }
}",1,,,0,,,0,,,,,,,0,0,"There is no actual code change (only formatting changes like white spaces), so the code change type is 0.","Since there are no changes in the implementation between the two versions, there is no Compatibility Issue, hence the CI type is 0."
666,<android.webkit.WebView: WebSettings getSettings()>,13,14,,,,"{
    return (mWebViewCore != null) ? mWebViewCore.getSettings() : null;
}","{
    checkThread();
    return (mWebViewCore != null) ? mWebViewCore.getSettings() : null;
}",1,"/**
 * Return the WebSettings object used to control the settings for this
 * WebView.
 * @return A WebSettings object that can be used to control this WebView's
 * settings.
 */
","/**
 * Return the WebSettings object used to control the settings for this
 * WebView.
 * @return A WebSettings object that can be used to control this WebView's
 * settings.
 */
",0,,,0,,,,,,,"3,4",0,"The additional call to checkThread() introduces a control dependency change (type 3), and since it's not a return, exception, or dependent API change, it also falls under other statement changed (type 4).","The additional checkThread() call does not cause a change in the method's output or exception behavior directly, it merely ensures that the WebView is accessed from the correct thread. If the checkThread() method only throws an exception when called from an incorrect thread, this cannot be considered as a potential different return value or exception thrown by the getSettings() method itself. Therefore, there is No Compatibility Issue (type 0)."
668,"<android.bluetooth.BluetoothSocket: int read(byte[],int,int)>",13,14,,,,"{
    mLock.readLock().lock();
    try {
        if (mClosed)
            throw new IOException(""socket closed"");
        return readNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}","{
    mLock.readLock().lock();
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException(""socket closed"");
        return readNative(b, offset, length);
    } finally {
        mLock.readLock().unlock();
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"3,4",0,"The check for a closed socket has changed from if (mClosed) to if (mSocketState == SocketState.CLOSED). This is a change in a variable used in a condition, which is a control dependency change (3), and since only the variable name has changed but not the control flow, it is also an other statement changed (4).","There is no change in the behavior of the method visible from the interface of the API. The renamed variable (from `mClosed` to `mSocketState`) still checks for the same condition (whether the socket is closed) and throws the same exception if the condition is true, which means there is no Compatibility Issue. Even though the inner state representation changed, this does not affect the client's interaction with the method, so the change should not cause any behavioral difference to the API consumer."
669,<android.webkit.WebView: Picture capturePicture()>,13,14,,,,"{
    if (mNativeClass == 0)
        return null;
    Picture result = new Picture();
    nativeCopyBaseContentToPicture(result);
    return result;
}","{
    checkThread();
    if (mNativeClass == 0)
        return null;
    Picture result = new Picture();
    nativeCopyBaseContentToPicture(result);
    return result;
}",1,"/**
 * Return a new picture that captures the current display of the webview.
 * This is a copy of the display, and will be unaffected if the webview
 * later loads a different URL.
 *
 * @return a picture containing the current contents of the view. Note this
 * picture is of the entire document, and is not restricted to the
 * bounds of the view.
 */
","/**
 * Return a new picture that captures the current display of the webview.
 * This is a copy of the display, and will be unaffected if the webview
 * later loads a different URL.
 *
 * @return a picture containing the current contents of the view. Note this
 * picture is of the entire document, and is not restricted to the
 * bounds of the view.
 */
",0,,,0,,,,,,,"3,4",0,"The method `checkThread();` is added at the beginning of the implementation causing a change in other statements (3). Since `checkThread();` is presumable a concurrency or correctness check and does not seem to affect the return value or the exception handling directly, it is also classified as another statement added (4).","The added `checkThread();` method call does not inherently change the return value or exception handling of the API method. It presumably ensures thread safety or checks for the correct thread usage, but as there is no indication that the method's behavior regarding the return value or exception handling has changed, there should be no compatibility issue caused by this addition."
671,<android.webkit.WebView: String getTitle()>,13,14,,,,"{
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTitle() : null;
}","{
    checkThread();
    WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
    return h != null ? h.getTitle() : null;
}",1,"/**
 * Get the title for the current page. This is the title of the current page
 * until WebViewClient.onReceivedTitle is called.
 * @return The title for the current page.
 */
","/**
 * Get the title for the current page. This is the title of the current page
 * until WebViewClient.onReceivedTitle is called.
 * @return The title for the current page.
 */
",0,,,0,,,,,,,4,0,"An additional method call (checkThread()) is introduced at the beginning of the late version of the method, but the return statement remains unchanged, so the code change type is 4.","The additional call to checkThread() does not affect the return value of the method or the exceptions being thrown that are part of the method's normal operation. Its purpose is likely to check the thread safety or the correct thread access but it does not inherently change the API's external behavior. Assuming checkThread() does not alter the state that would affect the return value, there is no Compatibility Issue based on the change, so the CI type is 0. However, if checkThread() throws an unchecked exception not mentioned in the documentation when called from an incorrect thread, this might introduce a compatibility issue due to a potential different exception being thrown. Since there is no indication that it does so, we assume it doesn't."
672,<android.animation.ValueAnimator: boolean isRunning()>,13,14,,,,"{
    return (mPlayingState == RUNNING);
}","{
    return (mPlayingState == RUNNING || mRunning);
}",1,,,0,[@Override],[@Override],0,,,,,,,1,1,"The return statement includes a new condition '|| mRunning' in addition to the original condition, so the code change type is 1.","The addition of the '|| mRunning' condition means that the method can now return true in more cases than before. Specifically, if 'mRunning' is true while 'mPlayingState' is not 'RUNNING', the earlier version of the method would return false, while the later version would return true. Thus the CI type is 1."
673,<android.view.View: float getScaleX()>,13,14,,,,"{
    return mScaleX;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mScaleX : 1;
}",1,"/**
 * The amount that the view is scaled in x around the pivot point, as a proportion of
 * the view's unscaled width. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
","/**
 * The amount that the view is scaled in x around the pivot point, as a proportion of
 * the view's unscaled width. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
",0,,,0,,,,,,,1,1,"The return statement has been modified from directly returning the value of mScaleX to conditionally returning either mTransformationInfo.mScaleX or 1 if mTransformationInfo is null. This is a change in the return statement, making the code change type 1.","Given that the return value of the API is now conditional and may return a different value (1 instead of mScaleX if mTransformationInfo is null), this constitutes a change that could lead to a Compatibility Issue. Thus, the CI type is 1 because the method potentially returns a different value based on the new condition."
675,"<android.content.ContentProviderProxy: String[] getStreamTypes(Uri,String)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeString(mimeTypeFilter);
    mRemote.transact(IContentProvider.GET_STREAM_TYPES_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    String[] out = reply.createStringArray();
    data.recycle();
    reply.recycle();
    return out;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeString(mimeTypeFilter);
        mRemote.transact(IContentProvider.GET_STREAM_TYPES_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        String[] out = reply.createStringArray();
        return out;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code change is related to the try-finally statement being added for better resource management and the moving of data.recycle() and reply.recycle() into the finally block, which is a type 4 change as it involves refactor without behavioral change. The structure of try block is changed, which is type 3 because the whole block of statements is now enclosed in a try-finally structure to ensure the resources are always released.","This change does not introduce a compatibility issue. The actual logic of the method and the behavior observed by the calling code remains the same. The return value and exception behavior of the API have not been altered. The API still reads the Parcelable, executes a remote transaction, and returns a String array without changing its behavior, so there is no compatibility issue. The only change is an improvement in resource management that should not affect existing clients of the API."
678,<android.view.View: boolean dispatchTrackballEvent(MotionEvent)>,13,14,,,,"{
    // Log.i(""view"", ""view="" + this + "", "" + event.toString());
    return onTrackballEvent(event);
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTrackballEvent(event, 0);
    }
    return onTrackballEvent(event);
}",1,"/**
 * Pass a trackball motion event down to the focused view.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
","/**
 * Pass a trackball motion event down to the focused view.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
",0,,,0,,,,,,,4,0,"An input event consistency verification has been added before the return statement. This is a change of type 4 (Other statement changed), as it adds a new statement that checks the event before it's passed on to onTrackballEvent.","The added statement is for input event consistency verification and does not change the method's return value or introduce new exceptions, so it does not lead to a Compatibility Issue."
682,<android.app.Activity: void performStop()>,13,14,,,,"{
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
    // Check for Activity leaks, if enabled.
    StrictMode.conditionallyCheckInstanceCounts();
}","{
    if (mLoadersStarted) {
        mLoadersStarted = false;
        if (mLoaderManager != null) {
            if (!mChangingConfigurations) {
                mLoaderManager.doStop();
            } else {
                mLoaderManager.doRetain();
            }
        }
    }
    if (!mStopped) {
        if (mWindow != null) {
            mWindow.closeAllPanels();
        }
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, true);
        }
        mFragments.dispatchStop();
        mCalled = false;
        mInstrumentation.callActivityOnStop(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onStop()"");
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (!mc.mReleased) {
                    mc.mCursor.deactivate();
                    mc.mReleased = true;
                }
            }
        }
        mStopped = true;
    }
    mResumed = false;
}",1,,,0,,,0,,,,,,,0,0,"There is no change in the implementation between the early and late versions of the API, so the change type is 0.","Since there is no change between the two versions, there is no compatibility issue, and the CI type is 0."
685,<android.view.View: float getRotationX()>,13,14,,,,"{
    return mRotationX;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mRotationX : 0;
}",1,"/**
 * The degrees that the view is rotated around the horizontal axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationX(float)
 *
 * @return The degrees of X rotation.
 */
","/**
 * The degrees that the view is rotated around the horizontal axis through the pivot point.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @see #setRotationX(float)
 *
 * @return The degrees of X rotation.
 */
",0,,,0,,,,,,,1,1,"The return statement in the late version involves a ternary conditional operator to check if mTransformationInfo is not null, which differs from the straightforward return of mRotationX in the early version. This is a modification in the return statement.","This change may lead to a potential Compatibility Issue because previously mRotationX was returned unconditionally, whereas in the late version, there's a check for null on mTransformationInfo and if it's null, the method returns 0 instead of the value of mRotationX. Thus, the API could return a different value when mTransformationInfo is null, indicating a CI caused by potential different return values."
686,<android.widget.ScrollView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
        // descendants.
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                final int overscrollMode = getOverScrollMode();
                if (overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0)) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        final int bottom = getScrollRange();
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, bottom)) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                final float y = ev.getY(index);
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}","{
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(ev);
    final int action = ev.getAction();
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_DOWN:
            {
                mIsBeingDragged = getChildCount() != 0;
                if (!mIsBeingDragged) {
                    return false;
                }
                /*
                 * If being flinged and user touches, stop the fling. isFinished
                 * will be false if being flinged.
                 */
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    if (mFlingStrictSpan != null) {
                        mFlingStrictSpan.finish();
                        mFlingStrictSpan = null;
                    }
                }
                // Remember where the motion event started
                mLastMotionY = ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
        case MotionEvent.ACTION_MOVE:
            if (mIsBeingDragged) {
                // Scroll to follow the motion event
                final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                final float y = ev.getY(activePointerIndex);
                final int deltaY = (int) (mLastMotionY - y);
                mLastMotionY = y;
                final int oldX = mScrollX;
                final int oldY = mScrollY;
                final int range = getScrollRange();
                final int overscrollMode = getOverScrollMode();
                final boolean canOverscroll = overscrollMode == OVER_SCROLL_ALWAYS || (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                if (overScrollBy(0, deltaY, 0, mScrollY, 0, range, 0, mOverscrollDistance, true)) {
                    // Break our velocity if we hit a scroll barrier.
                    mVelocityTracker.clear();
                }
                onScrollChanged(mScrollX, mScrollY, oldX, oldY);
                if (canOverscroll) {
                    final int pulledToY = oldY + deltaY;
                    if (pulledToY < 0) {
                        mEdgeGlowTop.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowBottom.isFinished()) {
                            mEdgeGlowBottom.onRelease();
                        }
                    } else if (pulledToY > range) {
                        mEdgeGlowBottom.onPull((float) deltaY / getHeight());
                        if (!mEdgeGlowTop.isFinished()) {
                            mEdgeGlowTop.onRelease();
                        }
                    }
                    if (mEdgeGlowTop != null && (!mEdgeGlowTop.isFinished() || !mEdgeGlowBottom.isFinished())) {
                        invalidate();
                    }
                }
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mIsBeingDragged) {
                final VelocityTracker velocityTracker = mVelocityTracker;
                velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
                int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId);
                if (getChildCount() > 0) {
                    if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
                        fling(-initialVelocity);
                    } else {
                        if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                            invalidate();
                        }
                    }
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            if (mIsBeingDragged && getChildCount() > 0) {
                if (mScroller.springBack(mScrollX, mScrollY, 0, 0, 0, getScrollRange())) {
                    invalidate();
                }
                mActivePointerId = INVALID_POINTER;
                endDrag();
            }
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
            {
                final int index = ev.getActionIndex();
                final float y = ev.getY(index);
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(index);
                break;
            }
        case MotionEvent.ACTION_POINTER_UP:
            onSecondaryPointerUp(ev);
            mLastMotionY = ev.getY(ev.findPointerIndex(mActivePointerId));
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
690,"<android.widget.Gallery: boolean onKeyUp(int,KeyEvent)>",13,14,,,,"{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if (mReceivedInvokeKeyDown) {
                    if (mItemCount > 0) {
                        dispatchPress(mSelectedChild);
                        postDelayed(new Runnable() {

                            public void run() {
                                dispatchUnpress();
                            }
                        }, ViewConfiguration.getPressedStateDuration());
                        int selectedIndex = mSelectedPosition - mFirstPosition;
                        performItemClick(getChildAt(selectedIndex), mSelectedPosition, mAdapter.getItemId(mSelectedPosition));
                    }
                }
                // Clear the flag
                mReceivedInvokeKeyDown = false;
                return true;
            }
    }
    return super.onKeyUp(keyCode, event);
}","{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            {
                if (mReceivedInvokeKeyDown) {
                    if (mItemCount > 0) {
                        dispatchPress(mSelectedChild);
                        postDelayed(new Runnable() {

                            @Override
                            public void run() {
                                dispatchUnpress();
                            }
                        }, ViewConfiguration.getPressedStateDuration());
                        int selectedIndex = mSelectedPosition - mFirstPosition;
                        performItemClick(getChildAt(selectedIndex), mSelectedPosition, mAdapter.getItemId(mSelectedPosition));
                    }
                }
                // Clear the flag
                mReceivedInvokeKeyDown = false;
                return true;
            }
    }
    return super.onKeyUp(keyCode, event);
}",1,,,0,[@Override],[@Override],0,,,,,,,0,0,"There are no substantial code changes, as the only modification between these two versions is the addition of the @Override annotation on the run method inside the Runnable. This annotation does not affect the method's behavior.","Since there are no changes in the method's implementation that would affect the return value or exception handling, there are no Compatibility Issues between these versions."
691,<android.server.BluetoothService: boolean connectPanDevice(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    return mBluetoothPanProfileHandler.connectPanDevice(device);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.connectPanDevice(device);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"A synchronized block has been added around the 'mBluetoothPanProfileHandler.connectPanDevice(device)' call executed, which represents a change in both control dependency (3) and other statements (4), as locks have been introduced but the flow and logic have not been altered in a way that would change the behavior or the return value of the method.","No Compatibility Issue should arise from simply adding a synchronized block, as this change is meant to make the code thread-safe without affecting the output or behavior from the perspective of single-threaded use or the method's contract. Hence, the CI type is 0."
697,<android.app.ActivityThread.H: void handleMessage(Message)>,13,14,,,,"{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + msg.what);
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
            }
            break;
        case PAUSE_ACTIVITY:
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            break;
        case PAUSE_ACTIVITY_FINISHING:
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            break;
        case STOP_ACTIVITY_SHOW:
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            break;
        case STOP_ACTIVITY_HIDE:
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            break;
        case SHOW_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, true);
            break;
        case HIDE_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, false);
            break;
        case RESUME_ACTIVITY:
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            break;
        case SEND_RESULT:
            handleSendResult((ResultData) msg.obj);
            break;
        case DESTROY_ACTIVITY:
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            break;
        case BIND_APPLICATION:
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            handleNewIntent((NewIntentData) msg.obj);
            break;
        case RECEIVER:
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            break;
        case CREATE_SERVICE:
            handleCreateService((CreateServiceData) msg.obj);
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData) msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData) msg.obj);
            break;
        case SERVICE_ARGS:
            handleServiceArgs((ServiceArgsData) msg.obj);
            break;
        case STOP_SERVICE:
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            break;
        case REQUEST_THUMBNAIL:
            handleRequestThumbnail((IBinder) msg.obj);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj, null);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            handleLowMemory();
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            handleActivityConfigurationChanged((IBinder) msg.obj);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj);
            break;
        case CREATE_BACKUP_AGENT:
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case DESTROY_BACKUP_AGENT:
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            completeRemoveProvider((IContentProvider) msg.obj);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            break;
        case SET_CORE_SETTINGS:
            handleSetCoreSettings((Bundle) msg.obj);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + msg.what);
}","{
    if (DEBUG_MESSAGES)
        Slog.v(TAG, "">>> handling: "" + msg.what);
    switch(msg.what) {
        case LAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                r.packageInfo = getPackageInfoNoCheck(r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null);
            }
            break;
        case RELAUNCH_ACTIVITY:
            {
                ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                handleRelaunchActivity(r);
            }
            break;
        case PAUSE_ACTIVITY:
            handlePauseActivity((IBinder) msg.obj, false, msg.arg1 != 0, msg.arg2);
            maybeSnapshot();
            break;
        case PAUSE_ACTIVITY_FINISHING:
            handlePauseActivity((IBinder) msg.obj, true, msg.arg1 != 0, msg.arg2);
            break;
        case STOP_ACTIVITY_SHOW:
            handleStopActivity((IBinder) msg.obj, true, msg.arg2);
            break;
        case STOP_ACTIVITY_HIDE:
            handleStopActivity((IBinder) msg.obj, false, msg.arg2);
            break;
        case SHOW_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, true);
            break;
        case HIDE_WINDOW:
            handleWindowVisibility((IBinder) msg.obj, false);
            break;
        case RESUME_ACTIVITY:
            handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0);
            break;
        case SEND_RESULT:
            handleSendResult((ResultData) msg.obj);
            break;
        case DESTROY_ACTIVITY:
            handleDestroyActivity((IBinder) msg.obj, msg.arg1 != 0, msg.arg2, false);
            break;
        case BIND_APPLICATION:
            AppBindData data = (AppBindData) msg.obj;
            handleBindApplication(data);
            break;
        case EXIT_APPLICATION:
            if (mInitialApplication != null) {
                mInitialApplication.onTerminate();
            }
            Looper.myLooper().quit();
            break;
        case NEW_INTENT:
            handleNewIntent((NewIntentData) msg.obj);
            break;
        case RECEIVER:
            handleReceiver((ReceiverData) msg.obj);
            maybeSnapshot();
            break;
        case CREATE_SERVICE:
            handleCreateService((CreateServiceData) msg.obj);
            break;
        case BIND_SERVICE:
            handleBindService((BindServiceData) msg.obj);
            break;
        case UNBIND_SERVICE:
            handleUnbindService((BindServiceData) msg.obj);
            break;
        case SERVICE_ARGS:
            handleServiceArgs((ServiceArgsData) msg.obj);
            break;
        case STOP_SERVICE:
            handleStopService((IBinder) msg.obj);
            maybeSnapshot();
            break;
        case REQUEST_THUMBNAIL:
            handleRequestThumbnail((IBinder) msg.obj);
            break;
        case CONFIGURATION_CHANGED:
            handleConfigurationChanged((Configuration) msg.obj, null);
            break;
        case CLEAN_UP_CONTEXT:
            ContextCleanupInfo cci = (ContextCleanupInfo) msg.obj;
            cci.context.performFinalCleanup(cci.who, cci.what);
            break;
        case GC_WHEN_IDLE:
            scheduleGcIdler();
            break;
        case DUMP_SERVICE:
            handleDumpService((DumpComponentInfo) msg.obj);
            break;
        case LOW_MEMORY:
            handleLowMemory();
            break;
        case ACTIVITY_CONFIGURATION_CHANGED:
            handleActivityConfigurationChanged((IBinder) msg.obj);
            break;
        case PROFILER_CONTROL:
            handleProfilerControl(msg.arg1 != 0, (ProfilerControlData) msg.obj, msg.arg2);
            break;
        case CREATE_BACKUP_AGENT:
            handleCreateBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case DESTROY_BACKUP_AGENT:
            handleDestroyBackupAgent((CreateBackupAgentData) msg.obj);
            break;
        case SUICIDE:
            Process.killProcess(Process.myPid());
            break;
        case REMOVE_PROVIDER:
            completeRemoveProvider((IContentProvider) msg.obj);
            break;
        case ENABLE_JIT:
            ensureJitEnabled();
            break;
        case DISPATCH_PACKAGE_BROADCAST:
            handleDispatchPackageBroadcast(msg.arg1, (String[]) msg.obj);
            break;
        case SCHEDULE_CRASH:
            throw new RemoteServiceException((String) msg.obj);
        case DUMP_HEAP:
            handleDumpHeap(msg.arg1 != 0, (DumpHeapData) msg.obj);
            break;
        case DUMP_ACTIVITY:
            handleDumpActivity((DumpComponentInfo) msg.obj);
            break;
        case SLEEPING:
            handleSleeping((IBinder) msg.obj, msg.arg1 != 0);
            break;
        case SET_CORE_SETTINGS:
            handleSetCoreSettings((Bundle) msg.obj);
            break;
        case UPDATE_PACKAGE_COMPATIBILITY_INFO:
            handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData) msg.obj);
            break;
        case TRIM_MEMORY:
            handleTrimMemory(msg.arg1);
            break;
    }
    if (DEBUG_MESSAGES)
        Slog.v(TAG, ""<<< done: "" + msg.what);
}",1,,,0,,,0,,,,,,,,,,
698,<android.view.View: void invalidate(boolean)>,13,14,,,,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) || (mPrivateFlags & INVALIDATED) != INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~DRAWN;
        if (invalidateCache) {
            mPrivateFlags |= INVALIDATED;
            mPrivateFlags &= ~DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewRoot to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}","{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) || (mPrivateFlags & INVALIDATED) != INVALIDATED || isOpaque() != mLastIsOpaque) {
        mLastIsOpaque = isOpaque();
        mPrivateFlags &= ~DRAWN;
        mPrivateFlags |= DIRTY;
        if (invalidateCache) {
            mPrivateFlags |= INVALIDATED;
            mPrivateFlags &= ~DRAWING_CACHE_VALID;
        }
        final AttachInfo ai = mAttachInfo;
        final ViewParent p = mParent;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final Rect r = ai.mTmpInvalRect;
            r.set(0, 0, mRight - mLeft, mBottom - mTop);
            // Don't call invalidate -- we don't want to internally scroll
            // our own bounds
            p.invalidateChild(this, r);
        }
    }
}",1,"/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
","/**
 * This is where the invalidate() work actually happens. A full invalidate()
 * causes the drawing cache to be invalidated, but this function can be called with
 * invalidateCache set to false to skip that invalidation step for cases that do not
 * need it (for example, a component that remains at the same dimensions with the same
 * content).
 *
 * @param invalidateCache Whether the drawing cache for this view should be invalidated as
 * well. This is usually true for a full invalidate, but may be set to false if the
 * View's contents or dimensions have not changed.
 */
",0,,,0,,,,,,,"1,3,4,5",1,"There's a new method call `skipInvalidate()` added, a return statement after it, and also a change of setting a different flag (`mPrivateFlags |= DIRTY;` instead of `mPrivateFlags &= ~DRAWN;`) so the change types are 1,3,4,5.","The introduction of `skipInvalidate()` and the associated return statement can lead to the method exiting earlier without performing the invalidate operations that it would have in the previous version. The change in flags also has the potential to alter the state of the View in a way that could affect downstream behavior. Thus, a Compatibility Issue could arise due to a potentially different method execution path and resultant state, which is indicated by CI type 1."
699,<android.view.View: float getScaleY()>,13,14,,,,"{
    return mScaleY;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mScaleY : 1;
}",1,"/**
 * The amount that the view is scaled in y around the pivot point, as a proportion of
 * the view's unscaled height. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
","/**
 * The amount that the view is scaled in y around the pivot point, as a proportion of
 * the view's unscaled height. A value of 1, the default, means that no scaling is applied.
 *
 * <p>By default, this is 1.0f.
 *
 * @see #getPivotX()
 * @see #getPivotY()
 * @return The scaling factor.
 */
",0,,,0,,,,,,,1,1,"The return statement has been changed to include a condition that returns either a member variable (mScaleY) or a default value (1). This is a significant change from directly returning the member variable mScaleY, so the code change type is 1.","The change can lead to the API potentially returning a different value if mTransformationInfo is null because it will now return 1 instead of mScaleY. Consequently, this alters the behavior of the method. Thus, the CI type is 1 since it entails a potential difference in return value."
700,<android.net.Uri.PathPart: PathPart readFrom(Parcel)>,13,14,,,,"{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new AssertionError();
    }
}","{
    int representation = parcel.readInt();
    switch(representation) {
        case Representation.BOTH:
            return from(parcel.readString(), parcel.readString());
        case Representation.ENCODED:
            return fromEncoded(parcel.readString());
        case Representation.DECODED:
            return fromDecoded(parcel.readString());
        default:
            throw new IllegalArgumentException(""Bad representation: "" + representation);
    }
}",1,,,0,,,0,,,,,,,2,2,"The exception thrown in the default case of the switch statement has changed, so the code change type is 2.","The change from throwing an AssertionError to throwing an IllegalArgumentException with a message in the default case may affect how callers handle this exceptional case, so the CI type is 2."
703,<android.webkit.WebView: boolean canGoForward()>,13,14,,,,"{
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() < l.getSize() - 1;
        }
    }
}","{
    checkThread();
    WebBackForwardList l = mCallbackProxy.getBackForwardList();
    synchronized (l) {
        if (l.getClearPending()) {
            return false;
        } else {
            return l.getCurrentIndex() < l.getSize() - 1;
        }
    }
}",1,"/**
 * Return true if this WebView has a forward history item.
 * @return True iff this Webview has a forward history item.
 */
","/**
 * Return true if this WebView has a forward history item.
 * @return True iff this Webview has a forward history item.
 */
",0,,,0,,,,,,,4,0,"The code has added a 'checkThread()' method call at the beginning of the method, so the change type is 4.","Since 'checkThread()' does not alter the return values or types, nor does it introduce new exception handling, it will not cause a compatibility issue as long as it does not throw an unchecked exception that would change the control flow (which is not indicated from the context provided), as such the CI type is 0."
707,"<android.text.BoringLayout: Metrics isBoring(CharSequence,TextPaint)>",13,14,,,,"{
    return isBoring(text, paint, null);
}","{
    return isBoring(text, paint, TextDirectionHeuristics.FIRSTSTRONG_LTR, null);
}",1,"/**
 * Returns null if not boring; the width, ascent, and descent if boring.
 */
","/**
 * Returns null if not boring; the width, ascent, and descent if boring.
 */
",0,,,0,,,,,,,5,1,"The late version of the method calls 'isBoring' with an additional parameter (TextDirectionHeuristics.FIRSTSTRONG_LTR), which indicates a change to a dependent API, hence the change type is 5.","Because the method now includes an additional parameter to the 'isBoring' call, this can alter the behavior of the API, potentially leading to a different return value. Therefore, a CI caused by potentially different return values or types is detected, and the CI type is 1."
710,<android.widget.Spinner: int getBaseline()>,13,14,,,,"{
    View child = null;
    if (getChildCount() > 0) {
        child = getChildAt(0);
    } else if (mAdapter != null && mAdapter.getCount() > 0) {
        child = makeAndAddView(0);
        mRecycler.put(0, child);
        removeAllViewsInLayout();
    }
    if (child != null) {
        return child.getTop() + child.getBaseline();
    } else {
        return -1;
    }
}","{
    View child = null;
    if (getChildCount() > 0) {
        child = getChildAt(0);
    } else if (mAdapter != null && mAdapter.getCount() > 0) {
        child = makeAndAddView(0);
        mRecycler.put(0, child);
        removeAllViewsInLayout();
    }
    if (child != null) {
        final int childBaseline = child.getBaseline();
        return childBaseline >= 0 ? child.getTop() + childBaseline : -1;
    } else {
        return -1;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The late version adds a new check for the baseline before returning it, with a control statement that checks if the baseline is greater than or equal to zero. Therefore, the change type is 3.","Since the introduction of the new check for the baseline value potentially alters the return value of the function (it now returns -1 instead of the sum in cases where the baseline is negative), this could lead to a different behavior when the API is used. Thus, the CI type is 1."
712,<android.server.BluetoothService: List<BluetoothDevice> getInputDevicesMatchingConnectionStates(int[])>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothInputProfileHandler.getInputDevicesMatchingConnectionStates(states);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.getInputDevicesMatchingConnectionStates(states);
    }
}",1,,,0,,,0,,,,,,,3,0,The only change is the introduction of a synchronized block around the return statement. There is no change to the return statement itself or to the logic determining the return value. The code change type is 3 due to the addition of synchronization control around the existing code.,"The addition of synchronization doesn't change the behavior from the viewpoint of the API consumer; it merely adds thread safety to the method. Thus, there is no compatibility issue as the return values and exception handling remain the same between the versions."
713,<android.service.wallpaper.WallpaperService.Engine: void attach(IWallpaperEngineWrapper)>,13,14,,,,"{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = ViewRoot.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    updateSurface(false, false, false);
}","{
    if (DEBUG)
        Log.v(TAG, ""attach: "" + this + "" wrapper="" + wrapper);
    if (mDestroyed) {
        return;
    }
    mIWallpaperEngine = wrapper;
    mCaller = wrapper.mCaller;
    mConnection = wrapper.mConnection;
    mWindowToken = wrapper.mWindowToken;
    mSurfaceHolder.setSizeFromLayout();
    mInitializing = true;
    mSession = ViewRootImpl.getWindowSession(getMainLooper());
    mWindow.setSession(mSession);
    mScreenOn = ((PowerManager) getSystemService(Context.POWER_SERVICE)).isScreenOn();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    registerReceiver(mReceiver, filter);
    if (DEBUG)
        Log.v(TAG, ""onCreate(): "" + this);
    onCreate(mSurfaceHolder);
    mInitializing = false;
    mReportedVisible = false;
    updateSurface(false, false, false);
}",1,,,0,,,0,,,,,,,"3,4",0,"The late version has an additional assignment of the mScreenOn variable and the use of the getSystemService() method, and the introduction of a new variable mReportedVisible which is initialized to false, resulting in code change types 3 and 4.","Since these changes do not affect the return value nor the exceptions thrown by the method, there is no compatibility issue regarding return values or exception handlings. Thus, the CI type is 0."
715,<android.animation.PropertyValuesHolder.FloatPropertyValuesHolder: void setAnimatedValue(Object)>,13,14,,,,"{
    if (mJniSetter != 0) {
        nCallFloatMethod(target, mJniSetter, mFloatAnimatedValue);
        return;
    }
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = mFloatAnimatedValue;
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}","{
    if (mFloatProperty != null) {
        mFloatProperty.setValue(target, mFloatAnimatedValue);
        return;
    }
    if (mProperty != null) {
        mProperty.set(target, mFloatAnimatedValue);
        return;
    }
    if (mJniSetter != 0) {
        nCallFloatMethod(target, mJniSetter, mFloatAnimatedValue);
        return;
    }
    if (mSetter != null) {
        try {
            mTmpValueArray[0] = mFloatAnimatedValue;
            mSetter.invoke(target, mTmpValueArray);
        } catch (InvocationTargetException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        } catch (IllegalAccessException e) {
            Log.e(""PropertyValuesHolder"", e.toString());
        }
    }
}",1,"/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
","/**
 * Internal function to set the value on the target object, using the setter set up
 * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
 * to handle turning the value calculated by ValueAnimator into a value set on the object
 * according to the name of the property.
 * @param target The target object on which the value is set
 */
",0,[@Override],[@Override],0,,,,,,,"3,4",0,"The code added two blocks to check and use mFloatProperty and mProperty before mJniSetter, and the order of checking mJniSetter has been moved after mFloatProperty and mProperty checks. Since control statements are added and their order is altered, the change type is 3. Additionally, these new blocks of code represent non-exception handling, non-return, new control flow and logic, so it also falls under change type 4.","There's no CI due to the new code blocks, as they present new ways to set the animated value on the target object, they don't affect the cases when mSetter is used. The conditions for mSetter and its exception handling remain unchanged, so the former behavior under those conditions will produce the same outcome. The CI type is 0."
716,<android.view.View: boolean isInTouchMode()>,13,14,,,,"{
    if (mAttachInfo != null) {
        return mAttachInfo.mInTouchMode;
    } else {
        return ViewRoot.isInTouchMode();
    }
}","{
    if (mAttachInfo != null) {
        return mAttachInfo.mInTouchMode;
    } else {
        return ViewRootImpl.isInTouchMode();
    }
}",1,"/**
 * Returns whether the device is currently in touch mode.  Touch mode is entered
 * once the user begins interacting with the device by touch, and affects various
 * things like whether focus is always visible to the user.
 *
 * @return Whether the device is in touch mode.
 */
","/**
 * Returns whether the device is currently in touch mode.  Touch mode is entered
 * once the user begins interacting with the device by touch, and affects various
 * things like whether focus is always visible to the user.
 *
 * @return Whether the device is in touch mode.
 */
",0,[@ViewDebug.ExportedProperty],[@ViewDebug.ExportedProperty],0,,,,,,,5,1,"The dependent API used in the return statement has changed from ViewRoot.isInTouchMode() to ViewRootImpl.isInTouchMode(), so the code change type is 5.","The change in the dependent method that is called may lead to a different return value as the implementation of ViewRootImpl.isInTouchMode() could be different from ViewRoot.isInTouchMode(). Hence, the CI type is 1."
717,<android.webkit.WebSettings: boolean getUseFixedViewport()>,13,14,,,,"{
    return getUseWideViewPort() && mUseFixedViewport;
}","{
    return getUseWideViewPort();
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,"1,5",1,"The return statement has changed from `return getUseWideViewPort() && mUseFixedViewport;` in the early version to just `return getUseWideViewPort();` in the late version, and part of the expression (`mUseFixedViewport`) has been removed. There is also an implied change to a dependent API because the functionality now solely relies on the result of `getUseWideViewPort()` without the combination of `mUseFixedViewport`. So, the code change types are 1 and 5.","The removal of `mUseFixedViewport` from the return statement will cause a change in the returned value when the condition involving `mUseFixedViewport` would have previously evaluated to false. Thus, there could be a different return value for the same inputs between the two versions, indicating a Compatibility Issue of type 1."
718,<android.webkit.ZoomManager: float getReadingLevelScale()>,13,14,,,,"{
    return computeScaleWithLimits(computeReadingLevelScale(getZoomOverviewScale()));
}","{
    WebSettings settings = mWebView.getSettings();
    final float doubleTapZoomFactor = settings != null ? settings.getDoubleTapZoom() / 100.f : 1.0f;
    return mDisplayDensity * doubleTapZoomFactor;
}",1,,"/**
 * Returns the zoom scale used for reading text on a double-tap.
 */
",1,,,0,,,,,,,"1,4,5",1,"The implementation has changed completely, including the removal of computeScaleWithLimits(computeReadingLevelScale(getZoomOverviewScale())) and introduction of a new logic using mWebView.getSettings() and settings.getDoubleTapZoom(). New variables and method calls have been introduced as well which indeed affect the dependent APIs, so the code change type is 1,4,5.","The method now returns a float based on entirely different calculations which involve new variables and method calls. As this changes the return value, the CI type is 1."
719,<android.view.View: void postInvalidateDelayed(long)>,13,14,,,,"{
    // if we are not attached to our window
    if (mAttachInfo != null) {
        Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_MSG;
        msg.obj = this;
        mAttachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}","{
    // We try only with the AttachInfo because there's no point in invalidating
    // if we are not attached to our window
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        Message msg = Message.obtain();
        msg.what = AttachInfo.INVALIDATE_MSG;
        msg.obj = this;
        attachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }
}",1,"/**
 * Cause an invalidate to happen on a subsequent cycle through the event
 * loop. Waits for the specified amount of time.
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 */
","/**
 * <p>Cause an invalidate to happen on a subsequent cycle through the event
 * loop. Waits for the specified amount of time.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param delayMilliseconds the duration in milliseconds to delay the
 * invalidation by
 */
",1,,,0,,,,,,,4,0,"The only change is a variable rename from mAttachInfo directly used to a local variable attachInfo; there's no semantic change. All other instructions remain the same, so the other statement changed, but it does not affect the behavior of the method. ","The change is only a local variable rename which won't affect the behavior of the API; therefore, there is no Compatibility Issue."
720,"<android.app.PendingIntent: PendingIntent getBroadcast(Context,int,Intent,int)>",13,14,,,,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_BROADCAST, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_BROADCAST, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will perform a broadcast, like calling
 * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.
 *
 * @param context The Context in which this PendingIntent should perform
 * the broadcast.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent The Intent to be broadcast.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",0,,,0,,,,,,,4,0,"The statement `intent.setAllowFds(false);` has been added in the late version which does not change the return type, the return value, or the exception handling. This change is an addition of a method call on the `intent` object which qualifies as an 'Other statement changed'.","There is no Compatibility Issue because the added method call does not affect the control flow or the method's outputs (assuming normal operation where the addition of this call does not introduce new exceptions). The method `setAllowFds(false);` is used to modify the behavior of file descriptor passing but does not alter the method's return values or the types or conditions of thrown exceptions as part of its normal operation. Thus, the change should not lead to different behavior of the API in terms of its specified outputs and exceptions."
721,<android.widget.AbsListView.FlingRunnable: void run()>,13,14,,,,"{
    switch(mTouchMode) {
        default:
            endFling();
            return;
        case TOUCH_MODE_SCROLL:
            if (mScroller.isFinished()) {
                return;
            }
        // Fall through
        case TOUCH_MODE_FLING:
            {
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final OverScroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                // Check to see if we have bumped into the scroll limit
                View motionView = getChildAt(mMotionPosition - mFirstPosition);
                int oldTop = 0;
                if (motionView != null) {
                    oldTop = motionView.getTop();
                }
                // Don't stop just because delta is zero (it could have been rounded)
                final boolean atEnd = trackMotionScroll(delta, delta) && (delta != 0);
                if (atEnd) {
                    if (motionView != null) {
                        // Tweak the scroll for how far we overshot
                        int overshoot = -(delta - (motionView.getTop() - oldTop));
                        overScrollBy(0, overshoot, 0, mScrollY, 0, 0, 0, mOverflingDistance, false);
                    }
                    if (more) {
                        edgeReached(delta);
                    }
                    break;
                }
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                        if (mFlingStrictSpan != null) {
                            mFlingStrictSpan.finish();
                            mFlingStrictSpan = null;
                        }
                    }
                }
                break;
            }
        case TOUCH_MODE_OVERFLING:
            {
                final OverScroller scroller = mScroller;
                if (scroller.computeScrollOffset()) {
                    final int scrollY = mScrollY;
                    final int deltaY = scroller.getCurrY() - scrollY;
                    if (overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, mOverflingDistance, false)) {
                        startSpringback();
                    } else {
                        invalidate();
                        post(this);
                    }
                } else {
                    endFling();
                }
                break;
            }
    }
}","{
    switch(mTouchMode) {
        default:
            endFling();
            return;
        case TOUCH_MODE_SCROLL:
            if (mScroller.isFinished()) {
                return;
            }
        // Fall through
        case TOUCH_MODE_FLING:
            {
                if (mDataChanged) {
                    layoutChildren();
                }
                if (mItemCount == 0 || getChildCount() == 0) {
                    endFling();
                    return;
                }
                final OverScroller scroller = mScroller;
                boolean more = scroller.computeScrollOffset();
                final int y = scroller.getCurrY();
                // Flip sign to convert finger direction to list items direction
                // (e.g. finger moving down means list is moving towards the top)
                int delta = mLastFlingY - y;
                // Pretend that each frame of a fling scroll is a touch scroll
                if (delta > 0) {
                    // List is moving towards the top. Use first view as mMotionPosition
                    mMotionPosition = mFirstPosition;
                    final View firstView = getChildAt(0);
                    mMotionViewOriginalTop = firstView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.min(getHeight() - mPaddingBottom - mPaddingTop - 1, delta);
                } else {
                    // List is moving towards the bottom. Use last view as mMotionPosition
                    int offsetToLast = getChildCount() - 1;
                    mMotionPosition = mFirstPosition + offsetToLast;
                    final View lastView = getChildAt(offsetToLast);
                    mMotionViewOriginalTop = lastView.getTop();
                    // Don't fling more than 1 screen
                    delta = Math.max(-(getHeight() - mPaddingBottom - mPaddingTop - 1), delta);
                }
                // Check to see if we have bumped into the scroll limit
                View motionView = getChildAt(mMotionPosition - mFirstPosition);
                int oldTop = 0;
                if (motionView != null) {
                    oldTop = motionView.getTop();
                }
                // Don't stop just because delta is zero (it could have been rounded)
                final boolean atEnd = trackMotionScroll(delta, delta) && (delta != 0);
                if (atEnd) {
                    if (motionView != null) {
                        // Tweak the scroll for how far we overshot
                        int overshoot = -(delta - (motionView.getTop() - oldTop));
                        overScrollBy(0, overshoot, 0, mScrollY, 0, 0, 0, mOverflingDistance, false);
                    }
                    if (more) {
                        edgeReached(delta);
                    }
                    break;
                }
                if (more && !atEnd) {
                    invalidate();
                    mLastFlingY = y;
                    post(this);
                } else {
                    endFling();
                    if (PROFILE_FLINGING) {
                        if (mFlingProfilingStarted) {
                            Debug.stopMethodTracing();
                            mFlingProfilingStarted = false;
                        }
                        if (mFlingStrictSpan != null) {
                            mFlingStrictSpan.finish();
                            mFlingStrictSpan = null;
                        }
                    }
                }
                break;
            }
        case TOUCH_MODE_OVERFLING:
            {
                final OverScroller scroller = mScroller;
                if (scroller.computeScrollOffset()) {
                    final int scrollY = mScrollY;
                    final int currY = scroller.getCurrY();
                    final int deltaY = currY - scrollY;
                    if (overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, mOverflingDistance, false)) {
                        final boolean crossDown = scrollY <= 0 && currY > 0;
                        final boolean crossUp = scrollY >= 0 && currY < 0;
                        if (crossDown || crossUp) {
                            int velocity = (int) scroller.getCurrVelocity();
                            if (crossUp)
                                velocity = -velocity;
                            // Don't flywheel from this; we're just continuing things.
                            scroller.abortAnimation();
                            start(velocity);
                        } else {
                            startSpringback();
                        }
                    } else {
                        invalidate();
                        post(this);
                    }
                } else {
                    endFling();
                }
                break;
            }
    }
}",1,,,0,,,0,,,,,,,,,,
724,<android.database.CursorWindow: void clear()>,13,14,,,,"{
    acquireReference();
    try {
        mStartPos = 0;
        native_clear();
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        mStartPos = 0;
        nativeClear(mWindowPtr);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Clears out the existing contents of the window, making it safe to reuse
 * for new data. Note that the number of columns in the window may NOT
 * change across a call to clear().
 */
","/**
 * Clears out the existing contents of the window, making it safe to reuse
 * for new data.
 * <p>
 * The start position ({@link #getStartPosition()}), number of rows ({@link #getNumRows()}),
 * and number of columns in the cursor are all reset to zero.
 * </p>
 */
",1,,,0,,,,,,,"4,5",1,"The native method name called within the try block has changed from native_clear() to nativeClear(mWindowPtr), indicating the change in the method invoked and likely its signature (since an argument is now being passed). Hence, the change type is 4 (Other statement changed) and 5 (Dependent API changed).","The change in the native method call, from native_clear() to nativeClear(mWindowPtr), could suggest a change in behavior, as the method's logic could be different. Additionally, if the native method affects the state of the CursorWindow differently, it can result in a difference in the window's state after the call to clear(). Therefore, this could lead to a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types) because of the difference in the implementation details that this method induces."
726,<android.view.GLES20DisplayList.DisplayListFinalizer: void finalize()>,13,14,,,,"{
    try {
        replaceNativeObject(0);
    } finally {
        super.finalize();
    }
}","{
    try {
        GLES20Canvas.destroyDisplayList(mNativeDisplayList);
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The method body has changed from calling replaceNativeObject(0) to GLES20Canvas.destroyDisplayList(mNativeDisplayList), which means there is a change in the implementation (code change type 4). Additionally, there is a change in the dependent APIs (code change type 5).","Despite the change in the implementation details, finalize() methods do not have a return value nor throw checked exceptions. The change in internal method calls does not lead to a different outcome from the perspective of the method signature, as the function of finalize is to perform cleanup actions, and exceptions should not escape the finalize() method. The change should not affect how other code interacts with this method, hence no compatibility issue is detected (CI type 0)."
727,<android.app.Activity: void performRestart()>,13,14,,,,"{
    mFragments.noteStateNotSaved();
    if (mStopped) {
        mStopped = false;
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, false);
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}","{
    mFragments.noteStateNotSaved();
    if (mStopped) {
        mStopped = false;
        if (mToken != null && mParent == null) {
            WindowManagerImpl.getDefault().setStoppedState(mToken, false);
        }
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i = 0; i < N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mReleased || mc.mUpdated) {
                    if (!mc.mCursor.requery()) {
                        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                            throw new IllegalStateException(""trying to requery an already closed cursor  "" + mc.mCursor);
                        }
                    }
                    mc.mReleased = false;
                    mc.mUpdated = false;
                }
            }
        }
        mCalled = false;
        mInstrumentation.callActivityOnRestart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(""Activity "" + mComponent.toShortString() + "" did not call through to super.onRestart()"");
        }
        performStart();
    }
}",1,,,0,,,0,,,,,,,"3,4","1,2","The code change includes the addition of an if statement to check the target SDK version before throwing an exception inside the existing for loop (Control dependency changed). Additionally, the decision on whether to throw the IllegalStateException now depends on the target SDK version, which is an Other statement changed (4).","This change could potentially cause a Compatibility Issue due to different exception handling depending on the application's target SDK version (Exception handling statement changed - 2). If the requery operation fails on a cursor, the behaviour will differ based on the target SDK version. For versions Ice Cream Sandwich and higher, an exception will be thrown, while for lower versions, the exception won't be thrown. This also implies a potential different return value or no return (normal flow interruption) in cases where exceptions are thrown (Return statement changed - 1)."
728,<android.widget.TextView: void onEditorAction(int)>,13,14,,,,"{
    final InputContentType ict = mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_DOWN);
            if (v != null) {
                if (!v.requestFocus(FOCUS_DOWN)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_UP);
            if (v != null) {
                if (!v.requestFocus(FOCUS_UP)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            return;
        }
    }
    Handler h = getHandler();
    if (h != null) {
        long eventTime = SystemClock.uptimeMillis();
        h.sendMessage(h.obtainMessage(ViewRoot.DISPATCH_KEY_FROM_IME, new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
        h.sendMessage(h.obtainMessage(ViewRoot.DISPATCH_KEY_FROM_IME, new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
    }
}","{
    final InputContentType ict = mInputContentType;
    if (ict != null) {
        if (ict.onEditorActionListener != null) {
            if (ict.onEditorActionListener.onEditorAction(this, actionCode, null)) {
                return;
            }
        }
        // app may be expecting.
        if (actionCode == EditorInfo.IME_ACTION_NEXT) {
            View v = focusSearch(FOCUS_FORWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_FORWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_PREVIOUS) {
            View v = focusSearch(FOCUS_BACKWARD);
            if (v != null) {
                if (!v.requestFocus(FOCUS_BACKWARD)) {
                    throw new IllegalStateException(""focus search returned a view "" + ""that wasn't able to take focus!"");
                }
            }
            return;
        } else if (actionCode == EditorInfo.IME_ACTION_DONE) {
            InputMethodManager imm = InputMethodManager.peekInstance();
            if (imm != null && imm.isActive(this)) {
                imm.hideSoftInputFromWindow(getWindowToken(), 0);
            }
            clearFocus();
            return;
        }
    }
    Handler h = getHandler();
    if (h != null) {
        long eventTime = SystemClock.uptimeMillis();
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
        h.sendMessage(h.obtainMessage(ViewRootImpl.DISPATCH_KEY_FROM_IME, new KeyEvent(SystemClock.uptimeMillis(), eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_SOFT_KEYBOARD | KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_EDITOR_ACTION)));
    }
}",1,"/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
","/**
 * Called when an attached input method calls
 * {@link InputConnection#performEditorAction(int)
 * InputConnection.performEditorAction()}
 * for this text view.  The default implementation will call your action
 * listener supplied to {@link #setOnEditorActionListener}, or perform
 * a standard operation for {@link EditorInfo#IME_ACTION_NEXT
 * EditorInfo.IME_ACTION_NEXT}, {@link EditorInfo#IME_ACTION_PREVIOUS
 * EditorInfo.IME_ACTION_PREVIOUS}, or {@link EditorInfo#IME_ACTION_DONE
 * EditorInfo.IME_ACTION_DONE}.
 *
 * <p>For backwards compatibility, if no IME options have been set and the
 * text view would not normally advance focus on enter, then
 * the NEXT and DONE actions received here will be turned into an enter
 * key down/up pair to go through the normal key handling.
 *
 * @param actionCode The code of the action being performed.
 *
 * @see #setOnEditorActionListener
 */
",0,,,0,,,,,,,"3,4",1,"There are two changes in this code. The first one is replacing `FOCUS_DOWN` and `FOCUS_UP` with `FOCUS_FORWARD` and `FOCUS_BACKWARD`, respectively, within the `focusSearch` method calls, which is a change in control dependency. The other change is the addition of a `clearFocus` method call when `actionCode` is `EditorInfo.IME_ACTION_DONE`, which counts as another statement changed. The class name from `ViewRoot.DISPATCH_KEY_FROM_IME` has been updated to `ViewRootImpl.DISPATCH_KEY_FROM_IME`, but since it's just a name change and not a signature or functional change, this does not count as a dependent API change. Therefore, the changes fall under codes 3 and 4.","Since `FOCUS_DOWN` and `FOCUS_UP` were replaced by `FOCUS_FORWARD` and `FOCUS_BACKWARD`, which are used to determine the view that should be focused next, this can potentially change the View that gets focus, triggering a different behavior and possibly a different return value. Thus, we have a compatibility issue of type 1. Additionally, the added `clearFocus` could also change the behavior of the method when the action code equals `EditorInfo.IME_ACTION_DONE` by clearing the focus from the current view, which wasn't happening in the earlier version, representing a behavior change and introducing another potential compatibility issue of type 1."
730,<android.widget.NumberPicker: void setValue(int)>,13,14,,,,"{
    if (mValue == value) {
        return;
    }
    if (value < mMinValue) {
        value = mWrapSelectorWheel ? mMaxValue : mMinValue;
    }
    if (value > mMaxValue) {
        value = mWrapSelectorWheel ? mMinValue : mMaxValue;
    }
    mValue = value;
    updateInputTextView();
    updateIncrementAndDecrementButtonsVisibilityState();
}","{
    if (mValue == value) {
        return;
    }
    if (value < mMinValue) {
        value = mWrapSelectorWheel ? mMaxValue : mMinValue;
    }
    if (value > mMaxValue) {
        value = mWrapSelectorWheel ? mMinValue : mMaxValue;
    }
    mValue = value;
    initializeSelectorWheelIndices();
    updateInputTextView();
    updateIncrementAndDecrementButtonsVisibilityState();
    invalidate();
}",1,"/**
 * Set the current value for the number picker.
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 *
 * @param value The current value.
 * @see #setWrapSelectorWheel(boolean)
 * @see #setMinValue(int)
 * @see #setMaxValue(int)
 */
","/**
 * Set the current value for the number picker.
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
 * current value is set to the {@link NumberPicker#getMaxValue()} value.
 * </p>
 * <p>
 * If the argument is less than the {@link NumberPicker#getMaxValue()} and
 * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
 * current value is set to the {@link NumberPicker#getMinValue()} value.
 * </p>
 *
 * @param value The current value.
 * @see #setWrapSelectorWheel(boolean)
 * @see #setMinValue(int)
 * @see #setMaxValue(int)
 */
",0,,,0,,,,,,,"3,4",0,"A new method call initializeSelectorWheelIndices() is added, and another new method call invalidate() is added in the late version. These fall under the categories of control dependency change and other statement change because they affect the sequence of operations within the method but do not change how the method's value is returned or how the exceptions are handled. It's an addition of method calls in the sequence of operations which affects the internal state and behavior.","The change does not affect the return value or the exceptions thrown by the method. The method's signature has not changed, and the additional method calls are related to internal state updates, which do not constitute an external behavior change from an API consumer perspective. Therefore, there is no compatibility issue caused by potential different return values or exception handling."
731,<android.webkit.WebView: WebBackForwardList restoreState(Bundle)>,13,14,,,,"{
    WebBackForwardList returnList = null;
    if (inState == null) {
        return returnList;
    }
    if (inState.containsKey(""index"") && inState.containsKey(""history"")) {
        mCertificate = SslCertificate.restoreState(inState.getBundle(""certificate""));
        final WebBackForwardList list = mCallbackProxy.getBackForwardList();
        final int index = inState.getInt(""index"");
        // modifications.
        synchronized (list) {
            final List<byte[]> history = (List<byte[]>) inState.getSerializable(""history"");
            final int size = history.size();
            // restoring the history index.
            if (index < 0 || index >= size) {
                return null;
            }
            for (int i = 0; i < size; i++) {
                byte[] data = history.remove(0);
                if (data == null) {
                    // the item and thus our history list cannot be rebuilt.
                    return null;
                }
                WebHistoryItem item = new WebHistoryItem(data);
                list.addHistoryItem(item);
            }
            // Grab the most recent copy to return to the caller.
            returnList = copyBackForwardList();
            // Update the copy to have the correct index.
            returnList.setCurrentIndex(index);
        }
        // Restore private browsing setting.
        if (inState.getBoolean(""privateBrowsingEnabled"")) {
            getSettings().setPrivateBrowsingEnabled(true);
        }
        mZoomManager.restoreZoomState(inState);
        // Remove all pending messages because we are restoring previous
        // state.
        mWebViewCore.removeMessages();
        // Send a restore state message.
        mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
    }
    return returnList;
}","{
    checkThread();
    WebBackForwardList returnList = null;
    if (inState == null) {
        return returnList;
    }
    if (inState.containsKey(""index"") && inState.containsKey(""history"")) {
        mCertificate = SslCertificate.restoreState(inState.getBundle(""certificate""));
        final WebBackForwardList list = mCallbackProxy.getBackForwardList();
        final int index = inState.getInt(""index"");
        // modifications.
        synchronized (list) {
            final List<byte[]> history = (List<byte[]>) inState.getSerializable(""history"");
            final int size = history.size();
            // restoring the history index.
            if (index < 0 || index >= size) {
                return null;
            }
            for (int i = 0; i < size; i++) {
                byte[] data = history.remove(0);
                if (data == null) {
                    // the item and thus our history list cannot be rebuilt.
                    return null;
                }
                WebHistoryItem item = new WebHistoryItem(data);
                list.addHistoryItem(item);
            }
            // Grab the most recent copy to return to the caller.
            returnList = copyBackForwardList();
            // Update the copy to have the correct index.
            returnList.setCurrentIndex(index);
        }
        // Restore private browsing setting.
        if (inState.getBoolean(""privateBrowsingEnabled"")) {
            getSettings().setPrivateBrowsingEnabled(true);
        }
        mZoomManager.restoreZoomState(inState);
        // Remove all pending messages because we are restoring previous
        // state.
        mWebViewCore.removeMessages();
        // Send a restore state message.
        mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
    }
    return returnList;
}",1,"/**
 * Restore the state of this WebView from the given map used in
 * {@link android.app.Activity#onRestoreInstanceState}. This method should
 * be called to restore the state of the WebView before using the object. If
 * it is called after the WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView. See {@link #savePicture} and {@link
 * #restorePicture} for saving and restoring the display data.
 * @param inState The incoming Bundle of state.
 * @return The restored back/forward list or null if restoreState failed.
 * @see #savePicture
 * @see #restorePicture
 */
","/**
 * Restore the state of this WebView from the given map used in
 * {@link android.app.Activity#onRestoreInstanceState}. This method should
 * be called to restore the state of the WebView before using the object. If
 * it is called after the WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView. See {@link #savePicture} and {@link
 * #restorePicture} for saving and restoring the display data.
 * @param inState The incoming Bundle of state.
 * @return The restored back/forward list or null if restoreState failed.
 * @see #savePicture
 * @see #restorePicture
 */
",0,,,0,,,,,,,4,0,"The only change in the implementation is the addition of the call to the method checkThread() at the beginning of the method in the late version. This is classified as an 'Other statement changed' (type 4) since it is neither a change in the return statements, exception handling, control dependency, nor is it a change in a dependent API.","Adding the checkThread() call doesn't lead to a Compatibility Issue as it doesn't affect the return value or exception handling of the method. This method is likely added for thread-safety or to ensure that the method is called on the correct thread, but it doesn't change the expected behavior of restoreState(Bundle) as observed by the caller regarding returned values or thrown exceptions, assuming correct usage regarding threading. Therefore, there is no Compatibility Issue (type 0)."
732,<android.app.WallpaperManager: void setBitmap(Bitmap)>,13,14,,,,"{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    }
}","{
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",0,,,0,,,,,,,0,0,"There is no actual code change, only a comment was added in the catch block for RemoteException. Comments have no effect on the API behavior.","Since there were no changes to the method behavior, statements, or control structure, there is no compatibility issue."
733,<android.text.SpannableStringBuilder: void removeSpan(Object)>,13,14,,,,"{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        if (mSpans[i] == what) {
            int ostart = mSpanStarts[i];
            int oend = mSpanEnds[i];
            if (ostart > mGapStart)
                ostart -= mGapLength;
            if (oend > mGapStart)
                oend -= mGapLength;
            int count = mSpanCount - (i + 1);
            System.arraycopy(mSpans, i + 1, mSpans, i, count);
            System.arraycopy(mSpanStarts, i + 1, mSpanStarts, i, count);
            System.arraycopy(mSpanEnds, i + 1, mSpanEnds, i, count);
            System.arraycopy(mSpanFlags, i + 1, mSpanFlags, i, count);
            mSpanCount--;
            mSpans[mSpanCount] = null;
            sendSpanRemoved(what, ostart, oend);
            return;
        }
    }
}","{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        if (mSpans[i] == what) {
            removeSpan(i);
            return;
        }
    }
}",1,"/**
 * Remove the specified markup object from the buffer.
 */
","/**
 * Remove the specified markup object from the buffer.
 */
",0,,,0,,,,,,,4,0,"The method body has changed to call `removeSpan(i)` instead of running inline operations. This indicates a refactoring, where the removal logic has likely been moved into the `removeSpan(int)` method to consolidate span removal logic, rather than a functional change. Still, since 'removeSpan' is a method of the same class (not an external or dependent API), and the internal behavior isn't shown as changed, the code change type is 4 only.","No Compatibility Issue should arise as the method functionality is presumably the same. The inline implementation of the span removal logic has been replaced with a method call that should perform the same operations internally, meaning the external behavior of the `removeSpan(Object)` method remains consistent."
734,<android.view.Gravity: boolean isHorizontal(int)>,13,14,,,,"{
    return gravity > 0 && (gravity & HORIZONTAL_GRAVITY_MASK) != 0;
}","{
    return gravity > 0 && (gravity & RELATIVE_HORIZONTAL_GRAVITY_MASK) != 0;
}",1,"/**
 * <p>Indicate whether the supplied gravity has an horizontal pull.</p>
 *
 * @param gravity the gravity to check for horizontal pull
 * @return true if the supplied gravity has an horizontal pull
 */
","/**
 * <p>Indicate whether the supplied gravity has an horizontal pull.</p>
 *
 * @param gravity the gravity to check for horizontal pull
 * @return true if the supplied gravity has an horizontal pull
 */
",0,,,0,,,,,,,4,1,"The bitwise AND operation changed from using HORIZONTAL_GRAVITY_MASK to RELATIVE_HORIZONTAL_GRAVITY_MASK. This constitutes an 'Other statement changed' since the core operation of evaluating the horizontal property changed, so the change type is 4.","The change in the bitwise operation potentially leads to a different boolean result being returned, since RELATIVE_HORIZONTAL_GRAVITY_MASK might capture different gravity flags compared to HORIZONTAL_GRAVITY_MASK. This would indeed cause the API to return a different value, and this constitutes a potential Compatibility Issue of type 1."
735,<android.nfc.tech.IsoDep: void setTimeout(int)>,13,14,,,,"{
    try {
        mTag.getTagService().setIsoDepTimeout(timeout);
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}","{
    try {
        int err = mTag.getTagService().setTimeout(TagTechnology.ISO_DEP, timeout);
        if (err != ErrorCodes.SUCCESS) {
            throw new IllegalArgumentException(""The supplied timeout is not valid"");
        }
    } catch (RemoteException e) {
        Log.e(TAG, ""NFC service dead"", e);
    }
}",1,"/**
 * Set the timeout of {@link #transceive} in milliseconds.
 * <p>The timeout only applies to ISO-DEP {@link #transceive}, and is
 * reset to a default value when {@link #close} is called.
 * <p>Setting a longer timeout may be useful when performing
 * transactions that require a long processing time on the tag
 * such as key generation.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param timeout timeout value in milliseconds
 */
","/**
 * Set the timeout of {@link #transceive} in milliseconds.
 * <p>The timeout only applies to ISO-DEP {@link #transceive}, and is
 * reset to a default value when {@link #close} is called.
 * <p>Setting a longer timeout may be useful when performing
 * transactions that require a long processing time on the tag
 * such as key generation.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param timeout timeout value in milliseconds
 */
",0,,,0,,,,,,,"1,2,4,5","1,2",The late version of the code has introduced several changes:,"- A new flow control introduces an `if` statement that checks the return value and throws an `IllegalArgumentException` if the value indicates an error, which is a change in the exception handling statement (type 2)."
736,<android.view.WindowManager.LayoutParams: int copyFrom(LayoutParams)>,13,14,,,,"{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    return changes;
}","{
    int changes = 0;
    if (width != o.width) {
        width = o.width;
        changes |= LAYOUT_CHANGED;
    }
    if (height != o.height) {
        height = o.height;
        changes |= LAYOUT_CHANGED;
    }
    if (x != o.x) {
        x = o.x;
        changes |= LAYOUT_CHANGED;
    }
    if (y != o.y) {
        y = o.y;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalWeight != o.horizontalWeight) {
        horizontalWeight = o.horizontalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalWeight != o.verticalWeight) {
        verticalWeight = o.verticalWeight;
        changes |= LAYOUT_CHANGED;
    }
    if (horizontalMargin != o.horizontalMargin) {
        horizontalMargin = o.horizontalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (verticalMargin != o.verticalMargin) {
        verticalMargin = o.verticalMargin;
        changes |= LAYOUT_CHANGED;
    }
    if (type != o.type) {
        type = o.type;
        changes |= TYPE_CHANGED;
    }
    if (flags != o.flags) {
        flags = o.flags;
        changes |= FLAGS_CHANGED;
    }
    if (privateFlags != o.privateFlags) {
        privateFlags = o.privateFlags;
        changes |= PRIVATE_FLAGS_CHANGED;
    }
    if (softInputMode != o.softInputMode) {
        softInputMode = o.softInputMode;
        changes |= SOFT_INPUT_MODE_CHANGED;
    }
    if (gravity != o.gravity) {
        gravity = o.gravity;
        changes |= LAYOUT_CHANGED;
    }
    if (format != o.format) {
        format = o.format;
        changes |= FORMAT_CHANGED;
    }
    if (windowAnimations != o.windowAnimations) {
        windowAnimations = o.windowAnimations;
        changes |= ANIMATION_CHANGED;
    }
    if (token == null) {
        // NOTE: token only copied if the recipient doesn't
        // already have one.
        token = o.token;
    }
    if (packageName == null) {
        // NOTE: packageName only copied if the recipient doesn't
        // already have one.
        packageName = o.packageName;
    }
    if (!mTitle.equals(o.mTitle)) {
        mTitle = o.mTitle;
        changes |= TITLE_CHANGED;
    }
    if (alpha != o.alpha) {
        alpha = o.alpha;
        changes |= ALPHA_CHANGED;
    }
    if (dimAmount != o.dimAmount) {
        dimAmount = o.dimAmount;
        changes |= DIM_AMOUNT_CHANGED;
    }
    if (screenBrightness != o.screenBrightness) {
        screenBrightness = o.screenBrightness;
        changes |= SCREEN_BRIGHTNESS_CHANGED;
    }
    if (buttonBrightness != o.buttonBrightness) {
        buttonBrightness = o.buttonBrightness;
        changes |= BUTTON_BRIGHTNESS_CHANGED;
    }
    if (screenOrientation != o.screenOrientation) {
        screenOrientation = o.screenOrientation;
        changes |= SCREEN_ORIENTATION_CHANGED;
    }
    if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
        systemUiVisibility = o.systemUiVisibility;
        subtreeSystemUiVisibility = o.subtreeSystemUiVisibility;
        changes |= SYSTEM_UI_VISIBILITY_CHANGED;
    }
    if (hasSystemUiListeners != o.hasSystemUiListeners) {
        hasSystemUiListeners = o.hasSystemUiListeners;
        changes |= SYSTEM_UI_LISTENER_CHANGED;
    }
    if (inputFeatures != o.inputFeatures) {
        inputFeatures = o.inputFeatures;
        changes |= INPUT_FEATURES_CHANGED;
    }
    return changes;
}",1,,,0,,,0,,,,,,,,,,
737,<android.content.res.Configuration: int updateFrom(Configuration)>,13,14,,,,"{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}","{
    int changed = 0;
    if (delta.fontScale > 0 && fontScale != delta.fontScale) {
        changed |= ActivityInfo.CONFIG_FONT_SCALE;
        fontScale = delta.fontScale;
    }
    if (delta.mcc != 0 && mcc != delta.mcc) {
        changed |= ActivityInfo.CONFIG_MCC;
        mcc = delta.mcc;
    }
    if (delta.mnc != 0 && mnc != delta.mnc) {
        changed |= ActivityInfo.CONFIG_MNC;
        mnc = delta.mnc;
    }
    if (delta.locale != null && (locale == null || !locale.equals(delta.locale))) {
        changed |= ActivityInfo.CONFIG_LOCALE;
        locale = delta.locale != null ? (Locale) delta.locale.clone() : null;
        textLayoutDirection = LocaleUtil.getLayoutDirectionFromLocale(locale);
    }
    if (delta.userSetLocale && (!userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
        userSetLocale = true;
        changed |= ActivityInfo.CONFIG_LOCALE;
    }
    if (delta.touchscreen != TOUCHSCREEN_UNDEFINED && touchscreen != delta.touchscreen) {
        changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
        touchscreen = delta.touchscreen;
    }
    if (delta.keyboard != KEYBOARD_UNDEFINED && keyboard != delta.keyboard) {
        changed |= ActivityInfo.CONFIG_KEYBOARD;
        keyboard = delta.keyboard;
    }
    if (delta.keyboardHidden != KEYBOARDHIDDEN_UNDEFINED && keyboardHidden != delta.keyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        keyboardHidden = delta.keyboardHidden;
    }
    if (delta.hardKeyboardHidden != HARDKEYBOARDHIDDEN_UNDEFINED && hardKeyboardHidden != delta.hardKeyboardHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        hardKeyboardHidden = delta.hardKeyboardHidden;
    }
    if (delta.navigation != NAVIGATION_UNDEFINED && navigation != delta.navigation) {
        changed |= ActivityInfo.CONFIG_NAVIGATION;
        navigation = delta.navigation;
    }
    if (delta.navigationHidden != NAVIGATIONHIDDEN_UNDEFINED && navigationHidden != delta.navigationHidden) {
        changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
        navigationHidden = delta.navigationHidden;
    }
    if (delta.orientation != ORIENTATION_UNDEFINED && orientation != delta.orientation) {
        changed |= ActivityInfo.CONFIG_ORIENTATION;
        orientation = delta.orientation;
    }
    if (delta.screenLayout != SCREENLAYOUT_SIZE_UNDEFINED && screenLayout != delta.screenLayout) {
        changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
        screenLayout = delta.screenLayout;
    }
    if (delta.uiMode != (UI_MODE_TYPE_UNDEFINED | UI_MODE_NIGHT_UNDEFINED) && uiMode != delta.uiMode) {
        changed |= ActivityInfo.CONFIG_UI_MODE;
        if ((delta.uiMode & UI_MODE_TYPE_MASK) != UI_MODE_TYPE_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_TYPE_MASK) | (delta.uiMode & UI_MODE_TYPE_MASK);
        }
        if ((delta.uiMode & UI_MODE_NIGHT_MASK) != UI_MODE_NIGHT_UNDEFINED) {
            uiMode = (uiMode & ~UI_MODE_NIGHT_MASK) | (delta.uiMode & UI_MODE_NIGHT_MASK);
        }
    }
    if (delta.screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED && screenWidthDp != delta.screenWidthDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenWidthDp = delta.screenWidthDp;
    }
    if (delta.screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED && screenHeightDp != delta.screenHeightDp) {
        changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
        screenHeightDp = delta.screenHeightDp;
    }
    if (delta.smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        smallestScreenWidthDp = delta.smallestScreenWidthDp;
    }
    if (delta.compatScreenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        compatScreenWidthDp = delta.compatScreenWidthDp;
    }
    if (delta.compatScreenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        compatScreenHeightDp = delta.compatScreenHeightDp;
    }
    if (delta.compatSmallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        compatSmallestScreenWidthDp = delta.compatSmallestScreenWidthDp;
    }
    if (delta.seq != 0) {
        seq = delta.seq;
    }
    return changed;
}",1,"/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
","/**
 * Copy the fields from delta into this Configuration object, keeping
 * track of which ones have changed.  Any undefined fields in
 * <var>delta</var> are ignored and not copied in to the current
 * Configuration.
 * @return Returns a bit mask of the changed fields, as per
 * {@link #diff}.
 */
",0,,,0,,,,,,,,,,
738,<android.webkit.WebView: boolean overlayHorizontalScrollbar()>,13,14,,,,"{
    return mOverlayHorizontalScrollbar;
}","{
    checkThread();
    return mOverlayHorizontalScrollbar;
}",1,"/**
 * Return whether horizontal scrollbar has overlay style
 * @return TRUE if horizontal scrollbar has overlay style.
 */
","/**
 * Return whether horizontal scrollbar has overlay style
 * @return TRUE if horizontal scrollbar has overlay style.
 */
",0,,,0,,,,,,,4,0,"An additional method call (checkThread()) has been introduced before returning the value of mOverlayHorizontalScrollbar, so the code change type is 4.","The addition of checkThread() does not affect the return value or the exception throwing of the method. checkThread() is likely a check to ensure that the method is being called on the correct thread, which doesn't inherently cause a change in behavior in terms of output. Since the return value of the API method remains the same and there is no change in the exceptions that can be thrown by the method based on the given implementation, there is no Compatibility Issue introduced by this change."
740,<android.widget.RemoteViewsAdapter.RemoteViewsAdapterServiceConnection: void onServiceConnected(IBinder)>,13,14,,,,"{
    mRemoteViewsFactory = IRemoteViewsFactory.Stub.asInterface(service);
    // Remove any deferred unbind messages
    final RemoteViewsAdapter adapter = mAdapter.get();
    if (adapter == null)
        return;
    // Queue up work that we need to do for the callback to run
    adapter.mWorkerQueue.post(new Runnable() {

        @Override
        public void run() {
            if (adapter.mNotifyDataSetChangedAfterOnServiceConnected) {
                // Handle queued notifyDataSetChanged() if necessary
                adapter.onNotifyDataSetChanged();
            } else {
                IRemoteViewsFactory factory = adapter.mServiceConnection.getRemoteViewsFactory();
                try {
                    if (!factory.isCreated()) {
                        // We only call onDataSetChanged() if this is the factory was just
                        // create in response to this bind
                        factory.onDataSetChanged();
                    }
                } catch (Exception e) {
                    Log.e(TAG, ""Error notifying factory of data set changed in "" + ""onServiceConnected(): "" + e.getMessage());
                    // (effectively nothing has changed)
                    return;
                }
                // Request meta data so that we have up to date data when calling back to
                // the remote adapter callback
                adapter.updateTemporaryMetaData();
                // Notify the host that we've connected
                adapter.mMainQueue.post(new Runnable() {

                    @Override
                    public void run() {
                        synchronized (adapter.mCache) {
                            adapter.mCache.commitTemporaryMetaData();
                        }
                        final RemoteAdapterConnectionCallback callback = adapter.mCallback.get();
                        if (callback != null) {
                            callback.onRemoteAdapterConnected();
                        }
                    }
                });
            }
            // Enqueue unbind message
            adapter.enqueueDeferredUnbindServiceMessage();
            mIsConnected = true;
            mIsConnecting = false;
        }
    });
}","{
    mRemoteViewsFactory = IRemoteViewsFactory.Stub.asInterface(service);
    // Remove any deferred unbind messages
    final RemoteViewsAdapter adapter = mAdapter.get();
    if (adapter == null)
        return;
    // Queue up work that we need to do for the callback to run
    adapter.mWorkerQueue.post(new Runnable() {

        @Override
        public void run() {
            if (adapter.mNotifyDataSetChangedAfterOnServiceConnected) {
                // Handle queued notifyDataSetChanged() if necessary
                adapter.onNotifyDataSetChanged();
            } else {
                IRemoteViewsFactory factory = adapter.mServiceConnection.getRemoteViewsFactory();
                try {
                    if (!factory.isCreated()) {
                        // We only call onDataSetChanged() if this is the factory was just
                        // create in response to this bind
                        factory.onDataSetChanged();
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, ""Error notifying factory of data set changed in "" + ""onServiceConnected(): "" + e.getMessage());
                    // (effectively nothing has changed)
                    return;
                } catch (RuntimeException e) {
                    Log.e(TAG, ""Error notifying factory of data set changed in "" + ""onServiceConnected(): "" + e.getMessage());
                }
                // Request meta data so that we have up to date data when calling back to
                // the remote adapter callback
                adapter.updateTemporaryMetaData();
                // Notify the host that we've connected
                adapter.mMainQueue.post(new Runnable() {

                    @Override
                    public void run() {
                        synchronized (adapter.mCache) {
                            adapter.mCache.commitTemporaryMetaData();
                        }
                        final RemoteAdapterConnectionCallback callback = adapter.mCallback.get();
                        if (callback != null) {
                            callback.onRemoteAdapterConnected();
                        }
                    }
                });
            }
            // Enqueue unbind message
            adapter.enqueueDeferredUnbindServiceMessage();
            mIsConnected = true;
            mIsConnecting = false;
        }
    });
}",1,,,0,,,0,,,,,,,2,0,"There is an introduced catch clause for RuntimeException in the late version, which handles a new type of exception differently than before. The previous code only caught Exception and logged an error without rethrowing it, while the new code adds more specific logging for RuntimeException but does not change the flow of execution significantly. Thus, the change type is 2.","As the new exception handling for RuntimeException does not alter the behavior of the method (since the previous code also caught Exception which includes RuntimeException), and the additional logging does not affect how the method functions from the caller's perspective, there isn't a Compatibility Issue with regard to different thrown exceptions or return values. The execution flow remains effectively the same. Hence, the CI type is 0."
741,"<android.webkit.WebView: boolean showFindDialog(String,boolean)>",13,14,,,,"{
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mLastFind;
    }
    if (text != null) {
        mFindCallback.setText(text);
    }
    return true;
}","{
    checkThread();
    FindActionModeCallback callback = new FindActionModeCallback(mContext);
    if (getParent() == null || startActionMode(callback) == null) {
        // Could not start the action mode, so end Find on page
        return false;
    }
    mFindCallback = callback;
    setFindIsUp(true);
    mFindCallback.setWebView(this);
    if (showIme) {
        mFindCallback.showSoftInput();
    } else if (text != null) {
        mFindCallback.setText(text);
        mFindCallback.findAll();
        return true;
    }
    if (text == null) {
        text = mLastFind;
    }
    if (text != null) {
        mFindCallback.setText(text);
    }
    return true;
}",1,"/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
","/**
 * Start an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 * @param text If non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme If true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return boolean True if the find dialog is shown, false otherwise.
 */
",0,,,0,,,,,,,4,0,"The only code change is the introduction of the checkThread() method call at the beginning of the method. It does not affect the return value or the control flow of the method, so the change type is 4.","The introduction of checkThread() method call doesn't lead to any change in the behavior regarding the return value or the exception handling of the method, so there is no compatibility issue."
743,<android.view.WindowManager.LayoutParams: String toString()>,13,14,,,,"{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    sb.append("" fmt="");
    sb.append(format);
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(256);
    sb.append(""WM.LayoutParams{"");
    sb.append(""("");
    sb.append(x);
    sb.append(',');
    sb.append(y);
    sb.append("")("");
    sb.append((width == MATCH_PARENT ? ""fill"" : (width == WRAP_CONTENT ? ""wrap"" : width)));
    sb.append('x');
    sb.append((height == MATCH_PARENT ? ""fill"" : (height == WRAP_CONTENT ? ""wrap"" : height)));
    sb.append("")"");
    if (horizontalMargin != 0) {
        sb.append("" hm="");
        sb.append(horizontalMargin);
    }
    if (verticalMargin != 0) {
        sb.append("" vm="");
        sb.append(verticalMargin);
    }
    if (gravity != 0) {
        sb.append("" gr=#"");
        sb.append(Integer.toHexString(gravity));
    }
    if (softInputMode != 0) {
        sb.append("" sim=#"");
        sb.append(Integer.toHexString(softInputMode));
    }
    sb.append("" ty="");
    sb.append(type);
    sb.append("" fl=#"");
    sb.append(Integer.toHexString(flags));
    if (privateFlags != 0) {
        sb.append("" pfl=0x"").append(Integer.toHexString(privateFlags));
    }
    if (format != PixelFormat.OPAQUE) {
        sb.append("" fmt="");
        sb.append(format);
    }
    if (windowAnimations != 0) {
        sb.append("" wanim=0x"");
        sb.append(Integer.toHexString(windowAnimations));
    }
    if (screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
        sb.append("" or="");
        sb.append(screenOrientation);
    }
    if (alpha != 1.0f) {
        sb.append("" alpha="");
        sb.append(alpha);
    }
    if (screenBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" sbrt="");
        sb.append(screenBrightness);
    }
    if (buttonBrightness != BRIGHTNESS_OVERRIDE_NONE) {
        sb.append("" bbrt="");
        sb.append(buttonBrightness);
    }
    if ((flags & FLAG_COMPATIBLE_WINDOW) != 0) {
        sb.append("" compatible=true"");
    }
    if (systemUiVisibility != 0) {
        sb.append("" sysui=0x"");
        sb.append(Integer.toHexString(systemUiVisibility));
    }
    if (subtreeSystemUiVisibility != 0) {
        sb.append("" vsysui=0x"");
        sb.append(Integer.toHexString(subtreeSystemUiVisibility));
    }
    if (hasSystemUiListeners) {
        sb.append("" sysuil="");
        sb.append(hasSystemUiListeners);
    }
    if (inputFeatures != 0) {
        sb.append("" if=0x"").append(Integer.toHexString(inputFeatures));
    }
    sb.append('}');
    return sb.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
744,"<android.widget.PopupWindow: void showAtLocation(View,int,int,int)>",13,14,,,,"{
    if (isShowing() || mContentView == null) {
        return;
    }
    unregisterForScrollChanged();
    mIsShowing = true;
    mIsDropdown = false;
    WindowManager.LayoutParams p = createPopupLayout(parent.getWindowToken());
    p.windowAnimations = computeAnimationResource();
    preparePopup(p);
    if (gravity == Gravity.NO_GRAVITY) {
        gravity = Gravity.TOP | Gravity.LEFT;
    }
    p.gravity = gravity;
    p.x = x;
    p.y = y;
    if (mHeightMode < 0)
        p.height = mLastHeight = mHeightMode;
    if (mWidthMode < 0)
        p.width = mLastWidth = mWidthMode;
    invokePopup(p);
}","{
    showAtLocation(parent.getWindowToken(), gravity, x, y);
}",1,"/**
 * <p>
 * Display the content view in a popup window at the specified location. If the popup window
 * cannot fit on screen, it will be clipped. See {@link android.view.WindowManager.LayoutParams}
 * for more information on how gravity and the x and y parameters are related. Specifying
 * a gravity of {@link android.view.Gravity#NO_GRAVITY} is similar to specifying
 * <code>Gravity.LEFT | Gravity.TOP</code>.
 * </p>
 *
 * @param parent a parent view to get the {@link android.view.View#getWindowToken()} token from
 * @param gravity the gravity which controls the placement of the popup window
 * @param x the popup's x location offset
 * @param y the popup's y location offset
 */
","/**
 * <p>
 * Display the content view in a popup window at the specified location. If the popup window
 * cannot fit on screen, it will be clipped. See {@link android.view.WindowManager.LayoutParams}
 * for more information on how gravity and the x and y parameters are related. Specifying
 * a gravity of {@link android.view.Gravity#NO_GRAVITY} is similar to specifying
 * <code>Gravity.LEFT | Gravity.TOP</code>.
 * </p>
 *
 * @param parent a parent view to get the {@link android.view.View#getWindowToken()} token from
 * @param gravity the gravity which controls the placement of the popup window
 * @param x the popup's x location offset
 * @param y the popup's y location offset
 */
",0,,,0,,,,,,,"1,5",0,"The implementation of the method has changed significantly, with the early implementation containing many lines of code whereas the late implementation only calls another method (showAtLocation with different parameters). This indicates a Dependent API change because the actual behavior of showing the popup window got delegated to a different method and Other statement changed because of the consolidation of all method statements into a single method call.","Potential different return values or types are irrelevant here since the method's return type is 'void' and there is no change in the exceptions thrown. However, since there are no exception handling changes and the net effect of the showAtLocation method should still have the same external behavior (to show the PopupWindow), there is No Compatibility Issue due to the changes in the method body. Assuming that the newly called showAtLocation method correctly handles the logic that was previously explicit in this method, its behavior should remain consistent from the API user's perspective."
746,"<android.app.ContextImpl: void sendBroadcast(Intent,String)>",13,14,,,,"{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false);
    } catch (RemoteException e) {
    }
}","{
    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
    try {
        intent.setAllowFds(false);
        ActivityManagerNative.getDefault().broadcastIntent(mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermission, false, false);
    } catch (RemoteException e) {
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The only change made in the method implementation is the addition of a new line of code `intent.setAllowFds(false);`, which sets whether file descriptors are allowed to be sent via the Intent. This change is neither a return statement, exception handling statement, nor control dependency change. It is an 'other statement' change, so the code change type is 4.","The call to `intent.setAllowFds(false);` restricts the types of extra data that can be sent with an intent, but it doesn't change the return type of the method (since it's void) or modify the exception handling behavior. Therefore, there is no Compatibility Issue; the method will not return a different value or throw an exception differently as a result of this change."
747,"<android.speech.tts.TextToSpeech: int addEarcon(String,String)>",13,14,,,,"{
    synchronized (mStartLock) {
        if (!mStarted) {
            return ERROR;
        }
        try {
            mITts.addEarconFile(mPackageName, earcon, filename);
            return SUCCESS;
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - addEarcon"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        }
        return ERROR;
    }
}","{
    synchronized (mStartLock) {
        mEarcons.put(earcon, Uri.parse(filename));
        return SUCCESS;
    }
}",1,"/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/tick.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Adds a mapping between a string of text and a sound file.
 * Use this to add custom earcons.
 *
 * @see #playEarcon(String, int, HashMap)
 *
 * @param earcon
 * The name of the earcon.
 * Example: <code>""[tick]""</code>
 * @param filename
 * The full path to the sound file (for example:
 * ""/sdcard/mysounds/tick.wav"")
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
",0,,,0,,,,,,,"1,2,3,4","1,2","The early version of the method implementation involves a remote service call (mITts.addEarconFile) and exception handling for RemoteException, NullPointerException, and IllegalStateException, while the late version directly updates a local HashMap (mEarcons.put) and does not involve remote service calls or exception handling. The control dependency has been changed since the try-catch blocks are removed. New operations are introduced such as updating the HashMap, and the return statement has also changed since it no longer has conditionals that return ERROR based on caught exceptions. So, the change type includes 1 (the actual returned value), 2 (exception handling statements), 3 (control dependency), and 4 (other statements like HashMap operation).","There is a Compatibility Issue because previously, if one of the exceptions was caught, the method would return ERROR, but now the method has no such exception handlers and always returns SUCCESS. Additionally, the removal of the remote service call can also lead to different behavior (possibly less failure cases, since local HashMap updates are less likely to fail than remote calls). The CI types are 1 (different return values), 2 (different exception handling)."
748,"<android.content.IntentSender: void sendIntent(Context,int,Intent,OnFinished,Handler)>",13,14,,,,"{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}","{
    sendIntent(context, code, intent, onFinished, handler, null);
}",1,"/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
","/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */
",0,,,0,,,,,,,5,0,"The late version of the method delegates to another overloaded method, changing the implementation which is referred to as a dependent API change, so the code change type is 5.","Despite the fact that the implementation delegates to another method, it calls sendIntent() with the same parameters as the original implementation with an additional `null` indicating there is no receiver permission required. Since the flow of the method logic has not been altered in ways that would affect the output or the exceptions thrown, no compatibility issue arises in this case; hence, the CI type is 0."
750,<android.ddm.DdmHandleHello: Chunk handleChunk(Chunk)>,13,14,,,,"{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",0,,,0,,,,,,,3,0,"The only change that has been made is within a logging statement where the condition has changed from checking the configuration log level Config.LOGV to a constant false. This change will prevent the logging statement from being executed, but it does not affect the API's behavior, so the code change type is 3.","Even though there is a change in the logging statement, it does not affect the functionality of the method or the value it returns. The logging is for debugging purposes and does not impact the method's normal behavior. Therefore, there is no Compatibility Issue, so the CI type is 0."
751,<android.view.KeyEvent: String toString()>,13,14,,,,"{
    return ""KeyEvent{action="" + actionToString(mAction) + "" keycode="" + keyCodeToString(mKeyCode) + "" scancode="" + mScanCode + "" metaState="" + metaStateToString(mMetaState) + "" flags=0x"" + Integer.toHexString(mFlags) + "" repeat="" + mRepeatCount + "" device="" + mDeviceId + "" source=0x"" + Integer.toHexString(mSource) + ""}"";
}","{
    StringBuilder msg = new StringBuilder();
    msg.append(""KeyEvent { action="").append(actionToString(mAction));
    msg.append("", keyCode="").append(keyCodeToString(mKeyCode));
    msg.append("", scanCode="").append(mScanCode);
    if (mCharacters != null) {
        msg.append("", characters=\"""").append(mCharacters).append(""\"""");
    }
    msg.append("", metaState="").append(metaStateToString(mMetaState));
    msg.append("", flags=0x"").append(Integer.toHexString(mFlags));
    msg.append("", repeatCount="").append(mRepeatCount);
    msg.append("", eventTime="").append(mEventTime);
    msg.append("", downTime="").append(mDownTime);
    msg.append("", deviceId="").append(mDeviceId);
    msg.append("", source=0x"").append(Integer.toHexString(mSource));
    msg.append("" }"");
    return msg.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The method implementation has changed from a single return statement to building a string with a `StringBuilder`. Control flow (conditional check for mCharacters) is added, and there are new messages appended like `eventTime`, `downTime`, and `repeatCount` has been changed to `repeatCount`. This indicates a change in control dependency (3) and other statements (4). The return value has been effectively changed because the string format of the output is modified and new fields are included (1).","The modification to the string format potentially leads to a different return value. Specifically, the addition of the `mCharacters`, `eventTime`, and `downTime` fields in the late version could result in this API returning a string that has more information than the early version, representing a discrepancy in behavior. This is a compatibility issue caused by potential different return values, hence the CI type is 1."
755,<android.widget.TextView: boolean onDragEvent(DragEvent)>,13,14,,,,"{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            final int offset = getOffset((int) event.getX(), (int) event.getY());
            Selection.setSelection((Spannable) mText, offset);
            return true;
        case DragEvent.ACTION_DROP:
            onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}","{
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_STARTED:
            return hasInsertionController();
        case DragEvent.ACTION_DRAG_ENTERED:
            TextView.this.requestFocus();
            return true;
        case DragEvent.ACTION_DRAG_LOCATION:
            final int offset = getOffsetForPosition(event.getX(), event.getY());
            Selection.setSelection((Spannable) mText, offset);
            return true;
        case DragEvent.ACTION_DROP:
            onDrop(event);
            return true;
        case DragEvent.ACTION_DRAG_ENDED:
        case DragEvent.ACTION_DRAG_EXITED:
        default:
            return true;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",1,"The dependent API `getOffset(int, int)` was changed to `getOffsetForPosition(float, float)` which indicates that a dependent API has been updated, so the code change types are 4,5.","A different method is being used (`getOffsetForPosition` instead of `getOffset`) which can potentially return different values and therefore, could lead to a different return from `onDragEvent`, qualifying for CI type 1."
761,<android.content.IntentFilter.AuthorityEntry: int match(Uri)>,13,14,,,,"{
    String host = data.getHost();
    if (host == null) {
        return NO_MATCH_DATA;
    }
    if (Config.LOGV)
        Log.v(""IntentFilter"", ""Match host "" + host + "": "" + mHost);
    if (mWild) {
        if (host.length() < mHost.length()) {
            return NO_MATCH_DATA;
        }
        host = host.substring(host.length() - mHost.length());
    }
    if (host.compareToIgnoreCase(mHost) != 0) {
        return NO_MATCH_DATA;
    }
    if (mPort >= 0) {
        if (mPort != data.getPort()) {
            return NO_MATCH_DATA;
        }
        return MATCH_CATEGORY_PORT;
    }
    return MATCH_CATEGORY_HOST;
}","{
    String host = data.getHost();
    if (host == null) {
        return NO_MATCH_DATA;
    }
    if (false)
        Log.v(""IntentFilter"", ""Match host "" + host + "": "" + mHost);
    if (mWild) {
        if (host.length() < mHost.length()) {
            return NO_MATCH_DATA;
        }
        host = host.substring(host.length() - mHost.length());
    }
    if (host.compareToIgnoreCase(mHost) != 0) {
        return NO_MATCH_DATA;
    }
    if (mPort >= 0) {
        if (mPort != data.getPort()) {
            return NO_MATCH_DATA;
        }
        return MATCH_CATEGORY_PORT;
    }
    return MATCH_CATEGORY_HOST;
}",1,"/**
 * Determine whether this AuthorityEntry matches the given data Uri.
 * <em>Note that this comparison is case-sensitive, unlike formal
 * RFC host names.  You thus should always normalize to lower-case.</em>
 *
 * @param data The Uri to match.
 * @return Returns either {@link IntentFilter#NO_MATCH_DATA},
 * {@link IntentFilter#MATCH_CATEGORY_PORT}, or
 * {@link IntentFilter#MATCH_CATEGORY_HOST}.
 */
","/**
 * Determine whether this AuthorityEntry matches the given data Uri.
 * <em>Note that this comparison is case-sensitive, unlike formal
 * RFC host names.  You thus should always normalize to lower-case.</em>
 *
 * @param data The Uri to match.
 * @return Returns either {@link IntentFilter#NO_MATCH_DATA},
 * {@link IntentFilter#MATCH_CATEGORY_PORT}, or
 * {@link IntentFilter#MATCH_CATEGORY_HOST}.
 */
",0,,,0,,,,,,,4,0,"The only change between the versions is replacing the condition in the if statement (`Config.LOGV`) with `false`, effectively disabling the log message. This is considered as an 'Other statement changed', so the code change type is 4.","Log statements do not affect the return values or exceptions that an API may raise, as they are not related to the program's logical flow. They are typically used for debugging or informational purposes and can be enabled or disabled without altering the behavior of the method for the calling code. Therefore, there is no Compatibility Issue, and the CI type is 0."
762,<android.view.View: boolean post(Runnable)>,13,14,,,,"{
    Handler handler;
    if (mAttachInfo != null) {
        handler = mAttachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRoot.getRunQueue().post(action);
        return true;
    }
    return handler.post(action);
}","{
    Handler handler;
    AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        handler = attachInfo.mHandler;
    } else {
        // Assume that post will succeed later
        ViewRootImpl.getRunQueue().post(action);
        return true;
    }
    return handler.post(action);
}",1,"/**
 * Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 */
","/**
 * <p>Causes the Runnable to be added to the message queue.
 * The runnable will be run on the user interface thread.</p>
 *
 * <p>This method can be invoked from outside of the UI thread
 * only when this View is attached to a window.</p>
 *
 * @param action The Runnable that will be executed.
 *
 * @return Returns true if the Runnable was successfully placed in to the
 * message queue.  Returns false on failure, usually because the
 * looper processing the message queue is exiting.
 */
",1,,,0,,,,,,,"4,5",0,"The implementation changed the way `mAttachInfo` is used by assigning it to a local variable and then using it, which is an other statement change. Also, the method being called on `ViewRoot` changed to `ViewRootImpl`. Since `ViewRootImpl.getRunQueue()` is a different API compared to `ViewRoot.getRunQueue()`, the code change type is 4,5.","These changes do not affect the behavior of the method regarding what it returns or the exceptions it might throw. The return values are still consistent whether `mAttachInfo` exists or not, and the delegation of the post action is to a `Handler` or a `RunQueue` which still results in a true return value when `mAttachInfo` is null. The exception handling has not changed. Therefore, there is no Compatibility Issue."
765,"<android.content.ContentProviderProxy: int bulkInsert(Uri,ContentValues[])>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeTypedArray(values, 0);
    mRemote.transact(IContentProvider.BULK_INSERT_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    int count = reply.readInt();
    data.recycle();
    reply.recycle();
    return count;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeTypedArray(values, 0);
        mRemote.transact(IContentProvider.BULK_INSERT_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        int count = reply.readInt();
        return count;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The code has changed to include the try-finally block for resource management (recycling parcels) and the removal of explicit recycling calls outside of the try block, hence the change is classified as 3,4 (Control dependency changed, Other statement changed).","While the try-finally block alters the resource management, it does not affect the API's external behavior. The structure ensures that resources are recycled properly in both success and failure cases. Hence, there is no Compatibility Issue; the API behavior in terms of the return value or exceptions remains the same."
767,<android.widget.TextView.SelectionModifierCursorController: void show()>,13,14,,,,"{
    if (isInBatchEditMode()) {
        return;
    }
    // Lazy object creation has to be done before updatePosition() is called.
    if (mStartHandle == null)
        mStartHandle = new HandleView(this, HandleView.LEFT);
    if (mEndHandle == null)
        mEndHandle = new HandleView(this, HandleView.RIGHT);
    mIsShowing = true;
    mStartHandle.show();
    mEndHandle.show();
    hideInsertionPointCursorController();
}","{
    if (isInBatchEditMode()) {
        return;
    }
    initDrawables();
    initHandles();
    hideInsertionPointCursorController();
}",1,,,0,,,0,,,,,,,"3,4,5",0,"There are no changes to return statements or exception handling, but the early version manually initializes `mStartHandle` and `mEndHandle` and calls their `show()` methods individually. In the late version, the initialization and showing of the handles appear to be encapsulated within `initHandles()`. Additionally, `initDrawables()` is a new call not present in the early version; The method `initDrawables()` itself is not provided, but its direct inclusion hints at its role in preparing any drawables that the controller might use (a possible change to dependent APIs). Therefore, the code change types here are 3 (control dependency changed: new method calls replace direct manipulations), 4 (other statement changed with the addition of 'initDrawables()'), and 5 (dependent API changed with the new method 'initHandles()').","Compatibility does not seem to be impacted if `initHandles()` and `initDrawables()` are purely refactoring changes that introduce no behavior differences outside simplification and abstraction of setup processes. There's no indication that return values would change nor that different exceptions would be thrown due to these modifications. Thus, there's no compatibility issue as long as 'initDrawables()' and 'initHandles()' encapsulate the earlier direct handle manipulations without altering the resulting state."
768,<android.webkit.WebView: boolean zoomOut()>,13,14,,,,"{
    return mZoomManager.zoomOut();
}","{
    checkThread();
    return mZoomManager.zoomOut();
}",1,"/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom out in the webview
 * @return TRUE if zoom out succeeds. FALSE if no zoom changes.
 */
",0,,,0,,,,,,,4,0,"A new statement 'checkThread();' has been added before the return statement, but there is no sign of change in what the method returns or the exception it may throw, thus the code change type is 4 (Other statement changed).","The new 'checkThread();' call should only influence the thread safety of the method, not affect the return value or the exceptions thrown. Therefore, there is no Compatibility Issue, hence CI type is 0 (No Compatibility Issue)."
769,<android.server.BluetoothDeviceProperties: boolean isEmpty()>,13,14,,,,"{
    return mPropertiesMap.isEmpty();
}","{
    synchronized (mPropertiesMap) {
        return mPropertiesMap.isEmpty();
    }
}",1,,,0,,,0,,,,,,,3,0,"The implementation code has changed by adding a synchronized block around the return statement, so the code change type is 3.","The addition of the synchronized block does not alter the behavior of the return statement; it only affects the thread-safety of the method. Therefore, there is no compatibility issue concerning the return value or exception handling, and the CI type is 0."
770,<android.view.accessibility.AccessibilityManager.MyHandler: void handleMessage(Message)>,13,14,,,,"{
    switch(message.what) {
        case DO_SET_ENABLED:
            synchronized (mHandler) {
                mIsEnabled = (message.arg1 == 1);
            }
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type: "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_SET_STATE:
            setState(message.arg1);
            return;
        default:
            Log.w(LOG_TAG, ""Unknown message type: "" + message.what);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,5",1,The code changes include:,- The control dependency under the case statement has also changed due to the different method being called.
771,<android.server.BluetoothService: boolean disconnectInputDeviceInternal(BluetoothDevice)>,13,14,,,,"{
    return mBluetoothInputProfileHandler.disconnectInputDeviceInternal(device);
}","{
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.disconnectInputDeviceInternal(device);
    }
}",1,,,0,,,0,,,,,,,3,0,"The only change made in the late version of the code is the introduction of synchronized block around the existing return statement. This change is a control dependency change, so the code change type is 3.","This synchronization does not affect the return value or the exception handling of the API; it just ensures thread safety of the operation. As there is no impact on the API's behavior and no change in the operation being performed, there is no compatibility issue introduced by this change, so the CI type is 0."
772,<android.view.GLES20Canvas.CanvasFinalizer: void finalize()>,13,14,,,,"{
    try {
        replaceNativeObject(0);
    } finally {
        super.finalize();
    }
}","{
    try {
        nDestroyRenderer(mRenderer);
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"4,5",0,"The method replaceNativeObject(0) is replaced with nDestroyRenderer(mRenderer), which indicates a change in the method called for cleanup, and the parameter has also changed. This is classified as another statement changed (4) and dependent API changed (5) since a different native method is being called.","Despite the change in the finalization method and the dependent API, there is no indication that this would lead to a compatibility issue since the purpose of both methods is related to resource cleanup, and the observable behavior and interface of finalize() have not changed. Finalize is expected to clean resources, and as long as it does this without altering the API's signature or expected behavior from garbage collection point of view, no compatibility issue is introduced. Therefore, the CI is 0."
773,<android.widget.FrameLayout: boolean getConsiderGoneChildrenWhenMeasuring()>,13,14,,,,"{
    return mMeasureAllChildren;
}","{
    return getMeasureAllChildren();
}",1,"/**
 * Determines whether to measure all children or just those in
 * the VISIBLE or INVISIBLE state when measuring.
 */
","/**
 * Determines whether all children, or just those in the VISIBLE or
 * INVISIBLE state, are considered when measuring.
 *
 * @return Whether all children are considered when measuring.
 *
 * @deprecated This method is deprecated in favor of
 * {@link #getMeasureAllChildren() getMeasureAllChildren()}, which was
 * renamed for consistency with
 * {@link #setMeasureAllChildren(boolean) setMeasureAllChildren()}.
 */
",1,,[@Deprecated],1,,,,,,,5,0,"The implementation changed from directly returning the value of the field 'mMeasureAllChildren' to calling a getter method 'getMeasureAllChildren()'. This is a change in the dependent method being called, so the change type is 5.","There is no Compatibility Issue here because the getter method is assumed to be returning the same value that would be directly accessed from the field. Deprecating the method does not change its behavior. Thus, the CI type is 0."
774,"<android.database.sqlite.SQLiteDatabase: Cursor rawQueryWithFactory(CursorFactory,String,String[],String)>",13,14,,,,"{
    verifyDbIsOpen();
    BlockGuard.getThreadPolicy().onReadFromDisk();
    long timeStart = 0;
    if (Config.LOGV || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteDatabase db = getDbConnection(sql);
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(db, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (Config.LOGV || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (Config.LOGV || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
        releaseDbConnection(db);
    }
    return cursor;
}","{
    verifyDbIsOpen();
    BlockGuard.getThreadPolicy().onReadFromDisk();
    long timeStart = 0;
    if (false || mSlowQueryThreshold != -1) {
        timeStart = System.currentTimeMillis();
    }
    SQLiteDatabase db = getDbConnection(sql);
    SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(db, sql, editTable);
    Cursor cursor = null;
    try {
        cursor = driver.query(cursorFactory != null ? cursorFactory : mFactory, selectionArgs);
    } finally {
        if (false || mSlowQueryThreshold != -1) {
            // Force query execution
            int count = -1;
            if (cursor != null) {
                count = cursor.getCount();
            }
            long duration = System.currentTimeMillis() - timeStart;
            if (false || duration >= mSlowQueryThreshold) {
                Log.v(SQLiteCursor.TAG, ""query ("" + duration + "" ms): "" + driver.toString() + "", args are "" + (selectionArgs != null ? TextUtils.join("","", selectionArgs) : ""<null>"") + "", count is "" + count);
            }
        }
        releaseDbConnection(db);
    }
    return cursor;
}",1,"/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
","/**
 * Runs the provided SQL and returns a cursor over the result set.
 *
 * @param cursorFactory the cursor factory to use, or null for the default factory
 * @param sql the SQL query. The SQL string must not be ; terminated
 * @param selectionArgs You may include ?s in where clause in the query,
 * which will be replaced by the values from selectionArgs. The
 * values will be bound as Strings.
 * @param editTable the name of the first table, which is editable
 * @return A {@link Cursor} object, which is positioned before the first entry. Note that
 * {@link Cursor}s are not synchronized, see the documentation for more details.
 */
",0,,,0,,,,,,,4,0,"The conditional code `Config.LOGV || mSlowQueryThreshold != -1` has been replaced with `false || mSlowQueryThreshold != -1` and within the `finally` block, `Config.LOGV || duration >= mSlowQueryThreshold` has been replaced with `false || duration >= mSlowQueryThreshold`. These changes only affect logging and not the functional behavior of the method, so the code change type is 4.","There is no Compatibility Issue as the changes are only related to the logging and do not affect the method’s return value or its ability to throw exceptions. The method’s behavior, in terms of execution flow, return value, and exception handling, remain consistent between the two versions. Hence, the CI type is 0."
775,<android.app.LauncherActivity.IconResizer: Drawable createIconThumbnail(Drawable)>,13,14,,,,"{
    int width = mIconWidth;
    int height = mIconHeight;
    final int iconWidth = icon.getIntrinsicWidth();
    final int iconHeight = icon.getIntrinsicHeight();
    if (icon instanceof PaintDrawable) {
        PaintDrawable painter = (PaintDrawable) icon;
        painter.setIntrinsicWidth(width);
        painter.setIntrinsicHeight(height);
    }
    if (width > 0 && height > 0) {
        if (width < iconWidth || height < iconHeight) {
            final float ratio = (float) iconWidth / iconHeight;
            if (iconWidth > iconHeight) {
                height = (int) (width / ratio);
            } else if (iconHeight > iconWidth) {
                width = (int) (height * ratio);
            }
            final Bitmap.Config c = icon.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            final Bitmap thumb = Bitmap.createBitmap(mIconWidth, mIconHeight, c);
            final Canvas canvas = mCanvas;
            canvas.setBitmap(thumb);
            // Copy the old bounds to restore them later
            // If we were to do oldBounds = icon.getBounds(),
            // the call to setBounds() that follows would
            // change the same instance and we would lose the
            // old bounds
            mOldBounds.set(icon.getBounds());
            final int x = (mIconWidth - width) / 2;
            final int y = (mIconHeight - height) / 2;
            icon.setBounds(x, y, x + width, y + height);
            icon.draw(canvas);
            icon.setBounds(mOldBounds);
            icon = new BitmapDrawable(getResources(), thumb);
        } else if (iconWidth < width && iconHeight < height) {
            final Bitmap.Config c = Bitmap.Config.ARGB_8888;
            final Bitmap thumb = Bitmap.createBitmap(mIconWidth, mIconHeight, c);
            final Canvas canvas = mCanvas;
            canvas.setBitmap(thumb);
            mOldBounds.set(icon.getBounds());
            final int x = (width - iconWidth) / 2;
            final int y = (height - iconHeight) / 2;
            icon.setBounds(x, y, x + iconWidth, y + iconHeight);
            icon.draw(canvas);
            icon.setBounds(mOldBounds);
            icon = new BitmapDrawable(getResources(), thumb);
        }
    }
    return icon;
}","{
    int width = mIconWidth;
    int height = mIconHeight;
    final int iconWidth = icon.getIntrinsicWidth();
    final int iconHeight = icon.getIntrinsicHeight();
    if (icon instanceof PaintDrawable) {
        PaintDrawable painter = (PaintDrawable) icon;
        painter.setIntrinsicWidth(width);
        painter.setIntrinsicHeight(height);
    }
    if (width > 0 && height > 0) {
        if (width < iconWidth || height < iconHeight) {
            final float ratio = (float) iconWidth / iconHeight;
            if (iconWidth > iconHeight) {
                height = (int) (width / ratio);
            } else if (iconHeight > iconWidth) {
                width = (int) (height * ratio);
            }
            final Bitmap.Config c = icon.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
            final Bitmap thumb = Bitmap.createBitmap(mIconWidth, mIconHeight, c);
            final Canvas canvas = mCanvas;
            canvas.setBitmap(thumb);
            // Copy the old bounds to restore them later
            // If we were to do oldBounds = icon.getBounds(),
            // the call to setBounds() that follows would
            // change the same instance and we would lose the
            // old bounds
            mOldBounds.set(icon.getBounds());
            final int x = (mIconWidth - width) / 2;
            final int y = (mIconHeight - height) / 2;
            icon.setBounds(x, y, x + width, y + height);
            icon.draw(canvas);
            icon.setBounds(mOldBounds);
            icon = new BitmapDrawable(getResources(), thumb);
            canvas.setBitmap(null);
        } else if (iconWidth < width && iconHeight < height) {
            final Bitmap.Config c = Bitmap.Config.ARGB_8888;
            final Bitmap thumb = Bitmap.createBitmap(mIconWidth, mIconHeight, c);
            final Canvas canvas = mCanvas;
            canvas.setBitmap(thumb);
            mOldBounds.set(icon.getBounds());
            final int x = (width - iconWidth) / 2;
            final int y = (height - iconHeight) / 2;
            icon.setBounds(x, y, x + iconWidth, y + iconHeight);
            icon.draw(canvas);
            icon.setBounds(mOldBounds);
            icon = new BitmapDrawable(getResources(), thumb);
            canvas.setBitmap(null);
        }
    }
    return icon;
}",1,"/**
 * Returns a Drawable representing the thumbnail of the specified Drawable.
 * The size of the thumbnail is defined by the dimension
 * android.R.dimen.launcher_application_icon_size.
 *
 * This method is not thread-safe and should be invoked on the UI thread only.
 *
 * @param icon The icon to get a thumbnail of.
 *
 * @return A thumbnail for the specified icon or the icon itself if the
 * thumbnail could not be created.
 */
","/**
 * Returns a Drawable representing the thumbnail of the specified Drawable.
 * The size of the thumbnail is defined by the dimension
 * android.R.dimen.launcher_application_icon_size.
 *
 * This method is not thread-safe and should be invoked on the UI thread only.
 *
 * @param icon The icon to get a thumbnail of.
 *
 * @return A thumbnail for the specified icon or the icon itself if the
 * thumbnail could not be created.
 */
",0,,,0,,,,,,,,,,
776,<android.net.http.SslError: int getPrimaryError()>,13,14,,,,"{
    if (mErrors != 0) {
        // go from the most to the least severe errors
        for (int error = SslError.SSL_MAX_ERROR - 1; error >= 0; --error) {
            if ((mErrors & (0x1 << error)) != 0) {
                return error;
            }
        }
    }
    return 0;
}","{
    if (mErrors != 0) {
        // go from the most to the least severe errors
        for (int error = SslError.SSL_MAX_ERROR - 1; error >= 0; --error) {
            if ((mErrors & (0x1 << error)) != 0) {
                return error;
            }
        }
        // mErrors should never be set to an invalid value.
        assert false;
    }
    return -1;
}",1,"/**
 * @return The primary, most severe, SSL error in the set
 */
","/**
 * Gets the most severe SSL error in this object's set of errors.
 * Returns -1 if the set is empty.
 * @return The most severe SSL error, or -1 if the set is empty.
 */
",1,,,0,,,,,,,"1,4",1,"The change consists of the new assertion statement added in the loop and modification of the default return value from 0 to -1 when mErrors is 0, which relates to both a return statement change and other statement change, so the types are 1,4.","The default return value changed from 0 to -1 and the assertion statement won't affect the method's behavior regarding return value or exception throwing. Therefore, we only have a CI related to the return value or type, which is type 1. The assertion would not introduce a compatibility issue as it is intended for use in debugging and does not affect release builds."
777,<android.net.http.SslCertificate: Bundle saveState(SslCertificate)>,13,14,,,,"{
    Bundle bundle = null;
    if (certificate != null) {
        bundle = new Bundle();
        bundle.putString(ISSUED_TO, certificate.getIssuedTo().getDName());
        bundle.putString(ISSUED_BY, certificate.getIssuedBy().getDName());
        bundle.putString(VALID_NOT_BEFORE, certificate.getValidNotBefore());
        bundle.putString(VALID_NOT_AFTER, certificate.getValidNotAfter());
    }
    return bundle;
}","{
    if (certificate == null) {
        return null;
    }
    Bundle bundle = new Bundle();
    bundle.putString(ISSUED_TO, certificate.getIssuedTo().getDName());
    bundle.putString(ISSUED_BY, certificate.getIssuedBy().getDName());
    bundle.putString(VALID_NOT_BEFORE, certificate.getValidNotBefore());
    bundle.putString(VALID_NOT_AFTER, certificate.getValidNotAfter());
    X509Certificate x509Certificate = certificate.mX509Certificate;
    if (x509Certificate != null) {
        try {
            bundle.putByteArray(X509_CERTIFICATE, x509Certificate.getEncoded());
        } catch (CertificateEncodingException ignored) {
        }
    }
    return bundle;
}",1,"/**
 * Saves the certificate state to a bundle
 * @param certificate The SSL certificate to store
 * @return A bundle with the certificate stored in it or null if fails
 */
","/**
 * Saves the certificate state to a bundle
 * @param certificate The SSL certificate to store
 * @return A bundle with the certificate stored in it or null if fails
 */
",0,,,0,,,,,,,"1,3,4",1,"The structure of the control flow changed as the if condition is inverted and some try-catch block for encoding is added in the late version. Additionally, there is a new operation of adding the X509Certificate encoding byte array to the bundle if the x509Certificate is not null which is also a change outside of a control dependency. Therefore, the code change types are 1 for return statement changes due to the inverted `if` condition, 3 for the control flow change, and 4 for the additional lines outside of control flow logic.","The change in control flow logic and the addition of extra information in the bundle could lead to the API returning a different Bundle object than before (both when `certificate` is `null` and when `x509Certificate` is not null), so the CI type is 1 for potential different return values."
784,"<android.widget.AdapterViewAnimator: void showOnly(int,boolean)>",13,14,,,,"{
    if (mAdapter == null)
        return;
    final int adapterCount = getCount();
    if (adapterCount == 0)
        return;
    for (int i = 0; i < mPreviousViews.size(); i++) {
        View viewToRemove = mViewsMap.get(mPreviousViews.get(i)).view;
        mViewsMap.remove(mPreviousViews.get(i));
        viewToRemove.clearAnimation();
        if (viewToRemove instanceof ViewGroup) {
            ViewGroup vg = (ViewGroup) viewToRemove;
            vg.removeAllViewsInLayout();
        }
        // applyTransformForChildAtIndex here just allows for any cleanup
        // associated with this view that may need to be done by a subclass
        applyTransformForChildAtIndex(viewToRemove, -1);
        removeViewInLayout(viewToRemove);
    }
    mPreviousViews.clear();
    int newWindowStartUnbounded = childIndex - mActiveOffset;
    int newWindowEndUnbounded = newWindowStartUnbounded + getNumActiveViews() - 1;
    int newWindowStart = Math.max(0, newWindowStartUnbounded);
    int newWindowEnd = Math.min(adapterCount - 1, newWindowEndUnbounded);
    if (mLoopViews) {
        newWindowStart = newWindowStartUnbounded;
        newWindowEnd = newWindowEndUnbounded;
    }
    int rangeStart = modulo(newWindowStart, getWindowSize());
    int rangeEnd = modulo(newWindowEnd, getWindowSize());
    boolean wrap = false;
    if (rangeStart > rangeEnd) {
        wrap = true;
    }
    // newWindowEndUnbounded > adapterCount - 1
    for (Integer index : mViewsMap.keySet()) {
        boolean remove = false;
        if (!wrap && (index < rangeStart || index > rangeEnd)) {
            remove = true;
        } else if (wrap && (index > rangeEnd && index < rangeStart)) {
            remove = true;
        }
        if (remove) {
            View previousView = mViewsMap.get(index).view;
            int oldRelativeIndex = mViewsMap.get(index).index;
            mPreviousViews.add(index);
            transformViewForTransition(oldRelativeIndex, -1, previousView, animate);
        }
    }
    // If the window has changed
    if (!(newWindowStart == mCurrentWindowStart && newWindowEnd == mCurrentWindowEnd && newWindowStartUnbounded == mCurrentWindowStartUnbounded)) {
        // Run through the indices in the new range
        for (int i = newWindowStart; i <= newWindowEnd; i++) {
            int index = modulo(i, getWindowSize());
            int oldRelativeIndex;
            if (mViewsMap.containsKey(index)) {
                oldRelativeIndex = mViewsMap.get(index).index;
            } else {
                oldRelativeIndex = -1;
            }
            int newRelativeIndex = i - newWindowStartUnbounded;
            // If this item is in the current window, great, we just need to apply
            // the transform for it's new relative position in the window, and animate
            // between it's current and new relative positions
            boolean inOldRange = mViewsMap.containsKey(index) && !mPreviousViews.contains(index);
            if (inOldRange) {
                View view = mViewsMap.get(index).view;
                mViewsMap.get(index).index = newRelativeIndex;
                applyTransformForChildAtIndex(view, newRelativeIndex);
                transformViewForTransition(oldRelativeIndex, newRelativeIndex, view, animate);
            // Otherwise this view is new to the window
            } else {
                // Get the new view from the adapter, add it and apply any transform / animation
                View newView = mAdapter.getView(modulo(i, adapterCount), null, this);
                // We wrap the new view in a FrameLayout so as to respect the contract
                // with the adapter, that is, that we don't modify this view directly
                FrameLayout fl = getFrameForChild();
                // If the view from the adapter is null, we still keep an empty frame in place
                if (newView != null) {
                    fl.addView(newView);
                }
                mViewsMap.put(index, new ViewAndIndex(fl, newRelativeIndex));
                addChild(fl);
                applyTransformForChildAtIndex(fl, newRelativeIndex);
                transformViewForTransition(-1, newRelativeIndex, fl, animate);
            }
            mViewsMap.get(index).view.bringToFront();
        }
        mCurrentWindowStart = newWindowStart;
        mCurrentWindowEnd = newWindowEnd;
        mCurrentWindowStartUnbounded = newWindowStartUnbounded;
    }
    requestLayout();
    invalidate();
}","{
    if (mAdapter == null)
        return;
    final int adapterCount = getCount();
    if (adapterCount == 0)
        return;
    for (int i = 0; i < mPreviousViews.size(); i++) {
        View viewToRemove = mViewsMap.get(mPreviousViews.get(i)).view;
        mViewsMap.remove(mPreviousViews.get(i));
        viewToRemove.clearAnimation();
        if (viewToRemove instanceof ViewGroup) {
            ViewGroup vg = (ViewGroup) viewToRemove;
            vg.removeAllViewsInLayout();
        }
        // applyTransformForChildAtIndex here just allows for any cleanup
        // associated with this view that may need to be done by a subclass
        applyTransformForChildAtIndex(viewToRemove, -1);
        removeViewInLayout(viewToRemove);
    }
    mPreviousViews.clear();
    int newWindowStartUnbounded = childIndex - mActiveOffset;
    int newWindowEndUnbounded = newWindowStartUnbounded + getNumActiveViews() - 1;
    int newWindowStart = Math.max(0, newWindowStartUnbounded);
    int newWindowEnd = Math.min(adapterCount - 1, newWindowEndUnbounded);
    if (mLoopViews) {
        newWindowStart = newWindowStartUnbounded;
        newWindowEnd = newWindowEndUnbounded;
    }
    int rangeStart = modulo(newWindowStart, getWindowSize());
    int rangeEnd = modulo(newWindowEnd, getWindowSize());
    boolean wrap = false;
    if (rangeStart > rangeEnd) {
        wrap = true;
    }
    // newWindowEndUnbounded > adapterCount - 1
    for (Integer index : mViewsMap.keySet()) {
        boolean remove = false;
        if (!wrap && (index < rangeStart || index > rangeEnd)) {
            remove = true;
        } else if (wrap && (index > rangeEnd && index < rangeStart)) {
            remove = true;
        }
        if (remove) {
            View previousView = mViewsMap.get(index).view;
            int oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            mPreviousViews.add(index);
            transformViewForTransition(oldRelativeIndex, -1, previousView, animate);
        }
    }
    // If the window has changed
    if (!(newWindowStart == mCurrentWindowStart && newWindowEnd == mCurrentWindowEnd && newWindowStartUnbounded == mCurrentWindowStartUnbounded)) {
        // Run through the indices in the new range
        for (int i = newWindowStart; i <= newWindowEnd; i++) {
            int index = modulo(i, getWindowSize());
            int oldRelativeIndex;
            if (mViewsMap.containsKey(index)) {
                oldRelativeIndex = mViewsMap.get(index).relativeIndex;
            } else {
                oldRelativeIndex = -1;
            }
            int newRelativeIndex = i - newWindowStartUnbounded;
            // If this item is in the current window, great, we just need to apply
            // the transform for it's new relative position in the window, and animate
            // between it's current and new relative positions
            boolean inOldRange = mViewsMap.containsKey(index) && !mPreviousViews.contains(index);
            if (inOldRange) {
                View view = mViewsMap.get(index).view;
                mViewsMap.get(index).relativeIndex = newRelativeIndex;
                applyTransformForChildAtIndex(view, newRelativeIndex);
                transformViewForTransition(oldRelativeIndex, newRelativeIndex, view, animate);
            // Otherwise this view is new to the window
            } else {
                // Get the new view from the adapter, add it and apply any transform / animation
                final int adapterPosition = modulo(i, adapterCount);
                View newView = mAdapter.getView(adapterPosition, null, this);
                long itemId = mAdapter.getItemId(adapterPosition);
                // We wrap the new view in a FrameLayout so as to respect the contract
                // with the adapter, that is, that we don't modify this view directly
                FrameLayout fl = getFrameForChild();
                // If the view from the adapter is null, we still keep an empty frame in place
                if (newView != null) {
                    fl.addView(newView);
                }
                mViewsMap.put(index, new ViewAndMetaData(fl, newRelativeIndex, adapterPosition, itemId));
                addChild(fl);
                applyTransformForChildAtIndex(fl, newRelativeIndex);
                transformViewForTransition(-1, newRelativeIndex, fl, animate);
            }
            mViewsMap.get(index).view.bringToFront();
        }
        mCurrentWindowStart = newWindowStart;
        mCurrentWindowEnd = newWindowEnd;
        mCurrentWindowStartUnbounded = newWindowStartUnbounded;
    }
    requestLayout();
    invalidate();
}",1,"/**
 * Shows only the specified child. The other displays Views exit the screen,
 * optionally with the with the {@link #getOutAnimation() out animation} and
 * the specified child enters the screen, optionally with the
 * {@link #getInAnimation() in animation}.
 *
 * @param childIndex The index of the child to be shown.
 * @param animate Whether or not to use the in and out animations, defaults
 * to true.
 */
","/**
 * Shows only the specified child. The other displays Views exit the screen,
 * optionally with the with the {@link #getOutAnimation() out animation} and
 * the specified child enters the screen, optionally with the
 * {@link #getInAnimation() in animation}.
 *
 * @param childIndex The index of the child to be shown.
 * @param animate Whether or not to use the in and out animations, defaults
 * to true.
 */
",0,,,0,,,,,,,,,,
785,"<android.view.View: void setTag(int,Object)>",13,14,,,,"{
    // or a framework id
    if ((key >>> 24) < 2) {
        throw new IllegalArgumentException(""The key must be an application-specific "" + ""resource id."");
    }
    setTagInternal(this, key, tag);
}","{
    // or a framework id
    if ((key >>> 24) < 2) {
        throw new IllegalArgumentException(""The key must be an application-specific "" + ""resource id."");
    }
    setKeyedTag(key, tag);
}",1,"/**
 * Sets a tag associated with this view and a key. A tag can be used
 * to mark a view in its hierarchy and does not have to be unique within
 * the hierarchy. Tags can also be used to store data within a view
 * without resorting to another data structure.
 *
 * The specified key should be an id declared in the resources of the
 * application to ensure it is unique (see the <a
 * href={@docRoot}guide/topics/resources/more-resources.html#Id"">ID resource type</a>).
 * Keys identified as belonging to
 * the Android framework or not associated with any package will cause
 * an {@link IllegalArgumentException} to be thrown.
 *
 * @param key The key identifying the tag
 * @param tag An Object to tag the view with
 *
 * @throws IllegalArgumentException If they specified key is not valid
 *
 * @see #setTag(Object)
 * @see #getTag(int)
 */
","/**
 * Sets a tag associated with this view and a key. A tag can be used
 * to mark a view in its hierarchy and does not have to be unique within
 * the hierarchy. Tags can also be used to store data within a view
 * without resorting to another data structure.
 *
 * The specified key should be an id declared in the resources of the
 * application to ensure it is unique (see the <a
 * href={@docRoot}guide/topics/resources/more-resources.html#Id"">ID resource type</a>).
 * Keys identified as belonging to
 * the Android framework or not associated with any package will cause
 * an {@link IllegalArgumentException} to be thrown.
 *
 * @param key The key identifying the tag
 * @param tag An Object to tag the view with
 *
 * @throws IllegalArgumentException If they specified key is not valid
 *
 * @see #setTag(Object)
 * @see #getTag(int)
 */
",0,,,0,,,,,,,5,0,"The implementation has changed the method being called from `setTagInternal(this, key, tag)` to `setKeyedTag(key, tag)`. This indicates a change in the dependent API, so the code change type is 5.","There is no Compatibility Issue as long as the new method `setKeyedTag(key, tag)` is expected to perform the same operation as the previous `setTagInternal(this, key, tag)` with respect to setting a tag on the View. The API's external behavior seems to remain the same as the change appears to be an internal refactoring. Therefore, the CI type is 0."
786,"<android.accounts.AbstractAccountAuthenticator.Transport: void updateCredentials(IAccountAuthenticatorResponse,Account,String,Bundle)>",13,14,,,,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""updateCredentials: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""updateCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""updateCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""updateCredentials"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""updateCredentials not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""updateCredentials: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.updateCredentials(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""updateCredentials: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""updateCredentials"", account.toString() + "","" + authTokenType, e);
    }
}",1,,,0,,,0,,,,,,,"2,4",2,"An exception handling statement changed from catching specific exceptions (NetworkErrorException and UnsupportedOperationException) to a more general Exception, the use of the handleException method instead of directly calling response.onError with specific error messages and codes is also a change. This results in a change type of 2 and 4 as the replacement of specific exception handlers with a generic one could be classified as an ""Other statement change.""","The change in exception handling can lead to different behavior when exceptions occur. Specifically, the change could modify which error code and message are passed back in the response due to different handling in the handleException method. Consequently, there is a potential for different exception handling in the two versions of the API, thus the CI type is 2."
787,<android.view.accessibility.AccessibilityManager: void interrupt()>,13,14,,,,"{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    try {
        mService.interrupt();
        if (LOGV) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}","{
    if (!mIsEnabled) {
        throw new IllegalStateException(""Accessibility off. Did you forget to check that?"");
    }
    try {
        mService.interrupt();
        if (DEBUG) {
            Log.i(LOG_TAG, ""Requested interrupt from all services"");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error while requesting interrupt from all services. "", re);
    }
}",1,"/**
 * Requests interruption of the accessibility feedback from all accessibility services.
 */
","/**
 * Requests feedback interruption from all accessibility services.
 */
",1,,,0,,,,,,,4,0,"The only change is in a logging condition, where LOGV is replaced with DEBUG. So the code change type is 4.","The change is purely in a logging condition and will not affect the API's behavior, as it does not change how exceptions are handled or how return values are determined. Therefore, there is no Compatibility Issue; the CI type is 0."
788,<android.view.View: float getY()>,13,14,,,,"{
    return mTop + mTranslationY;
}","{
    return mTop + (mTransformationInfo != null ? mTransformationInfo.mTranslationY : 0);
}",1,"/**
 * The visual y position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationY(float) translationY} property plus the current
 * {@link #getTop() top} property.
 *
 * @return The visual y position of this view, in pixels.
 */
","/**
 * The visual y position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationY(float) translationY} property plus the current
 * {@link #getTop() top} property.
 *
 * @return The visual y position of this view, in pixels.
 */
",0,,,0,,,,,,,4,1,"The implementation for calculating 'getY()' now involves an additional null check, and the value it returns may depend on the 'mTransformationInfo' object, so the change type is 4 (Other statement changed).","The change in the way the return value is calculated could potentially return a different value because it now takes into account whether 'mTransformationInfo' is null and uses 'mTranslationY' from 'mTransformationInfo' if it's not null. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
789,<android.inputmethodservice.KeyboardView: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    // Convert multi-pointer up/down events to single up/down events to
    // deal with the typical multi-pointer behavior of two-thumb typing
    final int pointerCount = me.getPointerCount();
    final int action = me.getAction();
    boolean result = false;
    final long now = me.getEventTime();
    if (pointerCount != mOldPointerCount) {
        if (pointerCount == 1) {
            // Send a down event for the latest pointer
            MotionEvent down = MotionEvent.obtain(now, now, MotionEvent.ACTION_DOWN, me.getX(), me.getY(), me.getMetaState());
            result = onModifiedTouchEvent(down, false);
            down.recycle();
            // If it's an up action, then deliver the up as well.
            if (action == MotionEvent.ACTION_UP) {
                result = onModifiedTouchEvent(me, true);
            }
        } else {
            // Send an up event for the last pointer
            MotionEvent up = MotionEvent.obtain(now, now, MotionEvent.ACTION_UP, mOldPointerX, mOldPointerY, me.getMetaState());
            result = onModifiedTouchEvent(up, true);
            up.recycle();
        }
    } else {
        if (pointerCount == 1) {
            result = onModifiedTouchEvent(me, false);
            mOldPointerX = me.getX();
            mOldPointerY = me.getY();
        } else {
            // Don't do anything when 2 pointers are down and moving.
            result = true;
        }
    }
    mOldPointerCount = pointerCount;
    return result;
}","{
    // location generates hover and touch events.
    if (mAccessibilityManager.isTouchExplorationEnabled()) {
        return true;
    }
    return onTouchEventInternal(event);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4","1,2","The entire method's body has significantly changed. The new implementation delegates the event handling to onTouchEventInternal or returns 'true' immediately based on certain condition, removing all previous logic and variables. This includes a new control dependency on the state of 'mAccessibilityManager.isTouchExplorationEnabled()', changes in the control flow with the removal of the old pointer count logic, and the deletion of local variable declarations and assignments. Hence, the change types are 1 for the return statement which could return a different value, 3 for the control dependency change, and 4 for other statement changes.","Given that there is a substantial change in the control flow logic as well as in the return value, this can lead to compatibility issues due to different returned values and the method behaving differently in exception handling scenarios. For instance, the early version does not throw any exception, but the late version could throw an exception indirectly through onTouchEventInternal. Therefore, the CI types are 1 for potential different return values and 2 for potential different exception handlings."
790,<android.view.View: float getRotation()>,13,14,,,,"{
    return mRotation;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mRotation : 0;
}",1,"/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
","/**
 * The degrees that the view is rotated around the pivot point.
 *
 * @see #setRotation(float)
 * @see #getPivotX()
 * @see #getPivotY()
 *
 * @return The degrees of rotation.
 */
",0,,,0,,,,,,,"1,4",1,"The return statement in the late version uses a ternary conditional operator checking for nullity of mTransformationInfo, which wasn't present in the early version. Additionally, there's an addition of member reference mTransformationInfo.mRotation. These changes constitute a change under the categories 1 and 4.","The change to the return statement may potentially return a different value because the result now depends on whether mTransformationInfo is null. If it's null, the method will return 0, which could be different from the value stored in mRotation in the early version. Thus, there's a potential Compatibility Issue of type 1."
791,"<android.webkit.WebView: boolean onKeyDown(int,KeyEvent)>",13,14,,,,"{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // to act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), true, event.getMetaState());
            return true;
        }
        if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_UP:
                    pageUp(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_DOWN:
                    pageDown(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(0, mScrollY, true, 0);
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(mContentWidth, mScrollY, true, 0);
            }
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        boolean wantsKeyEvents = nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            nativeRecordButtons(hasFocus() && hasWindowFocus(), true, true);
            if (!wantsKeyEvents)
                return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        if (!wantsKeyEvents)
            return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus.
        mWebViewCore.sendMessage(EventHub.FAKE_CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}","{
    if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG, ""keyDown at "" + System.currentTimeMillis() + ""keyCode="" + keyCode + "", "" + event + "", unicode="" + event.getUnicodeChar());
    }
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // don't implement accelerator keys here; defer to host application
    if (event.isCtrlPressed()) {
        return false;
    }
    if (mNativeClass == 0) {
        return false;
    }
    // do this hack up front, so it always works, regardless of touch-mode
    if (AUTO_REDRAW_HACK && (keyCode == KeyEvent.KEYCODE_CALL)) {
        mAutoRedraw = !mAutoRedraw;
        if (mAutoRedraw) {
            invalidate();
        }
        return true;
    }
    // 2. the host application wants to handle it;
    if (event.isSystem() || mCallbackProxy.uiOverrideKeyEvent(event)) {
        return false;
    }
    // accessibility support
    if (accessibilityScriptInjected()) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            // if an accessibility script is injected we delegate to it the key handling.
            // this script is a screen reader which is a fully fledged solution for blind
            // users to navigate in and interact with web pages.
            mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
            return true;
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityScriptInjected = false;
        }
    } else if (mAccessibilityInjector != null) {
        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
            if (mAccessibilityInjector.onKeyEvent(event)) {
                // to act on and consume the event.
                return true;
            }
        } else {
            // Clean up if accessibility was disabled after loading the current URL.
            mAccessibilityInjector = null;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_UP) {
        if (event.hasNoModifiers()) {
            pageUp(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageUp(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_PAGE_DOWN) {
        if (event.hasNoModifiers()) {
            pageDown(false);
            return true;
        } else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            pageDown(true);
            return true;
        }
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_HOME && event.hasNoModifiers()) {
        pageUp(true);
        return true;
    }
    if (keyCode == KeyEvent.KEYCODE_MOVE_END && event.hasNoModifiers()) {
        pageDown(true);
        return true;
    }
    if (keyCode >= KeyEvent.KEYCODE_DPAD_UP && keyCode <= KeyEvent.KEYCODE_DPAD_RIGHT) {
        switchOutDrawHistory();
        if (nativePageShouldHandleShiftAndArrows()) {
            letPageHandleNavKey(keyCode, event.getEventTime(), true, event.getMetaState());
            return true;
        }
        if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_UP:
                    pageUp(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_DOWN:
                    pageDown(true);
                    return true;
                case KeyEvent.KEYCODE_DPAD_LEFT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(0, mScrollY, true, 0);
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                    // start next trackball movement from page edge
                    nativeClearCursor();
                    return pinScrollTo(mContentWidth, mScrollY, true, 0);
            }
        }
        if (mSelectingText) {
            int xRate = keyCode == KeyEvent.KEYCODE_DPAD_LEFT ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_RIGHT ? 1 : 0;
            int yRate = keyCode == KeyEvent.KEYCODE_DPAD_UP ? -1 : keyCode == KeyEvent.KEYCODE_DPAD_DOWN ? 1 : 0;
            int multiplier = event.getRepeatCount() + 1;
            moveSelection(xRate * multiplier, yRate * multiplier);
            return true;
        }
        if (navHandledKey(keyCode, 1, false, event.getEventTime())) {
            playSoundEffect(keyCodeToSoundsEffect(keyCode));
            return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        return false;
    }
    if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
        switchOutDrawHistory();
        boolean wantsKeyEvents = nativeCursorNodePointer() == 0 || nativeCursorWantsKeyEvents();
        if (event.getRepeatCount() == 0) {
            if (mSelectingText) {
                // discard press if copy in progress
                return true;
            }
            mGotCenterDown = true;
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(LONG_PRESS_CENTER), LONG_PRESS_TIMEOUT);
            // Already checked mNativeClass, so we do not need to check it
            // again.
            recordButtons(null, hasFocus() && hasWindowFocus(), true, true);
            if (!wantsKeyEvents)
                return true;
        }
        // Bubble up the key event as WebView doesn't handle it
        if (!wantsKeyEvents)
            return false;
    }
    if (getSettings().getNavDump()) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_4:
                dumpDisplayTree();
                break;
            case KeyEvent.KEYCODE_5:
            case KeyEvent.KEYCODE_6:
                dumpDomTree(keyCode == KeyEvent.KEYCODE_5);
                break;
            case KeyEvent.KEYCODE_7:
            case KeyEvent.KEYCODE_8:
                dumpRenderTree(keyCode == KeyEvent.KEYCODE_7);
                break;
            case KeyEvent.KEYCODE_9:
                nativeInstrumentReport();
                return true;
        }
    }
    if (nativeCursorIsTextInput()) {
        // This message will put the node in focus, for the DOM's notion
        // of focus.
        mWebViewCore.sendMessage(EventHub.FAKE_CLICK, nativeCursorFramePointer(), nativeCursorNodePointer());
        // This will bring up the WebTextView and put it in focus, for
        // our view system's notion of focus
        rebuildWebTextView();
        // Now we need to pass the event to it
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    } else if (nativeHasFocusNode()) {
        // In this case, the cursor is not on a text input, but the focus
        // might be.  Check it, and if so, hand over to the WebTextView.
        rebuildWebTextView();
        if (inEditingMode()) {
            mWebTextView.setDefaultSelection();
            return mWebTextView.dispatchKeyEvent(event);
        }
    }
    // TODO: should we pass all the keys to DOM or check the meta tag
    if (nativeCursorWantsKeyEvents() || true) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        // return true as DOM handles the key
        return true;
    }
    // Bubble up the key event as WebView doesn't handle it
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
793,"<android.webkit.WebViewFragment: View onCreateView(LayoutInflater,ViewGroup,Bundle)>",13,14,,,,"{
    mWebView = new WebView(getActivity());
    return mWebView;
}","{
    if (mWebView != null) {
        mWebView.destroy();
    }
    mWebView = new WebView(getActivity());
    mIsWebViewAvailable = true;
    return mWebView;
}",1,"/**
 * Called to instantiate the view. Creates and returns the WebView.
 */
","/**
 * Called to instantiate the view. Creates and returns the WebView.
 */
",0,[@Override],[@Override],0,,,,,,,4,0,"There's an addition of an if-statement that destroys the current `mWebView` if it's not null, and a new field `mIsWebViewAvailable` is set to true in the late implementation. The return statement remains the same. The code change type is 4 as other statements have changed but they do not affect the return value.","There is no compatibility issue because the return value (`mWebView`) is still the same type `WebView`, and it is still getting initialized in the same way (`new WebView(getActivity())`). The additional code doesn't change the return type or value. Thus, the CI type is 0."
795,"<android.webkit.WebView: boolean restorePicture(Bundle,File)>",13,14,,,,"{
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                try {
                    final Picture p = Picture.createFromStream(in);
                    if (p != null) {
                        // Post a runnable on the main thread to update the
                        // history picture fields.
                        mPrivateHandler.post(new Runnable() {

                            public void run() {
                                restoreHistoryPictureFields(p, copy);
                            }
                        });
                    }
                } finally {
                    try {
                        in.close();
                    } catch (Exception e) {
                    // Nothing we can do now.
                    }
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}","{
    checkThread();
    if (src == null || b == null) {
        return false;
    }
    if (!src.exists()) {
        return false;
    }
    try {
        final FileInputStream in = new FileInputStream(src);
        final Bundle copy = new Bundle(b);
        new Thread(new Runnable() {

            public void run() {
                try {
                    final Picture p = Picture.createFromStream(in);
                    if (p != null) {
                        // Post a runnable on the main thread to update the
                        // history picture fields.
                        mPrivateHandler.post(new Runnable() {

                            public void run() {
                                restoreHistoryPictureFields(p, copy);
                            }
                        });
                    }
                } finally {
                    try {
                        in.close();
                    } catch (Exception e) {
                    // Nothing we can do now.
                    }
                }
            }
        }).start();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    return true;
}",1,"/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 * @deprecated This method is now obsolete.
 */
","/**
 * Restore the display data that was save in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}.
 *
 * Note that this will not work if the WebView is hardware accelerated.
 * @param b A Bundle containing the saved display data.
 * @param src The file where the picture data was stored.
 * @return True if the picture was successfully restored.
 * @deprecated This method is now obsolete.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,"There is no change in the implementation between the early and late versions, and the annotations are the same.","Since there is no change in the implementation, there is no compatibility issue between the two versions."
798,<android.webkit.WebTextView: void setType(int)>,13,14,,,,"{
    if (mWebView == null)
        return;
    boolean single = true;
    boolean inPassword = false;
    int maxLength = -1;
    int inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT;
    int imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI | EditorInfo.IME_FLAG_NO_FULLSCREEN;
    if (TEXT_AREA != type && mWebView.nativeFocusCandidateHasNextTextfield()) {
        imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
    }
    switch(type) {
        case NORMAL_TEXT_FIELD:
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case TEXT_AREA:
            single = false;
            inputType |= EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE | EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES | EditorInfo.TYPE_TEXT_FLAG_AUTO_CORRECT;
            imeOptions |= EditorInfo.IME_ACTION_NONE;
            break;
        case PASSWORD:
            inPassword = true;
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case SEARCH:
            imeOptions |= EditorInfo.IME_ACTION_SEARCH;
            break;
        case EMAIL:
            // inputType needs to be overwritten because of the different text variation.
            inputType = EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS;
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case NUMBER:
            // inputType needs to be overwritten because of the different class.
            inputType = EditorInfo.TYPE_CLASS_NUMBER | EditorInfo.TYPE_NUMBER_VARIATION_NORMAL;
            // Number and telephone do not have both a Tab key and an
            // action, so set the action to NEXT
            imeOptions |= EditorInfo.IME_ACTION_NEXT;
            break;
        case TELEPHONE:
            // inputType needs to be overwritten because of the different class.
            inputType = EditorInfo.TYPE_CLASS_PHONE;
            imeOptions |= EditorInfo.IME_ACTION_NEXT;
            break;
        case URL:
            // TYPE_TEXT_VARIATION_URI prevents Tab key from showing, so
            // exclude it for now.
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        default:
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
    }
    setHint(null);
    if (single) {
        mWebView.requestLabel(mWebView.nativeFocusCandidateFramePointer(), mNodePointer);
        maxLength = mWebView.nativeFocusCandidateMaxLength();
        boolean autoComplete = mWebView.nativeFocusCandidateIsAutoComplete();
        if (type != PASSWORD && (mAutoFillable || autoComplete)) {
            String name = mWebView.nativeFocusCandidateName();
            if (name != null && name.length() > 0) {
                mWebView.requestFormData(name, mNodePointer, mAutoFillable, autoComplete);
            }
        }
    }
    mSingle = single;
    setMaxLength(maxLength);
    setHorizontallyScrolling(single);
    setInputType(inputType);
    setImeOptions(imeOptions);
    setInPassword(inPassword);
    AutoCompleteAdapter adapter = null;
    setAdapterCustom(adapter);
}","{
    if (mWebView == null)
        return;
    boolean single = true;
    int maxLength = -1;
    int inputType = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT;
    int imeOptions = EditorInfo.IME_FLAG_NO_EXTRACT_UI | EditorInfo.IME_FLAG_NO_FULLSCREEN;
    if (!mWebView.nativeFocusCandidateIsSpellcheck()) {
        inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
    }
    if (TEXT_AREA != type && mWebView.nativeFocusCandidateHasNextTextfield()) {
        imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT;
    }
    switch(type) {
        case NORMAL_TEXT_FIELD:
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case TEXT_AREA:
            single = false;
            inputType |= InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;
            imeOptions |= EditorInfo.IME_ACTION_NONE;
            break;
        case PASSWORD:
            inputType |= EditorInfo.TYPE_TEXT_VARIATION_WEB_PASSWORD;
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case SEARCH:
            imeOptions |= EditorInfo.IME_ACTION_SEARCH;
            break;
        case EMAIL:
            // inputType needs to be overwritten because of the different text variation.
            inputType = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS;
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        case NUMBER:
            // inputType needs to be overwritten because of the different class.
            inputType = InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_VARIATION_NORMAL | InputType.TYPE_NUMBER_FLAG_SIGNED | InputType.TYPE_NUMBER_FLAG_DECIMAL;
            // Number and telephone do not have both a Tab key and an
            // action, so set the action to NEXT
            imeOptions |= EditorInfo.IME_ACTION_NEXT;
            break;
        case TELEPHONE:
            // inputType needs to be overwritten because of the different class.
            inputType = InputType.TYPE_CLASS_PHONE;
            imeOptions |= EditorInfo.IME_ACTION_NEXT;
            break;
        case URL:
            // TYPE_TEXT_VARIATION_URI prevents Tab key from showing, so
            // exclude it for now.
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
        default:
            imeOptions |= EditorInfo.IME_ACTION_GO;
            break;
    }
    setHint(null);
    setThreshold(1);
    boolean autoComplete = false;
    if (single) {
        mWebView.requestLabel(mWebView.nativeFocusCandidateFramePointer(), mNodePointer);
        maxLength = mWebView.nativeFocusCandidateMaxLength();
        autoComplete = mWebView.nativeFocusCandidateIsAutoComplete();
        if (type != PASSWORD && (mAutoFillable || autoComplete)) {
            String name = mWebView.nativeFocusCandidateName();
            if (name != null && name.length() > 0) {
                mWebView.requestFormData(name, mNodePointer, mAutoFillable, autoComplete);
            }
        }
    }
    mSingle = single;
    setMaxLength(maxLength);
    setHorizontallyScrolling(single);
    setInputType(inputType);
    clearComposingText();
    setImeOptions(imeOptions);
    setVisibility(VISIBLE);
    if (!autoComplete) {
        setAdapterCustom(null);
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,,,,
800,<android.server.BluetoothService: boolean disconnectPanDevice(BluetoothDevice)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    return mBluetoothPanProfileHandler.disconnectPanDevice(device);
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    synchronized (mBluetoothPanProfileHandler) {
        return mBluetoothPanProfileHandler.disconnectPanDevice(device);
    }
}",1,,,0,,,0,,,,,,,3,0,"The change is related to adding a synchronized block around the existing return statement; no other code changes are observed, and so the change type is 3.","The addition of a synchronized block does not change the behavior of the return value or the exceptions that might be thrown, so there is no compatibility issue in that regard. The synchronization only affects the thread-safety of the method, which isn't a compatibility issue for clients calling this method. Hence, the CI type is 0."
801,"<android.view.LayoutInflater: View inflate(XmlPullParser,ViewGroup,boolean)>",13,14,,,,"{
    synchronized (mConstructorArgs) {
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                View temp = createViewFromTag(root, name, attrs);
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        return result;
    }
}","{
    synchronized (mConstructorArgs) {
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = mContext;
        View result = root;
        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
            // Empty
            }
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + "": No start tag found!"");
            }
            final String name = parser.getName();
            if (DEBUG) {
                System.out.println(""**************************"");
                System.out.println(""Creating root view: "" + name);
                System.out.println(""**************************"");
            }
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(""<merge /> can be used only with a valid "" + ""ViewGroup root and attachToRoot=true"");
                }
                rInflate(parser, root, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                View temp;
                if (TAG_1995.equals(name)) {
                    temp = new BlinkLayout(mContext, attrs);
                } else {
                    temp = createViewFromTag(root, name, attrs);
                }
                ViewGroup.LayoutParams params = null;
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(""Creating params from root: "" + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }
                if (DEBUG) {
                    System.out.println(""-----> start inflating children"");
                }
                // Inflate all children under temp
                rInflate(parser, temp, attrs, true);
                if (DEBUG) {
                    System.out.println(""-----> done inflating children"");
                }
                // to root. Do that now.
                if (root != null && attachToRoot) {
                    root.addView(temp, params);
                }
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (IOException e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + "": "" + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don't retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }
        return result;
    }
}",1,"/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
","/**
 * Inflate a new view hierarchy from the specified XML node. Throws
 * {@link InflateException} if there is an error.
 * <p>
 * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
 * reasons, view inflation relies heavily on pre-processing of XML files
 * that is done at build time. Therefore, it is not currently possible to
 * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
 *
 * @param parser XML dom node containing the description of the view
 * hierarchy.
 * @param root Optional view to be the parent of the generated hierarchy (if
 * <em>attachToRoot</em> is true), or else simply an object that
 * provides a set of LayoutParams values for root of the returned
 * hierarchy (if <em>attachToRoot</em> is false.)
 * @param attachToRoot Whether the inflated hierarchy should be attached to
 * the root parameter? If false, root is only used to create the
 * correct subclass of LayoutParams for the root view in the XML.
 * @return The root View of the inflated hierarchy. If root was supplied and
 * attachToRoot is true, this is root; otherwise it is the root of
 * the inflated XML file.
 */
",0,,,0,,,,,,,,,,
802,<android.widget.ListView: void layoutChildren()>,13,14,,,,"{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewRoot assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}","{
    final boolean blockLayoutRequests = mBlockLayoutRequests;
    if (!blockLayoutRequests) {
        mBlockLayoutRequests = true;
    } else {
        return;
    }
    try {
        super.layoutChildren();
        invalidate();
        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }
        int childrenTop = mListPadding.top;
        int childrenBottom = mBottom - mTop - mListPadding.bottom;
        int childCount = getChildCount();
        int index = 0;
        int delta = 0;
        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;
        View focusLayoutRestoreView = null;
        // Remember stuff we will need down below
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                index = mNextSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    newSel = getChildAt(index);
                }
                break;
            case LAYOUT_FORCE_TOP:
            case LAYOUT_FORCE_BOTTOM:
            case LAYOUT_SPECIFIC:
            case LAYOUT_SYNC:
                break;
            case LAYOUT_MOVE_SELECTION:
            default:
                // Remember the previously selected view
                index = mSelectedPosition - mFirstPosition;
                if (index >= 0 && index < childCount) {
                    oldSel = getChildAt(index);
                }
                // Remember the previous first child
                oldFirst = getChildAt(0);
                if (mNextSelectedPosition >= 0) {
                    delta = mNextSelectedPosition - mSelectedPosition;
                }
                // Caution: newSel might be null
                newSel = getChildAt(index + delta);
        }
        boolean dataChanged = mDataChanged;
        if (dataChanged) {
            handleDataChanged();
        }
        // and calling it a day
        if (mItemCount == 0) {
            resetList();
            invokeOnItemScrollListener();
            return;
        } else if (mItemCount != mAdapter.getCount()) {
            throw new IllegalStateException(""The content of the adapter has changed but "" + ""ListView did not receive a notification. Make sure the content of "" + ""your adapter is not modified from a background thread, but only "" + ""from the UI thread. [in ListView("" + getId() + "", "" + getClass() + "") with Adapter("" + mAdapter.getClass() + "")]"");
        }
        setSelectedPositionInt(mNextSelectedPosition);
        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        // reset the focus restoration
        View focusLayoutRestoreDirectChild = null;
        // already cached in mHeaderViews;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition + i);
                if (ViewDebug.TRACE_RECYCLER) {
                    ViewDebug.trace(getChildAt(i), ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);
                }
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }
        // take focus back to us temporarily to avoid the eventual
        // call to clear focus when removing the focused child below
        // from messing things up when ViewAncestor assigns focus back
        // to someone else
        final View focusedChild = getFocusedChild();
        if (focusedChild != null) {
            // data hasn't changed, or if the focused position is a header or footer
            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
                focusLayoutRestoreDirectChild = focusedChild;
                // remember the specific view that had focus
                focusLayoutRestoreView = findFocus();
                if (focusLayoutRestoreView != null) {
                    // tell it we are going to mess with it
                    focusLayoutRestoreView.onStartTemporaryDetach();
                }
            }
            requestFocus();
        }
        // Clear out old views
        detachAllViewsFromParent();
        switch(mLayoutMode) {
            case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
            case LAYOUT_SYNC:
                sel = fillSpecific(mSyncPosition, mSpecificTop);
                break;
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_SPECIFIC:
                sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
                break;
            case LAYOUT_MOVE_SELECTION:
                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                break;
            default:
                if (childCount == 0) {
                    if (!mStackFromBottom) {
                        final int position = lookForSelectablePosition(0, true);
                        setSelectedPositionInt(position);
                        sel = fillFromTop(childrenTop);
                    } else {
                        final int position = lookForSelectablePosition(mItemCount - 1, false);
                        setSelectedPositionInt(position);
                        sel = fillUp(mItemCount - 1, childrenBottom);
                    }
                } else {
                    if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                        sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                    } else if (mFirstPosition < mItemCount) {
                        sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                    } else {
                        sel = fillSpecific(0, childrenTop);
                    }
                }
                break;
        }
        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();
        if (sel != null) {
            // are focusable
            if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
                if (!focusWasTaken) {
                    // selected item didn't take focus, fine, but still want
                    // to make sure something else outside of the selected view
                    // has focus
                    final View focused = getFocusedChild();
                    if (focused != null) {
                        focused.clearFocus();
                    }
                    positionSelector(INVALID_POSITION, sel);
                } else {
                    sel.setSelected(false);
                    mSelectorRect.setEmpty();
                }
            } else {
                positionSelector(INVALID_POSITION, sel);
            }
            mSelectedTop = sel.getTop();
        } else {
            if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
                View child = getChildAt(mMotionPosition - mFirstPosition);
                if (child != null)
                    positionSelector(mMotionPosition, child);
            } else {
                mSelectedTop = 0;
                mSelectorRect.setEmpty();
            }
            // focus (i.e. something focusable in touch mode)
            if (hasFocus() && focusLayoutRestoreView != null) {
                focusLayoutRestoreView.requestFocus();
            }
        }
        // our view hierarchy.
        if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
            focusLayoutRestoreView.onFinishTemporaryDetach();
        }
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;
        mNeedSync = false;
        setNextSelectedPositionInt(mSelectedPosition);
        updateScrollIndicators();
        if (mItemCount > 0) {
            checkSelectionChanged();
        }
        invokeOnItemScrollListener();
    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
803,<android.animation.PropertyValuesHolder.IntPropertyValuesHolder: void setupSetter(Class)>,13,14,,,,"{
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
    // System.out.println(""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}","{
    if (mProperty != null) {
        return;
    }
    // Check new static hashmap<propName, int> for setter method
    try {
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Integer> propertyMap = sJNISetterPropertyMap.get(targetClass);
        if (propertyMap != null) {
            Integer mJniSetterInteger = propertyMap.get(mPropertyName);
            if (mJniSetterInteger != null) {
                mJniSetter = mJniSetterInteger;
            }
        }
        if (mJniSetter == 0) {
            String methodName = getMethodName(""set"", mPropertyName);
            mJniSetter = nGetIntMethod(targetClass, methodName);
            if (mJniSetter != 0) {
                if (propertyMap == null) {
                    propertyMap = new HashMap<String, Integer>();
                    sJNISetterPropertyMap.put(targetClass, propertyMap);
                }
                propertyMap.put(mPropertyName, mJniSetter);
            }
        }
    } catch (NoSuchMethodError e) {
        Log.d(""PropertyValuesHolder"", ""Can't find native method using JNI, use reflection"" + e);
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    if (mJniSetter == 0) {
        // Couldn't find method through fast JNI approach - just use reflection
        super.setupSetter(targetClass);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",1,"The addition of the check `if (mProperty != null)` and the logging in the catch block imply changes categorized under control dependency and other statement, so the code change type is 3,4.","The introduction of a new control dependency `if (mProperty != null)` at the start of the method adds a return path that could potentially return from the method early without setting up a setter, leading to a behavior where the setter might not be configured as it would have in the previous version. This change can lead to a different behavior when the method is invoked, implying a potential Compatibility Issue of type 1."
804,"<android.os.Binder: boolean transact(int,Parcel,Parcel,int)>",13,14,,,,"{
    if (Config.LOGV)
        Log.v(""Binder"", ""Transact: "" + code + "" to "" + this);
    if (data != null) {
        data.setDataPosition(0);
    }
    boolean r = onTransact(code, data, reply, flags);
    if (reply != null) {
        reply.setDataPosition(0);
    }
    return r;
}","{
    if (false)
        Log.v(""Binder"", ""Transact: "" + code + "" to "" + this);
    if (data != null) {
        data.setDataPosition(0);
    }
    boolean r = onTransact(code, data, reply, flags);
    if (reply != null) {
        reply.setDataPosition(0);
    }
    return r;
}",1,"/**
 * Default implementation rewinds the parcels and calls onTransact.  On
 * the remote side, transact calls into the binder to do the IPC.
 */
","/**
 * Default implementation rewinds the parcels and calls onTransact.  On
 * the remote side, transact calls into the binder to do the IPC.
 */
",0,,,0,,,,,,,4,0,"The only change is the condition for the logging statement which has been hardcoded to 'false', thus preventing the log statement from executing. This is classified as an other statement changed, which is type 4.",The logging change is not related to the API's functionality and does not affect the return value or the exceptions thrown. No Compatibility Issue arises from this change.
805,"<android.widget.StackView.LayoutParams: void invalidateGlobalRegion(View,Rect)>",13,14,,,,"{
    // We need to make a new rect here, so as not to modify the one passed
    globalInvalidateRect.set(r);
    globalInvalidateRect.union(0, 0, getWidth(), getHeight());
    View p = v;
    if (!(v.getParent() != null && v.getParent() instanceof View))
        return;
    boolean firstPass = true;
    parentRect.set(0, 0, 0, 0);
    int depth = 0;
    while (p.getParent() != null && p.getParent() instanceof View && !parentRect.contains(globalInvalidateRect)) {
        if (!firstPass) {
            globalInvalidateRect.offset(p.getLeft() - p.getScrollX(), p.getTop() - p.getScrollY());
            depth++;
        }
        firstPass = false;
        p = (View) p.getParent();
        parentRect.set(p.getScrollX(), p.getScrollY(), p.getWidth() + p.getScrollX(), p.getHeight() + p.getScrollY());
        p.invalidate(globalInvalidateRect.left, globalInvalidateRect.top, globalInvalidateRect.right, globalInvalidateRect.bottom);
    }
    p.invalidate(globalInvalidateRect.left, globalInvalidateRect.top, globalInvalidateRect.right, globalInvalidateRect.bottom);
}","{
    // We need to make a new rect here, so as not to modify the one passed
    globalInvalidateRect.set(r);
    globalInvalidateRect.union(0, 0, getWidth(), getHeight());
    View p = v;
    if (!(v.getParent() != null && v.getParent() instanceof View))
        return;
    boolean firstPass = true;
    parentRect.set(0, 0, 0, 0);
    while (p.getParent() != null && p.getParent() instanceof View && !parentRect.contains(globalInvalidateRect)) {
        if (!firstPass) {
            globalInvalidateRect.offset(p.getLeft() - p.getScrollX(), p.getTop() - p.getScrollY());
        }
        firstPass = false;
        p = (View) p.getParent();
        parentRect.set(p.getScrollX(), p.getScrollY(), p.getWidth() + p.getScrollX(), p.getHeight() + p.getScrollY());
        p.invalidate(globalInvalidateRect.left, globalInvalidateRect.top, globalInvalidateRect.right, globalInvalidateRect.bottom);
    }
    p.invalidate(globalInvalidateRect.left, globalInvalidateRect.top, globalInvalidateRect.right, globalInvalidateRect.bottom);
}",1,,,0,,,0,,,,,,,"3,4",0,"The late version removes the variable 'depth', so this is an 'Other statement changed'. The condition statement in the while loop is not changed, but the indentation and the placement of 'firstPass' check within the loop have been modified. This would count as a 'Control dependency change' due to the modification within the control structure.","There is no Compatibility Issue as the final behavior of the API does not change. The removal of the 'depth' variable does not affect the API's output or side effects, and the changes within the loop do not change the condition under which iterations occur, nor the final outcome. The firstPass logic is still effectively the same (it prevents offsetting during the first pass), and the rest of the code remains functionally equivalent to ensure the same result is produced."
807,<android.webkit.CallbackProxy: void handleMessage(Message)>,13,14,,,,"{
    // 32-bit reads and writes.
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView, startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView, finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView, (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView, (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView, (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView, reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView, dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView, handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView, (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView, mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView, (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView, (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView, msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView);
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow((WebView) msg.obj);
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView, (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long currentQuota = ((Long) map.get(""currentQuota"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                long estimatedSize = ((Long) map.get(""estimatedSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, currentQuota, estimatedSize, totalUsedQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long spaceNeeded = ((Long) map.get(""spaceNeeded"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsPromptResult res = (JsPromptResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView, url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                res.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView, msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case SET_INSTALLABLE_WEBAPP:
            if (mWebChromeClient != null) {
                mWebChromeClient.setInstallableWebApp();
            }
            break;
        case NOTIFY_SEARCHBOX_LISTENERS:
            SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
            @SuppressWarnings(""unchecked"") List<String> suggestions = (List<String>) msg.obj;
            searchBox.handleSuggestions(msg.getData().getString(""query""), suggestions);
            break;
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView, realm, account, args);
                }
                break;
            }
    }
}","{
    // 32-bit reads and writes.
    switch(msg.what) {
        case PAGE_STARTED:
            String startedUrl = msg.getData().getString(""url"");
            mWebView.onPageStarted(startedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageStarted(mWebView, startedUrl, (Bitmap) msg.obj);
            }
            break;
        case PAGE_FINISHED:
            String finishedUrl = (String) msg.obj;
            mWebView.onPageFinished(finishedUrl);
            if (mWebViewClient != null) {
                mWebViewClient.onPageFinished(mWebView, finishedUrl);
            }
            break;
        case RECEIVED_ICON:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedIcon(mWebView, (Bitmap) msg.obj);
            }
            break;
        case RECEIVED_TOUCH_ICON_URL:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTouchIconUrl(mWebView, (String) msg.obj, msg.arg1 == 1);
            }
            break;
        case RECEIVED_TITLE:
            if (mWebChromeClient != null) {
                mWebChromeClient.onReceivedTitle(mWebView, (String) msg.obj);
            }
            break;
        case REPORT_ERROR:
            if (mWebViewClient != null) {
                int reasonCode = msg.arg1;
                final String description = msg.getData().getString(""description"");
                final String failUrl = msg.getData().getString(""failingUrl"");
                mWebViewClient.onReceivedError(mWebView, reasonCode, description, failUrl);
            }
            break;
        case RESEND_POST_DATA:
            Message resend = (Message) msg.getData().getParcelable(""resend"");
            Message dontResend = (Message) msg.getData().getParcelable(""dontResend"");
            if (mWebViewClient != null) {
                mWebViewClient.onFormResubmission(mWebView, dontResend, resend);
            } else {
                dontResend.sendToTarget();
            }
            break;
        case OVERRIDE_URL:
            String overrideUrl = msg.getData().getString(""url"");
            boolean override = uiOverrideUrlLoading(overrideUrl);
            ResultTransport<Boolean> result = (ResultTransport<Boolean>) msg.obj;
            synchronized (this) {
                result.setResult(override);
                notify();
            }
            break;
        case AUTH_REQUEST:
            if (mWebViewClient != null) {
                HttpAuthHandler handler = (HttpAuthHandler) msg.obj;
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                mWebViewClient.onReceivedHttpAuthRequest(mWebView, handler, host, realm);
            }
            break;
        case SSL_ERROR:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedSslError(mWebView, (SslErrorHandler) map.get(""handler""), (SslError) map.get(""error""));
            }
            break;
        case PROCEEDED_AFTER_SSL_ERROR:
            if (mWebViewClient != null) {
                mWebViewClient.onProceededAfterSslError(mWebView, (SslError) msg.obj);
            }
            break;
        case CLIENT_CERT_REQUEST:
            if (mWebViewClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                mWebViewClient.onReceivedClientCertRequest(mWebView, (ClientCertRequestHandler) map.get(""handler""), (String) map.get(""host_and_port""));
            }
            break;
        case PROGRESS:
            // changed.
            synchronized (this) {
                if (mWebChromeClient != null) {
                    mWebChromeClient.onProgressChanged(mWebView, mLatestProgress);
                }
                mProgressUpdatePending = false;
            }
            break;
        case UPDATE_VISITED:
            if (mWebViewClient != null) {
                mWebViewClient.doUpdateVisitedHistory(mWebView, (String) msg.obj, msg.arg1 != 0);
            }
            break;
        case LOAD_RESOURCE:
            if (mWebViewClient != null) {
                mWebViewClient.onLoadResource(mWebView, (String) msg.obj);
            }
            break;
        case DOWNLOAD_FILE:
            if (mDownloadListener != null) {
                String url = msg.getData().getString(""url"");
                String userAgent = msg.getData().getString(""userAgent"");
                String contentDisposition = msg.getData().getString(""contentDisposition"");
                String mimetype = msg.getData().getString(""mimetype"");
                Long contentLength = msg.getData().getLong(""contentLength"");
                mDownloadListener.onDownloadStart(url, userAgent, contentDisposition, mimetype, contentLength);
            }
            break;
        case CREATE_WINDOW:
            if (mWebChromeClient != null) {
                if (!mWebChromeClient.onCreateWindow(mWebView, msg.arg1 == 1, msg.arg2 == 1, (Message) msg.obj)) {
                    synchronized (this) {
                        notify();
                    }
                }
                mWebView.dismissZoomControl();
            }
            break;
        case REQUEST_FOCUS:
            if (mWebChromeClient != null) {
                mWebChromeClient.onRequestFocus(mWebView);
            }
            break;
        case CLOSE_WINDOW:
            if (mWebChromeClient != null) {
                mWebChromeClient.onCloseWindow((WebView) msg.obj);
            }
            break;
        case SAVE_PASSWORD:
            Bundle bundle = msg.getData();
            String schemePlusHost = bundle.getString(""host"");
            String username = bundle.getString(""username"");
            String password = bundle.getString(""password"");
            // will not be sent and we should notify WebCore ourselves.
            if (!mWebView.onSavePassword(schemePlusHost, username, password, (Message) msg.obj)) {
                synchronized (this) {
                    notify();
                }
            }
            break;
        case ASYNC_KEYEVENTS:
            if (mWebViewClient != null) {
                mWebViewClient.onUnhandledKeyEvent(mWebView, (KeyEvent) msg.obj);
            }
            break;
        case EXCEEDED_DATABASE_QUOTA:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String databaseIdentifier = (String) map.get(""databaseIdentifier"");
                String url = (String) map.get(""url"");
                long currentQuota = ((Long) map.get(""currentQuota"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                long estimatedSize = ((Long) map.get(""estimatedSize"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onExceededDatabaseQuota(url, databaseIdentifier, currentQuota, estimatedSize, totalUsedQuota, quotaUpdater);
            }
            break;
        case REACHED_APPCACHE_MAXSIZE:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                long spaceNeeded = ((Long) map.get(""spaceNeeded"")).longValue();
                long totalUsedQuota = ((Long) map.get(""totalUsedQuota"")).longValue();
                WebStorage.QuotaUpdater quotaUpdater = (WebStorage.QuotaUpdater) map.get(""quotaUpdater"");
                mWebChromeClient.onReachedMaxAppCacheSize(spaceNeeded, totalUsedQuota, quotaUpdater);
            }
            break;
        case GEOLOCATION_PERMISSIONS_SHOW_PROMPT:
            if (mWebChromeClient != null) {
                HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
                String origin = (String) map.get(""origin"");
                GeolocationPermissions.Callback callback = (GeolocationPermissions.Callback) map.get(""callback"");
                mWebChromeClient.onGeolocationPermissionsShowPrompt(origin, callback);
            }
            break;
        case GEOLOCATION_PERMISSIONS_HIDE_PROMPT:
            if (mWebChromeClient != null) {
                mWebChromeClient.onGeolocationPermissionsHidePrompt();
            }
            break;
        case JS_ALERT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsAlert(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_CONFIRM:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsConfirm(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setMessage(message).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_PROMPT:
            if (mWebChromeClient != null) {
                final JsPromptResult res = (JsPromptResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String defaultVal = msg.getData().getString(""default"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsPrompt(mWebView, url, message, defaultVal, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final LayoutInflater factory = LayoutInflater.from(mContext);
                    final View view = factory.inflate(R.layout.js_prompt, null);
                    final EditText v = (EditText) view.findViewById(R.id.value);
                    v.setText(defaultVal);
                    ((TextView) view.findViewById(R.id.message)).setText(message);
                    new AlertDialog.Builder(mContext).setTitle(getJsDialogTitle(url)).setView(view).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.confirm(v.getText().toString());
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int whichButton) {
                            res.cancel();
                        }
                    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

                        public void onCancel(DialogInterface dialog) {
                            res.cancel();
                        }
                    }).show();
                }
                // Tell the JsResult that it is ready for client
                // interaction.
                res.setReady();
            }
            break;
        case JS_UNLOAD:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                String message = msg.getData().getString(""message"");
                String url = msg.getData().getString(""url"");
                if (!mWebChromeClient.onJsBeforeUnload(mWebView, url, message, res)) {
                    if (!canShowAlertDialog()) {
                        res.cancel();
                        res.setReady();
                        break;
                    }
                    final String m = mContext.getString(R.string.js_dialog_before_unload, message);
                    new AlertDialog.Builder(mContext).setMessage(m).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.confirm();
                        }
                    }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

                        public void onClick(DialogInterface dialog, int which) {
                            res.cancel();
                        }
                    }).show();
                }
                res.setReady();
            }
            break;
        case JS_TIMEOUT:
            if (mWebChromeClient != null) {
                final JsResult res = (JsResult) msg.obj;
                if (mWebChromeClient.onJsTimeout()) {
                    res.confirm();
                } else {
                    res.cancel();
                }
                res.setReady();
            }
            break;
        case RECEIVED_CERTIFICATE:
            mWebView.setCertificate((SslCertificate) msg.obj);
            break;
        case NOTIFY:
            synchronized (this) {
                notify();
            }
            break;
        case SCALE_CHANGED:
            if (mWebViewClient != null) {
                mWebViewClient.onScaleChanged(mWebView, msg.getData().getFloat(""old""), msg.getData().getFloat(""new""));
            }
            break;
        case SWITCH_OUT_HISTORY:
            mWebView.switchOutDrawHistory();
            break;
        case ADD_MESSAGE_TO_CONSOLE:
            if (mWebChromeClient == null) {
                break;
            }
            String message = msg.getData().getString(""message"");
            String sourceID = msg.getData().getString(""sourceID"");
            int lineNumber = msg.getData().getInt(""lineNumber"");
            int msgLevel = msg.getData().getInt(""msgLevel"");
            int numberOfMessageLevels = ConsoleMessage.MessageLevel.values().length;
            // Sanity bounds check as we'll index an array with msgLevel
            if (msgLevel < 0 || msgLevel >= numberOfMessageLevels) {
                msgLevel = 0;
            }
            ConsoleMessage.MessageLevel messageLevel = ConsoleMessage.MessageLevel.values()[msgLevel];
            if (!mWebChromeClient.onConsoleMessage(new ConsoleMessage(message, sourceID, lineNumber, messageLevel))) {
                // If false was returned the user did not provide their own console function so
                // we should output some default messages to the system log.
                String logTag = ""Web Console"";
                String logMessage = message + "" at "" + sourceID + "":"" + lineNumber;
                switch(messageLevel) {
                    case TIP:
                        Log.v(logTag, logMessage);
                        break;
                    case LOG:
                        Log.i(logTag, logMessage);
                        break;
                    case WARNING:
                        Log.w(logTag, logMessage);
                        break;
                    case ERROR:
                        Log.e(logTag, logMessage);
                        break;
                    case DEBUG:
                        Log.d(logTag, logMessage);
                        break;
                }
            }
            break;
        case GET_VISITED_HISTORY:
            if (mWebChromeClient != null) {
                mWebChromeClient.getVisitedHistory((ValueCallback<String[]>) msg.obj);
            }
            break;
        case OPEN_FILE_CHOOSER:
            if (mWebChromeClient != null) {
                UploadFileMessageData data = (UploadFileMessageData) msg.obj;
                mWebChromeClient.openFileChooser(data.getUploadFile(), data.getAcceptType());
            }
            break;
        case ADD_HISTORY_ITEM:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onNewHistoryItem((WebHistoryItem) msg.obj);
            }
            break;
        case HISTORY_INDEX_CHANGED:
            if (mWebBackForwardListClient != null) {
                mWebBackForwardListClient.onIndexChanged((WebHistoryItem) msg.obj, msg.arg1);
            }
            break;
        case AUTH_CREDENTIALS:
            {
                String host = msg.getData().getString(""host"");
                String realm = msg.getData().getString(""realm"");
                username = msg.getData().getString(""username"");
                password = msg.getData().getString(""password"");
                mWebView.setHttpAuthUsernamePassword(host, realm, username, password);
                break;
            }
        case SET_INSTALLABLE_WEBAPP:
            if (mWebChromeClient != null) {
                mWebChromeClient.setInstallableWebApp();
            }
            break;
        case NOTIFY_SEARCHBOX_LISTENERS:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                @SuppressWarnings(""unchecked"") List<String> suggestions = (List<String>) msg.obj;
                searchBox.handleSuggestions(msg.getData().getString(""query""), suggestions);
                break;
            }
        case AUTO_LOGIN:
            {
                if (mWebViewClient != null) {
                    String realm = msg.getData().getString(""realm"");
                    String account = msg.getData().getString(""account"");
                    String args = msg.getData().getString(""args"");
                    mWebViewClient.onReceivedLoginRequest(mWebView, realm, account, args);
                }
                break;
            }
        case SEARCHBOX_IS_SUPPORTED_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean supported = (Boolean) msg.obj;
                searchBox.handleIsSupportedCallback(supported);
                break;
            }
        case SEARCHBOX_DISPATCH_COMPLETE_CALLBACK:
            {
                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
                Boolean success = (Boolean) msg.obj;
                searchBox.handleDispatchCompleteCallback(msg.getData().getString(""function""), msg.getData().getInt(""id""), success);
                break;
            }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
808,"<android.view.ViewGroup: View findFrontmostDroppableChildAt(float,float,PointF)>",13,14,,,,"{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = count - 1; i >= 0; i--) {
        final View child = children[i];
        if (!child.mCanAcceptDrop) {
            continue;
        }
        if (isTransformedTouchPointInView(x, y, child, outLocalPoint)) {
            return child;
        }
    }
    return null;
}","{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = count - 1; i >= 0; i--) {
        final View child = children[i];
        if (!child.canAcceptDrag()) {
            continue;
        }
        if (isTransformedTouchPointInView(x, y, child, outLocalPoint)) {
            return child;
        }
    }
    return null;
}",1,"// the position within its own local coordinate system.
","// the position within its own local coordinate system.
",0,,,0,,,,,,,5,0,"The method `child.mCanAcceptDrop` from the early version has been changed to `child.canAcceptDrag()` in the later version, indicating a change in the dependent API, thus the code change type is 5.","Although the API used to check if a child can accept drag has been changed, there is no inherent compatibility issue from this change alone as long as the semantics of `canAcceptDrag()` is consistent with the previous `mCanAcceptDrop`. It is a dependent API change that does not directly cause a compatibility issue without further context about the change in behavior of the `canAcceptDrag()` method. Therefore, we consider that there is no compatibility issue, and the CI type is 0."
809,"<android.service.wallpaper.WallpaperService.Engine: void updateSurface(boolean,boolean,boolean)>",13,14,,,,"{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mLayout, mWidth, mHeight, View.VISIBLE, false, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}","{
    if (mDestroyed) {
        Log.w(TAG, ""Ignoring updateSurface: destroyed"");
    }
    int myWidth = mSurfaceHolder.getRequestedWidth();
    if (myWidth <= 0)
        myWidth = ViewGroup.LayoutParams.MATCH_PARENT;
    int myHeight = mSurfaceHolder.getRequestedHeight();
    if (myHeight <= 0)
        myHeight = ViewGroup.LayoutParams.MATCH_PARENT;
    final boolean creating = !mCreated;
    final boolean surfaceCreating = !mSurfaceCreated;
    final boolean formatChanged = mFormat != mSurfaceHolder.getRequestedFormat();
    boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean typeChanged = mType != mSurfaceHolder.getRequestedType();
    final boolean flagsChanged = mCurWindowFlags != mWindowFlags;
    if (forceRelayout || creating || surfaceCreating || formatChanged || sizeChanged || typeChanged || flagsChanged || redrawNeeded) {
        if (DEBUG)
            Log.v(TAG, ""Changes: creating="" + creating + "" format="" + formatChanged + "" size="" + sizeChanged);
        try {
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mSurfaceHolder.getRequestedFormat();
            mType = mSurfaceHolder.getRequestedType();
            mLayout.x = 0;
            mLayout.y = 0;
            mLayout.width = myWidth;
            mLayout.height = myHeight;
            mLayout.format = mFormat;
            mCurWindowFlags = mWindowFlags;
            mLayout.flags = mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
            mLayout.memoryType = mType;
            mLayout.token = mWindowToken;
            if (!mCreated) {
                mLayout.type = mIWallpaperEngine.mWindowType;
                mLayout.gravity = Gravity.LEFT | Gravity.TOP;
                mLayout.setTitle(WallpaperService.this.getClass().getName());
                mLayout.windowAnimations = com.android.internal.R.style.Animation_Wallpaper;
                mInputChannel = new InputChannel();
                if (mSession.add(mWindow, mWindow.mSeq, mLayout, View.VISIBLE, mContentInsets, mInputChannel) < 0) {
                    Log.w(TAG, ""Failed to add window while updating wallpaper surface."");
                    return;
                }
                mCreated = true;
                InputQueue.registerInputChannel(mInputChannel, mInputHandler, Looper.myQueue());
            }
            mSurfaceHolder.mSurfaceLock.lock();
            mDrawingAllowed = true;
            final int relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, View.VISIBLE, false, mWinFrame, mContentInsets, mVisibleInsets, mConfiguration, mSurfaceHolder.mSurface);
            if (DEBUG)
                Log.v(TAG, ""New surface: "" + mSurfaceHolder.mSurface + "", frame="" + mWinFrame);
            int w = mWinFrame.width();
            if (mCurWidth != w) {
                sizeChanged = true;
                mCurWidth = w;
            }
            int h = mWinFrame.height();
            if (mCurHeight != h) {
                sizeChanged = true;
                mCurHeight = h;
            }
            mSurfaceHolder.setSurfaceFrameSize(w, h);
            mSurfaceHolder.mSurfaceLock.unlock();
            if (!mSurfaceHolder.mSurface.isValid()) {
                reportSurfaceDestroyed();
                if (DEBUG)
                    Log.v(TAG, ""Layout: Surface destroyed"");
                return;
            }
            boolean didSurface = false;
            try {
                mSurfaceHolder.ungetCallbacks();
                if (surfaceCreating) {
                    mIsCreating = true;
                    didSurface = true;
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceCreated("" + mSurfaceHolder + ""): "" + this);
                    onSurfaceCreated(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                }
                redrawNeeded |= creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0;
                if (forceReport || creating || surfaceCreating || formatChanged || sizeChanged) {
                    if (DEBUG) {
                        RuntimeException e = new RuntimeException();
                        e.fillInStackTrace();
                        Log.w(TAG, ""forceReport="" + forceReport + "" creating="" + creating + "" formatChanged="" + formatChanged + "" sizeChanged="" + sizeChanged, e);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onSurfaceChanged("" + mSurfaceHolder + "", "" + mFormat + "", "" + mCurWidth + "", "" + mCurHeight + ""): "" + this);
                    didSurface = true;
                    onSurfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, mCurWidth, mCurHeight);
                        }
                    }
                }
                if (redrawNeeded) {
                    onSurfaceRedrawNeeded(mSurfaceHolder);
                    SurfaceHolder.Callback[] callbacks = mSurfaceHolder.getCallbacks();
                    if (callbacks != null) {
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
                if (didSurface && !mReportedVisible) {
                    // don't want wallpapers running when not visible.
                    if (mIsCreating) {
                        // the state to get them to notice.
                        if (DEBUG)
                            Log.v(TAG, ""onVisibilityChanged(true) at surface: "" + this);
                        onVisibilityChanged(true);
                    }
                    if (DEBUG)
                        Log.v(TAG, ""onVisibilityChanged(false) at surface: "" + this);
                    onVisibilityChanged(false);
                }
            } finally {
                mIsCreating = false;
                mSurfaceCreated = true;
                if (redrawNeeded) {
                    mSession.finishDrawing(mWindow);
                }
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, ""Layout: x="" + mLayout.x + "" y="" + mLayout.y + "" w="" + mLayout.width + "" h="" + mLayout.height);
    }
}",1,,,0,,,0,,,,,,,,,,
812,<android.view.InputDevice: String toString()>,13,14,,,,"{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}","{
    StringBuilder description = new StringBuilder();
    description.append(""Input Device "").append(mId).append("": "").append(mName).append(""\n"");
    description.append(""  Keyboard Type: "");
    switch(mKeyboardType) {
        case KEYBOARD_TYPE_NONE:
            description.append(""none"");
            break;
        case KEYBOARD_TYPE_NON_ALPHABETIC:
            description.append(""non-alphabetic"");
            break;
        case KEYBOARD_TYPE_ALPHABETIC:
            description.append(""alphabetic"");
            break;
    }
    description.append(""\n"");
    description.append(""  Sources: 0x"").append(Integer.toHexString(mSources)).append("" ("");
    appendSourceDescriptionIfApplicable(description, SOURCE_KEYBOARD, ""keyboard"");
    appendSourceDescriptionIfApplicable(description, SOURCE_DPAD, ""dpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHSCREEN, ""touchscreen"");
    appendSourceDescriptionIfApplicable(description, SOURCE_MOUSE, ""mouse"");
    appendSourceDescriptionIfApplicable(description, SOURCE_STYLUS, ""stylus"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TRACKBALL, ""trackball"");
    appendSourceDescriptionIfApplicable(description, SOURCE_TOUCHPAD, ""touchpad"");
    appendSourceDescriptionIfApplicable(description, SOURCE_JOYSTICK, ""joystick"");
    appendSourceDescriptionIfApplicable(description, SOURCE_GAMEPAD, ""gamepad"");
    description.append("" )\n"");
    final int numAxes = mMotionRanges.size();
    for (int i = 0; i < numAxes; i++) {
        MotionRange range = mMotionRanges.get(i);
        description.append(""    "").append(MotionEvent.axisToString(range.mAxis));
        description.append("": source=0x"").append(Integer.toHexString(range.mSource));
        description.append("" min="").append(range.mMin);
        description.append("" max="").append(range.mMax);
        description.append("" flat="").append(range.mFlat);
        description.append("" fuzz="").append(range.mFuzz);
        description.append(""\n"");
    }
    return description.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The code change is in the call to appendSourceDescriptionIfApplicable method, where a new source description for SOURCE_STYLUS is added, and there seems to be no removal of existing code. This change is categorized as 4 (Other statement changed).","There is no Compatibility Issue as the method still constructs and returns a string representation of the InputDevice object. The added string piece for the stylus input does not affect the return type or change any existing behavior, it merely adds additional information when the stylus input is applicable."
813,<android.net.http.SslError: String toString()>,13,14,,,,"{
    return ""primary error: "" + getPrimaryError() + "" certificate: "" + getCertificate();
}","{
    return ""primary error: "" + getPrimaryError() + "" certificate: "" + getCertificate() + "" on URL: "" + getUrl();
}",1,"/**
 * @return A String representation of this SSL error object
 * (used mostly for debugging).
 */
","/**
 * Returns a string representation of this object.
 * @return A String representation of this object.
 */
",1,,,0,,,,,,,4,0,"The `toString()` method implementation has changed by appending `"" on URL: "" + getUrl()` to the return string. This is an additive change to the string without altering the logic or control flow of the method, so the code change type is 4.","The addition of extra information to the return string does not constitute a compatibility issue as the method is intended to return a descriptive string, and the addition of more information does not alter the behavior the external code can depend on in a backward-incompatible way. Thus, there is no CI, and the CI type is 0."
814,<android.widget.ListView: boolean removeHeaderView(View)>,13,14,,,,"{
    if (mHeaderViewInfos.size() > 0) {
        boolean result = false;
        if (((HeaderViewListAdapter) mAdapter).removeHeader(v)) {
            mDataSetObserver.onChanged();
            result = true;
        }
        removeFixedViewInfo(v, mHeaderViewInfos);
        return result;
    }
    return false;
}","{
    if (mHeaderViewInfos.size() > 0) {
        boolean result = false;
        if (mAdapter != null && ((HeaderViewListAdapter) mAdapter).removeHeader(v)) {
            if (mDataSetObserver != null) {
                mDataSetObserver.onChanged();
            }
            result = true;
        }
        removeFixedViewInfo(v, mHeaderViewInfos);
        return result;
    }
    return false;
}",1,"/**
 * Removes a previously-added header view.
 *
 * @param v The view to remove
 * @return true if the view was removed, false if the view was not a header
 * view
 */
","/**
 * Removes a previously-added header view.
 *
 * @param v The view to remove
 * @return true if the view was removed, false if the view was not a header
 * view
 */
",0,,,0,,,,,,,3,0,"The condition in the if statement was extended to check if mAdapter is not null, and another condition was added to check if mDataSetObserver is not null before calling onChanged on it. So the code change type is 3 as it involves a control dependency change.","There's no compatibility issue since the changes are checking for additional null conditions before executing code that already exists in both versions, which means the method's behavior remains consistent across both versions. The additional null checks will prevent potential NullPointerException. The end result returned by the method and the observable side effects remain unchanged; it still returns true if a header was successfully removed and false otherwise."
816,<android.view.ViewGroup: void removeAllViewsInLayout()>,13,14,,,,"{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final OnHierarchyChangeListener listener = mOnHierarchyChangeListener;
    final boolean notify = listener != null;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    View clearChildFocus = null;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.clearFocusForRemoval();
            clearChildFocus = view;
        }
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (notify) {
            listener.onChildViewRemoved(this, view);
        }
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus != null) {
        clearChildFocus(clearChildFocus);
    }
}","{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    View clearChildFocus = null;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.clearFocusForRemoval();
            clearChildFocus = view;
        }
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus != null) {
        clearChildFocus(clearChildFocus);
    }
}",1,"/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 */
","/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may ""have"" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 */
",0,,,0,,,,,,,"3,4",0,"The code has changed within the loop control structure with the removal of the condition `if (notify)` and replacing `listener.onChildViewRemoved(this, view);` with a call to `onViewRemoved(view);`. This change falls under control dependency change (3) because it is within the loop, and an other statement changed (4) since it alters the flow of method calls without affecting the control structure itself.","There is no Compatibility Issue because the removal of the notification to the listener via `if (notify)` followed by `listener.onChildViewRemoved(this, view);` has been replaced by a direct call to `onViewRemoved(view);`. This indicates that the responsibility to notify the `OnHierarchyChangeListener` may have been moved into the `onViewRemoved` method itself. As such, the external behavior of the method should remain unchanged with respect to how it notifies of child view removals. The modification does not represent a change in the exceptions being thrown or the values being returned by the method."
817,"<android.webkit.WebView: String[] getHttpAuthUsernamePassword(String,String)>",13,14,,,,"{
    return mDatabase.getHttpAuthUsernamePassword(host, realm);
}","{
    checkThread();
    return mDatabase.getHttpAuthUsernamePassword(host, realm);
}",1,"/**
 * Retrieve the HTTP authentication username and password for a given
 * host & realm pair
 *
 * @param host The host for which the credentials apply.
 * @param realm The realm for which the credentials apply.
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
","/**
 * Retrieve the HTTP authentication username and password for a given
 * host & realm pair
 *
 * @param host The host for which the credentials apply.
 * @param realm The realm for which the credentials apply.
 * @return String[] if found, String[0] is username, which can be null and
 * String[1] is password. Return null if it can't find anything.
 */
",0,,,0,,,,,,,4,0,"An additional method call (checkThread()) has been introduced before the return statement, so the code change type is 4.","The new method call checkThread() does not affect the return value or the exceptions that could be thrown from getHttpAuthUsernamePassword() as it appears to be a thread checking operation that doesn't change the output. Therefore, there is no Compatibility Issue with respect to return values or exceptions, thus CI type is 0."
818,<android.app.WallpaperManager: void setResource(int)>,13,14,,,,"{
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    }
}","{
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(""res:"" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}",1,"/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
","/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the default
 * wallpaper.
 */
",0,,,0,,,,,,,0,0,"There are no changes in the actual implementation code. The only change is a comment addition in the catch block, which does not affect the functionality or the behavior of the API.","Since there is no change in the implementation of the code that affects its behavior, there is no potential for a Compatibility Issue."
819,<android.nfc.NfcAdapter: NfcAdapter getDefaultAdapter()>,13,14,,,,"{
    Log.w(TAG, ""WARNING: NfcAdapter.getDefaultAdapter() is deprecated, use "" + ""NfcAdapter.getDefaultAdapter(Context) instead"", new Exception());
    return new NfcAdapter(null);
}","{
    Log.w(TAG, ""WARNING: NfcAdapter.getDefaultAdapter() is deprecated, use "" + ""NfcAdapter.getDefaultAdapter(Context) instead"", new Exception());
    return getSingleton();
}",1,"/**
 * Get a handle to the default NFC Adapter on this Android device.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 * @deprecated use {@link #getDefaultAdapter(Context)}
 */
","/**
 * Get a handle to the default NFC Adapter on this Android device.
 * <p>
 * Most Android devices will only have one NFC Adapter (NFC Controller).
 *
 * @return the default NFC adapter, or null if no NFC adapter exists
 * @deprecated use {@link #getDefaultAdapter(Context)}
 */
",0,[@Deprecated],[@Deprecated],0,,,,,,,"1,5",1,"The return statement has changed from returning a new NfcAdapter instance to calling the getSingleton() method, which implies a different source for the returned object. Additionally, the nature of the object returned by getSingleton() could be different from creating a new instance, thus there is both a return statement change and a dependent API change. Therefore, the code change types are 1,5.","Since the early version creates a new instance of NfcAdapter every time it is called while the late version potentially returns a singleton instance (implied by getSingleton()), the behavior of the API has changed in terms of what is returned. This can affect the callers depending on whether they expect a new instance each time or the same instance, thus the CI type is 1."
821,<android.service.wallpaper.WallpaperService.IWallpaperEngineWrapper: void executeMessage(Message)>,13,14,,,,"{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged();
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}","{
    switch(message.what) {
        case DO_ATTACH:
            {
                try {
                    mConnection.attachEngine(this);
                } catch (RemoteException e) {
                    Log.w(TAG, ""Wallpaper host disappeared"", e);
                    return;
                }
                Engine engine = onCreateEngine();
                mEngine = engine;
                mActiveEngines.add(engine);
                engine.attach(this);
                return;
            }
        case DO_DETACH:
            {
                mActiveEngines.remove(mEngine);
                mEngine.detach();
                return;
            }
        case DO_SET_DESIRED_SIZE:
            {
                mEngine.doDesiredSizeChanged(message.arg1, message.arg2);
                return;
            }
        case MSG_UPDATE_SURFACE:
            mEngine.updateSurface(true, false, false);
            break;
        case MSG_VISIBILITY_CHANGED:
            if (DEBUG)
                Log.v(TAG, ""Visibility change in "" + mEngine + "": "" + message.arg1);
            mEngine.doVisibilityChanged(message.arg1 != 0);
            break;
        case MSG_WALLPAPER_OFFSETS:
            {
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_WALLPAPER_COMMAND:
            {
                WallpaperCommand cmd = (WallpaperCommand) message.obj;
                mEngine.doCommand(cmd);
            }
            break;
        case MSG_WINDOW_RESIZED:
            {
                final boolean reportDraw = message.arg1 != 0;
                mEngine.updateSurface(true, false, reportDraw);
                mEngine.doOffsetsChanged(true);
            }
            break;
        case MSG_TOUCH_EVENT:
            {
                boolean skip = false;
                MotionEvent ev = (MotionEvent) message.obj;
                if (ev.getAction() == MotionEvent.ACTION_MOVE) {
                    synchronized (mEngine.mLock) {
                        if (mEngine.mPendingMove == ev) {
                            mEngine.mPendingMove = null;
                        } else {
                            // this is not the motion event we are looking for....
                            skip = true;
                        }
                    }
                }
                if (!skip) {
                    if (DEBUG)
                        Log.v(TAG, ""Delivering touch event: "" + ev);
                    mEngine.onTouchEvent(ev);
                }
                ev.recycle();
            }
            break;
        default:
            Log.w(TAG, ""Unknown message type "" + message.what);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"Control dependency changed due to the alteration of the parameter passed to `mEngine.doOffsetsChanged()` and a new parameter `true` is added in the late implementation. Additionally, the statement itself is modified to include this new parameter, which classifies as an ""other statement changed"", so the code change type is 3,4.","Even though there's a change in how `mEngine.doOffsetsChanged()` is called, including the addition of the `true` parameter, this does not inherently indicate a change in return value or thrown exceptions from the `executeMessage` method itself. Assuming `mEngine.doOffsetsChanged(true)` behaves compatibly with `mEngine.doOffsetsChanged()`, considering the internal implementation of `doOffsetsChanged` handles the parameter correctly and does not change the outward behavior observed by clients of `executeMessage`, there would be no compatibility issue expected. Therefore, there is no predicted compatibility issue, and the CI type is 0."
823,"<android.text.SpannableStringBuilder: SpannableStringBuilder replace(int,int,CharSequence,int,int)>",13,14,,,,"{
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    if (end == start && tbstart == tbend) {
        return this;
    }
    if (end == start || tbstart == tbend) {
        change(start, end, tb, tbstart, tbend);
    } else {
        int selstart = Selection.getSelectionStart(this);
        int selend = Selection.getSelectionEnd(this);
        // XXX just make the span fixups in change() do the right thing
        // instead of this madness!
        checkRange(""replace"", start, end);
        moveGapTo(end);
        TextWatcher[] recipients;
        recipients = sendTextWillChange(start, end - start, tbend - tbstart);
        int origlen = end - start;
        if (mGapLength < 2)
            resizeFor(length() + 1);
        for (int i = mSpanCount - 1; i >= 0; i--) {
            if (mSpanStarts[i] == mGapStart)
                mSpanStarts[i]++;
            if (mSpanEnds[i] == mGapStart)
                mSpanEnds[i]++;
        }
        mText[mGapStart] = ' ';
        mGapStart++;
        mGapLength--;
        if (mGapLength < 1)
            new Exception(""mGapLength < 1"").printStackTrace();
        int oldlen = (end + 1) - start;
        int inserted = change(false, start + 1, start + 1, tb, tbstart, tbend);
        change(false, start, start + 1, """", 0, 0);
        change(false, start + inserted, start + inserted + oldlen - 1, """", 0, 0);
        /*
             * Special case to keep the cursor in the same position
             * if it was somewhere in the middle of the replaced region.
             * If it was at the start or the end or crossing the whole
             * replacement, it should already be where it belongs.
             * TODO: Is there some more general mechanism that could
             * accomplish this?
             */
        if (selstart > start && selstart < end) {
            long off = selstart - start;
            off = off * inserted / (end - start);
            selstart = (int) off + start;
            setSpan(false, Selection.SELECTION_START, selstart, selstart, Spanned.SPAN_POINT_POINT);
        }
        if (selend > start && selend < end) {
            long off = selend - start;
            off = off * inserted / (end - start);
            selend = (int) off + start;
            setSpan(false, Selection.SELECTION_END, selend, selend, Spanned.SPAN_POINT_POINT);
        }
        sendTextChange(recipients, start, origlen, inserted);
        sendTextHasChanged(recipients);
    }
    return this;
}","{
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    if (end == start && tbstart == tbend) {
        return this;
    }
    if (end == start || tbstart == tbend) {
        change(start, end, tb, tbstart, tbend);
    } else {
        int selstart = Selection.getSelectionStart(this);
        int selend = Selection.getSelectionEnd(this);
        // XXX just make the span fixups in change() do the right thing
        // instead of this madness!
        checkRange(""replace"", start, end);
        moveGapTo(end);
        TextWatcher[] recipients;
        int origlen = end - start;
        recipients = sendTextWillChange(start, origlen, tbend - tbstart);
        if (mGapLength < 2)
            resizeFor(length() + 1);
        for (int i = mSpanCount - 1; i >= 0; i--) {
            if (mSpanStarts[i] == mGapStart)
                mSpanStarts[i]++;
            if (mSpanEnds[i] == mGapStart)
                mSpanEnds[i]++;
        }
        mText[mGapStart] = ' ';
        mGapStart++;
        mGapLength--;
        if (mGapLength < 1) {
            new Exception(""mGapLength < 1"").printStackTrace();
        }
        int inserted = change(false, start + 1, start + 1, tb, tbstart, tbend);
        change(false, start, start + 1, """", 0, 0);
        change(false, start + inserted, start + inserted + origlen, """", 0, 0);
        /*
             * Special case to keep the cursor in the same position
             * if it was somewhere in the middle of the replaced region.
             * If it was at the start or the end or crossing the whole
             * replacement, it should already be where it belongs.
             * TODO: Is there some more general mechanism that could
             * accomplish this?
             */
        if (selstart > start && selstart < end) {
            long off = selstart - start;
            off = off * inserted / (end - start);
            selstart = (int) off + start;
            setSpan(false, Selection.SELECTION_START, selstart, selstart, Spanned.SPAN_POINT_POINT);
        }
        if (selend > start && selend < end) {
            long off = selend - start;
            off = off * inserted / (end - start);
            selend = (int) off + start;
            setSpan(false, Selection.SELECTION_END, selend, selend, Spanned.SPAN_POINT_POINT);
        }
        sendTextChange(recipients, start, origlen, inserted);
        sendTextHasChanged(recipients);
    }
    return this;
}",1,"// Documentation from interface
","// Documentation from interface
",0,,,0,,,,,,,,,,
824,<android.widget.AdapterViewAnimator: boolean onRemoteAdapterConnected()>,13,14,,,,"{
    if (mRemoteViewsAdapter != mAdapter) {
        setAdapter(mRemoteViewsAdapter);
        // Restore the previous position (see onRestoreInstanceState)
        if (mRestoreWhichChild > -1) {
            setDisplayedChild(mRestoreWhichChild, false);
            mRestoreWhichChild = -1;
        }
        return false;
    } else if (mRemoteViewsAdapter != null) {
        mRemoteViewsAdapter.superNotifyDataSetChanged();
        return true;
    }
    return false;
}","{
    if (mRemoteViewsAdapter != mAdapter) {
        setAdapter(mRemoteViewsAdapter);
        if (mDeferNotifyDataSetChanged) {
            mRemoteViewsAdapter.notifyDataSetChanged();
            mDeferNotifyDataSetChanged = false;
        }
        // Restore the previous position (see onRestoreInstanceState)
        if (mRestoreWhichChild > -1) {
            setDisplayedChild(mRestoreWhichChild, false);
            mRestoreWhichChild = -1;
        }
        return false;
    } else if (mRemoteViewsAdapter != null) {
        mRemoteViewsAdapter.superNotifyDataSetChanged();
        return true;
    }
    return false;
}",1,"/**
 * Called back when the adapter connects to the RemoteViewsService.
 */
","/**
 * Called back when the adapter connects to the RemoteViewsService.
 */
",0,,,0,,,,,,,"3,4",0,"The condition (`if (mDeferNotifyDataSetChanged)`) and the call to `notifyDataSetChanged()` are added inside the first 'if' block, and a variable assignment (`mDeferNotifyDataSetChanged = false;`) is added. This constitutes a control dependency change (3) and an other statement change (4) since the sequence of operations in the method changed.","Despite the changes, there's no Compatibility Issue detected. The return value is `false` in both the early and the late version when `mRemoteViewsAdapter != mAdapter`. The additional operations do not affect the returned value; they only change the internal state which does not lead to a different return value. When `mRemoteViewsAdapter == mAdapter`, the method returns `true` in both versions and the additional code is not executed. The final return statement `return false;` is also unchanged."
825,<android.widget.FastScroller: void draw(Canvas)>,13,14,,,,"{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_DEFAULT:
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_DEFAULT:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else {
            mList.invalidate(viewWidth - mThumbW, y, viewWidth, y + mThumbH);
        }
    }
}","{
    if (mState == STATE_NONE) {
        // No need to draw anything
        return;
    }
    final int y = mThumbY;
    final int viewWidth = mList.getWidth();
    final FastScroller.ScrollFade scrollFade = mScrollFade;
    int alpha = -1;
    if (mState == STATE_EXIT) {
        alpha = scrollFade.getAlpha();
        if (alpha < ScrollFade.ALPHA_MAX / 2) {
            mThumbDrawable.setAlpha(alpha * 2);
        }
        int left = 0;
        switch(mPosition) {
            case View.SCROLLBAR_POSITION_DEFAULT:
            case View.SCROLLBAR_POSITION_RIGHT:
                left = viewWidth - (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
            case View.SCROLLBAR_POSITION_LEFT:
                left = -mThumbW + (mThumbW * alpha) / ScrollFade.ALPHA_MAX;
                break;
        }
        mThumbDrawable.setBounds(left, 0, left + mThumbW, mThumbH);
        mChangedBounds = true;
    }
    if (mTrackDrawable != null) {
        final Rect thumbBounds = mThumbDrawable.getBounds();
        final int left = thumbBounds.left;
        final int halfThumbHeight = (thumbBounds.bottom - thumbBounds.top) / 2;
        final int trackWidth = mTrackDrawable.getIntrinsicWidth();
        final int trackLeft = (left + mThumbW / 2) - trackWidth / 2;
        mTrackDrawable.setBounds(trackLeft, halfThumbHeight, trackLeft + trackWidth, mList.getHeight() - halfThumbHeight);
        mTrackDrawable.draw(canvas);
    }
    canvas.translate(0, y);
    mThumbDrawable.draw(canvas);
    canvas.translate(0, -y);
    // If user is dragging the scroll bar, draw the alphabet overlay
    if (mState == STATE_DRAGGING && mDrawOverlay) {
        if (mOverlayPosition == OVERLAY_AT_THUMB) {
            int left = 0;
            switch(mPosition) {
                default:
                case View.SCROLLBAR_POSITION_DEFAULT:
                case View.SCROLLBAR_POSITION_RIGHT:
                    left = Math.max(0, mThumbDrawable.getBounds().left - mThumbW - mOverlaySize);
                    break;
                case View.SCROLLBAR_POSITION_LEFT:
                    left = Math.min(mThumbDrawable.getBounds().right + mThumbW, mList.getWidth() - mOverlaySize);
                    break;
            }
            int top = Math.max(0, Math.min(y + (mThumbH - mOverlaySize) / 2, mList.getHeight() - mOverlaySize));
            final RectF pos = mOverlayPos;
            pos.left = left;
            pos.right = pos.left + mOverlaySize;
            pos.top = top;
            pos.bottom = pos.top + mOverlaySize;
            if (mOverlayDrawable != null) {
                mOverlayDrawable.setBounds((int) pos.left, (int) pos.top, (int) pos.right, (int) pos.bottom);
            }
        }
        mOverlayDrawable.draw(canvas);
        final Paint paint = mPaint;
        float descent = paint.descent();
        final RectF rectF = mOverlayPos;
        final Rect tmpRect = mTmpRect;
        mOverlayDrawable.getPadding(tmpRect);
        final int hOff = (tmpRect.right - tmpRect.left) / 2;
        final int vOff = (tmpRect.bottom - tmpRect.top) / 2;
        canvas.drawText(mSectionText, (int) (rectF.left + rectF.right) / 2 - hOff, (int) (rectF.bottom + rectF.top) / 2 + mOverlaySize / 4 - descent - vOff, paint);
    } else if (mState == STATE_EXIT) {
        if (alpha == 0) {
            // Done with exit
            setState(STATE_NONE);
        } else if (mTrackDrawable != null) {
            mList.invalidate(viewWidth - mThumbW, 0, viewWidth, mList.getHeight());
        } else {
            mList.invalidate(viewWidth - mThumbW, y, viewWidth, y + mThumbH);
        }
    }
}",1,,,0,,,0,,,,,,,,,,
826,<android.view.ViewGroup: boolean dispatchTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!onFilterTouchEventForSecurity(ev)) {
        return false;
    }
    final int action = ev.getAction();
    final int actionMasked = action & MotionEvent.ACTION_MASK;
    // Handle an initial down.
    if (actionMasked == MotionEvent.ACTION_DOWN || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
        // Throw away all previous state when starting a new touch gesture.
        // The framework may have dropped the up or cancel event for the previous gesture
        // due to an app switch, ANR, or some other state change.
        cancelAndClearTouchTargets(ev);
        resetTouchState();
    }
    // Check for interception.
    final boolean intercepted;
    if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
        final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
        if (!disallowIntercept) {
            intercepted = onInterceptTouchEvent(ev);
            // restore action in case onInterceptTouchEvent() changed it
            ev.setAction(action);
        } else {
            intercepted = false;
        }
    } else {
        // There are no touch targets and this action is not an initial down
        // so this view group continues to intercept touches.
        intercepted = true;
    }
    // Check for cancelation.
    final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
    // Update list of touch targets for pointer down, if needed.
    final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
    TouchTarget newTouchTarget = null;
    boolean alreadyDispatchedToNewTouchTarget = false;
    if (!canceled && !intercepted) {
        if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            // always 0 for down
            final int actionIndex = ev.getActionIndex();
            final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
            // Clean up earlier touch targets for this pointer id in case they
            // have become out of sync.
            removePointersFromTouchTargets(idBitsToAssign);
            final int childrenCount = mChildrenCount;
            if (childrenCount != 0) {
                // Find a child that can receive the event.  Scan children from front to back.
                final View[] children = mChildren;
                final float x = ev.getX(actionIndex);
                final float y = ev.getY(actionIndex);
                for (int i = childrenCount - 1; i >= 0; i--) {
                    final View child = children[i];
                    if ((child.mViewFlags & VISIBILITY_MASK) != VISIBLE && child.getAnimation() == null) {
                        // Skip invisible child unless it is animating.
                        continue;
                    }
                    if (!isTransformedTouchPointInView(x, y, child, null)) {
                        // New pointer is out of child's bounds.
                        continue;
                    }
                    newTouchTarget = getTouchTarget(child);
                    if (newTouchTarget != null) {
                        // Child is already receiving touch within its bounds.
                        // Give it the new pointer in addition to the ones it is handling.
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                        break;
                    }
                    resetCancelNextUpFlag(child);
                    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                        // Child wants to receive touch within its bounds.
                        mLastTouchDownTime = ev.getDownTime();
                        mLastTouchDownIndex = i;
                        mLastTouchDownX = ev.getX();
                        mLastTouchDownY = ev.getY();
                        newTouchTarget = addTouchTarget(child, idBitsToAssign);
                        alreadyDispatchedToNewTouchTarget = true;
                        break;
                    }
                }
            }
            if (newTouchTarget == null && mFirstTouchTarget != null) {
                // Did not find a child to receive the event.
                // Assign the pointer to the least recently added target.
                newTouchTarget = mFirstTouchTarget;
                while (newTouchTarget.next != null) {
                    newTouchTarget = newTouchTarget.next;
                }
                newTouchTarget.pointerIdBits |= idBitsToAssign;
            }
        }
    }
    // Dispatch to touch targets.
    boolean handled = false;
    if (mFirstTouchTarget == null) {
        // No touch targets so treat this as an ordinary view.
        handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
    } else {
        // Dispatch to touch targets, excluding the new touch target if we already
        // dispatched to it.  Cancel touch targets if necessary.
        TouchTarget predecessor = null;
        TouchTarget target = mFirstTouchTarget;
        while (target != null) {
            final TouchTarget next = target.next;
            if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                handled = true;
            } else {
                final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                    handled = true;
                }
                if (cancelChild) {
                    if (predecessor == null) {
                        mFirstTouchTarget = next;
                    } else {
                        predecessor.next = next;
                    }
                    target.recycle();
                    target = next;
                    continue;
                }
            }
            predecessor = target;
            target = next;
        }
    }
    // Update list of touch targets for pointer up or cancel, if needed.
    if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
        resetTouchState();
    } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
        final int actionIndex = ev.getActionIndex();
        final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
        removePointersFromTouchTargets(idBitsToRemove);
    }
    return handled;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (childrenCount != 0) {
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final View child = children[i];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = i;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}",1,"/**
 * {@inheritDoc}
 */
","/**
 * {@inheritDoc}
 */
",0,[@Override],[@Override],0,,,,,,,,,,
828,<android.widget.NumberPicker: void setWrapSelectorWheel(boolean)>,13,14,,,,"{
    if (wrapSelector && (mMaxValue - mMinValue) < mSelectorIndices.length) {
        throw new IllegalStateException(""Range less than selector items count."");
    }
    if (wrapSelector != mWrapSelectorWheel) {
        // force the selector indices array to be reinitialized
        mSelectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] = Integer.MAX_VALUE;
        mWrapSelectorWheel = wrapSelector;
        // force redraw since we might look different
        updateIncrementAndDecrementButtonsVisibilityState();
    }
}","{
    if (wrapSelectorWheel && (mMaxValue - mMinValue) < mSelectorIndices.length) {
        throw new IllegalStateException(""Range less than selector items count."");
    }
    if (wrapSelectorWheel != mWrapSelectorWheel) {
        mWrapSelectorWheel = wrapSelectorWheel;
        updateIncrementAndDecrementButtonsVisibilityState();
    }
}",1,"/**
 * Sets whether the selector wheel shown during flinging/scrolling should
 * wrap around the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getMaxValue()} values.
 * <p>
 * By default if the range (max - min) is more than five (the number of
 * items shown on the selector wheel) the selector wheel wrapping is
 * enabled.
 * </p>
 *
 * @param wrapSelector Whether to wrap.
 */
","/**
 * Sets whether the selector wheel shown during flinging/scrolling should
 * wrap around the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getMaxValue()} values.
 * <p>
 * By default if the range (max - min) is more than five (the number of
 * items shown on the selector wheel) the selector wheel wrapping is
 * enabled.
 * </p>
 *
 * @param wrapSelectorWheel Whether to wrap.
 */
",1,,,0,,,,,,,"3,4",0,"The early implementation contains a line that sets mSelectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] to Integer.MAX_VALUE, which is missing in the late implementation. Furthermore, the variable name in the method signature changed from 'wrapSelector' to 'wrapSelectorWheel'. However, there is no return statement or exception handling change, the changes fall under other statements changed (4) and control dependency (3) due to the removal of the re-initialization statement and the correspondence of the parameter name change to the usage within the method.","There is no Compatibility Issue since the removal of setting the SELECTOR_MIDDLE_ITEM_INDEX to Integer.MAX_VALUE does not affect the output (as this method is void and has no return), nor does it introduce a different exception handling behavior. The variable name change does not affect the external behavior. Thus the CI type is 0."
830,"<android.content.ContentProviderProxy: ParcelFileDescriptor openFile(Uri,String)>",13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IContentProvider.descriptor);
    url.writeToParcel(data, 0);
    data.writeString(mode);
    mRemote.transact(IContentProvider.OPEN_FILE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
    int has = reply.readInt();
    ParcelFileDescriptor fd = has != 0 ? reply.readFileDescriptor() : null;
    data.recycle();
    reply.recycle();
    return fd;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IContentProvider.descriptor);
        url.writeToParcel(data, 0);
        data.writeString(mode);
        mRemote.transact(IContentProvider.OPEN_FILE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionWithFileNotFoundExceptionFromParcel(reply);
        int has = reply.readInt();
        ParcelFileDescriptor fd = has != 0 ? reply.readFileDescriptor() : null;
        return fd;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The change is in exception handling and resource management with the introduction of a try-finally block, so the change types are 3 for the new control dependency change and 4 for changes that do not affect the return value or exception handling directly. The flow of the program and the potential resource deallocation with recycle() method is now inside a finally block, ensuring it executes regardless of how the try block is exited.",There is no Compatibility Issue since the method's behavior regarding its return value and the exceptions it may throw remains the same; only the resource management strategy has improved without changing observable behavior.
831,<android.app.WallpaperManager: Drawable peekFastDrawable()>,13,14,,,,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        Drawable dr = new FastBitmapDrawable(bm);
        return dr;
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
","/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */
",0,,,0,,,,,,,0,0,"The implementation has simply been refactored to return a new FastBitmapDrawable(bm) directly instead of assigning it to the variable dr and then returning dr. This change does not alter the behavior or return value of the API, so the code change type is 0.","There is no change in the values potentially returned by the API, and there are no new exception handlings or other behaviors introduced. The semantics of the API remain the same, and therefore there is no Compatibility Issue; thus, the CI type is 0."
832,"<android.database.CursorWindow: boolean isLong(int,int)>",13,14,,,,"{
    return getType(row, col) == Cursor.FIELD_TYPE_INTEGER;
}","{
    return getType(row, column) == Cursor.FIELD_TYPE_INTEGER;
}",1,"/**
 * Checks if a field contains a long
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return {@code true} if given field is a long
 * @deprecated use {@link #getType(int, int)} instead
 */
","/**
 * Returns true if the field at the specified row and column index
 * has type {@link Cursor#FIELD_TYPE_INTEGER}.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if the field has type {@link Cursor#FIELD_TYPE_INTEGER}.
 * @deprecated Use {@link #getType(int, int)} instead.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,The code has not changed between the early and late version apart from a variable naming difference (col to column) which doesn't change behavior.,There is no compatibility issue as no changes have been made to the logic or functionality of the API.
833,<android.inputmethodservice.ExtractEditText: boolean onTextContextMenuItem(int)>,13,14,,,,"{
    // Horrible hack: select word option has to be handled by original view to work.
    if (mIME != null && id != android.R.id.startSelectingText) {
        if (mIME.onExtractTextContextMenuItem(id)) {
            return true;
        }
    }
    return super.onTextContextMenuItem(id);
}","{
    if (mIME != null && mIME.onExtractTextContextMenuItem(id)) {
        return true;
    }
    return super.onTextContextMenuItem(id);
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The control dependency has changed with the removal of the condition 'id != android.R.id.startSelectingText', which alters the flow of the boolean expression in the 'if' statement, so the code change type is 3.","The removal of the condition 'id != android.R.id.startSelectingText' means that the method `mIME.onExtractTextContextMenuItem(id)` will now be called under circumstances where it previously wouldn't have been called. This change can potentially lead to the method returning 'true' in scenarios where it would have returned 'false' prior to the change, causing a Compatibility Issue due to potentially different return values, so the CI type is 1."
836,<android.widget.AdapterViewAnimator: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    int action = ev.getAction();
    boolean handled = false;
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                View v = getCurrentView();
                if (v != null) {
                    if (isTransformedTouchPointInView(ev.getX(), ev.getY(), v, null)) {
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mTouchMode = TOUCH_MODE_DOWN_IN_CURRENT_VIEW;
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            break;
        case MotionEvent.ACTION_POINTER_UP:
            break;
        case MotionEvent.ACTION_UP:
            {
                if (mTouchMode == TOUCH_MODE_DOWN_IN_CURRENT_VIEW) {
                    final View v = getCurrentView();
                    if (v != null) {
                        if (isTransformedTouchPointInView(ev.getX(), ev.getY(), v, null)) {
                            final Handler handler = getHandler();
                            if (handler != null) {
                                handler.removeCallbacks(mPendingCheckForTap);
                            }
                            showTapFeedback(v);
                            postDelayed(new Runnable() {

                                public void run() {
                                    hideTapFeedback(v);
                                    post(new Runnable() {

                                        public void run() {
                                            performItemClick(v, 0, 0);
                                        }
                                    });
                                }
                            }, ViewConfiguration.getPressedStateDuration());
                            handled = true;
                        }
                    }
                }
                mTouchMode = TOUCH_MODE_NONE;
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                View v = getCurrentView();
                if (v != null) {
                    hideTapFeedback(v);
                }
                mTouchMode = TOUCH_MODE_NONE;
            }
    }
    return handled;
}","{
    int action = ev.getAction();
    boolean handled = false;
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            {
                View v = getCurrentView();
                if (v != null) {
                    if (isTransformedTouchPointInView(ev.getX(), ev.getY(), v, null)) {
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mTouchMode = TOUCH_MODE_DOWN_IN_CURRENT_VIEW;
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    }
                }
                break;
            }
        case MotionEvent.ACTION_MOVE:
            break;
        case MotionEvent.ACTION_POINTER_UP:
            break;
        case MotionEvent.ACTION_UP:
            {
                if (mTouchMode == TOUCH_MODE_DOWN_IN_CURRENT_VIEW) {
                    final View v = getCurrentView();
                    final ViewAndMetaData viewData = getMetaDataForChild(v);
                    if (v != null) {
                        if (isTransformedTouchPointInView(ev.getX(), ev.getY(), v, null)) {
                            final Handler handler = getHandler();
                            if (handler != null) {
                                handler.removeCallbacks(mPendingCheckForTap);
                            }
                            showTapFeedback(v);
                            postDelayed(new Runnable() {

                                public void run() {
                                    hideTapFeedback(v);
                                    post(new Runnable() {

                                        public void run() {
                                            if (viewData != null) {
                                                performItemClick(v, viewData.adapterPosition, viewData.itemId);
                                            } else {
                                                performItemClick(v, 0, 0);
                                            }
                                        }
                                    });
                                }
                            }, ViewConfiguration.getPressedStateDuration());
                            handled = true;
                        }
                    }
                }
                mTouchMode = TOUCH_MODE_NONE;
                break;
            }
        case MotionEvent.ACTION_CANCEL:
            {
                View v = getCurrentView();
                if (v != null) {
                    hideTapFeedback(v);
                }
                mTouchMode = TOUCH_MODE_NONE;
            }
    }
    return handled;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,5",1,"The implementation has introduced a new variable `final ViewAndMetaData viewData = getMetaDataForChild(v);` and also altered the logic that passes parameters to `performItemClick(v, viewData.adapterPosition, viewData.itemId);`. These changes are a control dependency change because they occur within an 'if' block, and a dependent API change because the `performItemClick` method is called differently based on the new 'viewData' variable. Thus, the code change types are 3 and 5.","Due to the change, there is a potential Compatibility Issue as the method `performItemClick` could be called with different parameters (`viewData.adapterPosition` and `viewData.itemId` instead of hardcoded `0, 0`), which might alter the behavior of the API. Therefore, the Compatibility Issue type is 1."
837,"<android.text.TextUtils: CharSequence commaEllipsize(CharSequence,TextPaint,float,String,String)>",13,14,,,,"{
    MeasuredText mt = MeasuredText.obtain();
    try {
        int len = text.length();
        float width = setPara(mt, p, text, 0, len, Layout.DIR_REQUEST_DEFAULT_LTR);
        if (width <= avail) {
            return text;
        }
        char[] buf = mt.mChars;
        int commaCount = 0;
        for (int i = 0; i < len; i++) {
            if (buf[i] == ',') {
                commaCount++;
            }
        }
        int remaining = commaCount + 1;
        int ok = 0;
        int okRemaining = remaining;
        String okFormat = """";
        int w = 0;
        int count = 0;
        float[] widths = mt.mWidths;
        int request = mt.mDir == 1 ? Layout.DIR_REQUEST_LTR : Layout.DIR_REQUEST_RTL;
        MeasuredText tempMt = MeasuredText.obtain();
        for (int i = 0; i < len; i++) {
            w += widths[i];
            if (buf[i] == ',') {
                count++;
                String format;
                // XXX should use plural rules and not assume English plurals
                if (--remaining == 1) {
                    format = "" "" + oneMore;
                } else {
                    format = "" "" + String.format(more, remaining);
                }
                // XXX this is probably ok, but need to look at it more
                tempMt.setPara(format, 0, format.length(), request);
                float moreWid = tempMt.addStyleRun(p, tempMt.mLen, null);
                if (w + moreWid <= avail) {
                    ok = i + 1;
                    okRemaining = remaining;
                    okFormat = format;
                }
            }
        }
        MeasuredText.recycle(tempMt);
        SpannableStringBuilder out = new SpannableStringBuilder(okFormat);
        out.insert(0, text, 0, ok);
        return out;
    } finally {
        MeasuredText.recycle(mt);
    }
}","{
    return commaEllipsize(text, p, avail, oneMore, more, TextDirectionHeuristics.FIRSTSTRONG_LTR);
}",1,"/**
 * Converts a CharSequence of the comma-separated form ""Andy, Bob,
 * Charles, David"" that is too wide to fit into the specified width
 * into one like ""Andy, Bob, 2 more"".
 *
 * @param text the text to truncate
 * @param p the Paint with which to measure the text
 * @param avail the horizontal width available for the text
 * @param oneMore the string for ""1 more"" in the current locale
 * @param more the string for ""%d more"" in the current locale
 */
","/**
 * Converts a CharSequence of the comma-separated form ""Andy, Bob,
 * Charles, David"" that is too wide to fit into the specified width
 * into one like ""Andy, Bob, 2 more"".
 *
 * @param text the text to truncate
 * @param p the Paint with which to measure the text
 * @param avail the horizontal width available for the text
 * @param oneMore the string for ""1 more"" in the current locale
 * @param more the string for ""%d more"" in the current locale
 */
",0,,,0,,,,,,,"1,5",1,"The method's early implementation had a set of logics to compute and return a value, this logic has been entirely replaced in the late implementation with a call to commaEllipsize(text, p, avail, oneMore, more, TextDirectionHeuristics.FIRSTSTRONG_LTR). This replacement indicates that the dependent API called within 'commaEllipsize' method has changed. Therefore, the code change falls under the categories of return statement changed (1) and dependent API changed (5).","As the entire implementation has been replaced with a call to a potentially different API with additional parameters (TextDirectionHeuristics.FIRSTSTRONG_LTR), the API could result in different behavior when the late version is used. Hence, there is a possibility of a compatibility issue caused by potential different return values or types (1)."
839,<android.server.BluetoothService: boolean enable(boolean)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    // Airplane mode can prevent Bluetooth radio from being turned on.
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        return false;
    }
    if (mBluetoothState != BluetoothAdapter.STATE_OFF) {
        return false;
    }
    if (mEnableThread != null && mEnableThread.isAlive()) {
        return false;
    }
    setBluetoothState(BluetoothAdapter.STATE_TURNING_ON);
    mEnableThread = new EnableThread(saveSetting);
    mEnableThread.start();
    return true;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, ""Need BLUETOOTH_ADMIN permission"");
    // Airplane mode can prevent Bluetooth radio from being turned on.
    if (mIsAirplaneSensitive && isAirplaneModeOn() && !mIsAirplaneToggleable) {
        return false;
    }
    mBluetoothState.sendMessage(BluetoothAdapterStateMachine.USER_TURN_ON, saveSetting);
    return true;
}",1,"/**
 * Enable this Bluetooth device, asynchronously.
 * This turns on/off the underlying hardware.
 *
 * @param saveSetting If true, persist the new state of BT in settings
 * @return True on success (so far)
 */
","/**
 * Enable this Bluetooth device, asynchronously.
 * This turns on/off the underlying hardware.
 *
 * @param saveSetting If true, persist the new state of BT in settings
 * @return True on success (so far)
 */
",0,,,0,,,,,,,"1,3,5",1,"The condition check for the Bluetooth state and the check for the mEnableThread being alive have been removed, and the statement for setting the Bluetooth state has also been changed. Instead of setting the Bluetooth state directly and starting a new EnableThread, the late implementation sends a message to the BluetoothAdapterStateMachine. This indicates a dependent API change as the mechanism for enabling Bluetooth has been altered, a control dependency change because the if condition checks are removed, and a return statement change as the circumstances under which true or false is returned have changed. Therefore, the change types are 1,3,5.","Since there are fewer conditions to return false and the mechanism to turn Bluetooth on has changed, the late version API has the potential to return true in scenarios where the early version would have returned false, creating a change in behavior. Therefore, the CI is of type 1."
841,<android.database.CursorWindow: boolean setNumColumns(int)>,13,14,,,,"{
    acquireReference();
    try {
        return setNumColumns_native(columnNum);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeSetNumColumns(mWindowPtr, columnNum);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Set number of Columns
 * @param columnNum
 * @return true if success
 */
","/**
 * Sets the number of columns in this window.
 * <p>
 * This method must be called before any rows are added to the window, otherwise
 * it will fail to set the number of columns if it differs from the current number
 * of columns.
 * </p>
 *
 * @param columnNum The new number of columns.
 * @return True if successful.
 */
",1,,,0,,,,,,,"4,5",0,"The method called within the try block has changed from setNumColumns_native(columnNum) to nativeSetNumColumns(mWindowPtr, columnNum), and the method signature has changed as well, as there is an additional parameter. This is a change in the dependent API, making the type 4,5.","Even though the call to the native method has been changed, this does not indicate a compatibility issue since the method being called is internal, and the signature change does not affect the return type or exception handling of the public API. Therefore, there is no compatibility issue, which is type 0."
842,<android.os.MessageQueue: Message next()>,13,14,,,,"{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            final Message msg = mMessages;
            if (msg != null) {
                final long when = msg.when;
                if (now >= when) {
                    mBlocked = false;
                    mMessages = msg.next;
                    msg.next = null;
                    if (Config.LOGV)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                } else {
                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
                }
            } else {
                nextPollTimeoutMillis = -1;
            }
            // If first time, then get the number of idlers to run.
            if (pendingIdleHandlerCount < 0) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount == 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}","{
    // -1 only during first iteration
    int pendingIdleHandlerCount = -1;
    int nextPollTimeoutMillis = 0;
    for (; ; ) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            final Message msg = mMessages;
            if (msg != null) {
                final long when = msg.when;
                if (now >= when) {
                    mBlocked = false;
                    mMessages = msg.next;
                    msg.next = null;
                    if (false)
                        Log.v(""MessageQueue"", ""Returning message: "" + msg);
                    msg.markInUse();
                    return msg;
                } else {
                    nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE);
                }
            } else {
                nextPollTimeoutMillis = -1;
            }
            // If first time, then get the number of idlers to run.
            if (pendingIdleHandlerCount < 0) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount == 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }
            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i < pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            // release the reference to the handler
            mPendingIdleHandlers[i] = null;
            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(""MessageQueue"", ""IdleHandler threw exception"", t);
            }
            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;
        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}",1,,,0,,,0,,,,,,,,,,
844,<android.widget.AutoCompleteTextView: void doAfterTextChanged()>,13,14,,,,"{
    if (mBlockCompletion)
        return;
    // called performCompletion() and we shouldn't do any more processing.
    if (DEBUG)
        Log.v(TAG, ""after text changed: openBefore="" + mOpenBefore + "" open="" + isPopupShowing());
    if (mOpenBefore && !isPopupShowing()) {
        return;
    }
    // was typed in the text view
    if (enoughToFilter()) {
        if (mFilter != null) {
            mPopupCanBeUpdated = true;
            performFiltering(getText(), mLastKeyCode);
            buildImeCompletions();
        }
    } else {
        // are deleted from the text view
        if (!mPopup.isDropDownAlwaysVisible()) {
            dismissDropDown();
        }
        if (mFilter != null) {
            mFilter.filter(null);
        }
    }
}","{
    if (mBlockCompletion)
        return;
    // called performCompletion() and we shouldn't do any more processing.
    if (DEBUG)
        Log.v(TAG, ""after text changed: openBefore="" + mOpenBefore + "" open="" + isPopupShowing());
    if (mOpenBefore && !isPopupShowing()) {
        return;
    }
    // was typed in the text view
    if (enoughToFilter()) {
        if (mFilter != null) {
            mPopupCanBeUpdated = true;
            performFiltering(getText(), mLastKeyCode);
        }
    } else {
        // are deleted from the text view
        if (!mPopup.isDropDownAlwaysVisible()) {
            dismissDropDown();
        }
        if (mFilter != null) {
            mFilter.filter(null);
        }
    }
}",1,,,0,,,0,,,,,,,4,0,The method call to buildImeCompletions() is removed from the late implementation. This represents an 'Other statement changed' scenario which is classified under the code change type 4.,"The removed code does not affect the value this method returns (since it's a void method) nor does it change the exception that could be thrown. Therefore, there is no Compatibility Issue as per the definitions provided."
846,<android.view.View: void invalidate(Rect)>,13,14,,,,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewRoot to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}","{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect r = ai.mTmpInvalRect;
            r.set(dirty.left - scrollX, dirty.top - scrollY, dirty.right - scrollX, dirty.bottom - scrollY);
            mParent.invalidateChild(this, r);
        }
    }
}",1,"/**
 * Mark the the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw} will be called at some point in the future.
 * This must be called from a UI thread. To call from a non-UI thread, call
 * {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
","/**
 * Mark the area defined by dirty as needing to be drawn. If the view is
 * visible, {@link #onDraw(android.graphics.Canvas)} will be called at some point
 * in the future. This must be called from a UI thread. To call from a non-UI
 * thread, call {@link #postInvalidate()}.
 *
 * WARNING: This method is destructive to dirty.
 * @param dirty the rectangle representing the bounds of the dirty region
 */
",1,,,0,,,,,,,"3,4",0,"There is a new control statement introduced in the form of if (skipInvalidate()) which has a return statement inside it. Additionally, there is a new line of code: mPrivateFlags |= DIRTY;, modifying the value of mPrivateFlags. These account for the change types 3,4.","Although there is a control dependency change and an other statement changed, these changes do not lead to a CI because they do not affect the return values, nor do they change the exceptions thrown by the method. The new control statement with the 'return' statement will potentially skip the execution of the rest of the code if skipInvalidate() returns true, but this only alters the internal state without affecting the method's return type or exception throwing behavior (the method is a void method). Lastly, the addition of mPrivateFlags |= DIRTY; also does not impact the method's return or exception behavior. Thus, the Compatibility Issue situation is 0."
848,<android.view.View: float getTranslationY()>,13,14,,,,"{
    return mTranslationY;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mTranslationY : 0;
}",1,"/**
 * The horizontal location of this view relative to its {@link #getTop() top} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The vertical position of this view relative to its top position,
 * in pixels.
 */
","/**
 * The horizontal location of this view relative to its {@link #getTop() top} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The vertical position of this view relative to its top position,
 * in pixels.
 */
",0,,,0,,,,,,,1,1,"The return statement has changed from 'return mTranslationY;' to 'return mTransformationInfo != null ? mTransformationInfo.mTranslationY : 0;', which results in a potential different value being returned, so the code change type is 1.","Since the late version of the method checks if 'mTransformationInfo' is not null before returning 'mTranslationY', there's a possibility that the API could return a different value (0 instead of the actual mTranslationY when 'mTransformationInfo' is null). Thus, the CI type is 1 due to different return value potential."
852,"<android.database.CursorWindow: int getInt(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return (int) getLong_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    return (int) getLong(row, column);
}",1,"/**
 * Returns an int for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return an int value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as an
 * <code>int</code>.
 * <p>
 * The result is determined by invoking {@link #getLong} and converting the
 * result to <code>int</code>.
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as an <code>int</code>.
 */
",1,,,0,,,,,,,"4,5",1,"The dependent API that is called has changed from getLong_native(row - mStartPos, col) to getLong(row, column), and the reference management methods acquireReference() and releaseReference() are removed in the late version, so the code change type is 4,5.","The removal of the reference management calls potentially changes the behavior regarding how the method handles the cursor's lifecycle, and the change in the method call from getLong_native with adjusted parameters to getLong could result in different return values. Thus, the CI type is 1."
853,<android.ddm.DdmHandleThread: Chunk handleChunk(Chunk)>,13,14,,,,"{
    if (Config.LOGV)
        Log.v(""ddm-thread"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_THEN) {
        return handleTHEN(request);
    } else if (type == CHUNK_THST) {
        return handleTHST(request);
    } else if (type == CHUNK_STKL) {
        return handleSTKL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-thread"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_THEN) {
        return handleTHEN(request);
    } else if (type == CHUNK_THST) {
        return handleTHST(request);
    } else if (type == CHUNK_STKL) {
        return handleSTKL(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",0,,,0,,,,,,,4,0,"The only change in the implementation is within the logging statement's conditional check, from checking the `Config.LOGV` flag to simply being `false`, so the code change type is 4.","The change from `Config.LOGV` to `false` in the logging statement is not related to the API's functionality or control flow. It will not affect the value returned by the method or the exceptions thrown, hence there is no compatibility issue, and the CI type is 0."
854,"<android.app.ContextImpl: int checkCallingUriPermission(Uri,int)>",13,14,,,,"{
    if (!Process.supportsProcesses()) {
        return PackageManager.PERMISSION_GRANTED;
    }
    int pid = Binder.getCallingPid();
    if (pid != Process.myPid()) {
        return checkUriPermission(uri, pid, Binder.getCallingUid(), modeFlags);
    }
    return PackageManager.PERMISSION_DENIED;
}","{
    int pid = Binder.getCallingPid();
    if (pid != Process.myPid()) {
        return checkUriPermission(uri, pid, Binder.getCallingUid(), modeFlags);
    }
    return PackageManager.PERMISSION_DENIED;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The control dependency statement 'if (!Process.supportsProcesses())' and its related return statement 'return PackageManager.PERMISSION_GRANTED;' have been removed, which indicates a change type of 3.","The removal of the condition 'if (!Process.supportsProcesses())' means that the early implementation could have returned 'PackageManager.PERMISSION_GRANTED' under certain circumstances, whereas the late implementation never will. Therefore, the behavior of the API can be different, resulting in a type 1 CI."
858,"<android.widget.LinearLayout: void measureVertical(int,int)>",13,14,,,,"{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // A divider at the end will change how much space views can consume.
    final boolean showDividerBeginning = (mShowDividers & SHOW_DIVIDER_BEGINNING) == SHOW_DIVIDER_BEGINNING;
    final boolean showDividerMiddle = (mShowDividers & SHOW_DIVIDER_MIDDLE) == SHOW_DIVIDER_MIDDLE;
    // See how tall everyone is. Also remember max width.
    boolean firstVisible = true;
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (firstVisible) {
            firstVisible = false;
            if (showDividerBeginning) {
                mTotalLength += mDividerHeight;
            }
        } else if (showDividerMiddle) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && (mShowDividers & SHOW_DIVIDER_END) == SHOW_DIVIDER_END) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && heightMode == MeasureSpec.AT_MOST) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}","{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException(""A child of LinearLayout with index "" + ""less than mBaselineAlignedChildIndex has weight > 0, which "" + ""won't work.  Either remove the weight, or don't set "" + ""mBaselineAlignedChildIndex."");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && widthMode == MeasureSpec.UNSPECIFIED) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}",1,"/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
","/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */
",0,,,0,,,,,,,,,,
859,"<android.view.ViewGroup: boolean drawChild(Canvas,View,long)>",13,14,,,,"{
    boolean more = false;
    final int cl = child.mLeft;
    final int ct = child.mTop;
    final int cr = child.mRight;
    final int cb = child.mBottom;
    final boolean childHasIdentityMatrix = child.hasIdentityMatrix();
    final int flags = mGroupFlags;
    if ((flags & FLAG_CLEAR_TRANSFORMATION) == FLAG_CLEAR_TRANSFORMATION) {
        mChildTransformation.clear();
        mGroupFlags &= ~FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    Transformation invalidationTransform;
    final Animation a = child.getAnimation();
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = mDrawLayers ? child.getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE || (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
        caching = true;
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    if (a != null) {
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(cr - cl, cb - ct, getWidth(), getHeight());
            a.initializeInvalidateRegion(0, 0, cr - cl, cb - ct);
            child.onAnimationStart();
        }
        more = a.getTransformation(drawingTime, mChildTransformation, scalingRequired ? mAttachInfo.mApplicationScale : 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (mInvalidationTransformation == null) {
                mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = mChildTransformation;
        }
        transformToApply = mChildTransformation;
        concatMatrix = a.willChangeTransformationMatrix();
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) == FLAG_OPTIMIZE_INVALIDATE) {
                    mGroupFlags |= FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    mPrivateFlags |= DRAW_ANIMATION;
                    invalidate(cl, ct, cr, cb);
                }
            } else {
                if (mInvalidateRegion == null) {
                    mInvalidateRegion = new RectF();
                }
                final RectF region = mInvalidateRegion;
                a.getInvalidateRegion(0, 0, cr - cl, cb - ct, region, invalidationTransform);
                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                mPrivateFlags |= DRAW_ANIMATION;
                final int left = cl + (int) region.left;
                final int top = ct + (int) region.top;
                invalidate(left, top, left + (int) region.width(), top + (int) region.height());
            }
        }
    } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) == FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
        final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
        if (hasTransform) {
            final int transformType = mChildTransformation.getTransformationType();
            transformToApply = transformType != Transformation.TYPE_IDENTITY ? mChildTransformation : null;
            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    child.mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(cl, ct, cr, cb, Canvas.EdgeType.BW) && (child.mPrivateFlags & DRAW_ANIMATION) == 0) {
        return more;
    }
    float alpha = child.getAlpha();
    // Bail out early if the view does not need to be drawn
    if (alpha <= ViewConfiguration.ALPHA_THRESHOLD && (child.mPrivateFlags & ALPHA_SET) == 0 && !(child instanceof SurfaceView)) {
        return more;
    }
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        child.mRecreateDisplayList = (child.mPrivateFlags & INVALIDATED) == INVALIDATED;
        child.mPrivateFlags &= ~INVALIDATED;
    }
    child.computeScroll();
    final int sx = child.mScrollX;
    final int sy = child.mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                child.buildDrawingCache(true);
            }
            cache = child.getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    child.buildDrawingCache(true);
                    cache = child.getDrawingCache(true);
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = child.canHaveDisplayList();
                    break;
            }
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    final int restoreTo = canvas.save();
    if (offsetForScroll) {
        canvas.translate(cl - sx, ct - sy);
    } else {
        canvas.translate(cl, ct);
        if (scalingRequired) {
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    if (transformToApply != null || alpha < 1.0f || !child.hasIdentityMatrix()) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    // Undo the scroll translation, apply the transformation matrix,
                    // then redo the scroll translate to get the correct result.
                    canvas.translate(-transX, -transY);
                    canvas.concat(transformToApply.getMatrix());
                    canvas.translate(transX, transY);
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1.0f) {
                    alpha *= transformToApply.getAlpha();
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix) {
                canvas.translate(-transX, -transY);
                canvas.concat(child.getMatrix());
                canvas.translate(transX, transY);
            }
        }
        if (alpha < 1.0f) {
            mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!child.onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    child.mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        child.onSetAlpha(255);
        child.mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, cr - cl, cb - ct);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (hasDisplayList) {
        displayList = child.getDisplayList();
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE) {
            final HardwareLayer layer = child.getHardwareLayer();
            if (layer != null && layer.isValid()) {
                child.mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, child.mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, child.mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    if (ViewDebug.TRACE_HIERARCHY) {
                        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
                    }
                    child.mPrivateFlags &= ~DIRTY_MASK;
                    child.dispatchDraw(canvas);
                } else {
                    child.draw(canvas);
                }
            } else {
                child.mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, cr - cl, cb - ct, null);
            }
        }
    } else if (cache != null) {
        child.mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = mCachePaint;
            if (alpha < 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = child.mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    canvas.restoreToCount(restoreTo);
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            child.onSetAlpha(255);
        }
        finishAnimatingView(child, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        invalidate(true);
        if (a instanceof AlphaAnimation) {
            // alpha animations should cause the child to recreate its display list
            child.invalidate(true);
        }
    }
    child.mRecreateDisplayList = false;
    return more;
}","{
    boolean more = false;
    final int cl = child.mLeft;
    final int ct = child.mTop;
    final int cr = child.mRight;
    final int cb = child.mBottom;
    final boolean childHasIdentityMatrix = child.hasIdentityMatrix();
    final int flags = mGroupFlags;
    if ((flags & FLAG_CLEAR_TRANSFORMATION) == FLAG_CLEAR_TRANSFORMATION) {
        mChildTransformation.clear();
        mGroupFlags &= ~FLAG_CLEAR_TRANSFORMATION;
    }
    Transformation transformToApply = null;
    Transformation invalidationTransform;
    final Animation a = child.getAnimation();
    boolean concatMatrix = false;
    boolean scalingRequired = false;
    boolean caching;
    int layerType = mDrawLayers ? child.getLayerType() : LAYER_TYPE_NONE;
    final boolean hardwareAccelerated = canvas.isHardwareAccelerated();
    if ((flags & FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE || (flags & FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
        caching = true;
        if (mAttachInfo != null)
            scalingRequired = mAttachInfo.mScalingRequired;
    } else {
        caching = (layerType != LAYER_TYPE_NONE) || hardwareAccelerated;
    }
    if (a != null) {
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(cr - cl, cb - ct, getWidth(), getHeight());
            a.initializeInvalidateRegion(0, 0, cr - cl, cb - ct);
            child.onAnimationStart();
        }
        more = a.getTransformation(drawingTime, mChildTransformation, scalingRequired ? mAttachInfo.mApplicationScale : 1f);
        if (scalingRequired && mAttachInfo.mApplicationScale != 1f) {
            if (mInvalidationTransformation == null) {
                mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = mChildTransformation;
        }
        transformToApply = mChildTransformation;
        concatMatrix = a.willChangeTransformationMatrix();
        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) == FLAG_OPTIMIZE_INVALIDATE) {
                    mGroupFlags |= FLAG_INVALIDATE_REQUIRED;
                } else if ((flags & FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    mPrivateFlags |= DRAW_ANIMATION;
                    invalidate(cl, ct, cr, cb);
                }
            } else {
                if (mInvalidateRegion == null) {
                    mInvalidateRegion = new RectF();
                }
                final RectF region = mInvalidateRegion;
                a.getInvalidateRegion(0, 0, cr - cl, cb - ct, region, invalidationTransform);
                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                mPrivateFlags |= DRAW_ANIMATION;
                final int left = cl + (int) region.left;
                final int top = ct + (int) region.top;
                invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f));
            }
        }
    } else if ((flags & FLAG_SUPPORT_STATIC_TRANSFORMATIONS) == FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
        final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
        if (hasTransform) {
            final int transformType = mChildTransformation.getTransformationType();
            transformToApply = transformType != Transformation.TYPE_IDENTITY ? mChildTransformation : null;
            concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
        }
    }
    concatMatrix |= !childHasIdentityMatrix;
    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    child.mPrivateFlags |= DRAWN;
    if (!concatMatrix && canvas.quickReject(cl, ct, cr, cb, Canvas.EdgeType.BW) && (child.mPrivateFlags & DRAW_ANIMATION) == 0) {
        return more;
    }
    float alpha = child.getAlpha();
    // Bail out early if the view does not need to be drawn
    if (alpha <= ViewConfiguration.ALPHA_THRESHOLD && (child.mPrivateFlags & ALPHA_SET) == 0 && !(child instanceof SurfaceView)) {
        return more;
    }
    if (hardwareAccelerated) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        child.mRecreateDisplayList = (child.mPrivateFlags & INVALIDATED) == INVALIDATED;
        child.mPrivateFlags &= ~INVALIDATED;
    }
    child.computeScroll();
    final int sx = child.mScrollX;
    final int sy = child.mScrollY;
    DisplayList displayList = null;
    Bitmap cache = null;
    boolean hasDisplayList = false;
    if (caching) {
        if (!hardwareAccelerated) {
            if (layerType != LAYER_TYPE_NONE) {
                layerType = LAYER_TYPE_SOFTWARE;
                child.buildDrawingCache(true);
            }
            cache = child.getDrawingCache(true);
        } else {
            switch(layerType) {
                case LAYER_TYPE_SOFTWARE:
                    child.buildDrawingCache(true);
                    cache = child.getDrawingCache(true);
                    break;
                case LAYER_TYPE_NONE:
                    // Delay getting the display list until animation-driven alpha values are
                    // set up and possibly passed on to the view
                    hasDisplayList = child.canHaveDisplayList();
                    break;
            }
        }
    }
    final boolean hasNoCache = cache == null || hasDisplayList;
    final boolean offsetForScroll = cache == null && !hasDisplayList && layerType != LAYER_TYPE_HARDWARE;
    final int restoreTo = canvas.save();
    if (offsetForScroll) {
        canvas.translate(cl - sx, ct - sy);
    } else {
        canvas.translate(cl, ct);
        if (scalingRequired) {
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }
    if (transformToApply != null || alpha < 1.0f || !child.hasIdentityMatrix()) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;
            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }
            if (transformToApply != null) {
                if (concatMatrix) {
                    // Undo the scroll translation, apply the transformation matrix,
                    // then redo the scroll translate to get the correct result.
                    canvas.translate(-transX, -transY);
                    canvas.concat(transformToApply.getMatrix());
                    canvas.translate(transX, transY);
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1.0f) {
                    alpha *= transformToApply.getAlpha();
                    mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
                }
            }
            if (!childHasIdentityMatrix) {
                canvas.translate(-transX, -transY);
                canvas.concat(child.getMatrix());
                canvas.translate(transX, transY);
            }
        }
        if (alpha < 1.0f) {
            mGroupFlags |= FLAG_CLEAR_TRANSFORMATION;
            if (hasNoCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!child.onSetAlpha(multipliedAlpha)) {
                    int layerFlags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
                    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN || layerType != LAYER_TYPE_NONE) {
                        layerFlags |= Canvas.CLIP_TO_LAYER_SAVE_FLAG;
                    }
                    if (layerType == LAYER_TYPE_NONE) {
                        final int scrollX = hasDisplayList ? 0 : sx;
                        final int scrollY = hasDisplayList ? 0 : sy;
                        canvas.saveLayerAlpha(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, multipliedAlpha, layerFlags);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    child.mPrivateFlags |= ALPHA_SET;
                }
            }
        }
    } else if ((child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
        child.onSetAlpha(255);
        child.mPrivateFlags &= ~ALPHA_SET;
    }
    if ((flags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
        if (offsetForScroll) {
            canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
        } else {
            if (!scalingRequired || cache == null) {
                canvas.clipRect(0, 0, cr - cl, cb - ct);
            } else {
                canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
            }
        }
    }
    if (hasDisplayList) {
        displayList = child.getDisplayList();
        if (!displayList.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            displayList = null;
            hasDisplayList = false;
        }
    }
    if (hasNoCache) {
        boolean layerRendered = false;
        if (layerType == LAYER_TYPE_HARDWARE) {
            final HardwareLayer layer = child.getHardwareLayer();
            if (layer != null && layer.isValid()) {
                child.mLayerPaint.setAlpha((int) (alpha * 255));
                ((HardwareCanvas) canvas).drawHardwareLayer(layer, 0, 0, child.mLayerPaint);
                layerRendered = true;
            } else {
                final int scrollX = hasDisplayList ? 0 : sx;
                final int scrollY = hasDisplayList ? 0 : sy;
                canvas.saveLayer(scrollX, scrollY, scrollX + cr - cl, scrollY + cb - ct, child.mLayerPaint, Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);
            }
        }
        if (!layerRendered) {
            if (!hasDisplayList) {
                // Fast path for layouts with no backgrounds
                if ((child.mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
                    if (ViewDebug.TRACE_HIERARCHY) {
                        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
                    }
                    child.mPrivateFlags &= ~DIRTY_MASK;
                    child.dispatchDraw(canvas);
                } else {
                    child.draw(canvas);
                }
            } else {
                child.mPrivateFlags &= ~DIRTY_MASK;
                ((HardwareCanvas) canvas).drawDisplayList(displayList, cr - cl, cb - ct, null);
            }
        }
    } else if (cache != null) {
        child.mPrivateFlags &= ~DIRTY_MASK;
        Paint cachePaint;
        if (layerType == LAYER_TYPE_NONE) {
            cachePaint = mCachePaint;
            if (alpha < 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if ((flags & FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
        } else {
            cachePaint = child.mLayerPaint;
            cachePaint.setAlpha((int) (alpha * 255));
        }
        canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
    }
    canvas.restoreToCount(restoreTo);
    if (a != null && !more) {
        if (!hardwareAccelerated && !a.getFillAfter()) {
            child.onSetAlpha(255);
        }
        finishAnimatingView(child, a);
    }
    if (more && hardwareAccelerated) {
        // invalidation is the trigger to recreate display lists, so if we're using
        // display lists to render, force an invalidate to allow the animation to
        // continue drawing another frame
        invalidate(true);
        if (a.hasAlpha() && (child.mPrivateFlags & ALPHA_SET) == ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            child.invalidate(true);
        }
    }
    child.mRecreateDisplayList = false;
    return more;
}",1,"/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occuring
 * @return True if an invalidate() was issued
 */
","/**
 * Draw one child of this View Group. This method is responsible for getting
 * the canvas in the right state. This includes clipping, translating so
 * that the child's scrolled origin is at 0, 0, and applying any animation
 * transformations.
 *
 * @param canvas The canvas on which to draw the child
 * @param child Who to draw
 * @param drawingTime The time at which draw is occuring
 * @return True if an invalidate() was issued
 */
",0,,,0,,,,,,,,,,
860,"<android.webkit.SelectActionModeCallback: boolean onCreateActionMode(ActionMode,Menu)>",13,14,,,,"{
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_copy, menu);
    mode.setTitle(com.android.internal.R.string.textSelectionCABTitle);
    mActionMode = mode;
    return true;
}","{
    mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_copy, menu);
    final Context context = mWebView.getContext();
    boolean allowText = context.getResources().getBoolean(com.android.internal.R.bool.config_allowActionMenuItemTextWithIcon);
    mode.setTitle(allowText ? context.getString(com.android.internal.R.string.textSelectionCABTitle) : null);
    if (!mode.isUiFocusable()) {
        // If the action mode UI we're running in isn't capable of taking window focus
        // the user won't be able to type into the find on page UI. Disable this functionality.
        // (Note that this should only happen in floating dialog windows.)
        // This can be removed once we can handle multiple focusable windows at a time
        // in a better way.
        final MenuItem findOnPageItem = menu.findItem(com.android.internal.R.id.find);
        if (findOnPageItem != null) {
            findOnPageItem.setVisible(false);
        }
    }
    mActionMode = mode;
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",0,"The return statement hasn't changed, but there are control dependency changes with added checks for ""allowText"" and ""mode.isUiFocusable()"", and additional statements (both conditional and method calls) that do not alter return values or exception throws. The code change types are 1,3,4.","Despite added control dependencies and other statements, the API still always returns true and does not introduce any new exceptions; therefore, no compatibility issue arises, meaning the CI type is 0."
861,<android.view.View: void draw(Canvas)>,13,14,,,,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBGDrawable;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    int paddingTop = mPaddingTop;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
        paddingTop += getTopPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + paddingTop;
    int bottom = top + mBottom - mTop - mPaddingBottom - paddingTop;
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}","{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);
    }
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & DIRTY_MASK) == DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~DIRTY_MASK) | DRAWN;
    /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) {
        final Drawable background = mBGDrawable;
        if (background != null) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            if (mBackgroundSizeChanged) {
                background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);
                mBackgroundSizeChanged = false;
            }
            if ((scrollX | scrollY) == 0) {
                background.draw(canvas);
            } else {
                canvas.translate(scrollX, scrollY);
                background.draw(canvas);
                canvas.translate(-scrollX, -scrollY);
            }
        }
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque)
            onDraw(canvas);
        // Step 4, draw the children
        dispatchDraw(canvas);
        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
        // we're done...
        return;
    }
    /*
         * Here we do the full fledged routine...
         * (this is an uncommon case where speed matters less,
         * this is why we repeat some of the tests that have been
         * done above)
         */
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;
    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;
    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;
    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }
    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);
    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }
    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }
    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }
    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }
    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }
    saveCount = canvas.getSaveCount();
    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }
        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }
        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }
        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }
    // Step 3, draw the content
    if (!dirtyOpaque)
        onDraw(canvas);
    // Step 4, draw the children
    dispatchDraw(canvas);
    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;
    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, right, top + length, p);
    }
    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }
    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(left, top, left + length, bottom, p);
    }
    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        canvas.drawRect(right - length, top, right, bottom, p);
    }
    canvas.restoreToCount(saveCount);
    // Step 6, draw decorations (scrollbars)
    onDrawScrollBars(canvas);
}",1,"/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement {@link #onDraw} instead of
 * overriding this method. If you do need to override this method, call
 * the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
","/**
 * Manually render this view (and all of its children) to the given Canvas.
 * The view must have already done a full layout before this function is
 * called.  When implementing a view, implement
 * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
 * If you do need to override this method, call the superclass version.
 *
 * @param canvas The Canvas to which the View is rendered.
 */
",1,,,0,,,,,,,,,,
862,<android.widget.TextView: float getRightFadingEdgeStrength()>,13,14,,,,"{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            return (marquee.mMaxFadeScroll - marquee.mScroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            switch(mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}","{
    if (mCurrentAlpha <= ViewConfiguration.ALPHA_THRESHOLD_INT)
        return 0.0f;
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        if (mMarquee != null && !mMarquee.isStopped()) {
            final Marquee marquee = mMarquee;
            return (marquee.mMaxFadeScroll - marquee.mScroll) / getHorizontalFadingEdgeLength();
        } else if (getLineCount() == 1) {
            final int layoutDirection = getResolvedLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
            switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.LEFT:
                    final int textWidth = (mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight();
                    final float lineWidth = mLayout.getLineWidth(0);
                    return (lineWidth - textWidth) / getHorizontalFadingEdgeLength();
                case Gravity.RIGHT:
                    return 0.0f;
                case Gravity.CENTER_HORIZONTAL:
                case Gravity.FILL_HORIZONTAL:
                    return (mLayout.getLineWidth(0) - ((mRight - mLeft) - getCompoundPaddingLeft() - getCompoundPaddingRight())) / getHorizontalFadingEdgeLength();
            }
        }
    }
    return super.getRightFadingEdgeStrength();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The if condition has a new check on `mMarqueeFadeMode`, and there's a new method call `getResolvedLayoutDirection()` introduced. Additionally, there's a replacement of `mGravity` with `absoluteGravity`. Given these changes, we can classify them as the introduction of new return conditions (1), a control dependency change due to the new if condition (3), and other changes due to a new method call and variable replacement (4).","Because of the new if condition, it's possible that the method might return `super.getRightFadingEdgeStrength()` where previously it would have returned a calculated strength. Furthermore, the calculation of the fading edge strength can also differ due to the new usage of `absoluteGravity` which considers the layout direction, which might potentially return different values. Thus, there is a compatibility issue caused by potential different return values (1)."
863,<android.content.res.Configuration: String toString()>,13,14,,,,"{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    sb.append(mcc);
    sb.append(""mcc"");
    sb.append(mnc);
    sb.append(""mnc"");
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" (no locale)"");
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}","{
    StringBuilder sb = new StringBuilder(128);
    sb.append(""{"");
    sb.append(fontScale);
    sb.append("" "");
    sb.append(mcc);
    sb.append(""mcc"");
    sb.append(mnc);
    sb.append(""mnc"");
    if (locale != null) {
        sb.append("" "");
        sb.append(locale);
    } else {
        sb.append("" (no locale)"");
    }
    switch(textLayoutDirection) {
        case LocaleUtil.TEXT_LAYOUT_DIRECTION_RTL_DO_NOT_USE:
            sb.append("" rtl"");
            break;
        default:
            sb.append("" layoutdir="");
            sb.append(textLayoutDirection);
            break;
    }
    if (smallestScreenWidthDp != SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" sw"");
        sb.append(smallestScreenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?swdp"");
    }
    if (screenWidthDp != SCREEN_WIDTH_DP_UNDEFINED) {
        sb.append("" w"");
        sb.append(screenWidthDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?wdp"");
    }
    if (screenHeightDp != SCREEN_HEIGHT_DP_UNDEFINED) {
        sb.append("" h"");
        sb.append(screenHeightDp);
        sb.append(""dp"");
    } else {
        sb.append("" ?hdp"");
    }
    switch((screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        case SCREENLAYOUT_SIZE_UNDEFINED:
            sb.append("" ?lsize"");
            break;
        case SCREENLAYOUT_SIZE_SMALL:
            sb.append("" smll"");
            break;
        case SCREENLAYOUT_SIZE_NORMAL:
            sb.append("" nrml"");
            break;
        case SCREENLAYOUT_SIZE_LARGE:
            sb.append("" lrg"");
            break;
        case SCREENLAYOUT_SIZE_XLARGE:
            sb.append("" xlrg"");
            break;
        default:
            sb.append("" layoutSize="");
            sb.append(screenLayout & SCREENLAYOUT_SIZE_MASK);
            break;
    }
    switch((screenLayout & SCREENLAYOUT_LONG_MASK)) {
        case SCREENLAYOUT_LONG_UNDEFINED:
            sb.append("" ?long"");
            break;
        case SCREENLAYOUT_LONG_NO:
            /* not-long is not interesting to print */
            break;
        case SCREENLAYOUT_LONG_YES:
            sb.append("" long"");
            break;
        default:
            sb.append("" layoutLong="");
            sb.append(screenLayout & SCREENLAYOUT_LONG_MASK);
            break;
    }
    switch(orientation) {
        case ORIENTATION_UNDEFINED:
            sb.append("" ?orien"");
            break;
        case ORIENTATION_LANDSCAPE:
            sb.append("" land"");
            break;
        case ORIENTATION_PORTRAIT:
            sb.append("" port"");
            break;
        default:
            sb.append("" orien="");
            sb.append(orientation);
            break;
    }
    switch((uiMode & UI_MODE_TYPE_MASK)) {
        case UI_MODE_TYPE_UNDEFINED:
            sb.append("" ?uimode"");
            break;
        case UI_MODE_TYPE_NORMAL:
            /* normal is not interesting to print */
            break;
        case UI_MODE_TYPE_DESK:
            sb.append("" desk"");
            break;
        case UI_MODE_TYPE_CAR:
            sb.append("" car"");
            break;
        case UI_MODE_TYPE_TELEVISION:
            sb.append("" television"");
            break;
        default:
            sb.append("" uimode="");
            sb.append(uiMode & UI_MODE_TYPE_MASK);
            break;
    }
    switch((uiMode & UI_MODE_NIGHT_MASK)) {
        case UI_MODE_NIGHT_UNDEFINED:
            sb.append("" ?night"");
            break;
        case UI_MODE_NIGHT_NO:
            /* not-night is not interesting to print */
            break;
        case UI_MODE_NIGHT_YES:
            sb.append("" night"");
            break;
        default:
            sb.append("" night="");
            sb.append(uiMode & UI_MODE_NIGHT_MASK);
            break;
    }
    switch(touchscreen) {
        case TOUCHSCREEN_UNDEFINED:
            sb.append("" ?touch"");
            break;
        case TOUCHSCREEN_NOTOUCH:
            sb.append("" -touch"");
            break;
        case TOUCHSCREEN_STYLUS:
            sb.append("" stylus"");
            break;
        case TOUCHSCREEN_FINGER:
            sb.append("" finger"");
            break;
        default:
            sb.append("" touch="");
            sb.append(touchscreen);
            break;
    }
    switch(keyboard) {
        case KEYBOARD_UNDEFINED:
            sb.append("" ?keyb"");
            break;
        case KEYBOARD_NOKEYS:
            sb.append("" -keyb"");
            break;
        case KEYBOARD_QWERTY:
            sb.append("" qwerty"");
            break;
        case KEYBOARD_12KEY:
            sb.append("" 12key"");
            break;
        default:
            sb.append("" keys="");
            sb.append(keyboard);
            break;
    }
    switch(keyboardHidden) {
        case KEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case KEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case KEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        case KEYBOARDHIDDEN_SOFT:
            sb.append(""/s"");
            break;
        default:
            sb.append(""/"");
            sb.append(keyboardHidden);
            break;
    }
    switch(hardKeyboardHidden) {
        case HARDKEYBOARDHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case HARDKEYBOARDHIDDEN_NO:
            sb.append(""/v"");
            break;
        case HARDKEYBOARDHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(hardKeyboardHidden);
            break;
    }
    switch(navigation) {
        case NAVIGATION_UNDEFINED:
            sb.append("" ?nav"");
            break;
        case NAVIGATION_NONAV:
            sb.append("" -nav"");
            break;
        case NAVIGATION_DPAD:
            sb.append("" dpad"");
            break;
        case NAVIGATION_TRACKBALL:
            sb.append("" tball"");
            break;
        case NAVIGATION_WHEEL:
            sb.append("" wheel"");
            break;
        default:
            sb.append("" nav="");
            sb.append(navigation);
            break;
    }
    switch(navigationHidden) {
        case NAVIGATIONHIDDEN_UNDEFINED:
            sb.append(""/?"");
            break;
        case NAVIGATIONHIDDEN_NO:
            sb.append(""/v"");
            break;
        case NAVIGATIONHIDDEN_YES:
            sb.append(""/h"");
            break;
        default:
            sb.append(""/"");
            sb.append(navigationHidden);
            break;
    }
    if (seq != 0) {
        sb.append("" s."");
        sb.append(seq);
    }
    sb.append('}');
    return sb.toString();
}",1,,,0,,,0,,,,,,,,,,
864,"<android.webkit.CallbackProxy: void onPageStarted(String,Bitmap)>",13,14,,,,"{
    // been set.
    if (mWebViewClient == null) {
        return;
    }
    // Performance probe
    if (PERF_PROBE) {
        mWebCoreThreadTime = SystemClock.currentThreadTimeMillis();
        mWebCoreIdleTime = 0;
        Network.getInstance(mContext).startTiming();
    // un-comment this if PERF_PROBE is true
    // Looper.myQueue().setWaitCallback(mIdleCallback);
    }
    Message msg = obtainMessage(PAGE_STARTED);
    msg.obj = favicon;
    msg.getData().putString(""url"", url);
    sendMessage(msg);
}","{
    // Performance probe
    if (PERF_PROBE) {
        mWebCoreThreadTime = SystemClock.currentThreadTimeMillis();
        mWebCoreIdleTime = 0;
        Network.getInstance(mContext).startTiming();
    // un-comment this if PERF_PROBE is true
    // Looper.myQueue().setWaitCallback(mIdleCallback);
    }
    Message msg = obtainMessage(PAGE_STARTED);
    msg.obj = favicon;
    msg.getData().putString(""url"", url);
    sendMessage(msg);
}",1,,,0,,,0,,,,,,,4,0,"An if statement checking if mWebViewClient is null along with its corresponding return statement has been removed, this is not a change in the control dependency of the method itself but a change in a certain condition that would result in an early exit from the method. Therefore, the change is classified as 'Other statement changed' which is 4.","There is no Compatibility Issue because the return type and exceptions that this method could throw remain the same. The behavior change relates only to an internal condition check, which, if it were null, the method would exit early without sending a message—yet this code does not affect external behavior regarding the return type or exceptions thrown. Therefore, the code change doesn't lead to a Compatibility Issue."
865,<android.view.View: float getX()>,13,14,,,,"{
    return mLeft + mTranslationX;
}","{
    return mLeft + (mTransformationInfo != null ? mTransformationInfo.mTranslationX : 0);
}",1,"/**
 * The visual x position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationX(float) translationX} property plus the current
 * {@link #getLeft() left} property.
 *
 * @return The visual x position of this view, in pixels.
 */
","/**
 * The visual x position of this view, in pixels. This is equivalent to the
 * {@link #setTranslationX(float) translationX} property plus the current
 * {@link #getLeft() left} property.
 *
 * @return The visual x position of this view, in pixels.
 */
",0,,,0,,,,,,,4,1,"The method implementation has been changed to account for the possibility that mTransformationInfo might be null; this introduces a ternary conditional expression instead of a direct addition with mTranslationX which existed in the early version. Therefore, the code change type is 4.","The implementation previously added mTranslationX directly; however, in the later version, there is a condition that checks if mTransformationInfo is not null before using mTransformationInfo.mTranslationX. Otherwise, it adds 0. Therefore, this change could potentially return a different value if mTransformationInfo happens to be null, so the CI type is 1."
868,<android.view.HardwareRenderer.GlRenderer: void destroy(boolean)>,13,14,,,,"{
    if (full && mCanvas != null) {
        mCanvas = null;
    }
    if (!isEnabled() || mDestroyed)
        return;
    mDestroyed = true;
    sEgl.eglMakeCurrent(sEglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
    sEgl.eglDestroySurface(sEglDisplay, mEglSurface);
    mEglSurface = null;
    mGl = null;
    setEnabled(false);
}","{
    if (full && mCanvas != null) {
        mCanvas = null;
    }
    if (!isEnabled() || mDestroyed) {
        setEnabled(false);
        return;
    }
    destroySurface();
    setEnabled(false);
    mDestroyed = true;
    mGl = null;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4,5",1,"The return statement has been moved inside the conditional control block and additional code (`setEnabled(false);`) has been added before returning. A new method call (`destroySurface();`) replaces inline code for destroying the surface. Additionally, the order of statements after the conditional has changed, affecting the control dependencies and other statements, so the change types are 1,3,4,5.","These changes in control flow and the additional call to `setEnabled(false);` before the return when the conditions are met could lead to different return behaviors, such as the state of `mDestroyed` being potentially different. The `destroySurface()` method's introduction might also change the behavior due to the replaced inlined code. Because of these return behavior changes, the CI type is 1."
872,<android.database.CursorWindow: void finalize()>,13,14,,,,"{
    if (nWindow == 0) {
        return;
    }
    // due to bugs 3329504, 3502276, cursorwindow sometimes is closed in fialize()
    // don't print any warning saying ""don't release cursor in finzlize""
    // because it is a bug in framework code - NOT an app bug.
    recordClosingOfWindow(nWindow);
    close_native();
}","{
    try {
        if (mCloseGuard != null) {
            mCloseGuard.warnIfOpen();
        }
        dispose();
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"2,4",2,"There is a removal of the early implementation code which includes a return statement and a conditional check to skip the rest of the finalizer if nWindow was 0. Additionally, there is a new exception handling structure using a try-finally block, along with a call to a new method, dispose(), replacing the specific actions from the early version (recordClosingOfWindow(nWindow) and close_native()). The call to super.finalize() has also been moved to a finally block. Therefore, the change types include the addition of finalizer-related control flow (4) and exception handling changes (2).","The old version has a condition that can terminate the method prematurely, while the new version does not, which may lead to differences in behavior when nWindow is 0. Additionally, changing from specific close behavior to the more generic dispose() method and adding a new call to mCloseGuard.warnIfOpen() means that the behavior upon finalization could be different. Additionally, the new try-finally structure could result in the super.finalize() method being called under conditions where the early version might have exited, potentially causing different exceptions to be thrown. The CI type is 2 due to the change in exception handling."
873,"<android.view.View: void invalidate(int,int,int,int)>",13,14,,,,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewRoot to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}","{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE);
    }
    if (skipInvalidate()) {
        return;
    }
    if ((mPrivateFlags & (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS) || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID || (mPrivateFlags & INVALIDATED) != INVALIDATED) {
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        mPrivateFlags |= INVALIDATED;
        mPrivateFlags |= DIRTY;
        final ViewParent p = mParent;
        final AttachInfo ai = mAttachInfo;
        // noinspection PointlessBooleanExpression,ConstantConditions
        if (!HardwareRenderer.RENDER_DIRTY_REGIONS) {
            if (p != null && ai != null && ai.mHardwareAccelerated) {
                // fast-track for GL-enabled applications; just invalidate the whole hierarchy
                // with a null dirty rect, which tells the ViewAncestor to redraw everything
                p.invalidateChild(this, null);
                return;
            }
        }
        if (p != null && ai != null && l < r && t < b) {
            final int scrollX = mScrollX;
            final int scrollY = mScrollY;
            final Rect tmpr = ai.mTmpInvalRect;
            tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
            p.invalidateChild(this, tmpr);
        }
    }
}",1,"/**
 * Mark the the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw} will be called at some point
 * in the future. This must be called from a UI thread. To call
 * from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
","/**
 * Mark the area defined by the rect (l,t,r,b) as needing to be drawn.
 * The coordinates of the dirty rect are relative to the view.
 * If the view is visible, {@link #onDraw(android.graphics.Canvas)}
 * will be called at some point in the future. This must be called from
 * a UI thread. To call from a non-UI thread, call {@link #postInvalidate()}.
 * @param l the left position of the dirty region
 * @param t the top position of the dirty region
 * @param r the right position of the dirty region
 * @param b the bottom position of the dirty region
 */
",1,,,0,,,,,,,"3,4",0,"The control flow has changed due to the introduction of the `skipInvalidate()` check as the first condition within the method, and there is also an additional assignment statement `mPrivateFlags |= DIRTY;`. These are classified as control dependency change (3) and other statement changed (4).","Even though there is a control flow change and an additional assignment, these changes do not inherently lead to a Compatibility Issue. The new `skipInvalidate()` method likely encapsulates existing conditions but changes the control flow to return earlier. Since the same checks and actions (e.g., invalidating the parent and setting other flags) are still performed when `skipInvalidate()` is false, there would be no difference in external behavior, assuming that `skipInvalidate()` correctly identifies cases where the view would not have been invalidated in the earlier version. The additional `mPrivateFlags |= DIRTY;` seems to be a state change that is internal to the View, which should not affect the API's public behavior or agreement on the method's functionality. Therefore, this should not be marked as a CI unless there's evidence that this internal state change would affect observable behavior or unless `skipInvalidate()` checks for additional conditions not enforced in the early version. As it stands, we cannot assert a Behavioral Compatibility Issue without more information about the possible side effects of `DIRTY` being set on `mPrivateFlags` or the internal logic of `skipInvalidate()`."
875,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: void onDataSetChanged()>,13,14,,,,"{
    mFactory.onDataSetChanged();
}","{
    try {
        mFactory.onDataSetChanged();
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
}",1,,,0,,,0,,,,,,,"2,3",2,"An exception handling mechanism has been introduced with a 'try' block around the existing method call and a 'catch' block for handling exceptions, thus the code changed types are 2,3.","Previously, if there was an exception in mFactory.onDataSetChanged(), it would manifest as a thrown exception wherever this method was called. However, in the late version, exceptions are caught and passed to the UncaughtExceptionHandler of the current thread, changing the exception handling behavior of the API. This could lead to a CI since the method now behaves differently with respect to exceptions, so the CI type is 2."
876,<android.bluetooth.BluetoothDeviceProfileState.IncomingHid: boolean processMessage(Message)>,13,14,,,,"{
    log(""IncomingHid State->Processing Message: "" + message.what);
    Message deferMsg = new Message();
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case CONNECT_HFP_INCOMING:
        case DISCONNECT_HFP_OUTGOING:
        case CONNECT_A2DP_INCOMING:
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
        case CONNECT_HID_OUTGOING:
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case DISCONNECT_HFP_INCOMING:
            // ignore
            break;
        case DISCONNECT_HID_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            // Ignore, will be handled by Bluez
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}","{
    log(""IncomingHid State->Processing Message: "" + message.what);
    Message deferMsg = new Message();
    switch(message.what) {
        case CONNECT_HFP_OUTGOING:
        case CONNECT_HFP_INCOMING:
        case DISCONNECT_HFP_OUTGOING:
        case CONNECT_A2DP_INCOMING:
        case CONNECT_A2DP_OUTGOING:
        case DISCONNECT_A2DP_OUTGOING:
        case CONNECT_HID_OUTGOING:
        case CONNECT_HID_INCOMING:
        case DISCONNECT_HID_OUTGOING:
            deferMessage(message);
            break;
        case CONNECTION_ACCESS_REQUEST_REPLY:
            mConnectionAccessReplyReceived = true;
            int val = message.arg1;
            setTrust(val);
            handleIncomingConnection(CONNECT_HID_INCOMING, val == BluetoothDevice.CONNECTION_ACCESS_YES);
            break;
        case CONNECTION_ACCESS_REQUEST_EXPIRY:
            if (!mConnectionAccessReplyReceived) {
                handleIncomingConnection(CONNECT_HID_INCOMING, false);
                sendConnectionAccessRemovalIntent();
                sendMessage(TRANSITION_TO_STABLE);
            }
            break;
        case DISCONNECT_HFP_INCOMING:
            // ignore
            break;
        case DISCONNECT_HID_INCOMING:
        case DISCONNECT_A2DP_INCOMING:
            // Ignore, will be handled by Bluez
            break;
        case DISCONNECT_PBAP_OUTGOING:
        case UNPAIR:
        case AUTO_CONNECT_PROFILES:
            deferMessage(message);
            break;
        case TRANSITION_TO_STABLE:
            transitionTo(mBondedDevice);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"There are two new cases added to the switch statement: CONNECTION_ACCESS_REQUEST_REPLY and CONNECTION_ACCESS_REQUEST_EXPIRY, which indicates a control dependency change (3), and new logic is introduced with these cases representing other statement changes (4).","These changes introduce new pathways for handling certain messages but do not change how existing messages are processed. As the behavior is altered only for the new cases added, and there is no indication that these changes would cause the method to return a different result or throw a different exception for the previously handled cases, there is no Compatibility Issue according to the defined criteria."
878,"<android.speech.tts.TextToSpeech: int playSilence(long,int,HashMap<String, String>)>",13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                setCachedParam(params, Engine.KEY_PARAM_UTTERANCE_ID, Engine.PARAM_POSITION_UTTERANCE_ID);
            }
            result = mITts.playSilence(mPackageName, durationInMs, queueMode, mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playSilence"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playSilence"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - playSilence"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            return service.playSilence(getPackageName(), durationInMs, queueMode, getParams(params));
        }
    }, ERROR, ""playSilence"");
}",1,"/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 *
 * @param durationInMs
 * A long that indicates how long the silence should last.
 * @param queueMode
 * {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Plays silence for the specified amount of time using the specified
 * queue mode.
 *
 * @param durationInMs The duration of the silence.
 * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4,5","1,2","The implementation of the method has changed significantly: handling of method synchronization, parameter processing, and error handling have been replaced by a new structure. A new anonymous class Action with method run is introduced, the previous try-catch blocks and finally block have been removed, and the wrapped method call has new logic (runAction and getParams). Moreover, new dependent APIs like runAction and getParams have been introduced. Thus, there are changes in the return statement, control dependency, other statements, and dependent APIs, which are types 1,3,4,5.","Because of the removal of the exception handling mechanism and changes in the execution flow, as well as the use of new dependent APIs, the API potentially returns different values (either by a change in how parameters are processed or how exceptions are handled). As the previous version was catching exceptions and restarting TTS on errors, while the new version propagates them, there's also a CI due to the handling of exceptions. Therefore, the types of CI involved here are 1 (potential different return values) and 2 (potential different exception handlings)."
879,<android.view.View: boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent)>,13,14,,,,"{
    return false;
}","{
    if (mAccessibilityDelegate != null) {
        return mAccessibilityDelegate.dispatchPopulateAccessibilityEvent(this, event);
    } else {
        return dispatchPopulateAccessibilityEventInternal(event);
    }
}",1,"/**
 * Dispatches an {@link AccessibilityEvent} to the {@link View} children
 * to be populated.
 *
 * @param event The event.
 *
 * @return True if the event population was completed.
 */
","/**
 * Dispatches an {@link AccessibilityEvent} to the {@link View} first and then
 * to its children for adding their text content to the event. Note that the
 * event text is populated in a separate dispatch path since we add to the
 * event not only the text of the source but also the text of all its descendants.
 * A typical implementation will call
 * {@link #onPopulateAccessibilityEvent(AccessibilityEvent)} on the this view
 * and then call the {@link #dispatchPopulateAccessibilityEvent(AccessibilityEvent)}
 * on each child. Override this method if custom population of the event text
 * content is required.
 * <p>
 * If an {@link AccessibilityDelegate} has been specified via calling
 * {@link #setAccessibilityDelegate(AccessibilityDelegate)} its
 * {@link AccessibilityDelegate#dispatchPopulateAccessibilityEvent(View, AccessibilityEvent)}
 * is responsible for handling this call.
 * </p>
 * <p>
 * <em>Note:</em> Accessibility events of certain types are not dispatched for
 * populating the event text via this method. For details refer to {@link AccessibilityEvent}.
 * </p>
 *
 * @param event The event.
 *
 * @return True if the event population was completed.
 */
",1,,,0,,,,,,,"1,3,5",1,"The early implementation always returns false, while the late implementation may return different boolean values depending on conditions and the invocation of new methods (mAccessibilityDelegate.dispatchPopulateAccessibilityEvent() and dispatchPopulateAccessibilityEventInternal()). Additionally, there is the introduction of a control dependency change (if-else) and it relies on a possibly new or modified method dispatchPopulateAccessibilityEventInternal() or a change in the behavior of mAccessibilityDelegate, hence the changes are 1, 3, 5.","The late implementation introduces the potential for a different return value depending on whether mAccessibilityDelegate is not null and based on the outcome of the delegate's dispatchPopulateAccessibilityEvent or dispatchPopulateAccessibilityEventInternal() method, resulting in a CI type of 1."
881,<android.view.HardwareRenderer.GlRenderer: void initializeEgl()>,13,14,,,,"{
    if (sEglContext != null)
        return;
    sEglThread = Thread.currentThread();
    sEgl = (EGL10) EGLContext.getEGL();
    // Get to the default display.
    sEglDisplay = sEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
    if (sEglDisplay == EGL10.EGL_NO_DISPLAY) {
        throw new RuntimeException(""eglGetDisplay failed "" + getEGLErrorString(sEgl.eglGetError()));
    }
    // We can now initialize EGL for that display
    int[] version = new int[2];
    if (!sEgl.eglInitialize(sEglDisplay, version)) {
        throw new RuntimeException(""eglInitialize failed "" + getEGLErrorString(sEgl.eglGetError()));
    }
    sEglConfig = getConfigChooser(mGlVersion).chooseConfig(sEgl, sEglDisplay);
    if (sEglConfig == null) {
        // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
        if (mDirtyRegions) {
            mDirtyRegions = false;
            sEglConfig = getConfigChooser(mGlVersion).chooseConfig(sEgl, sEglDisplay);
            if (sEglConfig == null) {
                throw new RuntimeException(""eglConfig not initialized"");
            }
        } else {
            throw new RuntimeException(""eglConfig not initialized"");
        }
    }
    /*
            * Create an EGL context. We want to do this as rarely as we can, because an
            * EGL context is a somewhat heavy object.
            */
    sEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
}","{
    synchronized (sEglLock) {
        if (sEgl == null && sEglConfig == null) {
            sEgl = (EGL10) EGLContext.getEGL();
            // Get to the default display.
            sEglDisplay = sEgl.eglGetDisplay(EGL_DEFAULT_DISPLAY);
            if (sEglDisplay == EGL_NO_DISPLAY) {
                throw new RuntimeException(""eglGetDisplay failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            // We can now initialize EGL for that display
            int[] version = new int[2];
            if (!sEgl.eglInitialize(sEglDisplay, version)) {
                throw new RuntimeException(""eglInitialize failed "" + GLUtils.getEGLErrorString(sEgl.eglGetError()));
            }
            sEglConfig = chooseEglConfig();
            if (sEglConfig == null) {
                // We tried to use EGL_SWAP_BEHAVIOR_PRESERVED_BIT, try again without
                if (sDirtyRegions) {
                    sDirtyRegions = false;
                    sEglConfig = chooseEglConfig();
                    if (sEglConfig == null) {
                        throw new RuntimeException(""eglConfig not initialized"");
                    }
                } else {
                    throw new RuntimeException(""eglConfig not initialized"");
                }
            }
        }
    }
    mEglContext = sEglContextStorage.get();
    mEglThread = Thread.currentThread();
    if (mEglContext == null) {
        mEglContext = createContext(sEgl, sEglDisplay, sEglConfig);
        sEglContextStorage.set(mEglContext);
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The late version introduces a synchronized block and changes some variable scopes and names. It uses `sEglLock` for synchronization, modifies the condition in the if statement to check both `sEgl` and `sEglConfig` instead of `sEglContext`, and renames some variables like `sEglContext` to `mEglContext` and sets it from `sEglContextStorage`. It also changes the error handling by utilizing `GLUtils.getEGLErrorString` instead of `getEGLErrorString`, as well as replacing `EGL10.EGL_DEFAULT_DISPLAY` with `EGL_DEFAULT_DISPLAY`. Therefore, both control dependency and other statements have been changed, which corresponds to code change types 3,4.","Despite the changes, the overall goal and outcome of the `initializeEgl()` method remain intact. The synchronization was added to ensure thread safety, but it does not affect the external behavior of the method as it still initializes EGL if not already initialized. The changes in variable scopes and error handling messages do not alter the method's logic or the exceptions it may throw, assuming the error utility methods used (`GLUtils.getEGLErrorString` and the previous `getEGLErrorString`) behave similarly. Therefore, no compatibility issue is introduced due to these changes, which corresponds to CI type 0."
884,"<android.widget.RemoteViews: View apply(Context,ViewGroup)>",13,14,,,,"{
    View result;
    Context c = prepareContext(context);
    LayoutInflater inflater = (LayoutInflater) c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    inflater = inflater.cloneInContext(c);
    inflater.setFilter(this);
    result = inflater.inflate(mLayoutId, parent, false);
    performApply(result);
    return result;
}","{
    View result;
    Context c = prepareContext(context);
    LayoutInflater inflater = (LayoutInflater) c.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    inflater = inflater.cloneInContext(c);
    inflater.setFilter(this);
    result = inflater.inflate(mLayoutId, parent, false);
    performApply(result, parent);
    return result;
}",1,"/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
","/**
 * Inflates the view hierarchy represented by this object and applies
 * all of the actions.
 *
 * <p><strong>Caller beware: this may throw</strong>
 *
 * @param context Default context to use
 * @param parent Parent that the resulting view hierarchy will be attached to. This method
 * does <strong>not</strong> attach the hierarchy. The caller should do so when appropriate.
 * @return The inflated view hierarchy
 */
",0,,,0,,,,,,,"4,5",0,"The method performApply in the late version has an additional parameter 'parent' compared to the early version. This is a change in a statement other than a return, exception handling, or control dependency statement, hence it is classified as a change type 4. Furthermore, the change affects the invocation of a dependent method, so it's also classified as a change type 5.","Despite the change in how performApply is called, there is no direct implication that this change leads to a different return value or exception thrown by the apply method itself. The return statement 'return result;' remains unaffected, and no additional exception handling logic has been introduced. Assuming that performApply does not modify the 'result' object in a way that would change the behavior of 'return result;', it can be inferred that there is no Compatibility Issue with regards to the return value or exception thrown by the apply method. Therefore, the CI type is 0."
886,<android.webkit.WebView: void documentHasImages(Message)>,13,14,,,,"{
    if (response == null) {
        return;
    }
    mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES, response);
}","{
    checkThread();
    if (response == null) {
        return;
    }
    mWebViewCore.sendMessage(EventHub.DOC_HAS_IMAGES, response);
}",1,"/**
 * Query the document to see if it contains any image references. The
 * message object will be dispatched with arg1 being set to 1 if images
 * were found and 0 if the document does not reference any images.
 * @param response The message that will be dispatched with the result.
 */
","/**
 * Query the document to see if it contains any image references. The
 * message object will be dispatched with arg1 being set to 1 if images
 * were found and 0 if the document does not reference any images.
 * @param response The message that will be dispatched with the result.
 */
",0,,,0,,,,,,,4,0,"There is only an additional checkThread() method call in the late version implementation, which does not affect the return type or exceptions thrown by the method. This is categorized as 4: Other statement changed.","The change does not lead to a CI since the new method call checkThread() is most likely a thread safety check and will not change the method's behavior regarding return values or exception handling, provided it does not throw an exception itself. Therefore, the code will still behave the same way in terms of the actual logic concerning image document existence. The pred_CI is 0: No Compatibility Issue."
888,"<android.content.SyncAdapterType: void writeToParcel(Parcel,int)>",13,14,,,,"{
    if (isKey) {
        throw new IllegalStateException(""keys aren't parcelable"");
    }
    dest.writeString(authority);
    dest.writeString(accountType);
    dest.writeInt(userVisible ? 1 : 0);
    dest.writeInt(supportsUploading ? 1 : 0);
    dest.writeInt(isAlwaysSyncable ? 1 : 0);
    dest.writeInt(allowParallelSyncs ? 1 : 0);
}","{
    if (isKey) {
        throw new IllegalStateException(""keys aren't parcelable"");
    }
    dest.writeString(authority);
    dest.writeString(accountType);
    dest.writeInt(userVisible ? 1 : 0);
    dest.writeInt(supportsUploading ? 1 : 0);
    dest.writeInt(isAlwaysSyncable ? 1 : 0);
    dest.writeInt(allowParallelSyncs ? 1 : 0);
    dest.writeString(settingsActivity);
}",1,,,0,,,0,,,,,,,4,1,"An additional statement to write a new field `settingsActivity` to the parcel has been added, so the code change type is 4.","The addition of writing the `settingsActivity` string to the parcel means that the parcel will contain different data after the change. This is a structural change to the parcel and thus will cause the method to return a parcel with different content. Therefore, the CI type is 1."
890,<android.util.Log: String getStackTraceString(Throwable)>,13,14,,,,"{
    if (tr == null) {
        return """";
    }
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    tr.printStackTrace(pw);
    return sw.toString();
}","{
    if (tr == null) {
        return """";
    }
    // This is to reduce the amount of log spew that apps do in the non-error
    // condition of the network being unavailable.
    Throwable t = tr;
    while (t != null) {
        if (t instanceof UnknownHostException) {
            return """";
        }
        t = t.getCause();
    }
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    tr.printStackTrace(pw);
    return sw.toString();
}",1,"/**
 * Handy function to get a loggable stack trace from a Throwable
 * @param tr An exception to log
 */
","/**
 * Handy function to get a loggable stack trace from a Throwable
 * @param tr An exception to log
 */
",0,,,0,,,,,,,3,1,"The late implementation introduces a while loop to check for instances of UnknownHostException and potentially return an empty string where the early version would not, so the change type is 3 (Control dependency change).","The addition of the new check for UnknownHostException introduces a new condition under which the method will return an empty string instead of the throwable's stack trace, meaning that in some cases where the early version would have returned a stack trace, the late version will return an empty string. Therefore, the CI type is 1 (Compatibility Issue caused by potential different return values)."
891,"<android.database.CursorWindow: long getLong(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return getLong_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetLong(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns a long for the given field.
 * row is 0 based
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a long value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a <code>long</code>.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>0L</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the value obtained by parsing the string value with <code>strtoll</code>.
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is the <code>long</code> value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is the floating-point value converted to a <code>long</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a <code>long</code>.
 */
",1,,,0,,,,,,,5,0,"The method name called within the try block has changed from `getLong_native(int, int)` to `nativeGetLong(long, int, int)`, which indicates a change in the dependent API, so the code change type is 5.","Despite the change in the dependent method name and its parameters, there is no indication that the behavior of the method `getLong(int, int)` will be affected in a way that it will return a different result or throw a different exception. Thus, there is no Compatibility Issue."
892,<android.database.sqlite.SQLiteCursor: void finalize()>,13,14,,,,"{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (Config.LOGV) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}","{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                int len = mQuery.mSql.length();
                StrictMode.onSqliteObjectLeaked(""Finalizing a Cursor that has not been deactivated or closed. "" + ""database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
            SQLiteDebug.notifyActiveCursorFinalized();
        } else {
            if (false) {
                Log.v(TAG, ""Finalizing cursor on database = "" + mQuery.mDatabase.getPath() + "", table = "" + mEditTable + "", query = "" + mQuery.mSql);
            }
        }
    } finally {
        super.finalize();
    }
}",1,"/**
 * Release the native resources, if they haven't been released yet.
 */
","/**
 * Release the native resources, if they haven't been released yet.
 */
",0,[@Override],[@Override],0,,,,,,,4,0,The only change between the early and late versions is the condition for logging from `if (Config.LOGV)` to `if (false)`. This is an other statement changed and the change type is 4.,"This change does not affect the return value or the exception being thrown, hence there is no Compatibility Issue; the CI type is 0."
895,<android.app.Dialog: boolean onSearchRequested()>,13,14,,,,"{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // associate search with owner activity
    final ComponentName appName = getAssociatedActivity();
    if (appName != null) {
        searchManager.startSearch(null, false, appName, null, false);
        dismiss();
        return true;
    } else {
        return false;
    }
}","{
    final SearchManager searchManager = (SearchManager) mContext.getSystemService(Context.SEARCH_SERVICE);
    // associate search with owner activity
    final ComponentName appName = getAssociatedActivity();
    if (appName != null && searchManager.getSearchableInfo(appName) != null) {
        searchManager.startSearch(null, false, appName, null, false);
        dismiss();
        return true;
    } else {
        return false;
    }
}",1,"/**
 * This hook is called when the user signals the desire to start a search.
 */
","/**
 * This hook is called when the user signals the desire to start a search.
 */
",0,,,0,,,,,,,3,1,"There is a change in the condition of an if statement (additional condition: searchManager.getSearchableInfo(appName) != null), so the code change type is 3.","This control dependency change in the if statement condition can potentially lead to a different return value. In the early version, as long as appName is not null, the method will return true. However, in the late version, it will only return true if both appName is not null and searchManager.getSearchableInfo(appName) is also not null. This introduces a potential Compatibility Issue due to a potential different return value, and the CI type is 1."
896,<android.view.View: void setBackgroundDrawable(Drawable)>,13,14,,,,"{
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBGDrawable != null) {
        mBGDrawable.setCallback(null);
        unscheduleDrawable(mBGDrawable);
    }
    if (d != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        if (d.getPadding(padding)) {
            setPadding(padding.left, padding.top, padding.right, padding.bottom);
        }
        // if it has a different minimum size, we should layout again
        if (mBGDrawable == null || mBGDrawable.getMinimumHeight() != d.getMinimumHeight() || mBGDrawable.getMinimumWidth() != d.getMinimumWidth()) {
            requestLayout = true;
        }
        d.setCallback(this);
        if (d.isStateful()) {
            d.setState(getDrawableState());
        }
        d.setVisible(getVisibility() == VISIBLE, false);
        mBGDrawable = d;
        if ((mPrivateFlags & SKIP_DRAW) != 0) {
            mPrivateFlags &= ~SKIP_DRAW;
            mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBGDrawable = null;
        if ((mPrivateFlags & ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    if (d == mBGDrawable) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBGDrawable != null) {
        mBGDrawable.setCallback(null);
        unscheduleDrawable(mBGDrawable);
    }
    if (d != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        if (d.getPadding(padding)) {
            switch(d.getResolvedLayoutDirectionSelf()) {
                case LAYOUT_DIRECTION_RTL:
                    setPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    setPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBGDrawable == null || mBGDrawable.getMinimumHeight() != d.getMinimumHeight() || mBGDrawable.getMinimumWidth() != d.getMinimumWidth()) {
            requestLayout = true;
        }
        d.setCallback(this);
        if (d.isStateful()) {
            d.setState(getDrawableState());
        }
        d.setVisible(getVisibility() == VISIBLE, false);
        mBGDrawable = d;
        if ((mPrivateFlags & SKIP_DRAW) != 0) {
            mPrivateFlags &= ~SKIP_DRAW;
            mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBGDrawable = null;
        if ((mPrivateFlags & ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * Set the background to a given Drawable, or remove the background. If the
 * background has padding, this View's padding is set to the background's
 * padding. However, when a background is removed, this View's padding isn't
 * touched. If setting the padding is desired, please use
 * {@link #setPadding(int, int, int, int)}.
 *
 * @param d The Drawable to use as the background, or null to remove the
 * background
 */
","/**
 * Set the background to a given Drawable, or remove the background. If the
 * background has padding, this View's padding is set to the background's
 * padding. However, when a background is removed, this View's padding isn't
 * touched. If setting the padding is desired, please use
 * {@link #setPadding(int, int, int, int)}.
 *
 * @param d The Drawable to use as the background, or null to remove the
 * background
 */
",0,,,0,,,,,,,,,,
897,<android.inputmethodservice.KeyboardView: boolean onLongPress(Key)>,13,14,,,,"{
    int popupKeyboardId = popupKey.popupResId;
    if (popupKeyboardId != 0) {
        mMiniKeyboardContainer = mMiniKeyboardCache.get(popupKey);
        if (mMiniKeyboardContainer == null) {
            LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            mMiniKeyboardContainer = inflater.inflate(mPopupLayout, null);
            mMiniKeyboard = (KeyboardView) mMiniKeyboardContainer.findViewById(com.android.internal.R.id.keyboardView);
            View closeButton = mMiniKeyboardContainer.findViewById(com.android.internal.R.id.closeButton);
            if (closeButton != null)
                closeButton.setOnClickListener(this);
            mMiniKeyboard.setOnKeyboardActionListener(new OnKeyboardActionListener() {

                public void onKey(int primaryCode, int[] keyCodes) {
                    mKeyboardActionListener.onKey(primaryCode, keyCodes);
                    dismissPopupKeyboard();
                }

                public void onText(CharSequence text) {
                    mKeyboardActionListener.onText(text);
                    dismissPopupKeyboard();
                }

                public void swipeLeft() {
                }

                public void swipeRight() {
                }

                public void swipeUp() {
                }

                public void swipeDown() {
                }

                public void onPress(int primaryCode) {
                    mKeyboardActionListener.onPress(primaryCode);
                }

                public void onRelease(int primaryCode) {
                    mKeyboardActionListener.onRelease(primaryCode);
                }
            });
            // mInputView.setSuggest(mSuggest);
            Keyboard keyboard;
            if (popupKey.popupCharacters != null) {
                keyboard = new Keyboard(getContext(), popupKeyboardId, popupKey.popupCharacters, -1, getPaddingLeft() + getPaddingRight());
            } else {
                keyboard = new Keyboard(getContext(), popupKeyboardId);
            }
            mMiniKeyboard.setKeyboard(keyboard);
            mMiniKeyboard.setPopupParent(this);
            mMiniKeyboardContainer.measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.AT_MOST));
            mMiniKeyboardCache.put(popupKey, mMiniKeyboardContainer);
        } else {
            mMiniKeyboard = (KeyboardView) mMiniKeyboardContainer.findViewById(com.android.internal.R.id.keyboardView);
        }
        if (mWindowOffset == null) {
            mWindowOffset = new int[2];
            getLocationInWindow(mWindowOffset);
        }
        mPopupX = popupKey.x + mPaddingLeft;
        mPopupY = popupKey.y + mPaddingTop;
        mPopupX = mPopupX + popupKey.width - mMiniKeyboardContainer.getMeasuredWidth();
        mPopupY = mPopupY - mMiniKeyboardContainer.getMeasuredHeight();
        final int x = mPopupX + mMiniKeyboardContainer.getPaddingRight() + mWindowOffset[0];
        final int y = mPopupY + mMiniKeyboardContainer.getPaddingBottom() + mWindowOffset[1];
        mMiniKeyboard.setPopupOffset(x < 0 ? 0 : x, y);
        mMiniKeyboard.setShifted(isShifted());
        mPopupKeyboard.setContentView(mMiniKeyboardContainer);
        mPopupKeyboard.setWidth(mMiniKeyboardContainer.getMeasuredWidth());
        mPopupKeyboard.setHeight(mMiniKeyboardContainer.getMeasuredHeight());
        mPopupKeyboard.showAtLocation(this, Gravity.NO_GRAVITY, x, y);
        mMiniKeyboardOnScreen = true;
        // mMiniKeyboard.onTouchEvent(getTranslatedEvent(me));
        invalidateAllKeys();
        return true;
    }
    return false;
}","{
    int popupKeyboardId = popupKey.popupResId;
    if (popupKeyboardId != 0) {
        mMiniKeyboardContainer = mMiniKeyboardCache.get(popupKey);
        if (mMiniKeyboardContainer == null) {
            LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            mMiniKeyboardContainer = inflater.inflate(mPopupLayout, null);
            mMiniKeyboard = (KeyboardView) mMiniKeyboardContainer.findViewById(com.android.internal.R.id.keyboardView);
            View closeButton = mMiniKeyboardContainer.findViewById(com.android.internal.R.id.closeButton);
            if (closeButton != null)
                closeButton.setOnClickListener(this);
            mMiniKeyboard.setOnKeyboardActionListener(new OnKeyboardActionListener() {

                public void onKey(int primaryCode, int[] keyCodes) {
                    mKeyboardActionListener.onKey(primaryCode, keyCodes);
                    dismissPopupKeyboard();
                }

                public void onText(CharSequence text) {
                    mKeyboardActionListener.onText(text);
                    dismissPopupKeyboard();
                }

                public void swipeLeft() {
                }

                public void swipeRight() {
                }

                public void swipeUp() {
                }

                public void swipeDown() {
                }

                public void onPress(int primaryCode) {
                    mKeyboardActionListener.onPress(primaryCode);
                }

                public void onRelease(int primaryCode) {
                    mKeyboardActionListener.onRelease(primaryCode);
                }
            });
            // mInputView.setSuggest(mSuggest);
            Keyboard keyboard;
            if (popupKey.popupCharacters != null) {
                keyboard = new Keyboard(getContext(), popupKeyboardId, popupKey.popupCharacters, -1, getPaddingLeft() + getPaddingRight());
            } else {
                keyboard = new Keyboard(getContext(), popupKeyboardId);
            }
            mMiniKeyboard.setKeyboard(keyboard);
            mMiniKeyboard.setPopupParent(this);
            mMiniKeyboardContainer.measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.AT_MOST));
            mMiniKeyboardCache.put(popupKey, mMiniKeyboardContainer);
        } else {
            mMiniKeyboard = (KeyboardView) mMiniKeyboardContainer.findViewById(com.android.internal.R.id.keyboardView);
        }
        getLocationInWindow(mCoordinates);
        mPopupX = popupKey.x + mPaddingLeft;
        mPopupY = popupKey.y + mPaddingTop;
        mPopupX = mPopupX + popupKey.width - mMiniKeyboardContainer.getMeasuredWidth();
        mPopupY = mPopupY - mMiniKeyboardContainer.getMeasuredHeight();
        final int x = mPopupX + mMiniKeyboardContainer.getPaddingRight() + mCoordinates[0];
        final int y = mPopupY + mMiniKeyboardContainer.getPaddingBottom() + mCoordinates[1];
        mMiniKeyboard.setPopupOffset(x < 0 ? 0 : x, y);
        mMiniKeyboard.setShifted(isShifted());
        mPopupKeyboard.setContentView(mMiniKeyboardContainer);
        mPopupKeyboard.setWidth(mMiniKeyboardContainer.getMeasuredWidth());
        mPopupKeyboard.setHeight(mMiniKeyboardContainer.getMeasuredHeight());
        mPopupKeyboard.showAtLocation(this, Gravity.NO_GRAVITY, x, y);
        mMiniKeyboardOnScreen = true;
        // mMiniKeyboard.onTouchEvent(getTranslatedEvent(me));
        invalidateAllKeys();
        return true;
    }
    return false;
}",1,"/**
 * Called when a key is long pressed. By default this will open any popup keyboard associated
 * with this key through the attributes popupLayout and popupCharacters.
 * @param popupKey the key that was long pressed
 * @return true if the long press is handled, false otherwise. Subclasses should call the
 * method on the base class if the subclass doesn't wish to handle the call.
 */
","/**
 * Called when a key is long pressed. By default this will open any popup keyboard associated
 * with this key through the attributes popupLayout and popupCharacters.
 * @param popupKey the key that was long pressed
 * @return true if the long press is handled, false otherwise. Subclasses should call the
 * method on the base class if the subclass doesn't wish to handle the call.
 */
",0,,,0,,,,,,,,,,
898,<android.widget.PopupWindow: void setContentView(View)>,13,14,,,,"{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
}","{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
}",1,"/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */
","/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */
",0,,,0,,,,,,,3,0,"The control dependencies have changed with the addition of '&& mContentView != null' checks to the context and window manager initialization blocks, so the change type is 3.",There is no Compatibility Issue as the new condition 'mContentView != null' is strengthening the conditions under which 'mContext' and 'mWindowManager' are initialized. This won't lead to different return values or types or different exceptions being thrown since the method's return type is void and the method isn't designed to throw an exception.
901,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,float,float,float,float,int,float,float,int,int)>",13,14,,,,"{
    synchronized (gTmpPointerCoords) {
        final PointerCoords pc = gTmpPointerCoords[0];
        pc.clear();
        pc.x = x;
        pc.y = y;
        pc.pressure = pressure;
        pc.size = size;
        MotionEvent ev = obtain();
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, deviceId, InputDevice.SOURCE_UNKNOWN, action, 0, edgeFlags, metaState, 0, 0, xPrecision, yPrecision, downTime * NS_PER_MS, eventTime * NS_PER_MS, 1, gTmpPointerIds, gTmpPointerCoords);
        return ev;
    }
}","{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        ensureSharedTempPointerCapacity(1);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        pp[0].clear();
        pp[0].id = 0;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        pc[0].clear();
        pc[0].x = x;
        pc[0].y = y;
        pc[0].pressure = pressure;
        pc[0].size = size;
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, deviceId, InputDevice.SOURCE_UNKNOWN, action, 0, edgeFlags, metaState, 0, 0, 0, xPrecision, yPrecision, downTime * NS_PER_MS, eventTime * NS_PER_MS, 1, pp, pc);
        return ev;
    }
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime  The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param x The X coordinate of this event.
 * @param y The Y coordinate of this event.
 * @param pressure The current pressure of this event.  The pressure generally
 * ranges from 0 (no pressure at all) to 1 (normal pressure), however
 * values higher than 1 may be generated depending on the calibration of
 * the input device.
 * @param size A scaled value of the approximate size of the area being pressed when
 * touched with the finger. The actual value in pixels corresponding to the finger
 * touch is normalized with a device specific range of values
 * and scaled to a value between 0 and 1.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 */
",0,,,0,,,,,,,"1,3,4,5",1,Several changes occurred between the two versions: ,"3) The way `PointerProperties` and `PointerCoords` are being initialized has changed, including different variables and arrays being used."
902,<android.database.CursorWindow: void freeLastRow()>,13,14,,,,"{
    acquireReference();
    try {
        freeLastRow_native();
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        nativeFreeLastRow(mWindowPtr);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Free the last row
 */
","/**
 * Frees the last row in this cursor window.
 */
",1,,,0,,,,,,,"4,5",0,"The method call within the try block has changed from freeLastRow_native() to nativeFreeLastRow(mWindowPtr), indicating a change to a dependent API, which makes the code change type 4 and 5.","There is no Compatibility Issue detected as the try-finally block ensures that the behavior remains consistent with acquiring and releasing a reference, and the method's signature has not changed, nor has its return type (void does not change), and it does not throw any new or different exceptions."
903,"<android.accounts.AbstractAccountAuthenticator.Transport: void editProperties(IAccountAuthenticatorResponse,String)>",13,14,,,,"{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.editProperties(new AccountAuthenticatorResponse(response), accountType);
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""editProperties not supported"");
    }
}","{
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.editProperties(new AccountAuthenticatorResponse(response), accountType);
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""editProperties"", accountType, e);
    }
}",1,,,0,,,0,,,,,,,"2,4",2,"The change occurred in the exception handling statement where the specific exception catch block for UnsupportedOperationException has been replaced by a general Exception catch block, and there is a change in method called within the catch block, from calling `response.onError(...)` to `handleException(...)`. The code change type is 2 and 4.","Since the general Exception catch block can catch more exceptions than the previous specific UnsupportedOperationException catch block, and there's a change in the method handling the exception, the behavior of the API could potentially throw different exceptions or handle exceptions differently, leading to different results. The CI type is 2."
904,<android.widget.NumberPicker: boolean onTouchEvent(MotionEvent)>,13,14,,,,"{
    if (!isEnabled()) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    int action = ev.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = ev.getY();
            if (mBeginEditOnUpEvent || mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                if (deltaDownY > mTouchSlop) {
                    mBeginEditOnUpEvent = false;
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                }
            }
            int deltaMoveY = (int) (currentMoveY - mLastMotionEventY);
            scrollBy(0, deltaMoveY);
            invalidate();
            mLastMotionEventY = currentMoveY;
            break;
        case MotionEvent.ACTION_UP:
            if (mBeginEditOnUpEvent) {
                setDrawSelectorWheel(false);
                showInputControls(mShowInputControlsAnimimationDuration);
                mInputText.requestFocus();
                InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.showSoftInput(mInputText, 0);
                mInputText.setSelection(0, mInputText.getText().length());
                return true;
            }
            VelocityTracker velocityTracker = mVelocityTracker;
            velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            int initialVelocity = (int) velocityTracker.getYVelocity();
            if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                fling(initialVelocity);
                onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
            } else {
                if (mAdjustScrollerOnUpEvent) {
                    if (mFlingScroller.isFinished() && mAdjustScroller.isFinished()) {
                        postAdjustScrollerCommand(0);
                    }
                } else {
                    postAdjustScrollerCommand(SHOW_INPUT_CONTROLS_DELAY_MILLIS);
                }
            }
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            break;
    }
    return true;
}","{
    if (!isEnabled()) {
        return false;
    }
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    int action = ev.getActionMasked();
    switch(action) {
        case MotionEvent.ACTION_MOVE:
            float currentMoveY = ev.getY();
            if (mBeginEditOnUpEvent || mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
                if (deltaDownY > mTouchSlop) {
                    mBeginEditOnUpEvent = false;
                    onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                }
            }
            int deltaMoveY = (int) (currentMoveY - mLastMotionEventY);
            scrollBy(0, deltaMoveY);
            invalidate();
            mLastMotionEventY = currentMoveY;
            break;
        case MotionEvent.ACTION_UP:
            if (mBeginEditOnUpEvent) {
                setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL);
                showInputControls(mShowInputControlsAnimimationDuration);
                mInputText.requestFocus();
                return true;
            }
            VelocityTracker velocityTracker = mVelocityTracker;
            velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            int initialVelocity = (int) velocityTracker.getYVelocity();
            if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
                fling(initialVelocity);
                onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
            } else {
                if (mAdjustScrollerOnUpEvent) {
                    if (mFlingScroller.isFinished() && mAdjustScroller.isFinished()) {
                        postAdjustScrollerCommand(0);
                    }
                } else {
                    postAdjustScrollerCommand(SHOW_INPUT_CONTROLS_DELAY_MILLIS);
                }
            }
            mVelocityTracker.recycle();
            mVelocityTracker = null;
            break;
    }
    return true;
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3,4",1,"The change includes the deletion of setDrawSelectorWheel(false) and the InputMethodManager related code, addition of setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL), and modification of the way input controls are shown. Therefore, the code change types are 1 for the deleted and added statements that change the return behavior of the method, 3 for the change inside the conditional block, and 4 for the change in the method calls.","The deletion of input method manager calls and the change in the state setting (from `setDrawSelectorWheel(false)` to `setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL)`) indicate that there are different behaviors in terms of UI state and input method handling, leading to a potential difference in return values or types. Consequently, the CI type is 1."
905,"<android.app.PendingIntent: PendingIntent getService(Context,int,Intent,int)>",13,14,,,,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_SERVICE, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a service, like calling
 * {@link Context#startService Context.startService()}.  The start
 * arguments given to the service will come from the extras of the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the service.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent An Intent describing the service to be started.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",0,,,0,,,,,,,4,0,"The statement `intent.setAllowFds(false);` prior to using `intent` to get the IIntentSender indicates the only change made. This additional statement modifies the `intent`'s behavior, which is a change not directly related to return statements, exception handling statements, or control flow. Therefore the code change type is 4.","While the statement added in the late version modifies the state of the `intent`, it does not alter the method signature, return type, or exception thrown, and it will not cause a different return value under the given circumstances since it's just setting an attribute of the Intent object. The intent object is not used to determine the output of the method before this statement is executed, and eventual failure or success in setting this attribute would not change the flow of the method. Consequently, there is no compatibility issue regarding different return values or types, nor is there a difference in exception throwing behavior. Hence, the CI type is 0."
906,"<android.widget.SearchView: void onMeasure(int,int)>",13,14,,,,"{
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    if ((widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.EXACTLY) && mMaxWidth > 0 && width > mMaxWidth) {
        super.onMeasure(MeasureSpec.makeMeasureSpec(mMaxWidth, widthMode), heightMeasureSpec);
    } else {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}","{
    // Let the standard measurements take effect in iconified state.
    if (isIconified()) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        return;
    }
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int width = MeasureSpec.getSize(widthMeasureSpec);
    switch(widthMode) {
        case MeasureSpec.AT_MOST:
            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            } else {
                width = Math.min(getPreferredWidth(), width);
            }
            break;
        case MeasureSpec.EXACTLY:
            // If an exact width is specified, still don't exceed any specified maximum width
            if (mMaxWidth > 0) {
                width = Math.min(mMaxWidth, width);
            }
            break;
        case MeasureSpec.UNSPECIFIED:
            // Use maximum width, if specified, else preferred width
            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
            break;
    }
    widthMode = MeasureSpec.EXACTLY;
    super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), heightMeasureSpec);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"The code change includes the addition of an 'if' control statement for `isIconified()` check and a modification in the rest of the method, changing from 'if' conditions to a 'switch' block for handling different `widthMode` cases, so the change types are 1,3.","Because a new control flow is introduced to check if the view is iconified which could directly affect the layout measurement result, as well as changes in how different widthModes are handled (with potentially different width values being calculated), there is a possibility that the method will return a different value, hence a CI type 1."
907,<android.widget.RemoteViewsService.RemoteViewsFactoryAdapter: RemoteViews getViewAt(int)>,13,14,,,,"{
    RemoteViews rv = mFactory.getViewAt(position);
    rv.setIsWidgetCollectionChild(true);
    return rv;
}","{
    RemoteViews rv = null;
    try {
        rv = mFactory.getViewAt(position);
        if (rv != null) {
            rv.setIsWidgetCollectionChild(true);
        }
    } catch (Exception ex) {
        Thread t = Thread.currentThread();
        Thread.getDefaultUncaughtExceptionHandler().uncaughtException(t, ex);
    }
    return rv;
}",1,,,0,,,0,,,,,,,"2,3","1,2","The late implementation introduces a try-catch block, modifies the null check for the RemoteViews object, and adds an exception handling mechanism. The set of changes includes the introduction of a new exception handling statement and control dependency changes, so the change type is 2,3.","The late version could now potentially catch exceptions that were not caught in the early version and handle them differently (by passing them to the uncaught exception handler of the current thread), affecting the normal flow of the method. Additionally, the late version will return null if an exception occurs or if the mViewFactory returns null, which is a different behavior compared to the early version where an exception would have caused a crash and a non-null RemoteViews object would always have setIsWidgetCollectionChild(true) called on it before being returned. Therefore, the code change potentially leads to different return values or types and different exception handlings, and the CI type is 1,2."
908,<android.server.BluetoothService: boolean isDiscovering()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mIsDiscovering;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    String discoveringProperty = getProperty(""Discovering"", false);
    if (discoveringProperty == null) {
        return false;
    }
    return discoveringProperty.equals(""true"");
}",1,,,0,,,0,,,,,,,"1,4,5",1,"The API changed the way it determines whether the system is discovering. It no longer returns the value of `mIsDiscovering` directly; instead, it obtains a property value and checks it, which adds a new return statement and also changes the method of determining if discovery is in progress. This is a dependent API change as it now relies on the `getProperty` method, which didn't appear in the early version. Therefore, the code change type is 1,4,5.","As the logic to determine the return value is fundamentally changed, where earlier it was returning the value of a variable, now it is interpreting a string property which could return a different value than previous, the CI type is 1."
909,"<android.database.CursorWindow: boolean isNull(int,int)>",13,14,,,,"{
    return getType(row, col) == Cursor.FIELD_TYPE_NULL;
}","{
    return getType(row, column) == Cursor.FIELD_TYPE_NULL;
}",1,"/**
 * Returns {@code true} if given field is {@code NULL}.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return {@code true} if given field is {@code NULL}
 * @deprecated use {@link #getType(int, int)} instead
 */
","/**
 * Returns true if the field at the specified row and column index
 * has type {@link Cursor#FIELD_TYPE_NULL}.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if the field has type {@link Cursor#FIELD_TYPE_NULL}.
 * @deprecated Use {@link #getType(int, int)} instead.
 */
",1,[@Deprecated],[@Deprecated],0,,,,,,,0,0,"The implementation is identical in both versions, with the only noticeable difference being the renaming of a variable from 'col' to 'column'. However, this is an internal variable change and does not affect the method's external behavior.","There are no compatibility issues identified, since the method's behavior remains consistent between the two versions."
910,"<android.app.Activity: PendingIntent createPendingResult(int,Intent,int)>",13,14,,,,"{
    String packageName = getPackageName();
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}","{
    String packageName = getPackageName();
    try {
        data.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}",1,"/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
","/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */
",0,,,0,,,,,,,4,0,"The code change consists of invoking a new method call (data.setAllowFds(false)) before getting the intent sender. Therefore, the code change type is 4.","The addition of data.setAllowFds(false) does not affect the method's return value nor does it introduce new exception handling. It merely changes a property of the 'data' Intent object before using it, which should not lead to different behavior from a caller's perspective regarding return values or exceptions thrown by the method. As such, there is no compatibility issue, hence CI type is 0."
911,"<android.webkit.WebView: boolean onKeyMultiple(int,int,KeyEvent)>",13,14,,,,"{
    // send complex characters to webkit for use by JS and plugins
    if (keyCode == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    return false;
}","{
    if (mBlockWebkitViewMessages) {
        return false;
    }
    // send complex characters to webkit for use by JS and plugins
    if (keyCode == KeyEvent.KEYCODE_UNKNOWN && event.getCharacters() != null) {
        // pass the key to DOM
        mWebViewCore.sendMessage(EventHub.KEY_DOWN, event);
        mWebViewCore.sendMessage(EventHub.KEY_UP, event);
        // return true as DOM handles the key
        return true;
    }
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The change includes the addition of a new control dependency with the condition `mBlockWebkitViewMessages`. If this new condition is true, the late version will return false immediately, which alters the flow of the method. Therefore, the code change type is 3.","The addition of the new `if` statement and early return based on `mBlockWebkitViewMessages` means that in some cases where the early version would proceed to send messages to `mWebViewCore`, the late version will not, returning false instead. This change could cause the method to return a different value than before, thus the CI type is 1."
912,"<android.text.TextUtils: CharSequence ellipsize(CharSequence,TextPaint,float,TruncateAt,boolean,EllipsizeCallback)>",13,14,,,,"{
    if (sEllipsis == null) {
        Resources r = Resources.getSystem();
        sEllipsis = r.getString(R.string.ellipsis);
    }
    int len = text.length();
    MeasuredText mt = MeasuredText.obtain();
    try {
        float width = setPara(mt, paint, text, 0, text.length(), Layout.DIR_REQUEST_DEFAULT_LTR);
        if (width <= avail) {
            if (callback != null) {
                callback.ellipsized(0, 0);
            }
            return text;
        }
        // XXX assumes ellipsis string does not require shaping and
        // is unaffected by style
        float ellipsiswid = paint.measureText(sEllipsis);
        avail -= ellipsiswid;
        int left = 0;
        int right = len;
        if (avail < 0) {
        // it all goes
        } else if (where == TruncateAt.START) {
            right = len - mt.breakText(0, len, false, avail);
        } else if (where == TruncateAt.END) {
            left = mt.breakText(0, len, true, avail);
        } else {
            right = len - mt.breakText(0, len, false, avail / 2);
            avail -= mt.measure(right, len);
            left = mt.breakText(0, right, true, avail);
        }
        if (callback != null) {
            callback.ellipsized(left, right);
        }
        char[] buf = mt.mChars;
        Spanned sp = text instanceof Spanned ? (Spanned) text : null;
        int remaining = len - (right - left);
        if (preserveLength) {
            if (remaining > 0) {
                // else eliminate the ellipsis too
                buf[left++] = '\u2026';
            }
            for (int i = left; i < right; i++) {
                buf[i] = '\uFEFF';
            }
            String s = new String(buf, 0, len);
            if (sp == null) {
                return s;
            }
            SpannableString ss = new SpannableString(s);
            copySpansFrom(sp, 0, len, Object.class, ss, 0);
            return ss;
        }
        if (remaining == 0) {
            return """";
        }
        if (sp == null) {
            StringBuilder sb = new StringBuilder(remaining + sEllipsis.length());
            sb.append(buf, 0, left);
            sb.append(sEllipsis);
            sb.append(buf, right, len - right);
            return sb.toString();
        }
        SpannableStringBuilder ssb = new SpannableStringBuilder();
        ssb.append(text, 0, left);
        ssb.append(sEllipsis);
        ssb.append(text, right, len);
        return ssb;
    } finally {
        MeasuredText.recycle(mt);
    }
}","{
    return ellipsize(text, paint, avail, where, preserveLength, callback, TextDirectionHeuristics.FIRSTSTRONG_LTR, (where == TruncateAt.END_SMALL) ? ELLIPSIS_TWO_DOTS : ELLIPSIS_NORMAL);
}",1,"/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.
 */
","/**
 * Returns the original text if it fits in the specified width
 * given the properties of the specified Paint,
 * or, if it does not fit, a copy with ellipsis character added
 * at the specified edge or center.
 * If <code>preserveLength</code> is specified, the returned copy
 * will be padded with zero-width spaces to preserve the original
 * length and offsets instead of truncating.
 * If <code>callback</code> is non-null, it will be called to
 * report the start and end of the ellipsized range.  TextDirection
 * is determined by the first strong directional character.
 */
",1,,,0,,,,,,,"1,4,5",1,"The method's implementation has been completely overhauled to call a different method with a different set of parameters. This results in changes to the return statement, other statements, and relies on a different dependent API. Therefore, the change types are 1, 4, and 5.","With the complete change in the implementation logic and reliance on different utility methods and heuristics, there is a potential for different return values. Thus, the CI type is 1."
913,<android.server.BluetoothService: int getBluetoothState()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothState;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return getBluetoothStateInternal();
}",1,,,0,,,0,,,,,,,5,1,"The return statement has changed from directly returning mBluetoothState to returning the result of getBluetoothStateInternal(). This indicates that there has been a change in the dependent API, as the late version is relying on an internal method getBluetoothStateInternal() to obtain the Bluetooth state. Hence, the code change type is 5.","Since the API now depends on an internal method getBluetoothStateInternal() whose implementation is not shown in the given information, there is a potential that the returned value of the late version might differ from the early version. Therefore, the change could potentially cause a different value to be returned, and the CI type is 1."
914,<android.webkit.WebView: HitTestResult getHitTestResult()>,13,14,,,,"{
    return hitTestResult(mInitialHitTestResult);
}","{
    checkThread();
    return hitTestResult(mInitialHitTestResult);
}",1,"/**
 * Return a HitTestResult based on the current cursor node. If a HTML::a tag
 * is found and the anchor has a non-JavaScript url, the HitTestResult type
 * is set to SRC_ANCHOR_TYPE and the url is set in the ""extra"" field. If the
 * anchor does not have a url or if it is a JavaScript url, the type will
 * be UNKNOWN_TYPE and the url has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the url is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a url that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
","/**
 * Return a HitTestResult based on the current cursor node. If a HTML::a tag
 * is found and the anchor has a non-JavaScript url, the HitTestResult type
 * is set to SRC_ANCHOR_TYPE and the url is set in the ""extra"" field. If the
 * anchor does not have a url or if it is a JavaScript url, the type will
 * be UNKNOWN_TYPE and the url has to be retrieved through
 * {@link #requestFocusNodeHref} asynchronously. If a HTML::img tag is
 * found, the HitTestResult type is set to IMAGE_TYPE and the url is set in
 * the ""extra"" field. A type of
 * SRC_IMAGE_ANCHOR_TYPE indicates an anchor with a url that has an image as
 * a child node. If a phone number is found, the HitTestResult type is set
 * to PHONE_TYPE and the phone number is set in the ""extra"" field of
 * HitTestResult. If a map address is found, the HitTestResult type is set
 * to GEO_TYPE and the address is set in the ""extra"" field of HitTestResult.
 * If an email address is found, the HitTestResult type is set to EMAIL_TYPE
 * and the email is set in the ""extra"" field of HitTestResult. Otherwise,
 * HitTestResult type is set to UNKNOWN_TYPE.
 */
",0,,,0,,,,,,,4,0,"The new method call checkThread() is introduced in the late version before the return statement, which doesn't change the return variable, so the code change type is 4.","The additional checkThread() function seems to be a thread-safety check and doesn't alter the value returned by the function, nor does it introduce a new exception handling path, therefore there shouldn't be any Compatibility Issue. The CI situation is 0."
915,<android.server.BluetoothPanProfileHandler: boolean disconnectPanDevice(BluetoothDevice)>,13,14,,,,"{
    String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    debugLog(""disconnect PAN("" + objectPath + "")"");
    int state = getPanDeviceConnectionState(device);
    if (state != BluetoothPan.STATE_CONNECTED) {
        debugLog(device + "" already disconnected from PAN"");
        return false;
    }
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        errorLog(""No record for this Pan device:"" + device);
        return false;
    }
    handlePanDeviceStateChange(device, BluetoothPan.STATE_DISCONNECTING, panDevice.mLocalRole);
    if (panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
        if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath, device.getAddress(), panDevice.mIface)) {
            // Restore prev state, this shouldn't happen
            handlePanDeviceStateChange(device, state, panDevice.mLocalRole);
            return false;
        }
    } else {
        if (!mBluetoothService.disconnectPanDeviceNative(objectPath)) {
            // Restore prev state, this shouldn't happen
            handlePanDeviceStateChange(device, state, panDevice.mLocalRole);
            return false;
        }
    }
    return true;
}","{
    String objectPath = mBluetoothService.getObjectPathFromAddress(device.getAddress());
    debugLog(""disconnect PAN("" + objectPath + "")"");
    int state = getPanDeviceConnectionState(device);
    if (state != BluetoothPan.STATE_CONNECTED) {
        debugLog(device + "" already disconnected from PAN"");
        return false;
    }
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        errorLog(""No record for this Pan device:"" + device);
        return false;
    }
    handlePanDeviceStateChange(device, panDevice.mIface, BluetoothPan.STATE_DISCONNECTING, panDevice.mLocalRole);
    if (panDevice.mLocalRole == BluetoothPan.LOCAL_NAP_ROLE) {
        if (!mBluetoothService.disconnectPanServerDeviceNative(objectPath, device.getAddress(), panDevice.mIface)) {
            // Restore prev state, this shouldn't happen
            handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
            return false;
        }
    } else {
        if (!mBluetoothService.disconnectPanDeviceNative(objectPath)) {
            // Restore prev state, this shouldn't happen
            handlePanDeviceStateChange(device, panDevice.mIface, state, panDevice.mLocalRole);
            return false;
        }
    }
    return true;
}",1,,,0,,,0,,,,,,,"3,5",1,"The method handlePanDeviceStateChange has an added parameter (panDevice.mIface) and the order of parameters (state and panDevice.mIface) is also changed, so the change type is 3,5 due to control dependency and dependent API change.","The change in the parameter order or the addition of a new parameter can alter the behavior of the handlePanDeviceStateChange() method and hence the behavior of the method disconnectPanDevice which relies on it. This could lead to a different return value from the method, thus the CI type is 1."
917,<android.webkit.JniUtil: void setContext(Context)>,13,14,,,,"{
    if (initialized)
        return;
    sContext = context.getApplicationContext();
    initialized = true;
}","{
    if (sContext != null) {
        return;
    }
    sContext = context.getApplicationContext();
}",1,,,0,,,0,,,,,,,"3,4",0,"The control dependency has changed from checking `initialized` to checking if `sContext != null`. Also, the `initialized = true;` statement has been removed. This is a change of both control dependency and other statement (assignment statement removal), so the code change types are 3,4.","The change of the control dependency does not introduce a Compatibility Issue because the intent of the control flow remains the same: to prevent re-initialization after the first assignment has occurred. In both versions, it is ensured that `sContext` is set only once. The control flow change does not affect the API behavior from external observation (it either sets the context on the first call or does nothing on subsequent calls), and hence there is no CI. The removal of the `initialized = true;` statement does not introduce any functional difference since the check is now directly on `sContext`. As a result, the observable behavior remains unchanged, so there is no Compatibility Issue, CI type is 0."
919,<android.webkit.WebView.PrivateHandler: void handleMessage(Message)>,13,14,,,,"{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mScrollingLayer == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    mScrollingLayerRect.left += mAutoScrollX;
                    mScrollingLayerRect.top += mAutoScrollY;
                    nativeScrollLayer(mScrollingLayer, mScrollingLayerRect.left, mScrollingLayerRect.top);
                    invalidate();
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // set by updateSelection()
                mInitialHitTestResult = null;
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (getSettings().supportTouchOnly()) {
                    removeTouchHighlight(false);
                }
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mIds = new int[1];
                    ted.mIds[0] = 0;
                    ted.mPoints = new Point[1];
                    ted.mPoints[0] = new Point(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY));
                    ted.mPointsInView = new Point[1];
                    ted.mPointsInView[0] = new Point(mLastTouchX, mLastTouchY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    ted.mNativeLayer = nativeScrollableLayer(ted.mPoints[0].x, ted.mPoints[0].y, ted.mNativeLayerRect, null);
                    ted.mSequence = mTouchEventQueue.nextTouchSequence();
                    mTouchEventQueue.preQueueTouchEventData(ted);
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || (!imm.isActive(WebView.this) && (!inEditingMode() || !imm.isActive(mWebTextView)))) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                if (msg.arg1 == 1) {
                    spawnContentScrollTo(p.x, p.y);
                } else {
                    setContentScrollTo(p.x, p.y);
                }
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case REPLACE_BASE_CONTENT:
            {
                nativeReplaceBaseContent(msg.arg1);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                WebViewCore.ViewState viewState = draw.mViewState;
                boolean isPictureAfterFirstLayout = viewState != null;
                setBaseLayer(draw.mBaseLayer, draw.mInvalRegion, getSettings().getShowVisualIndicator(), isPictureAfterFirstLayout);
                final Point viewSize = draw.mViewSize;
                if (isPictureAfterFirstLayout) {
                    // Reset the last sent data here since dealing with new page.
                    mLastWidthSent = 0;
                    mZoomManager.onFirstLayout(draw);
                    if (!mDrawHistory) {
                        // Do not send the scroll event for this particular
                        // scroll message.  Note that a scroll event may
                        // still be fired if the user scrolls before the
                        // message can be handled.
                        mSendScrollEvent = false;
                        setContentScrollTo(viewState.mScrollX, viewState.mScrollY);
                        mSendScrollEvent = true;
                        // As we are on a new page, remove the WebTextView. This
                        // is necessary for page loads driven by webkit, and in
                        // particular when the user was on a password field, so
                        // the WebTextView was visible.
                        clearTextEntry();
                    }
                }
                // We update the layout (i.e. request a layout from the
                // view system) if the last view size that we sent to
                // WebCore matches the view size of the picture we just
                // received in the fixed dimension.
                final boolean updateLayout = viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
                // Don't send scroll event for picture coming from webkit,
                // since the new picture may cause a scroll event to override
                // the saved history scroll position.
                mSendScrollEvent = false;
                recordNewContentSize(draw.mContentSize.x, draw.mContentSize.y, updateLayout);
                mSendScrollEvent = true;
                if (DebugFlags.WEB_VIEW) {
                    Rect b = draw.mInvalRegion.getBounds();
                    Log.v(LOGTAG, ""NEW_PICTURE_MSG_ID {"" + b.left + "","" + b.top + "","" + b.right + "","" + b.bottom + ""}"");
                }
                invalidateContentRect(draw.mInvalRegion.getBounds());
                if (mPictureListener != null) {
                    mPictureListener.onNewPicture(WebView.this, capturePicture());
                }
                // update the zoom information based on the new picture
                mZoomManager.onNewPicture(draw);
                if (draw.mFocusSizeChanged && inEditingMode()) {
                    mFocusSizeChanged = true;
                }
                if (isPictureAfterFirstLayout) {
                    mViewManager.postReadyToDrawAll();
                }
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            nativeCreate(msg.arg1);
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.getData().getBoolean(""password"")) {
                    Spannable text = (Spannable) mWebTextView.getText();
                    int start = Selection.getSelectionStart(text);
                    int end = Selection.getSelectionEnd(text);
                    mWebTextView.setInPassword(true);
                    // Restore the selection, which may have been
                    // ruined by setInPassword.
                    Spannable pword = (Spannable) mWebTextView.getText();
                    Selection.setSelection(pword, start, end);
                // If the text entry has created more events, ignore
                // this one.
                } else if (msg.arg2 == mTextGeneration) {
                    String text = (String) msg.obj;
                    if (null == text) {
                        text = """";
                    }
                    mWebTextView.setTextAndKeepSelection(text);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
        // fall through to UPDATE_TEXT_SELECTION_MSG_ID
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case FORM_DID_BLUR:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                hideSoftKeyboard();
            }
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case UNHANDLED_NAV_KEY:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                rebuildWebTextView();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            TouchEventData ted = (TouchEventData) msg.obj;
            if (mTouchEventQueue.enqueueTouchEvent(ted)) {
                // WebCore is responding to us; remove pending timeout.
                // It will be re-posted when needed.
                removeMessages(PREVENT_DEFAULT_TIMEOUT);
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp && mFindCallback != null) {
                mFindCallback.findAll();
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SCREEN_ON:
            setKeepScreenOn(msg.arg1 == 1);
            break;
        case ENTER_FULLSCREEN_VIDEO:
            int layerId = msg.arg1;
            String url = (String) msg.obj;
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.enterFullScreenVideo(layerId, url);
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int npp = msg.arg1;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.setCancelable(false);
                mFullScreenHolder.setCanceledOnTouchOutside(false);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeight());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (mAccessibilityInjector != null) {
                String selectionString = (String) msg.obj;
                mAccessibilityInjector.onSelectionStringChange(selectionString);
            }
            break;
        case SET_TOUCH_HIGHLIGHT_RECTS:
            invalidate(mTouchHighlightRegion.getBounds());
            mTouchHighlightRegion.setEmpty();
            if (msg.obj != null) {
                ArrayList<Rect> rects = (ArrayList<Rect>) msg.obj;
                for (Rect rect : rects) {
                    Rect viewRect = contentToViewRect(rect);
                    // more than half of the screen.
                    if (viewRect.width() < getWidth() >> 1 || viewRect.height() < getHeight() >> 1) {
                        mTouchHighlightRegion.union(viewRect);
                        invalidate(viewRect);
                    } else {
                        Log.w(LOGTAG, ""Skip the huge selection rect:"" + viewRect);
                    }
                }
            }
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mWebTextView != null) {
                mWebTextView.setAutoFillable(mAutoFillData.getQueryId());
                rebuildWebTextView();
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mWebTextView != null) {
                // Clear the WebTextView adapter when AutoFill finishes
                // so that the drop down gets cleared.
                mWebTextView.setAdapterCustom(null);
            }
            break;
        case SELECT_AT:
            nativeSelectAt(msg.arg1, msg.arg2);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}","{
    // exclude INVAL_RECT_MSG_ID since it is frequently output
    if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
        if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
            Log.v(LOGTAG, HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
        } else if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
            Log.v(LOGTAG, HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
        } else {
            Log.v(LOGTAG, Integer.toString(msg.what));
        }
    }
    if (mWebViewCore == null) {
        // after WebView's destroy() is called, skip handling messages.
        return;
    }
    if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
        // Blocking messages from webkit
        return;
    }
    switch(msg.what) {
        case REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), msg.getData().getString(""username""), msg.getData().getString(""password""));
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case NEVER_REMEMBER_PASSWORD:
            {
                mDatabase.setUsernamePassword(msg.getData().getString(""host""), null, null);
                ((Message) msg.obj).sendToTarget();
                break;
            }
        case PREVENT_DEFAULT_TIMEOUT:
            {
                // to continue handling touch events
                if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
                    cancelWebCoreTouchEvent(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY), true);
                }
                break;
            }
        case SCROLL_SELECT_TEXT:
            {
                if (mAutoScrollX == 0 && mAutoScrollY == 0) {
                    mSentAutoScrollMessage = false;
                    break;
                }
                if (mScrollingLayer == 0) {
                    pinScrollBy(mAutoScrollX, mAutoScrollY, true, 0);
                } else {
                    mScrollingLayerRect.left += mAutoScrollX;
                    mScrollingLayerRect.top += mAutoScrollY;
                    nativeScrollLayer(mScrollingLayer, mScrollingLayerRect.left, mScrollingLayerRect.top);
                    invalidate();
                }
                sendEmptyMessageDelayed(SCROLL_SELECT_TEXT, SELECT_SCROLL_INTERVAL);
                break;
            }
        case UPDATE_SELECTION:
            {
                if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_SHORTPRESS_MODE || mTouchMode == TOUCH_SHORTPRESS_START_MODE) {
                    updateSelection();
                }
                break;
            }
        case SWITCH_TO_SHORTPRESS:
            {
                // set by updateSelection()
                mInitialHitTestResult = null;
                if (mTouchMode == TOUCH_INIT_MODE) {
                    if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
                        mTouchMode = TOUCH_SHORTPRESS_START_MODE;
                        updateSelection();
                    } else {
                        // set to TOUCH_SHORTPRESS_MODE so that it won't
                        // trigger double tap any more
                        mTouchMode = TOUCH_SHORTPRESS_MODE;
                    }
                } else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
                    mTouchMode = TOUCH_DONE_MODE;
                }
                break;
            }
        case SWITCH_TO_LONGPRESS:
            {
                if (USE_WEBKIT_RINGS || getSettings().supportTouchOnly()) {
                    removeTouchHighlight();
                }
                if (inFullScreenMode() || mDeferTouchProcess) {
                    TouchEventData ted = new TouchEventData();
                    ted.mAction = WebViewCore.ACTION_LONGPRESS;
                    ted.mIds = new int[1];
                    ted.mIds[0] = 0;
                    ted.mPoints = new Point[1];
                    ted.mPoints[0] = new Point(viewToContentX(mLastTouchX + mScrollX), viewToContentY(mLastTouchY + mScrollY));
                    ted.mPointsInView = new Point[1];
                    ted.mPointsInView[0] = new Point(mLastTouchX, mLastTouchY);
                    // metaState for long press is tricky. Should it be the
                    // state when the press started or when the press was
                    // released? Or some intermediary key state? For
                    // simplicity for now, we don't set it.
                    ted.mMetaState = 0;
                    ted.mReprocess = mDeferTouchProcess;
                    ted.mNativeLayer = nativeScrollableLayer(ted.mPoints[0].x, ted.mPoints[0].y, ted.mNativeLayerRect, null);
                    ted.mSequence = mTouchEventQueue.nextTouchSequence();
                    mTouchEventQueue.preQueueTouchEventData(ted);
                    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT, ted);
                } else if (mPreventDefault != PREVENT_DEFAULT_YES) {
                    mTouchMode = TOUCH_DONE_MODE;
                    performLongClick();
                }
                break;
            }
        case RELEASE_SINGLE_TAP:
            {
                doShortPress();
                break;
            }
        case SCROLL_TO_MSG_ID:
            {
                // obj = Point(x, y)
                if (msg.arg2 == 1) {
                    // This scroll is intended to bring the textfield into
                    // view, but is only necessary if the IME is showing
                    InputMethodManager imm = InputMethodManager.peekInstance();
                    if (imm == null || !imm.isAcceptingText() || (!imm.isActive(WebView.this) && (!inEditingMode() || !imm.isActive(mWebTextView)))) {
                        break;
                    }
                }
                final Point p = (Point) msg.obj;
                if (msg.arg1 == 1) {
                    spawnContentScrollTo(p.x, p.y);
                } else {
                    setContentScrollTo(p.x, p.y);
                }
                break;
            }
        case UPDATE_ZOOM_RANGE:
            {
                WebViewCore.ViewState viewState = (WebViewCore.ViewState) msg.obj;
                // mScrollX contains the new minPrefWidth
                mZoomManager.updateZoomRange(viewState, getViewWidth(), viewState.mScrollX);
                break;
            }
        case REPLACE_BASE_CONTENT:
            {
                nativeReplaceBaseContent(msg.arg1);
                break;
            }
        case NEW_PICTURE_MSG_ID:
            {
                // called for new content
                final WebViewCore.DrawData draw = (WebViewCore.DrawData) msg.obj;
                setNewPicture(draw, true);
                break;
            }
        case WEBCORE_INITIALIZED_MSG_ID:
            // nativeCreate sets mNativeClass to a non-zero value
            String drawableDir = BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR, mContext);
            nativeCreate(msg.arg1, drawableDir);
            if (mDelaySetPicture != null) {
                setNewPicture(mDelaySetPicture, true);
                mDelaySetPicture = null;
            }
            break;
        case UPDATE_TEXTFIELD_TEXT_MSG_ID:
            // and representing the same node as the pointer.
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                if (msg.arg2 == mTextGeneration) {
                    String text = (String) msg.obj;
                    if (null == text) {
                        text = """";
                    }
                    mWebTextView.setTextAndKeepSelection(text);
                }
            }
            break;
        case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
            displaySoftKeyboard(true);
        // fall through to UPDATE_TEXT_SELECTION_MSG_ID
        case UPDATE_TEXT_SELECTION_MSG_ID:
            updateTextSelectionFromMessage(msg.arg1, msg.arg2, (WebViewCore.TextSelectionData) msg.obj);
            break;
        case FORM_DID_BLUR:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                hideSoftKeyboard();
            }
            break;
        case RETURN_LABEL:
            if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setHint((String) msg.obj);
                InputMethodManager imm = InputMethodManager.peekInstance();
                // active, restart it so that its hint text is updated.
                if (imm != null && imm.isActive(mWebTextView)) {
                    imm.restartInput(mWebTextView);
                }
            }
            break;
        case UNHANDLED_NAV_KEY:
            navHandledKey(msg.arg1, 1, false, 0);
            break;
        case UPDATE_TEXT_ENTRY_MSG_ID:
            // sure the text edit box is still on the  screen.
            if (inEditingMode() && nativeCursorIsTextInput()) {
                updateWebTextViewPosition();
            }
            break;
        case CLEAR_TEXT_ENTRY:
            clearTextEntry();
            break;
        case INVAL_RECT_MSG_ID:
            {
                Rect r = (Rect) msg.obj;
                if (r == null) {
                    invalidate();
                } else {
                    // we need to scale r from content into view coords,
                    // which viewInvalidate() does for us
                    viewInvalidate(r.left, r.top, r.right, r.bottom);
                }
                break;
            }
        case REQUEST_FORM_DATA:
            AutoCompleteAdapter adapter = (AutoCompleteAdapter) msg.obj;
            if (mWebTextView.isSameTextField(msg.arg1)) {
                mWebTextView.setAdapterCustom(adapter);
            }
            break;
        case RESUME_WEBCORE_PRIORITY:
            WebViewCore.resumePriority();
            WebViewCore.resumeUpdatePicture(mWebViewCore);
            break;
        case LONG_PRESS_CENTER:
            // as this is shared by keydown and trackballdown, reset all
            // the states
            mGotCenterDown = false;
            mTrackballDown = false;
            performLongClick();
            break;
        case WEBCORE_NEED_TOUCH_EVENTS:
            mForwardTouchEvents = (msg.arg1 != 0);
            break;
        case PREVENT_TOUCH_ID:
            if (inFullScreenMode()) {
                break;
            }
            TouchEventData ted = (TouchEventData) msg.obj;
            if (mTouchEventQueue.enqueueTouchEvent(ted)) {
                // WebCore is responding to us; remove pending timeout.
                // It will be re-posted when needed.
                removeMessages(PREVENT_DEFAULT_TIMEOUT);
            }
            break;
        case REQUEST_KEYBOARD:
            if (msg.arg1 == 0) {
                hideSoftKeyboard();
            } else {
                displaySoftKeyboard(false);
            }
            break;
        case FIND_AGAIN:
            // Ignore if find has been dismissed.
            if (mFindIsUp && mFindCallback != null) {
                mFindCallback.findAll();
            }
            break;
        case DRAG_HELD_MOTIONLESS:
            mHeldMotionless = MOTIONLESS_TRUE;
            invalidate();
        case AWAKEN_SCROLL_BARS:
            if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
                awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(), false);
                mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS), ViewConfiguration.getScrollDefaultDelay());
            }
            break;
        case DO_MOTION_UP:
            doMotionUp(msg.arg1, msg.arg2);
            break;
        case SCREEN_ON:
            setKeepScreenOn(msg.arg1 == 1);
            break;
        case ENTER_FULLSCREEN_VIDEO:
            int layerId = msg.arg1;
            String url = (String) msg.obj;
            if (mHTML5VideoViewProxy != null) {
                mHTML5VideoViewProxy.enterFullScreenVideo(layerId, url);
            }
            break;
        case SHOW_FULLSCREEN:
            {
                View view = (View) msg.obj;
                int orientation = msg.arg1;
                int npp = msg.arg2;
                if (inFullScreenMode()) {
                    Log.w(LOGTAG, ""Should not have another full screen."");
                    dismissFullScreenMode();
                }
                mFullScreenHolder = new PluginFullScreenHolder(WebView.this, orientation, npp);
                mFullScreenHolder.setContentView(view);
                mFullScreenHolder.show();
                break;
            }
        case HIDE_FULLSCREEN:
            dismissFullScreenMode();
            break;
        case DOM_FOCUS_CHANGED:
            if (inEditingMode()) {
                nativeClearCursor();
                rebuildWebTextView();
            }
            break;
        case SHOW_RECT_MSG_ID:
            {
                WebViewCore.ShowRectData data = (WebViewCore.ShowRectData) msg.obj;
                int x = mScrollX;
                int left = contentToViewX(data.mLeft);
                int width = contentToViewDimension(data.mWidth);
                int maxWidth = contentToViewDimension(data.mContentWidth);
                int viewWidth = getViewWidth();
                if (width < viewWidth) {
                    // center align
                    x += left + width / 2 - mScrollX - viewWidth / 2;
                } else {
                    x += (int) (left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
                }
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(left="" + left + "",width="" + width + "",maxWidth="" + maxWidth + "",viewWidth="" + viewWidth + "",x="" + x + "",xPercentInDoc="" + data.mXPercentInDoc + "",xPercentInView="" + data.mXPercentInView + "")"");
                }
                // use the passing content width to cap x as the current
                // mContentWidth may not be updated yet
                x = Math.max(0, (Math.min(maxWidth, x + viewWidth)) - viewWidth);
                int top = contentToViewY(data.mTop);
                int height = contentToViewDimension(data.mHeight);
                int maxHeight = contentToViewDimension(data.mContentHeight);
                int viewHeight = getViewHeight();
                int y = (int) (top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
                if (DebugFlags.WEB_VIEW) {
                    Log.v(LOGTAG, ""showRectMsg=(top="" + top + "",height="" + height + "",maxHeight="" + maxHeight + "",viewHeight="" + viewHeight + "",y="" + y + "",yPercentInDoc="" + data.mYPercentInDoc + "",yPercentInView="" + data.mYPercentInView + "")"");
                }
                // use the passing content height to cap y as the current
                // mContentHeight may not be updated yet
                y = Math.max(0, (Math.min(maxHeight, y + viewHeight) - viewHeight));
                // We need to take into account the visible title height
                // when scrolling since y is an absolute view position.
                y = Math.max(0, y - getVisibleTitleHeightImpl());
                scrollTo(x, y);
            }
            break;
        case CENTER_FIT_RECT:
            centerFitRect((Rect) msg.obj);
            break;
        case SET_SCROLLBAR_MODES:
            mHorizontalScrollBarMode = msg.arg1;
            mVerticalScrollBarMode = msg.arg2;
            break;
        case SELECTION_STRING_CHANGED:
            if (mAccessibilityInjector != null) {
                String selectionString = (String) msg.obj;
                mAccessibilityInjector.onSelectionStringChange(selectionString);
            }
            break;
        case SET_TOUCH_HIGHLIGHT_RECTS:
            @SuppressWarnings(""unchecked"") ArrayList<Rect> rects = (ArrayList<Rect>) msg.obj;
            setTouchHighlightRects(rects);
            break;
        case SAVE_WEBARCHIVE_FINISHED:
            SaveWebArchiveMessage saveMessage = (SaveWebArchiveMessage) msg.obj;
            if (saveMessage.mCallback != null) {
                saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
            }
            break;
        case SET_AUTOFILLABLE:
            mAutoFillData = (WebViewCore.AutoFillData) msg.obj;
            if (mWebTextView != null) {
                mWebTextView.setAutoFillable(mAutoFillData.getQueryId());
                rebuildWebTextView();
            }
            break;
        case AUTOFILL_COMPLETE:
            if (mWebTextView != null) {
                // Clear the WebTextView adapter when AutoFill finishes
                // so that the drop down gets cleared.
                mWebTextView.setAdapterCustom(null);
            }
            break;
        case SELECT_AT:
            nativeSelectAt(msg.arg1, msg.arg2);
            break;
        default:
            super.handleMessage(msg);
            break;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,,,,
922,"<android.app.ContextImpl: Context createPackageContext(String,int)>",13,14,,,,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(mMainThread.getSystemContext());
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(mMainThread.getSystemContext());
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags);
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources, mBasePackageName);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"There is a new parameter 'mBasePackageName' added to the method call c.init() within the non-exception control path, so the code change type is 4.","Since the extra parameter in the init method call does not alter the return value of the createPackageContext method directly, and there is no new return statement or exception thrown because of this change, it does not introduce a Compatibility Issue; hence the CI type is 0."
924,<android.view.View: void getLocationInWindow(int[])>,13,14,,,,"{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of "" + ""two integers"");
    }
    location[0] = mLeft + (int) (mTranslationX + 0.5f);
    location[1] = mTop + (int) (mTranslationY + 0.5f);
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        location[0] += view.mLeft + (int) (view.mTranslationX + 0.5f) - view.mScrollX;
        location[1] += view.mTop + (int) (view.mTranslationY + 0.5f) - view.mScrollY;
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRoot) {
        // *cough*
        final ViewRoot vr = (ViewRoot) viewParent;
        location[1] -= vr.mCurScrollY;
    }
}","{
    if (location == null || location.length < 2) {
        throw new IllegalArgumentException(""location must be an array of "" + ""two integers"");
    }
    location[0] = mLeft;
    location[1] = mTop;
    if (mTransformationInfo != null) {
        location[0] += (int) (mTransformationInfo.mTranslationX + 0.5f);
        location[1] += (int) (mTransformationInfo.mTranslationY + 0.5f);
    }
    ViewParent viewParent = mParent;
    while (viewParent instanceof View) {
        final View view = (View) viewParent;
        location[0] += view.mLeft - view.mScrollX;
        location[1] += view.mTop - view.mScrollY;
        if (view.mTransformationInfo != null) {
            location[0] += (int) (view.mTransformationInfo.mTranslationX + 0.5f);
            location[1] += (int) (view.mTransformationInfo.mTranslationY + 0.5f);
        }
        viewParent = view.mParent;
    }
    if (viewParent instanceof ViewRootImpl) {
        // *cough*
        final ViewRootImpl vr = (ViewRootImpl) viewParent;
        location[1] -= vr.mCurScrollY;
    }
}",1,"/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
","/**
 * <p>Computes the coordinates of this view in its window. The argument
 * must be an array of two integers. After the method returns, the array
 * contains the x and y location in that order.</p>
 *
 * @param location an array of two integers in which to hold the coordinates
 */
",0,,,0,,,,,,,"1,3,4",1,"The changes include modifying existing arithmetic operations, introducing a check on mTransformationInfo, and changing the class referenced from 'ViewRoot' to 'ViewRootImpl'. The control dependency inside the 'while' has not changed, but the statements under it have because of the new conditions to check for nullity on mTransformationInfo. The variable assignments have also been changed to include or exclude certain transformations which would alter the location array's contents. The overall structure remains the same but the operations and values differ, so the code change types involve return statement, other statement, and control dependency changes.","Since this method calculates and returns the location within an array that can change due to the modified arithmetic operations, and the type of the referenced variable from 'ViewRoot' to 'ViewRootImpl', the API now potentially returns a different result; therefore, it's a CI caused by potential different return values."
925,<android.net.http.SslCertificate: String toString()>,13,14,,,,"{
    return ""Issued to: "" + mIssuedTo.getDName() + "";\n"" + ""Issued by: "" + mIssuedBy.getDName() + "";\n"";
}","{
    return (""Issued to: "" + mIssuedTo.getDName() + "";\n"" + ""Issued by: "" + mIssuedBy.getDName() + "";\n"");
}",1,"/**
 * @return A string representation of this certificate for debugging
 */
","/**
 * @return A string representation of this certificate for debugging
 */
",0,,,0,,,,,,,0,0,"The only change in the code is adding parentheses around the return statement, which doesn't change the behaviour or output of the method. Therefore, no actual code change has taken place.","Since the return value of the method is the same between the two versions and there are no changes that could lead to different behaviour, there is no compatibility issue."
926,<android.database.sqlite.SQLiteDatabase: void endTransaction()>,13,14,,,,"{
    verifyLockOwner();
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(COMMIT_SQL);
            // but this is the slowest way to run sqlite with in write-ahead logging mode.
            if (this.mConnectionPool != null) {
                execSQL(""PRAGMA wal_checkpoint;"");
                if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
                    Log.i(TAG, ""PRAGMA wal_Checkpoint done"");
                }
            }
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (Config.LOGD) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (Config.LOGV) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}","{
    verifyLockOwner();
    try {
        if (mInnerTransactionIsSuccessful) {
            mInnerTransactionIsSuccessful = false;
        } else {
            mTransactionIsSuccessful = false;
        }
        if (mLock.getHoldCount() != 1) {
            return;
        }
        RuntimeException savedException = null;
        if (mTransactionListener != null) {
            try {
                if (mTransactionIsSuccessful) {
                    mTransactionListener.onCommit();
                } else {
                    mTransactionListener.onRollback();
                }
            } catch (RuntimeException e) {
                savedException = e;
                mTransactionIsSuccessful = false;
            }
        }
        if (mTransactionIsSuccessful) {
            execSQL(COMMIT_SQL);
            // but this is the slowest way to run sqlite with in write-ahead logging mode.
            if (this.mConnectionPool != null) {
                execSQL(""PRAGMA wal_checkpoint;"");
                if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
                    Log.i(TAG, ""PRAGMA wal_Checkpoint done"");
                }
            }
            // log the transaction time to the Eventlog.
            if (ENABLE_DB_SAMPLE) {
                logTimeStat(getLastSqlStatement(), mTransStartTime, COMMIT_SQL);
            }
        } else {
            try {
                execSQL(""ROLLBACK;"");
                if (savedException != null) {
                    throw savedException;
                }
            } catch (SQLException e) {
                if (false) {
                    Log.d(TAG, ""exception during rollback, maybe the DB previously "" + ""performed an auto-rollback"");
                }
            }
        }
    } finally {
        mTransactionListener = null;
        unlockForced();
        if (false) {
            Log.v(TAG, ""unlocked "" + Thread.currentThread() + "", holdCount is "" + mLock.getHoldCount());
        }
    }
}",1,"/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
","/**
 * End a transaction. See beginTransaction for notes about how to use this and when transactions
 * are committed and rolled back.
 */
",0,,,0,,,,,,,4,0,"The change consists of adding a new block of logging functionality, and replacing the condition `Config.LOGD` with a constant `false`, so the change type is 4.","There is no change related to return values, exception handling, or control flow that would affect the API's behavior adversely. The added block of code is for logging purposes and doesn't impact the functional behavior or outcome of the method, and the condition change to `false` effectively disables the logging block that previously depended on a condition. Therefore, there is no Compatibility Issue."
928,<android.widget.NumberPicker: void computeScroll()>,13,14,,,,"{
    if (!mDrawSelectorWheel) {
        return;
    }
    Scroller scroller = mFlingScroller;
    if (scroller.isFinished()) {
        scroller = mAdjustScroller;
        if (scroller.isFinished()) {
            return;
        }
    }
    scroller.computeScrollOffset();
    int currentScrollerY = scroller.getCurrY();
    if (mPreviousScrollerY == 0) {
        mPreviousScrollerY = scroller.getStartY();
    }
    scrollBy(0, currentScrollerY - mPreviousScrollerY);
    mPreviousScrollerY = currentScrollerY;
    if (scroller.isFinished()) {
        onScrollerFinished(scroller);
    } else {
        invalidate();
    }
}","{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    Scroller scroller = mFlingScroller;
    if (scroller.isFinished()) {
        scroller = mAdjustScroller;
        if (scroller.isFinished()) {
            return;
        }
    }
    scroller.computeScrollOffset();
    int currentScrollerY = scroller.getCurrY();
    if (mPreviousScrollerY == 0) {
        mPreviousScrollerY = scroller.getStartY();
    }
    scrollBy(0, currentScrollerY - mPreviousScrollerY);
    mPreviousScrollerY = currentScrollerY;
    if (scroller.isFinished()) {
        onScrollerFinished(scroller);
    } else {
        invalidate();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,3,1,"The condition in the first 'if' statement has changed from checking `mDrawSelectorWheel` to checking `mSelectorWheelState`. This is a control dependency change, therefore the code change type is 3.","Since the conditional check has changed, it could potentially affect when the method returns early or proceeds with execution, resulting in different scrolling behavior. Consequently, the API could exhibit different behavior under certain conditions, which is a compatibility issue caused by potential different return values or types, as classified by CI type 1."
932,<android.server.BluetoothService: int getDiscoverableTimeout()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    String timeout = getProperty(""DiscoverableTimeout"");
    if (timeout != null)
        return Integer.valueOf(timeout);
    else
        return -1;
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    String timeout = getProperty(""DiscoverableTimeout"", true);
    if (timeout != null)
        return Integer.valueOf(timeout);
    else
        return -1;
}",1,"/**
 * Get the discoverability window for the device.  A timeout of zero
 * means that the device is permanently discoverable (if the device is
 * in the discoverable mode).
 *
 * @return The discoverability window of the device, in seconds.  A negative
 * value indicates an error.
 */
","/**
 * Get the discoverability window for the device.  A timeout of zero
 * means that the device is permanently discoverable (if the device is
 * in the discoverable mode).
 *
 * @return The discoverability window of the device, in seconds.  A negative
 * value indicates an error.
 */
",0,,,0,,,,,,,"4,5",0,"The method 'getProperty' was changed to include an additional parameter 'true', so the change type is 4,5 (Other statement changed, Dependent API changed).","Although there was a change to the method 'getProperty' call, it is not clear from the given data whether this change would lead to a different behavior in terms of the value returned by 'getDiscoverableTimeout'. The signature of 'getProperty' and its behavior with the additional parameter 'true' is not provided. Without further context indicating that 'getProperty(""DiscoverableTimeout"", true)' would yield a different result than 'getProperty(""DiscoverableTimeout"")', we cannot positively claim that there will be a different return value. Therefore, the CI type is 0 (No Compatibility Issue)."
933,"<android.database.CursorWindow: float getFloat(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return (float) getDouble_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    return (float) getDouble(row, column);
}",1,"/**
 * Returns a float for the given field.
 * row is 0 based
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a float value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a
 * <code>float</code>.
 * <p>
 * The result is determined by invoking {@link #getDouble} and converting the
 * result to <code>float</code>.
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as an <code>float</code>.
 */
",1,,,0,,,,,,,"1,5",1,"The code change involves the deletion of the acquireReference() and releaseReference() calls, and now directly returns the cast result of getDouble(). It also seems to have changed the method used from `getDouble_native` to `getDouble` and the parameter's name from `col` to `column`. Therefore, the change includes a return statement change and a dependent API change, hence the types are 1,5.","Considering that the control for retaining and releasing the reference of the object has been removed, and that method being called has changed from `getDouble_native` to `getDouble`, there is a high potential for a different behavior. This could lead to a CI due to the possibility of the method returning different values, especially if the `getDouble` method behaves differently than the `getDouble_native` method used in the early version, thus CI type is 1."
934,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> getAuthToken(Account,String,Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",13,14,,,,"{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            options);
        }
    }.start();
}","{
    if (account == null)
        throw new IllegalArgumentException(""account is null"");
    if (authTokenType == null)
        throw new IllegalArgumentException(""authTokenType is null"");
    final Bundle optionsIn = new Bundle();
    if (options != null) {
        optionsIn.putAll(options);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthToken(mResponse, account, authTokenType, false, /* notifyOnAuthFailure */
            true, /* expectActivityLaunch */
            optionsIn);
        }
    }.start();
}",1,"/**
 * Gets an auth token of the specified type for a particular account,
 * prompting the user for credentials if necessary.  This method is
 * intended for applications running in the foreground where it makes
 * sense to ask the user directly for a password.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, the user is prompted to enter a password.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user for a password
 * if necessary; used only to call startActivity(); must not be null.
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If an auth token
 * could not be fetched, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
","/**
 * Gets an auth token of the specified type for a particular account,
 * prompting the user for credentials if necessary.  This method is
 * intended for applications running in the foreground where it makes
 * sense to ask the user directly for a password.
 *
 * <p>If a previously generated auth token is cached for this account and
 * type, then it is returned.  Otherwise, if a saved password is
 * available, it is sent to the server to generate a new auth token.
 * Otherwise, the user is prompted to enter a password.
 *
 * <p>Some authenticators have auth token <em>types</em>, whose value
 * is authenticator-dependent.  Some services use different token types to
 * access different functionality -- for example, Google uses different auth
 * tokens to access Gmail and Google Calendar for the same account.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#USE_CREDENTIALS}.
 *
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependent
 * string token, must not be null
 * @param options Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user for a password
 * if necessary; used only to call startActivity(); must not be null.
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * at least the following fields:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted
 * </ul>
 *
 * (Other authenticator-specific values may be returned.)  If an auth token
 * could not be fetched, {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation is canceled for
 * any reason, incluidng the user canceling a credential request
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new auth token, usually because of network trouble
 * </ul>
 * If the account is no longer present on the device, the return value is
 * authenticator-dependent.  The caller should verify the validity of the
 * account before requesting an auth token.
 */
",0,,,0,,,,,,,"3,4",0,"The late version introduces a new local variable (optionsIn) which is a copy of the 'options' variable with an additional mapping from KEY_ANDROID_PACKAGE_NAME to mContext.getPackageName(). This leads to a change in the argument passed to 'mService.getAuthToken()', implying a code change of type 4 (Other statement changed) and 3 (Control dependency changed) because the creation of optionsIn depends on the condition that 'options' is not null.","There is no change in the potential return values or exception handlers directly caused by the adjustments in the implementation. The creation of optionsIn with additional information should not affect the output of 'getAuthToken()' in terms of throwing exceptions or returning different results since it is intended to enrich the options bundle with more details to be used by the service. Hence, no Compatibility Issue is expected just because of the extra data sent to the service, assuming the service handles the extra information correctly. Thus, the CI type is 0."
935,"<android.view.View: void setFlags(int,int)>",13,14,,,,"{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, set the DRAWN flag so that
                 * the next invalidate() will not be skipped.
                 */
            mPrivateFlags |= DRAWN;
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        invalidate(true);
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        invalidate(true);
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
}","{
    int old = mViewFlags;
    mViewFlags = (mViewFlags & ~mask) | (flags & mask);
    int changed = mViewFlags ^ old;
    if (changed == 0) {
        return;
    }
    int privateFlags = mPrivateFlags;
    /* Check if the FOCUSABLE bit has changed */
    if (((changed & FOCUSABLE_MASK) != 0) && ((privateFlags & HAS_BOUNDS) != 0)) {
        if (((old & FOCUSABLE_MASK) == FOCUSABLE) && ((privateFlags & FOCUSED) != 0)) {
            /* Give up focus if we are no longer focusable */
            clearFocus();
        } else if (((old & FOCUSABLE_MASK) == NOT_FOCUSABLE) && ((privateFlags & FOCUSED) == 0)) {
            /*
                 * Tell the view system that we are now available to take focus
                 * if no one else already has it.
                 */
            if (mParent != null)
                mParent.focusableViewAvailable(this);
        }
    }
    if ((flags & VISIBILITY_MASK) == VISIBLE) {
        if ((changed & VISIBILITY_MASK) != 0) {
            /*
                 * If this view is becoming visible, invalidate it in case it changed while
                 * it was not visible. Marking it drawn ensures that the invalidation will
                 * go through.
                 */
            mPrivateFlags |= DRAWN;
            invalidate(true);
            needGlobalAttributesUpdate(true);
            // the root view try to give this focus if nothing else does.
            if ((mParent != null) && (mBottom > mTop) && (mRight > mLeft)) {
                mParent.focusableViewAvailable(this);
            }
        }
    }
    /* Check if the GONE bit has changed */
    if ((changed & GONE) != 0) {
        needGlobalAttributesUpdate(false);
        requestLayout();
        if (((mViewFlags & VISIBILITY_MASK) == GONE)) {
            if (hasFocus())
                clearFocus();
            destroyDrawingCache();
            if (mParent instanceof View) {
                // GONE views noop invalidation, so invalidate the parent
                ((View) mParent).invalidate(true);
            }
            // Mark the view drawn to ensure that it gets invalidated properly the next
            // time it is visible and gets invalidated
            mPrivateFlags |= DRAWN;
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    /* Check if the VISIBLE bit has changed */
    if ((changed & INVISIBLE) != 0) {
        needGlobalAttributesUpdate(false);
        /*
             * If this view is becoming invisible, set the DRAWN flag so that
             * the next invalidate() will not be skipped.
             */
        mPrivateFlags |= DRAWN;
        if (((mViewFlags & VISIBILITY_MASK) == INVISIBLE) && hasFocus()) {
            // root view becoming invisible shouldn't clear focus
            if (getRootView() != this) {
                clearFocus();
            }
        }
        if (mAttachInfo != null) {
            mAttachInfo.mViewVisibilityChanged = true;
        }
    }
    if ((changed & VISIBILITY_MASK) != 0) {
        if (mParent instanceof ViewGroup) {
            ((ViewGroup) mParent).onChildVisibilityChanged(this, (flags & VISIBILITY_MASK));
            ((View) mParent).invalidate(true);
        } else if (mParent != null) {
            mParent.invalidateChild(this, null);
        }
        dispatchVisibilityChanged(this, (flags & VISIBILITY_MASK));
    }
    if ((changed & WILL_NOT_CACHE_DRAWING) != 0) {
        destroyDrawingCache();
    }
    if ((changed & DRAWING_CACHE_ENABLED) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
        invalidateParentCaches();
    }
    if ((changed & DRAWING_CACHE_QUALITY_MASK) != 0) {
        destroyDrawingCache();
        mPrivateFlags &= ~DRAWING_CACHE_VALID;
    }
    if ((changed & DRAW_MASK) != 0) {
        if ((mViewFlags & WILL_NOT_DRAW) != 0) {
            if (mBGDrawable != null) {
                mPrivateFlags &= ~SKIP_DRAW;
                mPrivateFlags |= ONLY_DRAWS_BACKGROUND;
            } else {
                mPrivateFlags |= SKIP_DRAW;
            }
        } else {
            mPrivateFlags &= ~SKIP_DRAW;
        }
        requestLayout();
        invalidate(true);
    }
    if ((changed & KEEP_SCREEN_ON) != 0) {
        if (mParent != null && mAttachInfo != null && !mAttachInfo.mRecomputeGlobalAttributes) {
            mParent.recomputeViewAttributes(this);
        }
    }
    if ((changed & LAYOUT_DIRECTION_MASK) != 0) {
        requestLayout();
    }
}",1,"/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
","/**
 * Set flags controlling behavior of this view.
 *
 * @param flags Constant indicating the value which should be set
 * @param mask Constant indicating the bit range that should be changed
 */
",0,,,0,,,,,,,,,,
936,<android.animation.ValueAnimator: ValueAnimator clone()>,13,14,,,,"{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
        int numListeners = oldListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            anim.mUpdateListeners.add(oldListeners.get(i));
        }
    }
    anim.mSeekTime = -1;
    anim.mPlayingBackwards = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        for (int i = 0; i < numValues; ++i) {
            anim.mValues[i] = oldValues[i].clone();
        }
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder valuesHolder = mValues[i];
            anim.mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);
        }
    }
    return anim;
}","{
    final ValueAnimator anim = (ValueAnimator) super.clone();
    if (mUpdateListeners != null) {
        ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
        anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
        int numListeners = oldListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            anim.mUpdateListeners.add(oldListeners.get(i));
        }
    }
    anim.mSeekTime = -1;
    anim.mPlayingBackwards = false;
    anim.mCurrentIteration = 0;
    anim.mInitialized = false;
    anim.mPlayingState = STOPPED;
    anim.mStartedDelay = false;
    PropertyValuesHolder[] oldValues = mValues;
    if (oldValues != null) {
        int numValues = oldValues.length;
        anim.mValues = new PropertyValuesHolder[numValues];
        anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder newValuesHolder = oldValues[i].clone();
            anim.mValues[i] = newValuesHolder;
            anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
        }
    }
    return anim;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,"The change has been in the loop where property values are cloned and added to `anim.mValuesMap`. In the early version, the cloning and adding to the map are done in two separate loops, while in the late version they are combined into a single loop with the cloned `PropertyValuesHolder` being used to add to both the array and the map. This is an internal optimization and does not affect the method's external behavior. So this is classified under the ""Other statement changed"" category 4.","There is no compatibility issue as the external behavior of the `clone()` method has not been altered. The method still creates a new `ValueAnimator` with the same values and listeners as the original. The change does not cause the API to return a different value or throw different exceptions, so the pred_CI is 0."
938,<android.view.inputmethod.InputMethodManager: void showInputMethodAndSubtypeEnabler(String)>,13,14,,,,"{
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, topId);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}","{
    synchronized (mH) {
        try {
            mService.showInputMethodAndSubtypeEnablerFromClient(mClient, imiId);
        } catch (RemoteException e) {
            Log.w(TAG, ""IME died: "" + mCurId, e);
        }
    }
}",1,,"/**
 * Show the settings for enabling subtypes of the specified input method.
 * @param imiId An input method, whose subtypes settings will be shown. If imiId is null,
 * subtypes of all input methods will be shown.
 */
",1,,,0,,,,,,,4,0,There is a change in one variable name from 'topId' to 'imiId' inside the call to mService.showInputMethodAndSubtypeEnablerFromClient(). The code change type is 4 since it's a change of a variable name but not directly related to the return value or exception handling.,"Assuming 'topId' and 'imiId' refer to the same concept or value and there is no behavioral change with the renaming of this variable, there should be no compatibility issue arising from this change, hence the CI type is 0."
939,"<android.widget.NumberPicker: void scrollBy(int,int)>",13,14,,,,"{
    int[] selectorIndices = getSelectorIndices();
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset >= mSelectorElementHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset <= -mSelectorElementHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementScrollSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
}","{
    if (mSelectorWheelState == SELECTOR_WHEEL_STATE_NONE) {
        return;
    }
    int[] selectorIndices = mSelectorIndices;
    if (!mWrapSelectorWheel && y > 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    if (!mWrapSelectorWheel && y < 0 && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
        mCurrentScrollOffset = mInitialScrollOffset;
        return;
    }
    mCurrentScrollOffset += y;
    while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
        mCurrentScrollOffset -= mSelectorElementHeight;
        decrementSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
    while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
        mCurrentScrollOffset += mSelectorElementHeight;
        incrementSelectorIndices(selectorIndices);
        changeCurrent(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX]);
        if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
            mCurrentScrollOffset = mInitialScrollOffset;
        }
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",1,"A new return statement has been added (immediately returns if mSelectorWheelState is SELECTOR_WHEEL_STATE_NONE) and changes to the conditions in the 'while' loops have been made, from comparing >= and <= to > and <. These changes are classified as 1 for the new return statement, and 3 for the change in control flow due to the updated condition checks.","The introduction of an early return based on the new condition (mSelectorWheelState) and the change of comparison operators in the 'while' loops may lead to different behavior. In particular, the function may exit earlier without modifying the state, or it may iterate differently over the selector indices which could lead to different modifications to mCurrentScrollOffset and the array of selectorIndices. These changes can potentially lead to different return values and types due to the introduction of a new return statement and control dependency change, thus the CI type is 1."
940,"<android.content.res.Resources: Drawable loadDrawable(TypedValue,int)>",13,14,,,,"{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (isColorDrawable) {
                    sPreloadedColorDrawables.put(key, cs);
                } else {
                    sPreloadedDrawables.put(key, cs);
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}","{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d(""PreloadDrawable"", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs = isColorDrawable ? sPreloadedColorDrawables.get(key) : sPreloadedDrawables.get(key);
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException(""Resource is not a Drawable (color or path): "" + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, ""Loading framework drawable #"" + Integer.toHexString(id) + "": "" + name + "" at "" + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, ""Loading drawable for cookie "" + value.assetCookie + "": "" + file);
            if (file.endsWith("".xml"")) {
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, ""drawable"");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            } else {
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println(""Opened file "" + file + "": "" + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println(""Created stream: "" + dr);
                } catch (Exception e) {
                    NotFoundException rnf = new NotFoundException(""File "" + file + "" from drawable resource ID #0x"" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                if (isColorDrawable) {
                    sPreloadedColorDrawables.put(key, cs);
                } else {
                    sPreloadedDrawables.put(key, cs);
                }
            } else {
                synchronized (mTmpValue) {
                    // + "" in "" + this + "": "" + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,,,,
942,"<android.app.PendingIntent: PendingIntent getActivity(Context,int,Intent,int)>",13,14,,,,"{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}","{
    String packageName = context.getPackageName();
    String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
    try {
        intent.setAllowFds(false);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(IActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] { intent }, resolvedType != null ? new String[] { resolvedType } : null, flags);
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    }
    return null;
}",1,"/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
","/**
 * Retrieve a PendingIntent that will start a new activity, like calling
 * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.
 * Note that the activity will be started outside of the context of an
 * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK
 * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.
 *
 * @param context The Context in which this PendingIntent should start
 * the activity.
 * @param requestCode Private request code for the sender (currently
 * not used).
 * @param intent Intent of the activity to be launched.
 * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},
 * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been
 * supplied.
 */
",0,,,0,,,,,,,4,0,"There is an additional statement `intent.setAllowFds(false);` in the late version implementation. This is an 'Other statement changed' (code 4), as it affects neither the return statement, exception handling, control dependencies, nor a dependent API.","Even though there's a new statement, it simply sets a property on the `Intent` object and doesn't change the behavior of the API in terms of the type or value of what's returned. It doesn't introduce a new return pathway or change exception handling. Therefore, this change does not introduce a Compatibility Issue, resulting in CI type 0."
944,"<android.text.TextUtils: CharSequence replace(CharSequence,String[],CharSequence[])>",13,14,,,,"{
    SpannableStringBuilder tb = new SpannableStringBuilder(template);
    for (int i = 0; i < sources.length; i++) {
        int where = indexOf(tb, sources[i]);
        if (where >= 0)
            tb.setSpan(sources[i], where, where + sources[i].length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    for (int i = 0; i < sources.length; i++) {
        int start = tb.getSpanStart(sources[i]);
        int end = tb.getSpanEnd(sources[i]);
        if (start >= 0) {
            tb.replace(start, end, destinations[i]);
        }
    }
    return tb;
}","{
    SpannableStringBuilder tb = new SpannableStringBuilder(template);
    for (int i = 0; i < sources.length; i++) {
        int where = indexOf(tb, sources[i]);
        if (where >= 0)
            tb.setSpan(sources[i], where, where + sources[i].length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
    for (int i = 0; i < sources.length; i++) {
        int start = tb.getSpanStart(sources[i]);
        int end = tb.getSpanEnd(sources[i]);
        if (start >= 0) {
            tb.replace(start, end, destinations[i]);
        }
    }
    return tb;
}",1,"/**
 * Return a new CharSequence in which each of the source strings is
 * replaced by the corresponding element of the destinations.
 */
","/**
 * Return a new CharSequence in which each of the source strings is
 * replaced by the corresponding element of the destinations.
 */
",0,,,0,,,,,,,4,0,"The change is isolated to a constant value, from `Spannable.SPAN_EXCLUSIVE_EXCLUSIVE` to `Spanned.SPAN_EXCLUSIVE_EXCLUSIVE`. This change does not alter the control flow, logic, or operations other than changing the constant used, which is assumed to have the same value because they are typically part of a set of related constants defining span behavior.","Given that the replacement of `Spannable.SPAN_EXCLUSIVE_EXCLUSIVE` with `Spanned.SPAN_EXCLUSIVE_EXCLUSIVE` is expected to reference the same underlying value, it does not constitute a behavior change or compatibility issue."
945,"<android.accounts.AccountManager: AccountManagerFuture<Bundle> addAccount(String,String,String[],Bundle,Activity,AccountManagerCallback<Bundle>,Handler)>",13,14,,,,"{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAcount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, addAccountOptions);
        }
    }.start();
}","{
    if (accountType == null)
        throw new IllegalArgumentException(""accountType is null"");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAcount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}",1,"/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
","/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */
",0,,,0,,,,,,,4,0,"The only change is the addition of a new local final variable `optionsIn` and the insertion of the `packageName` into it before it is passed to the method `mService.addAccount`. This code change falls under the category of ""Other statement changed"" since it does not involve any control flow, return statement, or exception handling statement changes, and also does not directly indicate a signature change in a dependent API.","There is no Compatibility Issue arising from this change. The behavior when `accountType` is `null` remains the same (throwing an `IllegalArgumentException`), there is no change in return type or value, and no new exception is introduced. The change to what is being passed into `mService.addAccount` does not directly affect the returning value or exception from the `addAccount` method but rather enhances the bundle by including additional information."
947,"<android.server.BluetoothDeviceProperties: Map<String, String> addProperties(String,String[])>",13,14,,,,"{
    /*
         * We get a DeviceFound signal every time RSSI changes or name changes.
         * Don't create a new Map object every time.
         */
    Map<String, String> propertyValues = mPropertiesMap.get(address);
    if (propertyValues == null) {
        propertyValues = new HashMap<String, String>();
    }
    for (int i = 0; i < properties.length; i++) {
        String name = properties[i];
        String newValue = null;
        int len;
        if (name == null) {
            Log.e(TAG, ""Error: Remote Device Property at index "" + i + "" is null"");
            continue;
        }
        if (name.equals(""UUIDs"") || name.equals(""Nodes"")) {
            StringBuilder str = new StringBuilder();
            len = Integer.valueOf(properties[++i]);
            for (int j = 0; j < len; j++) {
                str.append(properties[++i]);
                str.append("","");
            }
            if (len > 0) {
                newValue = str.toString();
            }
        } else {
            newValue = properties[++i];
        }
        propertyValues.put(name, newValue);
    }
    mPropertiesMap.put(address, propertyValues);
    // We have added a new remote device or updated its properties.
    // Also update the serviceChannel cache.
    mService.updateDeviceServiceChannelCache(address);
    return propertyValues;
}","{
    /*
         * We get a DeviceFound signal every time RSSI changes or name changes.
         * Don't create a new Map object every time.
         */
    Map<String, String> propertyValues;
    synchronized (mPropertiesMap) {
        propertyValues = mPropertiesMap.get(address);
        if (propertyValues == null) {
            propertyValues = new HashMap<String, String>();
        }
        for (int i = 0; i < properties.length; i++) {
            String name = properties[i];
            String newValue = null;
            int len;
            if (name == null) {
                Log.e(TAG, ""Error: Remote Device Property at index "" + i + "" is null"");
                continue;
            }
            if (name.equals(""UUIDs"") || name.equals(""Nodes"")) {
                StringBuilder str = new StringBuilder();
                len = Integer.valueOf(properties[++i]);
                for (int j = 0; j < len; j++) {
                    str.append(properties[++i]);
                    str.append("","");
                }
                if (len > 0) {
                    newValue = str.toString();
                }
            } else {
                newValue = properties[++i];
            }
            propertyValues.put(name, newValue);
        }
        mPropertiesMap.put(address, propertyValues);
    }
    // We have added a new remote device or updated its properties.
    // Also update the serviceChannel cache.
    mService.updateDeviceServiceChannelCache(address);
    return propertyValues;
}",1,,,0,,,0,,,,,,,"3,4",0,"The method now includes a synchronization block wrapped around the map modification logic, which is a change in other statement and control dependency but keeps all the other functionalities same as the earlier version. This change is about concurrency control and does not affect the method's return value or exception handling, hence the change types are 3 and 4.","While the code introduces synchronization (which could be considered a change in other statement and control dependency), it should not cause different return values or exceptions being thrown. Therefore, there's no Compatibility Issue."
949,<android.accounts.AccountManagerService.Session: void onTimedOut()>,13,14,,,,"{
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""timeout"");
    }
}","{
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        try {
            response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""timeout"");
        } catch (RemoteException e) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""Session.onTimedOut: caught RemoteException while responding"", e);
            }
        }
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The invocation of onError(...) within the if (response != null) condition has been wrapped in a try-catch block to specifically catch RemoteException, and a new log statement has been added in the catch block, so the code change type is 3,4.","There is no compatibility issue since the original onError(...) call is simply surrounded by an additional layer of error handling, and the added logging does not affect the functional behavior that callers of onTimedOut() would rely upon; thus, the CI type is 0."
951,<android.webkit.WebView: void loadUrl(String)>,13,14,,,,"{
    if (url == null) {
        return;
    }
    loadUrl(url, null);
}","{
    checkThread();
    loadUrlImpl(url);
}",1,"/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
","/**
 * Load the given url.
 * @param url The url of the resource to load.
 */
",0,,,0,,,,,,,"3,5",1,"There are several changes in the late implementation: the null check on the 'url' parameter has been removed, the call to 'loadUrl' with two parameters has been replaced by a call to 'loadUrlImpl', and there has been a new method call inserted: 'checkThread()'. This means that the code change type is 3,5 due to the control dependency change and the dependent API change (the replacement of 'loadUrl' with 'loadUrlImpl').","There could be a compatibility issue as the null-checking behavior is removed, and instead of returning directly, the new version will execute 'checkThread()' and 'loadUrlImpl()'. This results in a CI type of 1 because it could lead to different behavior when 'url' is null - the early version would return without action, while the late version might throw an exception or take a different action due to 'checkThread()' or 'loadUrlImpl()'."
952,<android.database.BulkCursorProxy: CursorWindow getWindow(int)>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    data.writeInt(startPos);
    mRemote.transact(GET_CURSOR_WINDOW_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    CursorWindow window = null;
    if (reply.readInt() == 1) {
        window = CursorWindow.newFromParcel(reply);
    }
    data.recycle();
    reply.recycle();
    return window;
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        data.writeInt(startPos);
        mRemote.transact(GET_CURSOR_WINDOW_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
        CursorWindow window = null;
        if (reply.readInt() == 1) {
            window = CursorWindow.newFromParcel(reply);
        }
        return window;
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,"2,3",0,"The late implementation introduces a try-finally block for resource management, which is an exception handling change, as well as a control dependency change, because it affects when the recycling of 'Parcel' objects will occur. Hence the change types are 2 and 3.","There is no Compatibility Issue detected here because the changes do not affect the value returned by the function nor the exceptions that are thrown from the function to the caller. The change only ensures that 'data' and 'reply' are recycled even if an exception occurs, which is an internal implementation detail and does not change the external behavior as observed by the caller. Therefore, the CI type is 0."
953,"<android.nfc.NfcAdapter: void enableForegroundNdefPush(Activity,NdefMessage)>",13,14,,,,"{
    if (activity == null || msg == null) {
        throw new NullPointerException();
    }
    if (!activity.isResumed()) {
        throw new IllegalStateException(""Foregorund NDEF push can only be enabled "" + ""when your activity is resumed"");
    }
    try {
        ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundNdefPushListener);
        sService.enableForegroundNdefPush(activity.getComponentName(), msg);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
    }
}","{
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message);
}",1,"/**
 * Enable NDEF message push over P2P while this Activity is in the foreground.
 *
 * <p>For this to function properly the other NFC device being scanned must
 * support the ""com.android.npp"" NDEF push protocol. Support for this
 * protocol is currently optional for Android NFC devices.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note""><em>NOTE:</em> While foreground NDEF push is active standard tag dispatch is disabled.
 * Only the foreground activity may receive tag discovered dispatches via
 * {@link #enableForegroundDispatch}.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the foreground Activity
 * @param msg a NDEF Message to push over P2P
 * @throws IllegalStateException if the Activity is not currently in the foreground
 * @throws OperationNotSupportedException if this Android device does not support NDEF push
 */
","/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's ""com.android.npp"" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class=""note"">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @deprecated use {@link #setNdefPushMessage} instead
 */
",1,,[@Deprecated],1,,,,,,,"2,3,4,5","1,2",The code changes include:,"- The deletion of `ActivityThread.currentActivityThread().registerOnActivityPausedListener(activity, mForegroundNdefPushListener)` and `sService.enableForegroundNdefPush(activity.getComponentName(), msg)`, and introduction of new method `mNfcActivityManager.setNdefPushMessage(activity, message)` which is a change in implementation and dependent APIs."
955,<android.webkit.WebView: void findNext(boolean)>,13,14,,,,"{
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    nativeFindNext(forward);
}","{
    checkThread();
    // client isn't initialized
    if (0 == mNativeClass)
        return;
    nativeFindNext(forward);
}",1,"/*
     * Highlight and scroll to the next occurance of String in findAll.
     * Wraps the page infinitely, and scrolls.  Must be called after
     * calling findAll.
     *
     * @param forward Direction to search.
     */
","/*
     * Highlight and scroll to the next occurance of String in findAll.
     * Wraps the page infinitely, and scrolls.  Must be called after
     * calling findAll.
     *
     * @param forward Direction to search.
     */
",0,,,0,,,,,,,4,0,"The change involves the addition of the checkThread() method call at the beginning of the method, so the code change type is 4.","The added checkThread() method call does not change the output value of the method nor does it change exception handling as there's no information that checkThread() throws a checked exception. Hence, this change doesn't lead to a Different Behaviors and the CI type is 0."
956,"<android.app.WallpaperManager: void setWallpaperOffsets(IBinder,float,float)>",13,14,,,,"{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRoot.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}","{
    try {
        // Log.v(TAG, ""Sending new wallpaper offsets from app..."");
        ViewRootImpl.getWindowSession(mContext.getMainLooper()).setWallpaperPosition(windowToken, xOffset, yOffset, mWallpaperXStep, mWallpaperYStep);
    // Log.v(TAG, ""...app returning after sending offsets!"");
    } catch (RemoteException e) {
    // Ignore.
    }
}",1,"/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
","/**
 * Set the position of the current wallpaper within any larger space, when
 * that wallpaper is visible behind the given window.  The X and Y offsets
 * are floating point numbers ranging from 0 to 1, representing where the
 * wallpaper should be positioned within the screen space.  These only
 * make sense when the wallpaper is larger than the screen.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param xOffset The offset along the X dimension, from 0 to 1.
 * @param yOffset The offset along the Y dimension, from 0 to 1.
 */
",0,,,0,,,,,,,4,0,"The code change is about the name of the class being used from ViewRoot to ViewRootImpl, and since this is only a reference change and not a method signature change, the change type is 4.","There is no Compatibility Issue since the method being called (getWindowSession().setWallpaperPosition(...)) did not change its signature or behavior; it's only the class through which the method is accessed that changed. The change does not affect the return values or the exception handling of the API, so there is no CI."
958,<android.server.BluetoothService: void removeServiceRecord(int)>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    checkAndRemoveRecord(handle, Binder.getCallingPid());
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    // Since this is a binder call check if Bluetooth is off
    if (getBluetoothStateInternal() == BluetoothAdapter.STATE_OFF)
        return;
    Message message = mHandler.obtainMessage(MESSAGE_REMOVE_SERVICE_RECORD);
    message.obj = new Pair<Integer, Integer>(handle, Binder.getCallingPid());
    mHandler.sendMessage(message);
}",1,,,0,,,0,,,,,,,"3,4",0,"The changes include adding a comment, adding a condition statement (if statement) to check the internal state of the Bluetooth before proceeding, and replacing the direct call to checkAndRemoveRecord() with the creation and sending of a Message object to a Handler. The reason for these changes is likely to introduce asynchronous handling of service record removal when Bluetooth is ON and avoid doing anything when Bluetooth is OFF, so the code change type is 3,4.","Despite the conditional return early in the Late_Implementation version if Bluetooth is turned off, this would not cause a Compatibility Issue because the Early_Version didn't perform any operation or change the state of the system if it was actually meant to be called only when the Bluetooth is on. This return merely formalizes a precondition that was implicit before. Additional code that handles the case when Bluetooth is on does not alter the behavior but instead changes how the operation is performed (asynchronously vs. synchronously), which should not affect the API's expected behavior seen by the client as the method's signature and observed effect remain unchanged. Therefore, no Compatibility Issue is detected."
959,<android.webkit.WebView: void finalize()>,13,14,,,,"{
    try {
        destroy();
    } finally {
        super.finalize();
    }
}","{
    try {
        if (mNativeClass != 0) {
            mPrivateHandler.post(new Runnable() {

                @Override
                public void run() {
                    destroy();
                }
            });
        }
    } finally {
        super.finalize();
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The implementation has changed to include an if-statement to check if 'mNativeClass' is not equal to 0 and enqueues the 'destroy()' execution on 'mPrivateHandler'. These changes are of type 3 (Control dependency changed) due to the added if-condition, and type 4 (Other statement changed) because of the new Runnable that wraps the 'destroy()' call.","There is no Compatibility Issue since the behavior change does not affect the API contract. 'finalize' is a void method meant to aid garbage collection: it does not return a value to the caller, nor does it throw checked exceptions to be handled by the user. The method's contract remains intact despite the internal implementation changing how 'destroy' is called. Thus, the end-user of the API would not experience any observable difference in API behavior due to these changes; the finalization of the WebView object still happens as per the garbage collection mechanism's work."
961,<android.ddm.DdmHandleProfiling: Chunk handleChunk(Chunk)>,13,14,,,,"{
    if (Config.LOGV)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}","{
    if (false)
        Log.v(""ddm-heap"", ""Handling "" + name(request.type) + "" chunk"");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else {
        throw new RuntimeException(""Unknown packet "" + ChunkHandler.name(type));
    }
}",1,"/**
 * Handle a chunk of data.
 */
","/**
 * Handle a chunk of data.
 */
",0,,,0,,,,,,,4,0,"The conditional check for logging has been changed from `Config.LOGV` to `false`, effectively disabling the log statement. This code change type is 4.","The change in the logging condition does not affect the behavior of the method in terms of logic, exception handling, or return values. It simply disables a logging statement which is not related to the functional behavior of the chunk handling, so there is no Compatibility Issue."
962,<android.webkit.WebView: boolean zoomIn()>,13,14,,,,"{
    return mZoomManager.zoomIn();
}","{
    checkThread();
    return mZoomManager.zoomIn();
}",1,"/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
","/**
 * Perform zoom in in the webview
 * @return TRUE if zoom in succeeds. FALSE if no zoom changes.
 */
",0,,,0,,,,,,,4,0,"The new method call `checkThread();` does not alter the control flow or the return value, so the change type is 4, which indicates an Other statement change.","Since `checkThread();` seems to be a check to ensure that the method is being called on the correct thread (probably the UI thread) but does not affect the return value or exception handling of the public API, no compatibility issue should arise from this change alone."
963,<android.view.accessibility.AccessibilityEvent: AccessibilityEvent obtain()>,13,14,,,,"{
    synchronized (mPoolLock) {
        if (sPool != null) {
            AccessibilityEvent event = sPool;
            sPool = sPool.mNext;
            sPoolSize--;
            event.mNext = null;
            event.mIsInPool = false;
            return event;
        }
        return new AccessibilityEvent();
    }
}","{
    synchronized (sPoolLock) {
        if (sPool != null) {
            AccessibilityEvent event = sPool;
            sPool = sPool.mNext;
            sPoolSize--;
            event.mNext = null;
            event.mIsInPool = false;
            return event;
        }
        return new AccessibilityEvent();
    }
}",1,"/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
","/**
 * Returns a cached instance if such is available or a new one is
 * instantiated.
 *
 * @return An instance.
 */
",0,,,0,,,,,,,0,0,"The change is only in a name of a lock object from `mPoolLock` to `sPoolLock`. There are no changes in the control flow or logic of the method, so there's no change that affects any of the categories defined.","As there is no change in the behavior or return value of the API, there is no Compatibility Issue."
964,<android.app.Activity: MenuInflater getMenuInflater()>,13,14,,,,"{
    return new MenuInflater(this);
}","{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext());
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}",1,"/**
 * Returns a {@link MenuInflater} with this context.
 */
","/**
 * Returns a {@link MenuInflater} with this context.
 */
",0,,,0,,,,,,,"1,3,4",1,"There is a control dependent conditional block added and within that, the instantiation of MenuInflater has been changed to account for the themed context retrieved from the action bar, which also adds a new variable (mMenuInflater). Additionally, a call to initActionBar() was introduced, which could change the state used by getMenuInflater(). The new variable assignment adds to the 'Other statement changed' category. So, the change types are 1, 3, and 4.","The late version of the method can return a MenuInflater associated with a different Context (themed context of the action bar when present, instead of the Activity context directly). This can potentially change the appearance and functionality of the menus, causing a compatibility issue due to different return values or types. Therefore, the CI type is 1."
965,<android.widget.TextView: boolean onSetAlpha(int)>,13,14,,,,"{
    // TODO text with spans with a background color currently do not respect this alpha.
    if (getBackground() == null) {
        mCurrentAlpha = alpha;
        final Drawables dr = mDrawables;
        if (dr != null) {
            if (dr.mDrawableLeft != null)
                dr.mDrawableLeft.mutate().setAlpha(alpha);
            if (dr.mDrawableTop != null)
                dr.mDrawableTop.mutate().setAlpha(alpha);
            if (dr.mDrawableRight != null)
                dr.mDrawableRight.mutate().setAlpha(alpha);
            if (dr.mDrawableBottom != null)
                dr.mDrawableBottom.mutate().setAlpha(alpha);
        }
        return true;
    }
    mCurrentAlpha = 255;
    return false;
}","{
    // TODO text with spans with a background color currently do not respect this alpha.
    if (getBackground() == null) {
        mCurrentAlpha = alpha;
        final Drawables dr = mDrawables;
        if (dr != null) {
            if (dr.mDrawableLeft != null)
                dr.mDrawableLeft.mutate().setAlpha(alpha);
            if (dr.mDrawableTop != null)
                dr.mDrawableTop.mutate().setAlpha(alpha);
            if (dr.mDrawableRight != null)
                dr.mDrawableRight.mutate().setAlpha(alpha);
            if (dr.mDrawableBottom != null)
                dr.mDrawableBottom.mutate().setAlpha(alpha);
            if (dr.mDrawableStart != null)
                dr.mDrawableStart.mutate().setAlpha(alpha);
            if (dr.mDrawableEnd != null)
                dr.mDrawableEnd.mutate().setAlpha(alpha);
        }
        return true;
    }
    mCurrentAlpha = 255;
    return false;
}",1,,,0,[@Override],[@Override],0,,,,,,,4,0,The late implementation adds two additional conditions to check `dr.mDrawableStart` and `dr.mDrawableEnd` and set their alpha values if they are not null. This constitutes a change type 4 (Other statement changed).,There is no Compatibility Issue here because the method still returns the same boolean value under the same conditions as in the early version. The additional mutations to `dr.mDrawableStart` and `dr.mDrawableEnd` only affect internal drawable state and do not change the method's return behavior.
966,"<android.app.ContextImpl: int checkPermission(String,int,int)>",13,14,,,,"{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    if (!Process.supportsProcesses()) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return ActivityManagerNative.getDefault().checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}","{
    if (permission == null) {
        throw new IllegalArgumentException(""permission is null"");
    }
    try {
        return ActivityManagerNative.getDefault().checkPermission(permission, pid, uid);
    } catch (RemoteException e) {
        return PackageManager.PERMISSION_DENIED;
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,3",0,"The exception handling statement hasn't changed. The control dependency 'if (!Process.supportsProcesses())' and its associated 'return PackageManager.PERMISSION_GRANTED;' have been removed, which is a control dependency change, so the change type is 1,3.","Even though the 'if' control dependency and return statement have been removed, it does not cause a compatibility issue because the removed condition 'if (!Process.supportsProcesses())' was checking a feature that was deprecated and no longer relevant to the actual permission checking behavior of the method. The remainder of the implementation and the thrown exception type remain the same, meaning the behavior of the method when actually called would not be different in terms of returning different values or throwing different exceptions, as the deprecated 'if' condition was just returning 'PERMISSION_GRANTED' without checking actual permissions. In the modern system, 'Process.supportsProcesses()' would always return true, making that branch irrelevant, so there's no CI caused by potential different return values/types or exception handlings."
967,"<android.view.ViewGroup: ViewParent invalidateChildInParent(int[],Rect)>",13,14,,,,"{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE_CHILD_IN_PARENT);
    }
    if ((mPrivateFlags & DRAWN) == DRAWN || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if (dirty.intersect(0, 0, mRight - left, mBottom - top) || (mPrivateFlags & DRAW_ANIMATION) == DRAW_ANIMATION) {
                mPrivateFlags &= ~DRAWING_CACHE_VALID;
                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
                if (mLayerType != LAYER_TYPE_NONE) {
                    mLocalDirtyRect.union(dirty);
                }
                return mParent;
            }
        } else {
            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            if (mLayerType != LAYER_TYPE_NONE) {
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}","{
    if (ViewDebug.TRACE_HIERARCHY) {
        ViewDebug.trace(this, ViewDebug.HierarchyTraceType.INVALIDATE_CHILD_IN_PARENT);
    }
    if ((mPrivateFlags & DRAWN) == DRAWN || (mPrivateFlags & DRAWING_CACHE_VALID) == DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) != FLAG_CLIP_CHILDREN || dirty.intersect(0, 0, mRight - left, mBottom - top) || (mPrivateFlags & DRAW_ANIMATION) == DRAW_ANIMATION) {
                mPrivateFlags &= ~DRAWING_CACHE_VALID;
                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
                if (mLayerType != LAYER_TYPE_NONE) {
                    mLocalDirtyRect.union(dirty);
                }
                return mParent;
            }
        } else {
            mPrivateFlags &= ~DRAWN & ~DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}",1,"/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
","/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */
",0,,,0,,,,,,,"3,4",0,"The code change includes the addition of a condition check for `FLAG_CLIP_CHILDREN` and changes in the way `dirty` is set or unioned based on this flag. This is both a change in the control dependency and other statement changes; therefore, the change type is 3,4.","The added condition `(mGroupFlags & FLAG_CLIP_CHILDREN) != FLAG_CLIP_CHILDREN` and the different operations on the `dirty` variable based on that condition don't constitute a compatibility issue because these changes don't affect the return value or exception handling of the method in a manner that would cause it to behave differently from the perspective of the API's contract. The method will still return the same value (`mParent` or `null`) based on similar conditions as before. The internal state modifications do not have an outward effect on the method's return type or the exceptions thrown. Thus, there is no compatibility issue."
969,"<android.accounts.AbstractAccountAuthenticator.Transport: void getAuthToken(IAccountAuthenticatorResponse,Account,String,Bundle)>",13,14,,,,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthToken: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthToken: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthToken"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""getAuthToken not supported"");
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getAuthToken"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""getAuthToken: "" + account + "", authTokenType "" + authTokenType);
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.getAuthToken(new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""getAuthToken: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""getAuthToken"", account.toString() + "","" + authTokenType, e);
    }
}",1,,,0,,,0,,,,,,,"2,4",2,"The specific catch blocks for UnsupportedOperationException and NetworkErrorException have been replaced with a general catch block for Exception, and a new method handleException() is being called within this block instead of directly responding with an error. This means the exception handling statement has changed, so the change type is 2. The handling logic for exceptions has been modified, which is also a type 4 change.","In the late version, all exceptions including but not limited to UnsupportedOperationException and NetworkErrorException are now handled by the handleException() method. This behavior change can lead to different exception handlings in comparison with the early version that had specific catch blocks for these exceptions. Thus, the CI type is 2."
970,"<android.database.CursorWindow: double getDouble(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return getDouble_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetDouble(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns a double for the given field.
 * row is 0 based
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a double value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a
 * <code>double</code>.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>0.0</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the value obtained by parsing the string value with <code>strtod</code>.
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the result
 * is the integer value converted to a <code>double</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the result
 * is the <code>double</code> value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a
 * {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a <code>double</code>.
 */
",1,,,0,,,,,,,5,0,"The method called within the try block has been changed from ""getDouble_native(int, int)"" to ""nativeGetDouble(long, int, int)"". This indicates a change in the dependent API (the called method's name and the number of its parameters have changed), which falls under the code change type 5.","However, since the API signature has not changed and the outer structure of the method remains the same (enclosed in a try-finally block with proper resource management via acquireReference() and releaseReference()), it can be inferred that this change does not alter the API's behavior from the caller's perspective. The return type is still double, and the method's purpose, which is to return a double value from a cursor window, has not changed. Therefore, there is no compatibility issue introduced due to this change, as it does not affect how the API behaves externally."
971,"<android.view.MotionEvent: MotionEvent obtain(long,long,int,int,int[],PointerCoords[],int,float,float,int,int,int,int)>",13,14,,,,"{
    MotionEvent ev = obtain();
    ev.mNativePtr = nativeInitialize(ev.mNativePtr, deviceId, source, action, flags, edgeFlags, metaState, 0, 0, xPrecision, yPrecision, downTime * NS_PER_MS, eventTime * NS_PER_MS, pointers, pointerIds, pointerCoords);
    return ev;
}","{
    synchronized (gSharedTempLock) {
        ensureSharedTempPointerCapacity(pointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        for (int i = 0; i < pointerCount; i++) {
            pp[i].clear();
            pp[i].id = pointerIds[i];
        }
        return obtain(downTime, eventTime, action, pointerCount, pp, pointerCoords, metaState, 0, xPrecision, yPrecision, deviceId, edgeFlags, source, flags);
    }
}",1,"/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param pointers The number of points that will be in this event.
 * @param pointerIds An array of <em>pointers</em> values providing
 * an identifier for each pointer.
 * @param pointerCoords An array of <em>pointers</em> values providing
 * a {@link PointerCoords} coordinate object for each pointer.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 * @param source The source of this event.
 * @param flags The motion event flags.
 */
","/**
 * Create a new MotionEvent, filling in all of the basic values that
 * define the motion.
 *
 * @param downTime The time (in ms) when the user originally pressed down to start
 * a stream of position events.  This must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param eventTime The the time (in ms) when this specific event was generated.  This
 * must be obtained from {@link SystemClock#uptimeMillis()}.
 * @param action The kind of action being performed, such as {@link #ACTION_DOWN}.
 * @param pointerCount The number of pointers that will be in this event.
 * @param pointerIds An array of <em>pointerCount</em> values providing
 * an identifier for each pointer.
 * @param pointerCoords An array of <em>pointerCount</em> values providing
 * a {@link PointerCoords} coordinate object for each pointer.
 * @param metaState The state of any meta / modifier keys that were in effect when
 * the event was generated.
 * @param xPrecision The precision of the X coordinate being reported.
 * @param yPrecision The precision of the Y coordinate being reported.
 * @param deviceId The id for the device that this event came from.  An id of
 * zero indicates that the event didn't come from a physical device; other
 * numbers are arbitrary and you shouldn't depend on the values.
 * @param edgeFlags A bitfield indicating which edges, if any, were touched by this
 * MotionEvent.
 * @param source The source of this event.
 * @param flags The motion event flags.
 *
 * @deprecated Use {@link #obtain(long, long, int, int, PointerProperties[], PointerCoords[], int, int, float, float, int, int, int, int)}
 * instead.
 */
",1,,[@Deprecated],1,,,,,,,"1,4",1,"The entire method body has changed. A new control block (synchronized block) and a different method call to 'obtain()' with different parameter list are introduced, which constitute an 'Other statement changed'. Additionally, since the method now constructs the MotionEvent object differently, this constitutes a 'Return statement changed'.","The 'obtain' method previously was calling nativeInitialize directly with a conversion from milliseconds to nanoseconds for the time variables, but now it initializes a MotionEvent object differently, with a different set of temporary shared objects and without the direct call to nativeInitialize. This could result in a MotionEvent object that behaves differently, especially considering temporal and pointer properties, thus potentially returning a different object, which is a Compatibility Issue of type 1 caused by potential different return values."
972,<android.view.accessibility.AccessibilityEvent: String toString()>,13,14,,,,"{
    StringBuilder builder = new StringBuilder();
    builder.append(super.toString());
    builder.append(""; EventType: "" + mEventType);
    builder.append(""; EventTime: "" + mEventTime);
    builder.append(""; ClassName: "" + mClassName);
    builder.append(""; PackageName: "" + mPackageName);
    builder.append(""; Text: "" + mText);
    builder.append(""; ContentDescription: "" + mContentDescription);
    builder.append(""; ItemCount: "" + mItemCount);
    builder.append(""; CurrentItemIndex: "" + mCurrentItemIndex);
    builder.append(""; IsEnabled: "" + isEnabled());
    builder.append(""; IsPassword: "" + isPassword());
    builder.append(""; IsChecked: "" + isChecked());
    builder.append(""; IsFullScreen: "" + isFullScreen());
    builder.append(""; BeforeText: "" + mBeforeText);
    builder.append(""; FromIndex: "" + mFromIndex);
    builder.append(""; AddedCount: "" + mAddedCount);
    builder.append(""; RemovedCount: "" + mRemovedCount);
    builder.append(""; ParcelableData: "" + mParcelableData);
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""EventType: "").append(eventTypeToString(mEventType));
    builder.append(""; EventTime: "").append(mEventTime);
    builder.append(""; PackageName: "").append(mPackageName);
    builder.append(super.toString());
    if (DEBUG) {
        builder.append(""\n"");
        builder.append(""; sourceWindowId: "").append(mSourceWindowId);
        builder.append(""; sourceViewId: "").append(mSourceViewId);
        for (int i = 0; i < mRecords.size(); i++) {
            AccessibilityRecord record = mRecords.get(i);
            builder.append(""  Record "");
            builder.append(i);
            builder.append("":"");
            builder.append("" [ ClassName: "" + record.mClassName);
            builder.append(""; Text: "" + record.mText);
            builder.append(""; ContentDescription: "" + record.mContentDescription);
            builder.append(""; ItemCount: "" + record.mItemCount);
            builder.append(""; CurrentItemIndex: "" + record.mCurrentItemIndex);
            builder.append(""; IsEnabled: "" + record.isEnabled());
            builder.append(""; IsPassword: "" + record.isPassword());
            builder.append(""; IsChecked: "" + record.isChecked());
            builder.append(""; IsFullScreen: "" + record.isFullScreen());
            builder.append(""; Scrollable: "" + record.isScrollable());
            builder.append(""; BeforeText: "" + record.mBeforeText);
            builder.append(""; FromIndex: "" + record.mFromIndex);
            builder.append(""; ToIndex: "" + record.mToIndex);
            builder.append(""; ScrollX: "" + record.mScrollX);
            builder.append(""; ScrollY: "" + record.mScrollY);
            builder.append(""; AddedCount: "" + record.mAddedCount);
            builder.append(""; RemovedCount: "" + record.mRemovedCount);
            builder.append(""; ParcelableData: "" + record.mParcelableData);
            builder.append("" ]"");
            builder.append(""\n"");
        }
    } else {
        builder.append(""; recordCount: "").append(getRecordCount());
    }
    return builder.toString();
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",1,"Multiple parts of the toString method have been changed. The assembling of the StringBuilder has been modified significantly, with a different method call (eventTypeToString(mEventType)), reordered content appending, and a new conditional DEBUG block. Thus the change categories are 1 and 4 (return statement changed, other statement changed).","Because the return statement has been altered to include additional information conditionally and changed the order of appended elements, the resulting string potentially returns different content. This constitutes a different return type or value, which can lead to a compatibility issue, so the CI type is 1."
973,<android.app.WallpaperManager: Drawable getFastDrawable()>,13,14,,,,"{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        Drawable dr = new FastBitmapDrawable(bm);
        return dr;
    }
    return null;
}","{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}",1,"/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
","/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */
",0,,,0,,,,,,,0,0,"The change between the two versions is the inline creation and return of the `Drawable` without assigning it to a local variable first. The actual behavior of the code, including the creation and returning of the `Drawable`, did not change.",Since the change does not affect the behavior of the method—both versions return the same `Drawable` when `bm` is not null and `null` otherwise—there is no Compatibility Issue.
974,<android.webkit.WebView: WebBackForwardList copyBackForwardList()>,13,14,,,,"{
    return mCallbackProxy.getBackForwardList().clone();
}","{
    checkThread();
    return mCallbackProxy.getBackForwardList().clone();
}",1,"/**
 * Return the WebBackForwardList for this WebView. This contains the
 * back/forward list for use in querying each item in the history stack.
 * This is a copy of the private WebBackForwardList so it contains only a
 * snapshot of the current state. Multiple calls to this method may return
 * different objects. The object returned from this method will not be
 * updated to reflect any new state.
 */
","/**
 * Return the WebBackForwardList for this WebView. This contains the
 * back/forward list for use in querying each item in the history stack.
 * This is a copy of the private WebBackForwardList so it contains only a
 * snapshot of the current state. Multiple calls to this method may return
 * different objects. The object returned from this method will not be
 * updated to reflect any new state.
 */
",0,,,0,,,,,,,4,0,"A new method call `checkThread();` has been added at the beginning of the function, so the code change type is 4.","The addition of `checkThread()` does not constitute a compatibility issue as it does not affect the method's return value or the exception that it throws. It is likely for internal thread-safety checks, which should be transparent to the caller. Thus, there is no Compatibility Issue, and the CI type is 0."
975,"<android.database.CursorWindow: byte[] getBlob(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return getBlob_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeGetBlob(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Returns a byte array for the given field.
 *
 * @param row the row to read from, row - getStartPosition() being the actual row in the window
 * @param col the column to read from
 * @return a String value for the given field
 */
","/**
 * Gets the value of the field at the specified row and column index as a byte array.
 * <p>
 * The result is determined as follows:
 * <ul>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the result
 * is <code>null</code>.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then the result
 * is the blob value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the result
 * is the array of bytes that make up the internal representation of the
 * string value.</li>
 * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER} or
 * {@link Cursor#FIELD_TYPE_FLOAT}, then a {@link SQLiteException} is thrown.</li>
 * </ul>
 * </p>
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return The value of the field as a byte array.
 */
",1,,,0,,,,,,,"1,5",1,"The function called inside the return statement has been changed from getBlob_native(int, int) to nativeGetBlob(long, int, int), and the late version introduces an additional parameter (mWindowPtr), so the code change is classified as 1,5.","Because the dependent method has changed and now seems to expect an additional parameter, the behavior and potentially the returned value of this method could differ, which indicates a CI in category 1."
978,<android.appwidget.AppWidgetManager: List<AppWidgetProviderInfo> getInstalledProviders()>,13,14,,,,"{
    try {
        List<AppWidgetProviderInfo> providers = sService.getInstalledProviders();
        for (AppWidgetProviderInfo info : providers) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
        }
        return providers;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}","{
    try {
        List<AppWidgetProviderInfo> providers = sService.getInstalledProviders();
        for (AppWidgetProviderInfo info : providers) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return providers;
    } catch (RemoteException e) {
        throw new RuntimeException(""system server dead?"", e);
    }
}",1,"/**
 * Return a list of the AppWidget providers that are currently installed.
 */
","/**
 * Return a list of the AppWidget providers that are currently installed.
 */
",0,,,0,,,,,,,4,0,"The implementation now includes two additional lines of code that convert the complex values of minResizeWidth and minResizeHeight to dimension pixel sizes, so the code change type is 4.","The additional lines of code are augmenting the AppWidgetProviderInfo objects with more information by setting the minResizeWidth and minResizeHeight in the pixel dimensions. These changes do not alter the control flow, exception handling, or the method signature; they do not affect compatibility as they are enhancing the objects with more data rather than altering existing behavior. The return type remains the same (List<AppWidgetProviderInfo>) and no new exceptions are introduced. Therefore, there is no compatibility issue."
979,"<android.database.sqlite.SQLiteQueryBuilder: Cursor query(SQLiteDatabase,String[],String,String[],String,String,String,String)>",13,14,,,,"{
    if (mTables == null) {
        return null;
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, SQLiteDatabase.findEditTable(mTables));
}","{
    if (mTables == null) {
        return null;
    }
    if (mStrict && selection != null && selection.length() > 0) {
        // Validate the user-supplied selection to detect syntactic anomalies
        // in the selection string that could indicate a SQL injection attempt.
        // The idea is to ensure that the selection clause is a valid SQL expression
        // by compiling it twice: once wrapped in parentheses and once as
        // originally specified. An attacker cannot create an expression that
        // would escape the SQL expression while maintaining balanced parentheses
        // in both the wrapped and original forms.
        String sqlForValidation = buildQuery(projectionIn, ""("" + selection + "")"", groupBy, having, sortOrder, limit);
        // will throw if query is invalid
        validateSql(db, sqlForValidation);
    }
    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, ""Performing query: "" + sql);
    }
    return db.rawQueryWithFactory(mFactory, sql, selectionArgs, // will throw if query is invalid
    SQLiteDatabase.findEditTable(mTables));
}",1,"/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
","/**
 * Perform a query by combining all current settings and the
 * information passed into this method.
 *
 * @param db the database to query on
 * @param projectionIn A list of which columns to return. Passing
 * null will return all columns, which is discouraged to prevent
 * reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,
 * formatted as an SQL WHERE clause (excluding the WHERE
 * itself). Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, which
 * will be replaced by the values from selectionArgs, in order
 * that they appear in the selection. The values will be bound
 * as Strings.
 * @param groupBy A filter declaring how to group rows, formatted
 * as an SQL GROUP BY clause (excluding the GROUP BY
 * itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in
 * the cursor, if row grouping is being used, formatted as an
 * SQL HAVING clause (excluding the HAVING itself).  Passing
 * null will cause all row groups to be included, and is
 * required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQL
 * ORDER BY clause (excluding the ORDER BY itself). Passing null
 * will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,
 * formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return a cursor over the result set
 * @see android.content.ContentResolver#query(android.net.Uri, String[],
 * String, String[], String)
 */
",0,,,0,,,,,,,"3,4",0,"The late version introduces a new block of code to validate a user-supplied selection string, which is an additional control structure. This is a control dependency change (3). Additionally, the comment ""will throw if query is invalid"" is added next to the return statement, which is an other statement change (4).","Even though there are new statements introduced, they are designed for security (validation) and will not affect the normal execution flow assuming the client's SQL is valid. In case of a SQL injection attempt or invalid query, it will throw an exception where previously it would not have thrown; however, that is part of intended improved behavior for security reasons. So this doesn't qualify as a compatibility issue since it enforces a constraint that should be met by correct client code. It adds an additional layer of security without altering the functional return behavior for correct client code. Therefore, there is no Compatibility Issue (0)."
980,"<android.widget.AbsListView: void setItemChecked(int,boolean)>",13,14,,,,"{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        if (oldValue != value) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), Boolean.TRUE);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}","{
    if (mChoiceMode == CHOICE_MODE_NONE) {
        return;
    }
    // Start selection mode if needed. We don't need to if we're unchecking something.
    if (value && mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL && mChoiceActionMode == null) {
        mChoiceActionMode = startActionMode(mMultiChoiceModeCallback);
    }
    if (mChoiceMode == CHOICE_MODE_MULTIPLE || mChoiceMode == CHOICE_MODE_MULTIPLE_MODAL) {
        boolean oldValue = mCheckStates.get(position);
        mCheckStates.put(position, value);
        if (mCheckedIdStates != null && mAdapter.hasStableIds()) {
            if (value) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            } else {
                mCheckedIdStates.delete(mAdapter.getItemId(position));
            }
        }
        if (oldValue != value) {
            if (value) {
                mCheckedItemCount++;
            } else {
                mCheckedItemCount--;
            }
        }
        if (mChoiceActionMode != null) {
            final long id = mAdapter.getItemId(position);
            mMultiChoiceModeCallback.onItemCheckedStateChanged(mChoiceActionMode, position, id, value);
        }
    } else {
        boolean updateIds = mCheckedIdStates != null && mAdapter.hasStableIds();
        // selected item
        if (value || isItemChecked(position)) {
            mCheckStates.clear();
            if (updateIds) {
                mCheckedIdStates.clear();
            }
        }
        // we ensure length of mCheckStates is 1, a fact getCheckedItemPosition relies on
        if (value) {
            mCheckStates.put(position, true);
            if (updateIds) {
                mCheckedIdStates.put(mAdapter.getItemId(position), position);
            }
            mCheckedItemCount = 1;
        } else if (mCheckStates.size() == 0 || !mCheckStates.valueAt(0)) {
            mCheckedItemCount = 0;
        }
    }
    // Do not generate a data change while we are in the layout phase
    if (!mInLayout && !mBlockLayoutRequests) {
        mDataChanged = true;
        rememberSyncState();
        requestLayout();
    }
}",1,"/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
","/**
 * Sets the checked state of the specified position. The is only valid if
 * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or
 * {@link #CHOICE_MODE_MULTIPLE}.
 *
 * @param position The item whose checked state is to be checked
 * @param value The new checked state for the item
 */
",0,,,0,,,,,,,4,0,"The code change is an update in the value put into `mCheckedIdStates` from `Boolean.TRUE` to `position` in two places. This is an Other statement change, thus the change type is 4.","While this change could affect the internal state of `mCheckedIdStates`, it does not constitute a compatibility issue according to the given rules, as the method's return type is `void` and does not throw exceptions. The behavior and interaction with `setItemChecked` remain consistent from the perspective of the API's caller. Thus, the CI type is 0."
981,<android.database.BulkCursorProxy: void onMove(int)>,13,14,,,,"{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IBulkCursor.descriptor);
    data.writeInt(position);
    mRemote.transact(ON_MOVE_TRANSACTION, data, reply, 0);
    DatabaseUtils.readExceptionFromParcel(reply);
    data.recycle();
    reply.recycle();
}","{
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    try {
        data.writeInterfaceToken(IBulkCursor.descriptor);
        data.writeInt(position);
        mRemote.transact(ON_MOVE_TRANSACTION, data, reply, 0);
        DatabaseUtils.readExceptionFromParcel(reply);
    } finally {
        data.recycle();
        reply.recycle();
    }
}",1,,,0,,,0,,,,,,,4,0,"The only change here is the addition of a try-finally block to ensure that `data` and `reply` are recycled in case an exception occurs. The primary code logic remains the same, and there are no changes to return statements, exception handling, control dependency, or dependent APIs. The code change type is 4 because this is a structural code improvement without altering the functionality.","There is no change affecting the behavior of the method, as the try-finally block simply ensures the proper recycling of parcels even when exceptions occur. The method's external behavior, in terms of the return value or the exceptions it throws, remains identical. Therefore, there are no compatibility issues introduced by this change."
982,<android.server.BluetoothService: List<BluetoothDevice> getConnectedInputDevices()>,13,14,,,,"{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    return mBluetoothInputProfileHandler.getConnectedInputDevices();
}","{
    mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.getConnectedInputDevices();
    }
}",1,,,0,,,0,,,,,,,3,0,"The introduction of the synchronized block around the return statement is the only change, which corresponds to a control dependency change, hence the code change type is 3.","There's no Compatibility Issue with respect to return values or exception handling, as the synchronized block solely ensures thread safety and does not affect the behaviour of the method's return value or the exception it might throw. Thus, the CI type is 0."
985,"<android.animation.PropertyValuesHolder: PropertyValuesHolder ofFloat(String,float)>",13,14,,,,"{
    PropertyValuesHolder pvh = new FloatPropertyValuesHolder(propertyName, values);
    return pvh;
}","{
    return new FloatPropertyValuesHolder(propertyName, values);
}",1,"/**
 * Constructs and returns a PropertyValuesHolder with a given property name and
 * set of float values.
 * @param propertyName The name of the property being animated.
 * @param values The values that the named property will animate between.
 * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
 */
","/**
 * Constructs and returns a PropertyValuesHolder with a given property name and
 * set of float values.
 * @param propertyName The name of the property being animated.
 * @param values The values that the named property will animate between.
 * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
 */
",0,,,0,,,,,,,0,0,The change is just a refactoring from using an intermediate local variable to return the new object directly. There is no effective change in behavior or output of the method.,"There is no Compatibility Issue since the behavior of the API has not changed; the same object type is being returned, and no new exceptions or return values have been introduced."
986,<android.speech.tts.TextToSpeech: int setPitch(float)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        try {
            // with all upcoming utterances.
            if (pitch > 0) {
                int p = (int) (pitch * 100);
                mCachedParams[Engine.PARAM_POSITION_PITCH + 1] = String.valueOf(p);
                result = SUCCESS;
            }
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - setPitch"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    if (pitch > 0.0f) {
        int intPitch = (int) (pitch * 100);
        if (intPitch > 0) {
            synchronized (mStartLock) {
                mParams.putInt(Engine.KEY_PARAM_PITCH, intPitch);
            }
            return SUCCESS;
        }
    }
    return ERROR;
}",1,"/**
 * Sets the speech pitch for the TextToSpeech engine.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param pitch
 * The pitch for the TextToSpeech engine. 1 is the normal pitch,
 * lower values lower the tone of the synthesized voice,
 * greater values increase it.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Sets the speech pitch for the TextToSpeech engine.
 *
 * This has no effect on any pre-recorded speech.
 *
 * @param pitch Speech pitch. {@code 1.0} is the normal pitch,
 * lower values lower the tone of the synthesized voice,
 * greater values increase it.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4",1,"The return statements and the control dependency have changed, with the removal of try-catch blocks, a new if condition, and a rearrangement of synchronized block and other logical changes in the method. This includes changes to exception handling and the moments when return statements are reached. Moreover, synchronization is now applied to a different code block and also there is a change in the API used to set the pitch parameters (from mCachedParams with an index to mParams with a key). Thus, the code change types are 1,3,4.","As the result variable is no longer returned within a try-catch block, and with the revised logic before returning SUCCESS or ERROR, this change could lead to the API returning different values under certain conditions. Additionally, the code no longer catches exceptions like NullPointerException and IllegalStateException, instead allowing them to propagate up the call stack. Therefore, there is a CI due to potential different return values or types (type 1) and different exception handlings (type 2)."
988,"<android.text.Layout: void draw(Canvas,Path,Paint,int)>",13,14,,,,"{
    int dtop, dbottom;
    synchronized (sTempRect) {
        if (!c.getClipBounds(sTempRect)) {
            return;
        }
        dtop = sTempRect.top;
        dbottom = sTempRect.bottom;
    }
    int top = 0;
    int bottom = getLineTop(getLineCount());
    if (dtop > top) {
        top = dtop;
    }
    if (dbottom < bottom) {
        bottom = dbottom;
    }
    int first = getLineForVertical(top);
    int last = getLineForVertical(bottom);
    int previousLineBottom = getLineTop(first);
    int previousLineEnd = getLineStart(first);
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    int width = mWidth;
    boolean spannedText = mSpannedText;
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    int textLength = 0;
    // They are evaluated at each line.
    if (spannedText) {
        Spanned sp = (Spanned) buf;
        textLength = buf.length();
        for (int i = first; i <= last; i++) {
            int start = previousLineEnd;
            int end = getLineStart(i + 1);
            previousLineEnd = end;
            int ltop = previousLineBottom;
            int lbottom = getLineTop(i + 1);
            previousLineBottom = lbottom;
            int lbaseline = lbottom - getLineDescent(i);
            if (start >= spanEnd) {
                // These should be infrequent, so we'll use this so that
                // we don't have to check as often.
                spanEnd = sp.nextSpanTransition(start, textLength, LineBackgroundSpan.class);
                // All LineBackgroundSpans on a line contribute to its
                // background.
                spans = getParagraphSpans(sp, start, end, LineBackgroundSpan.class);
            }
            for (int n = 0; n < spans.length; n++) {
                LineBackgroundSpan back = (LineBackgroundSpan) spans[n];
                back.drawBackground(c, paint, 0, width, ltop, lbaseline, lbottom, buf, start, end, i);
            }
        }
        // reset to their original values
        spanEnd = 0;
        previousLineBottom = getLineTop(first);
        previousLineEnd = getLineStart(first);
        spans = NO_PARA_SPANS;
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0) {
            c.translate(0, cursorOffsetVertical);
        }
        c.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0) {
            c.translate(0, -cursorOffsetVertical);
        }
    }
    Alignment align = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // line's descent.
    for (int i = first; i <= last; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (spannedText) {
            Spanned sp = (Spanned) buf;
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == first || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                align = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        align = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    boolean useFirstLineMargin = isFirstParaLine;
                    if (margin instanceof LeadingMarginSpan2) {
                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                        int startLine = getLineForOffset(sp.getSpanStart(margin));
                        useFirstLineMargin = i < startLine + count;
                    }
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(c, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(c, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            c.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(c, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}","{
    int dtop, dbottom;
    synchronized (sTempRect) {
        if (!c.getClipBounds(sTempRect)) {
            return;
        }
        dtop = sTempRect.top;
        dbottom = sTempRect.bottom;
    }
    int top = 0;
    int bottom = getLineTop(getLineCount());
    if (dtop > top) {
        top = dtop;
    }
    if (dbottom < bottom) {
        bottom = dbottom;
    }
    int first = getLineForVertical(top);
    int last = getLineForVertical(bottom);
    int previousLineBottom = getLineTop(first);
    int previousLineEnd = getLineStart(first);
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    int width = mWidth;
    boolean spannedText = mSpannedText;
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    int textLength = 0;
    // They are evaluated at each line.
    if (spannedText) {
        Spanned sp = (Spanned) buf;
        textLength = buf.length();
        for (int i = first; i <= last; i++) {
            int start = previousLineEnd;
            int end = getLineStart(i + 1);
            previousLineEnd = end;
            int ltop = previousLineBottom;
            int lbottom = getLineTop(i + 1);
            previousLineBottom = lbottom;
            int lbaseline = lbottom - getLineDescent(i);
            if (start >= spanEnd) {
                // These should be infrequent, so we'll use this so that
                // we don't have to check as often.
                spanEnd = sp.nextSpanTransition(start, textLength, LineBackgroundSpan.class);
                // All LineBackgroundSpans on a line contribute to its
                // background.
                spans = getParagraphSpans(sp, start, end, LineBackgroundSpan.class);
            }
            for (int n = 0; n < spans.length; n++) {
                LineBackgroundSpan back = (LineBackgroundSpan) spans[n];
                back.drawBackground(c, paint, 0, width, ltop, lbaseline, lbottom, buf, start, end, i);
            }
        }
        // reset to their original values
        spanEnd = 0;
        previousLineBottom = getLineTop(first);
        previousLineEnd = getLineStart(first);
        spans = NO_PARA_SPANS;
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0) {
            c.translate(0, cursorOffsetVertical);
        }
        c.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0) {
            c.translate(0, -cursorOffsetVertical);
        }
    }
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // line's descent.
    for (int i = first; i <= last; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (spannedText) {
            Spanned sp = (Spanned) buf;
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == first || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    boolean useFirstLineMargin = isFirstParaLine;
                    if (margin instanceof LeadingMarginSpan2) {
                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                        int startLine = getLineForOffset(sp.getSpanStart(margin));
                        useFirstLineMargin = i < startLine + count;
                    }
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(c, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(c, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            c.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(c, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}",1,"/**
 * Draw this Layout on the specified canvas, with the highlight path drawn
 * between the background and the text.
 *
 * @param c the canvas
 * @param highlight the path of the highlight or cursor; can be null
 * @param highlightPaint the paint for the highlight
 * @param cursorOffsetVertical the amount to temporarily translate the
 * canvas while rendering the highlight
 */
","/**
 * Draw this Layout on the specified canvas, with the highlight path drawn
 * between the background and the text.
 *
 * @param c the canvas
 * @param highlight the path of the highlight or cursor; can be null
 * @param highlightPaint the paint for the highlight
 * @param cursorOffsetVertical the amount to temporarily translate the
 * canvas while rendering the highlight
 */
",0,,,0,,,,,,,,,,
989,"<android.widget.ListView: void addHeaderView(View,Object,boolean)>",13,14,,,,"{
    if (mAdapter != null) {
        throw new IllegalStateException(""Cannot add header view to list -- setAdapter has already been called."");
    }
    FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mHeaderViewInfos.add(info);
}","{
    if (mAdapter != null && !(mAdapter instanceof HeaderViewListAdapter)) {
        throw new IllegalStateException(""Cannot add header view to list -- setAdapter has already been called."");
    }
    FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mHeaderViewInfos.add(info);
    // we need to notify the observer
    if (mAdapter != null && mDataSetObserver != null) {
        mDataSetObserver.onChanged();
    }
}",1,"/**
 * Add a fixed view to appear at the top of the list. If addHeaderView is
 * called more than once, the views will appear in the order they were
 * added. Views added using this call can take focus if they want.
 * <p>
 * NOTE: Call this before calling setAdapter. This is so ListView can wrap
 * the supplied cursor with one that will also account for header and footer
 * views.
 *
 * @param v The view to add.
 * @param data Data to associate with this view
 * @param isSelectable whether the item is selectable
 */
","/**
 * Add a fixed view to appear at the top of the list. If addHeaderView is
 * called more than once, the views will appear in the order they were
 * added. Views added using this call can take focus if they want.
 * <p>
 * NOTE: Call this before calling setAdapter. This is so ListView can wrap
 * the supplied cursor with one that will also account for header and footer
 * views.
 *
 * @param v The view to add.
 * @param data Data to associate with this view
 * @param isSelectable whether the item is selectable
 */
",0,,,0,,,,,,,"3,4",0,"There is a change in the condition that checks if the mAdapter is an instance of HeaderViewListAdapter, and there is a new control structure (if statement) that checks for mAdapter and mDataSetObserver followed by a method call. Thus, the code change types are 3 for the control dependency change due to the new if condition, and 4 for other statement changed due to the addition of the method call to onChanged().","Although there is a change in the execution path and new method call, neither of these would directly lead to a different return value or type (as the method is void) and would not result in different exception handling (no new exceptions are thrown). There's an assumption that existing apps that are extending ListView and setting a custom adapter that is not a HeaderViewListAdapter would have been misusing the API and would have encountered the IllegalStateException before the change as well. Therefore, we can assert that there is No Compatibility Issue."
991,"<android.server.BluetoothService: void dump(FileDescriptor,PrintWriter,String[])>",13,14,,,,"{
    dumpBluetoothState(pw);
    if (mBluetoothState != BluetoothAdapter.STATE_ON) {
        return;
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.PAN);
    dumpKnownDevices(pw);
    dumpAclConnectedDevices(pw);
    dumpHeadsetService(pw);
    dumpInputDeviceProfile(pw);
    dumpPanProfile(pw);
    dumpApplicationServiceRecords(pw);
}","{
    if (getBluetoothStateInternal() != BluetoothAdapter.STATE_ON) {
        return;
    }
    pw.println(""mIsAirplaneSensitive = "" + mIsAirplaneSensitive);
    pw.println(""mIsAirplaneToggleable = "" + mIsAirplaneToggleable);
    pw.println(""Local address = "" + getAddress());
    pw.println(""Local name = "" + getName());
    pw.println(""isDiscovering() = "" + isDiscovering());
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.HEADSET);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.INPUT_DEVICE);
    mAdapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.PAN);
    dumpKnownDevices(pw);
    dumpAclConnectedDevices(pw);
    dumpHeadsetService(pw);
    dumpInputDeviceProfile(pw);
    dumpPanProfile(pw);
    dumpApplicationServiceRecords(pw);
    dumpProfileState(pw);
}",1,,,0,[@Override],[@Override],0,,,,,,,"1,4",0,"The method `dumpBluetoothState(pw)` is deleted, and a new method `getBluetoothStateInternal()` is used in the early return check instead of directly checking `mBluetoothState`. Also, a new method `dumpProfileState(pw)` has been added to the end of the method. The change types are 1 and 4 since there is both a change in the content of the return check and an additional statement at the end of the method.","Although there are changes in the method, these changes do not lead to different return values or types, nor a different exception handling, as the method return type is `void`, and no new exceptions are introduced. Thus, there is no Compatibility Issue (Type 0)."
992,<android.server.BluetoothService: List<BluetoothDevice> lookupInputDevicesMatchingStates(int[])>,13,14,,,,"{
    return mBluetoothInputProfileHandler.lookupInputDevicesMatchingStates(states);
}","{
    synchronized (mBluetoothInputProfileHandler) {
        return mBluetoothInputProfileHandler.lookupInputDevicesMatchingStates(states);
    }
}",1,"/*package*/
","/*package*/
",0,,,0,,,,,,,"3,4",0,"The addition of the synchronized block around the existing return statement is the only change made, so the code change is synchronized-related (4). Additionally, since it's adding a control structure, it falls under the control dependency change (3).","The synchronized block ensures thread-safe execution but does not change the behavior of the returned value from the method or add a new exception handling path. Therefore, there's no Compatibility Issue (0) from this change."
994,"<android.accounts.AbstractAccountAuthenticator.Transport: void addAccount(IAccountAuthenticatorResponse,String,String,String[],Bundle)>",13,14,,,,"{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (NetworkErrorException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""addAccount"", e);
        }
        response.onError(AccountManager.ERROR_CODE_NETWORK_ERROR, e.getMessage());
    } catch (UnsupportedOperationException e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""addAccount"", e);
        }
        response.onError(AccountManager.ERROR_CODE_UNSUPPORTED_OPERATION, ""addAccount not supported"");
    }
}","{
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, ""addAccount: accountType "" + accountType + "", authTokenType "" + authTokenType + "", features "" + (features == null ? ""[]"" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            // force it to be unparcelled
            result.keySet();
            Log.v(TAG, ""addAccount: result "" + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        }
    } catch (Exception e) {
        handleException(response, ""addAccount"", accountType, e);
    }
}",1,,,0,,,0,,,,,,,"2,3,4",2,"The exception handling has been abstracted to a single catch block for a broad 'Exception' type and a call to 'handleException' method, the log statement within 'catch' block has been removed, and the control dependency has changed as a result. This constitutes change types 2, 3, and 4.","The late version API implements a broader catch clause (catching `Exception` instead of more specific exceptions like `NetworkErrorException` and `UnsupportedOperationException`), which changes the exception handling behavior. It may handle exceptions differently, specifically, it would catch all exceptions and handle them using the `handleException` method rather than reporting specific error codes for known exception types. Therefore, the CI type is 2."
996,<android.speech.tts.TextToSpeech: int setOnUtteranceCompletedListener(OnUtteranceCompletedListener)>,13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        if (!mStarted) {
            return result;
        }
        mITtscallback = new ITtsCallback.Stub() {

            public void utteranceCompleted(String utteranceId) throws RemoteException {
                if (listener != null) {
                    listener.onUtteranceCompleted(utteranceId);
                }
            }
        };
        try {
            result = mITts.registerCallback(mPackageName, mITtscallback);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - registerCallback"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - registerCallback"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - registerCallback"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            return result;
        }
    }
}","{
    mUtteranceCompletedListener = listener;
    return TextToSpeech.SUCCESS;
}",1,"/**
 * Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
 *
 * @param listener
 * The OnUtteranceCompletedListener
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Sets the listener that will be notified when synthesis of an utterance completes.
 *
 * @param listener The listener to use.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,2,3,4","1,2","A return statement is replaced, several exception handling statements are removed, a new field assignment is introduced, and the whole synchronized block containing control flow has been removed, thus the code change types are 1,2,3,4.","The method no longer handles exceptions nor assigns the callback through a service registration process; it simply sets a field and returns a constant value, which leads both to potential different return values or types as well as different exceptions being thrown (or in this case, not thrown), therefore the CI types are 1,2."
1000,"<android.content.IntentFilter: int match(String,String,String,Uri,Set<String>,String)>",13,14,,,,"{
    if (action != null && !matchAction(action)) {
        if (Config.LOGV)
            Log.v(logTag, ""No matching action "" + action + "" for "" + this);
        return NO_MATCH_ACTION;
    }
    int dataMatch = matchData(type, scheme, data);
    if (dataMatch < 0) {
        if (Config.LOGV) {
            if (dataMatch == NO_MATCH_TYPE) {
                Log.v(logTag, ""No matching type "" + type + "" for "" + this);
            }
            if (dataMatch == NO_MATCH_DATA) {
                Log.v(logTag, ""No matching scheme/path "" + data + "" for "" + this);
            }
        }
        return dataMatch;
    }
    String categoryMismatch = matchCategories(categories);
    if (categoryMismatch != null) {
        if (Config.LOGV) {
            Log.v(logTag, ""No matching category "" + categoryMismatch + "" for "" + this);
        }
        return NO_MATCH_CATEGORY;
    }
    // important than ones that can be embedded, but this is not the way...
    if (false) {
        if (categories != null) {
            dataMatch -= mCategories.size() - categories.size();
        }
    }
    return dataMatch;
}","{
    if (action != null && !matchAction(action)) {
        if (false)
            Log.v(logTag, ""No matching action "" + action + "" for "" + this);
        return NO_MATCH_ACTION;
    }
    int dataMatch = matchData(type, scheme, data);
    if (dataMatch < 0) {
        if (false) {
            if (dataMatch == NO_MATCH_TYPE) {
                Log.v(logTag, ""No matching type "" + type + "" for "" + this);
            }
            if (dataMatch == NO_MATCH_DATA) {
                Log.v(logTag, ""No matching scheme/path "" + data + "" for "" + this);
            }
        }
        return dataMatch;
    }
    String categoryMismatch = matchCategories(categories);
    if (categoryMismatch != null) {
        if (false) {
            Log.v(logTag, ""No matching category "" + categoryMismatch + "" for "" + this);
        }
        return NO_MATCH_CATEGORY;
    }
    // important than ones that can be embedded, but this is not the way...
    if (false) {
        if (categories != null) {
            dataMatch -= mCategories.size() - categories.size();
        }
    }
    return dataMatch;
}",1,"/**
 * Test whether this filter matches the given intent data.  A match is
 * only successful if the actions and categories in the Intent match
 * against the filter, as described in {@link IntentFilter}; in that case,
 * the match result returned will be as per {@link #matchData}.
 *
 * @param action The intent action to match against (Intent.getAction).
 * @param type The intent type to match against (Intent.resolveType()).
 * @param scheme The data scheme to match against (Intent.getScheme()).
 * @param data The data URI to match against (Intent.getData()).
 * @param categories The categories to match against
 * (Intent.getCategories()).
 * @param logTag Tag to use in debugging messages.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,
 * {@link #NO_MATCH_DATA} if the scheme/path didn't match,
 * {@link #NO_MATCH_ACTION if the action didn't match, or
 * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.
 *
 * @see #matchData
 * @see Intent#getAction
 * @see Intent#resolveType
 * @see Intent#getScheme
 * @see Intent#getData
 * @see Intent#getCategories
 */
","/**
 * Test whether this filter matches the given intent data.  A match is
 * only successful if the actions and categories in the Intent match
 * against the filter, as described in {@link IntentFilter}; in that case,
 * the match result returned will be as per {@link #matchData}.
 *
 * @param action The intent action to match against (Intent.getAction).
 * @param type The intent type to match against (Intent.resolveType()).
 * @param scheme The data scheme to match against (Intent.getScheme()).
 * @param data The data URI to match against (Intent.getData()).
 * @param categories The categories to match against
 * (Intent.getCategories()).
 * @param logTag Tag to use in debugging messages.
 *
 * @return Returns either a valid match constant (a combination of
 * {@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}),
 * or one of the error codes {@link #NO_MATCH_TYPE} if the type didn't match,
 * {@link #NO_MATCH_DATA} if the scheme/path didn't match,
 * {@link #NO_MATCH_ACTION if the action didn't match, or
 * {@link #NO_MATCH_CATEGORY} if one or more categories didn't match.
 *
 * @see #matchData
 * @see Intent#getAction
 * @see Intent#resolveType
 * @see Intent#getScheme
 * @see Intent#getData
 * @see Intent#getCategories
 */
",0,,,0,,,,,,,4,0,"The only change is replacing the condition `Config.LOGV` with `false` for the debugging log statements, which does not affect the logic of the code since these are non-functional changes that primarily affect logging and not the behavior of the method. The code change type is 4.","The changes made do not impact the return values or exception handling of the method; thus, there is no Compatibility Issue. The debugging statements are effectively disabled, which does not change the API's behavior from a client's perspective."
1001,"<android.view.GLES20Canvas: void drawText(String,float,float,Paint)>",13,14,,,,"{
    boolean hasModifier = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, 0, text.length(), x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (hasModifier)
            nResetModifiers(mRenderer);
    }
}","{
    int modifiers = setupModifiers(paint);
    try {
        nDrawText(mRenderer, text, 0, text.length(), x, y, paint.mBidiFlags, paint.mNativePaint);
    } finally {
        if (modifiers != MODIFIER_NONE)
            nResetModifiers(mRenderer, modifiers);
    }
}",1,,,0,[@Override],[@Override],0,,,,,,,"3,4",0,"The type of the variable 'hasModifier'/'modifiers' has changed, and there's an additional parameter in the call to nResetModifiers in the late version. However, these changes do not reflect a difference that would cause a behavior change in terms of API output or exception handling. The change was internal and related to how modifiers are handled, but the behavior of the method from the perspective of the API contract should remain unchanged. ","There is no Compatibility Issue, because the API's signature remains the same, the return type is void hence no change in return value or type, and no new exceptions are thrown (the exception handling remains consistent even though the internal management of modifiers has changed)."
1002,"<android.database.CursorWindow: boolean putNull(int,int)>",13,14,,,,"{
    acquireReference();
    try {
        return putNull_native(row - mStartPos, col);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativePutNull(mWindowPtr, row - mStartPos, column);
    } finally {
        releaseReference();
    }
}",1,"/**
 * Set the [row, col] value to NULL
 * @param row
 * @param col
 * @return false if fail to copy
 */
","/**
 * Puts a null value into the field at the specified row and column index.
 *
 * @param row The zero-based row index, relative to the cursor window's
 * start position ({@link #getStartPosition()}).
 * @param column The zero-based column index.
 * @return True if successful.
 */
",1,,,0,,,,,,,"1,5",1,"The method called within the return statement has changed from putNull_native(int,int) to nativePutNull(long,int,int), and an additional parameter is being passed in the late implementation. Thus, the change includes a modified method (dependent API changed) as well as a different return statement. The code change type is 1,5.","As the method called within the return statement is different and it includes an additional parameter, it may lead to a different behavior in terms of what value is returned. This constitutes a potential compatibility issue of type 1 caused by a potentially different return value."
1003,<android.accounts.AccountManagerService.Session: void onServiceDisconnected(ComponentName)>,13,14,,,,"{
    mAuthenticator = null;
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""disconnected"");
    }
}","{
    mAuthenticator = null;
    IAccountManagerResponse response = getResponseAndClose();
    if (response != null) {
        try {
            response.onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, ""disconnected"");
        } catch (RemoteException e) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""Session.onServiceDisconnected: "" + ""caught RemoteException while responding"", e);
            }
        }
    }
}",1,,,0,,,0,,,,,,,"2,3,4",2,"There is a control dependency change as well as exception handling statement change where the early version uses onError method within the authenticator but the late version includes additional try-catch block to handle RemoteException. There is also the introduction of logging when RemoteException is caught, categorized under other statement change. Therefore, the code change type is a combination of 2,3,4.","The early version does not handle RemoteExceptions during the onError call, leading potentially to an unhandled exception if the call failed, while the late version catches RemoteExceptions and logs them, changing the exception handling behavior of the method. Hence, the API would behave differently when encountering exceptions, which is why the CI type is 2."
1004,<android.view.View: float getTranslationX()>,13,14,,,,"{
    return mTranslationX;
}","{
    return mTransformationInfo != null ? mTransformationInfo.mTranslationX : 0;
}",1,"/**
 * The horizontal location of this view relative to its {@link #getLeft() left} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The horizontal position of this view relative to its left position, in pixels.
 */
","/**
 * The horizontal location of this view relative to its {@link #getLeft() left} position.
 * This position is post-layout, in addition to wherever the object's
 * layout placed it.
 *
 * @return The horizontal position of this view relative to its left position, in pixels.
 */
",0,,,0,,,,,,,1,1,"The return statement has been modified to return a different field or 0 if mTransformationInfo is null, instead of the previous direct return of mTranslationX. Thus the change type is 1.","This change in the return statement means the method could potentially return a different value depending on the state of mTransformationInfo, which constitutes a compatibility issue due to a potential different return value. The CI type is 1."
1005,<android.webkit.WebView: int getProgress()>,13,14,,,,"{
    return mCallbackProxy.getProgress();
}","{
    checkThread();
    return mCallbackProxy.getProgress();
}",1,"/**
 * Get the progress for the current page.
 * @return The progress for the current page between 0 and 100.
 */
","/**
 * Get the progress for the current page.
 * @return The progress for the current page between 0 and 100.
 */
",0,,,0,,,,,,,4,0,"An additional method call (checkThread()) has been introduced before the return statement; thus, the change type is 4.",The new method call (checkThread()) does not change the return value or the exception handling of the API but ensures that the code is running on the correct thread. This change should not cause any compatibility issues as it does not affect the outcome of the method; hence the CI type is 0.
1006,<android.database.sqlite.SQLiteQuery: String columnNameLocked(int)>,13,14,,,,"{
    acquireReference();
    try {
        return native_column_name(columnIndex);
    } finally {
        releaseReference();
    }
}","{
    acquireReference();
    try {
        return nativeColumnName(nStatement, columnIndex);
    } finally {
        releaseReference();
    }
}",1,"/* package */
","/* package */
",0,,,0,,,,,,,5,1,"The dependent API has been changed from `native_column_name(columnIndex)` to `nativeColumnName(nStatement, columnIndex)`. The method name and parameters have changed, so the code change type is 5.","Due to the change of the dependent API, including the method name and the addition of the parameter `nStatement`, there is the potential that the API will return a different value. Therefore, the CI type is 1."
1009,<android.app.AlertDialog.Builder: AlertDialog create()>,13,14,,,,"{
    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    dialog.setOnCancelListener(P.mOnCancelListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}","{
    final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);
    P.apply(dialog.mAlert);
    dialog.setCancelable(P.mCancelable);
    if (P.mCancelable) {
        dialog.setCanceledOnTouchOutside(true);
    }
    dialog.setOnCancelListener(P.mOnCancelListener);
    if (P.mOnKeyListener != null) {
        dialog.setOnKeyListener(P.mOnKeyListener);
    }
    return dialog;
}",1,"/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder. It does not
 * {@link Dialog#show()} the dialog. This allows the user to do any extra processing
 * before displaying the dialog. Use {@link #show()} if you don't have any other processing
 * to do and want this to be created and displayed.
 */
","/**
 * Creates a {@link AlertDialog} with the arguments supplied to this builder. It does not
 * {@link Dialog#show()} the dialog. This allows the user to do any extra processing
 * before displaying the dialog. Use {@link #show()} if you don't have any other processing
 * to do and want this to be created and displayed.
 */
",0,,,0,,,,,,,"3,4",0,"A new 'if' control statement is introduced to set 'canceledOnTouchOutside', and a method call ('setCanceledOnTouchOutside(true)') has been added inside this 'if' statement, so the change types are 3 (Control dependency change) and 4 (Other statement changed).","The newly added control statement checks if the dialog is cancelable and if so, sets it to be canceled when touched outside. This change doesn't affect return values or exception handling since it only adds a new property to the dialog when it meets a specific condition; hence, it does not cause a Compatibility Issue."
1011,<android.view.ViewGroup: boolean notifyChildOfDrag(View)>,13,14,,,,"{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    if (!mDragNotifiedChildren.contains(child)) {
        mDragNotifiedChildren.add(child);
        child.mCanAcceptDrop = child.dispatchDragEvent(mCurrentDrag);
    }
    return child.mCanAcceptDrop;
}","{
    if (ViewDebug.DEBUG_DRAG) {
        Log.d(View.VIEW_LOG_TAG, ""Sending drag-started to view: "" + child);
    }
    boolean canAccept = false;
    if (!mDragNotifiedChildren.contains(child)) {
        mDragNotifiedChildren.add(child);
        canAccept = child.dispatchDragEvent(mCurrentDrag);
        if (canAccept && !child.canAcceptDrag()) {
            child.mPrivateFlags2 |= View.DRAG_CAN_ACCEPT;
            child.refreshDrawableState();
        }
    }
    return canAccept;
}",1,,,0,,,0,,,,,,,"1,3,4",1,"The local variable 'canAccept' is introduced to store the result, and the condition to only set the flag when 'canAccept' and 'child.canAcceptDrag()' are true is new, which also includes a new call to 'child.refreshDrawableState()'. These represent changes in control dependency (check with an additional condition) and other statement changes (use of a new local variable and additional method calls). Thus, the changes include 1,3, and 4.","There is a potential different return value because the value of 'canAccept' now depends on a new condition that was not present in the early version in addition to the outcome of 'child.dispatchDragEvent(mCurrentDrag)'. Previously, the return value was directly tied to 'child.mCanAcceptDrop', which could have the same condition. Now, it's based on 'canAccept', which could result in a different boolean value being returned. Therefore, the CI type is 1."
1012,"<android.app.LoadedApk.ReceiverDispatcher.InnerReceiver: void performReceive(Intent,int,String,Bundle,boolean,boolean)>",13,14,,,,"{
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Slog.w(ActivityThread.TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}","{
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (ActivityThread.DEBUG_BROADCAST) {
        int seq = intent.getIntExtra(""seq"", -1);
        Slog.i(ActivityThread.TAG, ""Receiving broadcast "" + intent.getAction() + "" seq="" + seq + "" to "" + (rd != null ? rd.mReceiver : null));
    }
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras, ordered, sticky);
    } else {
        // behalf so that the system's broadcast sequence can continue.
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, ""Finishing broadcast to unregistered receiver"");
        IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            if (extras != null) {
                extras.setAllowFds(false);
            }
            mgr.finishReceiver(this, resultCode, data, extras, false);
        } catch (RemoteException e) {
            Slog.w(ActivityThread.TAG, ""Couldn't finish broadcast to unregistered receiver"");
        }
    }
}",1,,,0,,,0,,,,,,,"3,4",0,"The addition of `extras.setAllowFds(false);` within the `try` block is a change to the other statements, specifically the manipulation of the 'extras' Bundle. Also, this is under a condition (`if (extras != null)`), which is a control dependency change, so the code change type is 3,4.","The added statement `extras.setAllowFds(false);` might change the content of the 'extras' Bundle by disallowing file descriptors to be included, but it does not affect the way the method performs its main functionality, which is calling `rd.performReceive` or `mgr.finishReceiver`. Thus, it doesn't introduce a CI related to different return values/types or different exception handlings. The API's behavior, in terms of what it is intended to do, remains consistent. Therefore, the CI type is 0."
1014,"<android.speech.tts.TextToSpeech: int speak(String,int,HashMap<String, String>)>",13,14,,,,"{
    synchronized (mStartLock) {
        int result = ERROR;
        Log.i(""TextToSpeech.java - speak"", ""speak text of length "" + text.length());
        if (!mStarted) {
            Log.e(""TextToSpeech.java - speak"", ""service isn't started"");
            return result;
        }
        try {
            if ((params != null) && (!params.isEmpty())) {
                setCachedParam(params, Engine.KEY_PARAM_STREAM, Engine.PARAM_POSITION_STREAM);
                setCachedParam(params, Engine.KEY_PARAM_UTTERANCE_ID, Engine.PARAM_POSITION_UTTERANCE_ID);
                setCachedParam(params, Engine.KEY_PARAM_ENGINE, Engine.PARAM_POSITION_ENGINE);
                setCachedParam(params, Engine.KEY_PARAM_VOLUME, Engine.PARAM_POSITION_VOLUME);
                setCachedParam(params, Engine.KEY_PARAM_PAN, Engine.PARAM_POSITION_PAN);
            }
            result = mITts.speak(mPackageName, text, queueMode, mCachedParams);
        } catch (RemoteException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""RemoteException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (NullPointerException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""NullPointerException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } catch (IllegalStateException e) {
            // TTS died; restart it.
            Log.e(""TextToSpeech.java - speak"", ""IllegalStateException"");
            e.printStackTrace();
            mStarted = false;
            initTts();
        } finally {
            resetCachedParams();
            return result;
        }
    }
}","{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            Uri utteranceUri = mUtterances.get(text);
            if (utteranceUri != null) {
                return service.playAudio(getPackageName(), utteranceUri, queueMode, getParams(params));
            } else {
                return service.speak(getPackageName(), text, queueMode, getParams(params));
            }
        }
    }, ERROR, ""speak"");
}",1,"/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text
 * The string of text to be spoken.
 * @param queueMode
 * The queuing strategy to use.
 * {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params
 * The list of parameters to be used. Can be null if no parameters are given.
 * They are specified using a (key, value) pair, where the key can be
 * {@link Engine#KEY_PARAM_STREAM} or
 * {@link Engine#KEY_PARAM_UTTERANCE_ID}.
 *
 * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
 */
","/**
 * Speaks the string using the specified queuing strategy and speech
 * parameters.
 *
 * @param text The string of text to be spoken.
 * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
 * @param params Parameters for the request. Can be null.
 * Supported parameter names:
 * {@link Engine#KEY_PARAM_STREAM},
 * {@link Engine#KEY_PARAM_UTTERANCE_ID},
 * {@link Engine#KEY_PARAM_VOLUME},
 * {@link Engine#KEY_PARAM_PAN}.
 * Engine specific parameters may be passed in but the parameter keys
 * must be prefixed by the name of the engine they are intended for. For example
 * the keys ""com.svox.pico_foo"" and ""com.svox.pico:bar"" will be passed to the
 * engine named ""com.svox.pico"" if it is being used.
 *
 * @return {@link #ERROR} or {@link #SUCCESS}.
 */
",1,,,0,,,,,,,"1,3,4",1,"The implementation of the method has been entirely restructured: section of synchronized block has been replaced with a call to a new method runAction with a new anonymous Action class with a different logic flow, suggesting major overhaul in the implementation. Control structures have been changed, and there are other statement changes including the removal of logs, exception catch blocks, and the final block resetting the parameters. Additionally, the dependency on the method 'speak' or 'playAudio' of the 'ITextToSpeechService' interface indicates changes that could impact the outcome based on how these methods behave. Hence, there's a mix of return statement changed, control dependency changed, and other statement changed.","The method could potentially return different values due to the complete restructuring of the API. The newly implemented logic introduces a possible new path for playing audio from an Uri, and also it removes the previous logs and exception handling statements which can alter the behavior significantly. Hence, there is a compatibility issue caused by potentially different return values."
1015,<android.accounts.AccountManager.AmsTask.Response: void onResult(Bundle)>,13,14,,,,"{
    Intent intent = bundle.getParcelable(""intent"");
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
        // this will only happen if the system process is dead, which means
        // we will be dying ourselves
        }
    } else {
        set(bundle);
    }
}","{
    Intent intent = bundle.getParcelable(KEY_INTENT);
    if (intent != null && mActivity != null) {
        // since the user provided an Activity we will silently start intents
        // that we see
        mActivity.startActivity(intent);
    // leave the Future running to wait for the real response to this request
    } else if (bundle.getBoolean(""retry"")) {
        try {
            doWork();
        } catch (RemoteException e) {
        // this will only happen if the system process is dead, which means
        // we will be dying ourselves
        }
    } else {
        set(bundle);
    }
}",1,,,0,,,0,,,,,,,0,0,There is no change to the implementation of the method between the two versions.,"Since there is no code change in the method implementation between the two versions, no Compatibility Issue could arise."
1016,<android.view.View: boolean dispatchKeyEvent(KeyEvent)>,13,14,,,,"{
    // noinspection SimplifiableIfStatement,deprecation
    if (android.util.Config.LOGV) {
        captureViewInfo(""captureViewKeyEvent"", this);
    }
    // noinspection SimplifiableIfStatement
    if (mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    return event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this);
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onKeyEvent(event, 0);
    }
    // noinspection SimplifiableIfStatement
    if (mOnKeyListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
        return true;
    }
    if (event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this)) {
        return true;
    }
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }
    return false;
}",1,"/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
","/**
 * Dispatch a key event to the next view on the focus path. This path runs
 * from the top of the view tree down to the currently focused view. If this
 * view has focus, it will dispatch to itself. Otherwise it will dispatch
 * the next node down the focus path. This method also fires any key
 * listeners.
 *
 * @param event The key event to be dispatched.
 * @return True if the event was handled, false otherwise.
 */
",0,,,0,,,,,,,"1,3,4","1,2",There are several changes: ,- An extra block of code for input event consistency verification has been added at the end if the event is unhandled.
1017,"<android.server.BluetoothPanProfileHandler: void handlePanDeviceStateChange(BluetoothDevice,String,int,int)>",13,14,,,,"{
    int prevState;
    String ifaceAddr = null;
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        prevState = BluetoothPan.STATE_DISCONNECTED;
    } else {
        prevState = panDevice.mState;
        ifaceAddr = panDevice.mIfaceAddr;
    }
    if (prevState == state)
        return;
    if (role == BluetoothPan.LOCAL_NAP_ROLE) {
        if (state == BluetoothPan.STATE_CONNECTED) {
            ifaceAddr = enableTethering(iface);
            if (ifaceAddr == null)
                Log.e(TAG, ""Error seting up tether interface"");
        } else if (state == BluetoothPan.STATE_DISCONNECTED) {
            if (ifaceAddr != null) {
                mBluetoothIfaceAddresses.remove(ifaceAddr);
                ifaceAddr = null;
            }
        }
    } else {
        // PANU Role = reverse Tether
        if (state == BluetoothPan.STATE_CONNECTED) {
            BluetoothTetheringDataTracker.getInstance().startReverseTether(iface, device);
        } else if (state == BluetoothPan.STATE_DISCONNECTED && (prevState == BluetoothPan.STATE_CONNECTED || prevState == BluetoothPan.STATE_DISCONNECTING)) {
            BluetoothTetheringDataTracker.getInstance().stopReverseTether(panDevice.mIface);
        }
    }
    if (panDevice == null) {
        panDevice = new BluetoothPanDevice(state, ifaceAddr, iface, role);
        mPanDevices.put(device, panDevice);
    } else {
        panDevice.mState = state;
        panDevice.mIfaceAddr = ifaceAddr;
        panDevice.mLocalRole = role;
    }
    Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothPan.EXTRA_STATE, state);
    intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, role);
    mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
    debugLog(""Pan Device state : device: "" + device + "" State:"" + prevState + ""->"" + state);
    mBluetoothService.sendConnectionStateChange(device, state, prevState);
}","{
    int prevState;
    String ifaceAddr = null;
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        prevState = BluetoothPan.STATE_DISCONNECTED;
    } else {
        prevState = panDevice.mState;
        ifaceAddr = panDevice.mIfaceAddr;
    }
    if (prevState == state)
        return;
    if (role == BluetoothPan.LOCAL_NAP_ROLE) {
        if (state == BluetoothPan.STATE_CONNECTED) {
            ifaceAddr = enableTethering(iface);
            if (ifaceAddr == null)
                Log.e(TAG, ""Error seting up tether interface"");
        } else if (state == BluetoothPan.STATE_DISCONNECTED) {
            if (ifaceAddr != null) {
                mBluetoothIfaceAddresses.remove(ifaceAddr);
                ifaceAddr = null;
            }
        }
    } else {
        // PANU Role = reverse Tether
        if (state == BluetoothPan.STATE_CONNECTED) {
            BluetoothTetheringDataTracker.getInstance().startReverseTether(iface, device);
        } else if (state == BluetoothPan.STATE_DISCONNECTED && (prevState == BluetoothPan.STATE_CONNECTED || prevState == BluetoothPan.STATE_DISCONNECTING)) {
            BluetoothTetheringDataTracker.getInstance().stopReverseTether(panDevice.mIface);
        }
    }
    if (panDevice == null) {
        panDevice = new BluetoothPanDevice(state, ifaceAddr, iface, role);
        mPanDevices.put(device, panDevice);
    } else {
        panDevice.mState = state;
        panDevice.mIfaceAddr = ifaceAddr;
        panDevice.mLocalRole = role;
        panDevice.mIface = iface;
    }
    Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothPan.EXTRA_STATE, state);
    intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, role);
    mContext.sendBroadcast(intent, BluetoothService.BLUETOOTH_PERM);
    debugLog(""Pan Device state : device: "" + device + "" State:"" + prevState + ""->"" + state);
    mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.PAN, state, prevState);
}",1,,,0,,,0,,,,,,,4,0,"The late implementation has an additional assignment statement `panDevice.mIface = iface;` and the sendConnectionStateChange method call in the late version has an additional parameter `BluetoothProfile.PAN`. Since these changes are not about return statements or exception handling, but rather assigning a new value to a field in an object and changing the parameters in a method call, the code change type is 4.","These changes don't alter the return values or the exception handling of the method, so theoretically there should be no Compatibility Issue. However, caller code that relies on the side effects of the method might observe differences. But according to the provided instructions and definitions, these changes do not directly cause the API to return a different variable or throw exception differently. Therefore, there is no direct Compatibility Issue."
1018,<android.view.View: Matrix getInverseMatrix()>,13,14,,,,"{
    updateMatrix();
    if (mInverseMatrixDirty) {
        if (mInverseMatrix == null) {
            mInverseMatrix = new Matrix();
        }
        mMatrix.invert(mInverseMatrix);
        mInverseMatrixDirty = false;
    }
    return mInverseMatrix;
}","{
    final TransformationInfo info = mTransformationInfo;
    if (info != null) {
        updateMatrix();
        if (info.mInverseMatrixDirty) {
            if (info.mInverseMatrix == null) {
                info.mInverseMatrix = new Matrix();
            }
            info.mMatrix.invert(info.mInverseMatrix);
            info.mInverseMatrixDirty = false;
        }
        return info.mInverseMatrix;
    }
    return Matrix.IDENTITY_MATRIX;
}",1,"/**
 * Utility method to retrieve the inverse of the current mMatrix property.
 * We cache the matrix to avoid recalculating it when transform properties
 * have not changed.
 *
 * @return The inverse of the current matrix of this view.
 */
","/**
 * Utility method to retrieve the inverse of the current mMatrix property.
 * We cache the matrix to avoid recalculating it when transform properties
 * have not changed.
 *
 * @return The inverse of the current matrix of this view.
 */
",0,,,0,,,,,,,"1,3,4",1,"The late version introduces a new control dependency with the `if (info != null)` check, a change in the structure of accessing matrix information (now accessing fields of the `info` object), and an additional return statement that returns `Matrix.IDENTITY_MATRIX` when `info` is `null`. This accounts for changes in return statements (1), control dependency (3), and other statements (4).","The new control statement and the additional return statement introduce a scenario where `Matrix.IDENTITY_MATRIX` is returned instead of `mInverseMatrix`. As the return value can potentially be different in the older and newer version, this constitutes as a possible return value change and hence a Compatibility Issue (CI type 1)."
1019,<android.widget.FastScroller: boolean onInterceptTouchEvent(MotionEvent)>,13,14,,,,"{
    if (mState > STATE_NONE && ev.getAction() == MotionEvent.ACTION_DOWN) {
        if (isPointInside(ev.getX(), ev.getY())) {
            setState(STATE_DRAGGING);
            return true;
        }
    }
    return false;
}","{
    switch(ev.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            if (mState > STATE_NONE && isPointInside(ev.getX(), ev.getY())) {
                if (!mList.isInScrollingContainer()) {
                    beginDrag();
                    return true;
                }
                mInitialTouchY = ev.getY();
                startPendingDrag();
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            cancelPendingDrag();
            break;
    }
    return false;
}",1,,,0,,,0,,,,,,,"3,4",1,"The control flow has changed significantly. From an 'if' statement, the code has been refactored to use a 'switch' statement, accounting for additional actions such as ACTION_UP and ACTION_CANCEL. Additionally, new method calls like beginDrag(), startPendingDrag(), and cancelPendingDrag() are introduced, which is classified under other statement changed. Hence, the code change types are 3 (control dependency changed) and 4 (other statement changed).","The refactoring alters the conditions under which true is returned: addition of !mList.isInScrollingContainer() check, and the introduction of new methods that can affect the state of the object when handling the touch event. Also, the introduction of handling for ACTION_UP and ACTION_CANCEL actions also has the potential for changing the behavior of the method. Therefore, the CI type is 1 due to the potential for returning different boolean values compared to the early version."
