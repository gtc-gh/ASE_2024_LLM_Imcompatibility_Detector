Number,Signature,Early_Version,Late_Version,Early_Signature,Late_Signature,Diff_Signature,Early_Implementation,Late_Implementation,Diff_Implementation,Early_Comment,Late_Comment,Diff_Comment,Early_Annotation,Late_Annotation,Diff_Annotation,Early_Callback,Late_Callback,Diff_Callback,GT_CI_ControlFlow,GT_CI_Type,pred_change,pred_CI,change_description,CI_description
4,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,19,20,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,<android.view.ScaleGestureDetector: boolean onTouchEvent(MotionEvent)>,0,"{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}","{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}",1,"/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
","/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,1,"The condition inside the if statement (if (mInProgress)) has been partitioned with an additional else if clause inside, so the code change type is 4.","As there is a change in the if condition inside which the 'return true' statement is encased, it would result in the function potentially returning a different value in the late version, hence, the CI type is 1."
9,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,19,20,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,<android.widget.ActivityChooserView.Callbacks: void onClick(View)>,0,"{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            mContext.startActivity(launchIntent);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}","{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            startActivity(launchIntent, defaultActivity);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}",1,"// View.OnClickListener
","// View.OnClickListener
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The function call 'mContext.startActivity(launchIntent)' has been replaced by 'startActivity(launchIntent, defaultActivity)' in the late version. So, the code change type is 4.","Although there's a change in calling function, there is no indication that this change would lead to different behaviour in terms of the method's returns or exceptions. Hence, no Compatibility Issue exists, and the CI type is 0."
13,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,19,20,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,<android.print.PrinterCapabilitiesInfo.Builder: PrinterCapabilitiesInfo build()>,0,"{
    if (mPrototype.mMediaSizes == null || mPrototype.mMediaSizes.isEmpty()) {
        throw new IllegalStateException(""No media size specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_MEDIA_SIZE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default media size specified."");
    }
    if (mPrototype.mResolutions == null || mPrototype.mResolutions.isEmpty()) {
        throw new IllegalStateException(""No resolution specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_RESOLUTION] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default resolution specified."");
    }
    if (mPrototype.mColorModes == 0) {
        throw new IllegalStateException(""No color mode specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_COLOR_MODE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default color mode specified."");
    }
    if (mPrototype.mMinMargins == null) {
        throw new IllegalArgumentException(""margins cannot be null"");
    }
    return new PrinterCapabilitiesInfo(mPrototype);
}","{
    if (mPrototype.mMediaSizes == null || mPrototype.mMediaSizes.isEmpty()) {
        throw new IllegalStateException(""No media size specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_MEDIA_SIZE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default media size specified."");
    }
    if (mPrototype.mResolutions == null || mPrototype.mResolutions.isEmpty()) {
        throw new IllegalStateException(""No resolution specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_RESOLUTION] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default resolution specified."");
    }
    if (mPrototype.mColorModes == 0) {
        throw new IllegalStateException(""No color mode specified."");
    }
    if (mPrototype.mDefaults[PROPERTY_COLOR_MODE] == DEFAULT_UNDEFINED) {
        throw new IllegalStateException(""No default color mode specified."");
    }
    if (mPrototype.mMinMargins == null) {
        throw new IllegalArgumentException(""margins cannot be null"");
    }
    return mPrototype;
}",1,"/**
 * Crates a new {@link PrinterCapabilitiesInfo} enforcing that all
 * required properties have need specified. See individual methods
 * in this class for reference about required attributes.
 *
 * @return A new {@link PrinterCapabilitiesInfo}.
 *
 * @throws IllegalStateException If a required attribute was not specified.
 */
","/**
 * Crates a new {@link PrinterCapabilitiesInfo} enforcing that all
 * required properties have been specified. See individual methods
 * in this class for reference about required attributes.
 *
 * @return A new {@link PrinterCapabilitiesInfo}.
 *
 * @throws IllegalStateException If a required attribute was not specified.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement is changed from 'new PrinterCapabilitiesInfo(mPrototype);' in early version to 'mPrototype;' in the late version, therefore, the change type is 1.","The return value in both versions can be different because of the change in the return statement, this could lead to different behavior in the API when invoked, and hence the CI type is 1."
14,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,19,20,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliablePipe()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,0,"The method invocation argument in createCommSocketPair(false) has been removed in later version, making it a no-arguement method. So, the code change type is 5.","This changes the argument to the method createCommSocketPair, which changes the behavior of the dependent API call. However, there is no indication this change would cause the API to return a different value or throw a different exception, so no Compatibility Issue (CI) exists."
15,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",19,20,"<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.SensorEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = mSensorsEvents.get(handle);
    if (t == null) {
        Log.e(TAG, ""Error: Sensor Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    switch(t.sensor.getType()) {
        // Only report accuracy for sensors that support it.
        case Sensor.TYPE_MAGNETIC_FIELD:
        case Sensor.TYPE_ORIENTATION:
            // call onAccuracyChanged() only if the value changes
            final int accuracy = mSensorAccuracies.get(handle);
            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
                mSensorAccuracies.put(handle, t.accuracy);
                mListener.onAccuracyChanged(t.sensor, t.accuracy);
            }
            break;
        default:
            // For other sensors, just report the accuracy once
            if (mFirstEvent.get(handle) == false) {
                mFirstEvent.put(handle, true);
                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
            }
            break;
    }
    mListener.onSensorChanged(t);
}","{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    switch(t.sensor.getType()) {
        // Only report accuracy for sensors that support it.
        case Sensor.TYPE_MAGNETIC_FIELD:
        case Sensor.TYPE_ORIENTATION:
            // call onAccuracyChanged() only if the value changes
            final int accuracy = mSensorAccuracies.get(handle);
            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
                mSensorAccuracies.put(handle, t.accuracy);
                mListener.onAccuracyChanged(t.sensor, t.accuracy);
            }
            break;
        default:
            // For other sensors, just report the accuracy once
            if (mFirstEvent.get(handle) == false) {
                mFirstEvent.put(handle, true);
                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
            }
            break;
    }
    mListener.onSensorChanged(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,"3,4",No Compatibility Issue exist,"There are two changes in the late version. One is the introduction of a new synchronized block when getting the SensorEvent 't' from 'mSensorsEvents', which is a control dependency change, hence the change type is 3. Another change is that the log statement in the early version has been replaced by a different comment, which belongs to a change of other statements (change type 4).","Although there are changes in the late version, none of the changes could potentially lead the API to return a different value or throw a different exception, so no compatibility issue exists."
17,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",19,20,"<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>","<android.widget.AbsListView.RecycleBin: void addScrapView(View,int)>",0,"{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}","{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}",1,"/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
","/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"A new method call, notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE), has been introduced in the latest version, so the code change type is 4.","The newly introduced function doesn't affect the actual functionality or the return type of the overall API method. Therefore, no compatibility issue type is detected (0)."
18,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,19,20,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,<android.speech.tts.TextToSpeech: Set<String> getFeatures(Locale)>,0,"{
    return runAction(new Action<Set<String>>() {

        @Override
        public Set<String> run(ITextToSpeechService service) throws RemoteException {
            String[] features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (features != null) {
                final Set<String> featureSet = new HashSet<String>();
                Collections.addAll(featureSet, features);
                return featureSet;
            }
            return null;
        }
    }, null, ""getFeatures"");
}","{
    return runAction(new Action<Set<String>>() {

        @Override
        public Set<String> run(ITextToSpeechService service) throws RemoteException {
            String[] features = null;
            try {
                features = service.getFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            } catch (MissingResourceException e) {
                Log.w(TAG, ""Couldn't retrieve 3 letter ISO 639-2/T language and/or ISO 3166 "" + ""country code for locale: "" + locale, e);
                return null;
            }
            if (features != null) {
                final Set<String> featureSet = new HashSet<String>();
                Collections.addAll(featureSet, features);
                return featureSet;
            }
            return null;
        }
    }, null, ""getFeatures"");
}",1,"/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
","/**
 * Queries the engine for the set of features it supports for a given locale.
 * Features can either be framework defined, e.g.
 * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
 * Engine specific keys must be prefixed by the name of the engine they
 * are intended for. These keys can be used as parameters to
 * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
 * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
 *
 * Features are boolean flags, and their values in the synthesis parameters
 * must be behave as per {@link Boolean#parseBoolean(String)}.
 *
 * @param locale The locale to query features for.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3","1,2",The implementation in the late version introduces an additional try-catch block which handles the MissingResourceException and alters the initialisation of the variable 'features'. This counts as a change in exception handling statement (2) and a control dependency change (3).,"The introduced try-catch block could potentially change the return value of the method (if MissingResourceException is caught, null will be returned). This counts as a Compatibility Issue caused by potential different return values or types (1). Also, the exception handling has changed, leading to Compatibility Issue caused by potential different exception handlings (2)."
19,<android.hardware.camera2.impl.CameraDevice: void waitUntilIdle()>,19,20,<android.hardware.camera2.impl.CameraDevice: void waitUntilIdle()>,<android.hardware.camera2.impl.CameraDevice: void waitUntilIdle()>,0,"{
    synchronized (mLock) {
        checkIfCameraClosed();
        if (!mRepeatingRequestIdStack.isEmpty()) {
            throw new IllegalStateException(""Active repeating request ongoing"");
        }
        try {
            mRemoteDevice.waitUntilIdle();
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
    }
}","{
    synchronized (mLock) {
        checkIfCameraClosed();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            throw new IllegalStateException(""Active repeating request ongoing"");
        }
        try {
            mRemoteDevice.waitUntilIdle();
        } catch (CameraRuntimeException e) {
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
        mRepeatingRequestId = REQUEST_ID_NONE;
        mRepeatingRequestIdDeletedList.clear();
        mCaptureListenerMap.clear();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4","1,2","The condition of the 'if' statement and the code within the 'synchronized' block, outside of the 'try'-'catch' has been changed. So, the code change type is 3,4.","Due to the changes in control statement dependencies and other statements, the API could return different values since the condition under which the exception is thrown now depends on a different condition. In addition, new statements are added after exception catching returning potentially different values. Therefore, the CI type is 1,2."
21,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyHandler: void handleMessage(Message)>,0,"{
    if (isFinished()) {
        return;
    }
    switch(message.what) {
        case MSG_START:
            {
                mDocumentAdapter.onStart();
            }
            break;
        case MSG_LAYOUT:
            {
                final CancellationSignal cancellation;
                final LayoutSpec layoutSpec;
                synchronized (mLock) {
                    layoutSpec = mLastLayoutSpec;
                    mLastLayoutSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (layoutSpec != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing layout"");
                    }
                    mDocumentAdapter.onLayout(layoutSpec.oldAttributes, layoutSpec.newAttributes, cancellation, new MyLayoutResultCallback(layoutSpec.callback, layoutSpec.sequence), layoutSpec.metadata);
                }
            }
            break;
        case MSG_WRITE:
            {
                final CancellationSignal cancellation;
                final WriteSpec writeSpec;
                synchronized (mLock) {
                    writeSpec = mLastWriteSpec;
                    mLastWriteSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (writeSpec != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing write"");
                    }
                    mDocumentAdapter.onWrite(writeSpec.pages, writeSpec.fd, cancellation, new MyWriteResultCallback(writeSpec.callback, writeSpec.fd, writeSpec.sequence));
                }
            }
            break;
        case MSG_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Performing finish"");
                }
                mDocumentAdapter.onFinish();
                doFinish();
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}","{
    if (isFinished()) {
        return;
    }
    switch(message.what) {
        case MSG_START:
            {
                final PrintDocumentAdapter adapter;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                }
                if (adapter != null) {
                    adapter.onStart();
                }
            }
            break;
        case MSG_LAYOUT:
            {
                final PrintDocumentAdapter adapter;
                final CancellationSignal cancellation;
                final LayoutSpec layoutSpec;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    layoutSpec = mLastLayoutSpec;
                    mLastLayoutSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (layoutSpec != null && adapter != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing layout"");
                    }
                    adapter.onLayout(layoutSpec.oldAttributes, layoutSpec.newAttributes, cancellation, new MyLayoutResultCallback(layoutSpec.callback, layoutSpec.sequence), layoutSpec.metadata);
                }
            }
            break;
        case MSG_WRITE:
            {
                final PrintDocumentAdapter adapter;
                final CancellationSignal cancellation;
                final WriteSpec writeSpec;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    writeSpec = mLastWriteSpec;
                    mLastWriteSpec = null;
                    cancellation = new CancellationSignal();
                    mLayoutOrWriteCancellation = cancellation;
                }
                if (writeSpec != null && adapter != null) {
                    if (DEBUG) {
                        Log.i(LOG_TAG, ""Performing write"");
                    }
                    adapter.onWrite(writeSpec.pages, writeSpec.fd, cancellation, new MyWriteResultCallback(writeSpec.callback, writeSpec.fd, writeSpec.sequence));
                }
            }
            break;
        case MSG_FINISH:
            {
                if (DEBUG) {
                    Log.i(LOG_TAG, ""Performing finish"");
                }
                final PrintDocumentAdapter adapter;
                final Activity activity;
                synchronized (mLock) {
                    adapter = mDocumentAdapter;
                    activity = mActivity;
                    clearLocked();
                }
                if (adapter != null) {
                    adapter.onFinish();
                }
                if (activity != null) {
                    activity.getApplication().unregisterActivityLifecycleCallbacks(PrintDocumentAdapterDelegate.this);
                }
            }
            break;
        default:
            {
                throw new IllegalArgumentException(""Unknown message: "" + message.what);
            }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The method contains changes in both 'if' and 'switch' conditions and their respective nested actions. New variables are introduced and used in the 'switch' conditions, so the code change type is classified as 1,3.","The changes can lead to different behaviours of the function, as with the new conditions, the function may potentially return a different result or action. This introduces a compatibility issue of type 1, where different return values or types are possible."
25,<android.app.MediaRouteActionProvider: void setRouteTypes(int)>,19,20,<android.app.MediaRouteActionProvider: void setRouteTypes(int)>,<android.app.MediaRouteActionProvider: void setRouteTypes(int)>,0,"{
    if (mRouteTypes == types)
        return;
    if (mRouteTypes != 0) {
        mRouter.removeCallback(mCallback);
    }
    mRouteTypes = types;
    if (types != 0) {
        mRouter.addCallback(types, mCallback);
    }
    if (mView != null) {
        mView.setRouteTypes(mRouteTypes);
    }
}","{
    if (mRouteTypes != types) {
        // indication from the framework that it is being destroyed.
        if (mRouteTypes != 0) {
            mRouter.removeCallback(mCallback);
        }
        mRouteTypes = types;
        if (types != 0) {
            mRouter.addCallback(types, mCallback, MediaRouter.CALLBACK_FLAG_PASSIVE_DISCOVERY);
        }
        refreshRoute();
        if (mButton != null) {
            mButton.setRouteTypes(mRouteTypes);
        }
    }
}",1,,"/**
 * Sets the types of routes that will be shown in the media route chooser dialog
 * launched by this button.
 *
 * @param types The route types to match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The first change is in the beginning if statement, from `if (mRouteTypes == types)` to `if (mRouteTypes != types)`. Then in the API dependent statement: `mRouter.addCallback(types, mCallback)`, a third parameter `MediaRouter.CALLBACK_FLAG_PASSIVE_DISCOVERY` is added in the late version. Lastly, new statements are added: `refreshRoute()` and `if (mButton != null) { mButton.setRouteTypes(mRouteTypes);}`. Therefore, the code change types are 1,4,5.","The change in the if condition, the newly added parameters, and the new statements will lead to different behaviors of this method, therefore a compatibility issue may exist, type 1."
26,<android.os.Looper: String toString()>,19,20,<android.os.Looper: String toString()>,<android.os.Looper: String toString()>,0,"{
    return ""Looper{"" + Integer.toHexString(System.identityHashCode(this)) + ""}"";
}","{
    return ""Looper ("" + mThread.getName() + "", tid "" + mThread.getId() + "") {"" + Integer.toHexString(System.identityHashCode(this)) + ""}"";
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The content of the return statement has changed and a new dependent API mThread.getName() and mThread.getId() is used, so the code change type is 1,4.","As the content of the return statement has changed, the API potentially return a different string, so the CI type is 1."
27,<android.widget.TextView: Parcelable onSaveInstanceState()>,19,20,<android.widget.TextView: Parcelable onSaveInstanceState()>,<android.widget.TextView: Parcelable onSaveInstanceState()>,0,"{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            /*
                 * Calling setText() strips off any ChangeWatchers;
                 * strip them now to avoid leaking references.
                 * But do it to a copy so that if there are any
                 * further changes to the text of this view, it
                 * won't get into an inconsistent state.
                 */
            Spannable sp = new SpannableString(mText);
            for (ChangeWatcher cw : sp.getSpans(0, sp.length(), ChangeWatcher.class)) {
                sp.removeSpan(cw);
            }
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        return ss;
    }
    return superState;
}","{
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start >= 0 || end >= 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            Spannable sp = new SpannableStringBuilder(mText);
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start >= 0 && end >= 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        return ss;
    }
    return superState;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,1,"The statement ""Spannable sp = new SpannableString(mText);"" is replaced by ""Spannable sp = new SpannableStringBuilder(mText);"" and the loop which removes the ChangeWatcher objects is removed in the late version. Therefore, the change type is 4 (Other statement changed).","The change in how Spannable objects are created and the omission of removing ChangeWatcher objects can potentially lead to a difference in the 'ss' (SavedState) object that is returned by the function. Therefore, the potential value returned by the API can be different, giving rise to a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
28,<android.hardware.camera2.impl.CameraDevice: void stopRepeating()>,19,20,<android.hardware.camera2.impl.CameraDevice: void stopRepeating()>,<android.hardware.camera2.impl.CameraDevice: void stopRepeating()>,0,"{
    synchronized (mLock) {
        checkIfCameraClosed();
        while (!mRepeatingRequestIdStack.isEmpty()) {
            int requestId = mRepeatingRequestIdStack.pop();
            try {
                mRemoteDevice.cancelRequest(requestId);
            } catch (CameraRuntimeException e) {
                throw e.asChecked();
            } catch (RemoteException e) {
                // impossible
                return;
            }
        }
    }
}","{
    synchronized (mLock) {
        checkIfCameraClosed();
        if (mRepeatingRequestId != REQUEST_ID_NONE) {
            int requestId = mRepeatingRequestId;
            mRepeatingRequestId = REQUEST_ID_NONE;
            // Queue for deletion after in-flight requests finish
            mRepeatingRequestIdDeletedList.add(requestId);
            try {
                mRemoteDevice.cancelRequest(requestId);
            } catch (CameraRuntimeException e) {
                throw e.asChecked();
            } catch (RemoteException e) {
                // impossible
                return;
            }
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4","1,2","The code has changed significantly with the new ""if"" control structure and the removal of the ""while"" structure. This change not only implies a control dependency change but also changes the return statement and some other statements, such as the addition of the mRepeatingRequestIdDeletedList.add(requestId) operation. Hence, the code change type is 1,3,4.","The change in control structures, as well as the return statement and exception throwing, indicates that this modification can make the API return differently or throw different exceptions, depending upon the situation. Thus, the CI type is 1,2."
29,"<android.hardware.Camera.Parameters: void set(String,String)>",19,20,"<android.hardware.Camera.Parameters: void set(String,String)>","<android.hardware.Camera.Parameters: void set(String,String)>",0,"{
    if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
        Log.e(TAG, ""Key \"""" + key + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
        Log.e(TAG, ""Value \"""" + value + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    mMap.put(key, value);
}","{
    if (key.indexOf('=') != -1 || key.indexOf(';') != -1 || key.indexOf(0) != -1) {
        Log.e(TAG, ""Key \"""" + key + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    if (value.indexOf('=') != -1 || value.indexOf(';') != -1 || value.indexOf(0) != -1) {
        Log.e(TAG, ""Value \"""" + value + ""\"" contains invalid character (= or ; or \\0)"");
        return;
    }
    put(key, value);
}",1,"/**
 * Sets a String parameter.
 *
 * @param key   the key name for the parameter
 * @param value the String value of the parameter
 */
","/**
 * Sets a String parameter.
 *
 * @param key   the key name for the parameter
 * @param value the String value of the parameter
 */
",-1,,,-1,-1,-1,-1,-1,-1,5,1,"The statement calling the API in the last line has changed from 'mMap.put(key, value);' in the earlier version to 'put(key, value);' in the later version. It represents a change in the dependent API, classifying the code change type as 5.","The change of dependent API method call potentially leads to different behavior because 'put(key, value);' in the late version may not perform the exact same operation as 'mMap.put(key, value);' in the early version. Therefore, it could possibly lead to returning different results for this void method (through side effects), hence the CI type is classified as 1."
30,<android.os.Bundle: String toString()>,19,20,<android.os.Bundle: String toString()>,<android.os.Bundle: String toString()>,0,"{
    if (mParcelledData != null) {
        return ""Bundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
    }
    return ""Bundle["" + mMap.toString() + ""]"";
}","{
    if (mParcelledData != null) {
        if (mParcelledData == EMPTY_PARCEL) {
            return ""Bundle[EMPTY_PARCEL]"";
        } else {
            return ""Bundle[mParcelledData.dataSize="" + mParcelledData.dataSize() + ""]"";
        }
    }
    return ""Bundle["" + mMap.toString() + ""]"";
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new condition check 'if (mParcelledData == EMPTY_PARCEL)' has been added and one additional 'return' statement has been introduced, so the code change types are 1 and 3.","The modification in conditions and the additional return statement can potentially cause the API to return different data. Hence, the CI type is 1."
32,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,19,20,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,<android.print.PrintAttributes.MediaSize: MediaSize asPortrait()>,0,"{
    return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId);
}","{
    if (isPortrait()) {
        return this;
    }
    return new MediaSize(mId, mLabel, mPackageName, Math.min(mWidthMils, mHeightMils), Math.max(mWidthMils, mHeightMils), mLabelResId);
}",1,"/**
 * Returns a new media size in a portrait orientation
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation.
 */
","/**
 * Returns a new media size instance in a portrait orientation,
 * which is the height is the greater dimension.
 *
 * @return New instance in landscape orientation if this one
 * is in landscape, otherwise this instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late implementation, a condition 'isPortrait()' has been added and a 'return this' statement is introduced under this condition (the returned will be different if the condition 'isPortrait()' holds). Therefore, the code change type is 1 and 3. ","The change in control dependency has introduced a new potential return of the API. If 'isPortrait()' returns true, the whole object would be returned instead of creating a new object. Therefore, the situation causes a potential compatibility issue (CI) type of 1, indicating potential different return values."
33,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void finish()>,0,"{
    synchronized (mLock) {
        // Start not called or finish called - nothing to do.
        if (!mStartReqeusted || mFinishRequested) {
            return;
        }
        mFinishRequested = true;
        // will do the pending work.
        if (mLastLayoutSpec != null || mLastWriteSpec != null) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Waiting for current operation"");
            }
            return;
        }
        doPendingWorkLocked();
    }
}","{
    synchronized (mLock) {
        // Start not called or finish called or destroyed - nothing to do.
        if (!mStartReqeusted || mFinishRequested || mDestroyed) {
            return;
        }
        mFinishRequested = true;
        // will do the pending work.
        if (mLastLayoutSpec != null || mLastWriteSpec != null) {
            if (DEBUG) {
                Log.i(LOG_TAG, ""Waiting for current operation"");
            }
            return;
        }
        doPendingWorkLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition in the if statement has been extended with an additional check for 'mDestroyed' in the later version. So, the code change type is 3 indicating control dependency change.","Because of the change in the condition (now checking the mDestroyed flag), the behavior of the function can potentially change as it may return earlier in some cases. Therefore, the Compatibility Issue type is 1."
35,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,19,20,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,<android.app.MediaRouteActionProvider: View onCreateActionView(MenuItem)>,0,"{
    if (mMenuItem != null || mView != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mMenuItem = item;
    mView = new MediaRouteButton(mContext);
    mView.setCheatSheetEnabled(true);
    mView.setRouteTypes(mRouteTypes);
    mView.setExtendedSettingsClickListener(mExtendedSettingsListener);
    mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return mView;
}","{
    if (mButton != null) {
        Log.e(TAG, ""onCreateActionView: this ActionProvider is already associated "" + ""with a menu item. Don't reuse MediaRouteActionProvider instances! "" + ""Abandoning the old one..."");
    }
    mButton = new MediaRouteButton(mContext);
    mButton.setCheatSheetEnabled(true);
    mButton.setRouteTypes(mRouteTypes);
    mButton.setExtendedSettingsClickListener(mExtendedSettingsListener);
    mButton.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT));
    return mButton;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4,5",1,"The return statement has changed from 'return mView;' to 'return mButton;'. Related conditional statement (if), object instantiation, and method invocations associated with the variable have all changed to accommodate this. Therefore, the code change type is 1,4,5.","The change of return variable from 'mView' to 'mButton' will make the API potentially return a different value, therefore the CI type is 1."
36,"<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>",19,20,"<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>","<android.widget.ActivityChooserView.Callbacks: void onItemClick(AdapterView<?>,View,int,long)>",0,"{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        mContext.startActivity(launchIntent);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}","{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        ResolveInfo resolveInfo = mAdapter.getDataModel().getActivity(position);
                        startActivity(launchIntent, resolveInfo);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}",1,"// AdapterView#OnItemClickListener
","// AdapterView#OnItemClickListener
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"There are statements added within the case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY of the switch statement:  `ResolveInfo resolveInfo = mAdapter.getDataModel().getActivity(position); startActivity(launchIntent, resolveInfo);`. It also involves the change of a dependent API from `mContext.startActivity(launchIntent);` to `startActivity(launchIntent, resolveInfo);`. Therefore, the code change type is 4,5.","As the dependent API `startActivity()` has changed, it could potentailly leads to different behaviours when invoking the API, therefore the CI type is 1."
37,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>",19,20,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>","<android.print.PrintManager.PrintDocumentAdapterDelegate: void layout(PrintAttributes,PrintAttributes,ILayoutResultCallback,Bundle,int)>",0,"{
    synchronized (mLock) {
        // Start not called or finish called - nothing to do.
        if (!mStartReqeusted || mFinishRequested) {
            return;
        }
        // Layout cancels write and overrides layout.
        if (mLastWriteSpec != null) {
            IoUtils.closeQuietly(mLastWriteSpec.fd);
            mLastWriteSpec = null;
        }
        mLastLayoutSpec = new LayoutSpec();
        mLastLayoutSpec.callback = callback;
        mLastLayoutSpec.oldAttributes = oldAttributes;
        mLastLayoutSpec.newAttributes = newAttributes;
        mLastLayoutSpec.metadata = metadata;
        mLastLayoutSpec.sequence = sequence;
        // cancellation completes we will do the pending work.
        if (cancelPreviousCancellableOperationLocked()) {
            return;
        }
        doPendingWorkLocked();
    }
}","{
    final boolean destroyed;
    synchronized (mLock) {
        destroyed = mDestroyed;
        // If start called and not finished called and not destroyed - do some work.
        if (mStartReqeusted && !mFinishRequested && !mDestroyed) {
            // Layout cancels write and overrides layout.
            if (mLastWriteSpec != null) {
                IoUtils.closeQuietly(mLastWriteSpec.fd);
                mLastWriteSpec = null;
            }
            mLastLayoutSpec = new LayoutSpec();
            mLastLayoutSpec.callback = callback;
            mLastLayoutSpec.oldAttributes = oldAttributes;
            mLastLayoutSpec.newAttributes = newAttributes;
            mLastLayoutSpec.metadata = metadata;
            mLastLayoutSpec.sequence = sequence;
            // cancellation completes we will do the pending work.
            if (cancelPreviousCancellableOperationLocked()) {
                return;
            }
            doPendingWorkLocked();
        }
    }
    if (destroyed) {
        try {
            callback.onLayoutFailed(null, sequence);
        } catch (RemoteException re) {
            Log.i(LOG_TAG, ""Error notifying for cancelled layout"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,2,3","1,2","In the late implementation, a new local variable 'destroyed' is introduced. In the synchronized block, a new condition check '&& !mDestroyed' is added in the 'if' statement. After the synchronized block, a new 'if' block is inserted to handle the situations when 'destroyed' is true including calling a callback method and exception handling. According to these observations, the code change is a mix of return statement change (1), exception handling (2), and control dependency change (3).","The introduction of the new condition (i.e., '!mDestroyed') in the if statement can potentially impact the return values of this method. Additionally, the catch block catches RemoteException and log the error which changes the exception handling behavior of the implementation. Therefore, the compatibility issues exist due to potentially different return values (1) and potential changes in exception handling (2)."
40,"<android.app.ActivityThread.ApplicationThread: void dumpService(FileDescriptor,IBinder,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpService(FileDescriptor,IBinder,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpService(FileDescriptor,IBinder,String[])>",0,"{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = servicetoken;
        data.args = args;
        queueOrSendMessage(H.DUMP_SERVICE, data);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpService failed"", e);
    }
}","{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = servicetoken;
        data.args = args;
        sendMessage(H.DUMP_SERVICE, data, 0, 0, true);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpService failed"", e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",0,"The method queueOrSendMessage(H.DUMP_SERVICE, data) has been changed to sendMessage(H.DUMP_SERVICE, data, 0, 0, true) with different parameters, so the change type is 1,5.","This change does not lead to any compatibility issues as returning a different value or throwing a different exception is not occurring, so the CI type is 0."
41,"<android.app.ActivityThread.ApplicationThread: void dumpActivity(FileDescriptor,IBinder,String,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpActivity(FileDescriptor,IBinder,String,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpActivity(FileDescriptor,IBinder,String,String[])>",0,"{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = activitytoken;
        data.prefix = prefix;
        data.args = args;
        queueOrSendMessage(H.DUMP_ACTIVITY, data);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpActivity failed"", e);
    }
}","{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = activitytoken;
        data.prefix = prefix;
        data.args = args;
        sendMessage(H.DUMP_ACTIVITY, data, 0, 0, true);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpActivity failed"", e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only difference is that the method 'queueOrSendMessage' has been changed to 'sendMessage'. It does not belong to the other change types, so the code change type is 4.","The change might not cause changes to the return values or the exceptions thrown. Therefore, no Compatibility Issue should exist, so the CI type is 0."
43,<android.app.KeyguardManager: void exitKeyguardSecurely(OnKeyguardExitResult)>,19,20,<android.app.KeyguardManager: void exitKeyguardSecurely(OnKeyguardExitResult)>,<android.app.KeyguardManager: void exitKeyguardSecurely(OnKeyguardExitResult)>,0,"{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                callback.onKeyguardExitResult(success);
            }
        });
    } catch (RemoteException e) {
    }
}","{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                if (callback != null) {
                    callback.onKeyguardExitResult(success);
                }
            }
        });
    } catch (RemoteException e) {
    }
}",1,"/**
 * @deprecated Use {@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
 * and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
 * instead; this allows you to seamlessly hide the keyguard as your application
 * moves in and out of the foreground and does not require that any special
 * permissions be requested.
 *
 * Exit the keyguard securely.  The use case for this api is that, after
 * disabling the keyguard, your app, which was granted permission to
 * disable the keyguard and show a limited amount of information deemed
 * safe without the user getting past the keyguard, needs to navigate to
 * something that is not safe to view without getting past the keyguard.
 *
 * This will, if the keyguard is secure, bring up the unlock screen of
 * the keyguard.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#DISABLE_KEYGUARD}.
 *
 * @param callback Let's you know whether the operation was succesful and
 * it is safe to launch anything that would normally be considered safe
 * once the user has gotten past the keyguard.
 */
","/**
 * @deprecated Use {@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
 * and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
 * instead; this allows you to seamlessly hide the keyguard as your application
 * moves in and out of the foreground and does not require that any special
 * permissions be requested.
 *
 * Exit the keyguard securely.  The use case for this api is that, after
 * disabling the keyguard, your app, which was granted permission to
 * disable the keyguard and show a limited amount of information deemed
 * safe without the user getting past the keyguard, needs to navigate to
 * something that is not safe to view without getting past the keyguard.
 *
 * This will, if the keyguard is secure, bring up the unlock screen of
 * the keyguard.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#DISABLE_KEYGUARD}.
 *
 * @param callback Let's you know whether the operation was succesful and
 * it is safe to launch anything that would normally be considered safe
 * once the user has gotten past the keyguard.
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,3,0,"The anonymous class that implements the IOnKeyguardExitResult.Stub interface has an added 'if' condition in the onKeyguardExitResult() method, so the code change type is 3.","The added 'if' condition only checks if the callback is null. If callback is null, this API would not call callback.onKeyguardExitResult(success), which is also the case for the early version. So, no compatibility issue exists in this change. CI type is 0."
44,<android.hardware.camera2.impl.CameraDevice: void configureOutputs(List<Surface>)>,19,20,<android.hardware.camera2.impl.CameraDevice: void configureOutputs(List<Surface>)>,<android.hardware.camera2.impl.CameraDevice: void configureOutputs(List<Surface>)>,0,"{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<Surface>();
    }
    synchronized (mLock) {
        checkIfCameraClosed();
        // Streams to create
        HashSet<Surface> addSet = new HashSet<Surface>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            Surface s = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(s)) {
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(s);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            mRemoteDevice.waitUntilIdle();
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (Surface s : addSet) {
                // TODO: remove width,height,format since we are ignoring
                // it.
                int streamId = mRemoteDevice.createStream(0, 0, 0, s);
                mConfiguredOutputs.put(streamId, s);
            }
        // TODO: mRemoteDevice.endConfigure
        } catch (CameraRuntimeException e) {
            if (e.getReason() == CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."");
            }
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
        if (outputs.size() > 0) {
            mDeviceHandler.post(mCallOnIdle);
        } else {
            mDeviceHandler.post(mCallOnUnconfigured);
        }
    }
}","{
    // Treat a null input the same an empty list
    if (outputs == null) {
        outputs = new ArrayList<Surface>();
    }
    synchronized (mLock) {
        checkIfCameraClosed();
        // Streams to create
        HashSet<Surface> addSet = new HashSet<Surface>(outputs);
        // Streams to delete
        List<Integer> deleteList = new ArrayList<Integer>();
        // Determine which streams need to be created, which to be deleted
        for (int i = 0; i < mConfiguredOutputs.size(); ++i) {
            int streamId = mConfiguredOutputs.keyAt(i);
            Surface s = mConfiguredOutputs.valueAt(i);
            if (!outputs.contains(s)) {
                deleteList.add(streamId);
            } else {
                // Don't create a stream previously created
                addSet.remove(s);
            }
        }
        mDeviceHandler.post(mCallOnBusy);
        stopRepeating();
        try {
            waitUntilIdle();
            // Delete all streams first (to free up HW resources)
            for (Integer streamId : deleteList) {
                mRemoteDevice.deleteStream(streamId);
                mConfiguredOutputs.delete(streamId);
            }
            // Add all new streams
            for (Surface s : addSet) {
                // TODO: remove width,height,format since we are ignoring
                // it.
                int streamId = mRemoteDevice.createStream(0, 0, 0, s);
                mConfiguredOutputs.put(streamId, s);
            }
        // TODO: mRemoteDevice.endConfigure
        } catch (CameraRuntimeException e) {
            if (e.getReason() == CAMERA_IN_USE) {
                throw new IllegalStateException(""The camera is currently busy."" + "" You must wait until the previous operation completes."");
            }
            throw e.asChecked();
        } catch (RemoteException e) {
            // impossible
            return;
        }
        if (outputs.size() > 0) {
            mDeviceHandler.post(mCallOnIdle);
        } else {
            mDeviceHandler.post(mCallOnUnconfigured);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"In the late version, the syntax ""mRemoteDevice.waitUntilIdle();"" is changed to ""waitUntilIdle();"". This is a minor syntax modification and thus classified as other statement changed.","As the change is just a syntax modification and does not alter the outcome of the function, there is no Compatibility Issue with this change."
45,"<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: void onClientRegistered(int,int)>",19,20,"<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: void onClientRegistered(int,int)>","<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: void onClientRegistered(int,int)>",0,"{
    if (DBG)
        Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (mLeHandle == -1) {
            if (DBG)
                Log.d(TAG, ""onClientRegistered LE scan canceled"");
        }
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mLeHandle = clientIf;
            IBluetoothGatt iGatt = null;
            try {
                BluetoothAdapter adapter = mBluetoothAdapter.get();
                if (adapter != null) {
                    iGatt = adapter.getBluetoothManager().getBluetoothGatt();
                    if (mScanFilter == null) {
                        iGatt.startScan(mLeHandle, false);
                    } else {
                        ParcelUuid[] uuids = new ParcelUuid[mScanFilter.length];
                        for (int i = 0; i != uuids.length; ++i) {
                            uuids[i] = new ParcelUuid(mScanFilter[i]);
                        }
                        iGatt.startScanWithUuids(mLeHandle, false, uuids);
                    }
                } else {
                    Log.e(TAG, ""onClientRegistered, BluetoothAdapter null"");
                    mLeHandle = -1;
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mLeHandle = -1;
            }
            if (mLeHandle == -1) {
                // registration succeeded but start scan failed
                if (iGatt != null) {
                    try {
                        iGatt.unregisterClient(mLeHandle);
                    } catch (RemoteException e) {
                        Log.e(TAG, ""fail to unregister callback: "" + mLeHandle + "" error: "" + e);
                    }
                }
            }
        } else {
            // registration failed
            mLeHandle = -1;
        }
        notifyAll();
    }
}","{
    if (DBG)
        Log.d(TAG, ""onClientRegistered() - status="" + status + "" clientIf="" + clientIf);
    synchronized (this) {
        if (mLeHandle == -1) {
            if (DBG)
                Log.d(TAG, ""onClientRegistered LE scan canceled"");
        }
        if (status == BluetoothGatt.GATT_SUCCESS) {
            mLeHandle = clientIf;
            IBluetoothGatt iGatt = null;
            try {
                BluetoothAdapter adapter = mBluetoothAdapter.get();
                if (adapter != null) {
                    iGatt = adapter.getBluetoothManager().getBluetoothGatt();
                    if (mAdvertiseCallback != null) {
                        iGatt.startAdvertising(mLeHandle);
                    } else {
                        if (mScanFilter == null) {
                            iGatt.startScan(mLeHandle, false);
                        } else {
                            ParcelUuid[] uuids = new ParcelUuid[mScanFilter.length];
                            for (int i = 0; i != uuids.length; ++i) {
                                uuids[i] = new ParcelUuid(mScanFilter[i]);
                            }
                            iGatt.startScanWithUuids(mLeHandle, false, uuids);
                        }
                    }
                } else {
                    Log.e(TAG, ""onClientRegistered, BluetoothAdapter null"");
                    mLeHandle = -1;
                }
            } catch (RemoteException e) {
                Log.e(TAG, ""fail to start le scan: "" + e);
                mLeHandle = -1;
            }
            if (mLeHandle == -1) {
                // registration succeeded but start scan or advertise failed
                if (iGatt != null) {
                    try {
                        iGatt.unregisterClient(mLeHandle);
                    } catch (RemoteException e) {
                        Log.e(TAG, ""fail to unregister callback: "" + mLeHandle + "" error: "" + e);
                    }
                }
            }
        } else {
            // registration failed
            mLeHandle = -1;
        }
        notifyAll();
    }
}",1,"/**
 * Application interface registered - app is ready to go
 */
","/**
 * Application interface registered - app is ready to go
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4,5","1,2","A new condition statement has been introduced, and the implementation of the method iGatt.startAdvertising(mLeHandle) was added in the later version. Also, more values are being assigned to variables due to this new condition statement. Hence, the code change types classified as 3,4,5.","As a new method iGatt.startAdvertising(mLeHandle) is introduced and the variables' values such as mLeHandle and iGatt depend on a new condition, this new condition might also change the variables' value that used in return statements and exception handling. This could lead to potential different return values/types and exception handlings, hence the CI types are 1,2."
49,<android.app.MediaRouteButton: boolean performClick()>,19,20,<android.app.MediaRouteButton: boolean performClick()>,<android.app.MediaRouteButton: boolean performClick()>,0,"{
    // Send the appropriate accessibility events and call listeners
    boolean handled = super.performClick();
    if (!handled) {
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    if (mToggleMode) {
        if (mRemoteActive) {
            mRouter.selectRouteInt(mRouteTypes, mRouter.getDefaultRoute());
        } else {
            final int N = mRouter.getRouteCount();
            for (int i = 0; i < N; i++) {
                final RouteInfo route = mRouter.getRouteAt(i);
                if ((route.getSupportedTypes() & mRouteTypes) != 0 && route != mRouter.getDefaultRoute()) {
                    mRouter.selectRouteInt(mRouteTypes, route);
                }
            }
        }
    } else {
        showDialog();
    }
    return handled;
}","{
    // Send the appropriate accessibility events and call listeners
    boolean handled = super.performClick();
    if (!handled) {
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    return showDialogInternal() || handled;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"The implementation change in the late version includes changes in return statement, a control statement 'if (mToggleMode)' with its statements are deleted, and a new statement 'showDialogInternal()' is introduced. Therefore, the code change type is 1,3,4.","Due to the changes made in return statement and the deletion of control statements, the late version API may not behave the same as the early version, leading potentially to a different value being returned. Therefore, the CI type is 1."
50,<android.app.MediaRouteButton: void showDialog()>,19,20,<android.app.MediaRouteButton: void showDialog()>,<android.app.MediaRouteButton: void showDialog()>,0,"{
    final FragmentManager fm = getActivity().getFragmentManager();
    if (mDialogFragment == null) {
        // See if one is already attached to this activity.
        mDialogFragment = (MediaRouteChooserDialogFragment) fm.findFragmentByTag(MediaRouteChooserDialogFragment.FRAGMENT_TAG);
    }
    if (mDialogFragment != null) {
        Log.w(TAG, ""showDialog(): Already showing!"");
        return;
    }
    mDialogFragment = new MediaRouteChooserDialogFragment();
    mDialogFragment.setExtendedSettingsClickListener(mExtendedSettingsClickListener);
    mDialogFragment.setLauncherListener(new MediaRouteChooserDialogFragment.LauncherListener() {

        @Override
        public void onDetached(MediaRouteChooserDialogFragment detachedFragment) {
            mDialogFragment = null;
        }
    });
    mDialogFragment.setRouteTypes(mRouteTypes);
    mDialogFragment.show(fm, MediaRouteChooserDialogFragment.FRAGMENT_TAG);
}","{
    showDialogInternal();
}",1,"/**
 * Asynchronously show the route chooser dialog.
 * This will attach a {@link DialogFragment} to the containing Activity.
 */
","/**
 * Show the route chooser or controller dialog.
 * <p>
 * If the default route is selected or if the currently selected route does
 * not match the {@link #getRouteTypes route types}, then shows the route chooser dialog.
 * Otherwise, shows the route controller dialog to offer the user
 * a choice to disconnect from the route or perform other control actions
 * such as setting the route's volume.
 * </p><p>
 * This will attach a {@link DialogFragment} to the containing Activity.
 * </p>
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The entire implementation of method has been replaced with a call to a different method ""showDialogInternal()"", so the code change type is 1,5.","The complete change of implementation and the introduction of a new method will potentially make the API return different values or types, so the CI type is 1."
51,"<android.widget.AbsListView: View obtainView(int,boolean[])>",19,20,"<android.widget.AbsListView: View obtainView(int,boolean[])>","<android.widget.AbsListView: View obtainView(int,boolean[])>",0,"{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView == null) {
        scrapView = mRecycler.getScrapView(position);
    }
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}","{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, ""obtainView"");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}",1,"/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
","/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3,4",1,"The earlier code of getting family view from transient state or scrap has been changed. New control flow changes have been introduced to handle transient views where the view might be discarded if data cannot be rebound successfully. Also, a few miscellaneous statements like `scrapView = mRecycler.getTransientStateView(position);` have been deleted or replaced with other statements like `final View transientView = mRecycler.getTransientStateView(position);`. These types of changes fall under categories 1 (because the return statement might change due to the new flow), 3 (due to the new control flow), and 4 (because a few other code changes occurred).","The alteration of how transient view is managed (either assigned directly or attempted to re-bind the data) in the later version could potentially lead to a different returned View object in some situations where the data cannot be rebound successfully to the view. Hence, the potential CI Type is 1."
53,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",19,20,"<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>","<android.provider.DocumentsProvider: Bundle call(String,String,Bundle)>",0,"{
    final Context context = getContext();
    if (!method.startsWith(""android:"")) {
        // Let non-platform methods pass through
        return super.call(method, arg, extras);
    }
    final String documentId = extras.getString(Document.COLUMN_DOCUMENT_ID);
    final Uri documentUri = DocumentsContract.buildDocumentUri(mAuthority, documentId);
    // Require that caller can manage requested document
    final boolean callerHasManage = context.checkCallingOrSelfPermission(android.Manifest.permission.MANAGE_DOCUMENTS) == PackageManager.PERMISSION_GRANTED;
    if (!callerHasManage) {
        getContext().enforceCallingOrSelfUriPermission(documentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, method);
    }
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            out.putString(Document.COLUMN_DOCUMENT_ID, newDocumentId);
            // Extend permission grant towards caller if needed
            if (!callerHasManage) {
                final Uri newDocumentUri = DocumentsContract.buildDocumentUri(mAuthority, newDocumentId);
                context.grantUriPermission(getCallingPackage(), newDocumentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            context.revokeUriPermission(documentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}","{
    final Context context = getContext();
    if (!method.startsWith(""android:"")) {
        // Let non-platform methods pass through
        return super.call(method, arg, extras);
    }
    final String documentId = extras.getString(Document.COLUMN_DOCUMENT_ID);
    final Uri documentUri = DocumentsContract.buildDocumentUri(mAuthority, documentId);
    // Require that caller can manage requested document
    final boolean callerHasManage = context.checkCallingOrSelfPermission(android.Manifest.permission.MANAGE_DOCUMENTS) == PackageManager.PERMISSION_GRANTED;
    enforceWritePermissionInner(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            out.putString(Document.COLUMN_DOCUMENT_ID, newDocumentId);
            // Extend permission grant towards caller if needed
            if (!callerHasManage) {
                final Uri newDocumentUri = DocumentsContract.buildDocumentUri(mAuthority, newDocumentId);
                context.grantUriPermission(getCallingPackage(), newDocumentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            context.revokeUriPermission(documentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        } else {
            throw new UnsupportedOperationException(""Method not supported "" + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException(""Failed call "" + method, e);
    }
    return out;
}",1,"/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 *
 * @see #openDocument(String, String, CancellationSignal)
 * @see #deleteDocument(String)
 */
","/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 *
 * @see #openDocument(String, String, CancellationSignal)
 * @see #deleteDocument(String)
 */
",-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,2,"The method call getContext().enforceCallingOrSelfUriPermission() was replaced with enforceWritePermissionInner(), which is another method, thus the code change type is 4. ","The compatibility issue might arise due to change in method call which could potentially raise a different exception as the exception handling of these two methods might not be the same, so the CI type due to the new exception handling in the later version is 2."
57,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",19,20,"<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>","<android.hardware.SystemSensorManager.TriggerEventQueue: void dispatchSensorEvent(int,float[],int,long)>",0,"{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = mTriggerEvents.get(handle);
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}","{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, ""Error: Trigger Event is null for Sensor: "" + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}",1,"// Called from native code.
","// Called from native code.
",-1,"[@SuppressWarnings(""unused""), @Override]","[@SuppressWarnings(""unused""), @Override]",-1,-1,-1,-1,-1,-1,3,0,"In the late implementation, there is an addition of a synchronized statement, which is a control dependency change, hence classifying the code change as type 3.","The added synchronization block ensures that the 'mTriggerEvents.get(handle)' operation is thread safe, but this operation usually wouldn't affect the return value or exception handling of the method, so there are no compatibility issues to report. Thus, the CI type is 0."
59,<android.os.Message: String toString(long)>,19,20,<android.os.Message: String toString(long)>,<android.os.Message: String toString(long)>,0,"{
    StringBuilder b = new StringBuilder();
    b.append(""{ what="");
    b.append(what);
    b.append("" when="");
    TimeUtils.formatDuration(when - now, b);
    if (arg1 != 0) {
        b.append("" arg1="");
        b.append(arg1);
    }
    if (arg2 != 0) {
        b.append("" arg2="");
        b.append(arg2);
    }
    if (obj != null) {
        b.append("" obj="");
        b.append(obj);
    }
    b.append("" }"");
    return b.toString();
}","{
    StringBuilder b = new StringBuilder();
    b.append(""{ when="");
    TimeUtils.formatDuration(when - now, b);
    if (target != null) {
        if (callback != null) {
            b.append("" callback="");
            b.append(callback.getClass().getName());
        } else {
            b.append("" what="");
            b.append(what);
        }
        if (arg1 != 0) {
            b.append("" arg1="");
            b.append(arg1);
        }
        if (arg2 != 0) {
            b.append("" arg2="");
            b.append(arg2);
        }
        if (obj != null) {
            b.append("" obj="");
            b.append(obj);
        }
        b.append("" target="");
        b.append(target.getClass().getName());
    } else {
        b.append("" barrier="");
        b.append(arg1);
    }
    b.append("" }"");
    return b.toString();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new control flow statement (if (target != null)) is added, and within this block, new return value related commands are added, so the code change types are 1 and 3.","Due to the added control flow statement, the structure of the string returned by the _toString()_ method is potentially changed. This makes the output of the two versions potentially different, so the CI type is 1."
61,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,19,20,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,<android.app.ContextImpl: ContextImpl createSystemContext(ActivityThread)>,0,"{
    final ContextImpl context = new ContextImpl();
    context.init(Resources.getSystem(), mainThread, Process.myUserHandle());
    return context;
}","{
    LoadedApk packageInfo = new LoadedApk(mainThread);
    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, false, null, null);
    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(), context.mResourcesManager.getDisplayMetricsLocked(Display.DEFAULT_DISPLAY));
    return context;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement has changed from 'return context' after 'context.init(...)' to 'return context' after 'context.mResources.updateConfiguration(...)'. Also, the steps to initialize 'context' have been changed, so the code change type is 1,4.","The initialization and updates to the 'context' object have changed, which might change the state of the data that this method will return, therefore we can say the CI type is 1."
63,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,19,20,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,<android.os.ParcelFileDescriptor: ParcelFileDescriptor[] createReliableSocketPair()>,0,"{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}","{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}",1,"/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
","/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"4,5",1,"The parameter of a dependent API createCommSocketPair() has been changed, which belongs to Other statement change(4) and Dependent API change(5).","Since createCommSocketPair() function might return different results depending on the argument, the change in this function could potentially cause the API to return a different value and thus leads to a Compatibility Issue caused by potential different return values or types(1)."
66,<android.print.PrinterCapabilitiesInfo: List<Resolution> getResolutions()>,19,20,<android.print.PrinterCapabilitiesInfo: List<Resolution> getResolutions()>,<android.print.PrinterCapabilitiesInfo: List<Resolution> getResolutions()>,0,"{
    return mResolutions;
}","{
    return Collections.unmodifiableList(mResolutions);
}",1,"/**
 * Gets the supported resolutions.
 *
 * @return The resolutions.
 */
","/**
 * Gets the supported resolutions.
 *
 * @return The resolutions.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has modified from 'return mResolutions;' to 'return Collections.unmodifiableList(mResolutions);', and method 'Collections.unmodifiableList()' is called on 'mResolutions' in the late version, therefore the code change types are 1 and 5.","The change of return statement is making the API potentially return a different value. The early implementation returns mutable list, while the late version returns an unmodifiable list. Hence, the CI type is 1."
67,<android.app.MediaRouteActionProvider: boolean onPerformDefaultAction()>,19,20,<android.app.MediaRouteActionProvider: boolean onPerformDefaultAction()>,<android.app.MediaRouteActionProvider: boolean onPerformDefaultAction()>,0,"{
    final FragmentManager fm = getActivity().getFragmentManager();
    // See if one is already attached to this activity.
    MediaRouteChooserDialogFragment dialogFragment = (MediaRouteChooserDialogFragment) fm.findFragmentByTag(MediaRouteChooserDialogFragment.FRAGMENT_TAG);
    if (dialogFragment != null) {
        Log.w(TAG, ""onPerformDefaultAction(): Chooser dialog already showing!"");
        return false;
    }
    dialogFragment = new MediaRouteChooserDialogFragment();
    dialogFragment.setExtendedSettingsClickListener(mExtendedSettingsListener);
    dialogFragment.setRouteTypes(mRouteTypes);
    dialogFragment.show(fm, MediaRouteChooserDialogFragment.FRAGMENT_TAG);
    return true;
}","{
    if (mButton != null) {
        return mButton.showDialogInternal();
    }
    return false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The entire implementation has been replaced from a several line code block into a simple return statement, which indicates that both the return statement and control dependencies have changed, so the code change type is 1,3.","The return values are significantly different between the two versions, as the conditions determining the returned value have drastically changed, which could potentially return a different value than before. Thus, the CI type is 1."
70,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutCancelled()>,0,"{
    synchronized (mLock) {
        clearLocked();
    }
}","{
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        clearLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement is introduced under the new if condition. So the code change type is 1,3.","The introduction of a new if clause with a return statement potentially changes the execution flow of the method, which could lead to different behaviors. Therefore, the CI type is 1."
71,<android.printservice.PrintJob: int getAdvancedIntOption(String)>,19,20,<android.printservice.PrintJob: int getAdvancedIntOption(String)>,<android.printservice.PrintJob: int getAdvancedIntOption(String)>,0,"{
    PrintService.throwIfNotCalledOnMainThread();
    return 0;
}","{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedIntOption(key);
}",1,"/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */
","/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"Only the return statement 'return 0;' in the early version has been changed into 'return getInfo().getAdvancedIntOption(key);' in the late version, classified as a type 1 change.","Because the return value of the function has changed from a fixed '0' to 'getInfo().getAdvancedIntOption(key)', the method could potentially return a different value between the two versions, classified as a type 1 compatibility issue."
73,<android.widget.QuickContactBadge: void onClick(View)>,19,20,<android.widget.QuickContactBadge: void onClick(View)>,<android.widget.QuickContactBadge: void onClick(View)>,0,"{
    // If contact has been assigned, mExtras should no longer be null, but do a null check
    // anyway just in case assignContactFromPhone or Email was called with a null bundle or
    // wasn't assigned previously.
    final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactEmail);
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactPhone);
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}","{
    // If contact has been assigned, mExtras should no longer be null, but do a null check
    // anyway just in case assignContactFromPhone or Email was called with a null bundle or
    // wasn't assigned previously.
    final Bundle extras = (mExtras == null) ? new Bundle() : mExtras;
    if (mContactUri != null) {
        QuickContact.showQuickContact(getContext(), QuickContactBadge.this, mContactUri, QuickContact.MODE_LARGE, mExcludeMimes);
    } else if (mContactEmail != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactEmail);
        mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(mContactEmail)), EMAIL_LOOKUP_PROJECTION, null, null, null);
    } else if (mContactPhone != null && mQueryHandler != null) {
        extras.putString(EXTRA_URI_CONTENT, mContactPhone);
        mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER, extras, Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI, mContactPhone), PHONE_LOOKUP_PROJECTION, null, null, null);
    } else {
        // If a contact hasn't been assigned, don't react to click.
        return;
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition to startQuery has been changed from checking if mContactEmail or mContactPhone is not null to checking if both mContactEmail (or mContactPhone) and mQueryHandler are not null, so the code change type is 3.","The change of control dependency will affect the invocation of startQuery and thus could potentially make the API return early without executing startQuery. Therefore, the CI type is 1."
74,<android.widget.SpellChecker.SpellParser: void parse()>,19,20,<android.widget.SpellChecker.SpellParser: void parse()>,<android.widget.SpellChecker.SpellParser: void parse()>,0,"{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        removeRangeSpan(editable);
    }
    spellCheck();
}","{
    Editable editable = (Editable) mTextView.getText();
    // Iterate over the newly added text and schedule new SpellCheckSpans
    final int start;
    if (mIsSentenceSpellCheckSupported) {
        // TODO: Find the start position of the sentence.
        // Set span with the context
        start = Math.max(0, editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
    } else {
        start = editable.getSpanStart(mRange);
    }
    final int end = editable.getSpanEnd(mRange);
    int wordIteratorWindowEnd = Math.min(end, start + WORD_ITERATOR_INTERVAL);
    mWordIterator.setCharSequence(editable, start, wordIteratorWindowEnd);
    // Move back to the beginning of the current word, if any
    int wordStart = mWordIterator.preceding(start);
    int wordEnd;
    if (wordStart == BreakIterator.DONE) {
        wordEnd = mWordIterator.following(start);
        if (wordEnd != BreakIterator.DONE) {
            wordStart = mWordIterator.getBeginning(wordEnd);
        }
    } else {
        wordEnd = mWordIterator.getEnd(wordStart);
    }
    if (wordEnd == BreakIterator.DONE) {
        if (DBG) {
            Log.i(TAG, ""No more spell check."");
        }
        removeRangeSpan(editable);
        return;
    }
    // We need to expand by one character because we want to include the spans that
    // end/start at position start/end respectively.
    SpellCheckSpan[] spellCheckSpans = editable.getSpans(start - 1, end + 1, SpellCheckSpan.class);
    SuggestionSpan[] suggestionSpans = editable.getSpans(start - 1, end + 1, SuggestionSpan.class);
    int wordCount = 0;
    boolean scheduleOtherSpellCheck = false;
    if (mIsSentenceSpellCheckSupported) {
        if (wordIteratorWindowEnd < end) {
            if (DBG) {
                Log.i(TAG, ""schedule other spell check."");
            }
            // Several batches needed on that region. Cut after last previous word
            scheduleOtherSpellCheck = true;
        }
        int spellCheckEnd = mWordIterator.preceding(wordIteratorWindowEnd);
        boolean correct = spellCheckEnd != BreakIterator.DONE;
        if (correct) {
            spellCheckEnd = mWordIterator.getEnd(spellCheckEnd);
            correct = spellCheckEnd != BreakIterator.DONE;
        }
        if (!correct) {
            if (DBG) {
                Log.i(TAG, ""Incorrect range span."");
            }
            removeRangeSpan(editable);
            return;
        }
        do {
            // TODO: Find the start position of the sentence.
            int spellCheckStart = wordStart;
            boolean createSpellCheckSpan = true;
            // Cancel or merge overlapped spell check spans
            for (int i = 0; i < mLength; ++i) {
                final SpellCheckSpan spellCheckSpan = mSpellCheckSpans[i];
                if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
                    continue;
                }
                final int spanStart = editable.getSpanStart(spellCheckSpan);
                final int spanEnd = editable.getSpanEnd(spellCheckSpan);
                if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
                    // No need to merge
                    continue;
                }
                if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
                    // There is a completely overlapped spell check span
                    // skip this span
                    createSpellCheckSpan = false;
                    if (DBG) {
                        Log.i(TAG, ""The range is overrapped. Skip spell check."");
                    }
                    break;
                }
                // This spellCheckSpan is replaced by the one we are creating
                editable.removeSpan(spellCheckSpan);
                spellCheckStart = Math.min(spanStart, spellCheckStart);
                spellCheckEnd = Math.max(spanEnd, spellCheckEnd);
            }
            if (DBG) {
                Log.d(TAG, ""addSpellCheckSpan: "" + "", End = "" + spellCheckEnd + "", Start = "" + spellCheckStart + "", next = "" + scheduleOtherSpellCheck + ""\n"" + editable.subSequence(spellCheckStart, spellCheckEnd));
            }
            // Stop spell checking when there are no characters in the range.
            if (spellCheckEnd < start) {
                break;
            }
            if (spellCheckEnd <= spellCheckStart) {
                Log.w(TAG, ""Trying to spellcheck invalid region, from "" + start + "" to "" + end);
                break;
            }
            if (createSpellCheckSpan) {
                addSpellCheckSpan(editable, spellCheckStart, spellCheckEnd);
            }
        } while (false);
        wordStart = spellCheckEnd;
    } else {
        while (wordStart <= end) {
            if (wordEnd >= start && wordEnd > wordStart) {
                if (wordCount >= MAX_NUMBER_OF_WORDS) {
                    scheduleOtherSpellCheck = true;
                    break;
                }
                // not valid anymore and must be removed.
                if (wordStart < start && wordEnd > start) {
                    removeSpansAt(editable, start, spellCheckSpans);
                    removeSpansAt(editable, start, suggestionSpans);
                }
                if (wordStart < end && wordEnd > end) {
                    removeSpansAt(editable, end, spellCheckSpans);
                    removeSpansAt(editable, end, suggestionSpans);
                }
                // Do not create new boundary spans if they already exist
                boolean createSpellCheckSpan = true;
                if (wordEnd == start) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanEnd = editable.getSpanEnd(spellCheckSpans[i]);
                        if (spanEnd == start) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (wordStart == end) {
                    for (int i = 0; i < spellCheckSpans.length; i++) {
                        final int spanStart = editable.getSpanStart(spellCheckSpans[i]);
                        if (spanStart == end) {
                            createSpellCheckSpan = false;
                            break;
                        }
                    }
                }
                if (createSpellCheckSpan) {
                    addSpellCheckSpan(editable, wordStart, wordEnd);
                }
                wordCount++;
            }
            // iterate word by word
            int originalWordEnd = wordEnd;
            wordEnd = mWordIterator.following(wordEnd);
            if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
                wordIteratorWindowEnd = Math.min(end, originalWordEnd + WORD_ITERATOR_INTERVAL);
                mWordIterator.setCharSequence(editable, originalWordEnd, wordIteratorWindowEnd);
                wordEnd = mWordIterator.following(originalWordEnd);
            }
            if (wordEnd == BreakIterator.DONE)
                break;
            wordStart = mWordIterator.getBeginning(wordEnd);
            if (wordStart == BreakIterator.DONE) {
                break;
            }
        }
    }
    if (scheduleOtherSpellCheck && wordStart <= end) {
        // Update range span: start new spell check from last wordStart
        setRangeSpan(editable, wordStart, end);
    } else {
        if (DBG && scheduleOtherSpellCheck) {
            Log.w(TAG, ""Trying to schedule spellcheck for invalid region, from "" + wordStart + "" to "" + end);
        }
        removeRangeSpan(editable);
    }
    spellCheck();
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,,,,
76,<android.util.MapCollections.MapIterator: void remove()>,19,20,<android.util.MapCollections.MapIterator: void remove()>,<android.util.MapCollections.MapIterator: void remove()>,0,"{
    if (!mEntryValid) {
        throw new IllegalStateException();
    }
    mIndex--;
    mEnd--;
    mEntryValid = false;
    colRemoveAt(mIndex);
}","{
    if (!mEntryValid) {
        throw new IllegalStateException();
    }
    colRemoveAt(mIndex);
    mIndex--;
    mEnd--;
    mEntryValid = false;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,4,0,"Although the sequence of the statements in the method has changed, the overall operation performed by the method remains the same, that is, deleting an element. Thus, the change type is 4.","The sequence change in the internal operations does not affect the overall behaviour of the 'remove' method, and hence no compatibility issue is identified, and the CI type is 0."
80,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFinished(PageRange[])>,0,"{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
        clearLocked();
    }
    if (pages == null) {
        throw new IllegalArgumentException(""pages cannot be null"");
    }
    if (pages.length == 0) {
        throw new IllegalArgumentException(""pages cannot be empty"");
    }
    if (callback != null) {
        try {
            callback.onWriteFinished(pages, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFinished"", re);
        }
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (pages == null) {
        throw new IllegalArgumentException(""pages cannot be null"");
    }
    if (pages.length == 0) {
        throw new IllegalArgumentException(""pages cannot be empty"");
    }
    if (callback != null) {
        try {
            callback.onWriteFinished(pages, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFinished"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"A new condition checking for mDestroyed has been introduced and a new return statement under this condition has been added in the synchronized block. So, the code change type is 3,1.","The addition of the ""return;"" statement inside the ""if (mDestroyed)"" block could potentially change the return behavior of this method. Hence, from the user's perspective, the late version of this API may behave differently from the early version even under the same print operation. Therefore, the CI type is 1."
81,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,19,20,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,<android.bluetooth.BluetoothGattServer: boolean addService(BluetoothGattService)>,0,"{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mServices.add(service);
    try {
        mService.beginServiceDeclaration(mServerIf, service.getType(), service.getInstanceId(), service.getHandles(), new ParcelUuid(service.getUuid()));
        List<BluetoothGattService> includedServices = service.getIncludedServices();
        for (BluetoothGattService includedService : includedServices) {
            mService.addIncludedService(mServerIf, includedService.getType(), includedService.getInstanceId(), new ParcelUuid(includedService.getUuid()));
        }
        List<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();
        for (BluetoothGattCharacteristic characteristic : characteristics) {
            int permission = ((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
            mService.addCharacteristic(mServerIf, new ParcelUuid(characteristic.getUuid()), characteristic.getProperties(), permission);
            List<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();
            for (BluetoothGattDescriptor descriptor : descriptors) {
                permission = ((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
                mService.addDescriptor(mServerIf, new ParcelUuid(descriptor.getUuid()), permission);
            }
        }
        mService.endServiceDeclaration(mServerIf);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}","{
    if (DBG)
        Log.d(TAG, ""addService() - service: "" + service.getUuid());
    if (mService == null || mServerIf == 0)
        return false;
    mServices.add(service);
    try {
        mService.beginServiceDeclaration(mServerIf, service.getType(), service.getInstanceId(), service.getHandles(), new ParcelUuid(service.getUuid()), service.isAdvertisePreferred());
        List<BluetoothGattService> includedServices = service.getIncludedServices();
        for (BluetoothGattService includedService : includedServices) {
            mService.addIncludedService(mServerIf, includedService.getType(), includedService.getInstanceId(), new ParcelUuid(includedService.getUuid()));
        }
        List<BluetoothGattCharacteristic> characteristics = service.getCharacteristics();
        for (BluetoothGattCharacteristic characteristic : characteristics) {
            int permission = ((characteristic.getKeySize() - 7) << 12) + characteristic.getPermissions();
            mService.addCharacteristic(mServerIf, new ParcelUuid(characteristic.getUuid()), characteristic.getProperties(), permission);
            List<BluetoothGattDescriptor> descriptors = characteristic.getDescriptors();
            for (BluetoothGattDescriptor descriptor : descriptors) {
                permission = ((characteristic.getKeySize() - 7) << 12) + descriptor.getPermissions();
                mService.addDescriptor(mServerIf, new ParcelUuid(descriptor.getUuid()), permission);
            }
        }
        mService.endServiceDeclaration(mServerIf);
    } catch (RemoteException e) {
        Log.e(TAG, """", e);
        return false;
    }
    return true;
}",1,"/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the the list, the service and it's
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided
 * by this device.
 * @return true, if the service has been added successfully
 */
","/**
 * Add a service to the list of services to be hosted.
 *
 * <p>Once a service has been addded to the the list, the service and it's
 * included characteristics will be provided by the local device.
 *
 * <p>If the local device has already exposed services when this function
 * is called, a service update notification will be sent to all clients.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param service Service to be added to the list of services provided
 * by this device.
 * @return true, if the service has been added successfully
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,"The method parameter of the line ""mService.beginServiceDeclaration()"" has been changed from not having ""service.isAdvertisePreferred()"" to having ""service.isAdvertisePreferred()"", this indicates both a change in the return statement and in the dependent API","As a result of the code change, the behavior of the ""addService"" method may differ between the two versions depending on the return value from ""service.isAdvertisePreferred()"". This means that a compatibility issue exists and it is caused by potential different return values or types."
82,<android.view.View: boolean fitSystemWindows(Rect)>,19,20,<android.view.View: boolean fitSystemWindows(Rect)>,<android.view.View: boolean fitSystemWindows(Rect)>,0,"{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        Rect localInsets = sThreadLocal.get();
        if (localInsets == null) {
            localInsets = new Rect();
            sThreadLocal.set(localInsets);
        }
        boolean res = computeFitSystemWindows(insets, localInsets);
        internalSetPadding(localInsets.left, localInsets.top, localInsets.right, localInsets.bottom);
        return res;
    }
    return false;
}","{
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        Rect localInsets = sThreadLocal.get();
        if (localInsets == null) {
            localInsets = new Rect();
            sThreadLocal.set(localInsets);
        }
        boolean res = computeFitSystemWindows(insets, localInsets);
        mUserPaddingLeftInitial = localInsets.left;
        mUserPaddingRightInitial = localInsets.right;
        internalSetPadding(localInsets.left, localInsets.top, localInsets.right, localInsets.bottom);
        return res;
    }
    return false;
}",1,"/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * insets to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return {@code true} if this view applied the insets and it should not
 * continue propagating further down the hierarchy, {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
","/**
 * Called by the view hierarchy when the content insets for a window have
 * changed, to allow it to adjust its content to fit within those windows.
 * The content insets tell you the space that the status bar, input method,
 * and other system windows infringe on the application's window.
 *
 * <p>You do not normally need to deal with this function, since the default
 * window decoration given to applications takes care of applying it to the
 * content of the window.  If you use {@link #SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN}
 * or {@link #SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION} this will not be the case,
 * and your content can be placed under those system elements.  You can then
 * use this method within your view hierarchy if you have parts of your UI
 * which you would like to ensure are not being covered.
 *
 * <p>The default implementation of this method simply applies the content
 * insets to the view's padding, consuming that content (modifying the
 * insets to be 0), and returning true.  This behavior is off by default, but can
 * be enabled through {@link #setFitsSystemWindows(boolean)}.
 *
 * <p>This function's traversal down the hierarchy is depth-first.  The same content
 * insets object is propagated down the hierarchy, so any changes made to it will
 * be seen by all following views (including potentially ones above in
 * the hierarchy since this is a depth-first traversal).  The first view
 * that returns true will abort the entire traversal.
 *
 * <p>The default implementation works well for a situation where it is
 * used with a container that covers the entire window, allowing it to
 * apply the appropriate insets to its content on all edges.  If you need
 * a more complicated layout (such as two different views fitting system
 * windows, one on the top of the window, and one on the bottom),
 * you can override the method and handle the insets however you would like.
 * Note that the insets provided by the framework are always relative to the
 * far edges of the window, not accounting for the location of the called view
 * within that window.  (In fact when this method is called you do not yet know
 * where the layout will place the view, as it is done before layout happens.)
 *
 * <p>Note: unlike many View methods, there is no dispatch phase to this
 * call.  If you are overriding it in a ViewGroup and want to allow the
 * call to continue to your children, you must be sure to call the super
 * implementation.
 *
 * <p>Here is a sample layout that makes use of fitting system windows
 * to have controls for a video view placed inside of the window decorations
 * that it hides and shows.  This can be used with code like the second
 * sample (video player) shown in {@link #setSystemUiVisibility(int)}.
 *
 * {@sample development/samples/ApiDemos/res/layout/video_player.xml complete}
 *
 * @param insets Current content insets of the window.  Prior to
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} you must not modify
 * the insets or else you and Android will be unhappy.
 *
 * @return {@code true} if this view applied the insets and it should not
 * continue propagating further down the hierarchy, {@code false} otherwise.
 * @see #getFitsSystemWindows()
 * @see #setFitsSystemWindows(boolean)
 * @see #setSystemUiVisibility(int)
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"There are only couple of new statements introduced which assigns values to `mUserPaddingLeftInitial` and `mUserPaddingRightInitial`. So, the code change type is 4.","These new statements don't affect the behaviour of method, as they don't interfere with returned values or the exceptions thrown. Therefore, there are no compatibility issues (CI type 0)."
84,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,19,20,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,<android.view.ViewRootImpl.SyntheticInputStage: int onProcess(QueuedInputEvent)>,0,"{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    } else if (q.mEvent instanceof KeyEvent) {
        if (mKeys.process((KeyEvent) q.mEvent)) {
            return FINISH_HANDLED;
        }
    }
    return FORWARD;
}","{
    q.mFlags |= QueuedInputEvent.FLAG_RESYNTHESIZED;
    if (q.mEvent instanceof MotionEvent) {
        final MotionEvent event = (MotionEvent) q.mEvent;
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            mTrackball.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            mJoystick.process(event);
            return FINISH_HANDLED;
        } else if ((source & InputDevice.SOURCE_TOUCH_NAVIGATION) == InputDevice.SOURCE_TOUCH_NAVIGATION) {
            mTouchNavigation.process(event);
            return FINISH_HANDLED;
        }
    }
    return FORWARD;
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The statement 'else if (q.mEvent instanceof KeyEvent)' along with its conditions has been removed in the late version, which is a control statement change, so the code change type is 3.","As the condition statement 'else if (q.mEvent instanceof KeyEvent)' has been removed, the 'return FINISH_HANDLED' will not be executed when the condition is true in the late version. Therefore, it may return a different value, causing the CI type to be 1."
85,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,19,20,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,<android.net.LocalSocketImpl: void accept(LocalSocketImpl)>,0,"{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    s.fd = accept(fd, s);
}","{
    if (fd == null) {
        throw new IOException(""socket not created"");
    }
    s.fd = accept(fd, s);
    s.mFdCreatedInternally = true;
}",1,"/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @param s a socket that will be used to represent the new connection.
 * @throws IOException
 */
","/**
 * Accepts a new connection to the socket. Blocks until a new
 * connection arrives.
 *
 * @param s a socket that will be used to represent the new connection.
 * @throws IOException
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,0,"A new statement has been added in the late version, which sets s.mFdCreatedInternally as true. Hence, the change class is 1.","However, The introduced new statement which only changes the internal state of the LocalSocketImpl object 's' does not affect the behaviour of the 'accept' method regarding its return value or exceptions thrown, which suggests that no compatibility issues exist. So the CI type is 0."
88,"<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>",19,20,"<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>","<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFinished(PrintDocumentInfo,boolean)>",0,"{
    if (info == null) {
        throw new NullPointerException(""document info cannot be null"");
    }
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFinished(info, changed, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFinished"", re);
        }
    }
}","{
    if (info == null) {
        throw new NullPointerException(""document info cannot be null"");
    }
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFinished(info, changed, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFinished"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"The late version introduces a new control flow making the method return earlier under some circumstances, and adds an extra log output (Log.e()). So the change is classified as type 1 and 3.","Considering the newly added 'return' statement inside the 'synchronized' block, the function can potentially return a different type in the late version depending upon the condition 'mDestroyed', so the CI type is 1."
94,<android.app.MediaRouteActionProvider: boolean isVisible()>,19,20,<android.app.MediaRouteActionProvider: boolean isVisible()>,<android.app.MediaRouteActionProvider: boolean isVisible()>,0,"{
    return mRouter.getRouteCount() > 1;
}","{
    return mRouter.isRouteAvailable(mRouteTypes, MediaRouter.AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,5",1,"The return statement has changed from 'return mRouter.getRouteCount() > 1' to 'return mRouter.isRouteAvailable(mRouteTypes, MediaRouter.AVAILABILITY_FLAG_IGNORE_DEFAULT_ROUTE)', and the dependent API has changed from 'getRouteCount()' to 'isRouteAvailable()', so the code change type is 1,5.","The change of the return statement will make the API potentially return a different value as the condition for returning true or false has changed. Hence, the compatibility issue type is 1."
95,"<android.hardware.camera2.impl.CameraDevice.CameraDeviceCallbacks: void onResultReceived(int,CameraMetadataNative)>",19,20,"<android.hardware.camera2.impl.CameraDevice.CameraDeviceCallbacks: void onResultReceived(int,CameraMetadataNative)>","<android.hardware.camera2.impl.CameraDevice.CameraDeviceCallbacks: void onResultReceived(int,CameraMetadataNative)>",0,"{
    if (DEBUG) {
        Log.d(TAG, ""Received result for id "" + requestId);
    }
    final CaptureListenerHolder holder;
    synchronized (mLock) {
        // TODO: move this whole map into this class to make it more testable,
        // exposing the methods necessary like subscribeToRequest, unsubscribe..
        // TODO: make class static class
        holder = CameraDevice.this.mCaptureListenerMap.get(requestId);
        // keep a counter.
        if (holder != null && !holder.isRepeating()) {
            CameraDevice.this.mCaptureListenerMap.remove(requestId);
        }
    }
    // Check if we have a listener for this
    if (holder == null) {
        return;
    }
    if (isClosed())
        return;
    final CaptureRequest request = holder.getRequest();
    final CaptureResult resultAsCapture = new CaptureResult(result, request, requestId);
    holder.getHandler().post(new Runnable() {

        @Override
        public void run() {
            if (!CameraDevice.this.isClosed()) {
                holder.getListener().onCaptureCompleted(CameraDevice.this, request, resultAsCapture);
            }
        }
    });
}","{
    if (DEBUG) {
        Log.d(TAG, ""Received result for id "" + requestId);
    }
    final CaptureListenerHolder holder;
    Boolean quirkPartial = result.get(CaptureResult.QUIRKS_PARTIAL_RESULT);
    boolean quirkIsPartialResult = (quirkPartial != null && quirkPartial);
    synchronized (mLock) {
        // TODO: move this whole map into this class to make it more testable,
        // exposing the methods necessary like subscribeToRequest, unsubscribe..
        // TODO: make class static class
        holder = CameraDevice.this.mCaptureListenerMap.get(requestId);
        // Clean up listener once we no longer expect to see it.
        if (holder != null && !holder.isRepeating() && !quirkIsPartialResult) {
            CameraDevice.this.mCaptureListenerMap.remove(requestId);
        }
        // requests from mCaptureListenerMap.
        if (holder != null && holder.isRepeating() && !quirkIsPartialResult && mRepeatingRequestIdDeletedList.size() > 0) {
            Iterator<Integer> iter = mRepeatingRequestIdDeletedList.iterator();
            while (iter.hasNext()) {
                int deletedRequestId = iter.next();
                if (deletedRequestId < requestId) {
                    CameraDevice.this.mCaptureListenerMap.remove(deletedRequestId);
                    iter.remove();
                }
            }
        }
    }
    // Check if we have a listener for this
    if (holder == null) {
        return;
    }
    if (isClosed())
        return;
    final CaptureRequest request = holder.getRequest();
    final CaptureResult resultAsCapture = new CaptureResult(result, request, requestId);
    Runnable resultDispatch = null;
    // Either send a partial result or the final capture completed result
    if (quirkIsPartialResult) {
        // Partial result
        resultDispatch = new Runnable() {

            @Override
            public void run() {
                if (!CameraDevice.this.isClosed()) {
                    holder.getListener().onCapturePartial(CameraDevice.this, request, resultAsCapture);
                }
            }
        };
    } else {
        // Final capture result
        resultDispatch = new Runnable() {

            @Override
            public void run() {
                if (!CameraDevice.this.isClosed()) {
                    holder.getListener().onCaptureCompleted(CameraDevice.this, request, resultAsCapture);
                }
            }
        };
    }
    holder.getHandler().post(resultDispatch);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3,4",1,"In the late version, the variable quirkPartial is introduced, and a new 'if' statement with quirkIsPartialResult is added; and the synchronized block has been changed, as well as the value of the Runnable variable resultDispatch. Thus, the code change type is 1,3,4.","The new variable quirkIsPartialResult changes the control flow of the program, potentially affecting the value to be returned in late version, making the CI type as 1."
98,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",19,20,"<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>","<android.os.ParcelFileDescriptor: ParcelFileDescriptor open(File,int,Handler,OnCloseListener)>",0,"{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair(true);
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    // Kick off thread to watch for status updates
    final ListenerBridge bridge = new ListenerBridge(comm[1], handler.getLooper(), listener);
    bridge.start();
    return pfd;
}","{
    if (handler == null) {
        throw new IllegalArgumentException(""Handler must not be null"");
    }
    if (listener == null) {
        throw new IllegalArgumentException(""Listener must not be null"");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    // Kick off thread to watch for status updates
    IoUtils.setBlocking(comm[1], true);
    final ListenerBridge bridge = new ListenerBridge(comm[1], handler.getLooper(), listener);
    bridge.start();
    return pfd;
}",1,"/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
","/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The statement ""createCommSocketPair(true)"" is changed to ""createCommSocketPair()"" and a new statement ""IoUtils.setBlocking(comm[1], true)"" is added in the late version code. This means a return statement, a normal statement and a dependent API have been altered, so the change type is 1,4,5.","The alteration of the dependent API will potentially impact the return value of the method. Therefore, a compatibility issue caused by potentially different return values or types (type 1) exists."
100,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",19,20,"<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>","<android.provider.DocumentsContract: Bitmap getDocumentThumbnail(ContentResolver,Uri,Point,CancellationSignal)>",0,"{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}","{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, ""Failed to load thumbnail for "" + documentUri + "": "" + e);
        }
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}",1,"/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
","/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */
",-1,,,-1,-1,-1,-1,-1,-1,3,0,"The catch block has been modified to introduce a new condition 'if (!(e instanceof OperationCanceledException))', so the code change type is 3.","Despite the change in the catch block to check for a specific exception type (OperationCanceledException), the behavior of the method remains the same. It logs the exception (except when it's an OperationCanceledException) and returns null in case of an exception while it did the same without the specific condition check in the early version. So, no Compatibility Issue exists, and the CI type is 0."
102,<android.app.MediaRouteButton: void setRouteTypes(int)>,19,20,<android.app.MediaRouteButton: void setRouteTypes(int)>,<android.app.MediaRouteButton: void setRouteTypes(int)>,0,"{
    if (types == mRouteTypes) {
        // Already registered; nothing to do.
        return;
    }
    if (mAttachedToWindow && mRouteTypes != 0) {
        mRouter.removeCallback(mRouterCallback);
    }
    mRouteTypes = types;
    if (mAttachedToWindow) {
        updateRouteInfo();
        mRouter.addCallback(types, mRouterCallback);
    }
}","{
    if (mRouteTypes != types) {
        if (mAttachedToWindow && mRouteTypes != 0) {
            mRouter.removeCallback(mCallback);
        }
        mRouteTypes = types;
        if (mAttachedToWindow && types != 0) {
            mRouter.addCallback(types, mCallback, MediaRouter.CALLBACK_FLAG_PASSIVE_DISCOVERY);
        }
        refreshRoute();
    }
}",1,,"/**
 * Sets the types of routes that will be shown in the media route chooser dialog
 * launched by this button.
 *
 * @param types The route types to match.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",1,"The condition statement has changed from 'if (types == mRouteTypes)' to 'if (mRouteTypes != types)', and some other statements like 'updateRouteInfo()' are deleted and new statement 'refreshRoute()' is introduced, so the change type is 3,4.","As the condition statement after 'if' has changed, the flow of the program may be different, which may lead to different operations. Thus, the return status of the API may vary which is a compatibility issue. Therefore, the CI type is 1."
103,<android.app.ContextImpl: Context createDisplayContext(Display)>,19,20,<android.app.ContextImpl: Context createDisplayContext(Display)>,<android.app.ContextImpl: Context createDisplayContext(Display)>,0,"{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    int displayId = display.getDisplayId();
    ContextImpl context = new ContextImpl();
    context.init(mPackageInfo, null, mMainThread);
    context.mDisplay = display;
    DisplayAdjustments daj = getDisplayAdjustments(displayId);
    context.mResources = mResourcesManager.getTopLevelResources(mPackageInfo.getResDir(), displayId, null, daj.getCompatibilityInfo(), null);
    return context;
}","{
    if (display == null) {
        throw new IllegalArgumentException(""display must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, display, mOverrideConfiguration);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The method has been completely rewritten, with a new return statement that creates a new instance of 'ContextImpl' and passes arguments differently than in the previous version. Therefore, the code change type is 1,4.","The new return statement constructs a new instance of 'ContextImpl' in a different way, potentially resulting in different types, resulting in the CI type being 1. The thrown IllegalArgumentException remains the same in both versions, so there's no change in exception handling (CI type 2)."
105,<android.transition.TransitionInflater: TransitionInflater from(Context)>,19,20,<android.transition.TransitionInflater: TransitionInflater from(Context)>,<android.transition.TransitionInflater: TransitionInflater from(Context)>,0,"{
    TransitionInflater inflater = sInflaterMap.get(context);
    if (inflater != null) {
        return inflater;
    }
    inflater = new TransitionInflater(context);
    sInflaterMap.put(context, inflater);
    return inflater;
}","{
    return new TransitionInflater(context);
}",1,"/**
 * Obtains the TransitionInflater from the given context.
 */
","/**
 * Obtains the TransitionInflater from the given context.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,4",1,"The control structure and the return value variable have changed. The map sInflaterMap is no longer consulted or updated. So, the code change type is 1,4.","The returned inflater is no longer retrieved from the sInflaterMap or populated into it. The 'inflater' is now always a freshly initiated one, which might potentially lead to different behaviours. Therefore the CI type is 1."
106,<android.os.Bundle: void unparcel()>,19,20,<android.os.Bundle: void unparcel()>,<android.os.Bundle: void unparcel()>,0,"{
    if (mParcelledData == null) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
        return;
    }
    int N = mParcelledData.readInt();
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new ArrayMap<String, Object>(N);
    } else {
        mMap.erase();
        mMap.ensureCapacity(N);
    }
    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
}","{
    if (mParcelledData == null) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": no parcelled data"");
        return;
    }
    if (mParcelledData == EMPTY_PARCEL) {
        if (DEBUG)
            Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": empty"");
        if (mMap == null) {
            mMap = new ArrayMap<String, Object>(1);
        } else {
            mMap.erase();
        }
        mParcelledData = null;
        return;
    }
    int N = mParcelledData.readInt();
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "": reading "" + N + "" maps"");
    if (N < 0) {
        return;
    }
    if (mMap == null) {
        mMap = new ArrayMap<String, Object>(N);
    } else {
        mMap.erase();
        mMap.ensureCapacity(N);
    }
    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
    if (DEBUG)
        Log.d(TAG, ""unparcel "" + Integer.toHexString(System.identityHashCode(this)) + "" final map: "" + mMap);
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,"3,4",0,"The control dependency has been changed in the late version where a new if condition has been added to check if mParcelledData == EMPTY_PARCEL, and the following statements have been added. Besides, the log messages are changed as well, so the code change type is 3 (Control Dependency changed) and 4 (Other statement changed).","Despite the added lines of code, there are no changes in the function that cause it to potentially return a different value or throw an exception that didn't exist in the early version, so there is no compatibility issue."
107,<android.preference.Preference: int compareTo(Preference)>,19,20,<android.preference.Preference: int compareTo(Preference)>,<android.preference.Preference: int compareTo(Preference)>,0,"{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}","{
    if (mOrder != another.mOrder) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}",1,"/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
","/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */
",-1,,[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition in the first 'if' statement has changed, this corresponds to a Control dependency change. Therefore, the code change type is 3.","Since the condition of the first 'if' statement has been changed, it could potentially affect the outcome of the return statements that follow, causing the method to potentially return a different value. Therefore, the CI type is 1."
109,"<android.transition.Scene: Scene getSceneForLayout(ViewGroup,int,Context)>",19,20,"<android.transition.Scene: Scene getSceneForLayout(ViewGroup,int,Context)>","<android.transition.Scene: Scene getSceneForLayout(ViewGroup,int,Context)>",0,"{
    SparseArray<Scene> scenes = sScenes.get();
    if (scenes == null) {
        scenes = new SparseArray<Scene>();
        sScenes.set(scenes);
    }
    Scene scene = scenes.get(layoutId);
    if (scene != null) {
        return scene;
    } else {
        scene = new Scene(sceneRoot, layoutId, context);
        scenes.put(layoutId, scene);
        return scene;
    }
}","{
    SparseArray<Scene> scenes = (SparseArray<Scene>) sceneRoot.getTag(com.android.internal.R.id.scene_layoutid_cache);
    if (scenes == null) {
        scenes = new SparseArray<Scene>();
        sceneRoot.setTagInternal(com.android.internal.R.id.scene_layoutid_cache, scenes);
    }
    Scene scene = scenes.get(layoutId);
    if (scene != null) {
        return scene;
    } else {
        scene = new Scene(sceneRoot, layoutId, context);
        scenes.put(layoutId, scene);
        return scene;
    }
}",1,"/**
 * Returns a Scene described by the resource file associated with the given
 * <code>layoutId</code> parameter. If such a Scene has already been created,
 * that same Scene will be returned. This caching of layoutId-based scenes enables
 * sharing of common scenes between those created in code and those referenced
 * by {@link TransitionManager} XML resource files.
 *
 * @param sceneRoot The root of the hierarchy in which scene changes
 * and transitions will take place.
 * @param layoutId The id of a standard layout resource file.
 * @param context The context used in the process of inflating
 * the layout resource.
 * @return
 */
","/**
 * Returns a Scene described by the resource file associated with the given
 * <code>layoutId</code> parameter. If such a Scene has already been created for
 * the given <code>sceneRoot</code>, that same Scene will be returned.
 * This caching of layoutId-based scenes enables sharing of common scenes
 * between those created in code and those referenced by {@link TransitionManager}
 * XML resource files.
 *
 * @param sceneRoot The root of the hierarchy in which scene changes
 * and transitions will take place.
 * @param layoutId The id of a standard layout resource file.
 * @param context The context used in the process of inflating
 * the layout resource.
 * @return The scene for the given root and layout id
 */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only change between the two versions is how `scenes` is initialized and saved, but the remaining codes and the return statement `return scene` stay the same, the change type is 4.","Even though the way `scenes` is initialized and saved is changed, the method would still return the same type of results and throw the same exceptions. The sequence of operation and logic of the method remain unchanged, therefore, no compatibility issues exist, CI type is 0."
110,<android.print.PrintJobInfo: String toString()>,19,20,<android.print.PrintJobInfo: String toString()>,<android.print.PrintJobInfo: String toString()>,0,"{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintJobInfo{"");
    builder.append(""label: "").append(mLabel);
    builder.append("", id: "").append(mId);
    builder.append("", state: "").append(stateToString(mState));
    builder.append("", printer: "" + mPrinterId);
    builder.append("", tag: "").append(mTag);
    builder.append("", creationTime: "" + mCreationTime);
    builder.append("", copies: "").append(mCopies);
    builder.append("", attributes: "" + (mAttributes != null ? mAttributes.toString() : null));
    builder.append("", documentInfo: "" + (mDocumentInfo != null ? mDocumentInfo.toString() : null));
    builder.append("", cancelling: "" + mCanceling);
    builder.append("", pages: "" + (mPageRanges != null ? Arrays.toString(mPageRanges) : null));
    builder.append(""}"");
    return builder.toString();
}","{
    StringBuilder builder = new StringBuilder();
    builder.append(""PrintJobInfo{"");
    builder.append(""label: "").append(mLabel);
    builder.append("", id: "").append(mId);
    builder.append("", state: "").append(stateToString(mState));
    builder.append("", printer: "" + mPrinterId);
    builder.append("", tag: "").append(mTag);
    builder.append("", creationTime: "" + mCreationTime);
    builder.append("", copies: "").append(mCopies);
    builder.append("", attributes: "" + (mAttributes != null ? mAttributes.toString() : null));
    builder.append("", documentInfo: "" + (mDocumentInfo != null ? mDocumentInfo.toString() : null));
    builder.append("", cancelling: "" + mCanceling);
    builder.append("", pages: "" + (mPageRanges != null ? Arrays.toString(mPageRanges) : null));
    builder.append("", hasAdvancedOptions: "" + (mAdvancedOptions != null));
    builder.append(""}"");
    return builder.toString();
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"A new line of code has been added to append a new attribute (hasAdvancedOptions) to StringBuilder, so the code change types are 1 and 4.","The introduction of a new line of code will effect the return value of the API, which can make the output string different in the late version, so the CI type is 1."
112,"<android.os.Bundle: void writeToParcel(Parcel,int)>",19,20,"<android.os.Bundle: void writeToParcel(Parcel,int)>","<android.os.Bundle: void writeToParcel(Parcel,int)>",0,"{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}","{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            if (mParcelledData == EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
        } else {
            // Special case for empty bundles.
            if (mMap == null || mMap.size() <= 0) {
                parcel.writeInt(0);
                return;
            }
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}",1,"/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
","/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the Late_Implementation, new control statements were added to check if `mParcelledData == EMPTY_PARCEL` and `mMap == null || mMap.size() <= 0`, and a new return statement `return;` was introduced. Therefore, the code change falls into categories 1 and 3.","The new control statements and return statement in the late version could cause the API to potentially return different types or values when compared to the early version. Hence, a compatibility issue of type 1 could exist."
114,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,19,20,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,<android.os.MessageQueue: int enqueueSyncBarrier(long)>,0,"{
    // We don't need to wake the queue because the purpose of a barrier is to stall it.
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.arg1 = token;
        Message prev = null;
        Message p = mMessages;
        if (when != 0) {
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) {
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}","{
    // We don't need to wake the queue because the purpose of a barrier is to stall it.
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.when = when;
        msg.arg1 = token;
        Message prev = null;
        Message p = mMessages;
        if (when != 0) {
            while (p != null && p.when <= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) {
            // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,4,0,"The line 'msg.when = when;' is added. This is a particular assignment statement, which is neither a return nor a exception handling, nor a control dependency change. Therefore, this difference between the early version and the late version could be classified as 'Other statement changed' (4).",This code modification won't impact the values potentially returned by this function nor the exceptions it may throw. So no Compatibility Issue exists for this piece of code.
115,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,19,20,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,<android.app.ContextImpl: Context createConfigurationContext(Configuration)>,0,"{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    ContextImpl c = new ContextImpl();
    c.init(mPackageInfo, null, mMainThread);
    c.mResources = mResourcesManager.getTopLevelResources(mPackageInfo.getResDir(), getDisplayId(), overrideConfiguration, mResources.getCompatibilityInfo(), mActivityToken);
    return c;
}","{
    if (overrideConfiguration == null) {
        throw new IllegalArgumentException(""overrideConfiguration must not be null"");
    }
    return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, mUser, mRestricted, mDisplay, overrideConfiguration);
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,"The return statement changes from creating an instance of ContextImpl and then initializing fields manually, to creating an instance of ContextImpl with parameters in the constructor. Therefore, the change types are 1 and 4.","Because the object creation process and the order of input parameters in the 'ContextImpl' construction have been modified, the object returned by the API might be different. Therefore, it is a compatibility issue (CI=1)."
116,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>",19,20,"<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>","<android.print.PrintManager.PrintDocumentAdapterDelegate: void write(PageRange[],ParcelFileDescriptor,IWriteResultCallback,int)>",0,"{
    synchronized (mLock) {
        // Start not called or finish called - nothing to do.
        if (!mStartReqeusted || mFinishRequested) {
            return;
        }
        // Write cancels previous writes.
        if (mLastWriteSpec != null) {
            IoUtils.closeQuietly(mLastWriteSpec.fd);
            mLastWriteSpec = null;
        }
        mLastWriteSpec = new WriteSpec();
        mLastWriteSpec.callback = callback;
        mLastWriteSpec.pages = pages;
        mLastWriteSpec.fd = fd;
        mLastWriteSpec.sequence = sequence;
        // cancellation completes we will do the pending work.
        if (cancelPreviousCancellableOperationLocked()) {
            return;
        }
        doPendingWorkLocked();
    }
}","{
    final boolean destroyed;
    synchronized (mLock) {
        destroyed = mDestroyed;
        // If start called and not finished called and not destroyed - do some work.
        if (mStartReqeusted && !mFinishRequested && !mDestroyed) {
            // Write cancels previous writes.
            if (mLastWriteSpec != null) {
                IoUtils.closeQuietly(mLastWriteSpec.fd);
                mLastWriteSpec = null;
            }
            mLastWriteSpec = new WriteSpec();
            mLastWriteSpec.callback = callback;
            mLastWriteSpec.pages = pages;
            mLastWriteSpec.fd = fd;
            mLastWriteSpec.sequence = sequence;
            // cancellation completes we will do the pending work.
            if (cancelPreviousCancellableOperationLocked()) {
                return;
            }
            doPendingWorkLocked();
        }
    }
    if (destroyed) {
        try {
            callback.onWriteFailed(null, sequence);
        } catch (RemoteException re) {
            Log.i(LOG_TAG, ""Error notifying for cancelled write"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"2,3","1,2","The change is taking place in an exception handling statement. In the late version, an exception handling statement (try-catch block) has been added. Also, a new condition to check if 'mDestroyed' is true/false is added within the synchronized block. So the code change types are 2 for the addition of exception handling and 3 for the modified control dependency.","Due to the addition of exception handling, there is a possibility that the method may throw a new exception, leading to a potential compatibility issue of type 2. Furthermore, the added condition inside the synchronized block can lead to a different outcome (either invoking the method doPendingWorkLocked() or returning a callback on failure), causing a potential discrepancy in return values or types, marking a compatibility issue of type 1. Therefore, the CI types are 1,2."
117,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",19,20,"<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>","<android.app.ContextImpl: Context createPackageContextAsUser(String,int,UserHandle)>",0,"{
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        final ContextImpl context = new ContextImpl(mMainThread.getSystemContext());
        context.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        context.init(mPackageInfo, null, mMainThread, mResources, mBasePackageName, user);
        return context;
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl();
        c.mRestricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
        c.init(pi, null, mMainThread, mResources, mBasePackageName, user);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}","{
    final boolean restricted = (flags & CONTEXT_RESTRICTED) == CONTEXT_RESTRICTED;
    if (packageName.equals(""system"") || packageName.equals(""android"")) {
        return new ContextImpl(this, mMainThread, mPackageInfo, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
    }
    LoadedApk pi = mMainThread.getPackageInfo(packageName, mResources.getCompatibilityInfo(), flags, user.getIdentifier());
    if (pi != null) {
        ContextImpl c = new ContextImpl(this, mMainThread, pi, mActivityToken, user, restricted, mDisplay, mOverrideConfiguration);
        if (c.mResources != null) {
            return c;
        }
    }
    // Should be a better exception.
    throw new PackageManager.NameNotFoundException(""Application package "" + packageName + "" not found"");
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,4",1,The instantiation of ContextImpl and its initialization have been changed. A boolean variable 'restricted' is also introduced in the late version. These modifications are reflected as a change type 1 and 4.,"Returning the ContextImpl object has a different construction and initialization process. This change may lead to different behaviors of the constructed objects, therefore the CI type is 1."
120,"<android.os.Bundle: void readFromParcelInner(Parcel,int)>",19,20,"<android.os.Bundle: void readFromParcelInner(Parcel,int)>","<android.os.Bundle: void readFromParcelInner(Parcel,int)>",0,"{
    int magic = parcel.readInt();
    if (magic != BUNDLE_MAGIC) {
        // noinspection ThrowableInstanceNeverThrown
        throw new IllegalStateException(""Bad magic number for Bundle: 0x"" + Integer.toHexString(magic));
    }
    // Advance within this Parcel
    int offset = parcel.dataPosition();
    parcel.setDataPosition(offset + length);
    Parcel p = Parcel.obtain();
    p.setDataPosition(0);
    p.appendFrom(parcel, offset, length);
    if (DEBUG)
        Log.d(TAG, ""Retrieving "" + Integer.toHexString(System.identityHashCode(this)) + "": "" + length + "" bundle bytes starting at "" + offset);
    p.setDataPosition(0);
    mParcelledData = p;
    mHasFds = p.hasFileDescriptors();
    mFdsKnown = true;
}","{
    if (length == 0) {
        // Empty Bundle or end of data.
        mParcelledData = EMPTY_PARCEL;
        mHasFds = false;
        mFdsKnown = true;
        return;
    }
    int magic = parcel.readInt();
    if (magic != BUNDLE_MAGIC) {
        // noinspection ThrowableInstanceNeverThrown
        throw new IllegalStateException(""Bad magic number for Bundle: 0x"" + Integer.toHexString(magic));
    }
    // Advance within this Parcel
    int offset = parcel.dataPosition();
    parcel.setDataPosition(offset + length);
    Parcel p = Parcel.obtain();
    p.setDataPosition(0);
    p.appendFrom(parcel, offset, length);
    if (DEBUG)
        Log.d(TAG, ""Retrieving "" + Integer.toHexString(System.identityHashCode(this)) + "": "" + length + "" bundle bytes starting at "" + offset);
    p.setDataPosition(0);
    mParcelledData = p;
    mHasFds = p.hasFileDescriptors();
    mFdsKnown = true;
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"3,1",1,"From the early version to the late version, an additional condition is introduced to check if the length is 0, and a new return statement is introduced inside. Therefore, the change type is 3,1.","Because of the new condition and return statement, it leads to potentially different behaviours of the API. If the condition `length == 0` is met, the late version might return earlier than the early version. So, the CI type is 1."
121,<android.print.PrintAttributes.MediaSize: MediaSize asLandscape()>,19,20,<android.print.PrintAttributes.MediaSize: MediaSize asLandscape()>,<android.print.PrintAttributes.MediaSize: MediaSize asLandscape()>,0,"{
    return new MediaSize(mId, mLabel, mPackageName, Math.max(mWidthMils, mHeightMils), Math.min(mWidthMils, mHeightMils), mLabelResId);
}","{
    if (!isPortrait()) {
        return this;
    }
    return new MediaSize(mId, mLabel, mPackageName, Math.max(mWidthMils, mHeightMils), Math.min(mWidthMils, mHeightMils), mLabelResId);
}",1,"/**
 * Returns a new media size in a landscape orientation
 * which is the height is the lesser dimension.
 *
 * @return New instance in landscape orientation.
 */
","/**
 * Returns a new media size instance in a landscape orientation,
 * which is the height is the lesser dimension.
 *
 * @return New instance in landscape orientation if this one
 * is in portrait, otherwise this instance.
 */
",-1,,,-1,-1,-1,-1,-1,-1,"1,3",1,"In the late version, a new control statement ""if (!isPortrait()) return this;"" is introduced before the return statement of the early version. So the code change type is 1,3.","Given the new control statement and its return statement, the API may potentially return a different type and value (return this vs. return a new MediaSize instance). Therefore, the CI type is 1."
122,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,<android.print.PrintManager.PrintDocumentAdapterDelegate: void start()>,0,"{
    synchronized (mLock) {
        // Started or finished - nothing to do.
        if (mStartReqeusted || mFinishRequested) {
            return;
        }
        mStartReqeusted = true;
        doPendingWorkLocked();
    }
}","{
    synchronized (mLock) {
        // Started called or finish called or destroyed - nothing to do.
        if (mStartReqeusted || mFinishRequested || mDestroyed) {
            return;
        }
        mStartReqeusted = true;
        doPendingWorkLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,3,1,"The condition in the if statement has changed from (mStartReqeusted || mFinishRequested) to (mStartReqeusted || mFinishRequested || mDestroyed), so the code change type is 3. ","Given the condition (mStartReqeusted || mFinishRequested || mDestroyed), it might return early depending on the new variable mDestroyed, which was not considered in the earlier version. Therefore the API could potentially return a different value, thus the CI type is 1."
124,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,19,20,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,<android.net.nsd.NsdManager.ServiceHandler: void handleMessage(Message)>,0,"{
    Object listener = getListener(message.arg2);
    boolean listenerRemove = true;
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            break;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            break;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            break;
        case DISCOVER_SERVICES_STARTED:
            String s = ((NsdServiceInfo) message.obj).getServiceType();
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case DISCOVER_SERVICES_FAILED:
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdService(message.arg2).getServiceType(), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case STOP_DISCOVERY_FAILED:
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdService(message.arg2).getServiceType(), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdService(message.arg2).getServiceType());
            break;
        case REGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onRegistrationFailed(getNsdService(message.arg2), message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            // Keep listener until unregister
            listenerRemove = false;
            break;
        case UNREGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onUnregistrationFailed(getNsdService(message.arg2), message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceUnregistered(getNsdService(message.arg2));
            break;
        case RESOLVE_SERVICE_FAILED:
            ((ResolveListener) listener).onResolveFailed(getNsdService(message.arg2), message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
    if (listenerRemove) {
        removeListener(message.arg2);
    }
}","{
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, ""Channel lost"");
            return;
        default:
            break;
    }
    Object listener = getListener(message.arg2);
    if (listener == null) {
        Log.d(TAG, ""Stale key "" + message.arg2);
        return;
    }
    boolean listenerRemove = true;
    NsdServiceInfo ns = getNsdService(message.arg2);
    switch(message.what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case DISCOVER_SERVICES_FAILED:
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            // Keep listener until stop discovery
            listenerRemove = false;
            break;
        case STOP_DISCOVERY_FAILED:
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            // Keep listener until unregister
            listenerRemove = false;
            break;
        case UNREGISTER_SERVICE_FAILED:
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, ""Ignored "" + message);
            break;
    }
    if (listenerRemove) {
        removeListener(message.arg2);
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,4,5","1,2","The sequence of method calls, the variable assignments, and the control statements (such as 'try', 'catch', 'if', and 'for') are varied in the early and late implementations. Return statements have been added in the 'switch' block. A new dependent method (getNsdServiceInfoType) is called in the late version. Therefore, the code change types include 3, 4, and 5.","The early version and late version might behave differently due to the removal of exception handling, the addition of return statements, and the change in dependent APIs. The method might return at different points because of the newly added return statements in the 'switch' block. Also, the late version introduces a NULL check for the listener which might cause different behaviours if the listener were to be NULL. Therefore, Compatibility Issues 1 and 2 could exist."
125,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",19,20,"<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>","<android.print.PrintManager: PrintJob print(String,PrintDocumentAdapter,PrintAttributes)>",0,"{
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""priintJobName cannot be empty"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate(documentAdapter, mContext.getMainLooper());
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error creating a print job"", re);
    }
    return null;
}","{
    if (!(mContext instanceof Activity)) {
        throw new IllegalStateException(""Can print only from an activity"");
    }
    if (TextUtils.isEmpty(printJobName)) {
        throw new IllegalArgumentException(""printJobName cannot be empty"");
    }
    if (documentAdapter == null) {
        throw new IllegalArgumentException(""documentAdapter cannot be null"");
    }
    PrintDocumentAdapterDelegate delegate = new PrintDocumentAdapterDelegate((Activity) mContext, documentAdapter);
    try {
        Bundle result = mService.print(printJobName, delegate, attributes, mContext.getPackageName(), mAppId, mUserId);
        if (result != null) {
            PrintJobInfo printJob = result.getParcelable(EXTRA_PRINT_JOB);
            IntentSender intent = result.getParcelable(EXTRA_PRINT_DIALOG_INTENT);
            if (printJob == null || intent == null) {
                return null;
            }
            try {
                mContext.startIntentSender(intent, null, 0, 0, 0);
                return new PrintJob(printJob, this);
            } catch (SendIntentException sie) {
                Log.e(LOG_TAG, ""Couldn't start print job config activity."", sie);
            }
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, ""Error creating a print job"", re);
    }
    return null;
}",1,"/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 *
 * @param printJobName A name for the new print job.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes.
 * @return The created print job on success or null on failure.
 * @see PrintJob
 */
","/**
 * Creates a print job for printing a {@link PrintDocumentAdapter} with
 * default print attributes.
 * <p>
 * Calling this method brings the print UI allowing the user to customize
 * the print job and returns a {@link PrintJob} object without waiting for the
 * user to customize or confirm the print job. The returned print job instance
 * is in a {@link PrintJobInfo#STATE_CREATED created} state.
 * <p>
 * This method can be called only from an {@link Activity}. The rationale is that
 * printing from a service will create an inconsistent user experience as the print
 * UI would appear without any context.
 * </p>
 * <p>
 * Also the passed in {@link PrintDocumentAdapter} will be considered invalid if
 * your activity is finished. The rationale is that once the activity that
 * initiated printing is finished, the provided adapter may be in an inconsistent
 * state as it may depend on the UI presented by the activity.
 * </p>
 * <p>
 * The default print attributes are a hint to the system how the data is to
 * be printed. For example, a photo editor may look at the photo aspect ratio
 * to determine the default orientation and provide a hint whether the printing
 * should be in portrait or landscape. The system will do a best effort to
 * selected the hinted options in the print dialog, given the current printer
 * supports them.
 * </p>
 *
 * @param printJobName A name for the new print job which is shown to the user.
 * @param documentAdapter An adapter that emits the document to print.
 * @param attributes The default print job attributes or <code>null</code>.
 * @return The created print job on success or null on failure.
 * @throws IllegalStateException If not called from an {@link Activity}.
 * @throws IllegalArgumentException If the print job name is empty or the
 * document adapter is null.
 *
 * @see PrintJob
 */
",-1,,,-1,-1,-1,-1,-1,-1,"2,3,4","1,2","The change includes introduction of additional exceptions, change in control dependencies, as well as changes in the conditions for the thrown exceptions, so the code change type is 2,3,4.","As additional exceptions are thrown and control dependencies have changed. This could potentially lead to a different exception being thrown or a different return value. Thus, the CI type is 1,2."
129,<android.printservice.PrintJob: boolean hasAdvancedOption(String)>,19,20,<android.printservice.PrintJob: boolean hasAdvancedOption(String)>,<android.printservice.PrintJob: boolean hasAdvancedOption(String)>,0,"{
    PrintService.throwIfNotCalledOnMainThread();
    return false;
}","{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().hasAdvancedOption(key);
}",1,"/**
 * Gets whether this job has a given advanced (printer specific) print
 * option.
 *
 * @param key The option key.
 * @return Whether the option is present.
 */
","/**
 * Gets whether this job has a given advanced (printer specific) print
 * option.
 *
 * @param key The option key.
 * @return Whether the option is present.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed. In the early version, it always returns 'false', while in the later version, it returns the result of ""getInfo().hasAdvancedOption(key)"", so the change type is 1.","Due to the change of the return statement, the API potentially return different values, so the CI type is 1."
130,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",19,20,"<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>","<android.os.Parcel: void writeArrayMapInternal(ArrayMap<String, Object>)>",0,"{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "": key=0x"" + (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
        writeValue(val.keyAt(i));
        writeValue(val.valueAt(i));
    }
}","{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException(""here"");
        here.fillInStackTrace();
        Log.d(TAG, ""Writing "" + N + "" ArrayMap entries"", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeValue(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, ""  Write #"" + i + "" "" + (dataPosition() - startPos) + "" bytes: key=0x"" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + "" "" + val.keyAt(i));
    }
}",1,"/* package */
","/* package */
",-1,,,-1,-1,-1,-1,-1,-1,4,0,"The only difference comes in debug logs which does not affect the main functionality of the API, so the code change type is 4.","As only the debug logs statement has been changed, no potential different behavior will be caused by this change, thus no Compatibility Issue exists, so the CI type is 0."
132,<android.view.View: void setBackgroundDrawable(Drawable)>,19,20,<android.view.View: void setBackgroundDrawable(Drawable)>,<android.view.View: void setBackgroundDrawable(Drawable)>,0,"{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}","{
    computeOpaqueFlags();
    if (background == mBackground) {
        return;
    }
    boolean requestLayout = false;
    mBackgroundResource = 0;
    /*
         * Regardless of whether we're setting a new background or not, we want
         * to clear the previous drawable.
         */
    if (mBackground != null) {
        mBackground.setCallback(null);
        unscheduleDrawable(mBackground);
    }
    if (background != null) {
        Rect padding = sThreadLocal.get();
        if (padding == null) {
            padding = new Rect();
            sThreadLocal.set(padding);
        }
        resetResolvedDrawables();
        background.setLayoutDirection(getLayoutDirection());
        if (background.getPadding(padding)) {
            resetResolvedPadding();
            switch(background.getLayoutDirection()) {
                case LAYOUT_DIRECTION_RTL:
                    mUserPaddingLeftInitial = padding.right;
                    mUserPaddingRightInitial = padding.left;
                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);
                    break;
                case LAYOUT_DIRECTION_LTR:
                default:
                    mUserPaddingLeftInitial = padding.left;
                    mUserPaddingRightInitial = padding.right;
                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);
            }
            mLeftPaddingDefined = false;
            mRightPaddingDefined = false;
        }
        // if it has a different minimum size, we should layout again
        if (mBackground == null || mBackground.getMinimumHeight() != background.getMinimumHeight() || mBackground.getMinimumWidth() != background.getMinimumWidth()) {
            requestLayout = true;
        }
        background.setCallback(this);
        if (background.isStateful()) {
            background.setState(getDrawableState());
        }
        background.setVisible(getVisibility() == VISIBLE, false);
        mBackground = background;
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {
            mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            mPrivateFlags |= PFLAG_ONLY_DRAWS_BACKGROUND;
            requestLayout = true;
        }
    } else {
        /* Remove the background */
        mBackground = null;
        if ((mPrivateFlags & PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
            /*
                 * This view ONLY drew the background before and we're removing
                 * the background, so now it won't draw anything
                 * (hence we SKIP_DRAW)
                 */
            mPrivateFlags &= ~PFLAG_ONLY_DRAWS_BACKGROUND;
            mPrivateFlags |= PFLAG_SKIP_DRAW;
        }
        /*
             * When the background is set, we try to apply its padding to this
             * View. When the background is removed, we don't touch this View's
             * padding. This is noted in the Javadocs. Hence, we don't need to
             * requestLayout(), the invalidate() below is sufficient.
             */
        // The old background's minimum size could have affected this
        // View's layout, so let's requestLayout
        requestLayout = true;
    }
    computeOpaqueFlags();
    if (requestLayout) {
        requestLayout();
    }
    mBackgroundSizeChanged = true;
    invalidate(true);
}",1,"/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
","/**
 * @deprecated use {@link #setBackground(Drawable)} instead
 */
",-1,[@Deprecated],[@Deprecated],-1,-1,-1,-1,-1,-1,4,0,"Two statements are added, ""mLeftPaddingDefined = false;"" and ""mRightPaddingDefined = false;"", so the code change type is 4.","The added code is assigning ""false"" to two boolean variables, and it does not have an impact on the method's return value or exception handling, hence there is no CI."
133,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteCancelled()>,0,"{
    synchronized (mLock) {
        clearLocked();
    }
}","{
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        clearLocked();
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1,3",1,"A new return statement has been introduced under a new 'if' condition 'if (mDestroyed)', so the code change type is 1,3.","Because a new return statement has been introduced, the method could potentially return at a different place, which can result in different behaviors when the API is invoked. Hence, the CI type is 1."
134,<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: boolean scanStarted()>,19,20,<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: boolean scanStarted()>,<android.bluetooth.BluetoothAdapter.GattCallbackWrapper: boolean scanStarted()>,0,"{
    boolean started = false;
    synchronized (this) {
        if (mLeHandle == -1)
            return false;
        int count = 0;
        // wait for callback registration and LE scan to start
        while (mLeHandle == 0 && count < LE_CALLBACK_REG_WAIT_COUNT) {
            try {
                wait(LE_CALLBACK_REG_TIMEOUT);
            } catch (InterruptedException e) {
                Log.e(TAG, ""Callback reg wait interrupted: "" + e);
            }
            count++;
        }
        started = (mLeHandle > 0);
    }
    return started;
}","{
    return waitForRegisteration(LE_CALLBACK_REG_WAIT_COUNT);
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,4,5",1,"The internal logic of method 'scanStarted()' has been entirely replaced by calling method 'waitForRegisteration()' to simplify the logic. So the change type is 1,4,5.","The return value is potentially different between 'waitForRegisteration(LE_CALLBACK_REG_WAIT_COUNT)' and original implementation, thus the CI type is 1."
135,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyWriteResultCallback: void onWriteFailed(CharSequence)>,0,"{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onWriteFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFailed"", re);
        }
    }
}","{
    final IWriteResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onWriteFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onWriteFailed"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"3,1",1,"In the late version, a new conditional statement 'if (mDestroyed)' and a new return statement have been introduced within the synchronized block, so the code change type is 3 and 1.","The newly added 'return' statement within the conditional block can change the behavior of the API, making the API potentially return different values, so the CI type is 1."
136,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,19,20,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,<android.print.PrintManager.PrintDocumentAdapterDelegate.MyLayoutResultCallback: void onLayoutFailed(CharSequence)>,0,"{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFailed"", re);
        }
    }
}","{
    final ILayoutResultCallback callback;
    synchronized (mLock) {
        if (mDestroyed) {
            Log.e(LOG_TAG, ""PrintDocumentAdapter is destroyed. Did you "" + ""finish the printing activity before print completion?"");
            return;
        }
        callback = mCallback;
        clearLocked();
    }
    if (callback != null) {
        try {
            callback.onLayoutFailed(error, mSequence);
        } catch (RemoteException re) {
            Log.e(LOG_TAG, ""Error calling onLayoutFailed"", re);
        }
    }
}",1,,,-1,[@Override],[@Override],-1,-1,-1,-1,-1,-1,"1, 3",1,"A new control dependency 'if (mDestroyed)' and a new return statement 'return' has been introduced, therefore the change type is 1,3.","The new return statement within the control dependency 'if(mDestroyed)' in the late version could potentially cause the method to end prematurely without invoking `callback.onLayoutFailed(error, mSequence)`. This leads to different behaviours, thus the CI type is 1."
137,<android.printservice.PrintJob: String getAdvancedStringOption(String)>,19,20,<android.printservice.PrintJob: String getAdvancedStringOption(String)>,<android.printservice.PrintJob: String getAdvancedStringOption(String)>,0,"{
    PrintService.throwIfNotCalledOnMainThread();
    return null;
}","{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedStringOption(key);
}",1,"/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */
","/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return statement has changed from returning null to return getInfo().getAdvancedStringOption(key), so the code change type is 1.","The change of return statement will make API potentially return a different value, so the CI type is 1."
141,<android.os.MessageQueue: boolean isIdling()>,19,20,<android.os.MessageQueue: boolean isIdling()>,<android.os.MessageQueue: boolean isIdling()>,0,"{
    synchronized (this) {
        // We can assume mPtr != 0 when mQuitting is false.
        return !mQuitting && nativeIsIdling(mPtr);
    }
}","{
    synchronized (this) {
        return isIdlingLocked();
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"1,5",1,The native function call in the return statement is replaced with another function call. This corresponds to change types 1 (Return statement changed) and 5 (Dependent API changed).,"This change potentially causes the function's return value to change, which satisfies the definition of a Compatibility Issue of type 1 (Compatibility Issue caused by potential different return values or types)."
143,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",19,20,"<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>","<android.app.ActivityThread.ApplicationThread: void dumpProvider(FileDescriptor,IBinder,String[])>",0,"{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = providertoken;
        data.args = args;
        queueOrSendMessage(H.DUMP_PROVIDER, data);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpProvider failed"", e);
    }
}","{
    DumpComponentInfo data = new DumpComponentInfo();
    try {
        data.fd = ParcelFileDescriptor.dup(fd);
        data.token = providertoken;
        data.args = args;
        sendMessage(H.DUMP_PROVIDER, data, 0, 0, true);
    } catch (IOException e) {
        Slog.w(TAG, ""dumpProvider failed"", e);
    }
}",1,,,-1,,,-1,-1,-1,-1,-1,-1,"4,5",0,"The function `queueOrSendMessage()` in the early implementation has been replaced with `sendMessage()` in the late implementation. The parameters of these functions do not align, hence qualifies as a 'Dependent API changed'. Overall, the API changed type is ""Other statement change"" and ""Dependent API changed"".","Despite the changes in the function calls from `queueOrSendMessage()` to `sendMessage()`, the input and output behavior of the API overall remains the same. There is no potential to have different return types/values or throw different exceptions between the two versions, hence, no Compatibility Issue exists."
144,<android.print.PrinterCapabilitiesInfo: List<MediaSize> getMediaSizes()>,19,20,<android.print.PrinterCapabilitiesInfo: List<MediaSize> getMediaSizes()>,<android.print.PrinterCapabilitiesInfo: List<MediaSize> getMediaSizes()>,0,"{
    return mMediaSizes;
}","{
    return Collections.unmodifiableList(mMediaSizes);
}",1,"/**
 * Gets the supported media sizes.
 *
 * @return The media sizes.
 */
","/**
 * Gets the supported media sizes.
 *
 * @return The media sizes.
 */
",-1,,,-1,-1,-1,-1,-1,-1,1,1,"The return value of the API has changed from returning the original list to returning an unmodifiable version of the list, so the change type is 1.","As the late version returns a read-only (unmodifiable) list, the operations applied on the returned values from the API in the early version and late versions can cause different behaviours, leading to compatibility issue, and thus the CI type is 1."
